872
#method_before
private static void generateCodeEntry(YangNode curNode, String codeGenDir) throws IOException {
    if (curNode instanceof JavaCodeGenerator) {
        ((JavaCodeGenerator) curNode).generateCodeEntry(codeGenDir);
    } else {
        throw new TranslatorException("Gnenerated data model node cannot be translated to target language code");
    }
}
#method_after
private static void generateCodeEntry(YangNode curNode, String codeGenDir) throws IOException {
    if (curNode instanceof JavaCodeGenerator) {
        ((JavaCodeGenerator) curNode).generateCodeEntry(codeGenDir);
    } else {
        throw new TranslatorException("Generated data model node cannot be translated to target language code");
    }
}
#end_block

#method_before
private static void generateCodeExit(YangNode curNode) throws IOException {
    if (curNode instanceof JavaCodeGenerator) {
        ((JavaCodeGenerator) curNode).generateCodeExit();
    } else {
        throw new TranslatorException("Gnenerated data model node cannot be translated to target language code");
    }
}
#method_after
private static void generateCodeExit(YangNode curNode) throws IOException {
    if (curNode instanceof JavaCodeGenerator) {
        ((JavaCodeGenerator) curNode).generateCodeExit();
    } else {
        throw new TranslatorException("Generated data model node cannot be translated to target language code");
    }
}
#end_block

#method_before
private static void free(YangNode node) throws DataModelException {
    YangNode parent = node.getParent();
    if (node.getNextSibling() != null) {
        parent.setChild(null);
        parent.setChild(node.getNextSibling());
        node = null;
    } else if (node.getPreviousSibling() != null) {
        parent.setChild(null);
        parent.setChild(node.getPreviousSibling());
        node = null;
    } else {
        parent.setChild(null);
        node = null;
    }
}
#method_after
private static void free(YangNode node) throws DataModelException {
    YangNode parent = node.getParent();
    parent.setChild(null);
    if (node.getNextSibling() != null) {
        parent.setChild(node.getNextSibling());
    } else if (node.getPreviousSibling() != null) {
        parent.setChild(node.getPreviousSibling());
    }
    node = null;
}
#end_block

#method_before
@Test
public void builderClassGenerationTest() {
    String builderClassJavaDoc = getJavaDoc(BUILDER_CLASS, "testGeneration1", false);
    assertThat(true, is(builderClassJavaDoc.contains("Reperesents the builder implementation of") && builderClassJavaDoc.contains(" */\n")));
}
#method_after
@Test
public void builderClassGenerationTest() {
    String builderClassJavaDoc = getJavaDoc(BUILDER_CLASS, TEST_NAME, false);
    assertThat(true, is(builderClassJavaDoc.contains("Reperesents the builder implementation of") && builderClassJavaDoc.contains(END_STRING)));
}
#end_block

#method_before
@Test
public void builderInterfaceGenerationTest() {
    String builderInterfaceJavaDoc = getJavaDoc(BUILDER_INTERFACE, "testGeneration1", false);
    assertThat(true, is(builderInterfaceJavaDoc.contains("Builder for") && builderInterfaceJavaDoc.contains(" */\n")));
}
#method_after
@Test
public void builderInterfaceGenerationTest() {
    String builderInterfaceJavaDoc = getJavaDoc(BUILDER_INTERFACE, TEST_NAME, false);
    assertThat(true, is(builderInterfaceJavaDoc.contains("Builder for") && builderInterfaceJavaDoc.contains(END_STRING)));
}
#end_block

#method_before
@Test
public void buildGenerationTest() {
    String buildDoc = getJavaDoc(BUILD_METHOD, "testGeneration1", false);
    assertThat(true, is(buildDoc.contains("Builds object of") && buildDoc.contains(" */\n")));
}
#method_after
@Test
public void buildGenerationTest() {
    String buildDoc = getJavaDoc(BUILD_METHOD, TEST_NAME, false);
    assertThat(true, is(buildDoc.contains("Builds object of") && buildDoc.contains(END_STRING)));
}
#end_block

#method_before
@Test
public void constructorGenerationTest() {
    String constructorDoc = getJavaDoc(CONSTRUCTOR, "testGeneration1", false);
    assertThat(true, is(constructorDoc.contains("Construct object of") && constructorDoc.contains("builder object of") && constructorDoc.contains("@param") && constructorDoc.contains("*/\n")));
}
#method_after
@Test
public void constructorGenerationTest() {
    String constructorDoc = getJavaDoc(CONSTRUCTOR, TEST_NAME, false);
    assertThat(true, is(constructorDoc.contains("Creates an instance of ") && constructorDoc.contains("builder object of") && constructorDoc.contains("@param") && constructorDoc.contains("*/\n")));
}
#end_block

#method_before
@Test
public void defaultConstructorGenerationTest() {
    String defaultConstructorDoc = getJavaDoc(DEFAULT_CONSTRUCTOR, "testGeneration1", false);
    assertThat(true, is(defaultConstructorDoc.contains("Construct object of ") && defaultConstructorDoc.contains(" */\n")));
}
#method_after
@Test
public void defaultConstructorGenerationTest() {
    String defaultConstructorDoc = getJavaDoc(DEFAULT_CONSTRUCTOR, TEST_NAME, false);
    assertThat(true, is(defaultConstructorDoc.contains("Creates an instance of ") && defaultConstructorDoc.contains(END_STRING)));
}
#end_block

#method_before
@Test
public void getterGenerationTest() {
    String getterJavaDoc = getJavaDoc(GETTER_METHOD, "testGeneration1", false);
    assertThat(true, is(getterJavaDoc.contains("Returns the attribute") && getterJavaDoc.contains(" */\n")));
}
#method_after
@Test
public void getterGenerationTest() {
    String getterJavaDoc = getJavaDoc(GETTER_METHOD, TEST_NAME, false);
    assertThat(true, is(getterJavaDoc.contains("Returns the attribute") && getterJavaDoc.contains(END_STRING)));
}
#end_block

#method_before
@Test
public void implClassGenerationTest() {
    String implClassJavaDoc = getJavaDoc(IMPL_CLASS, "testGeneration1", false);
    assertThat(true, is(implClassJavaDoc.contains("Reperesents the implementation of") && implClassJavaDoc.contains(" */\n")));
}
#method_after
@Test
public void implClassGenerationTest() {
    String implClassJavaDoc = getJavaDoc(IMPL_CLASS, TEST_NAME, false);
    assertThat(true, is(implClassJavaDoc.contains("Reperesents the implementation of") && implClassJavaDoc.contains(END_STRING)));
}
#end_block

#method_before
@Test
public void interfaceGenerationTest() {
    String interfaceJavaDoc = getJavaDoc(INTERFACE, "testGeneration1", false);
    assertThat(true, is(interfaceJavaDoc.contains("Abstraction of an entity which Reperesents the functionalities of") && interfaceJavaDoc.contains(" */\n")));
}
#method_after
@Test
public void interfaceGenerationTest() {
    String interfaceJavaDoc = getJavaDoc(INTERFACE, TEST_NAME, false);
    assertThat(true, is(interfaceJavaDoc.contains("Abstraction of an entity which Reperesents the functionalities of") && interfaceJavaDoc.contains(END_STRING)));
}
#end_block

#method_before
@Test
public void packageInfoGenerationTest() {
    String packageInfo = getJavaDoc(PACKAGE_INFO, "testGeneration1", false);
    assertThat(true, is(packageInfo.contains("Implementation of YANG file") && packageInfo.contains(" */\n")));
}
#method_after
@Test
public void packageInfoGenerationTest() {
    String packageInfo = getJavaDoc(PACKAGE_INFO, TEST_NAME, false);
    assertThat(true, is(packageInfo.contains("Implementation of YANG file") && packageInfo.contains(END_STRING)));
}
#end_block

#method_before
@Test
public void setterGenerationTest() {
    String setterJavaDoc = getJavaDoc(SETTER_METHOD, "testGeneration1", false);
    assertThat(true, is(setterJavaDoc.contains("Returns the builder object of") && setterJavaDoc.contains(" */\n")));
}
#method_after
@Test
public void setterGenerationTest() {
    String setterJavaDoc = getJavaDoc(SETTER_METHOD, TEST_NAME, false);
    assertThat(true, is(setterJavaDoc.contains("Returns the builder object of") && setterJavaDoc.contains(END_STRING)));
}
#end_block

#method_before
@Test
public void typeDefSetterGenerationTest() {
    String typeDefSetter = getJavaDoc(TYPE_DEF_SETTER_METHOD, "testGeneration1", false);
    assertThat(true, is(typeDefSetter.contains("Sets the value of") && typeDefSetter.contains(" */\n")));
}
#method_after
@Test
public void typeDefSetterGenerationTest() {
    String typeDefSetter = getJavaDoc(TYPE_DEF_SETTER_METHOD, TEST_NAME, false);
    assertThat(true, is(typeDefSetter.contains("Sets the value of") && typeDefSetter.contains(END_STRING)));
}
#end_block

#method_before
public static String getYangRevisionStr(String date) throws TranslatorException {
    String[] revisionArr = date.split(HYPHEN);
    String rev = REVISION_PREFIX;
    rev = rev + revisionArr[INDEX_ZERO];
    if (Integer.parseInt(revisionArr[INDEX_ONE]) <= MAX_MONTHS && Integer.parseInt(revisionArr[INDEX_TWO]) <= MAX_DAYS) {
        for (int i = INDEX_ONE; i < revisionArr.length; i++) {
            Integer val = Integer.parseInt(revisionArr[i]);
            if (val < 10) {
                rev = rev + "0";
            }
            rev = rev + val;
        }
        return rev;
    } else {
        throw new TranslatorException("Date in revision is not proper: " + date);
    }
}
#method_after
public static String getYangRevisionStr(String date) throws TranslatorException {
    String[] revisionArr = date.split(HYPHEN);
    String rev = REVISION_PREFIX;
    rev = rev + revisionArr[INDEX_ZERO];
    if (Integer.parseInt(revisionArr[INDEX_ONE]) <= MAX_MONTHS && Integer.parseInt(revisionArr[INDEX_TWO]) <= MAX_DAYS) {
        for (int i = INDEX_ONE; i < revisionArr.length; i++) {
            Integer val = Integer.parseInt(revisionArr[i]);
            if (val < VALUE_CHECK) {
                rev = rev + ZERO;
            }
            rev = rev + val;
        }
        return rev;
    } else {
        throw new TranslatorException("Date in revision is not proper: " + date);
    }
}
#end_block

#method_before
private List<Intent> compile(OpticalCircuitIntent intent, ConnectPoint src, ConnectPoint dst, Optional<OpticalConnectivityIntent> existingConnectivity, List<Resource> resources, boolean supportsMultiplexing) {
    OpticalConnectivityIntent connectivityIntent;
    List<Resource> required;
    if (existingConnectivity.isPresent()) {
        connectivityIntent = existingConnectivity.get();
        required = resources;
    } else {
        // Find OCh ports with available resources
        Pair<OchPort, OchPort> ochPorts = findPorts(intent.getSrc(), intent.getDst(), intent.getSignalType());
        if (ochPorts == null) {
            throw new IntentCompilationException("Unable to find suitable OCH ports for intent " + intent);
        }
        ConnectPoint srcCP = new ConnectPoint(src.elementId(), ochPorts.getLeft().number());
        ConnectPoint dstCP = new ConnectPoint(dst.elementId(), ochPorts.getRight().number());
        // Create optical connectivity intent
        connectivityIntent = OpticalConnectivityIntent.builder().appId(appId).src(srcCP).dst(dstCP).signalType(ochPorts.getLeft().signalType()).bidirectional(intent.isBidirectional()).build();
        if (!supportsMultiplexing) {
            required = resources;
        } else {
            List<Resource> slots = availableSlotResources(srcCP, dstCP, intent.getSignalType());
            if (slots.isEmpty()) {
                throw new IntentCompilationException("Unable to find Tributary Slots for intent " + intent);
            }
            required = ImmutableList.<Resource>builder().addAll(resources).addAll(slots).build();
        }
    }
    if (resourceService.allocate(intent.id(), required).isEmpty()) {
        throw new IntentCompilationException("Unable to allocate resources for intent " + intent + ": resources=" + required);
    }
    intentService.submit(connectivityIntent);
    // Save circuit to connectivity intent mapping
    intentSetMultimap.allocateMapping(connectivityIntent.id(), intent.id());
    FlowRuleIntent circuitIntent = createFlowRule(intent, connectivityIntent, required.stream().flatMap(x -> Tools.stream(x.valueAs(TributarySlot.class))).collect(Collectors.toSet()));
    return ImmutableList.of(circuitIntent);
}
#method_after
@Override
public List<Intent> compile(OpticalCircuitIntent intent, List<Intent> installable) {
    // Check if ports are OduClt ports
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    Port srcPort = deviceService.getPort(src.deviceId(), src.port());
    Port dstPort = deviceService.getPort(dst.deviceId(), dst.port());
    checkArgument(srcPort instanceof OduCltPort);
    checkArgument(dstPort instanceof OduCltPort);
    log.debug("Compiling optical circuit intent between {} and {}", src, dst);
    // Release of intent resources here is only a temporary solution for handling the
    // case of recompiling due to intent restoration (when intent state is FAILED).
    // TODO: try to release intent resources in IntentManager.
    resourceService.release(intent.id());
    // Check OduClt ports availability
    Resource srcPortResource = Resources.discrete(src.deviceId(), src.port()).resource();
    Resource dstPortResource = Resources.discrete(dst.deviceId(), dst.port()).resource();
    // If ports are not available, compilation fails
    if (!Stream.of(srcPortResource, dstPortResource).allMatch(resourceService::isAvailable)) {
        throw new IntentCompilationException("Ports for the intent are not available. Intent: " + intent);
    }
    List<Resource> ports = ImmutableList.of(srcPortResource, dstPortResource);
    // Check if both devices support multiplexing (usage of TributarySlots)
    boolean multiplexingSupported = isMultiplexingSupported(intent.getSrc()) && isMultiplexingSupported(intent.getDst());
    OpticalConnectivityIntent connIntent = findOpticalConnectivityIntent(intent.getSrc(), intent.getDst(), intent.getSignalType(), multiplexingSupported);
    if (connIntent != null && !multiplexingSupported) {
        return compile(intent, src, dst, Optional.of(connIntent), ports, false);
    }
    // Create optical connectivity intent if needed - no optical intent or not enough slots available
    if (connIntent == null) {
        return compile(intent, src, dst, Optional.empty(), ports, multiplexingSupported);
    }
    List<Resource> slots = availableSlotResources(connIntent.getSrc(), connIntent.getDst(), intent.getSignalType());
    if (slots.isEmpty()) {
        return compile(intent, src, dst, Optional.empty(), ports, true);
    }
    return compile(intent, src, dst, Optional.of(connIntent), ImmutableList.<Resource>builder().addAll(ports).addAll(slots).build(), false);
}
#end_block

#method_before
@Test
public void test1GbeMultiplexOverOdu2() {
    // Use driver with TributarySlotQuery Behaviour
    sut.driverService = new MockDriverServiceWithTs();
    ConnectPoint oduCltSrcCP = new ConnectPoint(device1.id(), D1P1.number());
    ConnectPoint oduCltDstCP = new ConnectPoint(device2.id(), D2P1.number());
    ConnectPoint ochSrcCP = new ConnectPoint(device1.id(), D1P2.number());
    ConnectPoint ochDstCP = new ConnectPoint(device2.id(), D2P2.number());
    intent = OpticalCircuitIntent.builder().appId(APP_ID).key(KEY1).src(oduCltSrcCP).dst(oduCltDstCP).signalType(D1P1.signalType()).bidirectional(false).build();
    sut.activate(null);
    List<Intent> compiled = sut.compile(intent, Collections.emptyList(), Collections.emptySet());
    assertThat(compiled, hasSize(1));
    Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
    FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(device1.id())).findFirst().get();
    // validate SRC selector
    TrafficSelector.Builder selectorBuilder1 = DefaultTrafficSelector.builder();
    selectorBuilder1.matchInPort(oduCltSrcCP.port());
    selectorBuilder1.add(Criteria.matchOduSignalType(OduSignalType.ODU0));
    assertThat(rule1.selector(), is(selectorBuilder1.build()));
    // validate SRC treatment  (with OduSignalId, where 1 TributarySlot is used)
    TrafficTreatment.Builder treatmentBuilder1 = DefaultTrafficTreatment.builder();
    Set<TributarySlot> slots = new HashSet<>();
    slots.add(TributarySlot.of(1));
    OduSignalId oduSignalId = OduSignalUtils.buildOduSignalId(D1P2.signalType(), slots);
    treatmentBuilder1.add(Instructions.modL1OduSignalId(oduSignalId));
    treatmentBuilder1.setOutput(ochSrcCP.port());
    assertThat(rule1.treatment(), is(treatmentBuilder1.build()));
    FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(device2.id())).findFirst().get();
    // validate DST selector (with OduSignalId, where the same TributarySlot is used)
    TrafficSelector.Builder selectorBuilder2 = DefaultTrafficSelector.builder();
    selectorBuilder2.matchInPort(ochDstCP.port());
    selectorBuilder2.add(Criteria.matchOduSignalType(OduSignalType.ODU0));
    selectorBuilder2.add(Criteria.matchOduSignalId(oduSignalId));
    assertThat(rule2.selector(), is(selectorBuilder2.build()));
    // validate DST treatment
    assertThat(rule2.treatment(), is(DefaultTrafficTreatment.builder().setOutput(oduCltDstCP.port()).build()));
    rules.forEach(rule -> assertEquals("FlowRule priority is incorrect", intent.priority(), rule.priority()));
    sut.deactivate();
}
#method_after
@Test
public void test1GbeMultiplexOverOdu2() {
    // Use driver with TributarySlotQuery Behaviour
    sut.driverService = new MockDriverServiceWithTs();
    ConnectPoint oduCltSrcCP = new ConnectPoint(device1.id(), D1P1.number());
    ConnectPoint oduCltDstCP = new ConnectPoint(device2.id(), D2P1.number());
    ConnectPoint ochSrcCP = new ConnectPoint(device1.id(), D1P2.number());
    ConnectPoint ochDstCP = new ConnectPoint(device2.id(), D2P2.number());
    intent = OpticalCircuitIntent.builder().appId(APP_ID).key(KEY1).src(oduCltSrcCP).dst(oduCltDstCP).signalType(D1P1.signalType()).bidirectional(false).build();
    sut.activate(null);
    List<Intent> compiled = sut.compile(intent, Collections.emptyList());
    assertThat(compiled, hasSize(1));
    Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
    FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(device1.id())).findFirst().get();
    // validate SRC selector
    TrafficSelector.Builder selectorBuilder1 = DefaultTrafficSelector.builder();
    selectorBuilder1.matchInPort(oduCltSrcCP.port());
    selectorBuilder1.add(Criteria.matchOduSignalType(OduSignalType.ODU0));
    assertThat(rule1.selector(), is(selectorBuilder1.build()));
    // validate SRC treatment  (with OduSignalId, where 1 TributarySlot is used)
    TrafficTreatment.Builder treatmentBuilder1 = DefaultTrafficTreatment.builder();
    Set<TributarySlot> slots = new HashSet<>();
    slots.add(TributarySlot.of(1));
    OduSignalId oduSignalId = OduSignalUtils.buildOduSignalId(D1P2.signalType(), slots);
    treatmentBuilder1.add(Instructions.modL1OduSignalId(oduSignalId));
    treatmentBuilder1.setOutput(ochSrcCP.port());
    assertThat(rule1.treatment(), is(treatmentBuilder1.build()));
    FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(device2.id())).findFirst().get();
    // validate DST selector (with OduSignalId, where the same TributarySlot is used)
    TrafficSelector.Builder selectorBuilder2 = DefaultTrafficSelector.builder();
    selectorBuilder2.matchInPort(ochDstCP.port());
    selectorBuilder2.add(Criteria.matchOduSignalType(OduSignalType.ODU0));
    selectorBuilder2.add(Criteria.matchOduSignalId(oduSignalId));
    assertThat(rule2.selector(), is(selectorBuilder2.build()));
    // validate DST treatment
    assertThat(rule2.treatment(), is(DefaultTrafficTreatment.builder().setOutput(oduCltDstCP.port()).build()));
    rules.forEach(rule -> assertEquals("FlowRule priority is incorrect", intent.priority(), rule.priority()));
    sut.deactivate();
}
#end_block

#method_before
@Test
public void test10GbeMultiplexOverOdu2() {
    // Use driver with TributarySlotQuery Behaviour
    sut.driverService = new MockDriverServiceWithTs();
    ConnectPoint oduCltSrcCP = new ConnectPoint(device1.id(), D1P3.number());
    ConnectPoint oduCltDstCP = new ConnectPoint(device2.id(), D2P3.number());
    ConnectPoint ochSrcCP = new ConnectPoint(device1.id(), D1P2.number());
    ConnectPoint ochDstCP = new ConnectPoint(device2.id(), D2P2.number());
    intent = OpticalCircuitIntent.builder().appId(APP_ID).key(KEY1).src(oduCltSrcCP).dst(oduCltDstCP).signalType(D1P3.signalType()).bidirectional(false).build();
    sut.activate(null);
    List<Intent> compiled = sut.compile(intent, Collections.emptyList(), Collections.emptySet());
    assertThat(compiled, hasSize(1));
    Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
    FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(device1.id())).findFirst().get();
    // validate SRC selector
    TrafficSelector.Builder selectorBuilder1 = DefaultTrafficSelector.builder();
    selectorBuilder1.matchInPort(oduCltSrcCP.port());
    selectorBuilder1.add(Criteria.matchOduSignalType(OduSignalType.ODU2));
    assertThat(rule1.selector(), is(selectorBuilder1.build()));
    // validate SRC treatment (without OduSignalId, i.e. All TributarySlots are used)
    TrafficTreatment.Builder treatmentBuilder1 = DefaultTrafficTreatment.builder();
    treatmentBuilder1.setOutput(ochSrcCP.port());
    assertThat(rule1.treatment(), is(treatmentBuilder1.build()));
    FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(device2.id())).findFirst().get();
    // validate DST selector (without OduSignalId, i.e. All TributarySlots are used)
    TrafficSelector.Builder selectorBuilder2 = DefaultTrafficSelector.builder();
    selectorBuilder2.matchInPort(ochDstCP.port());
    selectorBuilder2.add(Criteria.matchOduSignalType(OduSignalType.ODU2));
    assertThat(rule2.selector(), is(selectorBuilder2.build()));
    // validate DST treatment
    assertThat(rule2.treatment(), is(DefaultTrafficTreatment.builder().setOutput(oduCltDstCP.port()).build()));
    rules.forEach(rule -> assertEquals("FlowRule priority is incorrect", intent.priority(), rule.priority()));
    sut.deactivate();
}
#method_after
@Test
public void test10GbeMultiplexOverOdu2() {
    // Use driver with TributarySlotQuery Behaviour
    sut.driverService = new MockDriverServiceWithTs();
    ConnectPoint oduCltSrcCP = new ConnectPoint(device1.id(), D1P3.number());
    ConnectPoint oduCltDstCP = new ConnectPoint(device2.id(), D2P3.number());
    ConnectPoint ochSrcCP = new ConnectPoint(device1.id(), D1P2.number());
    ConnectPoint ochDstCP = new ConnectPoint(device2.id(), D2P2.number());
    intent = OpticalCircuitIntent.builder().appId(APP_ID).key(KEY1).src(oduCltSrcCP).dst(oduCltDstCP).signalType(D1P3.signalType()).bidirectional(false).build();
    sut.activate(null);
    List<Intent> compiled = sut.compile(intent, Collections.emptyList());
    assertThat(compiled, hasSize(1));
    Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
    FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(device1.id())).findFirst().get();
    // validate SRC selector
    TrafficSelector.Builder selectorBuilder1 = DefaultTrafficSelector.builder();
    selectorBuilder1.matchInPort(oduCltSrcCP.port());
    selectorBuilder1.add(Criteria.matchOduSignalType(OduSignalType.ODU2));
    assertThat(rule1.selector(), is(selectorBuilder1.build()));
    // validate SRC treatment (without OduSignalId, i.e. All TributarySlots are used)
    TrafficTreatment.Builder treatmentBuilder1 = DefaultTrafficTreatment.builder();
    treatmentBuilder1.setOutput(ochSrcCP.port());
    assertThat(rule1.treatment(), is(treatmentBuilder1.build()));
    FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(device2.id())).findFirst().get();
    // validate DST selector (without OduSignalId, i.e. All TributarySlots are used)
    TrafficSelector.Builder selectorBuilder2 = DefaultTrafficSelector.builder();
    selectorBuilder2.matchInPort(ochDstCP.port());
    selectorBuilder2.add(Criteria.matchOduSignalType(OduSignalType.ODU2));
    assertThat(rule2.selector(), is(selectorBuilder2.build()));
    // validate DST treatment
    assertThat(rule2.treatment(), is(DefaultTrafficTreatment.builder().setOutput(oduCltDstCP.port()).build()));
    rules.forEach(rule -> assertEquals("FlowRule priority is incorrect", intent.priority(), rule.priority()));
    sut.deactivate();
}
#end_block

#method_before
@Test
public void test10GbeNoMuxOverOdu2() {
    // Use driver without support for TributarySlotQuery Behaviour
    sut.driverService = new MockDriverServiceNoTs();
    ConnectPoint oduCltSrcCP = new ConnectPoint(device1.id(), D1P3.number());
    ConnectPoint oduCltDstCP = new ConnectPoint(device2.id(), D2P3.number());
    ConnectPoint ochSrcCP = new ConnectPoint(device1.id(), D1P2.number());
    ConnectPoint ochDstCP = new ConnectPoint(device2.id(), D2P2.number());
    intent = OpticalCircuitIntent.builder().appId(APP_ID).key(KEY1).src(oduCltSrcCP).dst(oduCltDstCP).signalType(D1P3.signalType()).bidirectional(false).build();
    sut.activate(null);
    List<Intent> compiled = sut.compile(intent, Collections.emptyList(), Collections.emptySet());
    assertThat(compiled, hasSize(1));
    Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
    FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(device1.id())).findFirst().get();
    // validate SRC selector
    TrafficSelector.Builder selectorBuilder1 = DefaultTrafficSelector.builder();
    selectorBuilder1.matchInPort(oduCltSrcCP.port());
    assertThat(rule1.selector(), is(selectorBuilder1.build()));
    // validate SRC treatment (without OduSignalType and OduSignalId: i.e. No TributarySlots are used)
    TrafficTreatment.Builder treatmentBuilder1 = DefaultTrafficTreatment.builder();
    treatmentBuilder1.setOutput(ochSrcCP.port());
    assertThat(rule1.treatment(), is(treatmentBuilder1.build()));
    FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(device2.id())).findFirst().get();
    // validate DST selector (without OduSignalType and OduSignalId: i.e. No TributarySlots are used)
    TrafficSelector.Builder selectorBuilder2 = DefaultTrafficSelector.builder();
    selectorBuilder2.matchInPort(ochDstCP.port());
    assertThat(rule2.selector(), is(selectorBuilder2.build()));
    // validate DST treatment
    assertThat(rule2.treatment(), is(DefaultTrafficTreatment.builder().setOutput(oduCltDstCP.port()).build()));
    rules.forEach(rule -> assertEquals("FlowRule priority is incorrect", intent.priority(), rule.priority()));
    sut.deactivate();
}
#method_after
@Test
public void test10GbeNoMuxOverOdu2() {
    // Use driver without support for TributarySlotQuery Behaviour
    sut.driverService = new MockDriverServiceNoTs();
    ConnectPoint oduCltSrcCP = new ConnectPoint(device1.id(), D1P3.number());
    ConnectPoint oduCltDstCP = new ConnectPoint(device2.id(), D2P3.number());
    ConnectPoint ochSrcCP = new ConnectPoint(device1.id(), D1P2.number());
    ConnectPoint ochDstCP = new ConnectPoint(device2.id(), D2P2.number());
    intent = OpticalCircuitIntent.builder().appId(APP_ID).key(KEY1).src(oduCltSrcCP).dst(oduCltDstCP).signalType(D1P3.signalType()).bidirectional(false).build();
    sut.activate(null);
    List<Intent> compiled = sut.compile(intent, Collections.emptyList());
    assertThat(compiled, hasSize(1));
    Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
    FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(device1.id())).findFirst().get();
    // validate SRC selector
    TrafficSelector.Builder selectorBuilder1 = DefaultTrafficSelector.builder();
    selectorBuilder1.matchInPort(oduCltSrcCP.port());
    assertThat(rule1.selector(), is(selectorBuilder1.build()));
    // validate SRC treatment (without OduSignalType and OduSignalId: i.e. No TributarySlots are used)
    TrafficTreatment.Builder treatmentBuilder1 = DefaultTrafficTreatment.builder();
    treatmentBuilder1.setOutput(ochSrcCP.port());
    assertThat(rule1.treatment(), is(treatmentBuilder1.build()));
    FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(device2.id())).findFirst().get();
    // validate DST selector (without OduSignalType and OduSignalId: i.e. No TributarySlots are used)
    TrafficSelector.Builder selectorBuilder2 = DefaultTrafficSelector.builder();
    selectorBuilder2.matchInPort(ochDstCP.port());
    assertThat(rule2.selector(), is(selectorBuilder2.build()));
    // validate DST treatment
    assertThat(rule2.treatment(), is(DefaultTrafficTreatment.builder().setOutput(oduCltDstCP.port()).build()));
    rules.forEach(rule -> assertEquals("FlowRule priority is incorrect", intent.priority(), rule.priority()));
    sut.deactivate();
}
#end_block

#method_before
@Override
public List<Intent> compile(OpticalOduIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    // Check if ports are OduClt ports
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    Port srcPort = deviceService.getPort(src.deviceId(), src.port());
    Port dstPort = deviceService.getPort(dst.deviceId(), dst.port());
    checkArgument(srcPort instanceof OduCltPort);
    checkArgument(dstPort instanceof OduCltPort);
    log.debug("Compiling optical ODU intent between {} and {}", src, dst);
    // Release of intent resources here is only a temporary solution for handling the
    // case of recompiling due to intent restoration (when intent state is FAILED).
    // TODO: try to release intent resources in IntentManager.
    resourceService.release(intent.id());
    // Check OduClt ports availability
    Resource srcPortResource = Resources.discrete(src.deviceId(), src.port()).resource();
    Resource dstPortResource = Resources.discrete(dst.deviceId(), dst.port()).resource();
    // If ports are not available, compilation fails
    if (!Stream.of(srcPortResource, dstPortResource).allMatch(resourceService::isAvailable)) {
        throw new IntentCompilationException("Ports for the intent are not available. Intent: " + intent);
    }
    List<Resource> intentResources = new ArrayList<>();
    intentResources.add(srcPortResource);
    intentResources.add(dstPortResource);
    // Calculate available light paths
    Set<Path> paths = getOpticalPaths(intent);
    if (paths.isEmpty()) {
        throw new IntentCompilationException("Unable to find suitable lightpath for intent " + intent);
    }
    // Use first path that can be successfully reserved
    for (Path path : paths) {
        // Find available Tributary Slots on both directions of path
        Map<LinkKey, Set<TributarySlot>> slotsMap = findAvailableTributarySlots(intent, path);
        if (slotsMap.isEmpty()) {
            continue;
        }
        List<Resource> tributarySlotResources = convertToResources(slotsMap);
        if (!tributarySlotResources.stream().allMatch(resourceService::isAvailable)) {
            continue;
        }
        intentResources.addAll(tributarySlotResources);
        allocateResources(intent, intentResources);
        List<FlowRule> rules = new LinkedList<>();
        // Create rules for forward and reverse path
        rules = createRules(intent, intent.getSrc(), intent.getDst(), path, slotsMap, false);
        if (intent.isBidirectional()) {
            rules.addAll(createRules(intent, intent.getDst(), intent.getSrc(), path, slotsMap, true));
        }
        return Collections.singletonList(new FlowRuleIntent(appId, rules, ImmutableSet.copyOf(path.links())));
    }
    throw new IntentCompilationException("Unable to find suitable lightpath for intent " + intent);
}
#method_after
@Override
public List<Intent> compile(OpticalOduIntent intent, List<Intent> installable) {
    // Check if ports are OduClt ports
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    Port srcPort = deviceService.getPort(src.deviceId(), src.port());
    Port dstPort = deviceService.getPort(dst.deviceId(), dst.port());
    checkArgument(srcPort instanceof OduCltPort);
    checkArgument(dstPort instanceof OduCltPort);
    log.debug("Compiling optical ODU intent between {} and {}", src, dst);
    // Release of intent resources here is only a temporary solution for handling the
    // case of recompiling due to intent restoration (when intent state is FAILED).
    // TODO: try to release intent resources in IntentManager.
    resourceService.release(intent.id());
    // Check OduClt ports availability
    Resource srcPortResource = Resources.discrete(src.deviceId(), src.port()).resource();
    Resource dstPortResource = Resources.discrete(dst.deviceId(), dst.port()).resource();
    // If ports are not available, compilation fails
    if (!Stream.of(srcPortResource, dstPortResource).allMatch(resourceService::isAvailable)) {
        throw new IntentCompilationException("Ports for the intent are not available. Intent: " + intent);
    }
    List<Resource> intentResources = new ArrayList<>();
    intentResources.add(srcPortResource);
    intentResources.add(dstPortResource);
    // Calculate available light paths
    Set<Path> paths = getOpticalPaths(intent);
    if (paths.isEmpty()) {
        throw new IntentCompilationException("Unable to find suitable lightpath for intent " + intent);
    }
    // Use first path that can be successfully reserved
    for (Path path : paths) {
        // Find available Tributary Slots on both directions of path
        Map<LinkKey, Set<TributarySlot>> slotsMap = findAvailableTributarySlots(intent, path);
        if (slotsMap.isEmpty()) {
            continue;
        }
        List<Resource> tributarySlotResources = convertToResources(slotsMap);
        if (!tributarySlotResources.stream().allMatch(resourceService::isAvailable)) {
            continue;
        }
        intentResources.addAll(tributarySlotResources);
        allocateResources(intent, intentResources);
        List<FlowRule> rules = new LinkedList<>();
        // Create rules for forward and reverse path
        rules = createRules(intent, intent.getSrc(), intent.getDst(), path, slotsMap, false);
        if (intent.isBidirectional()) {
            rules.addAll(createRules(intent, intent.getDst(), intent.getSrc(), path, slotsMap, true));
        }
        return Collections.singletonList(new FlowRuleIntent(appId, rules, ImmutableSet.copyOf(path.links())));
    }
    throw new IntentCompilationException("Unable to find suitable lightpath for intent " + intent);
}
#end_block

#method_before
@Test
public void test1GbeMultiplexOverOdu2() {
    intent = OpticalOduIntent.builder().appId(APP_ID).key(KEY1).src(d1p1).dst(d3p2).signalType(D1P1.signalType()).bidirectional(false).build();
    sut.activate();
    List<Intent> compiled = sut.compile(intent, Collections.emptyList(), Collections.emptySet());
    assertThat(compiled, hasSize(1));
    Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
    // 1st Device
    FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(device1.id())).findFirst().get();
    // validate SRC selector
    TrafficSelector.Builder selectorBuilder1 = DefaultTrafficSelector.builder();
    selectorBuilder1.matchInPort(d1p1.port());
    selectorBuilder1.add(Criteria.matchOduSignalType(OduSignalType.ODU0));
    assertThat(rule1.selector(), is(selectorBuilder1.build()));
    // validate SRC treatment  (with OduSignalId, where 1 TributarySlot is used)
    TrafficTreatment.Builder treatmentBuilder1 = DefaultTrafficTreatment.builder();
    Set<TributarySlot> slots = new HashSet<>();
    slots.add(TributarySlot.of(1));
    OduSignalId oduSignalId = OduSignalUtils.buildOduSignalId(OduSignalType.ODU2, slots);
    treatmentBuilder1.add(Instructions.modL1OduSignalId(oduSignalId));
    treatmentBuilder1.setOutput(d1p2.port());
    assertThat(rule1.treatment(), is(treatmentBuilder1.build()));
    // 2nd Device
    FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(device2.id())).findFirst().get();
    // validate SRC selector
    TrafficSelector.Builder selectorBuilder2 = DefaultTrafficSelector.builder();
    selectorBuilder2.matchInPort(d2p1.port());
    selectorBuilder2.add(Criteria.matchOduSignalType(OduSignalType.ODU0));
    selectorBuilder2.add(Criteria.matchOduSignalId(oduSignalId));
    assertThat(rule2.selector(), is(selectorBuilder2.build()));
    // validate SRC treatment  (with OduSignalId, where 1 TributarySlot is used)
    TrafficTreatment.Builder treatmentBuilder2 = DefaultTrafficTreatment.builder();
    treatmentBuilder2.add(Instructions.modL1OduSignalId(oduSignalId));
    treatmentBuilder2.setOutput(d2p2.port());
    assertThat(rule2.treatment(), is(treatmentBuilder2.build()));
    // 3rd Device
    FlowRule rule3 = rules.stream().filter(x -> x.deviceId().equals(device3.id())).findFirst().get();
    // validate DST selector (with OduSignalId, where the same TributarySlot is used)
    TrafficSelector.Builder selectorBuilder3 = DefaultTrafficSelector.builder();
    selectorBuilder3.matchInPort(d3p1.port());
    selectorBuilder3.add(Criteria.matchOduSignalType(OduSignalType.ODU0));
    selectorBuilder3.add(Criteria.matchOduSignalId(oduSignalId));
    assertThat(rule3.selector(), is(selectorBuilder3.build()));
    // validate DST treatment
    assertThat(rule3.treatment(), is(DefaultTrafficTreatment.builder().setOutput(d3p2.port()).build()));
    rules.forEach(rule -> assertEquals("FlowRule priority is incorrect", intent.priority(), rule.priority()));
    sut.deactivate();
}
#method_after
@Test
public void test1GbeMultiplexOverOdu2() {
    intent = OpticalOduIntent.builder().appId(APP_ID).key(KEY1).src(d1p1).dst(d3p2).signalType(D1P1.signalType()).bidirectional(false).build();
    sut.activate();
    List<Intent> compiled = sut.compile(intent, Collections.emptyList());
    assertThat(compiled, hasSize(1));
    Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
    // 1st Device
    FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(device1.id())).findFirst().get();
    // validate SRC selector
    TrafficSelector.Builder selectorBuilder1 = DefaultTrafficSelector.builder();
    selectorBuilder1.matchInPort(d1p1.port());
    selectorBuilder1.add(Criteria.matchOduSignalType(OduSignalType.ODU0));
    assertThat(rule1.selector(), is(selectorBuilder1.build()));
    // validate SRC treatment  (with OduSignalId, where 1 TributarySlot is used)
    TrafficTreatment.Builder treatmentBuilder1 = DefaultTrafficTreatment.builder();
    Set<TributarySlot> slots = new HashSet<>();
    slots.add(TributarySlot.of(1));
    OduSignalId oduSignalId = OduSignalUtils.buildOduSignalId(OduSignalType.ODU2, slots);
    treatmentBuilder1.add(Instructions.modL1OduSignalId(oduSignalId));
    treatmentBuilder1.setOutput(d1p2.port());
    assertThat(rule1.treatment(), is(treatmentBuilder1.build()));
    // 2nd Device
    FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(device2.id())).findFirst().get();
    // validate SRC selector
    TrafficSelector.Builder selectorBuilder2 = DefaultTrafficSelector.builder();
    selectorBuilder2.matchInPort(d2p1.port());
    selectorBuilder2.add(Criteria.matchOduSignalType(OduSignalType.ODU0));
    selectorBuilder2.add(Criteria.matchOduSignalId(oduSignalId));
    assertThat(rule2.selector(), is(selectorBuilder2.build()));
    // validate SRC treatment  (with OduSignalId, where 1 TributarySlot is used)
    TrafficTreatment.Builder treatmentBuilder2 = DefaultTrafficTreatment.builder();
    treatmentBuilder2.add(Instructions.modL1OduSignalId(oduSignalId));
    treatmentBuilder2.setOutput(d2p2.port());
    assertThat(rule2.treatment(), is(treatmentBuilder2.build()));
    // 3rd Device
    FlowRule rule3 = rules.stream().filter(x -> x.deviceId().equals(device3.id())).findFirst().get();
    // validate DST selector (with OduSignalId, where the same TributarySlot is used)
    TrafficSelector.Builder selectorBuilder3 = DefaultTrafficSelector.builder();
    selectorBuilder3.matchInPort(d3p1.port());
    selectorBuilder3.add(Criteria.matchOduSignalType(OduSignalType.ODU0));
    selectorBuilder3.add(Criteria.matchOduSignalId(oduSignalId));
    assertThat(rule3.selector(), is(selectorBuilder3.build()));
    // validate DST treatment
    assertThat(rule3.treatment(), is(DefaultTrafficTreatment.builder().setOutput(d3p2.port()).build()));
    rules.forEach(rule -> assertEquals("FlowRule priority is incorrect", intent.priority(), rule.priority()));
    sut.deactivate();
}
#end_block

#method_before
@Test
public void test10GbeMultiplexOverOdu2() {
    intent = OpticalOduIntent.builder().appId(APP_ID).key(KEY1).src(d1p3).dst(d3p3).signalType(D1P3.signalType()).bidirectional(false).build();
    sut.activate();
    List<Intent> compiled = sut.compile(intent, Collections.emptyList(), Collections.emptySet());
    assertThat(compiled, hasSize(1));
    Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
    // 1st Device
    FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(device1.id())).findFirst().get();
    // validate SRC selector
    TrafficSelector.Builder selectorBuilder1 = DefaultTrafficSelector.builder();
    selectorBuilder1.matchInPort(d1p3.port());
    selectorBuilder1.add(Criteria.matchOduSignalType(OduSignalType.ODU2));
    assertThat(rule1.selector(), is(selectorBuilder1.build()));
    // validate SRC treatment  (without OduSignalId - all TributarySlots are used)
    TrafficTreatment.Builder treatmentBuilder1 = DefaultTrafficTreatment.builder();
    treatmentBuilder1.setOutput(d1p2.port());
    assertThat(rule1.treatment(), is(treatmentBuilder1.build()));
    // 2nd Device
    FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(device2.id())).findFirst().get();
    // validate SRC selector
    TrafficSelector.Builder selectorBuilder2 = DefaultTrafficSelector.builder();
    selectorBuilder2.matchInPort(d2p1.port());
    selectorBuilder2.add(Criteria.matchOduSignalType(OduSignalType.ODU2));
    assertThat(rule2.selector(), is(selectorBuilder2.build()));
    // validate SRC treatment  (without OduSignalId - all TributarySlots are used)
    TrafficTreatment.Builder treatmentBuilder2 = DefaultTrafficTreatment.builder();
    treatmentBuilder2.setOutput(d2p2.port());
    assertThat(rule2.treatment(), is(treatmentBuilder2.build()));
    // 3rd Device
    FlowRule rule3 = rules.stream().filter(x -> x.deviceId().equals(device3.id())).findFirst().get();
    // validate DST selector (without OduSignalId - all TributarySlots are used)
    TrafficSelector.Builder selectorBuilder3 = DefaultTrafficSelector.builder();
    selectorBuilder3.matchInPort(d3p1.port());
    selectorBuilder3.add(Criteria.matchOduSignalType(OduSignalType.ODU2));
    assertThat(rule3.selector(), is(selectorBuilder3.build()));
    // validate DST treatment
    assertThat(rule3.treatment(), is(DefaultTrafficTreatment.builder().setOutput(d3p3.port()).build()));
    rules.forEach(rule -> assertEquals("FlowRule priority is incorrect", intent.priority(), rule.priority()));
    sut.deactivate();
}
#method_after
@Test
public void test10GbeMultiplexOverOdu2() {
    intent = OpticalOduIntent.builder().appId(APP_ID).key(KEY1).src(d1p3).dst(d3p3).signalType(D1P3.signalType()).bidirectional(false).build();
    sut.activate();
    List<Intent> compiled = sut.compile(intent, Collections.emptyList());
    assertThat(compiled, hasSize(1));
    Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
    // 1st Device
    FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(device1.id())).findFirst().get();
    // validate SRC selector
    TrafficSelector.Builder selectorBuilder1 = DefaultTrafficSelector.builder();
    selectorBuilder1.matchInPort(d1p3.port());
    selectorBuilder1.add(Criteria.matchOduSignalType(OduSignalType.ODU2));
    assertThat(rule1.selector(), is(selectorBuilder1.build()));
    // validate SRC treatment  (without OduSignalId - all TributarySlots are used)
    TrafficTreatment.Builder treatmentBuilder1 = DefaultTrafficTreatment.builder();
    treatmentBuilder1.setOutput(d1p2.port());
    assertThat(rule1.treatment(), is(treatmentBuilder1.build()));
    // 2nd Device
    FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(device2.id())).findFirst().get();
    // validate SRC selector
    TrafficSelector.Builder selectorBuilder2 = DefaultTrafficSelector.builder();
    selectorBuilder2.matchInPort(d2p1.port());
    selectorBuilder2.add(Criteria.matchOduSignalType(OduSignalType.ODU2));
    assertThat(rule2.selector(), is(selectorBuilder2.build()));
    // validate SRC treatment  (without OduSignalId - all TributarySlots are used)
    TrafficTreatment.Builder treatmentBuilder2 = DefaultTrafficTreatment.builder();
    treatmentBuilder2.setOutput(d2p2.port());
    assertThat(rule2.treatment(), is(treatmentBuilder2.build()));
    // 3rd Device
    FlowRule rule3 = rules.stream().filter(x -> x.deviceId().equals(device3.id())).findFirst().get();
    // validate DST selector (without OduSignalId - all TributarySlots are used)
    TrafficSelector.Builder selectorBuilder3 = DefaultTrafficSelector.builder();
    selectorBuilder3.matchInPort(d3p1.port());
    selectorBuilder3.add(Criteria.matchOduSignalType(OduSignalType.ODU2));
    assertThat(rule3.selector(), is(selectorBuilder3.build()));
    // validate DST treatment
    assertThat(rule3.treatment(), is(DefaultTrafficTreatment.builder().setOutput(d3p3.port()).build()));
    rules.forEach(rule -> assertEquals("FlowRule priority is incorrect", intent.priority(), rule.priority()));
    sut.deactivate();
}
#end_block

#method_before
protected void printDevice(DeviceService deviceService, Device device) {
    if (device != null) {
        String driver = device.annotations().value(AnnotationKeys.DRIVER);
        if (driver == null) {
            DriverService driverService = get(DriverService.class);
            driver = driverService.getDriver(device.id()).name();
        }
        if (shortOnly) {
            print(FMT_SHORT, device.id(), deviceService.isAvailable(device.id()), deviceService.getRole(device.id()), device.type(), driver);
        } else if (!device.annotations().keys().contains(AnnotationKeys.DRIVER)) {
            print(FMT_DRIVER, device.id(), deviceService.isAvailable(device.id()), deviceService.getRole(device.id()), device.type(), device.manufacturer(), device.hwVersion(), device.swVersion(), device.serialNumber(), driver, annotations(device.annotations()));
        } else {
            print(FMT, device.id(), deviceService.isAvailable(device.id()), deviceService.getRole(device.id()), device.type(), device.manufacturer(), device.hwVersion(), device.swVersion(), device.serialNumber(), annotations(device.annotations()));
        }
    }
}
#method_after
protected void printDevice(DeviceService deviceService, Device device) {
    if (device != null) {
        String driver = get(DriverService.class).getDriver(device.id()).name();
        if (shortOnly) {
            print(FMT_SHORT, device.id(), deviceService.isAvailable(device.id()), deviceService.getRole(device.id()), device.type(), driver);
        } else {
            print(FMT, device.id(), deviceService.isAvailable(device.id()), deviceService.getRole(device.id()), device.type(), device.manufacturer(), device.hwVersion(), device.swVersion(), device.serialNumber(), driver, annotations(device.annotations(), ImmutableSet.of(AnnotationKeys.DRIVER)));
        }
    }
}
#end_block

#method_before
protected void printHost(Host host) {
    print(shortOnly ? FMT_SHORT : FMT, host.id(), host.mac(), host.location().deviceId(), host.location().port(), host.vlan(), host.ipAddresses(), shortOnly ? null : annotations(host.annotations()));
}
#method_after
protected void printHost(Host host) {
    if (shortOnly) {
        print(FMT_SHORT, host.id(), host.mac(), host.location().deviceId(), host.location().port(), host.vlan(), host.ipAddresses());
    } else {
        print(FMT, host.id(), host.mac(), host.location().deviceId(), host.location().port(), host.vlan(), host.ipAddresses(), annotations(host.annotations()));
    }
}
#end_block

#method_before
@Override
public void enterAugmentStatement(GeneratedYangParser.AugmentStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void enterAugmentStatement(GeneratedYangParser.AugmentStatementContext ctx) {
    AugmentListener.processAugmentEntry(this, ctx);
}
#end_block

#method_before
@Override
public void exitAugmentStatement(GeneratedYangParser.AugmentStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void exitAugmentStatement(GeneratedYangParser.AugmentStatementContext ctx) {
    AugmentListener.processAugmentExit(this, ctx);
}
#end_block

#method_before
@Override
public void enterRpcStatement(GeneratedYangParser.RpcStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void enterRpcStatement(GeneratedYangParser.RpcStatementContext ctx) {
    RpcListener.processRpcEntry(this, ctx);
}
#end_block

#method_before
@Override
public void exitRpcStatement(GeneratedYangParser.RpcStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void exitRpcStatement(GeneratedYangParser.RpcStatementContext ctx) {
    RpcListener.processRpcExit(this, ctx);
}
#end_block

#method_before
@Override
public void enterInputStatement(GeneratedYangParser.InputStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void enterInputStatement(GeneratedYangParser.InputStatementContext ctx) {
    InputListener.processInputEntry(this, ctx);
}
#end_block

#method_before
@Override
public void exitInputStatement(GeneratedYangParser.InputStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void exitInputStatement(GeneratedYangParser.InputStatementContext ctx) {
    InputListener.processInputExit(this, ctx);
}
#end_block

#method_before
@Override
public void enterOutputStatement(GeneratedYangParser.OutputStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void enterOutputStatement(GeneratedYangParser.OutputStatementContext ctx) {
    OutputListener.processOutputEntry(this, ctx);
}
#end_block

#method_before
@Override
public void exitOutputStatement(GeneratedYangParser.OutputStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void exitOutputStatement(GeneratedYangParser.OutputStatementContext ctx) {
    OutputListener.processOutputExit(this, ctx);
}
#end_block

#method_before
@Override
public void addNode(BgpNodeLSNlriVer4 nodeNlri, PathAttrNlriDetails details) {
    log.debug("Add node {}", nodeNlri.toString());
    if (deviceProviderService == null) {
        return;
    }
    Device.Type deviceType = Device.Type.ROUTER;
    BgpDpid nodeUri = new BgpDpid(nodeNlri);
    DeviceId deviceId = deviceId(uri(nodeUri.toString()));
    ChassisId cId = new ChassisId();
    DefaultAnnotations.Builder newBuilder = DefaultAnnotations.builder();
    newBuilder.set(AnnotationKeys.TYPE, "L3");
    newBuilder.set(AnnotationKeys.ROUTING_UNIVERSE, Long.toString(nodeNlri.getIdentifier()));
    List<BgpValueType> tlvs = nodeNlri.getLocalNodeDescriptors().getNodedescriptors().getSubTlvs();
    for (BgpValueType tlv : tlvs) {
        if (tlv instanceof AutonomousSystemTlv) {
            newBuilder.set(AnnotationKeys.AS_NUMBER, Integer.toString(((AutonomousSystemTlv) tlv).getAsNum()));
        } else if (tlv instanceof BgpLSIdentifierTlv) {
            newBuilder.set(AnnotationKeys.DOMAIN_IDENTIFIER, Integer.toString(((BgpLSIdentifierTlv) tlv).getBgpLsIdentifier()));
        }
        if (tlv.getType() == NodeDescriptors.IGP_ROUTERID_TYPE) {
            if (tlv instanceof IsIsPseudonode) {
                deviceType = Device.Type.VIRTUAL;
                newBuilder.set(AnnotationKeys.ROUTER_ID, ((IsIsPseudonode) tlv).getIsoNodeId().toString());
            } else if (tlv instanceof OspfPseudonode) {
                deviceType = Device.Type.VIRTUAL;
                newBuilder.set(AnnotationKeys.ROUTER_ID, Integer.toString(((OspfPseudonode) tlv).getrouterID()));
            } else if (tlv instanceof IsIsNonPseudonode) {
                newBuilder.set(AnnotationKeys.ROUTER_ID, ((IsIsNonPseudonode) tlv).getIsoNodeId().toString());
            } else if (tlv instanceof OspfNonPseudonode) {
                newBuilder.set(AnnotationKeys.ROUTER_ID, Integer.toString(((OspfNonPseudonode) tlv).getrouterID()));
            }
        }
    }
    DeviceDescription description = new DefaultDeviceDescription(uri(nodeUri.toString()), deviceType, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, cId, newBuilder.build());
    deviceProviderService.deviceConnected(deviceId, description);
}
#method_after
@Override
public void addNode(BgpNodeLSNlriVer4 nodeNlri, PathAttrNlriDetails details) {
    log.debug("Add node {}", nodeNlri.toString());
    if (deviceProviderService == null) {
        return;
    }
    Device.Type deviceType = ROUTER;
    BgpDpid nodeUri = new BgpDpid(nodeNlri);
    DeviceId deviceId = deviceId(uri(nodeUri.toString()));
    ChassisId cId = new ChassisId();
    DefaultAnnotations.Builder newBuilder = DefaultAnnotations.builder();
    newBuilder.set(AnnotationKeys.TYPE, "L3");
    newBuilder.set(ROUTING_UNIVERSE, Long.toString(nodeNlri.getIdentifier()));
    List<BgpValueType> tlvs = nodeNlri.getLocalNodeDescriptors().getNodedescriptors().getSubTlvs();
    for (BgpValueType tlv : tlvs) {
        if (tlv instanceof AutonomousSystemTlv) {
            newBuilder.set(AS_NUMBER, Integer.toString(((AutonomousSystemTlv) tlv).getAsNum()));
        } else if (tlv instanceof BgpLSIdentifierTlv) {
            newBuilder.set(DOMAIN_IDENTIFIER, Integer.toString(((BgpLSIdentifierTlv) tlv).getBgpLsIdentifier()));
        }
        if (tlv.getType() == NodeDescriptors.IGP_ROUTERID_TYPE) {
            if (tlv instanceof IsIsPseudonode) {
                deviceType = VIRTUAL;
                newBuilder.set(AnnotationKeys.ROUTER_ID, new String(((IsIsPseudonode) tlv).getIsoNodeId()));
            } else if (tlv instanceof OspfPseudonode) {
                deviceType = VIRTUAL;
                newBuilder.set(AnnotationKeys.ROUTER_ID, Integer.toString(((OspfPseudonode) tlv).getrouterID()));
            } else if (tlv instanceof IsIsNonPseudonode) {
                newBuilder.set(AnnotationKeys.ROUTER_ID, new String(((IsIsNonPseudonode) tlv).getIsoNodeId()));
            } else if (tlv instanceof OspfNonPseudonode) {
                newBuilder.set(AnnotationKeys.ROUTER_ID, Integer.toString(((OspfNonPseudonode) tlv).getrouterID()));
            }
        }
    }
    DeviceDescription description = new DefaultDeviceDescription(uri(nodeUri.toString()), deviceType, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, cId, newBuilder.build());
    deviceProviderService.deviceConnected(deviceId, description);
}
#end_block

#method_before
private LinkDescription buildLinkDes(BgpLinkLsNlriVer4 linkNlri, PathAttrNlriDetails details, boolean isAddLink) throws BgpParseException {
    long srcAddress = 0;
    long dstAddress = 0;
    Boolean localPseduo = false;
    Boolean remotePseduo = false;
    List<BgpValueType> localTlvs = linkNlri.getLinkIdentifier().localNodeDescriptors().getSubTlvs();
    for (BgpValueType localTlv : localTlvs) {
        if (localTlv instanceof IsIsPseudonode || localTlv instanceof OspfPseudonode) {
            localPseduo = true;
        }
    }
    List<BgpValueType> remoteTlvs = linkNlri.getLinkIdentifier().remoteNodeDescriptors().getSubTlvs();
    for (BgpValueType remoteTlv : remoteTlvs) {
        if (remoteTlv instanceof IsIsPseudonode || remoteTlv instanceof OspfPseudonode) {
            remotePseduo = true;
        }
    }
    List<BgpValueType> tlvs = linkNlri.getLinkIdentifier().linkDescriptors();
    for (BgpValueType tlv : tlvs) {
        if (tlv instanceof LinkLocalRemoteIdentifiersTlv) {
            srcAddress = ((LinkLocalRemoteIdentifiersTlv) tlv).getLinkLocalIdentifier();
            // Set 32nd bit.
            srcAddress = srcAddress | IDENTIFIER_SET;
            dstAddress = ((LinkLocalRemoteIdentifiersTlv) tlv).getLinkRemoteIdentifier();
            dstAddress = dstAddress | IDENTIFIER_SET;
        } else if (tlv instanceof IPv4AddressTlv) {
            if (tlv.getType() == BgpLinkLSIdentifier.IPV4_INTERFACE_ADDRESS_TYPE) {
                srcAddress = ((IPv4AddressTlv) tlv).address().toInt();
            } else {
                dstAddress = ((IPv4AddressTlv) tlv).address().toInt();
            }
        }
    }
    DeviceId srcId = deviceId(uri(new BgpDpid(linkNlri, BgpDpid.NODE_DESCRIPTOR_LOCAL).toString()));
    DeviceId dstId = deviceId(uri(new BgpDpid(linkNlri, BgpDpid.NODE_DESCRIPTOR_REMOTE).toString()));
    if (localPseduo && srcAddress == 0) {
        srcAddress = 0xffffffff;
    } else if (remotePseduo && dstAddress == 0) {
        dstAddress = 0xffffffff;
    }
    ConnectPoint src = new ConnectPoint(srcId, PortNumber.portNumber(srcAddress));
    ConnectPoint dst = new ConnectPoint(dstId, PortNumber.portNumber(dstAddress));
    BgpNodeLSNlriVer4 srcNodeNlri = new BgpNodeLSNlriVer4(linkNlri.getIdentifier(), linkNlri.getProtocolId().getType(), new BgpNodeLSIdentifier(linkNlri.getLinkIdentifier().localNodeDescriptors()), false, linkNlri.getRouteDistinguisher());
    BgpNodeLSNlriVer4 dstNodeNlri = new BgpNodeLSNlriVer4(linkNlri.getIdentifier(), linkNlri.getProtocolId().getType(), new BgpNodeLSIdentifier(linkNlri.getLinkIdentifier().remoteNodeDescriptors()), false, linkNlri.getRouteDistinguisher());
    addOrDeletePseudoNode(isAddLink, localPseduo, remotePseduo, srcNodeNlri, dstNodeNlri, srcId, dstId, details);
    return new DefaultLinkDescription(src, dst, Link.Type.DIRECT, false);
}
#method_after
private LinkDescription buildLinkDes(BgpLinkLsNlriVer4 linkNlri, PathAttrNlriDetails details, boolean isAddLink) throws BgpParseException {
    long srcAddress = 0;
    long dstAddress = 0;
    boolean localPseduo = false;
    boolean remotePseduo = false;
    List<BgpValueType> localTlvs = linkNlri.getLinkIdentifier().localNodeDescriptors().getSubTlvs();
    for (BgpValueType localTlv : localTlvs) {
        if (localTlv instanceof IsIsPseudonode || localTlv instanceof OspfPseudonode) {
            localPseduo = true;
        }
    }
    List<BgpValueType> remoteTlvs = linkNlri.getLinkIdentifier().remoteNodeDescriptors().getSubTlvs();
    for (BgpValueType remoteTlv : remoteTlvs) {
        if (remoteTlv instanceof IsIsPseudonode || remoteTlv instanceof OspfPseudonode) {
            remotePseduo = true;
        }
    }
    List<BgpValueType> tlvs = linkNlri.getLinkIdentifier().linkDescriptors();
    for (BgpValueType tlv : tlvs) {
        if (tlv instanceof LinkLocalRemoteIdentifiersTlv) {
            srcAddress = ((LinkLocalRemoteIdentifiersTlv) tlv).getLinkLocalIdentifier();
            // Set 32nd bit.
            srcAddress = srcAddress | IDENTIFIER_SET;
            dstAddress = ((LinkLocalRemoteIdentifiersTlv) tlv).getLinkRemoteIdentifier();
            dstAddress = dstAddress | IDENTIFIER_SET;
        } else if (tlv instanceof IPv4AddressTlv) {
            if (tlv.getType() == BgpLinkLSIdentifier.IPV4_INTERFACE_ADDRESS_TYPE) {
                srcAddress = ((IPv4AddressTlv) tlv).address().toInt();
            } else {
                dstAddress = ((IPv4AddressTlv) tlv).address().toInt();
            }
        }
    }
    DeviceId srcId = deviceId(uri(new BgpDpid(linkNlri, BgpDpid.NODE_DESCRIPTOR_LOCAL).toString()));
    DeviceId dstId = deviceId(uri(new BgpDpid(linkNlri, BgpDpid.NODE_DESCRIPTOR_REMOTE).toString()));
    if (localPseduo && srcAddress == 0) {
        srcAddress = PSEUDO_PORT;
    } else if (remotePseduo && dstAddress == 0) {
        dstAddress = PSEUDO_PORT;
    }
    ConnectPoint src = new ConnectPoint(srcId, PortNumber.portNumber(srcAddress));
    ConnectPoint dst = new ConnectPoint(dstId, PortNumber.portNumber(dstAddress));
    BgpNodeLSNlriVer4 srcNodeNlri = new BgpNodeLSNlriVer4(linkNlri.getIdentifier(), linkNlri.getProtocolId().getType(), new BgpNodeLSIdentifier(linkNlri.getLinkIdentifier().localNodeDescriptors()), false, linkNlri.getRouteDistinguisher());
    BgpNodeLSNlriVer4 dstNodeNlri = new BgpNodeLSNlriVer4(linkNlri.getIdentifier(), linkNlri.getProtocolId().getType(), new BgpNodeLSIdentifier(linkNlri.getLinkIdentifier().remoteNodeDescriptors()), false, linkNlri.getRouteDistinguisher());
    addOrDeletePseudoNode(isAddLink, localPseduo, remotePseduo, srcNodeNlri, dstNodeNlri, srcId, dstId, details);
    return new DefaultLinkDescription(src, dst, Link.Type.DIRECT, false);
}
#end_block

#method_before
private void addOrDeletePseudoNode(boolean isAddLink, boolean localPseduo, boolean remotePseduo, BgpNodeLSNlriVer4 srcNodeNlri, BgpNodeLSNlriVer4 dstNodeNlri, DeviceId srcId, DeviceId dstId, PathAttrNlriDetails details) {
    if (isAddLink) {
        if (localPseduo) {
            if (deviceService.getDevice(srcId) == null) {
                for (BgpNodeListener l : controller.listener()) {
                    l.addNode(srcNodeNlri, details);
                }
            }
        } else if (remotePseduo) {
            if (deviceService.getDevice(dstId) == null) {
                for (BgpNodeListener l : controller.listener()) {
                    l.addNode(dstNodeNlri, details);
                }
            }
        }
    } else {
        if (localPseduo) {
            Set<Link> links = linkService.getDeviceLinks(srcId);
            if (links == null || links.isEmpty()) {
                for (BgpNodeListener l : controller.listener()) {
                    l.deleteNode(srcNodeNlri);
                }
            }
        } else if (remotePseduo) {
            log.info("Remote pseudo delete loink ");
            Set<Link> links = linkService.getDeviceLinks(dstId);
            if (links == null || links.isEmpty()) {
                for (BgpNodeListener l : controller.listener()) {
                    l.deleteNode(dstNodeNlri);
                }
            }
        }
    }
}
#method_after
private void addOrDeletePseudoNode(boolean isAddLink, boolean localPseduo, boolean remotePseduo, BgpNodeLSNlriVer4 srcNodeNlri, BgpNodeLSNlriVer4 dstNodeNlri, DeviceId srcId, DeviceId dstId, PathAttrNlriDetails details) {
    if (isAddLink) {
        if (localPseduo) {
            if (deviceService.getDevice(srcId) == null) {
                for (BgpNodeListener l : controller.listener()) {
                    l.addNode(srcNodeNlri, details);
                }
            }
        } else if (remotePseduo) {
            if (deviceService.getDevice(dstId) == null) {
                for (BgpNodeListener l : controller.listener()) {
                    l.addNode(dstNodeNlri, details);
                }
            }
        }
    } else {
        if (localPseduo) {
            Set<Link> links = linkService.getDeviceLinks(srcId);
            if (links == null || links.isEmpty()) {
                for (BgpNodeListener l : controller.listener()) {
                    l.deleteNode(srcNodeNlri);
                }
            }
        } else if (remotePseduo) {
            log.info("Remote pseudo delete link ");
            Set<Link> links = linkService.getDeviceLinks(dstId);
            if (links == null || links.isEmpty()) {
                for (BgpNodeListener l : controller.listener()) {
                    l.deleteNode(dstNodeNlri);
                }
            }
        }
    }
}
#end_block

#method_before
@Before
public void startUp() {
    provider.deviceProviderRegistry = nodeRegistry;
    provider.linkProviderRegistry = linkRegistry;
    provider.controller = controller;
    provider.deviceService = deviceService;
    provider.activate();
    assertNotNull("device provider should be registered", nodeRegistry.provider);
    assertNotNull("link provider should be registered", linkRegistry.linkProvider);
    assertNotNull("node listener should be registered", controller.nodeListener);
    assertNotNull("link listener should be registered", controller.linkListener);
}
#method_after
@Before
public void startUp() {
    provider.deviceProviderRegistry = nodeRegistry;
    provider.linkProviderRegistry = linkRegistry;
    provider.controller = controller;
    provider.deviceService = deviceService;
    provider.activate();
    assertThat("device provider should be registered", not(nodeRegistry.provider));
    assertThat("link provider should be registered", not(linkRegistry.linkProvider));
    assertThat("node listener should be registered", not(controller.nodeListener));
    assertThat("link listener should be registered", not(controller.linkListener));
}
#end_block

#method_before
@After
public void tearDown() {
    provider.deactivate();
    assertNull("listener should be removed", controller.nodeListener);
    assertNull("listener should be removed", controller.linkListener);
    provider.controller = null;
    provider.deviceService = null;
    provider.deviceProviderRegistry = null;
}
#method_after
@After
public void tearDown() {
    provider.deactivate();
    provider.controller = null;
    provider.deviceService = null;
    provider.deviceProviderRegistry = null;
    assertThat(controller.nodeListener, is(new HashSet<BgpNodeListener>()));
    assertThat(controller.linkListener, is(new HashSet<BgpLinkListener>()));
}
#end_block

#method_before
@Override
public LinkProvider provider() {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public DeviceProvider provider() {
    return null;
}
#end_block

#method_before
private TrafficTreatment.Builder buildActions(List<OFAction> actions, TrafficTreatment.Builder builder) {
    DriverHandler driverHandler = getDriver(deviceId);
    ExtensionTreatmentInterpreter treatmentInterpreter;
    if (driverHandler.hasBehaviour(ExtensionTreatmentInterpreter.class)) {
        treatmentInterpreter = driverHandler.behaviour(ExtensionTreatmentInterpreter.class);
    } else {
        treatmentInterpreter = null;
    }
    for (OFAction act : actions) {
        switch(act.getType()) {
            case OUTPUT:
                OFActionOutput out = (OFActionOutput) act;
                builder.setOutput(PortNumber.portNumber(out.getPort().getPortNumber()));
                break;
            case SET_VLAN_VID:
                OFActionSetVlanVid vlan = (OFActionSetVlanVid) act;
                builder.setVlanId(VlanId.vlanId(vlan.getVlanVid().getVlan()));
                break;
            case SET_VLAN_PCP:
                OFActionSetVlanPcp pcp = (OFActionSetVlanPcp) act;
                builder.setVlanPcp(pcp.getVlanPcp().getValue());
                break;
            case SET_DL_DST:
                OFActionSetDlDst dldst = (OFActionSetDlDst) act;
                builder.setEthDst(MacAddress.valueOf(dldst.getDlAddr().getLong()));
                break;
            case SET_DL_SRC:
                OFActionSetDlSrc dlsrc = (OFActionSetDlSrc) act;
                builder.setEthSrc(MacAddress.valueOf(dlsrc.getDlAddr().getLong()));
                break;
            case SET_NW_DST:
                OFActionSetNwDst nwdst = (OFActionSetNwDst) act;
                IPv4Address di = nwdst.getNwAddr();
                builder.setIpDst(Ip4Address.valueOf(di.getInt()));
                break;
            case SET_NW_SRC:
                OFActionSetNwSrc nwsrc = (OFActionSetNwSrc) act;
                IPv4Address si = nwsrc.getNwAddr();
                builder.setIpSrc(Ip4Address.valueOf(si.getInt()));
                break;
            case EXPERIMENTER:
                OFActionExperimenter exp = (OFActionExperimenter) act;
                if (exp.getExperimenter() == 0x80005A06 || exp.getExperimenter() == 0x748771) {
                    OFActionCircuit ct = (OFActionCircuit) exp;
                    CircuitSignalID circuitSignalID = ((OFOxmOchSigid) ct.getField()).getValue();
                    builder.add(Instructions.modL0Lambda(Lambda.ochSignal(lookupGridType(circuitSignalID.getGridType()), lookupChannelSpacing(circuitSignalID.getChannelSpacing()), circuitSignalID.getChannelNumber(), circuitSignalID.getSpectralWidth())));
                } else if (treatmentInterpreter != null) {
                    if (treatmentInterpreter.supported(NICIRA_MOV_ARP_SHA_TO_THA.type()) || treatmentInterpreter.supported(NICIRA_MOV_ARP_SPA_TO_TPA.type()) || treatmentInterpreter.supported(NICIRA_MOV_ETH_SRC_TO_DST.type()) || treatmentInterpreter.supported(NICIRA_MOV_IP_SRC_TO_DST.type()) || treatmentInterpreter.supported(NICIRA_RESUBMIT.type())) {
                        builder.extension(treatmentInterpreter.mapAction(exp), deviceId);
                    }
                } else {
                    log.warn("Unsupported OFActionExperimenter {}", exp.getExperimenter());
                }
                break;
            case SET_FIELD:
                OFActionSetField setField = (OFActionSetField) act;
                handleSetField(builder, setField);
                break;
            case POP_MPLS:
                OFActionPopMpls popMpls = (OFActionPopMpls) act;
                builder.popMpls(new EthType(popMpls.getEthertype().getValue()));
                break;
            case PUSH_MPLS:
                builder.pushMpls();
                break;
            case COPY_TTL_IN:
                builder.copyTtlIn();
                break;
            case COPY_TTL_OUT:
                builder.copyTtlOut();
                break;
            case DEC_MPLS_TTL:
                builder.decMplsTtl();
                break;
            case DEC_NW_TTL:
                builder.decNwTtl();
                break;
            case GROUP:
                OFActionGroup group = (OFActionGroup) act;
                builder.group(new DefaultGroupId(group.getGroup().getGroupNumber()));
                break;
            case SET_QUEUE:
                OFActionSetQueue setQueue = (OFActionSetQueue) act;
                builder.setQueue(setQueue.getQueueId());
                break;
            case ENQUEUE:
                OFActionEnqueue enqueue = (OFActionEnqueue) act;
                builder.setQueue(enqueue.getQueueId(), PortNumber.portNumber(enqueue.getPort().getPortNumber()));
                break;
            case STRIP_VLAN:
            case POP_VLAN:
                builder.popVlan();
                break;
            case PUSH_VLAN:
                builder.pushVlan();
                break;
            case SET_TP_DST:
            case SET_TP_SRC:
            case POP_PBB:
            case PUSH_PBB:
            case SET_MPLS_LABEL:
            case SET_MPLS_TC:
            case SET_MPLS_TTL:
            case SET_NW_ECN:
            case SET_NW_TOS:
            case SET_NW_TTL:
            default:
                log.warn("Action type {} not yet implemented.", act.getType());
        }
    }
    return builder;
}
#method_after
private TrafficTreatment.Builder buildActions(List<OFAction> actions, TrafficTreatment.Builder builder) {
    DriverHandler driverHandler = getDriver(deviceId);
    ExtensionTreatmentInterpreter treatmentInterpreter;
    if (driverHandler.hasBehaviour(ExtensionTreatmentInterpreter.class)) {
        treatmentInterpreter = driverHandler.behaviour(ExtensionTreatmentInterpreter.class);
    } else {
        treatmentInterpreter = null;
    }
    for (OFAction act : actions) {
        switch(act.getType()) {
            case OUTPUT:
                OFActionOutput out = (OFActionOutput) act;
                builder.setOutput(PortNumber.portNumber(out.getPort().getPortNumber()));
                break;
            case SET_VLAN_VID:
                OFActionSetVlanVid vlan = (OFActionSetVlanVid) act;
                builder.setVlanId(VlanId.vlanId(vlan.getVlanVid().getVlan()));
                break;
            case SET_VLAN_PCP:
                OFActionSetVlanPcp pcp = (OFActionSetVlanPcp) act;
                builder.setVlanPcp(pcp.getVlanPcp().getValue());
                break;
            case SET_DL_DST:
                OFActionSetDlDst dldst = (OFActionSetDlDst) act;
                builder.setEthDst(MacAddress.valueOf(dldst.getDlAddr().getLong()));
                break;
            case SET_DL_SRC:
                OFActionSetDlSrc dlsrc = (OFActionSetDlSrc) act;
                builder.setEthSrc(MacAddress.valueOf(dlsrc.getDlAddr().getLong()));
                break;
            case SET_NW_DST:
                OFActionSetNwDst nwdst = (OFActionSetNwDst) act;
                IPv4Address di = nwdst.getNwAddr();
                builder.setIpDst(Ip4Address.valueOf(di.getInt()));
                break;
            case SET_NW_SRC:
                OFActionSetNwSrc nwsrc = (OFActionSetNwSrc) act;
                IPv4Address si = nwsrc.getNwAddr();
                builder.setIpSrc(Ip4Address.valueOf(si.getInt()));
                break;
            case EXPERIMENTER:
                OFActionExperimenter exp = (OFActionExperimenter) act;
                if (exp.getExperimenter() == 0x80005A06 || exp.getExperimenter() == 0x748771) {
                    OFActionCircuit ct = (OFActionCircuit) exp;
                    CircuitSignalID circuitSignalID = ((OFOxmOchSigid) ct.getField()).getValue();
                    builder.add(Instructions.modL0Lambda(Lambda.ochSignal(lookupGridType(circuitSignalID.getGridType()), lookupChannelSpacing(circuitSignalID.getChannelSpacing()), circuitSignalID.getChannelNumber(), circuitSignalID.getSpectralWidth())));
                } else if (treatmentInterpreter != null) {
                    builder.extension(treatmentInterpreter.mapAction(exp), deviceId);
                } else {
                    log.warn("Unsupported OFActionExperimenter {}", exp.getExperimenter());
                }
                break;
            case SET_FIELD:
                OFActionSetField setField = (OFActionSetField) act;
                handleSetField(builder, setField);
                break;
            case POP_MPLS:
                OFActionPopMpls popMpls = (OFActionPopMpls) act;
                builder.popMpls(new EthType(popMpls.getEthertype().getValue()));
                break;
            case PUSH_MPLS:
                builder.pushMpls();
                break;
            case COPY_TTL_IN:
                builder.copyTtlIn();
                break;
            case COPY_TTL_OUT:
                builder.copyTtlOut();
                break;
            case DEC_MPLS_TTL:
                builder.decMplsTtl();
                break;
            case DEC_NW_TTL:
                builder.decNwTtl();
                break;
            case GROUP:
                OFActionGroup group = (OFActionGroup) act;
                builder.group(new DefaultGroupId(group.getGroup().getGroupNumber()));
                break;
            case SET_QUEUE:
                OFActionSetQueue setQueue = (OFActionSetQueue) act;
                builder.setQueue(setQueue.getQueueId());
                break;
            case ENQUEUE:
                OFActionEnqueue enqueue = (OFActionEnqueue) act;
                builder.setQueue(enqueue.getQueueId(), PortNumber.portNumber(enqueue.getPort().getPortNumber()));
                break;
            case STRIP_VLAN:
            case POP_VLAN:
                builder.popVlan();
                break;
            case PUSH_VLAN:
                builder.pushVlan();
                break;
            case SET_TP_DST:
            case SET_TP_SRC:
            case POP_PBB:
            case PUSH_PBB:
            case SET_MPLS_LABEL:
            case SET_MPLS_TC:
            case SET_MPLS_TTL:
            case SET_NW_ECN:
            case SET_NW_TOS:
            case SET_NW_TTL:
            default:
                log.warn("Action type {} not yet implemented.", act.getType());
        }
    }
    return builder;
}
#end_block

#method_before
@Test
public void testSingleLongPathCompilation() {
    HostToHostIntent intent = makeIntent(HOST_ONE, HOST_TWO);
    assertThat(intent, is(notNullValue()));
    String[] hops = { HOST_ONE, "h1", "h2", "h3", "h4", "h5", "h6", "h7", "h8", HOST_TWO };
    HostToHostIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(Matchers.notNullValue()));
    assertThat(result, hasSize(2));
    Intent forwardResultIntent = result.get(0);
    assertThat(forwardResultIntent instanceof PathIntent, is(true));
    Intent reverseResultIntent = result.get(1);
    assertThat(reverseResultIntent instanceof PathIntent, is(true));
    if (forwardResultIntent instanceof PathIntent) {
        PathIntent forwardPathIntent = (PathIntent) forwardResultIntent;
        assertThat(forwardPathIntent.path().links(), hasSize(9));
        // assertThat(forwardPathIntent.path().links(), linksHasPath(HOST_ONE, "h1"));
        assertThat(forwardPathIntent.path().links(), linksHasPath("h1", "h2"));
        assertThat(forwardPathIntent.path().links(), linksHasPath("h2", "h3"));
        assertThat(forwardPathIntent.path().links(), linksHasPath("h3", "h4"));
        assertThat(forwardPathIntent.path().links(), linksHasPath("h4", "h5"));
        assertThat(forwardPathIntent.path().links(), linksHasPath("h5", "h6"));
        assertThat(forwardPathIntent.path().links(), linksHasPath("h6", "h7"));
        assertThat(forwardPathIntent.path().links(), linksHasPath("h7", "h8"));
        assertThat(forwardPathIntent.path().links(), linksHasPath("h8", HOST_TWO));
    }
    if (reverseResultIntent instanceof PathIntent) {
        PathIntent reversePathIntent = (PathIntent) reverseResultIntent;
        assertThat(reversePathIntent.path().links(), hasSize(9));
        assertThat(reversePathIntent.path().links(), linksHasPath("h1", HOST_ONE));
        assertThat(reversePathIntent.path().links(), linksHasPath("h2", "h1"));
        assertThat(reversePathIntent.path().links(), linksHasPath("h3", "h2"));
        assertThat(reversePathIntent.path().links(), linksHasPath("h4", "h3"));
        assertThat(reversePathIntent.path().links(), linksHasPath("h5", "h4"));
        assertThat(reversePathIntent.path().links(), linksHasPath("h6", "h5"));
        assertThat(reversePathIntent.path().links(), linksHasPath("h7", "h6"));
        assertThat(reversePathIntent.path().links(), linksHasPath("h8", "h7"));
        assertThat(reversePathIntent.path().links(), linksHasPath(HOST_TWO, "h8"));
    }
}
#method_after
@Test
public void testSingleLongPathCompilation() {
    HostToHostIntent intent = makeIntent(HOST_ONE, HOST_TWO);
    assertThat(intent, is(notNullValue()));
    String[] hops = { HOST_ONE, "h1", "h2", "h3", "h4", "h5", "h6", "h7", "h8", HOST_TWO };
    HostToHostIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(Matchers.notNullValue()));
    assertThat(result, hasSize(2));
    Intent forwardResultIntent = result.get(0);
    assertThat(forwardResultIntent instanceof PathIntent, is(true));
    Intent reverseResultIntent = result.get(1);
    assertThat(reverseResultIntent instanceof PathIntent, is(true));
    if (forwardResultIntent instanceof PathIntent) {
        PathIntent forwardPathIntent = (PathIntent) forwardResultIntent;
        assertThat(forwardPathIntent.path().links(), hasSize(9));
        assertThat(forwardPathIntent.path().links(), linksHasPath(HOST_ONE, "h1"));
        assertThat(forwardPathIntent.path().links(), linksHasPath("h1", "h2"));
        assertThat(forwardPathIntent.path().links(), linksHasPath("h2", "h3"));
        assertThat(forwardPathIntent.path().links(), linksHasPath("h3", "h4"));
        assertThat(forwardPathIntent.path().links(), linksHasPath("h4", "h5"));
        assertThat(forwardPathIntent.path().links(), linksHasPath("h5", "h6"));
        assertThat(forwardPathIntent.path().links(), linksHasPath("h6", "h7"));
        assertThat(forwardPathIntent.path().links(), linksHasPath("h7", "h8"));
        assertThat(forwardPathIntent.path().links(), linksHasPath("h8", HOST_TWO));
    }
    if (reverseResultIntent instanceof PathIntent) {
        PathIntent reversePathIntent = (PathIntent) reverseResultIntent;
        assertThat(reversePathIntent.path().links(), hasSize(9));
        assertThat(reversePathIntent.path().links(), linksHasPath("h1", HOST_ONE));
        assertThat(reversePathIntent.path().links(), linksHasPath("h2", "h1"));
        assertThat(reversePathIntent.path().links(), linksHasPath("h3", "h2"));
        assertThat(reversePathIntent.path().links(), linksHasPath("h4", "h3"));
        assertThat(reversePathIntent.path().links(), linksHasPath("h5", "h4"));
        assertThat(reversePathIntent.path().links(), linksHasPath("h6", "h5"));
        assertThat(reversePathIntent.path().links(), linksHasPath("h7", "h6"));
        assertThat(reversePathIntent.path().links(), linksHasPath("h8", "h7"));
        assertThat(reversePathIntent.path().links(), linksHasPath(HOST_TWO, "h8"));
    }
}
#end_block

#method_before
public static void processInputEntry(TreeWalkListener listener, GeneratedYangParser.InputStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, INPUT_DATA, "", ENTRY);
    Parsable curData = listener.getParsedDataStack().peek();
    if (curData instanceof YangRpc) {
        YangInput yangInput = getYangInputNode(JAVA_GENERATION);
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(yangInput);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, INPUT_DATA, "", ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(yangInput);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, INPUT_DATA, "", ENTRY));
    }
}
#method_after
public static void processInputEntry(TreeWalkListener listener, GeneratedYangParser.InputStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, INPUT_DATA, "", ENTRY);
    Parsable curData = listener.getParsedDataStack().peek();
    if (curData instanceof YangRpc) {
        YangInput yangInput = getYangInputNode(JAVA_GENERATION);
        yangInput.setName(((YangRpc) curData).getName() + INPUT_KEYWORD);
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(yangInput);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, INPUT_DATA, "", ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(yangInput);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, INPUT_DATA, "", ENTRY));
    }
}
#end_block

#method_before
@Test
public void processInputStatementWithDataDefinition() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/InputStatementWithDataDefinition.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangInput yangInput = (YangInput) yangRpc.getChild();
    ListIterator<YangLeaf> leafIterator = yangInput.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("image-name"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    YangList yangList = (YangList) yangInput.getChild();
    assertThat(yangList.getName(), is("ospf"));
    assertThat(yangList.getKeyList().contains("invalid-interval"), is(true));
    assertThat(yangList.isConfig(), is(true));
    assertThat(yangList.getMaxElements(), is(10));
    assertThat(yangList.getMinElements(), is(3));
    leafIterator = yangList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    YangContainer yangContainer = (YangContainer) yangList.getNextSibling();
    assertThat(yangContainer.getName(), is("isis"));
    leafIterator = yangContainer.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
}
#method_after
@Test
public void processInputStatementWithDataDefinition() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/InputStatementWithDataDefinition.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangInput yangInput = (YangInput) yangRpc.getChild();
    assertThat(yangInput.getName(), is("activate-software-imageInput"));
    ListIterator<YangLeaf> leafIterator = yangInput.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("image-name"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    YangList yangList = (YangList) yangInput.getChild();
    assertThat(yangList.getName(), is("ospf"));
    assertThat(yangList.getKeyList().contains("invalid-interval"), is(true));
    assertThat(yangList.isConfig(), is(true));
    assertThat(yangList.getMaxElements(), is(10));
    assertThat(yangList.getMinElements(), is(3));
    leafIterator = yangList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    YangContainer yangContainer = (YangContainer) yangList.getNextSibling();
    assertThat(yangContainer.getName(), is("isis"));
    leafIterator = yangContainer.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
}
#end_block

#method_before
@Test
public void processInputStatementWithTypedef() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/InputStatementWithTypedef.yang");
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangInput yangInput = (YangInput) yangRpc.getChild();
    YangTypeDef typeDef = (YangTypeDef) yangInput.getChild();
    assertThat(typeDef.getName(), is("my-type"));
    assertThat(typeDef.getStatus(), is(YangStatusType.DEPRECATED));
    assertThat(typeDef.getDataType().getDataType(), is(YangDataTypes.INT32));
}
#method_after
@Test
public void processInputStatementWithTypedef() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/InputStatementWithTypedef.yang");
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangInput yangInput = (YangInput) yangRpc.getChild();
    assertThat(yangInput.getName(), is("activate-software-imageInput"));
    YangTypeDef typeDef = (YangTypeDef) yangInput.getChild();
    assertThat(typeDef.getName(), is("my-type"));
    assertThat(typeDef.getStatus(), is(YangStatusType.DEPRECATED));
    assertThat(typeDef.getDataType().getDataType(), is(YangDataTypes.INT32));
}
#end_block

#method_before
public static void processOutputEntry(TreeWalkListener listener, GeneratedYangParser.OutputStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, OUTPUT_DATA, "", ENTRY);
    Parsable curData = listener.getParsedDataStack().peek();
    if (curData instanceof YangRpc) {
        YangOutput yangOutput = getYangOutputNode(JAVA_GENERATION);
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(yangOutput);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, OUTPUT_DATA, "", ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(yangOutput);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, OUTPUT_DATA, "", ENTRY));
    }
}
#method_after
public static void processOutputEntry(TreeWalkListener listener, GeneratedYangParser.OutputStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, OUTPUT_DATA, "", ENTRY);
    Parsable curData = listener.getParsedDataStack().peek();
    if (curData instanceof YangRpc) {
        YangOutput yangOutput = getYangOutputNode(JAVA_GENERATION);
        yangOutput.setName(((YangRpc) curData).getName() + OUTPUT_KEYWORD);
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(yangOutput);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, OUTPUT_DATA, "", ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(yangOutput);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, OUTPUT_DATA, "", ENTRY));
    }
}
#end_block

#method_before
@Override
public void enterAugmentStatement(GeneratedYangParser.AugmentStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void enterAugmentStatement(GeneratedYangParser.AugmentStatementContext ctx) {
    AugmentListener.processAugmentEntry(this, ctx);
}
#end_block

#method_before
@Override
public void exitAugmentStatement(GeneratedYangParser.AugmentStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void exitAugmentStatement(GeneratedYangParser.AugmentStatementContext ctx) {
    AugmentListener.processAugmentExit(this, ctx);
}
#end_block

#method_before
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
    getJavaFileInfo().setJavaName(getCaptialCase(getCamelCase(getName())));
    getJavaFileInfo().setPackage(getCurNodePackage(this));
    getJavaFileInfo().setPackageFilePath(getPackageDirPathFromJavaJPackage(getJavaFileInfo().getPackage()));
    getJavaFileInfo().setBaseCodeGenPath(codeGenDir);
    String absolutePath = getAbsolutePackagePath(getJavaFileInfo().getBaseCodeGenPath(), getJavaFileInfo().getPackageFilePath());
    setTempJavaCodeFragmentFiles(new TempJavaCodeFragmentFiles(getJavaFileInfo().getGeneratedFileTypes(), absolutePath, getJavaFileInfo().getJavaName()));
    getTempJavaCodeFragmentFiles().addCurNodeLeavesInfoToTempFiles(this);
    getTempJavaCodeFragmentFiles().addCurNodeInfoInParentTempFile(this, false);
}
#method_after
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
// TODO
}
#end_block

#method_before
@Override
public void generateCodeExit() {
// TODO Auto-generated method stub
}
#method_after
@Override
public void generateCodeExit() throws IOException {
// TODO
}
#end_block

#method_before
@Test
public void processOutputStatementWithDataDefinition() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/OutputStatementWithDataDefinition.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangOutput yangOutput = (YangOutput) yangRpc.getChild();
    ListIterator<YangLeaf> leafIterator = yangOutput.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("image-name"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    YangList yangList = (YangList) yangOutput.getChild();
    assertThat(yangList.getName(), is("ospf"));
    assertThat(yangList.getKeyList().contains("invalid-interval"), is(true));
    assertThat(yangList.isConfig(), is(true));
    assertThat(yangList.getMaxElements(), is(10));
    assertThat(yangList.getMinElements(), is(3));
    leafIterator = yangList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    YangContainer yangContainer = (YangContainer) yangList.getNextSibling();
    assertThat(yangContainer.getName(), is("isis"));
    leafIterator = yangContainer.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
}
#method_after
@Test
public void processOutputStatementWithDataDefinition() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/OutputStatementWithDataDefinition.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangOutput yangOutput = (YangOutput) yangRpc.getChild();
    assertThat(yangOutput.getName(), is("activate-software-imageOutput"));
    ListIterator<YangLeaf> leafIterator = yangOutput.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("image-name"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    YangList yangList = (YangList) yangOutput.getChild();
    assertThat(yangList.getName(), is("ospf"));
    assertThat(yangList.getKeyList().contains("invalid-interval"), is(true));
    assertThat(yangList.isConfig(), is(true));
    assertThat(yangList.getMaxElements(), is(10));
    assertThat(yangList.getMinElements(), is(3));
    leafIterator = yangList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    YangContainer yangContainer = (YangContainer) yangList.getNextSibling();
    assertThat(yangContainer.getName(), is("isis"));
    leafIterator = yangContainer.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
}
#end_block

#method_before
@Test
public void processOutputStatementWithTypedef() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/OutputStatementWithTypedef.yang");
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangOutput yangOutput = (YangOutput) yangRpc.getChild();
    YangTypeDef typeDef = (YangTypeDef) yangOutput.getChild();
    assertThat(typeDef.getName(), is("my-type"));
    assertThat(typeDef.getStatus(), is(YangStatusType.DEPRECATED));
    assertThat(typeDef.getName(), is("my-type"));
    assertThat(typeDef.getStatus(), is(YangStatusType.DEPRECATED));
    assertThat(typeDef.getDataType().getDataType(), is(YangDataTypes.INT32));
}
#method_after
@Test
public void processOutputStatementWithTypedef() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/OutputStatementWithTypedef.yang");
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangOutput yangOutput = (YangOutput) yangRpc.getChild();
    assertThat(yangOutput.getName(), is("activate-software-imageOutput"));
    YangTypeDef typeDef = (YangTypeDef) yangOutput.getChild();
    assertThat(typeDef.getName(), is("my-type"));
    assertThat(typeDef.getStatus(), is(YangStatusType.DEPRECATED));
    assertThat(typeDef.getName(), is("my-type"));
    assertThat(typeDef.getStatus(), is(YangStatusType.DEPRECATED));
    assertThat(typeDef.getDataType().getDataType(), is(YangDataTypes.INT32));
}
#end_block

#method_before
@Override
public void changePortState(DeviceId deviceId, PortNumber portNumber, boolean enable) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(deviceId, PORT_NUMBER_NULL);
    DeviceProvider provider = getProvider(deviceId);
    if (provider != null) {
        provider.changePortState(deviceId, portNumber, enable);
        log.warn("Port {} on device {} being administratively brought {}", portNumber, deviceId, (enable) ? "UP" : "DOWN");
    } else {
        log.warn("Provider not found for {}", deviceId);
    }
}
#method_after
@Override
public void changePortState(DeviceId deviceId, PortNumber portNumber, boolean enable) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(deviceId, PORT_NUMBER_NULL);
    DeviceProvider provider = getProvider(deviceId);
    if (provider != null) {
        log.warn("Port {} on device {} being administratively brought {}", portNumber, deviceId, (enable) ? "UP" : "DOWN");
        provider.changePortState(deviceId, portNumber, enable);
    } else {
        log.warn("Provider not found for {}", deviceId);
    }
}
#end_block

#method_before
@Override
protected List<String> choices() {
    ArgumentList args = getArgumentList();
    checkArgument(args.getCursorArgumentIndex() >= 1, "Expects DeviceId as previous argument");
    String deviceIdStr = args.getArguments()[1];
    DeviceId deviceId = DeviceId.deviceId(deviceIdStr);
    DeviceService deviceService = getService(DeviceService.class);
    return StreamSupport.stream(deviceService.getPorts(deviceId).spliterator(), false).map(port -> port.number().toString()).collect(Collectors.toList());
}
#method_after
@Override
protected List<String> choices() {
    ArgumentList args = getArgumentList();
    // parse argument list for deviceId
    DeviceService deviceService = getService(DeviceService.class);
    Device dev = null;
    for (String str : args.getArguments()) {
        if (str.contains(":")) {
            dev = deviceService.getDevice(DeviceId.deviceId(str));
            if (dev != null) {
                break;
            }
        }
    }
    if (dev == null) {
        return Collections.singletonList("Missing device");
    }
    DeviceId deviceId = dev.id();
    return StreamSupport.stream(deviceService.getPorts(deviceId).spliterator(), false).map(port -> port.number().toString()).collect(Collectors.toList());
}
#end_block

#method_before
public void processPacketIn(InboundPacket pkt) {
    Ethernet ethernet = pkt.parsed();
    ARP arp = (ARP) ethernet.getPayload();
    ConnectPoint connectPoint = pkt.receivedFrom();
    connectPoint.port();
    DeviceId deviceId = connectPoint.deviceId();
    arp.getSenderHardwareAddress();
    Ip4Address.valueOf(arp.getSenderProtocolAddress());
    if (arp.getOpCode() == ARP.OP_REQUEST) {
        handleArpRequest(deviceId, connectPoint, ethernet);
    } else {
        handleArpReply(deviceId, connectPoint, ethernet);
    }
}
#method_after
public void processPacketIn(InboundPacket pkt) {
    Ethernet ethernet = pkt.parsed();
    ARP arp = (ARP) ethernet.getPayload();
    ConnectPoint connectPoint = pkt.receivedFrom();
    DeviceId deviceId = connectPoint.deviceId();
    if (arp.getOpCode() == ARP.OP_REQUEST) {
        handleArpRequest(deviceId, connectPoint, ethernet);
    } else {
        handleArpReply(deviceId, connectPoint, ethernet);
    }
}
#end_block

#method_before
/*private synchronized Group deleteNextHop(IpPrefix prefix) {
        IpAddress nextHopIp = prefixToNextHop.remove(prefix);
        NextHop nextHop = nextHops.get(nextHopIp);
        if (nextHop == null) {
            log.warn("No next hop found when removing prefix {}", prefix);
            return null;
        }

        Group group = groupService.getGroup(deviceId,
                                            new DefaultGroupKey(appKryo.
                                                                serialize(nextHop.group())));

        // FIXME disabling group deletes for now until we verify the logic is OK
        if (nextHopsCount.remove(nextHopIp, 1) <= 1) {
            // There was one or less next hops, so there are now none

            log.debug("removing group for next hop {}", nextHop);

            nextHops.remove(nextHopIp);

            groupService.removeGroup(deviceId,
                                     new DefaultGroupKey(appKryo.build().serialize(nextHop.group())),
                                     appId);
        }

        return group;
    }*/
private void processIntfFilters(boolean install, Set<Interface> intfs) {
    log.info("Processing {} router interfaces", intfs.size());
    for (Interface intf : intfs) {
        if (!intf.connectPoint().deviceId().equals(deviceId)) {
            // Ignore interfaces if they are not on the router switch
            continue;
        }
        FilteringObjective.Builder fob = DefaultFilteringObjective.builder();
        // first add filter for the interface
        fob.withKey(Criteria.matchInPort(intf.connectPoint().port())).addCondition(Criteria.matchEthDst(intf.mac())).addCondition(Criteria.matchVlanId(intf.vlan()));
        fob.withPriority(PRIORITY_OFFSET);
        if (intf.vlan() == VlanId.NONE) {
            TrafficTreatment tt = DefaultTrafficTreatment.builder().pushVlan().setVlanId(VlanId.vlanId(ASSIGNED_VLAN)).build();
            fob.withMeta(tt);
        }
        fob.permit().fromApp(routerAppId);
        sendFilteringObjective(install, fob, intf);
        if (controlPlaneConnectPoint != null) {
            // then add the same mac/vlan filters for control-plane connect point
            fob.withKey(Criteria.matchInPort(controlPlaneConnectPoint.port()));
            sendFilteringObjective(install, fob, intf);
        }
    }
}
#method_after
/*private synchronized Group deleteNextHop(IpPrefix prefix) {
        IpAddress nextHopIp = prefixToNextHop.remove(prefix);
        NextHop nextHop = nextHops.get(nextHopIp);
        if (nextHop == null) {
            log.warn("No next hop found when removing prefix {}", prefix);
            return null;
        }

        Group group = groupService.getGroup(deviceId,
                                            new DefaultGroupKey(appKryo.
                                                                serialize(nextHop.group())));

        // FIXME disabling group deletes for now until we verify the logic is OK
        if (nextHopsCount.remove(nextHopIp, 1) <= 1) {
            // There was one or less next hops, so there are now none

            log.debug("removing group for next hop {}", nextHop);

            nextHops.remove(nextHopIp);

            groupService.removeGroup(deviceId,
                                     new DefaultGroupKey(appKryo.build().serialize(nextHop.group())),
                                     appId);
        }

        return group;
    }*/
private void processIntfFilters(boolean install, Set<Interface> intfs) {
    log.info("Processing {} router interfaces", intfs.size());
    for (Interface intf : intfs) {
        if (!intf.connectPoint().deviceId().equals(deviceId)) {
            // Ignore interfaces if they are not on the router switch
            continue;
        }
        createFilteringObjective(install, intf);
    }
}
#end_block

#method_before
private void processIntfFilter(boolean install, Interface intf) {
    if (!intf.connectPoint().deviceId().equals(deviceId)) {
        // Ignore interfaces if they are not on the router switch
        return;
    }
    FilteringObjective.Builder fob = createFilteringObjective(intf);
    sendFilteringObjective(install, fob, intf);
}
#method_after
private void processIntfFilter(boolean install, Interface intf) {
    if (!intf.connectPoint().deviceId().equals(deviceId)) {
        // Ignore interfaces if they are not on the router switch
        return;
    }
    createFilteringObjective(install, intf);
}
#end_block

#method_before
private FilteringObjective.Builder createFilteringObjective(Interface intf) {
    FilteringObjective.Builder fob = DefaultFilteringObjective.builder();
    // first add filter for the interface
    fob.withKey(Criteria.matchInPort(intf.connectPoint().port())).addCondition(Criteria.matchEthDst(intf.mac())).addCondition(Criteria.matchVlanId(intf.vlan()));
    fob.withPriority(PRIORITY_OFFSET);
    if (intf.vlan() == VlanId.NONE) {
        TrafficTreatment tt = DefaultTrafficTreatment.builder().pushVlan().setVlanId(VlanId.vlanId(ASSIGNED_VLAN)).build();
        fob.withMeta(tt);
    }
    fob.permit().fromApp(routerAppId);
    return fob;
}
#method_after
private void createFilteringObjective(boolean install, Interface intf) {
    FilteringObjective.Builder fob = DefaultFilteringObjective.builder();
    // first add filter for the interface
    fob.withKey(Criteria.matchInPort(intf.connectPoint().port())).addCondition(Criteria.matchEthDst(intf.mac())).addCondition(Criteria.matchVlanId(intf.vlan()));
    fob.withPriority(PRIORITY_OFFSET);
    if (intf.vlan() == VlanId.NONE) {
        TrafficTreatment tt = DefaultTrafficTreatment.builder().pushVlan().setVlanId(VlanId.vlanId(ASSIGNED_VLAN)).build();
        fob.withMeta(tt);
    }
    fob.permit().fromApp(routerAppId);
    sendFilteringObjective(install, fob, intf);
    if (controlPlaneConnectPoint != null) {
        // then add the same mac/vlan filters for control-plane connect point
        fob.withKey(Criteria.matchInPort(controlPlaneConnectPoint.port()));
        sendFilteringObjective(install, fob, intf);
    }
}
#end_block

#method_before
public static Set<ImportInfo> getImportInfo() {
    return importInfo;
}
#method_after
public static Set<JavaQualifiedTypeInfo> getImportInfo() {
    return importInfo;
}
#end_block

#method_before
public static void addImportInfo(ImportInfo importInfo) {
    getImportInfo().add(importInfo);
}
#method_after
public static void addImportInfo(JavaQualifiedTypeInfo importData) {
    getImportInfo().add(importData);
}
#end_block

#method_before
public static String getJavaDataType(YangType<?> yangType) {
    YangDataTypes type = yangType.getDataType();
    if (type.equals(YangDataTypes.INT8)) {
        return UtilConstants.BYTE;
    } else if (type.equals(YangDataTypes.INT16)) {
        return UtilConstants.SHORT;
    } else if (type.equals(YangDataTypes.INT32)) {
        return UtilConstants.INT;
    } else if (type.equals(YangDataTypes.INT64)) {
        return UtilConstants.LONG;
    } else if (type.equals(YangDataTypes.UINT8)) {
        return UtilConstants.SHORT;
    } else if (type.equals(YangDataTypes.UINT16)) {
        return UtilConstants.INT;
    } else if (type.equals(YangDataTypes.UINT32)) {
        return UtilConstants.LONG;
    } else if (type.equals(YangDataTypes.UINT64)) {
    // TODO: BIGINTEGER.
    } else if (type.equals(YangDataTypes.DECIMAL64)) {
    // TODO: DECIMAL64.
    } else if (type.equals(YangDataTypes.STRING)) {
        return UtilConstants.STRING;
    } else if (type.equals(YangDataTypes.BOOLEAN)) {
        return UtilConstants.BOOLEAN;
    } else if (type.equals(YangDataTypes.ENUMERATION)) {
    // TODO: ENUMERATION.
    } else if (type.equals(YangDataTypes.BITS)) {
    // TODO:BITS
    } else if (type.equals(YangDataTypes.BINARY)) {
    // TODO:BINARY
    } else if (type.equals(YangDataTypes.LEAFREF)) {
    // TODO:LEAFREF
    } else if (type.equals(YangDataTypes.IDENTITYREF)) {
    // TODO:IDENTITYREF
    } else if (type.equals(YangDataTypes.EMPTY)) {
    // TODO:EMPTY
    } else if (type.equals(YangDataTypes.UNION)) {
    // TODO:UNION
    } else if (type.equals(YangDataTypes.INSTANCE_IDENTIFIER)) {
    // TODO:INSTANCE_IDENTIFIER
    } else if (type.equals(YangDataTypes.DERIVED)) {
        return yangType.getDataTypeName();
    }
    return null;
}
#method_after
public static String getJavaDataType(YangType<?> yangType) {
    YangDataTypes type = yangType.getDataType();
    if (type.equals(INT8)) {
        return BYTE;
    } else if (type.equals(INT16)) {
        return SHORT;
    } else if (type.equals(INT32)) {
        return INT;
    } else if (type.equals(INT64)) {
        return LONG;
    } else if (type.equals(UINT8)) {
        return SHORT;
    } else if (type.equals(UINT16)) {
        return INT;
    } else if (type.equals(UINT32)) {
        return LONG;
    } else if (type.equals(UINT64)) {
    // TODO: BIGINTEGER.
    } else if (type.equals(DECIMAL64)) {
    // TODO: DECIMAL64.
    } else if (type.equals(STRING)) {
        return STRING_DATA_TYPE;
    } else if (type.equals(BOOLEAN)) {
        return BOOLEAN_DATA_TYPE;
    } else if (type.equals(ENUMERATION)) {
    // TODO: ENUMERATION.
    } else if (type.equals(BITS)) {
    // TODO:BITS
    } else if (type.equals(BINARY)) {
    // TODO:BINARY
    } else if (type.equals(LEAFREF)) {
    // TODO:LEAFREF
    } else if (type.equals(IDENTITYREF)) {
    // TODO:IDENTITYREF
    } else if (type.equals(EMPTY)) {
    // TODO:EMPTY
    } else if (type.equals(UNION)) {
    // TODO:UNION
    } else if (type.equals(INSTANCE_IDENTIFIER)) {
    // TODO:INSTANCE_IDENTIFIER
    } else if (type.equals(DERIVED)) {
        return yangType.getDataTypeName();
    }
    return null;
}
#end_block

#method_before
public static String getJavaImportClass(YangType<?> yangType, boolean isListAttr) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        if (type.equals(YangDataTypes.INT8)) {
            return UtilConstants.BYTE_WRAPPER;
        } else if (type.equals(YangDataTypes.INT16)) {
            return UtilConstants.SHORT_WRAPPER;
        } else if (type.equals(YangDataTypes.INT32)) {
            return UtilConstants.INTEGER_WRAPPER;
        } else if (type.equals(YangDataTypes.INT64)) {
            return UtilConstants.LONG_WRAPPER;
        } else if (type.equals(YangDataTypes.UINT8)) {
            return UtilConstants.SHORT_WRAPPER;
        } else if (type.equals(YangDataTypes.UINT16)) {
            return UtilConstants.INTEGER_WRAPPER;
        } else if (type.equals(YangDataTypes.UINT32)) {
            return UtilConstants.LONG_WRAPPER;
        } else if (type.equals(YangDataTypes.UINT64)) {
        // TODO: BIGINTEGER.
        } else if (type.equals(YangDataTypes.DECIMAL64)) {
        // TODO: DECIMAL64.
        } else if (type.equals(YangDataTypes.STRING)) {
            return UtilConstants.STRING;
        } else if (type.equals(YangDataTypes.BOOLEAN)) {
            return UtilConstants.BOOLEAN_WRAPPER;
        } else if (type.equals(YangDataTypes.ENUMERATION)) {
        // TODO: ENUMERATION.
        } else if (type.equals(YangDataTypes.BITS)) {
        // TODO:BITS
        } else if (type.equals(YangDataTypes.BINARY)) {
        // TODO:BINARY
        } else if (type.equals(YangDataTypes.LEAFREF)) {
        // TODO:LEAFREF
        } else if (type.equals(YangDataTypes.IDENTITYREF)) {
        // TODO:IDENTITYREF
        } else if (type.equals(YangDataTypes.EMPTY)) {
        // TODO:EMPTY
        } else if (type.equals(YangDataTypes.UNION)) {
        // TODO:UNION
        } else if (type.equals(YangDataTypes.INSTANCE_IDENTIFIER)) {
        // TODO:INSTANCE_IDENTIFIER
        } else if (type.equals(YangDataTypes.DERIVED)) {
            return JavaIdentifierSyntax.getCaptialCase(JavaIdentifierSyntax.getCamelCase(yangType.getDataTypeName()));
        }
    } else {
        if (type.equals(YangDataTypes.UINT64)) {
        // TODO: BIGINTEGER.
        } else if (type.equals(YangDataTypes.DECIMAL64)) {
        // TODO: DECIMAL64.
        } else if (type.equals(YangDataTypes.STRING)) {
            return UtilConstants.STRING;
        } else if (type.equals(YangDataTypes.ENUMERATION)) {
        // TODO: ENUMERATION.
        } else if (type.equals(YangDataTypes.BITS)) {
        // TODO:BITS
        } else if (type.equals(YangDataTypes.BINARY)) {
        // TODO:BINARY
        } else if (type.equals(YangDataTypes.LEAFREF)) {
        // TODO:LEAFREF
        } else if (type.equals(YangDataTypes.IDENTITYREF)) {
        // TODO:IDENTITYREF
        } else if (type.equals(YangDataTypes.EMPTY)) {
        // TODO:EMPTY
        } else if (type.equals(YangDataTypes.UNION)) {
        // TODO:UNION
        } else if (type.equals(YangDataTypes.INSTANCE_IDENTIFIER)) {
        // TODO:INSTANCE_IDENTIFIER
        } else if (type.equals(YangDataTypes.DERIVED)) {
            return JavaIdentifierSyntax.getCaptialCase(JavaIdentifierSyntax.getCamelCase(yangType.getDataTypeName()));
        }
    }
    return null;
}
#method_after
public static String getJavaImportClass(YangType<?> yangType, boolean isListAttr) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        if (type.equals(INT8)) {
            return BYTE_WRAPPER;
        } else if (type.equals(INT16)) {
            return SHORT_WRAPPER;
        } else if (type.equals(INT32)) {
            return INTEGER_WRAPPER;
        } else if (type.equals(INT64)) {
            return LONG_WRAPPER;
        } else if (type.equals(UINT8)) {
            return SHORT_WRAPPER;
        } else if (type.equals(UINT16)) {
            return INTEGER_WRAPPER;
        } else if (type.equals(UINT32)) {
            return LONG_WRAPPER;
        } else if (type.equals(UINT64)) {
        // TODO: BIGINTEGER.
        } else if (type.equals(DECIMAL64)) {
        // TODO: DECIMAL64.
        } else if (type.equals(STRING)) {
            return STRING_DATA_TYPE;
        } else if (type.equals(BOOLEAN)) {
            return BOOLEAN_WRAPPER;
        } else if (type.equals(ENUMERATION)) {
        // TODO: ENUMERATION.
        } else if (type.equals(BITS)) {
        // TODO:BITS
        } else if (type.equals(BINARY)) {
        // TODO:BINARY
        } else if (type.equals(LEAFREF)) {
        // TODO:LEAFREF
        } else if (type.equals(IDENTITYREF)) {
        // TODO:IDENTITYREF
        } else if (type.equals(EMPTY)) {
        // TODO:EMPTY
        } else if (type.equals(UNION)) {
        // TODO:UNION
        } else if (type.equals(INSTANCE_IDENTIFIER)) {
        // TODO:INSTANCE_IDENTIFIER
        } else if (type.equals(DERIVED)) {
            return getCaptialCase(getCamelCase(yangType.getDataTypeName()));
        }
    } else {
        if (type.equals(UINT64)) {
        // TODO: BIGINTEGER.
        } else if (type.equals(DECIMAL64)) {
        // TODO: DECIMAL64.
        } else if (type.equals(STRING)) {
            return STRING_DATA_TYPE;
        } else if (type.equals(ENUMERATION)) {
        // TODO: ENUMERATION.
        } else if (type.equals(BITS)) {
        // TODO:BITS
        } else if (type.equals(BINARY)) {
        // TODO:BINARY
        } else if (type.equals(LEAFREF)) {
        // TODO:LEAFREF
        } else if (type.equals(IDENTITYREF)) {
        // TODO:IDENTITYREF
        } else if (type.equals(EMPTY)) {
        // TODO:EMPTY
        } else if (type.equals(UNION)) {
        // TODO:UNION
        } else if (type.equals(INSTANCE_IDENTIFIER)) {
        // TODO:INSTANCE_IDENTIFIER
        } else if (type.equals(DERIVED)) {
            return getCaptialCase(getCamelCase(yangType.getDataTypeName()));
        }
    }
    return null;
}
#end_block

#method_before
public static String getJavaImportPackage(YangType<?> yangType, boolean isListAttr, String classInfo) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        if (type.equals(YangDataTypes.INT8) || type.equals(YangDataTypes.INT16) || type.equals(YangDataTypes.INT32) || type.equals(YangDataTypes.INT64) || type.equals(YangDataTypes.UINT8) || type.equals(YangDataTypes.UINT16) || type.equals(YangDataTypes.UINT32) || type.equals(YangDataTypes.STRING) || type.equals(YangDataTypes.BOOLEAN)) {
            return UtilConstants.JAVA_LANG;
        } else if (type.equals(YangDataTypes.UINT64)) {
        // TODO: BIGINTEGER.
        } else if (type.equals(YangDataTypes.DECIMAL64)) {
        // TODO: DECIMAL64.
        } else if (type.equals(YangDataTypes.ENUMERATION)) {
        // TODO: ENUMERATION.
        } else if (type.equals(YangDataTypes.BITS)) {
        // TODO:BITS
        } else if (type.equals(YangDataTypes.BINARY)) {
        // TODO:BINARY
        } else if (type.equals(YangDataTypes.LEAFREF)) {
        // TODO:LEAFREF
        } else if (type.equals(YangDataTypes.IDENTITYREF)) {
        // TODO:IDENTITYREF
        } else if (type.equals(YangDataTypes.EMPTY)) {
        // TODO:EMPTY
        } else if (type.equals(YangDataTypes.UNION)) {
        // TODO:UNION
        } else if (type.equals(YangDataTypes.INSTANCE_IDENTIFIER)) {
        // TODO:INSTANCE_IDENTIFIER
        } else if (type.equals(YangDataTypes.DERIVED)) {
            for (ImportInfo imports : getImportInfo()) {
                if (imports.getClassInfo().equals(classInfo)) {
                    return imports.getPkgInfo();
                }
            }
        }
    } else {
        if (type.equals(YangDataTypes.UINT64)) {
        // TODO: BIGINTEGER.
        } else if (type.equals(YangDataTypes.DECIMAL64)) {
        // TODO: DECIMAL64.
        } else if (type.equals(YangDataTypes.STRING)) {
            return UtilConstants.JAVA_LANG;
        } else if (type.equals(YangDataTypes.ENUMERATION)) {
        // TODO: ENUMERATION.
        } else if (type.equals(YangDataTypes.BITS)) {
        // TODO:BITS
        } else if (type.equals(YangDataTypes.BINARY)) {
        // TODO:BINARY
        } else if (type.equals(YangDataTypes.LEAFREF)) {
        // TODO:LEAFREF
        } else if (type.equals(YangDataTypes.IDENTITYREF)) {
        // TODO:IDENTITYREF
        } else if (type.equals(YangDataTypes.EMPTY)) {
        // TODO:EMPTY
        } else if (type.equals(YangDataTypes.UNION)) {
        // TODO:UNION
        } else if (type.equals(YangDataTypes.INSTANCE_IDENTIFIER)) {
        // TODO:INSTANCE_IDENTIFIER
        } else if (type.equals(YangDataTypes.DERIVED)) {
            for (ImportInfo imports : getImportInfo()) {
                if (imports.getClassInfo().equals(classInfo)) {
                    return imports.getPkgInfo();
                }
            }
        }
    }
    return null;
}
#method_after
public static String getJavaImportPackage(YangType<?> yangType, boolean isListAttr, String classInfo) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        if (type.equals(INT8) || type.equals(INT16) || type.equals(INT32) || type.equals(INT64) || type.equals(UINT8) || type.equals(UINT16) || type.equals(UINT32) || type.equals(STRING) || type.equals(BOOLEAN)) {
            return JAVA_LANG;
        } else if (type.equals(UINT64)) {
        // TODO: BIGINTEGER.
        } else if (type.equals(DECIMAL64)) {
        // TODO: DECIMAL64.
        } else if (type.equals(ENUMERATION)) {
        // TODO: ENUMERATION.
        } else if (type.equals(BITS)) {
        // TODO:BITS
        } else if (type.equals(BINARY)) {
        // TODO:BINARY
        } else if (type.equals(LEAFREF)) {
        // TODO:LEAFREF
        } else if (type.equals(IDENTITYREF)) {
        // TODO:IDENTITYREF
        } else if (type.equals(EMPTY)) {
        // TODO:EMPTY
        } else if (type.equals(UNION)) {
        // TODO:UNION
        } else if (type.equals(INSTANCE_IDENTIFIER)) {
        // TODO:INSTANCE_IDENTIFIER
        } else if (type.equals(DERIVED)) {
            for (JavaQualifiedTypeInfo imports : getImportInfo()) {
                if (imports.getClassInfo().equals(classInfo)) {
                    return imports.getPkgInfo();
                }
            }
        }
    } else {
        if (type.equals(UINT64)) {
        // TODO: BIGINTEGER.
        } else if (type.equals(DECIMAL64)) {
        // TODO: DECIMAL64.
        } else if (type.equals(STRING)) {
            return JAVA_LANG;
        } else if (type.equals(ENUMERATION)) {
        // TODO: ENUMERATION.
        } else if (type.equals(BITS)) {
        // TODO:BITS
        } else if (type.equals(BINARY)) {
        // TODO:BINARY
        } else if (type.equals(LEAFREF)) {
        // TODO:LEAFREF
        } else if (type.equals(IDENTITYREF)) {
        // TODO:IDENTITYREF
        } else if (type.equals(EMPTY)) {
        // TODO:EMPTY
        } else if (type.equals(UNION)) {
        // TODO:UNION
        } else if (type.equals(INSTANCE_IDENTIFIER)) {
        // TODO:INSTANCE_IDENTIFIER
        } else if (type.equals(DERIVED)) {
            for (JavaQualifiedTypeInfo imports : getImportInfo()) {
                if (imports.getClassInfo().equals(classInfo)) {
                    return imports.getPkgInfo();
                }
            }
        }
    }
    return null;
}
#end_block

#method_before
public static void addPackageInfo(File path, String classInfo, String pack) throws IOException {
    if (pack.contains(UtilConstants.ORG)) {
        String[] strArray = pack.split(UtilConstants.ORG);
        pack = UtilConstants.ORG + strArray[1];
    }
    try {
        File packageInfo = new File(path + File.separator + "package-info.java");
        packageInfo.createNewFile();
        FileWriter fileWriter = null;
        BufferedWriter bufferedWriter = null;
        fileWriter = new FileWriter(packageInfo);
        bufferedWriter = new BufferedWriter(fileWriter);
        bufferedWriter.write(CopyrightHeader.getCopyrightHeader());
        bufferedWriter.write(JavaDocGen.getJavaDoc(JavaDocGen.JavaDocType.PACKAGE_INFO, classInfo, false));
        bufferedWriter.write(UtilConstants.PACKAGE + UtilConstants.SPACE + pack + UtilConstants.SEMI_COLAN);
        bufferedWriter.close();
    } catch (IOException e) {
        throw new IOException("Exception occured while creating package info file.");
    }
}
#method_after
public static void addPackageInfo(File path, String classInfo, String pack) throws IOException {
    if (pack.contains(ORG)) {
        String[] strArray = pack.split(ORG);
        pack = ORG + strArray[1];
    }
    try {
        File packageInfo = new File(path + SLASH + "package-info.java");
        packageInfo.createNewFile();
        FileWriter fileWriter = new FileWriter(packageInfo);
        BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);
        bufferedWriter.write(CopyrightHeader.getCopyrightHeader());
        bufferedWriter.write(JavaDocGen.getJavaDoc(PACKAGE_INFO, classInfo, false));
        bufferedWriter.write(PACKAGE + SPACE + pack + SEMI_COLAN);
        bufferedWriter.close();
        fileWriter.close();
    } catch (IOException e) {
        throw new IOException("Exception occured while creating package info file.");
    }
}
#end_block

#method_before
public static void clean(String dir) {
    File generatedDirectory = new File(dir);
    if (generatedDirectory.exists()) {
        try {
            FileUtils.deleteDirectory(generatedDirectory);
        } catch (IOException e) {
            log.info("Failed to delete the generated files in " + generatedDirectory + " directory");
        }
    }
}
#method_after
public static void clean(String dir) throws IOException {
    File generatedDirectory = new File(dir);
    if (generatedDirectory.exists()) {
        try {
            deleteDirectory(generatedDirectory);
        } catch (IOException e) {
            throw new IOException("Failed to delete the generated files in " + generatedDirectory + " directory");
        }
    }
}
#end_block

#method_before
public static String partString(String partString) {
    String[] strArray = partString.split(UtilConstants.COMMA);
    String newString = "";
    for (int i = 0; i < strArray.length; i++) {
        if (i % 4 != 0 || i == 0) {
            newString = newString + strArray[i] + UtilConstants.COMMA;
        } else {
            newString = newString + UtilConstants.NEW_LINE + UtilConstants.TWELVE_SPACE_INDENTATION + strArray[i] + UtilConstants.COMMA;
        }
    }
    return trimAtLast(newString, UtilConstants.COMMA);
}
#method_after
public static String partString(String partString) {
    String[] strArray = partString.split(COMMA);
    String newString = EMPTY_STRING;
    for (int i = 0; i < strArray.length; i++) {
        if (i % 4 != 0 || i == 0) {
            newString = newString + strArray[i] + COMMA;
        } else {
            newString = newString + NEW_LINE + TWELVE_SPACE_INDENTATION + strArray[i] + COMMA;
        }
    }
    return trimAtLast(newString, COMMA);
}
#end_block

#method_before
public static String getDirectory(String baseDir, String fileDir) {
    if (fileDir.charAt(fileDir.length() - 1) == File.separatorChar) {
        fileDir = trimAtLast(fileDir, UtilConstants.SLASH);
    }
    String[] strArray = fileDir.split(UtilConstants.SLASH);
    if (strArray[0].equals(UtilConstants.EMPTY_STRING)) {
        return fileDir;
    } else {
        return baseDir + File.separator + fileDir;
    }
}
#method_after
public static String getDirectory(String baseCodeGenPath, String pathOfJavaPkg) {
    if (pathOfJavaPkg.charAt(pathOfJavaPkg.length() - 1) == File.separatorChar) {
        pathOfJavaPkg = trimAtLast(pathOfJavaPkg, SLASH);
    }
    String[] strArray = pathOfJavaPkg.split(SLASH);
    if (strArray[0].equals(EMPTY_STRING)) {
        return pathOfJavaPkg;
    } else {
        return baseCodeGenPath + SLASH + pathOfJavaPkg;
    }
}
#end_block

#method_before
public static void copyYangFilesToTarget(List<String> yangFiles, String outputDir, MavenProject project) throws IOException {
    List<File> files = getListOfFile(yangFiles);
    String path = outputDir + TARGET_RESOURCE_PATH;
    File targetDir = new File(path);
    targetDir.mkdirs();
    for (File file : files) {
        Files.copy(file.toPath(), (new File(path + file.getName())).toPath(), StandardCopyOption.REPLACE_EXISTING);
    }
    Resource rsc = new Resource();
    rsc.setDirectory(outputDir + UtilConstants.SLASH + UtilConstants.TEMP + UtilConstants.SLASH);
    project.addResource(rsc);
}
#method_after
public static void copyYangFilesToTarget(List<String> yangFiles, String outputDir, MavenProject project) throws IOException {
    List<File> files = getListOfFile(yangFiles);
    String path = outputDir + TARGET_RESOURCE_PATH;
    File targetDir = new File(path);
    targetDir.mkdirs();
    for (File file : files) {
        Files.copy(file.toPath(), (new File(path + file.getName())).toPath(), StandardCopyOption.REPLACE_EXISTING);
    }
    Resource rsc = new Resource();
    rsc.setDirectory(outputDir + SLASH + TEMP + SLASH);
    project.addResource(rsc);
}
#end_block

#method_before
public static String getJavaDoc(JavaDocType type, String name, boolean isList) {
    name = JavaIdentifierSyntax.getLowerCase(JavaIdentifierSyntax.getCamelCase(name));
    String javaDoc = "";
    if (type.equals(JavaDocType.IMPL_CLASS)) {
        javaDoc = generateForImplClass(name);
    } else if (type.equals(JavaDocType.BUILDER_CLASS)) {
        javaDoc = generateForBuilderClass(name);
    } else if (type.equals(JavaDocType.INTERFACE)) {
        javaDoc = generateForInterface(name);
    } else if (type.equals(JavaDocType.BUILDER_INTERFACE)) {
        javaDoc = generateForBuilderInterface(name);
    } else if (type.equals(JavaDocType.PACKAGE_INFO)) {
        javaDoc = generateForPackage(name);
    } else if (type.equals(JavaDocType.GETTER)) {
        javaDoc = generateForGetters(name, isList);
    } else if (type.equals(JavaDocType.TYPE_DEF_SETTER)) {
        javaDoc = generateForTypeDefSetter(name);
    } else if (type.equals(JavaDocType.TYPE_DEF_CONSTRUCTOR)) {
        javaDoc = generateForTypeDefConstructor(name);
    } else if (type.equals(JavaDocType.SETTER)) {
        javaDoc = generateForSetters(name, isList);
    } else if (type.equals(JavaDocType.OF)) {
        javaDoc = generateForOf(name);
    } else if (type.equals(JavaDocType.DEFAULT_CONSTRUCTOR)) {
        javaDoc = generateForDefaultConstructors();
    } else if (type.equals(JavaDocType.BUILD)) {
        javaDoc = generateForBuild(name);
    } else {
        javaDoc = generateForConstructors(name);
    }
    return javaDoc;
}
#method_after
public static String getJavaDoc(JavaDocType type, String name, boolean isList) {
    name = JavaIdentifierSyntax.getLowerCase(JavaIdentifierSyntax.getCamelCase(name));
    String javaDoc = UtilConstants.EMPTY_STRING;
    if (type.equals(JavaDocType.IMPL_CLASS)) {
        javaDoc = generateForImplClass(name);
    } else if (type.equals(JavaDocType.BUILDER_CLASS)) {
        javaDoc = generateForBuilderClass(name);
    } else if (type.equals(JavaDocType.INTERFACE)) {
        javaDoc = generateForInterface(name);
    } else if (type.equals(JavaDocType.BUILDER_INTERFACE)) {
        javaDoc = generateForBuilderInterface(name);
    } else if (type.equals(JavaDocType.PACKAGE_INFO)) {
        javaDoc = generateForPackage(name);
    } else if (type.equals(JavaDocType.GETTER_METHOD)) {
        javaDoc = generateForGetters(name, isList);
    } else if (type.equals(JavaDocType.TYPE_DEF_SETTER_METHOD)) {
        javaDoc = generateForTypeDefSetter(name);
    } else if (type.equals(JavaDocType.TYPE_DEF_CONSTRUCTOR)) {
        javaDoc = generateForTypeDefConstructor(name);
    } else if (type.equals(JavaDocType.SETTER_METHOD)) {
        javaDoc = generateForSetters(name, isList);
    } else if (type.equals(JavaDocType.OF_METHOD)) {
        javaDoc = generateForOf(name);
    } else if (type.equals(JavaDocType.DEFAULT_CONSTRUCTOR)) {
        javaDoc = generateForDefaultConstructors();
    } else if (type.equals(JavaDocType.BUILD_METHOD)) {
        javaDoc = generateForBuild(name);
    } else {
        javaDoc = generateForConstructors(name);
    }
    return javaDoc;
}
#end_block

#method_before
private static String generateForGetters(String attribute, boolean isList) {
    String getter = UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_FIRST_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_GETTERS + attribute + UtilConstants.PERIOD + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.NEW_LINE_ESTRIC + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_RETURN;
    if (isList) {
        String listAttribute = UtilConstants.LIST.toLowerCase() + UtilConstants.SPACE + UtilConstants.OF + UtilConstants.SPACE;
        getter = getter + listAttribute;
    }
    getter = getter + attribute + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_END_LINE;
    return getter;
}
#method_after
private static String generateForGetters(String attribute, boolean isList) {
    String getter = NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_FIRST_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_GETTERS + attribute + PERIOD + NEW_LINE + FOUR_SPACE_INDENTATION + NEW_LINE_ESTRIC + FOUR_SPACE_INDENTATION + JAVA_DOC_RETURN;
    if (isList) {
        String listAttribute = LIST.toLowerCase() + SPACE + OF + SPACE;
        getter = getter + listAttribute;
    } else {
        getter = getter + VALUE + SPACE + OF + SPACE;
    }
    getter = getter + attribute + NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_END_LINE;
    return getter;
}
#end_block

#method_before
private static String generateForSetters(String attribute, boolean isList) {
    String setter = UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_FIRST_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_SETTERS + attribute + UtilConstants.PERIOD + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.NEW_LINE_ESTRIC + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_PARAM;
    if (isList) {
        setter = setter + attribute + UtilConstants.SUFIX_S + UtilConstants.SPACE;
        String listAttribute = UtilConstants.LIST.toLowerCase() + UtilConstants.SPACE + UtilConstants.OF + UtilConstants.SPACE;
        setter = setter + listAttribute;
    } else {
        setter = setter + attribute + UtilConstants.SPACE;
    }
    setter = setter + attribute + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_RETURN + UtilConstants.BUILDER_OBJECT + attribute + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_END_LINE;
    return setter;
}
#method_after
private static String generateForSetters(String attribute, boolean isList) {
    String setter = NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_FIRST_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_SETTERS + attribute + PERIOD + NEW_LINE + FOUR_SPACE_INDENTATION + NEW_LINE_ESTRIC + FOUR_SPACE_INDENTATION + JAVA_DOC_PARAM + attribute + SPACE;
    if (isList) {
        String listAttribute = LIST.toLowerCase() + SPACE + OF + SPACE;
        setter = setter + listAttribute;
    } else {
        setter = setter + VALUE + SPACE + OF + SPACE;
    }
    setter = setter + attribute + NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_RETURN + BUILDER_OBJECT + attribute + NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_END_LINE;
    return setter;
}
#end_block

#method_before
private static String generateForOf(String attribute) {
    return UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_FIRST_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_OF + attribute + UtilConstants.PERIOD + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.NEW_LINE_ESTRIC + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_PARAM + UtilConstants.VALUE + UtilConstants.SPACE + UtilConstants.VALUE + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_RETURN + UtilConstants.OBJECT + UtilConstants.SPACE + UtilConstants.OF + UtilConstants.SPACE + attribute + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_END_LINE;
}
#method_after
private static String generateForOf(String attribute) {
    return NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_FIRST_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_OF + attribute + PERIOD + NEW_LINE + FOUR_SPACE_INDENTATION + NEW_LINE_ESTRIC + FOUR_SPACE_INDENTATION + JAVA_DOC_PARAM + VALUE + SPACE + VALUE + SPACE + OF + SPACE + attribute + NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_RETURN + OBJECT + SPACE + OF + SPACE + attribute + NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_END_LINE;
}
#end_block

#method_before
private static String generateForTypeDefSetter(String attribute) {
    return (UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_FIRST_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_SETTERS_COMMON + attribute + UtilConstants.PERIOD + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.NEW_LINE_ESTRIC + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_PARAM + UtilConstants.VALUE + UtilConstants.SPACE + UtilConstants.VALUE + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_END_LINE);
}
#method_after
private static String generateForTypeDefSetter(String attribute) {
    return (NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_FIRST_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_SETTERS_COMMON + attribute + PERIOD + NEW_LINE + FOUR_SPACE_INDENTATION + NEW_LINE_ESTRIC + FOUR_SPACE_INDENTATION + JAVA_DOC_PARAM + VALUE + SPACE + VALUE + SPACE + OF + SPACE + attribute + NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_END_LINE);
}
#end_block

#method_before
private static String generateForTypeDefConstructor(String attribute) {
    return (UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_FIRST_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_CONSTRUCTOR + attribute + UtilConstants.PERIOD + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.NEW_LINE_ESTRIC + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_PARAM + UtilConstants.VALUE + UtilConstants.SPACE + UtilConstants.VALUE + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_END_LINE);
}
#method_after
private static String generateForTypeDefConstructor(String attribute) {
    return (NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_FIRST_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_CONSTRUCTOR + attribute + PERIOD + NEW_LINE + FOUR_SPACE_INDENTATION + NEW_LINE_ESTRIC + FOUR_SPACE_INDENTATION + JAVA_DOC_PARAM + VALUE + SPACE + VALUE + SPACE + OF + SPACE + attribute + NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_END_LINE);
}
#end_block

#method_before
private static String generateForImplClass(String className) {
    return UtilConstants.NEW_LINE + UtilConstants.JAVA_DOC_FIRST_LINE + UtilConstants.IMPL_CLASS_JAVA_DOC + className + UtilConstants.PERIOD + UtilConstants.NEW_LINE + UtilConstants.JAVA_DOC_END_LINE;
}
#method_after
private static String generateForImplClass(String className) {
    return NEW_LINE + JAVA_DOC_FIRST_LINE + IMPL_CLASS_JAVA_DOC + className + PERIOD + NEW_LINE + JAVA_DOC_END_LINE;
}
#end_block

#method_before
private static String generateForBuilderClass(String className) {
    return UtilConstants.NEW_LINE + UtilConstants.JAVA_DOC_FIRST_LINE + UtilConstants.BUILDER_CLASS_JAVA_DOC + className + UtilConstants.PERIOD + UtilConstants.NEW_LINE + UtilConstants.JAVA_DOC_END_LINE;
}
#method_after
private static String generateForBuilderClass(String className) {
    return NEW_LINE + JAVA_DOC_FIRST_LINE + BUILDER_CLASS_JAVA_DOC + className + PERIOD + NEW_LINE + JAVA_DOC_END_LINE;
}
#end_block

#method_before
private static String generateForInterface(String interfaceName) {
    return UtilConstants.NEW_LINE + UtilConstants.JAVA_DOC_FIRST_LINE + UtilConstants.INTERFACE_JAVA_DOC + interfaceName + UtilConstants.PERIOD + UtilConstants.NEW_LINE + UtilConstants.JAVA_DOC_END_LINE;
}
#method_after
private static String generateForInterface(String interfaceName) {
    return NEW_LINE + JAVA_DOC_FIRST_LINE + INTERFACE_JAVA_DOC + interfaceName + PERIOD + NEW_LINE + JAVA_DOC_END_LINE;
}
#end_block

#method_before
private static String generateForBuilderInterface(String builderforName) {
    return UtilConstants.JAVA_DOC_FIRST_LINE + UtilConstants.BUILDER_INTERFACE_JAVA_DOC + builderforName + UtilConstants.PERIOD + UtilConstants.NEW_LINE + UtilConstants.JAVA_DOC_END_LINE;
}
#method_after
private static String generateForBuilderInterface(String builderforName) {
    return JAVA_DOC_FIRST_LINE + BUILDER_INTERFACE_JAVA_DOC + builderforName + PERIOD + NEW_LINE + JAVA_DOC_END_LINE;
}
#end_block

#method_before
private static String generateForPackage(String packageName) {
    return UtilConstants.JAVA_DOC_FIRST_LINE + UtilConstants.PACKAGE_INFO_JAVADOC + packageName + UtilConstants.PERIOD + UtilConstants.NEW_LINE + UtilConstants.JAVA_DOC_END_LINE;
}
#method_after
private static String generateForPackage(String packageName) {
    return JAVA_DOC_FIRST_LINE + PACKAGE_INFO_JAVADOC + packageName + PERIOD + NEW_LINE + JAVA_DOC_END_LINE;
}
#end_block

#method_before
private static String generateForDefaultConstructors() {
    return UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_FIRST_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_DEFAULT_CONSTRUCTOR + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_END_LINE;
}
#method_after
private static String generateForDefaultConstructors() {
    return FOUR_SPACE_INDENTATION + JAVA_DOC_FIRST_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_DEFAULT_CONSTRUCTOR + FOUR_SPACE_INDENTATION + JAVA_DOC_END_LINE;
}
#end_block

#method_before
private static String generateForConstructors(String className) {
    return UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_FIRST_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_CONSTRUCTOR + className + UtilConstants.IMPL + UtilConstants.PERIOD + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.NEW_LINE_ESTRIC + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_PARAM + UtilConstants.BUILDER.toLowerCase() + UtilConstants.OBJECT + UtilConstants.SPACE + UtilConstants.BUILDER_OBJECT + UtilConstants.SPACE + className + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_END_LINE;
}
#method_after
private static String generateForConstructors(String className) {
    return NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_FIRST_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_CONSTRUCTOR + className + IMPL + PERIOD + NEW_LINE + FOUR_SPACE_INDENTATION + NEW_LINE_ESTRIC + FOUR_SPACE_INDENTATION + JAVA_DOC_PARAM + BUILDER.toLowerCase() + OBJECT + SPACE + BUILDER_OBJECT + SPACE + className + NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_END_LINE;
}
#end_block

#method_before
private static String generateForBuild(String buildName) {
    return UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_FIRST_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_BUILD + buildName + UtilConstants.PERIOD + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.NEW_LINE_ESTRIC + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_RETURN + UtilConstants.JAVA_DOC_BUILD_RETURN + buildName + UtilConstants.PERIOD + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_END_LINE;
}
#method_after
private static String generateForBuild(String buildName) {
    return NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_FIRST_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_BUILD + buildName + PERIOD + NEW_LINE + FOUR_SPACE_INDENTATION + NEW_LINE_ESTRIC + FOUR_SPACE_INDENTATION + JAVA_DOC_RETURN + JAVA_DOC_BUILD_RETURN + buildName + PERIOD + NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_END_LINE;
}
#end_block

#method_before
public static String generateClassDefinition(int genFileTypes, String yangName) {
    /**
     * based on the file type and the YANG name of the file, generate the
     * class / interface definition start.
     */
    if ((genFileTypes & GeneratedFileType.INTERFACE_MASK) != 0) {
        return getInterfaceDefinition(yangName);
    } else if ((genFileTypes & GeneratedFileType.BUILDER_CLASS_MASK) != 0) {
        return getBuilderClassDefinition(yangName);
    } else if ((genFileTypes & GeneratedFileType.IMPL_CLASS_MASK) != 0) {
        return getImplClassDefinition(yangName);
    } else if ((genFileTypes & GeneratedFileType.BUILDER_INTERFACE_MASK) != 0) {
        return getBuilderInterfaceDefinition(yangName);
    } else if ((genFileTypes & GeneratedFileType.GENERATE_TYPEDEF_CLASS) != 0) {
        return getTypeDefClassDefinition(yangName);
    }
    return null;
}
#method_after
public static String generateClassDefinition(int genFileTypes, String yangName) {
    /**
     * based on the file type and the YANG name of the file, generate the
     * class / interface definition start.
     */
    if ((genFileTypes & INTERFACE_MASK) != 0) {
        return getInterfaceDefinition(yangName);
    } else if ((genFileTypes & BUILDER_CLASS_MASK) != 0) {
        return getBuilderClassDefinition(yangName);
    } else if ((genFileTypes & IMPL_CLASS_MASK) != 0) {
        return getImplClassDefinition(yangName);
    } else if ((genFileTypes & BUILDER_INTERFACE_MASK) != 0) {
        return getBuilderInterfaceDefinition(yangName);
    } else if ((genFileTypes & GENERATE_TYPEDEF_CLASS) != 0) {
        return getTypeDefClassDefinition(yangName);
    }
    return null;
}
#end_block

#method_before
private static String getInterfaceDefinition(String yangName) {
    return UtilConstants.PUBLIC + UtilConstants.SPACE + UtilConstants.INTERFACE + UtilConstants.SPACE + yangName + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE;
}
#method_after
private static String getInterfaceDefinition(String yangName) {
    return PUBLIC + SPACE + INTERFACE + SPACE + yangName + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
}
#end_block

#method_before
private static String getBuilderInterfaceDefinition(String yangName) {
    return UtilConstants.INTERFACE + UtilConstants.SPACE + yangName + UtilConstants.BUILDER + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE + UtilConstants.NEW_LINE;
}
#method_after
private static String getBuilderInterfaceDefinition(String yangName) {
    return INTERFACE + SPACE + yangName + BUILDER + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + NEW_LINE;
}
#end_block

#method_before
private static String getBuilderClassDefinition(String yangName) {
    return UtilConstants.PUBLIC + UtilConstants.SPACE + UtilConstants.CLASS + UtilConstants.SPACE + yangName + UtilConstants.BUILDER + UtilConstants.SPACE + UtilConstants.IMPLEMENTS + UtilConstants.SPACE + yangName + UtilConstants.PERIOD + yangName + UtilConstants.BUILDER + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE;
}
#method_after
private static String getBuilderClassDefinition(String yangName) {
    return PUBLIC + SPACE + CLASS + SPACE + yangName + BUILDER + SPACE + IMPLEMENTS + SPACE + yangName + PERIOD + yangName + BUILDER + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
}
#end_block

#method_before
private static String getImplClassDefinition(String yangName) {
    return UtilConstants.PUBLIC + UtilConstants.SPACE + UtilConstants.FINAL + UtilConstants.SPACE + UtilConstants.CLASS + UtilConstants.SPACE + yangName + UtilConstants.IMPL + UtilConstants.SPACE + UtilConstants.IMPLEMENTS + UtilConstants.SPACE + yangName + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE;
}
#method_after
private static String getImplClassDefinition(String yangName) {
    return PUBLIC + SPACE + FINAL + SPACE + CLASS + SPACE + yangName + IMPL + SPACE + IMPLEMENTS + SPACE + yangName + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
}
#end_block

#method_before
private static String getTypeDefClassDefinition(String yangName) {
    return UtilConstants.PUBLIC + UtilConstants.SPACE + UtilConstants.FINAL + UtilConstants.SPACE + UtilConstants.CLASS + UtilConstants.SPACE + yangName + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE;
}
#method_after
private static String getTypeDefClassDefinition(String yangName) {
    return PUBLIC + SPACE + FINAL + SPACE + CLASS + SPACE + yangName + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
}
#end_block

#method_before
public static String parseBuilderInterfaceBuildMethodString(String name) {
    return JavaDocGen.getJavaDoc(JavaDocGen.JavaDocType.BUILD, name, false) + getBuildForInterface(name);
}
#method_after
public static String parseBuilderInterfaceBuildMethodString(String name) {
    return getJavaDoc(BUILD_METHOD, name, false) + getBuildForInterface(name);
}
#end_block

#method_before
public static String getGetterString(AttributeInfo attr) {
    String returnType = getReturnType(attr);
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    return JavaDocGen.getJavaDoc(JavaDocGen.JavaDocType.GETTER, attributeName, attr.isListAttr()) + getGetterForInterface(attributeName, returnType, attr.isListAttr());
}
#method_after
public static String getGetterString(JavaAttributeInfo attr) {
    String returnType = getReturnType(attr);
    String attributeName = getLowerCase(attr.getAttributeName());
    return getJavaDoc(GETTER_METHOD, attributeName, attr.isListAttr()) + getGetterForInterface(attributeName, returnType, attr.isListAttr());
}
#end_block

#method_before
public static String getSetterString(AttributeInfo attr, String className) {
    String attrType = getReturnType(attr);
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    return JavaDocGen.getJavaDoc(JavaDocGen.JavaDocType.SETTER, attributeName, attr.isListAttr()) + getSetterForInterface(attributeName, attrType, className, attr.isListAttr());
}
#method_after
public static String getSetterString(JavaAttributeInfo attr, String className) {
    String attrType = getReturnType(attr);
    String attributeName = getLowerCase(attr.getAttributeName());
    return getJavaDoc(SETTER_METHOD, attributeName, attr.isListAttr()) + getSetterForInterface(attributeName, attrType, className, attr.isListAttr());
}
#end_block

#method_before
public static String getConstructorString(String name) {
    return JavaDocGen.getJavaDoc(JavaDocGen.JavaDocType.CONSTRUCTOR, name, false);
}
#method_after
public static String getConstructorString(String name) {
    return getJavaDoc(CONSTRUCTOR, name, false);
}
#end_block

#method_before
public static String getDefaultConstructorString(String name, String modifierType) {
    return JavaDocGen.getJavaDoc(JavaDocGen.JavaDocType.DEFAULT_CONSTRUCTOR, name, false) + getDefaultConstructor(name, modifierType);
}
#method_after
public static String getDefaultConstructorString(String name, String modifierType) {
    return getJavaDoc(DEFAULT_CONSTRUCTOR, name, false) + getDefaultConstructor(name, modifierType);
}
#end_block

#method_before
public static String getTypeDefConstructor(AttributeInfo attr, String className) {
    String attrQuaifiedType = getReturnType(attr);
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    if (!attr.isListAttr()) {
        return getTypeDefConstructorString(attrQuaifiedType, attributeName, className);
    }
    String listAttr = getListString() + attrQuaifiedType + UtilConstants.DIAMOND_CLOSE_BRACKET;
    return getTypeDefConstructorString(listAttr, attributeName, className);
}
#method_after
public static String getTypeDefConstructor(JavaAttributeInfo attr, String className) {
    String attrQuaifiedType = getReturnType(attr);
    String attributeName = getLowerCase(attr.getAttributeName());
    if (!attr.isListAttr()) {
        return getTypeDefConstructorString(attrQuaifiedType, attributeName, className);
    }
    String listAttr = getListString() + attrQuaifiedType + DIAMOND_CLOSE_BRACKET;
    return getTypeDefConstructorString(listAttr, attributeName, className);
}
#end_block

#method_before
private static String getTypeDefConstructorString(String type, String name, String className) {
    return UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.PUBLIC + UtilConstants.SPACE + className + UtilConstants.OPEN_PARENTHESIS + type + UtilConstants.SPACE + UtilConstants.VALUE + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE + UtilConstants.EIGHT_SPACE_INDENTATION + UtilConstants.THIS + UtilConstants.PERIOD + name + UtilConstants.SPACE + UtilConstants.EQUAL + UtilConstants.SPACE + UtilConstants.VALUE + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.CLOSE_CURLY_BRACKET;
}
#method_after
private static String getTypeDefConstructorString(String type, String name, String className) {
    return FOUR_SPACE_INDENTATION + PUBLIC + SPACE + className + OPEN_PARENTHESIS + type + SPACE + VALUE + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + THIS + PERIOD + name + SPACE + EQUAL + SPACE + VALUE + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
}
#end_block

#method_before
public static String getCheckNotNull(String name) {
    return UtilConstants.EIGHT_SPACE_INDENTATION + UtilConstants.CHECK_NOT_NULL_STRING + UtilConstants.OPEN_PARENTHESIS + name + UtilConstants.COMMA + UtilConstants.SPACE + name + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE;
}
#method_after
public static String getCheckNotNull(String name) {
    return EIGHT_SPACE_INDENTATION + CHECK_NOT_NULL_STRING + OPEN_PARENTHESIS + name + COMMA + SPACE + name + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
}
#end_block

#method_before
public static String getBuildString(String name) {
    return UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.OVERRIDE + UtilConstants.NEW_LINE + getBuild(name);
}
#method_after
public static String getBuildString(String name) {
    return FOUR_SPACE_INDENTATION + OVERRIDE + NEW_LINE + getBuild(name);
}
#end_block

#method_before
public static String getGetterForClass(AttributeInfo attr) {
    String attrQuaifiedType = getReturnType(attr);
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    if (!attr.isListAttr()) {
        return getGetter(attrQuaifiedType, attributeName);
    }
    String listAttr = getListString() + attrQuaifiedType + UtilConstants.DIAMOND_CLOSE_BRACKET;
    return getGetter(listAttr, attributeName + UtilConstants.SUFIX_S);
}
#method_after
public static String getGetterForClass(JavaAttributeInfo attr) {
    String attrQuaifiedType = getReturnType(attr);
    String attributeName = getLowerCase(attr.getAttributeName());
    if (!attr.isListAttr()) {
        return getGetter(attrQuaifiedType, attributeName);
    }
    String listAttr = getListString() + attrQuaifiedType + DIAMOND_CLOSE_BRACKET;
    return getGetter(listAttr, attributeName);
}
#end_block

#method_before
private static String getGetter(String type, String name) {
    return UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.PUBLIC + UtilConstants.SPACE + type + UtilConstants.SPACE + UtilConstants.GET_METHOD_PREFIX + JavaIdentifierSyntax.getCaptialCase(name) + UtilConstants.OPEN_PARENTHESIS + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE + UtilConstants.EIGHT_SPACE_INDENTATION + UtilConstants.RETURN + UtilConstants.SPACE + name + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.CLOSE_CURLY_BRACKET;
}
#method_after
private static String getGetter(String type, String name) {
    return FOUR_SPACE_INDENTATION + PUBLIC + SPACE + type + SPACE + GET_METHOD_PREFIX + getCaptialCase(name) + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + name + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
}
#end_block

#method_before
public static String getSetterForClass(AttributeInfo attr, String className) {
    String attrQuaifiedType = getReturnType(attr);
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    if (!attr.isListAttr()) {
        return getSetter(className, attributeName, attrQuaifiedType);
    }
    String listAttr = getListString() + attrQuaifiedType + UtilConstants.DIAMOND_CLOSE_BRACKET;
    return getSetter(className, attributeName + UtilConstants.SUFIX_S, listAttr);
}
#method_after
public static String getSetterForClass(JavaAttributeInfo attr, String className) {
    String attrQuaifiedType = getReturnType(attr);
    String attributeName = getLowerCase(attr.getAttributeName());
    if (!attr.isListAttr()) {
        return getSetter(className, attributeName, attrQuaifiedType);
    }
    String listAttr = getListString() + attrQuaifiedType + DIAMOND_CLOSE_BRACKET;
    return getSetter(className, attributeName, listAttr);
}
#end_block

#method_before
private static String getSetter(String className, String name, String type) {
    return UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.PUBLIC + UtilConstants.SPACE + className + UtilConstants.BUILDER + UtilConstants.SPACE + UtilConstants.SET_METHOD_PREFIX + JavaIdentifierSyntax.getCaptialCase(name) + UtilConstants.OPEN_PARENTHESIS + type + UtilConstants.SPACE + name + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE + UtilConstants.EIGHT_SPACE_INDENTATION + UtilConstants.THIS + UtilConstants.PERIOD + name + UtilConstants.SPACE + UtilConstants.EQUAL + UtilConstants.SPACE + name + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE + UtilConstants.EIGHT_SPACE_INDENTATION + UtilConstants.RETURN + UtilConstants.SPACE + UtilConstants.THIS + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.CLOSE_CURLY_BRACKET;
}
#method_after
private static String getSetter(String className, String name, String type) {
    return FOUR_SPACE_INDENTATION + PUBLIC + SPACE + className + BUILDER + SPACE + SET_METHOD_PREFIX + getCaptialCase(name) + OPEN_PARENTHESIS + type + SPACE + name + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + THIS + PERIOD + name + SPACE + EQUAL + SPACE + name + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + THIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
}
#end_block

#method_before
public static String getSetterForTypeDefClass(AttributeInfo attr) {
    String attrQuaifiedType = getReturnType(attr);
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    if (!attr.isListAttr()) {
        return getTypeDefSetter(attrQuaifiedType, attributeName);
    }
    String listAttr = getListString() + attrQuaifiedType + UtilConstants.DIAMOND_CLOSE_BRACKET;
    return getTypeDefSetter(listAttr, attributeName + UtilConstants.SUFIX_S);
}
#method_after
public static String getSetterForTypeDefClass(JavaAttributeInfo attr) {
    String attrQuaifiedType = getReturnType(attr);
    String attributeName = getLowerCase(attr.getAttributeName());
    return getTypeDefSetter(attrQuaifiedType, attributeName);
}
#end_block

#method_before
private static String getTypeDefSetter(String type, String name) {
    return UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.PUBLIC + UtilConstants.SPACE + UtilConstants.VOID + UtilConstants.SPACE + UtilConstants.SET_METHOD_PREFIX + JavaIdentifierSyntax.getCaptialCase(name) + UtilConstants.OPEN_PARENTHESIS + type + UtilConstants.SPACE + UtilConstants.VALUE + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE + UtilConstants.EIGHT_SPACE_INDENTATION + UtilConstants.THIS + UtilConstants.PERIOD + name + UtilConstants.SPACE + UtilConstants.EQUAL + UtilConstants.SPACE + UtilConstants.VALUE + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.CLOSE_CURLY_BRACKET;
}
#method_after
private static String getTypeDefSetter(String type, String name) {
    return FOUR_SPACE_INDENTATION + PUBLIC + SPACE + VOID + SPACE + SET_METHOD_PREFIX + getCaptialCase(name) + OPEN_PARENTHESIS + type + SPACE + VALUE + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + THIS + PERIOD + name + SPACE + EQUAL + SPACE + VALUE + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
}
#end_block

#method_before
public static String getOverRideString() {
    return UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.OVERRIDE + UtilConstants.NEW_LINE;
}
#method_after
public static String getOverRideString() {
    return NEW_LINE + FOUR_SPACE_INDENTATION + OVERRIDE + NEW_LINE;
}
#end_block

#method_before
public static String getGetterForInterface(String yangName, String returnType, boolean isList) {
    if (!isList) {
        return getGetterInterfaceString(returnType, yangName);
    }
    String listAttr = getListString() + returnType + UtilConstants.DIAMOND_CLOSE_BRACKET;
    return getGetterInterfaceString(listAttr, yangName + UtilConstants.SUFIX_S);
}
#method_after
public static String getGetterForInterface(String yangName, String returnType, boolean isList) {
    if (!isList) {
        return getGetterInterfaceString(returnType, yangName);
    }
    String listAttr = getListString() + returnType + DIAMOND_CLOSE_BRACKET;
    return getGetterInterfaceString(listAttr, yangName);
}
#end_block

#method_before
private static String getGetterInterfaceString(String returnType, String yangName) {
    return UtilConstants.FOUR_SPACE_INDENTATION + returnType + UtilConstants.SPACE + UtilConstants.GET_METHOD_PREFIX + JavaIdentifierSyntax.getCaptialCase(yangName) + UtilConstants.OPEN_PARENTHESIS + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SEMI_COLAN;
}
#method_after
private static String getGetterInterfaceString(String returnType, String yangName) {
    return FOUR_SPACE_INDENTATION + returnType + SPACE + GET_METHOD_PREFIX + getCaptialCase(yangName) + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN;
}
#end_block

#method_before
public static String getSetterForInterface(String attrName, String attrType, String className, boolean isList) {
    if (!isList) {
        return getSetterInterfaceString(className, attrName, attrType);
    }
    String listAttr = getListString() + attrType + UtilConstants.DIAMOND_CLOSE_BRACKET;
    return getSetterInterfaceString(className, attrName + UtilConstants.SUFIX_S, listAttr);
}
#method_after
public static String getSetterForInterface(String attrName, String attrType, String className, boolean isList) {
    if (!isList) {
        return getSetterInterfaceString(className, attrName, attrType);
    }
    String listAttr = getListString() + attrType + DIAMOND_CLOSE_BRACKET;
    return getSetterInterfaceString(className, attrName, listAttr);
}
#end_block

#method_before
private static String getSetterInterfaceString(String className, String attrName, String attrType) {
    return UtilConstants.FOUR_SPACE_INDENTATION + className + UtilConstants.BUILDER + UtilConstants.SPACE + UtilConstants.SET_METHOD_PREFIX + JavaIdentifierSyntax.getCaptialCase(attrName) + UtilConstants.OPEN_PARENTHESIS + attrType + UtilConstants.SPACE + attrName + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SEMI_COLAN;
}
#method_after
private static String getSetterInterfaceString(String className, String attrName, String attrType) {
    return FOUR_SPACE_INDENTATION + className + BUILDER + SPACE + SET_METHOD_PREFIX + getCaptialCase(attrName) + OPEN_PARENTHESIS + attrType + SPACE + attrName + CLOSE_PARENTHESIS + SEMI_COLAN;
}
#end_block

#method_before
private static String getListString() {
    return UtilConstants.LIST + UtilConstants.DIAMOND_OPEN_BRACKET;
}
#method_after
private static String getListString() {
    return LIST + DIAMOND_OPEN_BRACKET;
}
#end_block

#method_before
private static String getReturnType(AttributeInfo attr) {
    String returnType = UtilConstants.EMPTY_STRING;
    if (attr.isQualifiedName() && (attr.getImportInfo().getPkgInfo() != null)) {
        returnType = attr.getImportInfo().getPkgInfo() + UtilConstants.PERIOD;
    }
    returnType = returnType + attr.getImportInfo().getClassInfo();
    return returnType;
}
#method_after
private static String getReturnType(JavaAttributeInfo attr) {
    String returnType = EMPTY_STRING;
    if (attr.isQualifiedName() && (attr.getImportInfo().getPkgInfo() != null)) {
        returnType = attr.getImportInfo().getPkgInfo() + PERIOD;
    }
    returnType = returnType + attr.getImportInfo().getClassInfo();
    return returnType;
}
#end_block

#method_before
public static String getBuildForInterface(String yangName) {
    return UtilConstants.FOUR_SPACE_INDENTATION + yangName + UtilConstants.SPACE + UtilConstants.BUILD + UtilConstants.OPEN_PARENTHESIS + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE;
}
#method_after
public static String getBuildForInterface(String yangName) {
    return FOUR_SPACE_INDENTATION + yangName + SPACE + BUILD + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
}
#end_block

#method_before
public static String getConstructorStart(String yangName) {
    String javadoc = MethodsGenerator.getConstructorString(yangName);
    String constructor = UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.PUBLIC + UtilConstants.SPACE + yangName + UtilConstants.IMPL + UtilConstants.OPEN_PARENTHESIS + yangName + UtilConstants.BUILDER + UtilConstants.SPACE + UtilConstants.BUILDER.toLowerCase() + UtilConstants.OBJECT + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE;
    return javadoc + constructor;
}
#method_after
public static String getConstructorStart(String yangName) {
    String javadoc = getConstructorString(yangName);
    String constructor = FOUR_SPACE_INDENTATION + PUBLIC + SPACE + yangName + IMPL + OPEN_PARENTHESIS + yangName + BUILDER + SPACE + BUILDER.toLowerCase() + OBJECT + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    return javadoc + constructor;
}
#end_block

#method_before
public static String getConstructor(String yangName, AttributeInfo attr) {
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    if (attr.isListAttr()) {
        attributeName = attributeName + UtilConstants.SUFIX_S;
    }
    String constructor = UtilConstants.EIGHT_SPACE_INDENTATION + UtilConstants.THIS + UtilConstants.PERIOD + JavaIdentifierSyntax.getCamelCase(attributeName) + UtilConstants.SPACE + UtilConstants.EQUAL + UtilConstants.SPACE + UtilConstants.BUILDER.toLowerCase() + UtilConstants.OBJECT + UtilConstants.PERIOD + UtilConstants.GET_METHOD_PREFIX + JavaIdentifierSyntax.getCaptialCase(JavaIdentifierSyntax.getCamelCase(attributeName)) + UtilConstants.OPEN_PARENTHESIS + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE;
    return constructor;
}
#method_after
public static String getConstructor(String yangName, JavaAttributeInfo attr) {
    String attributeName = getLowerCase(attr.getAttributeName());
    String constructor = EIGHT_SPACE_INDENTATION + THIS + PERIOD + getCamelCase(attributeName) + SPACE + EQUAL + SPACE + BUILDER.toLowerCase() + OBJECT + PERIOD + GET_METHOD_PREFIX + getCaptialCase(getCamelCase(attributeName)) + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
    return constructor;
}
#end_block

#method_before
public static String getBuild(String yangName) {
    return UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.PUBLIC + UtilConstants.SPACE + yangName + UtilConstants.SPACE + UtilConstants.BUILD + UtilConstants.OPEN_PARENTHESIS + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE + UtilConstants.EIGHT_SPACE_INDENTATION + UtilConstants.RETURN + UtilConstants.SPACE + UtilConstants.NEW + UtilConstants.SPACE + yangName + UtilConstants.IMPL + UtilConstants.OPEN_PARENTHESIS + UtilConstants.THIS + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.CLOSE_CURLY_BRACKET;
}
#method_after
public static String getBuild(String yangName) {
    return FOUR_SPACE_INDENTATION + PUBLIC + SPACE + yangName + SPACE + BUILD + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + NEW + SPACE + yangName + IMPL + OPEN_PARENTHESIS + THIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
}
#end_block

#method_before
private static String getDefaultConstructor(String name, String modifierType) {
    return UtilConstants.FOUR_SPACE_INDENTATION + modifierType + UtilConstants.SPACE + name + UtilConstants.OPEN_PARENTHESIS + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.CLOSE_CURLY_BRACKET;
}
#method_after
private static String getDefaultConstructor(String name, String modifierType) {
    return FOUR_SPACE_INDENTATION + modifierType + SPACE + name + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
}
#end_block

#method_before
public static String getToStringMethodOpen() {
    return getOverRideString() + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.PUBLIC + UtilConstants.SPACE + UtilConstants.STRING + UtilConstants.SPACE + UtilConstants.TO + UtilConstants.STRING + UtilConstants.OPEN_PARENTHESIS + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE + UtilConstants.EIGHT_SPACE_INDENTATION + UtilConstants.RETURN + UtilConstants.GOOGLE_MORE_OBJECT_METHOD_STRING + UtilConstants.NEW_LINE;
}
#method_after
public static String getToStringMethodOpen() {
    return getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + GOOGLE_MORE_OBJECT_METHOD_STRING + NEW_LINE;
}
#end_block

#method_before
public static String getToStringMethodClose() {
    return UtilConstants.TWELVE_SPACE_INDENTATION + UtilConstants.PERIOD + UtilConstants.TO + UtilConstants.STRING + UtilConstants.OPEN_PARENTHESIS + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.CLOSE_CURLY_BRACKET + UtilConstants.NEW_LINE;
}
#method_after
public static String getToStringMethodClose() {
    return TWELVE_SPACE_INDENTATION + PERIOD + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
}
#end_block

#method_before
public static String getToStringMethod(AttributeInfo attr) {
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    if (attr.isListAttr()) {
        attributeName = attributeName + UtilConstants.SUFIX_S;
    }
    return UtilConstants.TWELVE_SPACE_INDENTATION + UtilConstants.PERIOD + UtilConstants.ADD_STRING + UtilConstants.OPEN_PARENTHESIS + UtilConstants.QUOTES + attributeName + UtilConstants.QUOTES + UtilConstants.COMMA + UtilConstants.SPACE + attributeName + UtilConstants.CLOSE_PARENTHESIS;
}
#method_after
public static String getToStringMethod(JavaAttributeInfo attr) {
    String attributeName = getLowerCase(attr.getAttributeName());
    return TWELVE_SPACE_INDENTATION + PERIOD + ADD_STRING + OPEN_PARENTHESIS + QUOTES + attributeName + QUOTES + COMMA + SPACE + attributeName + CLOSE_PARENTHESIS;
}
#end_block

#method_before
public static String getHashCodeMethodOpen() {
    return getOverRideString() + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.PUBLIC + UtilConstants.SPACE + UtilConstants.INT + UtilConstants.SPACE + UtilConstants.HASH_CODE_STRING + UtilConstants.OPEN_PARENTHESIS + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE + UtilConstants.EIGHT_SPACE_INDENTATION + UtilConstants.RETURN + UtilConstants.SPACE + UtilConstants.OBJECT_STRING + UtilConstants.SUFIX_S + UtilConstants.PERIOD + UtilConstants.HASH + UtilConstants.OPEN_PARENTHESIS;
}
#method_after
public static String getHashCodeMethodOpen() {
    return getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + INT + SPACE + HASH_CODE_STRING + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + OBJECT_STRING + SUFFIX_S + PERIOD + HASH + OPEN_PARENTHESIS;
}
#end_block

#method_before
public static String getHashCodeMethodClose(String hashcodeString) {
    hashcodeString = YangIoUtils.trimAtLast(hashcodeString, UtilConstants.COMMA);
    hashcodeString = YangIoUtils.trimAtLast(hashcodeString, UtilConstants.SPACE);
    return hashcodeString + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.CLOSE_CURLY_BRACKET + UtilConstants.NEW_LINE;
}
#method_after
public static String getHashCodeMethodClose(String hashcodeString) {
    hashcodeString = trimAtLast(hashcodeString, COMMA);
    hashcodeString = trimAtLast(hashcodeString, SPACE);
    return hashcodeString + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
}
#end_block

#method_before
public static String getHashCodeMethod(AttributeInfo attr) {
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    if (attr.isListAttr()) {
        attributeName = attributeName + UtilConstants.SUFIX_S;
    }
    return attributeName + UtilConstants.COMMA + UtilConstants.SPACE;
}
#method_after
public static String getHashCodeMethod(JavaAttributeInfo attr) {
    return getLowerCase(attr.getAttributeName()) + COMMA + SPACE;
}
#end_block

#method_before
public static String getEqualsMethodOpen(String className) {
    return getOverRideString() + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.PUBLIC + UtilConstants.SPACE + UtilConstants.BOOLEAN + UtilConstants.SPACE + UtilConstants.EQUALS_STRING + UtilConstants.OPEN_PARENTHESIS + UtilConstants.OBJECT_STRING + UtilConstants.SPACE + UtilConstants.OBJ + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE + getEqualsMethodsCommonIfCondition() + getEqualsMethodsSpecificIfCondition(className);
}
#method_after
public static String getEqualsMethodOpen(String className) {
    return getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + BOOLEAN_DATA_TYPE + SPACE + EQUALS_STRING + OPEN_PARENTHESIS + OBJECT_STRING + SPACE + OBJ + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + getEqualsMethodsCommonIfCondition() + getEqualsMethodsSpecificIfCondition(className);
}
#end_block

#method_before
private static String getEqualsMethodsCommonIfCondition() {
    return UtilConstants.EIGHT_SPACE_INDENTATION + UtilConstants.IF + UtilConstants.SPACE + UtilConstants.OPEN_PARENTHESIS + UtilConstants.THIS + UtilConstants.SPACE + UtilConstants.EQUAL + UtilConstants.EQUAL + UtilConstants.SPACE + UtilConstants.OBJ + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE + UtilConstants.TWELVE_SPACE_INDENTATION + UtilConstants.RETURN + UtilConstants.SPACE + UtilConstants.TRUE + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE + UtilConstants.EIGHT_SPACE_INDENTATION + UtilConstants.CLOSE_CURLY_BRACKET + UtilConstants.NEW_LINE;
}
#method_after
private static String getEqualsMethodsCommonIfCondition() {
    return EIGHT_SPACE_INDENTATION + IF + SPACE + OPEN_PARENTHESIS + THIS + SPACE + EQUAL + EQUAL + SPACE + OBJ + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + TWELVE_SPACE_INDENTATION + RETURN + SPACE + TRUE + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
}
#end_block

#method_before
private static String getEqualsMethodsSpecificIfCondition(String className) {
    return UtilConstants.EIGHT_SPACE_INDENTATION + UtilConstants.IF + UtilConstants.SPACE + UtilConstants.OPEN_PARENTHESIS + UtilConstants.OBJ + UtilConstants.INSTANCE_OF + className + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE + UtilConstants.TWELVE_SPACE_INDENTATION + className + UtilConstants.SPACE + UtilConstants.OTHER + UtilConstants.SPACE + UtilConstants.EQUAL + UtilConstants.SPACE + UtilConstants.OPEN_PARENTHESIS + className + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SPACE + UtilConstants.OBJ + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE + UtilConstants.TWELVE_SPACE_INDENTATION + UtilConstants.RETURN + UtilConstants.NEW_LINE;
}
#method_after
private static String getEqualsMethodsSpecificIfCondition(String className) {
    return EIGHT_SPACE_INDENTATION + IF + SPACE + OPEN_PARENTHESIS + OBJ + INSTANCE_OF + className + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + TWELVE_SPACE_INDENTATION + className + SPACE + OTHER + SPACE + EQUAL + SPACE + OPEN_PARENTHESIS + className + CLOSE_PARENTHESIS + SPACE + OBJ + SEMI_COLAN + NEW_LINE + TWELVE_SPACE_INDENTATION + RETURN + NEW_LINE;
}
#end_block

#method_before
public static String getEqualsMethodClose(String equalMethodString) {
    equalMethodString = YangIoUtils.trimAtLast(equalMethodString, UtilConstants.AND);
    equalMethodString = YangIoUtils.trimAtLast(equalMethodString, UtilConstants.AND);
    equalMethodString = YangIoUtils.trimAtLast(equalMethodString, UtilConstants.SPACE);
    equalMethodString = YangIoUtils.trimAtLast(equalMethodString, UtilConstants.NEW_LINE) + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE;
    return equalMethodString + UtilConstants.EIGHT_SPACE_INDENTATION + UtilConstants.CLOSE_CURLY_BRACKET + UtilConstants.NEW_LINE + UtilConstants.EIGHT_SPACE_INDENTATION + UtilConstants.RETURN + UtilConstants.SPACE + UtilConstants.FALSE + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.CLOSE_CURLY_BRACKET + UtilConstants.NEW_LINE;
}
#method_after
public static String getEqualsMethodClose(String equalMethodString) {
    equalMethodString = trimAtLast(equalMethodString, AND);
    equalMethodString = trimAtLast(equalMethodString, AND);
    equalMethodString = trimAtLast(equalMethodString, SPACE);
    equalMethodString = trimAtLast(equalMethodString, NEW_LINE) + SEMI_COLAN + NEW_LINE;
    return equalMethodString + EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + FALSE + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
}
#end_block

#method_before
public static String getEqualsMethod(AttributeInfo attr) {
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    if (attr.isListAttr()) {
        attributeName = attributeName + UtilConstants.SUFIX_S;
    }
    return UtilConstants.SIXTEEN_SPACE_INDENTATION + UtilConstants.SPACE + UtilConstants.OBJECT_STRING + UtilConstants.SUFIX_S + UtilConstants.PERIOD + UtilConstants.EQUALS_STRING + UtilConstants.OPEN_PARENTHESIS + attributeName + UtilConstants.COMMA + UtilConstants.SPACE + UtilConstants.OTHER + UtilConstants.PERIOD + attributeName + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SPACE + UtilConstants.AND + UtilConstants.AND;
}
#method_after
public static String getEqualsMethod(JavaAttributeInfo attr) {
    String attributeName = getLowerCase(attr.getAttributeName());
    return SIXTEEN_SPACE_INDENTATION + SPACE + OBJECT_STRING + SUFFIX_S + PERIOD + EQUALS_STRING + OPEN_PARENTHESIS + attributeName + COMMA + SPACE + OTHER + PERIOD + attributeName + CLOSE_PARENTHESIS + SPACE + AND + AND;
}
#end_block

#method_before
public static String getOfMethod(String name, AttributeInfo attr) {
    String attrQuaifiedType = getReturnType(attr);
    return UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.PUBLIC + UtilConstants.SPACE + UtilConstants.STATIC + UtilConstants.SPACE + name + UtilConstants.SPACE + UtilConstants.OF + UtilConstants.OPEN_PARENTHESIS + attrQuaifiedType + UtilConstants.SPACE + UtilConstants.VALUE + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE + UtilConstants.EIGHT_SPACE_INDENTATION + UtilConstants.RETURN + UtilConstants.SPACE + UtilConstants.NEW + UtilConstants.SPACE + name + UtilConstants.OPEN_PARENTHESIS + UtilConstants.VALUE + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.CLOSE_CURLY_BRACKET + UtilConstants.NEW_LINE;
}
#method_after
public static String getOfMethod(String name, JavaAttributeInfo attr) {
    String attrQuaifiedType = getReturnType(attr);
    return FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STATIC + SPACE + name + SPACE + OF + OPEN_PARENTHESIS + attrQuaifiedType + SPACE + VALUE + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + NEW + SPACE + name + OPEN_PARENTHESIS + VALUE + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
}
#end_block

#method_before
public static List<String> getJavaFiles(String root) throws NullPointerException, IOException {
    return getFiles(root, ".java");
}
#method_after
public static List<String> getJavaFiles(String root) throws NullPointerException, IOException {
    return getFiles(root, JAVA_FILE_EXTENTION);
}
#end_block

#method_before
public static List<String> getYangFiles(String root) throws NullPointerException, IOException {
    return getFiles(root, ".yang");
}
#method_after
public static List<String> getYangFiles(String root) throws NullPointerException, IOException {
    return getFiles(root, YANG_FILE_EXTENTION);
}
#end_block

#method_before
@Test
public void testForImportText() {
    ImportInfo importInfo = new ImportInfo();
    importInfo.setPkgInfo(PKG_INFO);
    importInfo.setClassInfo(CLASS_INFO);
    String imports = JavaCodeSnippetGen.getImportText(importInfo);
    assertThat(true, is(imports.equals(UtilConstants.IMPORT + PKG_INFO + UtilConstants.PERIOD + CLASS_INFO + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE)));
}
#method_after
@Test
public void testForImportText() {
    JavaQualifiedTypeInfo importInfo = new JavaQualifiedTypeInfo();
    importInfo.setPkgInfo(PKG_INFO);
    importInfo.setClassInfo(CLASS_INFO);
    String imports = getImportText(importInfo);
    assertThat(true, is(imports.equals(IMPORT + PKG_INFO + PERIOD + CLASS_INFO + SEMI_COLAN + NEW_LINE)));
}
#end_block

#method_before
@Test
public void testForJavaClassDefStart() {
    String classDef = JavaCodeSnippetGen.getJavaClassDefStart(FILE_GEN_TYPE, YANG_NAME);
    assertThat(true, is(classDef.equals(UtilConstants.PUBLIC + UtilConstants.SPACE + UtilConstants.INTERFACE + UtilConstants.SPACE + YANG_NAME + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE)));
}
#method_after
@Test
public void testForJavaClassDefStart() {
    String classDef = getJavaClassDefStart(FILE_GEN_TYPE, YANG_NAME);
    assertThat(true, is(classDef.equals(PUBLIC + SPACE + INTERFACE + SPACE + YANG_NAME + SPACE + OPEN_CURLY_BRACKET + NEW_LINE)));
}
#end_block

#method_before
@Test
public void testForListAttribute() {
    String listAttribute = JavaCodeSnippetGen.getListAttribute(STRING);
    assertThat(true, is(listAttribute.equals(UtilConstants.LIST + UtilConstants.DIAMOND_OPEN_BRACKET + STRING + UtilConstants.DIAMOND_CLOSE_BRACKET)));
}
#method_after
@Test
public void testForListAttribute() {
    String listAttribute = getListAttribute(STRING_DATA_TYPE);
    assertThat(true, is(listAttribute.equals(LIST + DIAMOND_OPEN_BRACKET + STRING_DATA_TYPE + DIAMOND_CLOSE_BRACKET)));
}
#end_block

#method_before
@Test
public void testForJavaAttributeInfo() {
    String attributeWithoutTypePkg = JavaCodeSnippetGen.getJavaAttributeDefination(null, UtilConstants.STRING, YANG_NAME, false);
    assertThat(true, is(attributeWithoutTypePkg.equals(UtilConstants.PRIVATE + UtilConstants.SPACE + UtilConstants.STRING + UtilConstants.SPACE + YANG_NAME + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE)));
    String attributeWithTypePkg = JavaCodeSnippetGen.getJavaAttributeDefination(UtilConstants.JAVA_LANG, UtilConstants.STRING, YANG_NAME, false);
    assertThat(true, is(attributeWithTypePkg.equals(UtilConstants.PRIVATE + UtilConstants.SPACE + UtilConstants.JAVA_LANG + UtilConstants.PERIOD + UtilConstants.STRING + UtilConstants.SPACE + YANG_NAME + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE)));
    String attributeWithListPkg = JavaCodeSnippetGen.getJavaAttributeDefination(UtilConstants.JAVA_LANG, UtilConstants.STRING, YANG_NAME, true);
    assertThat(true, is(attributeWithListPkg.equals(UtilConstants.PRIVATE + UtilConstants.SPACE + UtilConstants.LIST + UtilConstants.DIAMOND_OPEN_BRACKET + UtilConstants.JAVA_LANG + UtilConstants.PERIOD + UtilConstants.STRING + UtilConstants.DIAMOND_CLOSE_BRACKET + UtilConstants.SPACE + YANG_NAME + UtilConstants.SUFIX_S + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE)));
    String attributeWithListWithoutPkg = JavaCodeSnippetGen.getJavaAttributeDefination(null, UtilConstants.STRING, YANG_NAME, true);
    assertThat(true, is(attributeWithListWithoutPkg.equals(UtilConstants.PRIVATE + UtilConstants.SPACE + UtilConstants.LIST + UtilConstants.DIAMOND_OPEN_BRACKET + UtilConstants.STRING + UtilConstants.DIAMOND_CLOSE_BRACKET + UtilConstants.SPACE + YANG_NAME + UtilConstants.SUFIX_S + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE)));
}
#method_after
@Test
public void testForJavaAttributeInfo() {
    String attributeWithoutTypePkg = getJavaAttributeDefination(null, STRING_DATA_TYPE, YANG_NAME, false);
    assertThat(true, is(attributeWithoutTypePkg.equals(PRIVATE + SPACE + STRING_DATA_TYPE + SPACE + YANG_NAME + SEMI_COLAN + NEW_LINE)));
    String attributeWithTypePkg = getJavaAttributeDefination(JAVA_LANG, STRING_DATA_TYPE, YANG_NAME, false);
    assertThat(true, is(attributeWithTypePkg.equals(PRIVATE + SPACE + JAVA_LANG + PERIOD + STRING_DATA_TYPE + SPACE + YANG_NAME + SEMI_COLAN + NEW_LINE)));
    String attributeWithListPkg = getJavaAttributeDefination(JAVA_LANG, STRING_DATA_TYPE, YANG_NAME, true);
    assertThat(true, is(attributeWithListPkg.equals(PRIVATE + SPACE + LIST + DIAMOND_OPEN_BRACKET + JAVA_LANG + PERIOD + STRING_DATA_TYPE + DIAMOND_CLOSE_BRACKET + SPACE + YANG_NAME + SEMI_COLAN + NEW_LINE)));
    String attributeWithListWithoutPkg = getJavaAttributeDefination(null, STRING_DATA_TYPE, YANG_NAME, true);
    assertThat(true, is(attributeWithListWithoutPkg.equals(PRIVATE + SPACE + LIST + DIAMOND_OPEN_BRACKET + STRING_DATA_TYPE + DIAMOND_CLOSE_BRACKET + SPACE + YANG_NAME + SEMI_COLAN + NEW_LINE)));
}
#end_block

#method_before
@Test
public void buildGenerationTest() {
    String buildDoc = JavaDocGen.getJavaDoc(JavaDocType.BUILD, "testGeneration1", false);
    assertTrue(buildDoc.contains("Builds object of") && buildDoc.contains(" */\n"));
}
#method_after
@Test
public void buildGenerationTest() {
    String buildDoc = JavaDocGen.getJavaDoc(JavaDocType.BUILD_METHOD, "testGeneration1", false);
    assertTrue(buildDoc.contains("Builds object of") && buildDoc.contains(" */\n"));
}
#end_block

#method_before
@Test
public void getterGenerationTest() {
    String getterJavaDoc = JavaDocGen.getJavaDoc(JavaDocType.GETTER, "testGeneration1", false);
    assertTrue(getterJavaDoc.contains("Returns the attribute") && getterJavaDoc.contains(" */\n"));
}
#method_after
@Test
public void getterGenerationTest() {
    String getterJavaDoc = JavaDocGen.getJavaDoc(JavaDocType.GETTER_METHOD, "testGeneration1", false);
    assertTrue(getterJavaDoc.contains("Returns the attribute") && getterJavaDoc.contains(" */\n"));
}
#end_block

#method_before
@Test
public void setterGenerationTest() {
    String setterJavaDoc = JavaDocGen.getJavaDoc(JavaDocType.SETTER, "testGeneration1", false);
    assertTrue(setterJavaDoc.contains("Returns the builder object of") && setterJavaDoc.contains(" */\n"));
}
#method_after
@Test
public void setterGenerationTest() {
    String setterJavaDoc = JavaDocGen.getJavaDoc(JavaDocType.SETTER_METHOD, "testGeneration1", false);
    assertTrue(setterJavaDoc.contains("Returns the builder object of") && setterJavaDoc.contains(" */\n"));
}
#end_block

#method_before
@Test
public void typeDefSetterGenerationTest() {
    String typeDefSetter = JavaDocGen.getJavaDoc(JavaDocType.TYPE_DEF_SETTER, "testGeneration1", false);
    assertTrue(typeDefSetter.contains("Sets the value of") && typeDefSetter.contains(" */\n"));
}
#method_after
@Test
public void typeDefSetterGenerationTest() {
    String typeDefSetter = JavaDocGen.getJavaDoc(JavaDocType.TYPE_DEF_SETTER_METHOD, "testGeneration1", false);
    assertTrue(typeDefSetter.contains("Sets the value of") && typeDefSetter.contains(" */\n"));
}
#end_block

#method_before
public static boolean doesPackageExist(String pkg) {
    File pkgDir = new File(pkg.replace(UtilConstants.PERIOD, UtilConstants.SLASH));
    File pkgWithFile = new File(pkgDir + File.separator + "package-info.java");
    if (pkgDir.exists() && pkgWithFile.isFile()) {
        return true;
    }
    return false;
}
#method_after
public static boolean doesPackageExist(String pkg) {
    File pkgDir = new File(convertPkgToPath(pkg));
    File pkgWithFile = new File(pkgDir + SLASH + "package-info.java");
    if (pkgDir.exists() && pkgWithFile.isFile()) {
        return true;
    }
    return false;
}
#end_block

#method_before
public static void createPackage(String pkg, String pkgInfo) throws IOException {
    if (!doesPackageExist(pkg)) {
        try {
            File pack = YangIoUtils.createDirectories(pkg.replace(UtilConstants.PERIOD, UtilConstants.SLASH));
            YangIoUtils.addPackageInfo(pack, pkgInfo, pkg);
        } catch (IOException e) {
            throw new IOException("failed to create package-info file");
        }
    }
}
#method_after
public static void createPackage(String pkg, String pkgInfo) throws IOException {
    if (!doesPackageExist(pkg)) {
        try {
            File pack = createDirectories(pkg);
            addPackageInfo(pack, pkgInfo, convertPathToPkg(pkg));
        } catch (IOException e) {
            throw new IOException("failed to create package-info file");
        }
    }
}
#end_block

#method_before
public static void appendFileContents(File toAppend, File srcFile) throws IOException {
    updateFileHandle(srcFile, UtilConstants.NEW_LINE + readAppendFile(toAppend.toString(), UtilConstants.FOUR_SPACE_INDENTATION), false);
    return;
}
#method_after
public static void appendFileContents(File toAppend, File srcFile) throws IOException {
    updateFileHandle(srcFile, NEW_LINE + readAppendFile(toAppend.toString(), FOUR_SPACE_INDENTATION), false);
    return;
}
#end_block

#method_before
public static String readAppendFile(String toAppend, String spaces) throws IOException {
    FileReader fileReader = new FileReader(toAppend);
    BufferedReader bufferReader = new BufferedReader(fileReader);
    try {
        StringBuilder stringBuilder = new StringBuilder();
        String line = bufferReader.readLine();
        while (line != null) {
            if (line.equals(UtilConstants.SPACE) | line.equals(UtilConstants.EMPTY_STRING) | line.equals(UtilConstants.EIGHT_SPACE_INDENTATION) | line.equals(UtilConstants.MULTIPLE_NEW_LINE)) {
                stringBuilder.append(UtilConstants.NEW_LINE);
            } else if (line.equals(UtilConstants.FOUR_SPACE_INDENTATION)) {
                stringBuilder.append(UtilConstants.EMPTY_STRING);
            } else {
                stringBuilder.append(spaces + line);
                stringBuilder.append(UtilConstants.NEW_LINE);
            }
            line = bufferReader.readLine();
        }
        return stringBuilder.toString();
    } finally {
        fileReader.close();
        bufferReader.close();
    }
}
#method_after
public static String readAppendFile(String toAppend, String spaces) throws IOException {
    FileReader fileReader = new FileReader(toAppend);
    BufferedReader bufferReader = new BufferedReader(fileReader);
    try {
        StringBuilder stringBuilder = new StringBuilder();
        String line = bufferReader.readLine();
        while (line != null) {
            if (line.equals(SPACE) | line.equals(EMPTY_STRING) | line.equals(EIGHT_SPACE_INDENTATION) | line.equals(MULTIPLE_NEW_LINE)) {
                stringBuilder.append(NEW_LINE);
            } else if (line.equals(FOUR_SPACE_INDENTATION)) {
                stringBuilder.append(EMPTY_STRING);
            } else {
                stringBuilder.append(spaces + line);
                stringBuilder.append(NEW_LINE);
            }
            line = bufferReader.readLine();
        }
        return stringBuilder.toString();
    } finally {
        fileReader.close();
        bufferReader.close();
    }
}
#end_block

#method_before
@Test
public void updateFileHandleTest() throws IOException {
    File dir = new File(baseDir + File.separator + "File1");
    dir.mkdirs();
    File createFile = new File(dir + "testFile");
    createFile.createNewFile();
    File createSourceFile = new File(dir + "sourceTestFile");
    createSourceFile.createNewFile();
    FileSystemUtil.updateFileHandle(createFile, "This is to append a text to the file first1\n", false);
    FileSystemUtil.updateFileHandle(createFile, "This is next second line\n", false);
    FileSystemUtil.updateFileHandle(createFile, "This is next third line in the file", false);
    FileSystemUtil.appendFileContents(createFile, createSourceFile);
    FileSystemUtil.updateFileHandle(createFile, null, true);
}
#method_after
@Test
public void updateFileHandleTest() throws IOException {
    File dir = new File(BASE_PKG + File.separator + "File1");
    dir.mkdirs();
    File createFile = new File(dir + "testFile");
    createFile.createNewFile();
    File createSourceFile = new File(dir + "sourceTestFile");
    createSourceFile.createNewFile();
    FileSystemUtil.updateFileHandle(createFile, TEST_DATA_1, false);
    FileSystemUtil.updateFileHandle(createFile, TEST_DATA_2, false);
    FileSystemUtil.updateFileHandle(createFile, TEST_DATA_3, false);
    FileSystemUtil.appendFileContents(createFile, createSourceFile);
    FileSystemUtil.updateFileHandle(createFile, null, true);
}
#end_block

#method_before
@Test
public void packageExistTest() throws IOException {
    String dirPath = "exist1.exist2.exist3";
    String strPath = baseDirPkg + dirPath;
    File createDir = new File(strPath.replace(UtilConstants.PERIOD, UtilConstants.SLASH));
    createDir.mkdirs();
    File createFile = new File(createDir + File.separator + "package-info.java");
    createFile.createNewFile();
    assertTrue(FileSystemUtil.doesPackageExist(strPath));
    FileSystemUtil.createPackage(strPath, packageInfoContent);
    createDir.delete();
}
#method_after
@Test
public void packageExistTest() throws IOException {
    String dirPath = "exist1.exist2.exist3";
    String strPath = BASE_DIR_PKG + dirPath;
    File createDir = new File(strPath.replace(UtilConstants.PERIOD, UtilConstants.SLASH));
    createDir.mkdirs();
    File createFile = new File(createDir + File.separator + "package-info.java");
    createFile.createNewFile();
    assertTrue(FileSystemUtil.doesPackageExist(strPath));
    FileSystemUtil.createPackage(strPath, PKG_INFO_CONTENT);
    createDir.delete();
}
#end_block

#method_before
public static File generateInterfaceFile(File file, String className, List<String> imports, List<AttributeInfo> attrList, String pkg, CachedFileHandle handle) throws IOException {
    String path = handle.getBaseDirPath() + pkg.replace(UtilConstants.PERIOD, UtilConstants.SLASH);
    initiateFile(file, className, INTERFACE_MASK, imports, pkg);
    if (!attrList.isEmpty()) {
        List<String> methods = new ArrayList<>();
        try {
            methods.add(handle.getTempData(TempDataStoreTypes.GETTER_METHODS, className, path));
        } catch (ClassNotFoundException | IOException e) {
            log.info("There is no attribute info of " + className + " YANG file in the temporary files.");
            throw new IOException("Fail to read data from temp file.");
        }
        /**
         * Add getter methods to interface file.
         */
        for (String method : methods) {
            appendMethod(file, method);
        }
    }
    return file;
}
#method_after
public static File generateInterfaceFile(File file, List<String> imports, YangNode curNode) throws IOException {
    JavaFileInfo javaFileInfo = ((HasJavaFileInfo) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, INTERFACE_MASK, imports, path);
    /**
     * Add getter methods to interface file.
     */
    try {
        /**
         * Getter methods.
         */
        insertDataIntoJavaFile(file, getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, curNode));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while interface file generation");
    }
    return file;
}
#end_block

#method_before
public static File generateBuilderInterfaceFile(File file, String className, String pkg, List<AttributeInfo> attrList, CachedFileHandle handle) throws IOException {
    String path = handle.getBaseDirPath() + pkg.replace(UtilConstants.PERIOD, UtilConstants.SLASH);
    initiateFile(file, className, BUILDER_INTERFACE_MASK, null, pkg);
    List<String> methods = new ArrayList<>();
    if (!attrList.isEmpty()) {
        try {
            methods.add(UtilConstants.FOUR_SPACE_INDENTATION + handle.getTempData(TempDataStoreTypes.GETTER_METHODS, className, path));
            methods.add(UtilConstants.NEW_LINE);
            methods.add(UtilConstants.FOUR_SPACE_INDENTATION + handle.getTempData(TempDataStoreTypes.SETTER_METHODS, className, path));
        } catch (ClassNotFoundException | IOException e) {
            log.info("There is no attribute info of " + className + " YANG file in the temporary files.");
            throw new IOException("Fail to read data from temp file.");
        }
    }
    /**
     * Add build method to builder interface file.
     */
    methods.add(MethodsGenerator.parseBuilderInterfaceBuildMethodString(className));
    /**
     * Add getters and setters in builder interface.
     */
    for (String method : methods) {
        appendMethod(file, method);
    }
    insert(file, UtilConstants.CLOSE_CURLY_BRACKET + UtilConstants.NEW_LINE);
    return file;
}
#method_after
public static File generateBuilderInterfaceFile(File file, YangNode curNode) throws IOException {
    JavaFileInfo javaFileInfo = ((HasJavaFileInfo) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, BUILDER_INTERFACE_MASK, null, path);
    List<String> methods = new ArrayList<>();
    try {
        /**
         * Getter methods.
         */
        methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, curNode));
        /**
         * Setter methods.
         */
        methods.add(NEW_LINE);
        methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(SETTER_FOR_INTERFACE_MASK, curNode));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while builder interface file generation");
    }
    /**
     * Add build method to builder interface file.
     */
    methods.add(((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().addBuildMethodForInterface());
    /**
     * Add getters and setters in builder interface.
     */
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#end_block

#method_before
public static File generateBuilderClassFile(File file, String className, List<String> imports, String pkg, List<AttributeInfo> attrList, CachedFileHandle handle) throws IOException {
    String path = handle.getBaseDirPath() + pkg.replace(UtilConstants.PERIOD, UtilConstants.SLASH);
    initiateFile(file, className, BUILDER_CLASS_MASK, imports, pkg);
    List<String> methods = new ArrayList<>();
    if (!attrList.isEmpty()) {
        /**
         * Add attribute strings.
         */
        List<String> attributes = new ArrayList<>();
        try {
            attributes.add(handle.getTempData(TempDataStoreTypes.ATTRIBUTE, className, path));
        } catch (ClassNotFoundException | IOException e) {
            log.info("There is no attribute info of " + className + " YANG file in the temporary files.");
            throw new IOException("Fail to read data from temp file.");
        }
        /**
         * Add attributes to the file.
         */
        for (String attribute : attributes) {
            insert(file, UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + attribute);
        }
        try {
            methods.add(YangIoUtils.deleteLastChar(handle.getTempData(TempDataStoreTypes.GETTER_METHODS_IMPL, className, path) + UtilConstants.NEW_LINE));
            methods.add(handle.getTempData(TempDataStoreTypes.SETTER_METHODS_IMPL, className, path) + UtilConstants.NEW_LINE);
        } catch (ClassNotFoundException | IOException e) {
            log.info("There is no attribute info of " + className + " YANG file in the temporary files.");
            throw new IOException("Fail to read data from temp file.");
        }
    }
    /**
     * Add default constructor and build method impl.
     */
    methods.add(MethodsGenerator.getBuildString(className) + UtilConstants.NEW_LINE);
    methods.add(UtilConstants.NEW_LINE + MethodsGenerator.getDefaultConstructorString(className + UtilConstants.BUILDER, UtilConstants.PUBLIC));
    /**
     * Add methods in builder class.
     */
    for (String method : methods) {
        appendMethod(file, method);
    }
    return file;
}
#method_after
public static File generateBuilderClassFile(File file, List<String> imports, YangNode curNode) throws IOException {
    JavaFileInfo javaFileInfo = ((HasJavaFileInfo) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, BUILDER_CLASS_MASK, imports, path);
    List<String> methods = new ArrayList<>();
    /**
     * Add attribute strings.
     */
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, curNode));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while builder class file generation");
    }
    try {
        /**
         * Getter methods.
         */
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, curNode));
        /**
         * Setter methods.
         */
        methods.add(getDataFromTempFileHandle(SETTER_FOR_CLASS_MASK, curNode) + NEW_LINE);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while builder class file generation");
    }
    /**
     * Add default constructor and build method impl.
     */
    methods.add(((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().addBuildMethodImpl());
    methods.add(((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PUBLIC, BUILDER));
    /**
     * Add methods in builder class.
     */
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#end_block

#method_before
public static File generateImplClassFile(File file, String className, String pkg, List<AttributeInfo> attrList, CachedFileHandle handle) throws IOException {
    String path = handle.getBaseDirPath() + pkg.replace(UtilConstants.PERIOD, UtilConstants.SLASH);
    initiateFile(file, className, IMPL_CLASS_MASK, null, path);
    List<String> methods = new ArrayList<>();
    if (!attrList.isEmpty()) {
        List<String> attributes = new ArrayList<>();
        try {
            attributes.add(handle.getTempData(TempDataStoreTypes.ATTRIBUTE, className, path));
        } catch (ClassNotFoundException | IOException e) {
            log.info("There is no attribute info of " + className + " YANG file in the temporary files.");
            throw new IOException("Fail to read data from temp file.");
        }
        /**
         * Add attributes to the file.
         */
        for (String attribute : attributes) {
            insert(file, UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + attribute);
        }
        insert(file, UtilConstants.NEW_LINE);
        try {
            methods.add(handle.getTempData(TempDataStoreTypes.GETTER_METHODS_IMPL, className, path));
            methods.add(MethodsGenerator.getHashCodeMethodClose(MethodsGenerator.getHashCodeMethodOpen() + YangIoUtils.partString(handle.getTempData(TempDataStoreTypes.HASH_CODE, className, path).replace(UtilConstants.NEW_LINE, ""))));
            methods.add(MethodsGenerator.getEqualsMethodClose(MethodsGenerator.getEqualsMethodOpen(className + UtilConstants.IMPL) + handle.getTempData(TempDataStoreTypes.EQUALS, className, path)));
            methods.add(MethodsGenerator.getToStringMethodOpen() + handle.getTempData(TempDataStoreTypes.TO_STRING, className, path) + MethodsGenerator.getToStringMethodClose());
        } catch (ClassNotFoundException | IOException e) {
            log.info("There is no attribute info of " + className + " YANG file in the temporary files.");
            throw new IOException("Fail to read data from temp file.");
        }
    }
    try {
        methods.add(MethodsGenerator.getConstructorStart(className) + handle.getTempData(TempDataStoreTypes.CONSTRUCTOR, className, path) + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.CLOSE_CURLY_BRACKET);
    } catch (ClassNotFoundException | IOException e) {
        log.info("There is no attribute info of " + className + " YANG file in the temporary files.");
        throw new IOException("Fail to read data from temp file.");
    }
    /**
     * Add methods in impl class.
     */
    for (String method : methods) {
        appendMethod(file, UtilConstants.FOUR_SPACE_INDENTATION + method + UtilConstants.NEW_LINE);
    }
    insert(file, UtilConstants.CLOSE_CURLY_BRACKET + UtilConstants.NEW_LINE);
    return file;
}
#method_after
public static File generateImplClassFile(File file, YangNode curNode) throws IOException {
    JavaFileInfo javaFileInfo = ((HasJavaFileInfo) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, IMPL_CLASS_MASK, null, path);
    List<String> methods = new ArrayList<>();
    /**
     * Add attribute strings.
     */
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, curNode));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
    }
    insertDataIntoJavaFile(file, NEW_LINE);
    try {
        /**
         * Getter methods.
         */
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, curNode));
        /**
         * Hash code method.
         */
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + partString(getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, curNode).replace(NEW_LINE, EMPTY_STRING))));
        /**
         * Equals method.
         */
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + IMPL) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, curNode)));
        /**
         * To string method.
         */
        methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, curNode) + getToStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
    }
    try {
        /**
         * Constructor.
         */
        methods.add(getConstructorStart(className) + getDataFromTempFileHandle(CONSTRUCTOR_IMPL_MASK, curNode) + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
    }
    /**
     * Add methods in impl class.
     */
    for (String method : methods) {
        insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + method + NEW_LINE);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#end_block

#method_before
public static File generateTypeDefClassFile(File file, String className, List<String> imports, String pkg, List<AttributeInfo> cachedAttributeList, CachedFileHandle handle) throws IOException {
    String path = handle.getBaseDirPath() + pkg.replace(UtilConstants.PERIOD, UtilConstants.SLASH);
    initiateFile(file, className, GENERATE_TYPEDEF_CLASS, imports, pkg);
    List<String> typeDef = new ArrayList<>();
    try {
        typeDef.add(handle.getTempData(TempDataStoreTypes.TYPE_DEF, className, path));
    } catch (ClassNotFoundException | IOException e) {
        log.info("There is no attribute info of " + className + " YANG file in the temporary files.");
        throw new IOException("Fail to read data from temp file.");
    }
    /**
     * Add attributes to the file.
     */
    for (String attribute : typeDef) {
        insert(file, UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + attribute);
    }
    return file;
}
#method_after
public static File generateTypeDefClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfo javaFileInfo = ((HasJavaFileInfo) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, GENERATE_TYPEDEF_CLASS, imports, path);
    List<String> methods = new ArrayList<>();
    /**
     * Add attribute strings.
     */
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, curNode));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file generation");
    }
    /**
     * Default constructor.
     */
    methods.add(((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING));
    /**
     * Constructor.
     */
    methods.add(((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().addTypeDefConstructor());
    /**
     * Of method.
     */
    methods.add(((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().addOfMethod());
    try {
        /**
         * Getter method.
         */
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, curNode));
        /**
         * Setter method.
         */
        methods.add(((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().addTypeDefsSetter());
        /**
         * Hash code method.
         */
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + partString(getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, curNode).replace(NEW_LINE, EMPTY_STRING))));
        /**
         * Equals method.
         */
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, curNode)));
        /**
         * To string method.
         */
        methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, curNode) + getToStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while tyoe def class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#end_block

#method_before
public static void parseCopyrightHeader() throws IOException {
    File temp = new File("temp.txt");
    try {
        InputStream stream = classLoader.getResourceAsStream("CopyrightHeader.txt");
        OutputStream out = new FileOutputStream(temp);
        int index;
        while ((index = stream.read()) != EOF) {
            out.write(index);
        }
        out.close();
        stream.close();
        getStringFileContent(temp);
        setCopyrightHeader(getStringFileContent(temp));
    } catch (IOException e) {
        throw new IOException("failed to parse the Copyright header");
    } finally {
        temp.delete();
    }
}
#method_after
public static void parseCopyrightHeader() throws IOException {
    File temp = new File(TEMP_FILE);
    try {
        InputStream stream = classLoader.getResourceAsStream(COPYRIGHT_HEADER_FILE);
        OutputStream out = new FileOutputStream(temp);
        int index;
        while ((index = stream.read()) != EOF) {
            out.write(index);
        }
        out.close();
        stream.close();
        getStringFileContent(temp);
        setCopyrightHeader(getStringFileContent(temp));
    } catch (IOException e) {
        throw new IOException("failed to parse the Copyright header");
    } finally {
        temp.delete();
    }
}
#end_block

#method_before
private static String getStringFileContent(File toAppend) throws IOException {
    BufferedReader bufferReader = new BufferedReader(new FileReader(toAppend));
    try {
        StringBuilder stringBuilder = new StringBuilder();
        String line = bufferReader.readLine();
        while (line != null) {
            stringBuilder.append(line);
            stringBuilder.append("\n");
            line = bufferReader.readLine();
        }
        return stringBuilder.toString();
    } finally {
        bufferReader.close();
    }
}
#method_after
private static String getStringFileContent(File toAppend) throws IOException {
    FileReader fileReader = new FileReader(toAppend);
    BufferedReader bufferReader = new BufferedReader(fileReader);
    try {
        StringBuilder stringBuilder = new StringBuilder();
        String line = bufferReader.readLine();
        while (line != null) {
            stringBuilder.append(line);
            stringBuilder.append(NEW_LINE);
            line = bufferReader.readLine();
        }
        return stringBuilder.toString();
    } finally {
        fileReader.close();
        bufferReader.close();
    }
}
#end_block

#method_before
@Override
public void execute() throws MojoExecutionException, MojoFailureException {
    try {
        /**
         * For deleting the generated code in previous build.
         */
        YangIoUtils.clean(YangIoUtils.getDirectory(baseDir, genFilesDir) + File.separator + UtilConstants.DEFAULT_BASE_PKG.replace(UtilConstants.PERIOD, UtilConstants.SLASH));
        YangIoUtils.clean(YangIoUtils.getDirectory(baseDir, outputDirectory));
        searchDir = YangIoUtils.getDirectory(baseDir, yangFilesDir);
        codeGenDir = YangIoUtils.getDirectory(baseDir, genFilesDir) + File.separator;
        List<String> yangFiles = YangFileScanner.getYangFiles(searchDir);
        Iterator<String> yangFileIterator = yangFiles.iterator();
        while (yangFileIterator.hasNext()) {
            String yangFile = yangFileIterator.next();
            try {
                YangNode yangNode = yangUtilsParser.getDataModel(yangFile);
                JavaCodeGenerator.generateJavaCode(yangNode, codeGenDir);
            } catch (ParserException e) {
                String logInfo = "Error in file: " + e.getFileName();
                if (e.getLineNumber() != 0) {
                    logInfo = logInfo + " at line: " + e.getLineNumber() + " at position: " + e.getCharPositionInLine();
                }
                if (e.getMessage() != null) {
                    logInfo = logInfo + "\n" + e.getMessage();
                }
                getLog().info(logInfo);
            }
        }
        YangIoUtils.addToSource(YangIoUtils.getDirectory(baseDir, genFilesDir) + File.separator + UtilConstants.DEFAULT_BASE_PKG.replace(UtilConstants.PERIOD, UtilConstants.SLASH), project, context);
        YangIoUtils.copyYangFilesToTarget(yangFiles, YangIoUtils.getDirectory(baseDir, outputDirectory), project);
    } catch (Exception e) {
        getLog().info(e);
    }
}
#method_after
@Override
public void execute() throws MojoExecutionException, MojoFailureException {
    try {
        /**
         * For deleting the generated code in previous build.
         */
        clean(getDirectory(baseDir, genFilesDir) + DEFAULT_PKG);
        clean(getDirectory(baseDir, outputDirectory));
        searchDir = getDirectory(baseDir, yangFilesDir);
        codeGenDir = getDirectory(baseDir, genFilesDir) + SLASH;
        List<String> yangFiles = YangFileScanner.getYangFiles(searchDir);
        Iterator<String> yangFileIterator = yangFiles.iterator();
        while (yangFileIterator.hasNext()) {
            String yangFile = yangFileIterator.next();
            try {
                YangNode yangNode = yangUtilsParser.getDataModel(yangFile);
                generateJavaCode(yangNode, codeGenDir);
            } catch (ParserException e) {
                String logInfo = "Error in file: " + e.getFileName();
                if (e.getLineNumber() != 0) {
                    logInfo = logInfo + " at line: " + e.getLineNumber() + " at position: " + e.getCharPositionInLine();
                }
                if (e.getMessage() != null) {
                    logInfo = logInfo + NEW_LINE + e.getMessage();
                }
                getLog().info(logInfo);
            }
        }
        addToSource(getDirectory(baseDir, genFilesDir) + DEFAULT_PKG, project, context);
        copyYangFilesToTarget(yangFiles, getDirectory(baseDir, outputDirectory), project);
    } catch (Exception e) {
        getLog().info(e);
        throw new MojoExecutionException("Exception occured due to " + e.getLocalizedMessage());
    }
}
#end_block

#method_before
public static String getImportText(ImportInfo importInfo) {
    return UtilConstants.IMPORT + importInfo.getPkgInfo() + UtilConstants.PERIOD + importInfo.getClassInfo() + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE;
}
#method_after
public static String getImportText(JavaQualifiedTypeInfo importInfo) {
    return IMPORT + importInfo.getPkgInfo() + PERIOD + importInfo.getClassInfo() + SEMI_COLAN + NEW_LINE;
}
#end_block

#method_before
public static String getJavaClassDefStart(int genFileTypes, String yangName) {
    /*
         * get the camel case name for java class / interface.
         */
    yangName = JavaIdentifierSyntax.getCamelCase(yangName);
    return ClassDefinitionGenerator.generateClassDefinition(genFileTypes, yangName);
}
#method_after
public static String getJavaClassDefStart(int genFileTypes, String yangName) {
    /*
         * get the camel case name for java class / interface.
         */
    yangName = getCamelCase(yangName);
    return generateClassDefinition(genFileTypes, yangName);
}
#end_block

#method_before
public static String getJavaAttributeDefination(String javaAttributeTypePkg, String javaAttributeType, String javaAttributeName, boolean isList) {
    String attributeDefination = UtilConstants.PRIVATE + UtilConstants.SPACE;
    if (!isList) {
        if (javaAttributeTypePkg != null) {
            attributeDefination = attributeDefination + javaAttributeTypePkg + UtilConstants.PERIOD;
        }
        attributeDefination = attributeDefination + javaAttributeType + UtilConstants.SPACE + javaAttributeName + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE;
    } else {
        attributeDefination = attributeDefination + UtilConstants.LIST + UtilConstants.DIAMOND_OPEN_BRACKET;
        if (javaAttributeTypePkg != null) {
            attributeDefination = attributeDefination + javaAttributeTypePkg + UtilConstants.PERIOD;
        }
        attributeDefination = attributeDefination + javaAttributeType + UtilConstants.DIAMOND_CLOSE_BRACKET + UtilConstants.SPACE + javaAttributeName + UtilConstants.SUFIX_S + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE;
    }
    return attributeDefination;
}
#method_after
public static String getJavaAttributeDefination(String javaAttributeTypePkg, String javaAttributeType, String javaAttributeName, boolean isList) {
    String attributeDefination = PRIVATE + SPACE;
    if (!isList) {
        if (javaAttributeTypePkg != null) {
            attributeDefination = attributeDefination + javaAttributeTypePkg + PERIOD;
        }
        attributeDefination = attributeDefination + javaAttributeType + SPACE + javaAttributeName + SEMI_COLAN + NEW_LINE;
    } else {
        attributeDefination = attributeDefination + LIST + DIAMOND_OPEN_BRACKET;
        if (javaAttributeTypePkg != null) {
            attributeDefination = attributeDefination + javaAttributeTypePkg + PERIOD;
        }
        attributeDefination = attributeDefination + javaAttributeType + DIAMOND_CLOSE_BRACKET + SPACE + javaAttributeName + SEMI_COLAN + NEW_LINE;
    }
    return attributeDefination;
}
#end_block

#method_before
public static String getListAttribute(String type) {
    return UtilConstants.LIST + UtilConstants.DIAMOND_OPEN_BRACKET + type + UtilConstants.DIAMOND_CLOSE_BRACKET;
}
#method_after
public static String getListAttribute(String type) {
    return LIST + DIAMOND_OPEN_BRACKET + type + DIAMOND_CLOSE_BRACKET;
}
#end_block

#method_before
public static String getJavaClassDefClose() {
    return UtilConstants.CLOSE_CURLY_BRACKET;
}
#method_after
public static String getJavaClassDefClose() {
    return CLOSE_CURLY_BRACKET;
}
#end_block

#method_before
@GET
@Path("messages")
@Produces(MediaType.APPLICATION_JSON)
public Response controlMessageMetrics() {
    ArrayNode deviceNodes = root.putArray("devices");
    monitorService.availableResources(ControlResource.Type.CONTROL_MESSAGE).forEach(name -> {
        ObjectNode deviceNode = mapper().createObjectNode();
        ObjectNode valueNode = mapper().createObjectNode();
        metricsStats(monitorService, localNodeId, CONTROL_MESSAGE_METRICS, DeviceId.deviceId(name), valueNode);
        deviceNode.put("name", name);
        deviceNode.set("value", valueNode);
        deviceNodes.add(deviceNode);
    });
    return ok(root).build();
}
#method_after
@GET
@Path("messages")
@Produces(MediaType.APPLICATION_JSON)
public Response controlMessageMetrics() {
    ArrayNode deviceNodes = root.putArray("devices");
    monitorService.availableResources(CONTROL_MESSAGE).forEach(name -> {
        ObjectNode deviceNode = mapper().createObjectNode();
        ObjectNode valueNode = mapper().createObjectNode();
        metricsStats(monitorService, localNodeId, CONTROL_MESSAGE_METRICS, DeviceId.deviceId(name), valueNode);
        deviceNode.put("name", name);
        deviceNode.set("value", valueNode);
        deviceNodes.add(deviceNode);
    });
    return ok(root).build();
}
#end_block

#method_before
@GET
@Path("disk_metrics")
@Produces(MediaType.APPLICATION_JSON)
public Response diskMetrics() {
    ArrayNode diskNodes = root.putArray("disks");
    monitorService.availableResources(ControlResource.Type.DISK).forEach(name -> {
        ObjectNode diskNode = mapper().createObjectNode();
        ObjectNode valueNode = mapper().createObjectNode();
        metricsStats(monitorService, localNodeId, DISK_METRICS, name, valueNode);
        diskNode.put("name", name);
        diskNode.set("value", valueNode);
        diskNodes.add(diskNode);
    });
    return ok(root).build();
}
#method_after
@GET
@Path("disk_metrics")
@Produces(MediaType.APPLICATION_JSON)
public Response diskMetrics() {
    ArrayNode diskNodes = root.putArray("disks");
    monitorService.availableResources(DISK).forEach(name -> {
        ObjectNode diskNode = mapper().createObjectNode();
        ObjectNode valueNode = mapper().createObjectNode();
        metricsStats(monitorService, localNodeId, DISK_METRICS, name, valueNode);
        diskNode.put("name", name);
        diskNode.set("value", valueNode);
        diskNodes.add(diskNode);
    });
    return ok(root).build();
}
#end_block

#method_before
@GET
@Path("network_metrics")
@Produces(MediaType.APPLICATION_JSON)
public Response networkMetrics() {
    ArrayNode networkNodes = root.putArray("networks");
    monitorService.availableResources(ControlResource.Type.NETWORK).forEach(name -> {
        ObjectNode networkNode = mapper().createObjectNode();
        ObjectNode valueNode = mapper().createObjectNode();
        metricsStats(monitorService, localNodeId, NETWORK_METRICS, name, valueNode);
        networkNode.put("name", name);
        networkNode.set("value", valueNode);
        networkNodes.add(networkNode);
    });
    return ok(root).build();
}
#method_after
@GET
@Path("network_metrics")
@Produces(MediaType.APPLICATION_JSON)
public Response networkMetrics() {
    ArrayNode networkNodes = root.putArray("networks");
    monitorService.availableResources(NETWORK).forEach(name -> {
        ObjectNode networkNode = mapper().createObjectNode();
        ObjectNode valueNode = mapper().createObjectNode();
        metricsStats(monitorService, localNodeId, NETWORK_METRICS, name, valueNode);
        networkNode.put("name", name);
        networkNode.set("value", valueNode);
        networkNodes.add(networkNode);
    });
    return ok(root).build();
}
#end_block

#method_before
@Test
public void balanceWithRegion2() {
    // set up region - 2 sets of masters with (3 nodes, 1 node)
    Set<NodeId> masterSet1 = ImmutableSet.of(NID1, NID3, NID4);
    Set<NodeId> masterSet2 = ImmutableSet.of(NID2);
    List<Set<NodeId>> masters = ImmutableList.of(masterSet1, masterSet2);
    Region r = regionManager.createRegion(RID1, "R1", METRO, masters);
    Set<DeviceId> deviceIdsOrig = ImmutableSet.of(DID1, DID2);
    regionManager.addDevices(RID1, deviceIdsOrig);
    Set<DeviceId> deviceIds = regionManager.getRegionDevices(RID1);
    assertEquals("incorrect device count", 2, deviceIds.size());
    assertEquals("incorrect devices in region", deviceIdsOrig, deviceIds);
    Sets.union(masterSet1, masterSet2).forEach(nodeId -> {
    });
    testClusterService.put(CNODE1, ControllerNode.State.ACTIVE);
    testClusterService.put(CNODE2, ControllerNode.State.ACTIVE);
    testClusterService.put(CNODE3, ControllerNode.State.ACTIVE);
    testClusterService.put(CNODE4, ControllerNode.State.ACTIVE);
    // set master to non region nodes
    mgr.setRole(NID_LOCAL, DID1, MASTER);
    mgr.setRole(NID_LOCAL, DID2, MASTER);
    checkDeviceMasters(deviceIds, Sets.newHashSet(NID_LOCAL), deviceId -> assertEquals("wrong local role:", MASTER, mgr.getLocalRole(deviceId)));
    // do region balancing
    mgr.useRegionForBalanceRoles = true;
    mgr.balanceRoles();
    Set<NodeId> expectedMasters = Sets.newHashSet(NID1, NID3, NID4);
    checkDeviceMasters(deviceIds, expectedMasters);
    // make N1 inactive
    testClusterService.put(CNODE1, ControllerNode.State.INACTIVE);
    expectedMasters.remove(NID1);
    mgr.balanceRoles();
    checkDeviceMasters(deviceIds, expectedMasters);
    // make N2 inactive
    testClusterService.put(CNODE4, ControllerNode.State.INACTIVE);
    expectedMasters.remove(NID4);
    mgr.balanceRoles();
    checkDeviceMasters(deviceIds, expectedMasters);
    // make N3 inactive
    testClusterService.put(CNODE3, ControllerNode.State.INACTIVE);
    expectedMasters = Sets.newHashSet(NID2);
    mgr.balanceRoles();
    checkDeviceMasters(deviceIds, expectedMasters);
    // make N3 active
    testClusterService.put(CNODE3, ControllerNode.State.ACTIVE);
    expectedMasters = Sets.newHashSet(NID3);
    mgr.balanceRoles();
    checkDeviceMasters(deviceIds, expectedMasters);
    // make N2 active
    testClusterService.put(CNODE4, ControllerNode.State.ACTIVE);
    expectedMasters.add(NID4);
    mgr.balanceRoles();
    checkDeviceMasters(deviceIds, expectedMasters);
    // make N2 active
    testClusterService.put(CNODE1, ControllerNode.State.ACTIVE);
    expectedMasters.add(NID1);
    mgr.balanceRoles();
    checkDeviceMasters(deviceIds, expectedMasters);
}
#method_after
@Test
public void balanceWithRegion2() {
    // set up region - 2 sets of masters with (3 nodes, 1 node)
    Set<NodeId> masterSet1 = ImmutableSet.of(NID1, NID3, NID4);
    Set<NodeId> masterSet2 = ImmutableSet.of(NID2);
    List<Set<NodeId>> masters = ImmutableList.of(masterSet1, masterSet2);
    Region r = regionManager.createRegion(RID1, "R1", METRO, masters);
    Set<DeviceId> deviceIdsOrig = ImmutableSet.of(DID1, DID2, DID3, DEV_OTHER);
    regionManager.addDevices(RID1, deviceIdsOrig);
    Set<DeviceId> deviceIds = regionManager.getRegionDevices(RID1);
    assertEquals("incorrect device count", deviceIdsOrig.size(), deviceIds.size());
    assertEquals("incorrect devices in region", deviceIdsOrig, deviceIds);
    testClusterService.put(CNODE1, ControllerNode.State.ACTIVE);
    testClusterService.put(CNODE2, ControllerNode.State.ACTIVE);
    testClusterService.put(CNODE3, ControllerNode.State.ACTIVE);
    testClusterService.put(CNODE4, ControllerNode.State.ACTIVE);
    // set master to non region nodes
    deviceIdsOrig.forEach(deviceId1 -> mgr.setRole(NID_LOCAL, deviceId1, MASTER));
    checkDeviceMasters(deviceIds, Sets.newHashSet(NID_LOCAL), deviceId -> assertEquals("wrong local role:", MASTER, mgr.getLocalRole(deviceId)));
    // do region balancing
    mgr.useRegionForBalanceRoles = true;
    mgr.balanceRoles();
    Set<NodeId> expectedMasters = Sets.newHashSet(NID1, NID3, NID4);
    checkDeviceMasters(deviceIds, expectedMasters);
    // make N1 inactive
    testClusterService.put(CNODE1, ControllerNode.State.INACTIVE);
    expectedMasters.remove(NID1);
    mgr.balanceRoles();
    checkDeviceMasters(deviceIds, expectedMasters);
    // make N4 inactive
    testClusterService.put(CNODE4, ControllerNode.State.INACTIVE);
    expectedMasters.remove(NID4);
    mgr.balanceRoles();
    checkDeviceMasters(deviceIds, expectedMasters);
    // make N3 inactive
    testClusterService.put(CNODE3, ControllerNode.State.INACTIVE);
    expectedMasters = Sets.newHashSet(NID2);
    mgr.balanceRoles();
    checkDeviceMasters(deviceIds, expectedMasters);
    // make N3 active
    testClusterService.put(CNODE3, ControllerNode.State.ACTIVE);
    expectedMasters = Sets.newHashSet(NID3);
    mgr.balanceRoles();
    checkDeviceMasters(deviceIds, expectedMasters);
    // make N4 active
    testClusterService.put(CNODE4, ControllerNode.State.ACTIVE);
    expectedMasters.add(NID4);
    mgr.balanceRoles();
    checkDeviceMasters(deviceIds, expectedMasters);
    // make N1 active
    testClusterService.put(CNODE1, ControllerNode.State.ACTIVE);
    expectedMasters.add(NID1);
    mgr.balanceRoles();
    checkDeviceMasters(deviceIds, expectedMasters);
}
#end_block

#method_before
@Override
public MastershipTerm getMastershipTerm(DeviceId deviceId) {
    return store.getTermFor(deviceId);
}
#method_after
@Override
public MastershipTerm getMastershipTerm(DeviceId deviceId) {
    checkPermission(CLUSTER_READ);
    return store.getTermFor(deviceId);
}
#end_block

#method_before
@Override
public void balanceRoles() {
    List<ControllerNode> nodes = newArrayList(clusterService.getNodes());
    Map<ControllerNode, Set<DeviceId>> controllerDevices = new HashMap<>();
    int deviceCount = 0;
    // Create buckets reflecting current ownership.
    for (ControllerNode node : nodes) {
        if (clusterService.getState(node.id()) == ACTIVE) {
            Set<DeviceId> devicesOf = new HashSet<>(getDevicesOf(node.id()));
            deviceCount += devicesOf.size();
            controllerDevices.put(node, devicesOf);
            log.info("Node {} has {} devices.", node.id(), devicesOf.size());
        }
    }
    if (useRegionForBalanceRoles && balanceRolesUsingRegions(controllerDevices)) {
        return;
    }
    // Now re-balance the buckets until they are roughly even.
    List<CompletableFuture<Void>> balanceBucketsFutures = balanceControllerNodes(controllerDevices, deviceCount);
    CompletableFuture<Void> balanceRolesFuture = CompletableFuture.allOf(balanceBucketsFutures.toArray(new CompletableFuture[balanceBucketsFutures.size()]));
    Futures.getUnchecked(balanceRolesFuture);
}
#method_after
@Override
public void balanceRoles() {
    List<ControllerNode> nodes = newArrayList(clusterService.getNodes());
    Map<ControllerNode, Set<DeviceId>> controllerDevices = new HashMap<>();
    int deviceCount = 0;
    // Create buckets reflecting current ownership.
    for (ControllerNode node : nodes) {
        if (clusterService.getState(node.id()).isActive()) {
            Set<DeviceId> devicesOf = new HashSet<>(getDevicesOf(node.id()));
            deviceCount += devicesOf.size();
            controllerDevices.put(node, devicesOf);
            log.info("Node {} has {} devices.", node.id(), devicesOf.size());
        }
    }
    if (useRegionForBalanceRoles && balanceRolesUsingRegions(controllerDevices)) {
        return;
    }
    // Now re-balance the buckets until they are roughly even.
    List<CompletableFuture<Void>> balanceBucketsFutures = balanceControllerNodes(controllerDevices, deviceCount);
    CompletableFuture<Void> balanceRolesFuture = CompletableFuture.allOf(balanceBucketsFutures.toArray(new CompletableFuture[balanceBucketsFutures.size()]));
    Futures.getUnchecked(balanceRolesFuture);
}
#end_block

#method_before
private boolean balanceRolesUsingRegions(Map<ControllerNode, Set<DeviceId>> controllerDevices) {
    Set<Region> regions = regionService.getRegions();
    if (regions.size() == 0) {
        // no balancing was done using regions.
        return false;
    }
    // handle nodes belonginging to regions
    Set<ControllerNode> nodesInRegions = Sets.newHashSet();
    for (Region region : regions) {
        Map<ControllerNode, Set<DeviceId>> activeRegionControllers = balanceRolesInRegion(region, controllerDevices);
        if (activeRegionControllers != null) {
            nodesInRegions.addAll(activeRegionControllers.keySet());
        }
    }
    // handle nodes not belonginging in any region
    Set<ControllerNode> nodesNotInRegions = Sets.difference(controllerDevices.keySet(), nodesInRegions);
    if (nodesNotInRegions.size() > 0) {
        int deviceCount = 0;
        Map<ControllerNode, Set<DeviceId>> controllerDevicesNotInRegions = new HashMap<>();
        for (ControllerNode controllerNode : nodesNotInRegions) {
            controllerDevicesNotInRegions.put(controllerNode, controllerDevices.get(controllerNode));
            deviceCount += controllerDevices.get(controllerNode).size();
        }
        // Now re-balance the buckets until they are roughly even.
        List<CompletableFuture<Void>> balanceBucketsFutures = balanceControllerNodes(controllerDevicesNotInRegions, deviceCount);
        CompletableFuture<Void> balanceRolesFuture = CompletableFuture.allOf(balanceBucketsFutures.toArray(new CompletableFuture[balanceBucketsFutures.size()]));
        Futures.getUnchecked(balanceRolesFuture);
    }
    // balancing was done using regions.
    return true;
}
#method_after
private boolean balanceRolesUsingRegions(Map<ControllerNode, Set<DeviceId>> allControllerDevices) {
    Set<Region> regions = regionService.getRegions();
    if (regions.isEmpty()) {
        // no balancing was done using regions.
        return false;
    }
    // handle nodes belonging to regions
    Set<ControllerNode> nodesInRegions = Sets.newHashSet();
    for (Region region : regions) {
        Map<ControllerNode, Set<DeviceId>> activeRegionControllers = balanceRolesInRegion(region, allControllerDevices);
        nodesInRegions.addAll(activeRegionControllers.keySet());
    }
    // handle nodes not belonging to any region
    Set<ControllerNode> nodesNotInRegions = Sets.difference(allControllerDevices.keySet(), nodesInRegions);
    if (!nodesNotInRegions.isEmpty()) {
        int deviceCount = 0;
        Map<ControllerNode, Set<DeviceId>> controllerDevicesNotInRegions = new HashMap<>();
        for (ControllerNode controllerNode : nodesNotInRegions) {
            controllerDevicesNotInRegions.put(controllerNode, allControllerDevices.get(controllerNode));
            deviceCount += allControllerDevices.get(controllerNode).size();
        }
        // Now re-balance the buckets until they are roughly even.
        List<CompletableFuture<Void>> balanceBucketsFutures = balanceControllerNodes(controllerDevicesNotInRegions, deviceCount);
        CompletableFuture<Void> balanceRolesFuture = CompletableFuture.allOf(balanceBucketsFutures.toArray(new CompletableFuture[balanceBucketsFutures.size()]));
        Futures.getUnchecked(balanceRolesFuture);
    }
    // balancing was done using regions.
    return true;
}
#end_block

#method_before
private Map<ControllerNode, Set<DeviceId>> balanceRolesInRegion(Region region, Map<ControllerNode, Set<DeviceId>> controllerDevices) {
    // retrieve all devices associated with specified region
    Set<DeviceId> devicesInRegion = regionService.getRegionDevices(region.id());
    log.info("Region {} has {} devices.", region.id(), devicesInRegion.size());
    if (devicesInRegion.size() == 0) {
        // no devices in this region, so nothing to balance.
        return null;
    }
    List<Set<NodeId>> mastersList = region.masters();
    log.info("Region {} has {} sets of masters.", region.id(), mastersList.size());
    if (mastersList.size() == 0) {
        // for now just leave devices alone
        return null;
    }
    // get the first master node set that has at least one active node
    Set<DeviceId> devicesInMasters = Sets.newHashSet();
    Map<ControllerNode, Set<DeviceId>> regionalControllerDevices = new HashMap<>();
    int deviceCount = 0;
    int listIndex = 0;
    for (Set<NodeId> masterSet : mastersList) {
        log.info("Region {} masters set {} has {} nodes.", region.id(), listIndex, masterSet.size());
        if (masterSet.size() == 0) {
            // nothing on this level
            listIndex++;
            continue;
        }
        // Create buckets reflecting current ownership.
        for (NodeId nodeId : masterSet) {
            if (clusterService.getState(nodeId) == ACTIVE) {
                ControllerNode controllerNode = clusterService.getNode(nodeId);
                Set<DeviceId> devicesOf = new HashSet<>(controllerDevices.get(controllerNode));
                regionalControllerDevices.put(controllerNode, devicesOf);
                deviceCount += devicesOf.size();
                devicesInMasters.addAll(devicesOf);
                log.info("Active Node {} has {} devices.", nodeId, devicesOf.size());
            }
        }
        if (regionalControllerDevices.size() > 0) {
            // now have a set of >0 active controllers
            break;
        }
        // keep on looking
        listIndex++;
    }
    // Now re-balance the buckets until they are roughly even.
    List<CompletableFuture<Void>> balanceBucketsFutures = balanceControllerNodes(regionalControllerDevices, deviceCount);
    // handle devices that are not currently mastered by the master node set
    Set<DeviceId> devicesNotMasteredWithControllers = Sets.difference(devicesInRegion, devicesInMasters);
    if (devicesNotMasteredWithControllers.size() > 0) {
        // active controllers in master node set are already balanced, just
        // assign device mastership in sequence
        List<ControllerNode> sorted = new ArrayList<>(regionalControllerDevices.keySet());
        Collections.sort(sorted, (o1, o2) -> ((Integer) (regionalControllerDevices.get(o1)).size()).compareTo((Integer) (regionalControllerDevices.get(o2)).size()));
        int deviceIndex = 0;
        for (DeviceId deviceId : devicesNotMasteredWithControllers) {
            ControllerNode cnode = sorted.get(deviceIndex % sorted.size());
            balanceBucketsFutures.add(setRole(cnode.id(), deviceId, MASTER));
            deviceIndex++;
        }
    }
    CompletableFuture<Void> balanceRolesFuture = CompletableFuture.allOf(balanceBucketsFutures.toArray(new CompletableFuture[balanceBucketsFutures.size()]));
    Futures.getUnchecked(balanceRolesFuture);
    // update the map before returning
    regionalControllerDevices.forEach((controllerNode, deviceIds) -> {
        regionalControllerDevices.put(controllerNode, new HashSet<>(getDevicesOf(controllerNode.id())));
    });
    return regionalControllerDevices;
}
#method_after
private Map<ControllerNode, Set<DeviceId>> balanceRolesInRegion(Region region, Map<ControllerNode, Set<DeviceId>> allControllerDevices) {
    // retrieve all devices associated with specified region
    Set<DeviceId> devicesInRegion = regionService.getRegionDevices(region.id());
    log.info("Region {} has {} devices.", region.id(), devicesInRegion.size());
    if (devicesInRegion.isEmpty()) {
        // no devices in this region, so nothing to balance.
        return new HashMap<>();
    }
    List<Set<NodeId>> mastersList = region.masters();
    log.info("Region {} has {} sets of masters.", region.id(), mastersList.size());
    if (mastersList.isEmpty()) {
        // for now just leave devices alone
        return new HashMap<>();
    }
    // get the region's preferred set of masters
    Set<DeviceId> devicesInMasters = Sets.newHashSet();
    Map<ControllerNode, Set<DeviceId>> regionalControllerDevices = getRegionsPreferredMasters(region, devicesInMasters, allControllerDevices);
    // Now re-balance the buckets until they are roughly even.
    List<CompletableFuture<Void>> balanceBucketsFutures = balanceControllerNodes(regionalControllerDevices, devicesInMasters.size());
    // handle devices that are not currently mastered by the master node set
    Set<DeviceId> devicesNotMasteredWithControllers = Sets.difference(devicesInRegion, devicesInMasters);
    if (!devicesNotMasteredWithControllers.isEmpty()) {
        // active controllers in master node set are already balanced, just
        // assign device mastership in sequence
        List<ControllerNode> sorted = new ArrayList<>(regionalControllerDevices.keySet());
        Collections.sort(sorted, (o1, o2) -> ((Integer) (regionalControllerDevices.get(o1)).size()).compareTo((Integer) (regionalControllerDevices.get(o2)).size()));
        int deviceIndex = 0;
        for (DeviceId deviceId : devicesNotMasteredWithControllers) {
            ControllerNode cnode = sorted.get(deviceIndex % sorted.size());
            balanceBucketsFutures.add(setRole(cnode.id(), deviceId, MASTER));
            regionalControllerDevices.get(cnode).add(deviceId);
            deviceIndex++;
        }
    }
    CompletableFuture<Void> balanceRolesFuture = CompletableFuture.allOf(balanceBucketsFutures.toArray(new CompletableFuture[balanceBucketsFutures.size()]));
    Futures.getUnchecked(balanceRolesFuture);
    // update the map before returning
    regionalControllerDevices.forEach((controllerNode, deviceIds) -> {
        regionalControllerDevices.put(controllerNode, new HashSet<>(getDevicesOf(controllerNode.id())));
    });
    return regionalControllerDevices;
}
#end_block

#method_before
public static void processShortCaseEntry(TreeWalkListener listener, GeneratedYangParser.ShortCaseStatementContext ctx) {
    ParseTree errorConstructContext;
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, SHORT_CASE_DATA, "", ENTRY);
    YangCase caseNode = getYangCaseNode(JAVA_GENERATION);
    if (ctx.containerStatement() != null) {
        caseNode.setName(ctx.containerStatement().identifier().getText());
        errorConstructContext = ctx.containerStatement();
    } else if (ctx.listStatement() != null) {
        caseNode.setName(ctx.listStatement().identifier().getText());
        errorConstructContext = ctx.listStatement();
    } else if (ctx.leafListStatement() != null) {
        caseNode.setName(ctx.leafListStatement().identifier().getText());
        errorConstructContext = ctx.leafListStatement();
    } else if (ctx.leafStatement() != null) {
        caseNode.setName(ctx.leafStatement().identifier().getText());
        errorConstructContext = ctx.leafStatement();
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_CHILD, SHORT_CASE_DATA, "", ENTRY));
    }
    // TODO implement for augment.
    int line = ((ParserRuleContext) errorConstructContext).getStart().getLine();
    int charPositionInLine = ((ParserRuleContext) errorConstructContext).getStart().getCharPositionInLine();
    // Check for identifier collision
    detectCollidingChildUtil(listener, line, charPositionInLine, caseNode.getName(), CASE_DATA);
    if ((listener.getParsedDataStack().peek()) instanceof YangChoice) {
        try {
            ((YangChoice) listener.getParsedDataStack().peek()).addChild(caseNode);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, SHORT_CASE_DATA, caseNode.getName(), ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(caseNode);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, SHORT_CASE_DATA, caseNode.getName(), ENTRY));
    }
}
#method_after
public static void processShortCaseEntry(TreeWalkListener listener, GeneratedYangParser.ShortCaseStatementContext ctx) {
    ParseTree errorConstructContext;
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, SHORT_CASE_DATA, "", ENTRY);
    YangCase caseNode = getYangCaseNode(JAVA_GENERATION);
    if (ctx.containerStatement() != null) {
        caseNode.setName(getValidIdentifier(ctx.containerStatement().identifier().getText(), CASE_DATA, ctx));
        errorConstructContext = ctx.containerStatement();
    } else if (ctx.listStatement() != null) {
        caseNode.setName(getValidIdentifier(ctx.listStatement().identifier().getText(), CASE_DATA, ctx));
        errorConstructContext = ctx.listStatement();
    } else if (ctx.leafListStatement() != null) {
        caseNode.setName(getValidIdentifier(ctx.leafListStatement().identifier().getText(), CASE_DATA, ctx));
        errorConstructContext = ctx.leafListStatement();
    } else if (ctx.leafStatement() != null) {
        caseNode.setName(getValidIdentifier(ctx.leafStatement().identifier().getText(), CASE_DATA, ctx));
        errorConstructContext = ctx.leafStatement();
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_CHILD, SHORT_CASE_DATA, "", ENTRY));
    }
    // TODO implement for augment.
    int line = ((ParserRuleContext) errorConstructContext).getStart().getLine();
    int charPositionInLine = ((ParserRuleContext) errorConstructContext).getStart().getCharPositionInLine();
    // Check for identifier collision
    detectCollidingChildUtil(listener, line, charPositionInLine, caseNode.getName(), CASE_DATA);
    if ((listener.getParsedDataStack().peek()) instanceof YangChoice) {
        try {
            ((YangChoice) listener.getParsedDataStack().peek()).addChild(caseNode);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, SHORT_CASE_DATA, caseNode.getName(), ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(caseNode);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, SHORT_CASE_DATA, caseNode.getName(), ENTRY));
    }
}
#end_block

#method_before
public static void processCaseEntry(TreeWalkListener listener, GeneratedYangParser.CaseStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, CASE_DATA, ctx.identifier().getText(), ENTRY);
    // Check validity of identifier and remove double quotes.
    String identifier = getValidIdentifier(ctx.identifier().getText(), CASE_DATA, ctx);
    // Validate sub statement cardinality.
    validateSubStatementsCardinality(ctx);
    Parsable curData = listener.getParsedDataStack().peek();
    // Check for identifier collision
    int line = ctx.getStart().getLine();
    int charPositionInLine = ctx.getStart().getCharPositionInLine();
    detectCollidingChildUtil(listener, line, charPositionInLine, identifier, CASE_DATA);
    if (curData instanceof YangChoice) {
        YangCase caseNode = getYangCaseNode(JAVA_GENERATION);
        caseNode.setName(ctx.identifier().getText());
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(caseNode);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, CASE_DATA, ctx.identifier().getText(), ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(caseNode);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, CASE_DATA, ctx.identifier().getText(), ENTRY));
    }
}
#method_after
public static void processCaseEntry(TreeWalkListener listener, GeneratedYangParser.CaseStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, CASE_DATA, ctx.identifier().getText(), ENTRY);
    // Check validity of identifier and remove double quotes.
    String identifier = getValidIdentifier(ctx.identifier().getText(), CASE_DATA, ctx);
    // Validate sub statement cardinality.
    validateSubStatementsCardinality(ctx);
    Parsable curData = listener.getParsedDataStack().peek();
    // Check for identifier collision
    int line = ctx.getStart().getLine();
    int charPositionInLine = ctx.getStart().getCharPositionInLine();
    detectCollidingChildUtil(listener, line, charPositionInLine, identifier, CASE_DATA);
    if (curData instanceof YangChoice) {
        YangCase caseNode = getYangCaseNode(JAVA_GENERATION);
        caseNode.setName(identifier);
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(caseNode);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, CASE_DATA, ctx.identifier().getText(), ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(caseNode);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, CASE_DATA, ctx.identifier().getText(), ENTRY));
    }
}
#end_block

#method_before
public static void processChoiceEntry(TreeWalkListener listener, GeneratedYangParser.ChoiceStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, CHOICE_DATA, ctx.identifier().getText(), ENTRY);
    // Check validity of identifier and remove double quotes.
    String identifier = getValidIdentifier(ctx.identifier().getText(), CHOICE_DATA, ctx);
    // Validate sub statement cardinality.
    validateSubStatementsCardinality(ctx);
    Parsable curData = listener.getParsedDataStack().peek();
    // Check for identifier collision
    int line = ctx.getStart().getLine();
    int charPositionInLine = ctx.getStart().getCharPositionInLine();
    detectCollidingChildUtil(listener, line, charPositionInLine, identifier, CHOICE_DATA);
    if (curData instanceof YangModule || curData instanceof YangSubModule || curData instanceof YangContainer || curData instanceof YangList || curData instanceof YangCase || curData instanceof YangGrouping || curData instanceof YangAugment || curData instanceof YangInput || curData instanceof YangOutput || curData instanceof YangNotification) {
        YangChoice choiceNode = getYangChoiceNode(JAVA_GENERATION);
        choiceNode.setName(ctx.identifier().getText());
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(choiceNode);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, CHOICE_DATA, ctx.identifier().getText(), ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(choiceNode);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, CHOICE_DATA, ctx.identifier().getText(), ENTRY));
    }
}
#method_after
public static void processChoiceEntry(TreeWalkListener listener, GeneratedYangParser.ChoiceStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, CHOICE_DATA, ctx.identifier().getText(), ENTRY);
    // Check validity of identifier and remove double quotes.
    String identifier = getValidIdentifier(ctx.identifier().getText(), CHOICE_DATA, ctx);
    // Validate sub statement cardinality.
    validateSubStatementsCardinality(ctx);
    Parsable curData = listener.getParsedDataStack().peek();
    // Check for identifier collision
    int line = ctx.getStart().getLine();
    int charPositionInLine = ctx.getStart().getCharPositionInLine();
    detectCollidingChildUtil(listener, line, charPositionInLine, identifier, CHOICE_DATA);
    if (curData instanceof YangModule || curData instanceof YangSubModule || curData instanceof YangContainer || curData instanceof YangList || curData instanceof YangCase || curData instanceof YangGrouping || curData instanceof YangAugment || curData instanceof YangInput || curData instanceof YangOutput || curData instanceof YangNotification) {
        YangChoice choiceNode = getYangChoiceNode(JAVA_GENERATION);
        choiceNode.setName(identifier);
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(choiceNode);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, CHOICE_DATA, ctx.identifier().getText(), ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(choiceNode);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, CHOICE_DATA, ctx.identifier().getText(), ENTRY));
    }
}
#end_block

#method_before
private static void validateSubStatementsCardinality(GeneratedYangParser.ChoiceStatementContext ctx) {
    validateCardinalityMaxOne(ctx.whenStatement(), WHEN_DATA, CHOICE_DATA, ctx.identifier().getText());
    validateCardinalityMaxOne(ctx.defaultStatement(), DEFAULT_DATA, CHOICE_DATA, ctx.identifier().getText());
    validateCardinalityMaxOne(ctx.configStatement(), CONFIG_DATA, CHOICE_DATA, ctx.identifier().getText());
    validateCardinalityMaxOne(ctx.mandatoryStatement(), MANDATORY_DATA, CHOICE_DATA, ctx.identifier().getText());
    validateCardinalityMaxOne(ctx.statusStatement(), STATUS_DATA, CHOICE_DATA, ctx.identifier().getText());
    validateCardinalityMaxOne(ctx.descriptionStatement(), DESCRIPTION_DATA, CHOICE_DATA, ctx.identifier().getText());
    validateCardinalityMaxOne(ctx.referenceStatement(), REFERENCE_DATA, CHOICE_DATA, ctx.identifier().getText());
    validateCardinalityMaxOne(ctx.referenceStatement(), REFERENCE_DATA, CHOICE_DATA, ctx.identifier().getText());
    validateMutuallyExclusiveChilds(ctx.shortCaseStatement(), SHORT_CASE_DATA, ctx.caseStatement(), CASE_DATA, CHOICE_DATA, ctx.identifier().getText());
}
#method_after
private static void validateSubStatementsCardinality(GeneratedYangParser.ChoiceStatementContext ctx) {
    validateCardinalityMaxOne(ctx.whenStatement(), WHEN_DATA, CHOICE_DATA, ctx.identifier().getText());
    validateCardinalityMaxOne(ctx.defaultStatement(), DEFAULT_DATA, CHOICE_DATA, ctx.identifier().getText());
    validateCardinalityMaxOne(ctx.configStatement(), CONFIG_DATA, CHOICE_DATA, ctx.identifier().getText());
    validateCardinalityMaxOne(ctx.mandatoryStatement(), MANDATORY_DATA, CHOICE_DATA, ctx.identifier().getText());
    validateCardinalityMaxOne(ctx.statusStatement(), STATUS_DATA, CHOICE_DATA, ctx.identifier().getText());
    validateCardinalityMaxOne(ctx.descriptionStatement(), DESCRIPTION_DATA, CHOICE_DATA, ctx.identifier().getText());
    validateCardinalityMaxOne(ctx.referenceStatement(), REFERENCE_DATA, CHOICE_DATA, ctx.identifier().getText());
    validateMutuallyExclusiveChilds(ctx.shortCaseStatement(), SHORT_CASE_DATA, ctx.caseStatement(), CASE_DATA, CHOICE_DATA, ctx.identifier().getText());
}
#end_block

#method_before
private String insertConfig(String childTableName, String childColumnName, String parentTableName, String parentColumnName, String parentUuid, Row row) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    TableSchema tableSchema = dbSchema.getTableSchema(childTableName);
    String namedUuid = childTableName;
    Insert insert = new Insert(tableSchema, namedUuid, row);
    ArrayList<Operation> operations = Lists.newArrayList();
    operations.add(insert);
    if (parentTableName != null && parentColumnName != null) {
        TableSchema parentTableSchema = dbSchema.getTableSchema(parentTableName);
        ColumnSchema parentColumnSchema = parentTableSchema.getColumnSchema(parentColumnName);
        List<Mutation> mutations = Lists.newArrayList();
        Mutation mutation = MutationUtil.insert(parentColumnSchema.name(), Uuid.uuid(namedUuid));
        mutations.add(mutation);
        List<Condition> conditions = Lists.newArrayList();
        Condition condition = ConditionUtil.isEqual("_uuid", Uuid.uuid(parentUuid));
        conditions.add(condition);
        Mutate op = new Mutate(parentTableSchema, conditions, mutations);
        operations.add(op);
    }
    if (childTableName.equalsIgnoreCase(OvsdbConstant.PORT)) {
        log.info("Handle port insert");
        Insert intfInsert = handlePortInsertTable(OvsdbConstant.INTERFACE, row);
        if (intfInsert != null) {
            operations.add(intfInsert);
        }
        Insert ins = (Insert) operations.get(0);
        ins.getRow().put("interfaces", Uuid.uuid(OvsdbConstant.INTERFACE));
    }
    List<OperationResult> results;
    try {
        results = transactConfig(OvsdbConstant.DATABASENAME, operations).get();
        return results.get(0).getUuid().value();
    } catch (InterruptedException e) {
        log.warn("Interrupted while waiting to get result");
        Thread.currentThread().interrupt();
    } catch (ExecutionException e) {
        log.error("Exception thrown while to get result");
    }
    return null;
}
#method_after
private String insertConfig(String childTableName, String childColumnName, String parentTableName, String parentColumnName, String parentUuid, Row row) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    TableSchema tableSchema = dbSchema.getTableSchema(childTableName);
    Insert insert = new Insert(tableSchema, childTableName, row);
    ArrayList<Operation> operations = Lists.newArrayList();
    operations.add(insert);
    if (parentTableName != null && parentColumnName != null) {
        TableSchema parentTableSchema = dbSchema.getTableSchema(parentTableName);
        ColumnSchema parentColumnSchema = parentTableSchema.getColumnSchema(parentColumnName);
        List<Mutation> mutations = Lists.newArrayList();
        Mutation mutation = MutationUtil.insert(parentColumnSchema.name(), Uuid.uuid(childTableName));
        mutations.add(mutation);
        List<Condition> conditions = Lists.newArrayList();
        Condition condition = ConditionUtil.isEqual("_uuid", Uuid.uuid(parentUuid));
        conditions.add(condition);
        Mutate op = new Mutate(parentTableSchema, conditions, mutations);
        operations.add(op);
    }
    if (childTableName.equalsIgnoreCase(OvsdbConstant.PORT)) {
        log.info("Handle port insert");
        Insert intfInsert = handlePortInsertTable(OvsdbConstant.INTERFACE, row);
        if (intfInsert != null) {
            operations.add(intfInsert);
        }
        Insert ins = (Insert) operations.get(0);
        ins.getRow().put("interfaces", Uuid.uuid(OvsdbConstant.INTERFACE));
    }
    List<OperationResult> results;
    try {
        results = transactConfig(OvsdbConstant.DATABASENAME, operations).get();
        return results.get(0).getUuid().value();
    } catch (InterruptedException e) {
        log.warn("Interrupted while waiting to get result");
        Thread.currentThread().interrupt();
    } catch (ExecutionException e) {
        log.error("Exception thrown while to get result");
    }
    return null;
}
#end_block

#method_before
@Test
public void testRegionPost() {
    mockRegionAdminService.createRegion(anyObject(), anyObject(), anyObject(), anyObject());
    expectLastCall().andReturn(region2).anyTimes();
    replay(mockRegionAdminService);
    WebTarget wt = target();
    InputStream jsonStream = MetersResourceTest.class.getResourceAsStream("post-region.json");
    Response response = wt.path("regions").request(MediaType.APPLICATION_JSON_TYPE).post(Entity.json(jsonStream));
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_CREATED));
    verify(mockRegionAdminService);
}
#method_after
@Test
public void testRegionPost() {
    mockRegionAdminService.createRegion(anyObject(), anyObject(), anyObject(), anyObject());
    expectLastCall().andReturn(region2).anyTimes();
    replay(mockRegionAdminService);
    WebTarget wt = target();
    InputStream jsonStream = RegionsResourceTest.class.getResourceAsStream("post-region.json");
    Response response = wt.path("regions").request(MediaType.APPLICATION_JSON_TYPE).post(Entity.json(jsonStream));
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_CREATED));
    verify(mockRegionAdminService);
}
#end_block

#method_before
@Test
public void testRegionPut() {
    mockRegionAdminService.updateRegion(anyObject(), anyObject(), anyObject(), anyObject());
    expectLastCall().andReturn(region1).anyTimes();
    replay(mockRegionAdminService);
    WebTarget wt = target();
    InputStream jsonStream = MetersResourceTest.class.getResourceAsStream("post-region.json");
    Response response = wt.path("regions/" + region1.id().toString()).request(MediaType.APPLICATION_JSON_TYPE).put(Entity.json(jsonStream));
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_OK));
    verify(mockRegionAdminService);
}
#method_after
@Test
public void testRegionPut() {
    mockRegionAdminService.updateRegion(anyObject(), anyObject(), anyObject(), anyObject());
    expectLastCall().andReturn(region1).anyTimes();
    replay(mockRegionAdminService);
    WebTarget wt = target();
    InputStream jsonStream = RegionsResourceTest.class.getResourceAsStream("post-region.json");
    Response response = wt.path("regions/" + region1.id().toString()).request(MediaType.APPLICATION_JSON_TYPE).put(Entity.json(jsonStream));
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_OK));
    verify(mockRegionAdminService);
}
#end_block

#method_before
@Test
public void testAddDevicesPost() {
    mockRegionAdminService.addDevices(anyObject(), anyObject());
    expectLastCall();
    replay(mockRegionAdminService);
    WebTarget wt = target();
    InputStream jsonStream = MetersResourceTest.class.getResourceAsStream("region-deviceIds.json");
    Response response = wt.path("regions/" + region1.id().toString() + "/devices").request(MediaType.APPLICATION_JSON_TYPE).post(Entity.json(jsonStream));
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_CREATED));
    verify(mockRegionAdminService);
}
#method_after
@Test
public void testAddDevicesPost() {
    mockRegionAdminService.addDevices(anyObject(), anyObject());
    expectLastCall();
    replay(mockRegionAdminService);
    WebTarget wt = target();
    InputStream jsonStream = RegionsResourceTest.class.getResourceAsStream("region-deviceIds.json");
    Response response = wt.path("regions/" + region1.id().toString() + "/devices").request(MediaType.APPLICATION_JSON_TYPE).post(Entity.json(jsonStream));
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_CREATED));
    verify(mockRegionAdminService);
}
#end_block

#method_before
@Test
public void testRemoveDevicesDelete() {
    mockRegionAdminService.removeDevices(anyObject(), anyObject());
    expectLastCall();
    replay(mockRegionAdminService);
    WebTarget wt = target();
    InputStream jsonStream = MetersResourceTest.class.getResourceAsStream("region-deviceIds.json");
    // FIXME: need to consider whether to use jsonStream for entry deletion
    Response response = wt.path("regions/" + region1.id().toString() + "/devices").request(MediaType.APPLICATION_JSON_TYPE).delete();
// assertThat(response.getStatus(), is(HttpURLConnection.HTTP_OK));
// verify(mockRegionAdminService);
}
#method_after
@Test
public void testRemoveDevicesDelete() {
    mockRegionAdminService.removeDevices(anyObject(), anyObject());
    expectLastCall();
    replay(mockRegionAdminService);
    WebTarget wt = target();
    InputStream jsonStream = RegionsResourceTest.class.getResourceAsStream("region-deviceIds.json");
    // FIXME: need to consider whether to use jsonStream for entry deletion
    Response response = wt.path("regions/" + region1.id().toString() + "/devices").request(MediaType.APPLICATION_JSON_TYPE).delete();
// assertThat(response.getStatus(), is(HttpURLConnection.HTTP_OK));
// verify(mockRegionAdminService);
}
#end_block

#method_before
@POST
@Path("{subjectClassKey}/{subjectKey}/{configKey}")
@Consumes(MediaType.APPLICATION_JSON)
@SuppressWarnings("unchecked")
public Response upload(@PathParam("subjectClassKey") String subjectClassKey, @PathParam("subjectKey") String subjectKey, @PathParam("configKey") String configKey, InputStream request) throws IOException {
    NetworkConfigService service = get(NetworkConfigService.class);
    ObjectNode root = (ObjectNode) mapper().readTree(request);
    service.applyConfig(subjectClassKey, service.getSubjectFactory(subjectClassKey).createSubject(subjectKey), configKey, root);
    return Response.ok().build();
}
#method_after
@POST
@Path("{subjectClassKey}/{subjectKey}/{configKey}")
@Consumes(MediaType.APPLICATION_JSON)
@SuppressWarnings("unchecked")
public Response upload(@PathParam("subjectClassKey") String subjectClassKey, @PathParam("subjectKey") String subjectKey, @PathParam("configKey") String configKey, InputStream request) throws IOException {
    NetworkConfigService service = get(NetworkConfigService.class);
    JsonNode root = mapper().readTree(request);
    service.applyConfig(subjectClassKey, service.getSubjectFactory(subjectClassKey).createSubject(subjectKey), configKey, root);
    return Response.ok().build();
}
#end_block

#method_before
@Override
public boolean delete(DeviceId device, String request, InputStream payload, String mediaType) {
    WebTarget wt = getWebTarget(device, request);
    Response response = null;
    // FIXME: do we need to delete entry by specifying content in DELETE request?
    response = wt.request(mediaType).delete();
    return checkReply(response);
}
#method_after
@Override
public boolean delete(DeviceId device, String request, InputStream payload, String mediaType) {
    WebTarget wt = getWebTarget(device, request);
    // FIXME: do we need to delete an entry by enclosing data in DELETE request?
    // wouldn't it be nice to use PUT to implement the similar concept?
    Response response = wt.request(mediaType).delete();
    return checkReply(response);
}
#end_block

#method_before
@Path("upload")
@POST
@Consumes(MediaType.MULTIPART_FORM_DATA)
public Response upload(@FormDataParam("file") InputStream stream) throws IOException {
    get(ApplicationAdminService.class).install(stream);
    return Response.ok().build();
}
#method_after
@Path("upload")
@POST
@Consumes(MediaType.MULTIPART_FORM_DATA)
public Response upload(@QueryParam("activate") @DefaultValue("false") String activate, @FormDataParam("file") InputStream stream) throws IOException {
    ApplicationAdminService service = get(ApplicationAdminService.class);
    Application app = service.install(stream);
    lastInstalledAppName = app.id().name();
    if (Objects.equals(activate, "true")) {
        service.activate(app.id());
    }
    return Response.ok().build();
}
#end_block

#method_before
private void addRemoteRoute(McastRoute route) {
    checkNotNull(route);
    if (syncHost == null) {
        log.warn("No host configured for synchronization; route will be dropped");
        return;
    }
    log.debug("Sending route {} to other ONOS {}", route, fabricOnosUrl);
    Invocation.Builder builder = getClientBuilder(fabricOnosUrl);
    ObjectNode json = codecService.getCodec(McastRoute.class).encode(route, new AbstractWebResource());
    builder.post(Entity.json(json.toString()));
}
#method_after
private void addRemoteRoute(McastRoute route) {
    checkNotNull(route);
    if (syncHost == null) {
        log.warn("No host configured for synchronization; route will be dropped");
        return;
    }
    log.debug("Sending route {} to other ONOS {}", route, fabricOnosUrl);
    Invocation.Builder builder = getClientBuilder(fabricOnosUrl);
    ObjectNode json = codecService.getCodec(McastRoute.class).encode(route, new AbstractWebResource());
    try {
        builder.post(Entity.json(json.toString()));
    } catch (ProcessingException e) {
        log.warn("Unable to send route to remote controller: {}", e.getMessage());
    }
}
#end_block

#method_before
private void removeRemoteRoute(McastRoute route) {
    if (syncHost == null) {
        log.warn("No host configured for synchronization; route will be dropped");
        return;
    }
    log.debug("Removing route {} from other ONOS {}", route, fabricOnosUrl);
    Invocation.Builder builder = getClientBuilder(fabricOnosUrl);
    ObjectNode json = codecService.getCodec(McastRoute.class).encode(route, new AbstractWebResource());
    // TODO: do we need to specify the content for deletion?
    builder.delete();
}
#method_after
private void removeRemoteRoute(McastRoute route) {
    if (syncHost == null) {
        log.warn("No host configured for synchronization; route will be dropped");
        return;
    }
    log.debug("Removing route {} from other ONOS {}", route, fabricOnosUrl);
    Invocation.Builder builder = getClientBuilder(fabricOnosUrl).property(ClientProperties.SUPPRESS_HTTP_COMPLIANCE_VALIDATION, true);
    ObjectNode json = codecService.getCodec(McastRoute.class).encode(route, new AbstractWebResource());
    builder.method("DELETE", Entity.entity(json.asText(), MediaType.APPLICATION_OCTET_STREAM));
}
#end_block

#method_before
private Invocation.Builder getClientBuilder(String uri) {
    Client client = ClientBuilder.newClient();
    client.property(ClientProperties.CONNECT_TIMEOUT, DEFAULT_REST_TIMEOUT_MS);
    client.property(ClientProperties.READ_TIMEOUT, DEFAULT_REST_TIMEOUT_MS);
    client.register(HttpAuthenticationFeature.basic(user, password));
    WebTarget wt = client.target(uri);
    return wt.request(JSON_UTF_8.toString());
}
#method_after
private Invocation.Builder getClientBuilder(String uri) {
    ClientConfig config = new ClientConfig();
    Client client = ClientBuilder.newClient(config);
    client.property(ClientProperties.CONNECT_TIMEOUT, DEFAULT_REST_TIMEOUT_MS);
    client.property(ClientProperties.READ_TIMEOUT, DEFAULT_REST_TIMEOUT_MS);
    client.register(HttpAuthenticationFeature.basic(user, password));
    WebTarget wt = client.target(uri);
    return wt.request(JSON_UTF_8.toString());
}
#end_block

#method_before
@Test
@Ignore("FIXME: This needs to get reworked")
public void addRule() throws IOException {
    WebTarget wt = target();
    String response;
    String json;
    replay(mockAclService);
    // FIXME: following code snippet requires refactoring by extracing
    // json string as a separated file
    // input a invalid JSON string that contains neither nw_src and nw_dst
    json = "{\"ipProto\":\"TCP\",\"dstTpPort\":\"80\"}";
    response = wt.request().post(Entity.json(json), String.class);
    assertThat(response, containsString("Failed! Either srcIp or dstIp must be assigned."));
    // input a invalid JSON string that doesn't contain CIDR mask bits
    json = "{\"ipProto\":\"TCP\",\"srcIp\":\"10.0.0.1\",\"dstTpPort\":\"80\",\"action\":\"DENY\"}";
    response = wt.request().post(Entity.json(json), String.class);
    assertThat(response, containsString("Malformed IPv4 prefix string: 10.0.0.1. " + "Address must take form \"x.x.x.x/y\""));
    // input a invalid JSON string that contains a invalid IP address
    json = "{\"ipProto\":\"TCP\",\"srcIp\":\"10.0.0.256/32\",\"dstTpPort\":\"80\",\"action\":\"DENY\"}";
    response = wt.request().post(Entity.json(json), String.class);
    assertThat(response, containsString("Invalid IP address string: 10.0.0.256"));
    // input a invalid JSON string that contains a invalid IP address
    json = "{\"ipProto\":\"TCP\",\"srcIp\":\"10.0.01/32\",\"dstTpPort\":\"80\",\"action\":\"DENY\"}";
    response = wt.request().post(Entity.json(json), String.class);
    assertThat(response, containsString("Invalid IP address string: 10.0.01"));
    // input a invalid JSON string that contains a invalid CIDR mask bits
    json = "{\"ipProto\":\"TCP\",\"srcIp\":\"10.0.0.1/a\",\"dstTpPort\":\"80\",\"action\":\"DENY\"}";
    response = wt.request().post(Entity.json(json), String.class);
    assertThat(response, containsString("Failed! For input string: \"a\""));
    // input a invalid JSON string that contains a invalid CIDR mask bits
    json = "{\"ipProto\":\"TCP\",\"srcIp\":\"10.0.0.1/33\",\"dstTpPort\":\"80\",\"action\":\"DENY\"}";
    response = wt.request().post(Entity.json(json), String.class);
    assertThat(response, containsString("Invalid prefix length 33. The value must be in the interval [0, 32]"));
    // input a invalid JSON string that contains a invalid ipProto value
    json = "{\"ipProto\":\"ARP\",\"srcIp\":\"10.0.0.1/32\",\"dstTpPort\":\"80\",\"action\":\"DENY\"}";
    response = wt.request().post(Entity.json(json), String.class);
    assertThat(response, containsString("ipProto must be assigned to TCP, UDP, or ICMP."));
    // input a invalid JSON string that contains a invalid dstTpPort value
    json = "{\"ipProto\":\"TCP\",\"srcIp\":\"10.0.0.1/32\",\"dstTpPort\":\"a\",\"action\":\"DENY\"}";
    response = wt.request().post(Entity.json(json), String.class);
    assertThat(response, containsString("dstTpPort must be assigned to a numerical value."));
    // input a invalid JSON string that contains a invalid action value
    json = "{\"ipProto\":\"TCP\",\"srcIp\":\"10.0.0.1/32\",\"dstTpPort\":\"80\",\"action\":\"PERMIT\"}";
    response = wt.request().post(Entity.json(json), String.class);
    assertThat(response, containsString("action must be assigned to ALLOW or DENY."));
}
#method_after
@Test
@Ignore("FIXME: This needs to get reworked")
public void addRule() throws IOException {
    WebTarget wt = target();
    String response;
    String json;
    replay(mockAclService);
    // FIXME: following code snippet requires refactoring by extracting
    // json string as a separated file
    // input a invalid JSON string that contains neither nw_src and nw_dst
    json = "{\"ipProto\":\"TCP\",\"dstTpPort\":\"80\"}";
    response = wt.request().post(Entity.json(json), String.class);
    assertThat(response, containsString("Failed! Either srcIp or dstIp must be assigned."));
    // input a invalid JSON string that doesn't contain CIDR mask bits
    json = "{\"ipProto\":\"TCP\",\"srcIp\":\"10.0.0.1\",\"dstTpPort\":\"80\",\"action\":\"DENY\"}";
    response = wt.request().post(Entity.json(json), String.class);
    assertThat(response, containsString("Malformed IPv4 prefix string: 10.0.0.1. " + "Address must take form \"x.x.x.x/y\""));
    // input a invalid JSON string that contains a invalid IP address
    json = "{\"ipProto\":\"TCP\",\"srcIp\":\"10.0.0.256/32\",\"dstTpPort\":\"80\",\"action\":\"DENY\"}";
    response = wt.request().post(Entity.json(json), String.class);
    assertThat(response, containsString("Invalid IP address string: 10.0.0.256"));
    // input a invalid JSON string that contains a invalid IP address
    json = "{\"ipProto\":\"TCP\",\"srcIp\":\"10.0.01/32\",\"dstTpPort\":\"80\",\"action\":\"DENY\"}";
    response = wt.request().post(Entity.json(json), String.class);
    assertThat(response, containsString("Invalid IP address string: 10.0.01"));
    // input a invalid JSON string that contains a invalid CIDR mask bits
    json = "{\"ipProto\":\"TCP\",\"srcIp\":\"10.0.0.1/a\",\"dstTpPort\":\"80\",\"action\":\"DENY\"}";
    response = wt.request().post(Entity.json(json), String.class);
    assertThat(response, containsString("Failed! For input string: \"a\""));
    // input a invalid JSON string that contains a invalid CIDR mask bits
    json = "{\"ipProto\":\"TCP\",\"srcIp\":\"10.0.0.1/33\",\"dstTpPort\":\"80\",\"action\":\"DENY\"}";
    response = wt.request().post(Entity.json(json), String.class);
    assertThat(response, containsString("Invalid prefix length 33. The value must be in the interval [0, 32]"));
    // input a invalid JSON string that contains a invalid ipProto value
    json = "{\"ipProto\":\"ARP\",\"srcIp\":\"10.0.0.1/32\",\"dstTpPort\":\"80\",\"action\":\"DENY\"}";
    response = wt.request().post(Entity.json(json), String.class);
    assertThat(response, containsString("ipProto must be assigned to TCP, UDP, or ICMP."));
    // input a invalid JSON string that contains a invalid dstTpPort value
    json = "{\"ipProto\":\"TCP\",\"srcIp\":\"10.0.0.1/32\",\"dstTpPort\":\"a\",\"action\":\"DENY\"}";
    response = wt.request().post(Entity.json(json), String.class);
    assertThat(response, containsString("dstTpPort must be assigned to a numerical value."));
    // input a invalid JSON string that contains a invalid action value
    json = "{\"ipProto\":\"TCP\",\"srcIp\":\"10.0.0.1/32\",\"dstTpPort\":\"80\",\"action\":\"PERMIT\"}";
    response = wt.request().post(Entity.json(json), String.class);
    assertThat(response, containsString("action must be assigned to ALLOW or DENY."));
}
#end_block

#method_before
@Before
public void setUp() {
    sut = new PathIntentCompiler();
    coreService = createMock(CoreService.class);
    expect(coreService.registerApplication("org.onosproject.net.intent")).andReturn(appId);
    sut.coreService = coreService;
    sut.resourceService = new MockResourceService();
    Intent.bindIdGenerator(idGenerator);
    intent = PathIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).priority(PRIORITY).path(new DefaultPath(pid, links, hops)).build();
    constraintVlanIntent = PathIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, links, hops)).build();
    constraintMplsIntent = PathIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.MPLS))).path(new DefaultPath(pid, links, hops)).build();
    intentExtensionService = createMock(IntentExtensionService.class);
    intentExtensionService.registerCompiler(PathIntent.class, sut);
    intentExtensionService.unregisterCompiler(PathIntent.class);
    sut.intentManager = intentExtensionService;
    replay(coreService, intentExtensionService);
}
#method_after
@Before
public void setUp() {
    sut = new PathIntentCompiler();
    coreService = createMock(CoreService.class);
    expect(coreService.registerApplication("org.onosproject.net.intent")).andReturn(appId);
    sut.coreService = coreService;
    sut.resourceService = new MockResourceService();
    Intent.bindIdGenerator(idGenerator);
    intent = PathIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).priority(PRIORITY).path(new DefaultPath(pid, links, hops)).build();
    // Intent with VLAN encap without egress VLAN
    constraintVlanIntent = PathIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, links, hops)).build();
    // Intent with VLAN encap with ingress and egress VLAN
    constrainIngressEgressVlanIntent = PathIntent.builder().appId(APP_ID).selector(vlanSelector).treatment(vlanTreatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, links, hops)).build();
    constraintMplsIntent = PathIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.MPLS))).path(new DefaultPath(pid, links, hops)).build();
    intentExtensionService = createMock(IntentExtensionService.class);
    intentExtensionService.registerCompiler(PathIntent.class, sut);
    intentExtensionService.unregisterCompiler(PathIntent.class);
    registrator = new IntentConfigurableRegistrator();
    registrator.extensionService = intentExtensionService;
    registrator.cfgService = new ComponentConfigAdapter();
    registrator.activate();
    sut.registrator = registrator;
    replay(coreService, intentExtensionService);
}
#end_block

#method_before
@Test
public void testCompile() {
    sut.activate();
    List<Intent> compiled = sut.compile(intent, Collections.emptyList(), Collections.emptySet());
    assertThat(compiled, hasSize(1));
    Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
    FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(d1p0.deviceId())).findFirst().get();
    assertThat(rule1.deviceId(), is(d1p0.deviceId()));
    assertThat(rule1.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d1p0.port()).build()));
    assertThat(rule1.treatment(), is(DefaultTrafficTreatment.builder().setOutput(d1p1.port()).build()));
    assertThat(rule1.priority(), is(intent.priority()));
    FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(d2p0.deviceId())).findFirst().get();
    assertThat(rule2.deviceId(), is(d2p0.deviceId()));
    assertThat(rule2.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d2p0.port()).build()));
    assertThat(rule2.treatment(), is(DefaultTrafficTreatment.builder().setOutput(d2p1.port()).build()));
    assertThat(rule2.priority(), is(intent.priority()));
    FlowRule rule3 = rules.stream().filter(x -> x.deviceId().equals(d3p0.deviceId())).findFirst().get();
    assertThat(rule3.deviceId(), is(d3p1.deviceId()));
    assertThat(rule3.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d3p1.port()).build()));
    assertThat(rule3.treatment(), is(DefaultTrafficTreatment.builder(treatment).setOutput(d3p0.port()).build()));
    assertThat(rule3.priority(), is(intent.priority()));
    sut.deactivate();
}
#method_after
@Test
public void testCompile() {
    sut.activate();
    List<Intent> compiled = sut.compile(intent, Collections.emptyList(), Collections.emptySet());
    assertThat(compiled, hasSize(1));
    Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
    FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(d1p0.deviceId())).findFirst().get();
    verifyIdAndPriority(rule1, d1p0.deviceId());
    assertThat(rule1.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d1p0.port()).build()));
    assertThat(rule1.treatment(), is(DefaultTrafficTreatment.builder().setOutput(d1p1.port()).build()));
    FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(d2p0.deviceId())).findFirst().get();
    verifyIdAndPriority(rule2, d2p0.deviceId());
    assertThat(rule2.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d2p0.port()).build()));
    assertThat(rule2.treatment(), is(DefaultTrafficTreatment.builder().setOutput(d2p1.port()).build()));
    FlowRule rule3 = rules.stream().filter(x -> x.deviceId().equals(d3p0.deviceId())).findFirst().get();
    verifyIdAndPriority(rule3, d3p1.deviceId());
    assertThat(rule3.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d3p1.port()).build()));
    assertThat(rule3.treatment(), is(DefaultTrafficTreatment.builder(treatment).setOutput(d3p0.port()).build()));
    sut.deactivate();
}
#end_block

#method_before
@Test
public void testVlanEncapCompile() {
    sut.activate();
    List<Intent> compiled = sut.compile(constraintVlanIntent, Collections.emptyList(), Collections.emptySet());
    assertThat(compiled, hasSize(1));
    Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
    assertThat(rules, hasSize(3));
    FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(d1p0.deviceId())).findFirst().get();
    assertThat(rule1.deviceId(), is(d1p0.deviceId()));
    assertThat(rule1.priority(), is(intent.priority()));
    assertThat(rule1.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d1p0.port()).build()));
    VlanId vlanToEncap = verifyVlanEncapTreatment(rule1.treatment(), d1p1, true, false);
    FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(d2p0.deviceId())).findFirst().get();
    assertThat(rule2.deviceId(), is(d2p0.deviceId()));
    assertThat(rule2.priority(), is(intent.priority()));
    verifyVlanEncapSelector(rule2.selector(), d2p0, vlanToEncap);
    verifyVlanEncapTreatment(rule2.treatment(), d2p1, false, false);
    FlowRule rule3 = rules.stream().filter(x -> x.deviceId().equals(d3p0.deviceId())).findFirst().get();
    assertThat(rule3.deviceId(), is(d3p1.deviceId()));
    assertThat(rule3.priority(), is(intent.priority()));
    verifyVlanEncapSelector(rule3.selector(), d3p1, vlanToEncap);
    verifyVlanEncapTreatment(rule3.treatment(), d3p0, false, true);
    sut.deactivate();
}
#method_after
@Test
public void testVlanEncapCompile() {
    sut.activate();
    List<Intent> compiled = sut.compile(constraintVlanIntent, Collections.emptyList(), Collections.emptySet());
    assertThat(compiled, hasSize(1));
    Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
    assertThat(rules, hasSize(3));
    FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(d1p0.deviceId())).findFirst().get();
    verifyIdAndPriority(rule1, d1p0.deviceId());
    assertThat(rule1.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d1p0.port()).build()));
    VlanId vlanToEncap = verifyVlanEncapTreatment(rule1.treatment(), d1p1, true, false);
    FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(d2p0.deviceId())).findFirst().get();
    verifyIdAndPriority(rule2, d2p0.deviceId());
    verifyVlanEncapSelector(rule2.selector(), d2p0, vlanToEncap);
    verifyVlanEncapTreatment(rule2.treatment(), d2p1, false, false);
    FlowRule rule3 = rules.stream().filter(x -> x.deviceId().equals(d3p0.deviceId())).findFirst().get();
    verifyIdAndPriority(rule3, d3p1.deviceId());
    verifyVlanEncapSelector(rule3.selector(), d3p1, vlanToEncap);
    verifyVlanEncapTreatment(rule3.treatment(), d3p0, false, true);
    sut.deactivate();
}
#end_block

#method_before
@Test
public void testMplsEncapCompile() {
    sut.activate();
    List<Intent> compiled = sut.compile(constraintMplsIntent, Collections.emptyList(), Collections.emptySet());
    assertThat(compiled, hasSize(1));
    Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
    assertThat(rules, hasSize(3));
    FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(d1p0.deviceId())).findFirst().get();
    assertThat(rule1.deviceId(), is(d1p0.deviceId()));
    assertThat(rule1.priority(), is(intent.priority()));
    assertThat(rule1.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d1p0.port()).build()));
    MplsLabel mplsLabelToEncap = verifyMplsEncapTreatment(rule1.treatment(), d1p1, true, false);
    FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(d2p0.deviceId())).findFirst().get();
    assertThat(rule2.deviceId(), is(d2p0.deviceId()));
    assertThat(rule2.priority(), is(intent.priority()));
    verifyMplsEncapSelector(rule2.selector(), d2p0, mplsLabelToEncap);
    verifyMplsEncapTreatment(rule2.treatment(), d2p1, false, false);
    FlowRule rule3 = rules.stream().filter(x -> x.deviceId().equals(d3p0.deviceId())).findFirst().get();
    assertThat(rule3.deviceId(), is(d3p1.deviceId()));
    assertThat(rule3.priority(), is(intent.priority()));
    verifyMplsEncapSelector(rule3.selector(), d3p1, mplsLabelToEncap);
    verifyMplsEncapTreatment(rule3.treatment(), d3p0, false, true);
    sut.deactivate();
}
#method_after
@Test
public void testMplsEncapCompile() {
    sut.activate();
    List<Intent> compiled = sut.compile(constraintMplsIntent, Collections.emptyList(), Collections.emptySet());
    assertThat(compiled, hasSize(1));
    Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
    assertThat(rules, hasSize(3));
    FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(d1p0.deviceId())).findFirst().get();
    verifyIdAndPriority(rule1, d1p0.deviceId());
    assertThat(rule1.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d1p0.port()).build()));
    MplsLabel mplsLabelToEncap = verifyMplsEncapTreatment(rule1.treatment(), d1p1, true, false);
    FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(d2p0.deviceId())).findFirst().get();
    verifyIdAndPriority(rule2, d2p0.deviceId());
    verifyMplsEncapSelector(rule2.selector(), d2p0, mplsLabelToEncap);
    verifyMplsEncapTreatment(rule2.treatment(), d2p1, false, false);
    FlowRule rule3 = rules.stream().filter(x -> x.deviceId().equals(d3p0.deviceId())).findFirst().get();
    verifyIdAndPriority(rule3, d3p1.deviceId());
    verifyMplsEncapSelector(rule3.selector(), d3p1, mplsLabelToEncap);
    verifyMplsEncapTreatment(rule3.treatment(), d3p0, false, true);
    sut.deactivate();
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.net.intent");
    intentManager.registerCompiler(PathIntent.class, this);
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.net.intent");
    registrator.registerCompiler(PathIntent.class, this, false);
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    intentManager.unregisterCompiler(PathIntent.class);
}
#method_after
@Deactivate
public void deactivate() {
    registrator.unregisterCompiler(PathIntent.class, false);
}
#end_block

#method_before
@Override
public List<Intent> compile(PathIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    // Note: right now recompile is not considered
    // TODO: implement recompile behavior
    List<Link> links = intent.path().links();
    List<FlowRule> rules = new LinkedList<>();
    Optional<EncapsulationConstraint> enacpConstraint = intent.constraints().stream().filter(constraint -> constraint instanceof EncapsulationConstraint).map(x -> (EncapsulationConstraint) x).findAny();
    // if no encapsulation or is involved only a single switch use the default behaviour
    if (!enacpConstraint.isPresent() || links.size() == 1) {
        for (int i = 0; i < links.size() - 1; i++) {
            ConnectPoint ingress = links.get(i).dst();
            ConnectPoint egress = links.get(i + 1).src();
            FlowRule rule = createFlowRule(intent.selector(), intent.treatment(), ingress, egress, intent.priority(), isLast(links, i));
            rules.add(rule);
        }
        return ImmutableList.of(new FlowRuleIntent(appId, null, rules, intent.resources()));
    } else {
        Set<LinkKey> linkRequest = Sets.newHashSetWithExpectedSize(intent.path().links().size() - 2);
        for (int i = 1; i <= intent.path().links().size() - 2; i++) {
            LinkKey link = linkKey(intent.path().links().get(i));
            linkRequest.add(link);
            // add the inverse link. I want that the label is reserved both for
            // the direct and inverse link
            linkRequest.add(linkKey(link.dst(), link.src()));
        }
        if (EncapsulationType.VLAN == enacpConstraint.get().encapType()) {
            rules = manageVlanEncap(intent, linkRequest);
        }
        if (EncapsulationType.MPLS == enacpConstraint.get().encapType()) {
            rules = manageMplsEncap(intent, linkRequest);
        }
        return ImmutableList.of(new FlowRuleIntent(appId, null, rules, intent.resources()));
    }
}
#method_after
@Override
public List<Intent> compile(PathIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    List<FlowRule> rules = new LinkedList<>();
    List<DeviceId> devices = new LinkedList<>();
    compile(this, intent, rules, devices);
    return ImmutableList.of(new FlowRuleIntent(appId, null, rules, intent.resources()));
}
#end_block

#method_before
private Set<MplsLabel> findMplsLabel(ConnectPoint cp) {
    return resourceService.getAvailableResources(Resources.discrete(cp.deviceId(), cp.port()).id()).stream().filter(x -> x.last() instanceof MplsLabel).map(x -> (MplsLabel) x.last()).collect(Collectors.toSet());
}
#method_after
private Set<MplsLabel> findMplsLabel(ConnectPoint cp) {
    return resourceService.getAvailableResourceValues(Resources.discrete(cp.deviceId(), cp.port()).id(), MplsLabel.class);
}
#end_block

#method_before
private <S, C extends Config<S>> C createConfig(S subject, Class<C> configClass, JsonNode json, boolean detached) {
    if (json != null) {
        ConfigFactory<S, C> factory = factoriesByConfig.get(configClass.getName());
        if (factory != null) {
            validateJsonType(json, factory);
            C config = factory.createConfig();
            config.init(subject, factory.configKey(), json, mapper, detached ? null : applyDelegate);
            return config;
        }
    }
    return null;
}
#method_after
@SuppressWarnings("unchecked")
private <S, C extends Config<S>> C createConfig(S subject, Class<C> configClass, JsonNode json, boolean detached) {
    if (json != null) {
        ConfigFactory<S, C> factory = factoriesByConfig.get(configClass.getName());
        if (factory != null) {
            validateJsonType(json, factory);
            C config = factory.createConfig();
            config.init(subject, factory.configKey(), json, mapper, detached ? null : applyDelegate);
            return config;
        }
    }
    return null;
}
#end_block

#method_before
private void initNode(CordVtnNode node) {
    checkNotNull(node);
    NodeState state = (NodeState) node.state();
    log.debug("Processing node: {} state: {}", node.hostname(), state.toString());
    state.process(this, node);
}
#method_after
private void initNode(CordVtnNode node) {
    checkNotNull(node);
    NodeState state = (NodeState) node.state();
    log.debug("Processing node: {} state: {}", node.hostname(), state);
    state.process(this, node);
}
#end_block

#method_before
private void setNodeState(CordVtnNode node, NodeState newState) {
    checkNotNull(node);
    log.debug("Changed {} state: {}", node.hostname(), newState.toString());
    nodeStore.put(node.hostname(), CordVtnNode.getUpdatedNode(node, newState));
}
#method_after
private void setNodeState(CordVtnNode node, NodeState newState) {
    checkNotNull(node);
    log.debug("Changed {} state: {}", node.hostname(), newState);
    nodeStore.put(node.hostname(), CordVtnNode.getUpdatedNode(node, newState));
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    NodeId leaderNodeId = leadershipService.getLeader(appId.name());
    if (!Objects.equals(localNodeId, leaderNodeId)) {
        // do not allow to proceed without leadership
        return;
    }
    Device device = event.subject();
    ConnectionHandler<Device> handler = (device.type().equals(SWITCH) ? bridgeHandler : ovsdbHandler);
    switch(event.type()) {
        case PORT_ADDED:
            eventExecutor.submit(() -> bridgeHandler.portAdded(event.port()));
            break;
        case PORT_UPDATED:
            if (!event.port().isEnabled()) {
                eventExecutor.submit(() -> bridgeHandler.portRemoved(event.port()));
            }
            break;
        case DEVICE_ADDED:
        case DEVICE_AVAILABILITY_CHANGED:
            if (deviceService.isAvailable(device.id())) {
                eventExecutor.submit(() -> handler.connected(device));
            } else {
                eventExecutor.submit(() -> handler.disconnected(device));
            }
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    NodeId leaderNodeId = leadershipService.getLeader(appId.name());
    if (!Objects.equals(localNodeId, leaderNodeId)) {
        // do not allow to proceed without leadership
        return;
    }
    Device device = event.subject();
    ConnectionHandler<Device> handler = (device.type().equals(SWITCH) ? bridgeHandler : ovsdbHandler);
    switch(event.type()) {
        case PORT_ADDED:
            eventExecutor.execute(() -> bridgeHandler.portAdded(event.port()));
            break;
        case PORT_UPDATED:
            if (!event.port().isEnabled()) {
                eventExecutor.execute(() -> bridgeHandler.portRemoved(event.port()));
            }
            break;
        case DEVICE_ADDED:
        case DEVICE_AVAILABILITY_CHANGED:
            if (deviceService.isAvailable(device.id())) {
                eventExecutor.execute(() -> handler.connected(device));
            } else {
                eventExecutor.execute(() -> handler.disconnected(device));
            }
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public void event(MapEvent<String, CordVtnNode> event) {
    NodeId leaderNodeId = leadershipService.getLeader(appId.name());
    if (!Objects.equals(localNodeId, leaderNodeId)) {
        // do not allow to proceed without leadership
        return;
    }
    CordVtnNode oldNode;
    CordVtnNode newNode;
    switch(event.type()) {
        case UPDATE:
            oldNode = event.oldValue().value();
            newNode = event.newValue().value();
            if (!newNode.equals(oldNode)) {
                log.info("{} has been updated", newNode.hostname());
                log.debug("New node: {}", newNode.toString());
            }
            // perform init procedure based on current state on any updates,
            // insert, or even if the node is the same for robustness since
            // it's no harm to run the init procedure multiple times
            eventExecutor.submit(() -> initNode(newNode));
            break;
        case INSERT:
            newNode = event.newValue().value();
            log.info("Added {}", newNode.hostname());
            eventExecutor.submit(() -> initNode(newNode));
            break;
        case REMOVE:
            oldNode = event.oldValue().value();
            log.info("{} is removed", oldNode.hostname());
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(MapEvent<String, CordVtnNode> event) {
    NodeId leaderNodeId = leadershipService.getLeader(appId.name());
    if (!Objects.equals(localNodeId, leaderNodeId)) {
        // do not allow to proceed without leadership
        return;
    }
    CordVtnNode oldNode;
    CordVtnNode newNode;
    switch(event.type()) {
        case UPDATE:
            oldNode = event.oldValue().value();
            newNode = event.newValue().value();
            if (!newNode.equals(oldNode)) {
                log.info("{} has been updated", newNode.hostname());
                log.debug("New node: {}", newNode);
            }
            // perform init procedure based on current state on any updates,
            // insert, or even if the node is the same for robustness since
            // it's no harm to run the init procedure multiple times
            eventExecutor.execute(() -> initNode(newNode));
            break;
        case INSERT:
            newNode = event.newValue().value();
            log.info("Added {}", newNode.hostname());
            eventExecutor.execute(() -> initNode(newNode));
            break;
        case REMOVE:
            oldNode = event.oldValue().value();
            log.info("{} is removed", oldNode.hostname());
            break;
        default:
            break;
    }
}
#end_block

#method_before
protected SortedMap<Device, List<FlowEntry>> getSortedFlows(DeviceService deviceService, FlowRuleService service, CoreService coreService) {
    SortedMap<Device, List<FlowEntry>> flows = new TreeMap<>(Comparators.ELEMENT_COMPARATOR);
    List<FlowEntry> rules;
    Iterable<Device> devices = null;
    if (uri == null) {
        devices = deviceService.getDevices();
    } else {
        Device dev = deviceService.getDevice(DeviceId.deviceId(uri));
        devices = (dev == null) ? deviceService.getDevices() : Collections.singletonList(dev);
    }
    for (Device d : devices) {
        if (predicate.equals(TRUE_PREDICATE)) {
            rules = newArrayList(service.getFlowEntries(d.id()));
        } else {
            rules = newArrayList();
            for (FlowEntry f : service.getFlowEntries(d.id())) {
                if (predicate.test(f)) {
                    rules.add(f);
                }
            }
        }
        rules.sort(Comparators.FLOW_RULE_COMPARATOR);
        int i = 0;
        int j = 0;
        int[] coreRules = new int[10];
        for (FlowEntry f : rules) {
            ApplicationId appId = coreService.getAppId(f.appId());
            if (coreOutput) {
                if (appId.name() == "org.onosproject.core") {
                    coreRules[j] = i;
                    j++;
                }
            }
            i++;
        }
        if (coreOutput) {
            for (int k = j - 1; k >= 0; k--) {
                rules.remove(coreRules[k]);
            }
        }
        flows.put(d, rules);
    }
    return flows;
}
#method_after
protected SortedMap<Device, List<FlowEntry>> getSortedFlows(DeviceService deviceService, FlowRuleService service, CoreService coreService) {
    SortedMap<Device, List<FlowEntry>> flows = new TreeMap<>(Comparators.ELEMENT_COMPARATOR);
    List<FlowEntry> rules;
    Iterable<Device> devices = null;
    if (uri == null) {
        devices = deviceService.getDevices();
    } else {
        Device dev = deviceService.getDevice(DeviceId.deviceId(uri));
        devices = (dev == null) ? deviceService.getDevices() : Collections.singletonList(dev);
    }
    for (Device d : devices) {
        if (predicate.equals(TRUE_PREDICATE)) {
            rules = newArrayList(service.getFlowEntries(d.id()));
        } else {
            rules = newArrayList();
            for (FlowEntry f : service.getFlowEntries(d.id())) {
                if (predicate.test(f)) {
                    rules.add(f);
                }
            }
        }
        rules.sort(Comparators.FLOW_RULE_COMPARATOR);
        if (suppressCoreOutput) {
            short coreAppId = coreService.getAppId("org.onosproject.core").id();
            rules = rules.stream().filter(f -> f.appId() != coreAppId).collect(Collectors.toList());
        }
        flows.put(d, rules);
    }
    return flows;
}
#end_block

#method_before
@Test
public void testFibAdd() {
    IpPrefix prefix = Ip4Prefix.valueOf("1.1.1.0/24");
    FibEntry fibEntry = new FibEntry(prefix, Ip4Address.valueOf("192.168.10.1"), MacAddress.valueOf("00:00:00:00:00:01"));
    // create the next Objective
    Interface egressIntf = interfaceService.getMatchingInterface(fibEntry.nextHopIp());
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setEthSrc(MacAddress.valueOf("00:00:00:00:00:01")).setEthDst(MacAddress.valueOf("00:00:00:00:00:01"));
    TrafficSelector.Builder metabuilder = null;
    if (!egressIntf.vlan().equals(VlanId.NONE)) {
        treatment.pushVlan().setVlanId(egressIntf.vlan()).setVlanPcp((byte) 0);
    } else {
        metabuilder = DefaultTrafficSelector.builder();
        metabuilder.matchVlanId(VlanId.vlanId(SingleSwitchFibInstaller.ASSIGNED_VLAN));
    }
    treatment.setOutput(PortNumber.portNumber(1));
    int nextId = 11;
    NextObjective.Builder nextBuilder = DefaultNextObjective.builder().withId(nextId).addTreatment(treatment.build()).withType(NextObjective.Type.SIMPLE).fromApp(APPID);
    if (metabuilder != null) {
        nextBuilder.withMeta(metabuilder.build());
    }
    NextObjective nextObjective = nextBuilder.add();
    flowObjectiveService.next(DeviceId.deviceId("of:0000000000000001"), nextObjective);
    // set up the flowObjective
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(prefix).build();
    int priority = prefix.prefixLength() * 5 + 100;
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().fromApp(APPID).makePermanent().withSelector(selector).withPriority(priority).withFlag(ForwardingObjective.Flag.SPECIFIC);
    Integer nextId1 = 11;
    fwdBuilder.nextStep(nextId1);
    flowObjectiveService.forward(DeviceId.deviceId("of:0000000000000001"), fwdBuilder.add());
    EasyMock.expectLastCall().once();
    setUpFlowObjectiveService();
    // Send in the UPDATE FibUpdate
    FibUpdate fibUpdate = new FibUpdate(FibUpdate.Type.UPDATE, fibEntry);
    fibListener.update(Collections.singleton(fibUpdate), Collections.emptyList());
    verify(flowObjectiveService);
}
#method_after
@Test
public void testFibAdd() {
    IpPrefix prefix = Ip4Prefix.valueOf("1.1.1.0/24");
    FibEntry fibEntry = new FibEntry(prefix, Ip4Address.valueOf("192.168.10.1"), MacAddress.valueOf("00:00:00:00:00:01"));
    // create the next Objective
    Interface egressIntf = interfaceService.getMatchingInterface(fibEntry.nextHopIp());
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setEthSrc(MacAddress.valueOf("00:00:00:00:00:01")).setEthDst(MacAddress.valueOf("00:00:00:00:00:01"));
    TrafficSelector.Builder metabuilder = null;
    if (!egressIntf.vlan().equals(VlanId.NONE)) {
        treatment.pushVlan().setVlanId(egressIntf.vlan()).setVlanPcp((byte) 0);
    } else {
        metabuilder = DefaultTrafficSelector.builder();
        metabuilder.matchVlanId(VlanId.vlanId(SingleSwitchFibInstaller.ASSIGNED_VLAN));
    }
    treatment.setOutput(PortNumber.portNumber(1));
    int nextId = 11;
    NextObjective.Builder nextBuilder = DefaultNextObjective.builder().withId(nextId).addTreatment(treatment.build()).withType(NextObjective.Type.SIMPLE).fromApp(APPID);
    if (metabuilder != null) {
        nextBuilder.withMeta(metabuilder.build());
    }
    NextObjective nextObjective = nextBuilder.add();
    flowObjectiveService.next(deviceId, nextObjective);
    // set up the flowObjective
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(prefix).build();
    int priority = prefix.prefixLength() * 5 + 100;
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().fromApp(APPID).makePermanent().withSelector(selector).withPriority(priority).withFlag(ForwardingObjective.Flag.SPECIFIC);
    Integer nextId1 = 11;
    fwdBuilder.nextStep(nextId1);
    flowObjectiveService.forward(deviceId, fwdBuilder.add());
    EasyMock.expectLastCall().once();
    setUpFlowObjectiveService();
    // Send in the UPDATE FibUpdate
    FibUpdate fibUpdate = new FibUpdate(FibUpdate.Type.UPDATE, fibEntry);
    fibListener.update(Collections.singleton(fibUpdate), Collections.emptyList());
    verify(flowObjectiveService);
}
#end_block

#method_before
@Test
public void testFibAddWithVlan() {
    IpPrefix prefix = Ip4Prefix.valueOf("3.3.3.0/24");
    FibEntry fibEntry = new FibEntry(prefix, Ip4Address.valueOf("192.168.40.1"), MacAddress.valueOf("00:00:00:00:00:04"));
    // create the next Objective
    Interface egressIntf = interfaceService.getMatchingInterface(fibEntry.nextHopIp());
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setEthSrc(MacAddress.valueOf("00:00:00:00:00:04")).setEthDst(MacAddress.valueOf("00:00:00:00:00:04"));
    TrafficSelector.Builder metabuilder = null;
    if (!egressIntf.vlan().equals(VlanId.NONE)) {
        treatment.pushVlan().setVlanId(egressIntf.vlan()).setVlanPcp((byte) 0);
    } else {
        metabuilder = DefaultTrafficSelector.builder();
        metabuilder.matchVlanId(VlanId.vlanId(SingleSwitchFibInstaller.ASSIGNED_VLAN));
    }
    treatment.setOutput(PortNumber.portNumber(1));
    int nextId = 11;
    NextObjective.Builder nextBuilder = DefaultNextObjective.builder().withId(nextId).addTreatment(treatment.build()).withType(NextObjective.Type.SIMPLE).fromApp(APPID);
    if (metabuilder != null) {
        nextBuilder.withMeta(metabuilder.build());
    }
    NextObjective nextObjective = nextBuilder.add();
    flowObjectiveService.next(DeviceId.deviceId("of:0000000000000001"), nextObjective);
    // set up the flowObjective
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(prefix).build();
    int priority = prefix.prefixLength() * 5 + 100;
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().fromApp(APPID).makePermanent().withSelector(selector).withPriority(priority).withFlag(ForwardingObjective.Flag.SPECIFIC);
    Integer nextId1 = 11;
    fwdBuilder.nextStep(nextId1);
    flowObjectiveService.forward(DeviceId.deviceId("of:0000000000000001"), fwdBuilder.add());
    EasyMock.expectLastCall().once();
    setUpFlowObjectiveService();
    // Send in the UPDATE FibUpdate
    FibUpdate fibUpdate = new FibUpdate(FibUpdate.Type.UPDATE, fibEntry);
    fibListener.update(Collections.singleton(fibUpdate), Collections.emptyList());
    verify(flowObjectiveService);
}
#method_after
@Test
public void testFibAddWithVlan() {
    IpPrefix prefix = Ip4Prefix.valueOf("3.3.3.0/24");
    FibEntry fibEntry = new FibEntry(prefix, Ip4Address.valueOf("192.168.40.1"), MacAddress.valueOf("00:00:00:00:00:04"));
    // create the next Objective
    Interface egressIntf = interfaceService.getMatchingInterface(fibEntry.nextHopIp());
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setEthSrc(MacAddress.valueOf("00:00:00:00:00:04")).setEthDst(MacAddress.valueOf("00:00:00:00:00:04"));
    TrafficSelector.Builder metabuilder = null;
    if (!egressIntf.vlan().equals(VlanId.NONE)) {
        treatment.pushVlan().setVlanId(egressIntf.vlan()).setVlanPcp((byte) 0);
    } else {
        metabuilder = DefaultTrafficSelector.builder();
        metabuilder.matchVlanId(VlanId.vlanId(SingleSwitchFibInstaller.ASSIGNED_VLAN));
    }
    treatment.setOutput(PortNumber.portNumber(1));
    int nextId = 11;
    NextObjective.Builder nextBuilder = DefaultNextObjective.builder().withId(nextId).addTreatment(treatment.build()).withType(NextObjective.Type.SIMPLE).fromApp(APPID);
    if (metabuilder != null) {
        nextBuilder.withMeta(metabuilder.build());
    }
    NextObjective nextObjective = nextBuilder.add();
    flowObjectiveService.next(deviceId, nextObjective);
    // set up the flowObjective
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(prefix).build();
    int priority = prefix.prefixLength() * 5 + 100;
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().fromApp(APPID).makePermanent().withSelector(selector).withPriority(priority).withFlag(ForwardingObjective.Flag.SPECIFIC);
    Integer nextId1 = 11;
    fwdBuilder.nextStep(nextId1);
    flowObjectiveService.forward(deviceId, fwdBuilder.add());
    EasyMock.expectLastCall().once();
    setUpFlowObjectiveService();
    // Send in the UPDATE FibUpdate
    FibUpdate fibUpdate = new FibUpdate(FibUpdate.Type.UPDATE, fibEntry);
    fibListener.update(Collections.singleton(fibUpdate), Collections.emptyList());
    verify(flowObjectiveService);
}
#end_block

#method_before
@Test
public void testFibUpdate() {
    // Firstly add a route
    testFibAdd();
    reset(flowObjectiveService);
    IpPrefix prefix = Ip4Prefix.valueOf("1.1.1.0/24");
    // Start to construct a new route entry and new intent
    FibEntry fibEntryUpdate = new FibEntry(prefix, Ip4Address.valueOf("192.168.20.1"), MacAddress.valueOf("00:00:00:00:00:02"));
    // create the next Objective
    Interface egressIntf = interfaceService.getMatchingInterface(fibEntryUpdate.nextHopIp());
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setEthSrc(MacAddress.valueOf("00:00:00:00:00:02")).setEthDst(MacAddress.valueOf("00:00:00:00:00:02"));
    TrafficSelector.Builder metabuilder = null;
    if (!egressIntf.vlan().equals(VlanId.NONE)) {
        treatment.pushVlan().setVlanId(egressIntf.vlan()).setVlanPcp((byte) 0);
    } else {
        metabuilder = DefaultTrafficSelector.builder();
        metabuilder.matchVlanId(VlanId.vlanId(SingleSwitchFibInstaller.ASSIGNED_VLAN));
    }
    treatment.setOutput(PortNumber.portNumber(1));
    int nextId = 11;
    NextObjective.Builder nextBuilder = DefaultNextObjective.builder().withId(nextId).addTreatment(treatment.build()).withType(NextObjective.Type.SIMPLE).fromApp(APPID);
    if (metabuilder != null) {
        nextBuilder.withMeta(metabuilder.build());
    }
    NextObjective nextObjective = nextBuilder.add();
    flowObjectiveService.next(DeviceId.deviceId("of:0000000000000001"), nextObjective);
    // set up the flowObjective
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(prefix).build();
    int priority = prefix.prefixLength() * 5 + 100;
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().fromApp(APPID).makePermanent().withSelector(selector).withPriority(priority).withFlag(ForwardingObjective.Flag.SPECIFIC);
    Integer nextId1 = 11;
    fwdBuilder.nextStep(nextId1);
    flowObjectiveService.forward(DeviceId.deviceId("of:0000000000000001"), fwdBuilder.add());
    EasyMock.expectLastCall().once();
    setUpFlowObjectiveService();
    // Send in the UPDATE FibUpdate
    FibUpdate fibUpdate = new FibUpdate(FibUpdate.Type.UPDATE, fibEntryUpdate);
    fibListener.update(Collections.singletonList(fibUpdate), Collections.emptyList());
    verify(flowObjectiveService);
}
#method_after
@Test
public void testFibUpdate() {
    // Firstly add a route
    testFibAdd();
    reset(flowObjectiveService);
    IpPrefix prefix = Ip4Prefix.valueOf("1.1.1.0/24");
    // Start to construct a new route entry and new intent
    FibEntry fibEntryUpdate = new FibEntry(prefix, Ip4Address.valueOf("192.168.20.1"), MacAddress.valueOf("00:00:00:00:00:02"));
    // create the next Objective
    Interface egressIntf = interfaceService.getMatchingInterface(fibEntryUpdate.nextHopIp());
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setEthSrc(MacAddress.valueOf("00:00:00:00:00:02")).setEthDst(MacAddress.valueOf("00:00:00:00:00:02"));
    TrafficSelector.Builder metabuilder = null;
    if (!egressIntf.vlan().equals(VlanId.NONE)) {
        treatment.pushVlan().setVlanId(egressIntf.vlan()).setVlanPcp((byte) 0);
    } else {
        metabuilder = DefaultTrafficSelector.builder();
        metabuilder.matchVlanId(VlanId.vlanId(SingleSwitchFibInstaller.ASSIGNED_VLAN));
    }
    treatment.setOutput(PortNumber.portNumber(1));
    int nextId = 11;
    NextObjective.Builder nextBuilder = DefaultNextObjective.builder().withId(nextId).addTreatment(treatment.build()).withType(NextObjective.Type.SIMPLE).fromApp(APPID);
    if (metabuilder != null) {
        nextBuilder.withMeta(metabuilder.build());
    }
    NextObjective nextObjective = nextBuilder.add();
    flowObjectiveService.next(deviceId, nextObjective);
    // set up the flowObjective
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(prefix).build();
    int priority = prefix.prefixLength() * 5 + 100;
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().fromApp(APPID).makePermanent().withSelector(selector).withPriority(priority).withFlag(ForwardingObjective.Flag.SPECIFIC);
    Integer nextId1 = 11;
    fwdBuilder.nextStep(nextId1);
    flowObjectiveService.forward(deviceId, fwdBuilder.add());
    EasyMock.expectLastCall().once();
    setUpFlowObjectiveService();
    // Send in the UPDATE FibUpdate
    FibUpdate fibUpdate = new FibUpdate(FibUpdate.Type.UPDATE, fibEntryUpdate);
    fibListener.update(Collections.singletonList(fibUpdate), Collections.emptyList());
    verify(flowObjectiveService);
}
#end_block

#method_before
/**
 * Tests deleting a FIB entry.
 *
 * We verify that the flowObjectiveService records the correct state and that the
 * correct flow is withdrawn from the flowObjectiveService.
 */
@Test
public void testFibDelete() {
    // Firstly add a route
    testFibAdd();
    IpPrefix prefix = Ip4Prefix.valueOf("1.1.1.0/24");
    // Construct the existing route entry
    FibEntry fibEntry = new FibEntry(prefix, null, null);
    // set up the flowObjective
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(prefix).build();
    int priority = prefix.prefixLength() * 5 + 100;
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().fromApp(APPID).makePermanent().withSelector(selector).withPriority(priority).withFlag(ForwardingObjective.Flag.SPECIFIC);
    fwdBuilder.withTreatment(DefaultTrafficTreatment.builder().build());
    reset(flowObjectiveService);
    flowObjectiveService.forward(DeviceId.deviceId("of:0000000000000001"), fwdBuilder.remove());
    replay(flowObjectiveService);
    // Send in the DELETE FibUpdate
    FibUpdate fibUpdate = new FibUpdate(FibUpdate.Type.DELETE, fibEntry);
    fibListener.update(Collections.emptyList(), Collections.singletonList(fibUpdate));
    verify(flowObjectiveService);
}
#method_after
/**
 * Tests deleting a FIB entry.
 *
 * We verify that the flowObjectiveService records the correct state and that the
 * correct flow is withdrawn from the flowObjectiveService.
 */
@Test
public void testFibDelete() {
    // Firstly add a route
    testFibAdd();
    IpPrefix prefix = Ip4Prefix.valueOf("1.1.1.0/24");
    // Construct the existing route entry
    FibEntry fibEntry = new FibEntry(prefix, null, null);
    // set up the flowObjective
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(prefix).build();
    int priority = prefix.prefixLength() * 5 + 100;
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().fromApp(APPID).makePermanent().withSelector(selector).withPriority(priority).withFlag(ForwardingObjective.Flag.SPECIFIC);
    fwdBuilder.withTreatment(DefaultTrafficTreatment.builder().build());
    reset(flowObjectiveService);
    flowObjectiveService.forward(deviceId, fwdBuilder.remove());
    replay(flowObjectiveService);
    // Send in the DELETE FibUpdate
    FibUpdate fibUpdate = new FibUpdate(FibUpdate.Type.DELETE, fibEntry);
    fibListener.update(Collections.emptyList(), Collections.singletonList(fibUpdate));
    verify(flowObjectiveService);
}
#end_block

#method_before
private void encodeExtension(ObjectNode result) {
    Instructions.ExtensionInstructionWrapper extensionInstruction = (Instructions.ExtensionInstructionWrapper) instruction;
    result.put(InstructionCodec.TYPE, extensionInstruction.extensionInstruction().type().toString());
}
#method_after
private void encodeExtension(ObjectNode result) {
    // TODO Support extension in REST API
    log.info("Cannot convert instruction type of EXTENSION");
}
#end_block

#method_before
@Override
public void groupOperationFailed(DeviceId deviceId, GroupOperation operation) {
    StoredGroupEntry existing = getStoredGroupEntry(deviceId, operation.groupId());
    if (existing == null) {
        log.warn("No group entry with ID {} found ", operation.groupId());
        return;
    }
    log.warn("groupOperationFailed: group operation {} failed" + "for group {} in device {} with code {}", operation.opType(), existing.id(), existing.deviceId(), operation.failureCode());
    if (operation.failureCode() == GroupOperation.GroupMsgErrorCode.GROUP_EXISTS) {
        log.warn("Current extraneous groups in device:{} are: {}", deviceId, getExtraneousGroups(deviceId));
        if (operation.buckets().equals(existing.buckets())) {
            if (existing.state() == GroupState.PENDING_ADD) {
                log.warn("GROUP_EXISTS: GroupID and Buckets match for group in pending " + "add state - moving to ADDED for group {} in device {}", existing.id(), deviceId);
                addOrUpdateGroupEntry(existing);
                return;
            } else {
                log.warn("GROUP EXISTS: Group ID matched but buckets did not. " + "Operation: {} Existing: {}", operation.buckets(), existing.buckets());
            }
        }
    }
    switch(operation.opType()) {
        case ADD:
            if (existing.state() == GroupState.PENDING_ADD) {
                notifyDelegate(new GroupEvent(Type.GROUP_ADD_FAILED, existing));
                log.warn("groupOperationFailed: cleaningup " + "group {} from store in device {}....", existing.id(), existing.deviceId());
                // Removal from groupid based map will happen in the
                // map update listener
                getGroupStoreKeyMap().remove(new GroupStoreKeyMapKey(existing.deviceId(), existing.appCookie()));
            }
            break;
        case MODIFY:
            notifyDelegate(new GroupEvent(Type.GROUP_UPDATE_FAILED, existing));
            break;
        case DELETE:
            notifyDelegate(new GroupEvent(Type.GROUP_REMOVE_FAILED, existing));
            break;
        default:
            log.warn("Unknown group operation type {}", operation.opType());
    }
}
#method_after
@Override
public void groupOperationFailed(DeviceId deviceId, GroupOperation operation) {
    StoredGroupEntry existing = getStoredGroupEntry(deviceId, operation.groupId());
    if (existing == null) {
        log.warn("No group entry with ID {} found ", operation.groupId());
        return;
    }
    log.warn("groupOperationFailed: group operation {} failed" + "for group {} in device {} with code {}", operation.opType(), existing.id(), existing.deviceId(), operation.failureCode());
    if (operation.failureCode() == GroupOperation.GroupMsgErrorCode.GROUP_EXISTS) {
        log.warn("Current extraneous groups in device:{} are: {}", deviceId, getExtraneousGroups(deviceId));
        if (operation.buckets().equals(existing.buckets())) {
            if (existing.state() == GroupState.PENDING_ADD) {
                log.info("GROUP_EXISTS: GroupID and Buckets match for group in pending " + "add state - moving to ADDED for group {} in device {}", existing.id(), deviceId);
                addOrUpdateGroupEntry(existing);
                return;
            } else {
                log.warn("GROUP EXISTS: Group ID matched but buckets did not. " + "Operation: {} Existing: {}", operation.buckets(), existing.buckets());
            }
        }
    }
    switch(operation.opType()) {
        case ADD:
            if (existing.state() == GroupState.PENDING_ADD) {
                notifyDelegate(new GroupEvent(Type.GROUP_ADD_FAILED, existing));
                log.warn("groupOperationFailed: cleaningup " + "group {} from store in device {}....", existing.id(), existing.deviceId());
                // Removal from groupid based map will happen in the
                // map update listener
                getGroupStoreKeyMap().remove(new GroupStoreKeyMapKey(existing.deviceId(), existing.appCookie()));
            }
            break;
        case MODIFY:
            notifyDelegate(new GroupEvent(Type.GROUP_UPDATE_FAILED, existing));
            break;
        case DELETE:
            notifyDelegate(new GroupEvent(Type.GROUP_REMOVE_FAILED, existing));
            break;
        default:
            log.warn("Unknown group operation type {}", operation.opType());
    }
}
#end_block

#method_before
@Override
public List<String> getNextMappings(NextGroup nextGroup) {
    List<String> mappings = new ArrayList<>();
    List<Deque<GroupKey>> gkeys = appKryo.deserialize(nextGroup.data());
    for (Deque<GroupKey> gkd : gkeys) {
        Group lastGroup = null;
        String gchain = "";
        for (GroupKey gk : gkd) {
            Group g = groupService.getGroup(deviceId, gk);
            if (g == null) {
                gchain += "  ERROR" + " -->";
                continue;
            }
            gchain += "  0x" + Integer.toHexString(g.id().id()) + " -->";
            lastGroup = g;
        }
        // add port information for last group in group-chain
        for (Instruction i : lastGroup.buckets().buckets().get(0).treatment().allInstructions()) {
            if (i instanceof OutputInstruction) {
                gchain += " port:" + ((OutputInstruction) i).port();
            }
        }
        mappings.add(gchain);
    }
    return mappings;
}
#method_after
@Override
public List<String> getNextMappings(NextGroup nextGroup) {
    List<String> mappings = new ArrayList<>();
    List<Deque<GroupKey>> gkeys = appKryo.deserialize(nextGroup.data());
    for (Deque<GroupKey> gkd : gkeys) {
        Group lastGroup = null;
        StringBuffer gchain = new StringBuffer();
        for (GroupKey gk : gkd) {
            Group g = groupService.getGroup(deviceId, gk);
            if (g == null) {
                gchain.append("  ERROR").append(" -->");
                continue;
            }
            gchain.append("  0x").append(Integer.toHexString(g.id().id())).append(" -->");
            lastGroup = g;
        }
        // add port information for last group in group-chain
        for (Instruction i : lastGroup.buckets().buckets().get(0).treatment().allInstructions()) {
            if (i instanceof OutputInstruction) {
                gchain.append(" port:").append(((OutputInstruction) i).port());
            }
        }
        mappings.add(gchain.toString());
    }
    return mappings;
}
#end_block

#method_before
private GroupInfo createL2L3Chain(TrafficTreatment treatment, int nextId, ApplicationId appId, boolean mpls, TrafficSelector meta) {
    // for the l2interface group, get vlan and port info
    // for the outer group, get the src/dst mac, and vlan info
    TrafficTreatment.Builder outerTtb = DefaultTrafficTreatment.builder();
    TrafficTreatment.Builder innerTtb = DefaultTrafficTreatment.builder();
    VlanId vlanid = null;
    long portNum = 0;
    boolean setVlan = false, popVlan = false;
    MacAddress srcMac = MacAddress.ZERO;
    MacAddress dstMac = MacAddress.ZERO;
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            switch(l2ins.subtype()) {
                case ETH_DST:
                    dstMac = ((L2ModificationInstruction.ModEtherInstruction) l2ins).mac();
                    outerTtb.setEthDst(dstMac);
                    break;
                case ETH_SRC:
                    srcMac = ((L2ModificationInstruction.ModEtherInstruction) l2ins).mac();
                    outerTtb.setEthSrc(srcMac);
                    break;
                case VLAN_ID:
                    vlanid = ((L2ModificationInstruction.ModVlanIdInstruction) l2ins).vlanId();
                    outerTtb.setVlanId(vlanid);
                    setVlan = true;
                    break;
                case VLAN_POP:
                    innerTtb.popVlan();
                    popVlan = true;
                    break;
                case DEC_MPLS_TTL:
                case MPLS_LABEL:
                case MPLS_POP:
                case MPLS_PUSH:
                case VLAN_PCP:
                case VLAN_PUSH:
                default:
                    break;
            }
        } else if (ins.type() == Instruction.Type.OUTPUT) {
            portNum = ((Instructions.OutputInstruction) ins).port().toLong();
            innerTtb.add(ins);
        } else {
            log.warn("Driver does not handle this type of TrafficTreatment" + " instruction in nextObjectives:  {}", ins.type());
        }
    }
    if (vlanid == null && meta != null) {
        // use metadata if available
        Criterion vidCriterion = meta.getCriterion(Criterion.Type.VLAN_VID);
        if (vidCriterion != null) {
            vlanid = ((VlanIdCriterion) vidCriterion).vlanId();
        }
        // if vlan is not set, use the vlan in metadata for outerTtb
        if (vlanid != null && !setVlan) {
            outerTtb.setVlanId(vlanid);
        }
    }
    if (vlanid == null) {
        log.error("Driver cannot process an L2/L3 group chain without " + "egress vlan information for dev: {} port:{}", deviceId, portNum);
        return null;
    }
    if (!setVlan && !popVlan) {
        // untagged outgoing port
        TrafficTreatment.Builder temp = DefaultTrafficTreatment.builder();
        temp.popVlan();
        innerTtb.build().allInstructions().forEach(i -> temp.add(i));
        innerTtb = temp;
    }
    // assemble information for ofdpa l2interface group
    int l2groupId = L2_INTERFACE_TYPE | (vlanid.toShort() << 16) | (int) portNum;
    // a globally unique groupkey that is different for ports in the same device,
    // but different for the same portnumber on different devices. Also different
    // for the various group-types created out of the same next objective.
    int l2gk = l2InterfaceGroupKey(deviceId, vlanid, portNum);
    final GroupKey l2groupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l2gk));
    // assemble information for outer group
    GroupDescription outerGrpDesc = null;
    if (mpls) {
        // outer group is MPLSInteface
        // int mplsgroupId = MPLS_INTERFACE_TYPE | (int) portNum;
        int mplsInterfaceIndex = getNextAvailableIndex();
        int mplsgroupId = MPLS_INTERFACE_TYPE | (SUBTYPE_MASK & mplsInterfaceIndex);
        // using mplsinterfacemask in groupkey to differentiate from l2interface
        // int mplsgk = MPLS_INTERFACE_TYPE | (SUBTYPE_MASK & (deviceId.hashCode() << 8 | (int) portNum));
        final GroupKey mplsgroupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(mplsInterfaceIndex));
        outerTtb.group(new DefaultGroupId(l2groupId));
        // create the mpls-interface group description to wait for the
        // l2 interface group to be processed
        GroupBucket mplsinterfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
        outerGrpDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(mplsinterfaceGroupBucket)), mplsgroupkey, mplsgroupId, appId);
        log.debug("Trying MPLS-Interface: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(mplsgroupId), mplsgroupkey, nextId);
    } else {
        // outer group is L3Unicast
        // int l3GroupIdHash = Objects.hash(srcMac, dstMac, portNum);
        // int l3groupId = L3_UNICAST_TYPE | (TYPE_MASK & l3GroupIdHash);
        // int l3GroupKeyHash = Objects.hash(deviceId, srcMac, dstMac, portNum);
        // int l3gk = L3_UNICAST_TYPE | (TYPE_MASK & l3GroupKeyHash);
        int l3unicastIndex = getNextAvailableIndex();
        int l3groupId = L3_UNICAST_TYPE | (TYPE_MASK & l3unicastIndex);
        final GroupKey l3groupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l3unicastIndex));
        outerTtb.group(new DefaultGroupId(l2groupId));
        // create the l3unicast group description to wait for the
        // l2 interface group to be processed
        GroupBucket l3unicastGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
        outerGrpDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3unicastGroupBucket)), l3groupkey, l3groupId, appId);
        log.debug("Trying L3Unicast: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l3groupId), l3groupkey, nextId);
    }
    // store l2groupkey with the groupChainElem for the outer-group that depends on it
    GroupChainElem gce = new GroupChainElem(outerGrpDesc, 1, false);
    updatePendingGroups(l2groupkey, gce);
    // create group description for the inner l2interfacegroup
    GroupBucket l2interfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(innerTtb.build());
    GroupDescription l2groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l2interfaceGroupBucket)), l2groupkey, l2groupId, appId);
    log.debug("Trying L2Interface: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l2groupId), l2groupkey, nextId);
    return new GroupInfo(l2groupDescription, outerGrpDesc);
}
#method_after
private GroupInfo createL2L3Chain(TrafficTreatment treatment, int nextId, ApplicationId appId, boolean mpls, TrafficSelector meta) {
    // for the l2interface group, get vlan and port info
    // for the outer group, get the src/dst mac, and vlan info
    TrafficTreatment.Builder outerTtb = DefaultTrafficTreatment.builder();
    TrafficTreatment.Builder innerTtb = DefaultTrafficTreatment.builder();
    VlanId vlanid = null;
    long portNum = 0;
    boolean setVlan = false, popVlan = false;
    MacAddress srcMac = MacAddress.ZERO;
    MacAddress dstMac = MacAddress.ZERO;
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            switch(l2ins.subtype()) {
                case ETH_DST:
                    dstMac = ((L2ModificationInstruction.ModEtherInstruction) l2ins).mac();
                    outerTtb.setEthDst(dstMac);
                    break;
                case ETH_SRC:
                    srcMac = ((L2ModificationInstruction.ModEtherInstruction) l2ins).mac();
                    outerTtb.setEthSrc(srcMac);
                    break;
                case VLAN_ID:
                    vlanid = ((L2ModificationInstruction.ModVlanIdInstruction) l2ins).vlanId();
                    outerTtb.setVlanId(vlanid);
                    setVlan = true;
                    break;
                case VLAN_POP:
                    innerTtb.popVlan();
                    popVlan = true;
                    break;
                case DEC_MPLS_TTL:
                case MPLS_LABEL:
                case MPLS_POP:
                case MPLS_PUSH:
                case VLAN_PCP:
                case VLAN_PUSH:
                default:
                    break;
            }
        } else if (ins.type() == Instruction.Type.OUTPUT) {
            portNum = ((Instructions.OutputInstruction) ins).port().toLong();
            innerTtb.add(ins);
        } else {
            log.warn("Driver does not handle this type of TrafficTreatment" + " instruction in nextObjectives:  {}", ins.type());
        }
    }
    if (vlanid == null && meta != null) {
        // use metadata if available
        Criterion vidCriterion = meta.getCriterion(Criterion.Type.VLAN_VID);
        if (vidCriterion != null) {
            vlanid = ((VlanIdCriterion) vidCriterion).vlanId();
        }
        // if vlan is not set, use the vlan in metadata for outerTtb
        if (vlanid != null && !setVlan) {
            outerTtb.setVlanId(vlanid);
        }
    }
    if (vlanid == null) {
        log.error("Driver cannot process an L2/L3 group chain without " + "egress vlan information for dev: {} port:{}", deviceId, portNum);
        return null;
    }
    if (!setVlan && !popVlan) {
        // untagged outgoing port
        TrafficTreatment.Builder temp = DefaultTrafficTreatment.builder();
        temp.popVlan();
        innerTtb.build().allInstructions().forEach(i -> temp.add(i));
        innerTtb = temp;
    }
    // assemble information for ofdpa l2interface group
    int l2groupId = L2_INTERFACE_TYPE | (vlanid.toShort() << 16) | (int) portNum;
    // a globally unique groupkey that is different for ports in the same device,
    // but different for the same portnumber on different devices. Also different
    // for the various group-types created out of the same next objective.
    int l2gk = l2InterfaceGroupKey(deviceId, vlanid, portNum);
    final GroupKey l2groupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l2gk));
    // assemble information for outer group
    GroupDescription outerGrpDesc = null;
    if (mpls) {
        // outer group is MPLSInteface
        int mplsInterfaceIndex = getNextAvailableIndex();
        int mplsgroupId = MPLS_INTERFACE_TYPE | (SUBTYPE_MASK & mplsInterfaceIndex);
        final GroupKey mplsgroupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(mplsInterfaceIndex));
        outerTtb.group(new DefaultGroupId(l2groupId));
        // create the mpls-interface group description to wait for the
        // l2 interface group to be processed
        GroupBucket mplsinterfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
        outerGrpDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(mplsinterfaceGroupBucket)), mplsgroupkey, mplsgroupId, appId);
        log.debug("Trying MPLS-Interface: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(mplsgroupId), mplsgroupkey, nextId);
    } else {
        // outer group is L3Unicast
        int l3unicastIndex = getNextAvailableIndex();
        int l3groupId = L3_UNICAST_TYPE | (TYPE_MASK & l3unicastIndex);
        final GroupKey l3groupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l3unicastIndex));
        outerTtb.group(new DefaultGroupId(l2groupId));
        // create the l3unicast group description to wait for the
        // l2 interface group to be processed
        GroupBucket l3unicastGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
        outerGrpDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3unicastGroupBucket)), l3groupkey, l3groupId, appId);
        log.debug("Trying L3Unicast: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l3groupId), l3groupkey, nextId);
    }
    // store l2groupkey with the groupChainElem for the outer-group that depends on it
    GroupChainElem gce = new GroupChainElem(outerGrpDesc, 1, false);
    updatePendingGroups(l2groupkey, gce);
    // create group description for the inner l2interfacegroup
    GroupBucket l2interfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(innerTtb.build());
    GroupDescription l2groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l2interfaceGroupBucket)), l2groupkey, l2groupId, appId);
    log.debug("Trying L2Interface: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l2groupId), l2groupkey, nextId);
    return new GroupInfo(l2groupDescription, outerGrpDesc);
}
#end_block

#method_before
private void processBroadcastNextObjective(NextObjective nextObj) {
    // break up broadcast next objective to multiple groups
    Collection<TrafficTreatment> buckets = nextObj.next();
    VlanId vlanId = readVlanFromMeta(nextObj);
    if (vlanId == null) {
        log.warn("Required VLAN ID info in nextObj metadata but not found. Aborting");
        return;
    }
    // each treatment is converted to an L2 interface group
    List<GroupDescription> l2interfaceGroupDescs = new ArrayList<>();
    List<Deque<GroupKey>> allGroupKeys = new ArrayList<>();
    for (TrafficTreatment treatment : buckets) {
        TrafficTreatment.Builder newTreatment = DefaultTrafficTreatment.builder();
        PortNumber portNum = null;
        // ensure that the only allowed treatments are pop-vlan and output
        for (Instruction ins : treatment.allInstructions()) {
            if (ins.type() == Instruction.Type.L2MODIFICATION) {
                L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
                switch(l2ins.subtype()) {
                    case VLAN_POP:
                        newTreatment.add(l2ins);
                        break;
                    default:
                        log.debug("action {} not permitted for broadcast nextObj", l2ins.subtype());
                        break;
                }
            } else if (ins.type() == Instruction.Type.OUTPUT) {
                portNum = ((Instructions.OutputInstruction) ins).port();
                newTreatment.add(ins);
            } else {
                log.debug("TrafficTreatment of type {} not permitted in " + " broadcast nextObjective", ins.type());
            }
        }
        // assemble info for l2 interface group
        int l2gk = l2InterfaceGroupKey(deviceId, vlanId, portNum.toLong());
        final GroupKey l2groupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l2gk));
        int l2groupId = L2_INTERFACE_TYPE | (vlanId.toShort() << 16) | (int) portNum.toLong();
        GroupBucket l2interfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(newTreatment.build());
        GroupDescription l2interfaceGroupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l2interfaceGroupBucket)), l2groupkey, l2groupId, nextObj.appId());
        log.debug("Trying L2-Interface: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l2groupId), l2groupkey, nextObj.id());
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        gkeyChain.addFirst(l2groupkey);
        // store the info needed to create this group
        l2interfaceGroupDescs.add(l2interfaceGroupDescription);
        allGroupKeys.add(gkeyChain);
    }
    // assemble info for l2 flood group
    // since there can be only one flood group for a vlan, its index is always the same - 0
    Integer l2floodgroupId = L2_FLOOD_TYPE | (vlanId.toShort() << 16);
    // int l2floodgk = L2_FLOOD_TYPE | nextObj.id() << 12;
    int l2floodgk = getNextAvailableIndex();
    final GroupKey l2floodgroupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l2floodgk));
    // collection of group buckets pointing to all the l2 interface groups
    List<GroupBucket> l2floodBuckets = new ArrayList<>();
    for (GroupDescription l2intGrpDesc : l2interfaceGroupDescs) {
        TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
        ttb.group(new DefaultGroupId(l2intGrpDesc.givenGroupId()));
        GroupBucket abucket = DefaultGroupBucket.createAllGroupBucket(ttb.build());
        l2floodBuckets.add(abucket);
    }
    // create the l2flood group-description to wait for all the
    // l2interface groups to be processed
    GroupDescription l2floodGroupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.ALL, new GroupBuckets(l2floodBuckets), l2floodgroupkey, l2floodgroupId, nextObj.appId());
    GroupChainElem gce = new GroupChainElem(l2floodGroupDescription, l2interfaceGroupDescs.size(), false);
    log.debug("Trying L2-Flood: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l2floodgroupId), l2floodgroupkey, nextObj.id());
    // create objects for local and distributed storage
    allGroupKeys.forEach(gkeyChain -> gkeyChain.addFirst(l2floodgroupkey));
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(allGroupKeys, nextObj);
    // store l2floodgroupkey with the ofdpaGroupChain for the nextObjective
    // that depends on it
    updatePendingNextObjective(l2floodgroupkey, ofdpaGrp);
    for (GroupDescription l2intGrpDesc : l2interfaceGroupDescs) {
        // store all l2groupkeys with the groupChainElem for the l2floodgroup
        // that depends on it
        updatePendingGroups(l2intGrpDesc.appCookie(), gce);
        // send groups for all l2 interface groups
        groupService.addGroup(l2intGrpDesc);
    }
}
#method_after
private void processBroadcastNextObjective(NextObjective nextObj) {
    // break up broadcast next objective to multiple groups
    Collection<TrafficTreatment> buckets = nextObj.next();
    VlanId vlanId = readVlanFromMeta(nextObj);
    if (vlanId == null) {
        log.warn("Required VLAN ID info in nextObj metadata but not found. Aborting");
        return;
    }
    // each treatment is converted to an L2 interface group
    List<GroupDescription> l2interfaceGroupDescs = new ArrayList<>();
    List<Deque<GroupKey>> allGroupKeys = new ArrayList<>();
    for (TrafficTreatment treatment : buckets) {
        TrafficTreatment.Builder newTreatment = DefaultTrafficTreatment.builder();
        PortNumber portNum = null;
        // ensure that the only allowed treatments are pop-vlan and output
        for (Instruction ins : treatment.allInstructions()) {
            if (ins.type() == Instruction.Type.L2MODIFICATION) {
                L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
                switch(l2ins.subtype()) {
                    case VLAN_POP:
                        newTreatment.add(l2ins);
                        break;
                    default:
                        log.debug("action {} not permitted for broadcast nextObj", l2ins.subtype());
                        break;
                }
            } else if (ins.type() == Instruction.Type.OUTPUT) {
                portNum = ((Instructions.OutputInstruction) ins).port();
                newTreatment.add(ins);
            } else {
                log.debug("TrafficTreatment of type {} not permitted in " + " broadcast nextObjective", ins.type());
            }
        }
        // assemble info for l2 interface group
        int l2gk = l2InterfaceGroupKey(deviceId, vlanId, portNum.toLong());
        final GroupKey l2groupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l2gk));
        int l2groupId = L2_INTERFACE_TYPE | (vlanId.toShort() << 16) | (int) portNum.toLong();
        GroupBucket l2interfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(newTreatment.build());
        GroupDescription l2interfaceGroupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l2interfaceGroupBucket)), l2groupkey, l2groupId, nextObj.appId());
        log.debug("Trying L2-Interface: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l2groupId), l2groupkey, nextObj.id());
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        gkeyChain.addFirst(l2groupkey);
        // store the info needed to create this group
        l2interfaceGroupDescs.add(l2interfaceGroupDescription);
        allGroupKeys.add(gkeyChain);
    }
    // assemble info for l2 flood group
    // since there can be only one flood group for a vlan, its index is always the same - 0
    Integer l2floodgroupId = L2_FLOOD_TYPE | (vlanId.toShort() << 16);
    int l2floodgk = getNextAvailableIndex();
    final GroupKey l2floodgroupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l2floodgk));
    // collection of group buckets pointing to all the l2 interface groups
    List<GroupBucket> l2floodBuckets = new ArrayList<>();
    for (GroupDescription l2intGrpDesc : l2interfaceGroupDescs) {
        TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
        ttb.group(new DefaultGroupId(l2intGrpDesc.givenGroupId()));
        GroupBucket abucket = DefaultGroupBucket.createAllGroupBucket(ttb.build());
        l2floodBuckets.add(abucket);
    }
    // create the l2flood group-description to wait for all the
    // l2interface groups to be processed
    GroupDescription l2floodGroupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.ALL, new GroupBuckets(l2floodBuckets), l2floodgroupkey, l2floodgroupId, nextObj.appId());
    GroupChainElem gce = new GroupChainElem(l2floodGroupDescription, l2interfaceGroupDescs.size(), false);
    log.debug("Trying L2-Flood: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l2floodgroupId), l2floodgroupkey, nextObj.id());
    // create objects for local and distributed storage
    allGroupKeys.forEach(gkeyChain -> gkeyChain.addFirst(l2floodgroupkey));
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(allGroupKeys, nextObj);
    // store l2floodgroupkey with the ofdpaGroupChain for the nextObjective
    // that depends on it
    updatePendingNextObjective(l2floodgroupkey, ofdpaGrp);
    for (GroupDescription l2intGrpDesc : l2interfaceGroupDescs) {
        // store all l2groupkeys with the groupChainElem for the l2floodgroup
        // that depends on it
        updatePendingGroups(l2intGrpDesc.appCookie(), gce);
        // send groups for all l2 interface groups
        groupService.addGroup(l2intGrpDesc);
    }
}
#end_block

#method_before
private void processHashedNextObjective(NextObjective nextObj) {
    // storage for all group keys in the chain of groups created
    List<Deque<GroupKey>> allGroupKeys = new ArrayList<>();
    List<GroupInfo> unsentGroups = new ArrayList<>();
    createHashBucketChains(nextObj, allGroupKeys, unsentGroups);
    // now we can create the outermost L3 ECMP group
    List<GroupBucket> l3ecmpGroupBuckets = new ArrayList<>();
    for (GroupInfo gi : unsentGroups) {
        // create ECMP bucket to point to the outer group
        TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
        ttb.group(new DefaultGroupId(gi.outerGrpDesc.givenGroupId()));
        GroupBucket sbucket = DefaultGroupBucket.createSelectGroupBucket(ttb.build());
        l3ecmpGroupBuckets.add(sbucket);
    }
    // int l3ecmpGroupId = L3_ECMP_TYPE | nextObj.id() << 12;
    int l3ecmpIndex = getNextAvailableIndex();
    int l3ecmpGroupId = L3_ECMP_TYPE | (TYPE_MASK & l3ecmpIndex);
    GroupKey l3ecmpGroupKey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l3ecmpIndex));
    GroupDescription l3ecmpGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.SELECT, new GroupBuckets(l3ecmpGroupBuckets), l3ecmpGroupKey, l3ecmpGroupId, nextObj.appId());
    GroupChainElem l3ecmpGce = new GroupChainElem(l3ecmpGroupDesc, l3ecmpGroupBuckets.size(), false);
    // create objects for local and distributed storage
    allGroupKeys.forEach(gkeyChain -> gkeyChain.addFirst(l3ecmpGroupKey));
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(allGroupKeys, nextObj);
    // store l3ecmpGroupKey with the ofdpaGroupChain for the nextObjective
    // that depends on it
    updatePendingNextObjective(l3ecmpGroupKey, ofdpaGrp);
    log.debug("Trying L3ECMP: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l3ecmpGroupId), l3ecmpGroupKey, nextObj.id());
    // finally we are ready to send the innermost groups
    for (GroupInfo gi : unsentGroups) {
        log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(gi.innerGrpDesc.givenGroupId()), deviceId);
        updatePendingGroups(gi.outerGrpDesc.appCookie(), l3ecmpGce);
        groupService.addGroup(gi.innerGrpDesc);
    }
}
#method_after
private void processHashedNextObjective(NextObjective nextObj) {
    // storage for all group keys in the chain of groups created
    List<Deque<GroupKey>> allGroupKeys = new ArrayList<>();
    List<GroupInfo> unsentGroups = new ArrayList<>();
    createHashBucketChains(nextObj, allGroupKeys, unsentGroups);
    // now we can create the outermost L3 ECMP group
    List<GroupBucket> l3ecmpGroupBuckets = new ArrayList<>();
    for (GroupInfo gi : unsentGroups) {
        // create ECMP bucket to point to the outer group
        TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
        ttb.group(new DefaultGroupId(gi.outerGrpDesc.givenGroupId()));
        GroupBucket sbucket = DefaultGroupBucket.createSelectGroupBucket(ttb.build());
        l3ecmpGroupBuckets.add(sbucket);
    }
    int l3ecmpIndex = getNextAvailableIndex();
    int l3ecmpGroupId = L3_ECMP_TYPE | (TYPE_MASK & l3ecmpIndex);
    GroupKey l3ecmpGroupKey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l3ecmpIndex));
    GroupDescription l3ecmpGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.SELECT, new GroupBuckets(l3ecmpGroupBuckets), l3ecmpGroupKey, l3ecmpGroupId, nextObj.appId());
    GroupChainElem l3ecmpGce = new GroupChainElem(l3ecmpGroupDesc, l3ecmpGroupBuckets.size(), false);
    // create objects for local and distributed storage
    allGroupKeys.forEach(gkeyChain -> gkeyChain.addFirst(l3ecmpGroupKey));
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(allGroupKeys, nextObj);
    // store l3ecmpGroupKey with the ofdpaGroupChain for the nextObjective
    // that depends on it
    updatePendingNextObjective(l3ecmpGroupKey, ofdpaGrp);
    log.debug("Trying L3ECMP: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l3ecmpGroupId), l3ecmpGroupKey, nextObj.id());
    // finally we are ready to send the innermost groups
    for (GroupInfo gi : unsentGroups) {
        log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(gi.innerGrpDesc.givenGroupId()), deviceId);
        updatePendingGroups(gi.outerGrpDesc.appCookie(), l3ecmpGce);
        groupService.addGroup(gi.innerGrpDesc);
    }
}
#end_block

#method_before
private void createHashBucketChains(NextObjective nextObj, List<Deque<GroupKey>> allGroupKeys, List<GroupInfo> unsentGroups) {
    // break up hashed next objective to multiple groups
    Collection<TrafficTreatment> buckets = nextObj.next();
    for (TrafficTreatment bucket : buckets) {
        // figure out how many labels are pushed in each bucket
        int labelsPushed = 0;
        MplsLabel innermostLabel = null;
        for (Instruction ins : bucket.allInstructions()) {
            if (ins.type() == Instruction.Type.L2MODIFICATION) {
                L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
                if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_PUSH) {
                    labelsPushed++;
                }
                if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_LABEL) {
                    if (innermostLabel == null) {
                        innermostLabel = ((L2ModificationInstruction.ModMplsLabelInstruction) l2ins).label();
                    }
                }
            }
        }
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        // XXX we only deal with 0 and 1 label push right now
        if (labelsPushed == 0) {
            GroupInfo nolabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), false, nextObj.meta());
            if (nolabelGroupInfo == null) {
                log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
                return;
            }
            gkeyChain.addFirst(nolabelGroupInfo.innerGrpDesc.appCookie());
            gkeyChain.addFirst(nolabelGroupInfo.outerGrpDesc.appCookie());
            // we can't send the inner group description yet, as we have to
            // create the dependent ECMP group first. So we store..
            unsentGroups.add(nolabelGroupInfo);
        } else if (labelsPushed == 1) {
            GroupInfo onelabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), true, nextObj.meta());
            if (onelabelGroupInfo == null) {
                log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
                return;
            }
            // we need to add another group to this chain - the L3VPN group
            TrafficTreatment.Builder l3vpnTtb = DefaultTrafficTreatment.builder();
            l3vpnTtb.pushMpls().setMpls(innermostLabel).setMplsBos(true).copyTtlOut().group(new DefaultGroupId(onelabelGroupInfo.outerGrpDesc.givenGroupId()));
            GroupBucket l3vpnGrpBkt = DefaultGroupBucket.createIndirectGroupBucket(l3vpnTtb.build());
            // int l3vpngroupId = MPLS_L3VPN_SUBTYPE | l3VpnIndex.incrementAndGet();
            // int l3vpngk = MPLS_L3VPN_SUBTYPE | nextObj.id() << 12 | l3VpnIndex.get();
            int l3vpnIndex = getNextAvailableIndex();
            int l3vpngroupId = MPLS_L3VPN_SUBTYPE | (SUBTYPE_MASK & l3vpnIndex);
            GroupKey l3vpngroupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l3vpnIndex));
            GroupDescription l3vpnGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3vpnGrpBkt)), l3vpngroupkey, l3vpngroupId, nextObj.appId());
            GroupChainElem l3vpnGce = new GroupChainElem(l3vpnGroupDesc, 1, false);
            updatePendingGroups(onelabelGroupInfo.outerGrpDesc.appCookie(), l3vpnGce);
            gkeyChain.addFirst(onelabelGroupInfo.innerGrpDesc.appCookie());
            gkeyChain.addFirst(onelabelGroupInfo.outerGrpDesc.appCookie());
            gkeyChain.addFirst(l3vpngroupkey);
            // now we can replace the outerGrpDesc with the one we just created
            onelabelGroupInfo.outerGrpDesc = l3vpnGroupDesc;
            // we can't send the innermost group yet, as we have to create
            // the dependent ECMP group first. So we store ...
            unsentGroups.add(onelabelGroupInfo);
            log.debug("Trying L3VPN: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l3vpngroupId), l3vpngroupkey, nextObj.id());
        } else {
            log.warn("Driver currently does not handle more than 1 MPLS " + "labels. Not processing nextObjective {}", nextObj.id());
            return;
        }
        // all groups in this chain
        allGroupKeys.add(gkeyChain);
    }
}
#method_after
private void createHashBucketChains(NextObjective nextObj, List<Deque<GroupKey>> allGroupKeys, List<GroupInfo> unsentGroups) {
    // break up hashed next objective to multiple groups
    Collection<TrafficTreatment> buckets = nextObj.next();
    for (TrafficTreatment bucket : buckets) {
        // figure out how many labels are pushed in each bucket
        int labelsPushed = 0;
        MplsLabel innermostLabel = null;
        for (Instruction ins : bucket.allInstructions()) {
            if (ins.type() == Instruction.Type.L2MODIFICATION) {
                L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
                if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_PUSH) {
                    labelsPushed++;
                }
                if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_LABEL) {
                    if (innermostLabel == null) {
                        innermostLabel = ((L2ModificationInstruction.ModMplsLabelInstruction) l2ins).label();
                    }
                }
            }
        }
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        // XXX we only deal with 0 and 1 label push right now
        if (labelsPushed == 0) {
            GroupInfo nolabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), false, nextObj.meta());
            if (nolabelGroupInfo == null) {
                log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
                return;
            }
            gkeyChain.addFirst(nolabelGroupInfo.innerGrpDesc.appCookie());
            gkeyChain.addFirst(nolabelGroupInfo.outerGrpDesc.appCookie());
            // we can't send the inner group description yet, as we have to
            // create the dependent ECMP group first. So we store..
            unsentGroups.add(nolabelGroupInfo);
        } else if (labelsPushed == 1) {
            GroupInfo onelabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), true, nextObj.meta());
            if (onelabelGroupInfo == null) {
                log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
                return;
            }
            // we need to add another group to this chain - the L3VPN group
            TrafficTreatment.Builder l3vpnTtb = DefaultTrafficTreatment.builder();
            l3vpnTtb.pushMpls().setMpls(innermostLabel).setMplsBos(true).copyTtlOut().group(new DefaultGroupId(onelabelGroupInfo.outerGrpDesc.givenGroupId()));
            GroupBucket l3vpnGrpBkt = DefaultGroupBucket.createIndirectGroupBucket(l3vpnTtb.build());
            int l3vpnIndex = getNextAvailableIndex();
            int l3vpngroupId = MPLS_L3VPN_SUBTYPE | (SUBTYPE_MASK & l3vpnIndex);
            GroupKey l3vpngroupkey = new DefaultGroupKey(OFDPA2Pipeline.appKryo.serialize(l3vpnIndex));
            GroupDescription l3vpnGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3vpnGrpBkt)), l3vpngroupkey, l3vpngroupId, nextObj.appId());
            GroupChainElem l3vpnGce = new GroupChainElem(l3vpnGroupDesc, 1, false);
            updatePendingGroups(onelabelGroupInfo.outerGrpDesc.appCookie(), l3vpnGce);
            gkeyChain.addFirst(onelabelGroupInfo.innerGrpDesc.appCookie());
            gkeyChain.addFirst(onelabelGroupInfo.outerGrpDesc.appCookie());
            gkeyChain.addFirst(l3vpngroupkey);
            // now we can replace the outerGrpDesc with the one we just created
            onelabelGroupInfo.outerGrpDesc = l3vpnGroupDesc;
            // we can't send the innermost group yet, as we have to create
            // the dependent ECMP group first. So we store ...
            unsentGroups.add(onelabelGroupInfo);
            log.debug("Trying L3VPN: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l3vpngroupId), l3vpngroupkey, nextObj.id());
        } else {
            log.warn("Driver currently does not handle more than 1 MPLS " + "labels. Not processing nextObjective {}", nextObj.id());
            return;
        }
        // all groups in this chain
        allGroupKeys.add(gkeyChain);
    }
}
#end_block

#method_before
@Override
public void startReport() {
    try {
        ganglia = new GMetric(address, port, GANGLIA_MODE, ttl);
        MetricRegistry mr = metricsService.getMetricRegistry();
        gangliaReporter = GangliaReporter.forRegistry(filter(mr)).convertRatesTo(TimeUnit.SECONDS).convertDurationsTo(TimeUnit.MILLISECONDS).build(ganglia);
        gangliaReporter.start(REPORT_PERIOD, REPORT_TIME_UNIT);
    } catch (IOException e) {
        e.printStackTrace();
    }
}
#method_after
@Override
public void startReport() {
    try {
        ganglia = new GMetric(address, port, GANGLIA_MODE, ttl);
        MetricRegistry mr = metricsService.getMetricRegistry();
        gangliaReporter = GangliaReporter.forRegistry(filter(mr)).convertRatesTo(TimeUnit.SECONDS).convertDurationsTo(TimeUnit.MILLISECONDS).build(ganglia);
        gangliaReporter.start(REPORT_PERIOD, REPORT_TIME_UNIT);
    } catch (IOException e) {
        log.error("Fail to connect to given ganglia server!");
    }
}
#end_block

#method_before
private void readComponentConfiguration(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    String addressStr = Tools.get(properties, "address");
    address = addressStr != null ? addressStr : DEFAULT_ADDRESS;
    log.info("Configured. Ganglia server address is {}", address);
    String metricNameStr = Tools.get(properties, "metricNames");
    metricNames = metricNameStr != null ? metricNameStr : DEFAULT_METRIC_NAMES;
    log.info("Configured. Metric name is {}", metricNames);
    Integer portConfigured = getIntegerProperty(properties, "port");
    if (portConfigured == null) {
        port = DEFAULT_PORT;
        log.info("Ganglia port is not configured, default value is {}", port);
    }
    Integer ttlConfigured = getIntegerProperty(properties, "ttl");
    if (ttlConfigured == null) {
        ttl = DEFAULT_TTL;
        log.info("Ganglia TTL is not configured, default value is {}", ttl);
    }
    boolean monitorAllEnabled = isPropertyEnabled(properties, "monitorAll");
    if (monitorAll != monitorAllEnabled) {
        monitorAll = monitorAllEnabled;
        log.info("Configured. Monitor all metrics is {}", monitorAll ? "enabled" : "disabled");
    }
}
#method_after
private void readComponentConfiguration(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    String addressStr = Tools.get(properties, "address");
    address = addressStr != null ? addressStr : DEFAULT_ADDRESS;
    log.info("Configured. Ganglia server address is {}", address);
    String metricNameStr = Tools.get(properties, "metricNames");
    metricNames = metricNameStr != null ? metricNameStr : DEFAULT_METRIC_NAMES;
    log.info("Configured. Metric name is {}", metricNames);
    Integer portConfigured = Tools.getIntegerProperty(properties, "port");
    if (portConfigured == null) {
        port = DEFAULT_PORT;
        log.info("Ganglia port is not configured, default value is {}", port);
    } else {
        port = portConfigured;
        log.info("Configured. Ganglia port is configured to {}", port);
    }
    Integer ttlConfigured = Tools.getIntegerProperty(properties, "ttl");
    if (ttlConfigured == null) {
        ttl = DEFAULT_TTL;
        log.info("Ganglia TTL is not configured, default value is {}", ttl);
    } else {
        ttl = ttlConfigured;
        log.info("Configured. Ganglia TTL is configured to {}", ttl);
    }
    Boolean monitorAllEnabled = Tools.isPropertyEnabled(properties, "monitorAll");
    if (monitorAllEnabled == null) {
        log.info("Monitor all metrics is not configured, " + "using current value of {}", monitorAll);
    } else {
        monitorAll = monitorAllEnabled;
        log.info("Configured. Monitor all metrics is {}", monitorAll ? "enabled" : "disabled");
    }
}
#end_block

#method_before
@Test
public void processMinElementsInvalidValue() throws IOException, ParserException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("mismatched input 'asd' expecting INTEGER");
    YangNode node = manager.getDataModel("src/test/resources/MinElementsInvalidValue.yang");
}
#method_after
@Test
public void processMinElementsInvalidValue() throws IOException, ParserException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("YANG file error : min-elements value asd is not valid.");
    YangNode node = manager.getDataModel("src/test/resources/MinElementsInvalidValue.yang");
}
#end_block

#method_before
@Test
public void processConfigInvalidValue() throws IOException, ParserException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("Invalid content in config \"invalid\" before processing.");
    YangNode node = manager.getDataModel("src/test/resources/ConfigInvalidValue.yang");
}
#method_after
@Test
public void processConfigInvalidValue() throws IOException, ParserException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("YANG file error : config value invalid is not valid.");
    YangNode node = manager.getDataModel("src/test/resources/ConfigInvalidValue.yang");
}
#end_block

#method_before
public static void processMandatoryEntry(TreeWalkListener listener, GeneratedYangParser.MandatoryStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, MANDATORY_DATA, "", ENTRY);
    boolean isMandatory = getValidMandatoryValue(ctx);
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getYangConstructType()) {
        case LEAF_DATA:
            YangLeaf leaf = (YangLeaf) tmpNode;
            leaf.setMandatory(isMandatory);
            break;
        case // TODO
        CHOICE_DATA:
            break;
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, MANDATORY_DATA, "", ENTRY));
    }
}
#method_after
public static void processMandatoryEntry(TreeWalkListener listener, GeneratedYangParser.MandatoryStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, MANDATORY_DATA, "", ENTRY);
    boolean isMandatory = getValidBooleanValue(ctx.mandatory().getText(), MANDATORY_DATA, ctx);
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getYangConstructType()) {
        case LEAF_DATA:
            YangLeaf leaf = (YangLeaf) tmpNode;
            leaf.setMandatory(isMandatory);
            break;
        case // TODO
        CHOICE_DATA:
            break;
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, MANDATORY_DATA, "", ENTRY));
    }
}
#end_block

#method_before
public static void processKeyEntry(TreeWalkListener listener, GeneratedYangParser.KeyStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, KEY_DATA, ctx.key().getText(), ENTRY);
    Parsable tmpData = listener.getParsedDataStack().peek();
    if (listener.getParsedDataStack().peek() instanceof YangList) {
        YangList yangList = (YangList) tmpData;
        String tmpKeyValue = ctx.key().getText().replace("\"", "");
        if (tmpKeyValue.contains(" ")) {
            String[] keyValues = tmpKeyValue.split(" ");
            for (String keyValue : keyValues) {
                try {
                    yangList.addKey(keyValue);
                } catch (DataModelException e) {
                    throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, KEY_DATA, ctx.key().getText(), ENTRY, e.getMessage()));
                }
            }
        } else {
            try {
                yangList.addKey(tmpKeyValue);
            } catch (DataModelException e) {
                throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, KEY_DATA, ctx.key().getText(), ENTRY, e.getMessage()));
            }
        }
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, KEY_DATA, ctx.key().getText(), ENTRY));
    }
}
#method_after
public static void processKeyEntry(TreeWalkListener listener, GeneratedYangParser.KeyStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, KEY_DATA, ctx.key().getText(), ENTRY);
    Parsable tmpData = listener.getParsedDataStack().peek();
    if (listener.getParsedDataStack().peek() instanceof YangList) {
        YangList yangList = (YangList) tmpData;
        String tmpKeyValue = removeQuotesAndHandleConcat(ctx.key().getText());
        if (tmpKeyValue.contains(" ")) {
            String[] keyValues = tmpKeyValue.split(" ");
            for (String keyValue : keyValues) {
                try {
                    yangList.addKey(keyValue);
                } catch (DataModelException e) {
                    throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, KEY_DATA, ctx.key().getText(), ENTRY, e.getMessage()));
                }
            }
        } else {
            try {
                yangList.addKey(tmpKeyValue);
            } catch (DataModelException e) {
                throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, KEY_DATA, ctx.key().getText(), ENTRY, e.getMessage()));
            }
        }
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, KEY_DATA, ctx.key().getText(), ENTRY));
    }
}
#end_block

#method_before
public static void processPositionEntry(TreeWalkListener listener, GeneratedYangParser.PositionStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, POSITION_DATA, ctx.position().getText(), ENTRY);
    String position = removeQuotesAndHandleConcat(ctx.position().getText());
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getYangConstructType()) {
        case BIT_DATA:
            {
                YangBit bitNode = (YangBit) tmpNode;
                if (!isBitPositionValid(listener, ctx, position)) {
                    ParserException parserException = new ParserException(errMsg);
                    parserException.setLine(ctx.getStart().getLine());
                    parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                    throw parserException;
                }
                bitNode.setPosition(Integer.valueOf(position));
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, POSITION_DATA, ctx.position().getText(), ENTRY));
    }
}
#method_after
public static void processPositionEntry(TreeWalkListener listener, GeneratedYangParser.PositionStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, POSITION_DATA, ctx.position().getText(), ENTRY);
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getYangConstructType()) {
        case BIT_DATA:
            {
                YangBit bitNode = (YangBit) tmpNode;
                int positionValue = getValidBitPosition(listener, ctx);
                bitNode.setPosition(positionValue);
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, POSITION_DATA, ctx.position().getText(), ENTRY));
    }
}
#end_block

#method_before
public static void processConfigEntry(TreeWalkListener listener, GeneratedYangParser.ConfigStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, CONFIG_DATA, "", ENTRY);
    boolean isConfig = getValidConfigValue(ctx);
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getYangConstructType()) {
        case LEAF_DATA:
            YangLeaf leaf = (YangLeaf) tmpData;
            leaf.setConfig(isConfig);
            break;
        case CONTAINER_DATA:
            YangContainer container = (YangContainer) tmpData;
            container.setConfig(isConfig);
            break;
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setConfig(isConfig);
            break;
        case LIST_DATA:
            YangList yangList = (YangList) tmpData;
            yangList.setConfig(isConfig);
            break;
        case // TODO
        CHOICE_DATA:
            break;
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, CONFIG_DATA, "", ENTRY));
    }
}
#method_after
public static void processConfigEntry(TreeWalkListener listener, GeneratedYangParser.ConfigStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, CONFIG_DATA, "", ENTRY);
    boolean isConfig = getValidBooleanValue(ctx.config().getText(), CONFIG_DATA, ctx);
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getYangConstructType()) {
        case LEAF_DATA:
            YangLeaf leaf = (YangLeaf) tmpData;
            leaf.setConfig(isConfig);
            break;
        case CONTAINER_DATA:
            YangContainer container = (YangContainer) tmpData;
            container.setConfig(isConfig);
            break;
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setConfig(isConfig);
            break;
        case LIST_DATA:
            YangList yangList = (YangList) tmpData;
            yangList.setConfig(isConfig);
            break;
        case // TODO
        CHOICE_DATA:
            break;
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, CONFIG_DATA, "", ENTRY));
    }
}
#end_block

#method_before
@Test
public void processMinElementsInvalidValue() throws IOException, ParserException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("Invalid content in min-elements \"asd\" before processing");
    YangNode node = manager.getDataModel("src/test/resources/MinElementsInvalidValue.yang");
}
#method_after
@Test
public void processMinElementsInvalidValue() throws IOException, ParserException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("YANG file error : min-elements value asd is not valid.");
    YangNode node = manager.getDataModel("src/test/resources/MinElementsInvalidValue.yang");
}
#end_block

#method_before
private static int getValidMaxElementValue(GeneratedYangParser.MaxElementsStatementContext ctx) {
    int maxElementsValue;
    String value = removeQuotesAndHandleConcat(ctx.maxValue().getText());
    if (value.equals(UNBOUNDED_KEYWORD)) {
        maxElementsValue = Integer.MAX_VALUE;
    } else if (value.matches(INTEGER_PATTERN)) {
        maxElementsValue = Integer.parseInt(value);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_CONTENT, MAX_ELEMENT_DATA, value, ENTRY));
    }
    return maxElementsValue;
}
#method_after
private static int getValidMaxElementValue(GeneratedYangParser.MaxElementsStatementContext ctx) {
    int maxElementsValue;
    String value = removeQuotesAndHandleConcat(ctx.maxValue().getText());
    if (value.equals(UNBOUNDED_KEYWORD)) {
        maxElementsValue = Integer.MAX_VALUE;
    } else if (value.matches(POSITIVE_INTEGER_PATTERN)) {
        maxElementsValue = Integer.parseInt(value);
    } else {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(MAX_ELEMENT_DATA) + " value " + value + " is not " + "valid.");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    return maxElementsValue;
}
#end_block

#method_before
public static void processMinElementsEntry(TreeWalkListener listener, GeneratedYangParser.MinElementsStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, MIN_ELEMENT_DATA, ctx.minValue().getText(), ENTRY);
    int minElementValue = getValidMinElementValue(ctx);
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getYangConstructType()) {
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setMinElements(minElementValue);
            break;
        case LIST_DATA:
            YangList yangList = (YangList) tmpData;
            yangList.setMinElements(minElementValue);
            break;
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, MIN_ELEMENT_DATA, ctx.minValue().getText(), ENTRY));
    }
}
#method_after
public static void processMinElementsEntry(TreeWalkListener listener, GeneratedYangParser.MinElementsStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, MIN_ELEMENT_DATA, ctx.minValue().getText(), ENTRY);
    int minElementValue = getValidNonNegativeIntegerValue(ctx.minValue().getText(), MIN_ELEMENT_DATA, ctx);
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getYangConstructType()) {
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setMinElements(minElementValue);
            break;
        case LIST_DATA:
            YangList yangList = (YangList) tmpData;
            yangList.setMinElements(minElementValue);
            break;
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, MIN_ELEMENT_DATA, ctx.minValue().getText(), ENTRY));
    }
}
#end_block

#method_before
public static void processVersionEntry(TreeWalkListener listener, GeneratedYangParser.YangVersionStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, VERSION_DATA, ctx.version().getText(), ENTRY);
    String version = removeQuotesAndHandleConcat(ctx.version().getText());
    if (!isVersionValid(Integer.valueOf(version))) {
        ParserException parserException = new ParserException("YANG file error: Input version not supported");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getYangConstructType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                module.setVersion((byte) 1);
                break;
            }
        case SUB_MODULE_DATA:
            {
                YangSubModule subModule = (YangSubModule) tmpNode;
                subModule.setVersion((byte) 1);
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, VERSION_DATA, ctx.version().getText(), ENTRY));
    }
}
#method_after
public static void processVersionEntry(TreeWalkListener listener, GeneratedYangParser.YangVersionStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, VERSION_DATA, ctx.version().getText(), ENTRY);
    byte version = getValidVersion(ctx);
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getYangConstructType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                module.setVersion(version);
                break;
            }
        case SUB_MODULE_DATA:
            {
                YangSubModule subModule = (YangSubModule) tmpNode;
                subModule.setVersion(version);
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, VERSION_DATA, ctx.version().getText(), ENTRY));
    }
}
#end_block

#method_before
public static Integer getIntegerProperty(Dictionary<?, ?> properties, String propertyName) {
    Integer value = null;
    try {
        String s = Tools.get(properties, propertyName);
        value = Strings.isNullOrEmpty(s) ? value : Integer.parseInt(s);
    } catch (NumberFormatException | ClassCastException e) {
        value = null;
    }
    return value;
}
#method_after
public static Integer getIntegerProperty(Dictionary<?, ?> properties, String propertyName) {
    Integer value;
    try {
        String s = get(properties, propertyName);
        value = Strings.isNullOrEmpty(s) ? null : Integer.valueOf(s);
    } catch (NumberFormatException | ClassCastException e) {
        value = null;
    }
    return value;
}
#end_block

#method_before
public static Integer getIntegerProperty(Dictionary<?, ?> properties, String propertyName) {
    Integer value = null;
    try {
        String s = Tools.get(properties, propertyName);
        value = Strings.isNullOrEmpty(s) ? value : Integer.parseInt(s);
    } catch (NumberFormatException | ClassCastException e) {
        value = null;
    }
    return value;
}
#method_after
public static int getIntegerProperty(Dictionary<?, ?> properties, String propertyName, int defaultValue) {
    try {
        String s = get(properties, propertyName);
        return Strings.isNullOrEmpty(s) ? defaultValue : Integer.valueOf(s);
    } catch (NumberFormatException | ClassCastException e) {
        return defaultValue;
    }
}
#end_block

#method_before
public static Boolean isPropertyEnabled(Dictionary<?, ?> properties, String propertyName) {
    Boolean value = null;
    try {
        String s = (String) properties.get(propertyName);
        value = Strings.isNullOrEmpty(s) ? null : s.trim().equals("true");
    } catch (ClassCastException e) {
        // No propertyName defined.
        value = null;
    }
    return value;
}
#method_after
public static Boolean isPropertyEnabled(Dictionary<?, ?> properties, String propertyName) {
    Boolean value;
    try {
        String s = get(properties, propertyName);
        value = Strings.isNullOrEmpty(s) ? null : Boolean.valueOf(s);
    } catch (ClassCastException e) {
        value = null;
    }
    return value;
}
#end_block

#method_before
public static Boolean isPropertyEnabled(Dictionary<?, ?> properties, String propertyName) {
    Boolean value = null;
    try {
        String s = (String) properties.get(propertyName);
        value = Strings.isNullOrEmpty(s) ? null : s.trim().equals("true");
    } catch (ClassCastException e) {
        // No propertyName defined.
        value = null;
    }
    return value;
}
#method_after
public static boolean isPropertyEnabled(Dictionary<?, ?> properties, String propertyName, boolean defaultValue) {
    try {
        String s = get(properties, propertyName);
        return Strings.isNullOrEmpty(s) ? defaultValue : Boolean.valueOf(s);
    } catch (ClassCastException e) {
        return defaultValue;
    }
}
#end_block

#method_before
private void readComponentConfiguration(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    Boolean packetOutOnlyEnabled = Tools.isPropertyEnabled(properties, "packetOutOnly");
    if (packetOutOnlyEnabled == null) {
        log.info("Packet-out is not configured, " + "using current value of {}", packetOutOnly);
    } else {
        packetOutOnly = packetOutOnlyEnabled;
        log.info("Configured. Packet-out only forwarding is {}", packetOutOnly ? "enabled" : "disabled");
    }
    Boolean packetOutOfppTableEnabled = Tools.isPropertyEnabled(properties, "packetOutOfppTable");
    if (packetOutOfppTableEnabled == null) {
        log.info("OFPP_TABLE port is not configured, " + "using current value of {}", packetOutOfppTable);
    } else {
        packetOutOfppTable = packetOutOfppTableEnabled;
        log.info("Configured. Forwarding using OFPP_TABLE port is {}", packetOutOfppTable ? "enabled" : "disabled");
    }
    Boolean ipv6ForwardingEnabled = Tools.isPropertyEnabled(properties, "ipv6Forwarding");
    if (ipv6ForwardingEnabled == null) {
        log.info("IPv6 forwarding is not configured, " + "using current value of {}", ipv6Forwarding);
    } else {
        ipv6Forwarding = ipv6ForwardingEnabled;
        log.info("Configured. IPv6 forwarding is {}", ipv6Forwarding ? "enabled" : "disabled");
    }
    Boolean matchDstMacOnlyEnabled = Tools.isPropertyEnabled(properties, "matchDstMacOnly");
    if (matchDstMacOnlyEnabled == null) {
        log.info("Match Dst MAC is not configured, " + "using current value of {}", matchDstMacOnly);
    } else {
        matchDstMacOnly = matchDstMacOnlyEnabled;
        log.info("Configured. Match Dst MAC Only is {}", matchDstMacOnly ? "enabled" : "disabled");
    }
    Boolean matchVlanIdEnabled = Tools.isPropertyEnabled(properties, "matchVlanId");
    if (matchVlanIdEnabled == null) {
        log.info("Matching Vlan ID is not configured, " + "using current value of {}", matchVlanId);
    } else {
        matchVlanId = matchVlanIdEnabled;
        log.info("Configured. Matching Vlan ID is {}", matchVlanId ? "enabled" : "disabled");
    }
    Boolean matchIpv4AddressEnabled = Tools.isPropertyEnabled(properties, "matchIpv4Address");
    if (matchIpv4AddressEnabled == null) {
        log.info("Matching IPv4 Address is not configured, " + "using current value of {}", matchIpv4Address);
    } else {
        matchIpv4Address = matchIpv4AddressEnabled;
        log.info("Configured. Matching IPv4 Addresses is {}", matchIpv4Address ? "enabled" : "disabled");
    }
    Boolean matchIpv4DscpEnabled = Tools.isPropertyEnabled(properties, "matchIpv4Dscp");
    if (matchIpv4DscpEnabled == null) {
        log.info("Matching IPv4 DSCP and ECN is not configured, " + "using current value of {}", matchIpv4Dscp);
    } else {
        matchIpv4Dscp = matchIpv4DscpEnabled;
        log.info("Configured. Matching IPv4 DSCP and ECN is {}", matchIpv4Dscp ? "enabled" : "disabled");
    }
    Boolean matchIpv6AddressEnabled = Tools.isPropertyEnabled(properties, "matchIpv6Address");
    if (matchIpv6AddressEnabled == null) {
        log.info("Matching IPv6 Address is not configured, " + "using current value of {}", matchIpv6Address);
    } else {
        matchIpv6Address = matchIpv6AddressEnabled;
        log.info("Configured. Matching IPv6 Addresses is {}", matchIpv6Address ? "enabled" : "disabled");
    }
    Boolean matchIpv6FlowLabelEnabled = Tools.isPropertyEnabled(properties, "matchIpv6FlowLabel");
    if (matchIpv6FlowLabelEnabled == null) {
        log.info("Matching IPv6 FlowLabel is not configured, " + "using current value of {}", matchIpv6FlowLabel);
    } else {
        matchIpv6FlowLabel = matchIpv6FlowLabelEnabled;
        log.info("Configured. Matching IPv6 FlowLabel is {}", matchIpv6FlowLabel ? "enabled" : "disabled");
    }
    Boolean matchTcpUdpPortsEnabled = Tools.isPropertyEnabled(properties, "matchTcpUdpPorts");
    if (matchTcpUdpPortsEnabled == null) {
        log.info("Matching TCP/UDP fields is not configured, " + "using current value of {}", matchTcpUdpPorts);
    } else {
        matchTcpUdpPorts = matchTcpUdpPortsEnabled;
        log.info("Configured. Matching TCP/UDP fields is {}", matchTcpUdpPorts ? "enabled" : "disabled");
    }
    Boolean matchIcmpFieldsEnabled = Tools.isPropertyEnabled(properties, "matchIcmpFields");
    if (matchIcmpFieldsEnabled == null) {
        log.info("Matching ICMP (v4 and v6) fields is not configured, " + "using current value of {}", matchIcmpFields);
    } else {
        matchIcmpFields = matchIcmpFieldsEnabled;
        log.info("Configured. Matching ICMP (v4 and v6) fields is {}", matchIcmpFields ? "enabled" : "disabled");
    }
    Integer flowTimeoutConfigured = Tools.getIntegerProperty(properties, "flowTimeout");
    if (flowTimeoutConfigured == null) {
        flowTimeout = DEFAULT_TIMEOUT;
        log.info("Flow Timeout is not configured, default value is {}", flowTimeout);
    } else {
        flowTimeout = flowTimeoutConfigured;
        log.info("Configured. Flow Timeout is configured to {}", flowTimeout, " seconds");
    }
    Integer flowPriorityConfigured = Tools.getIntegerProperty(properties, "flowPriority");
    if (flowPriorityConfigured == null) {
        flowPriority = DEFAULT_PRIORITY;
        log.info("Flow Priority is not configured, default value is {}", flowPriority);
    } else {
        flowPriority = flowPriorityConfigured;
        log.info("Configured. Flow Priority is configured to {}", flowPriority);
    }
    Boolean ignoreIpv4McastPacketsEnabled = Tools.isPropertyEnabled(properties, "ignoreIpv4McastPackets");
    if (ignoreIpv4McastPacketsEnabled == null) {
        log.info("Ignore IPv4 multi-cast packet is not configured, " + "using current value of {}", ignoreIpv4McastPackets);
    } else {
        ignoreIpv4McastPackets = ignoreIpv4McastPacketsEnabled;
        log.info("Configured. Ignore IPv4 multicast packets is {}", ignoreIpv4McastPackets ? "enabled" : "disabled");
    }
}
#method_after
private void readComponentConfiguration(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    Boolean packetOutOnlyEnabled = Tools.isPropertyEnabled(properties, "packetOutOnly");
    if (packetOutOnlyEnabled == null) {
        log.info("Packet-out is not configured, " + "using current value of {}", packetOutOnly);
    } else {
        packetOutOnly = packetOutOnlyEnabled;
        log.info("Configured. Packet-out only forwarding is {}", packetOutOnly ? "enabled" : "disabled");
    }
    Boolean packetOutOfppTableEnabled = Tools.isPropertyEnabled(properties, "packetOutOfppTable");
    if (packetOutOfppTableEnabled == null) {
        log.info("OFPP_TABLE port is not configured, " + "using current value of {}", packetOutOfppTable);
    } else {
        packetOutOfppTable = packetOutOfppTableEnabled;
        log.info("Configured. Forwarding using OFPP_TABLE port is {}", packetOutOfppTable ? "enabled" : "disabled");
    }
    Boolean ipv6ForwardingEnabled = Tools.isPropertyEnabled(properties, "ipv6Forwarding");
    if (ipv6ForwardingEnabled == null) {
        log.info("IPv6 forwarding is not configured, " + "using current value of {}", ipv6Forwarding);
    } else {
        ipv6Forwarding = ipv6ForwardingEnabled;
        log.info("Configured. IPv6 forwarding is {}", ipv6Forwarding ? "enabled" : "disabled");
    }
    Boolean matchDstMacOnlyEnabled = Tools.isPropertyEnabled(properties, "matchDstMacOnly");
    if (matchDstMacOnlyEnabled == null) {
        log.info("Match Dst MAC is not configured, " + "using current value of {}", matchDstMacOnly);
    } else {
        matchDstMacOnly = matchDstMacOnlyEnabled;
        log.info("Configured. Match Dst MAC Only is {}", matchDstMacOnly ? "enabled" : "disabled");
    }
    Boolean matchVlanIdEnabled = Tools.isPropertyEnabled(properties, "matchVlanId");
    if (matchVlanIdEnabled == null) {
        log.info("Matching Vlan ID is not configured, " + "using current value of {}", matchVlanId);
    } else {
        matchVlanId = matchVlanIdEnabled;
        log.info("Configured. Matching Vlan ID is {}", matchVlanId ? "enabled" : "disabled");
    }
    Boolean matchIpv4AddressEnabled = Tools.isPropertyEnabled(properties, "matchIpv4Address");
    if (matchIpv4AddressEnabled == null) {
        log.info("Matching IPv4 Address is not configured, " + "using current value of {}", matchIpv4Address);
    } else {
        matchIpv4Address = matchIpv4AddressEnabled;
        log.info("Configured. Matching IPv4 Addresses is {}", matchIpv4Address ? "enabled" : "disabled");
    }
    Boolean matchIpv4DscpEnabled = Tools.isPropertyEnabled(properties, "matchIpv4Dscp");
    if (matchIpv4DscpEnabled == null) {
        log.info("Matching IPv4 DSCP and ECN is not configured, " + "using current value of {}", matchIpv4Dscp);
    } else {
        matchIpv4Dscp = matchIpv4DscpEnabled;
        log.info("Configured. Matching IPv4 DSCP and ECN is {}", matchIpv4Dscp ? "enabled" : "disabled");
    }
    Boolean matchIpv6AddressEnabled = Tools.isPropertyEnabled(properties, "matchIpv6Address");
    if (matchIpv6AddressEnabled == null) {
        log.info("Matching IPv6 Address is not configured, " + "using current value of {}", matchIpv6Address);
    } else {
        matchIpv6Address = matchIpv6AddressEnabled;
        log.info("Configured. Matching IPv6 Addresses is {}", matchIpv6Address ? "enabled" : "disabled");
    }
    Boolean matchIpv6FlowLabelEnabled = Tools.isPropertyEnabled(properties, "matchIpv6FlowLabel");
    if (matchIpv6FlowLabelEnabled == null) {
        log.info("Matching IPv6 FlowLabel is not configured, " + "using current value of {}", matchIpv6FlowLabel);
    } else {
        matchIpv6FlowLabel = matchIpv6FlowLabelEnabled;
        log.info("Configured. Matching IPv6 FlowLabel is {}", matchIpv6FlowLabel ? "enabled" : "disabled");
    }
    Boolean matchTcpUdpPortsEnabled = Tools.isPropertyEnabled(properties, "matchTcpUdpPorts");
    if (matchTcpUdpPortsEnabled == null) {
        log.info("Matching TCP/UDP fields is not configured, " + "using current value of {}", matchTcpUdpPorts);
    } else {
        matchTcpUdpPorts = matchTcpUdpPortsEnabled;
        log.info("Configured. Matching TCP/UDP fields is {}", matchTcpUdpPorts ? "enabled" : "disabled");
    }
    Boolean matchIcmpFieldsEnabled = Tools.isPropertyEnabled(properties, "matchIcmpFields");
    if (matchIcmpFieldsEnabled == null) {
        log.info("Matching ICMP (v4 and v6) fields is not configured, " + "using current value of {}", matchIcmpFields);
    } else {
        matchIcmpFields = matchIcmpFieldsEnabled;
        log.info("Configured. Matching ICMP (v4 and v6) fields is {}", matchIcmpFields ? "enabled" : "disabled");
    }
    Boolean ignoreIpv4McastPacketsEnabled = Tools.isPropertyEnabled(properties, "ignoreIpv4McastPackets");
    if (ignoreIpv4McastPacketsEnabled == null) {
        log.info("Ignore IPv4 multi-cast packet is not configured, " + "using current value of {}", ignoreIpv4McastPackets);
    } else {
        ignoreIpv4McastPackets = ignoreIpv4McastPacketsEnabled;
        log.info("Configured. Ignore IPv4 multicast packets is {}", ignoreIpv4McastPackets ? "enabled" : "disabled");
    }
    flowTimeout = Tools.getIntegerProperty(properties, "flowTimeout", DEFAULT_TIMEOUT);
    log.info("Configured. Flow Timeout is configured to {}", flowTimeout, " seconds");
    flowPriority = Tools.getIntegerProperty(properties, "flowPriority", DEFAULT_PRIORITY);
    log.info("Configured. Flow Priority is configured to {}", flowPriority);
}
#end_block

#method_before
@Override
public List<String> getNextMappings(NextGroup nextGroup) {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public List<String> getNextMappings(NextGroup nextGroup) {
    return null;
}
#end_block

#method_before
@Override
public List<String> getNextMappings(NextGroup nextGroup) {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public List<String> getNextMappings(NextGroup nextGroup) {
    // nextObjectives converted to flow-actions not groups
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public void initPolicy(String policy) {
    this.policy = policy;
    deviceService.getDevices().forEach(device -> this.deviceCompositionTreeMap.put(device.id(), FlowObjectiveCompositionUtil.parsePolicyString(policy)));
    log.info("Initialize policy {}", policy);
}
#method_after
@Override
public void initPolicy(String policy) {
    checkPermission(FLOWRULE_WRITE);
    this.policy = policy;
    deviceService.getDevices().forEach(device -> this.deviceCompositionTreeMap.put(device.id(), FlowObjectiveCompositionUtil.parsePolicyString(policy)));
    log.info("Initialize policy {}", policy);
}
#end_block

#method_before
@Override
public List<String> getNextMappings() {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public List<String> getNextMappings() {
    // TODO Implementation deferred as this is an experimental component.
    return null;
}
#end_block

#method_before
@Override
public List<String> getNextMappings(NextGroup nextGroup) {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public List<String> getNextMappings(NextGroup nextGroup) {
    // TODO Implementation deferred to vendor
    return null;
}
#end_block

#method_before
@Override
public List<String> getNextMappings(NextGroup nextGroup) {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public List<String> getNextMappings(NextGroup nextGroup) {
    // TODO Implementation deferred to vendor
    return null;
}
#end_block

#method_before
@Override
public List<String> getNextMappings(NextGroup nextGroup) {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public List<String> getNextMappings(NextGroup nextGroup) {
    // TODO Implementation deferred to vendor
    return null;
}
#end_block

#method_before
@Override
public List<String> getNextMappings(NextGroup nextGroup) {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public List<String> getNextMappings(NextGroup nextGroup) {
    // TODO Implementation deferred to vendor
    return null;
}
#end_block

#method_before
@Override
public List<String> getNextMappings(NextGroup nextGroup) {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public List<String> getNextMappings(NextGroup nextGroup) {
    // Default single table pipeline does not use nextObjectives or groups
    return null;
}
#end_block

#method_before
@Override
public List<String> getNextMappings() {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public List<String> getNextMappings() {
    return null;
}
#end_block

#method_before
@Override
public Map<Integer, NextGroup> getAllGroups() {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public Map<Integer, NextGroup> getAllGroups() {
    return null;
}
#end_block

#method_before
@Override
public List<String> getNextMappings(NextGroup nextGroup) {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public List<String> getNextMappings(NextGroup nextGroup) {
    // TODO Implementation deferred to vendor
    return null;
}
#end_block

#method_before
@Override
protected void execute() {
    ApplicationService service = get(ApplicationService.class);
    List<Application> apps = newArrayList(service.getApplications());
    Collections.sort(apps, Comparators.APP_COMPARATOR);
    if (outputJson()) {
        print("%s", json(service, apps));
    } else {
        for (Application app : apps) {
            boolean isActive = service.getState(app.id()) == ACTIVE;
            if (activeOnly && isActive || !activeOnly) {
                if (shortOnly) {
                    print(SHORT_FMT, isActive ? "*" : " ", app.id().id(), app.id().name(), app.version(), app.description().replaceAll("[\\r\\n]", " ").replaceAll(" +", " "));
                } else {
                    print(FMT, isActive ? "*" : " ", app.id().id(), app.id().name(), app.version(), app.origin(), app.category(), app.description(), app.features(), app.featuresRepo().map(URI::toString).orElse(""), app.requiredApps(), app.permissions(), app.url());
                }
            }
        }
    }
}
#method_after
@Override
protected void execute() {
    ApplicationService service = get(ApplicationService.class);
    List<Application> apps = newArrayList(service.getApplications());
    Collections.sort(apps, Comparators.APP_COMPARATOR);
    if (outputJson()) {
        print("%s", json(service, apps));
    } else {
        for (Application app : apps) {
            boolean isActive = service.getState(app.id()) == ACTIVE;
            if (activeOnly && isActive || !activeOnly) {
                if (shortOnly) {
                    String shortDescription = app.title().equals(app.id().name()) ? app.description().replaceAll("[\\r\\n]", " ").replaceAll(" +", " ") : app.title();
                    print(SHORT_FMT, isActive ? "*" : " ", app.id().id(), app.id().name(), app.version(), shortDescription);
                } else {
                    print(FMT, isActive ? "*" : " ", app.id().id(), app.id().name(), app.version(), app.origin(), app.category(), app.description(), app.features(), app.featuresRepo().map(URI::toString).orElse(""), app.requiredApps(), app.permissions(), app.url());
                }
            }
        }
    }
}
#end_block

#method_before
@Test
public void getParseBuilderInterfaceMethodConstructorTest() {
    ImportInfo forSetter = new ImportInfo();
    attrType.setDataTypeName("binary");
    attrType.getDataTypeName();
    attrType.setDataType(YangDataTypes.BINARY);
    attrType.getDataType();
    testAttr.setAttributeName("attributeTest");
    testAttr.setAttributeType(attrType);
    forSetter.setPkgInfo("test1/test3");
    forSetter.setClassInfo("This class contains");
    testAttr.setImportInfo(forSetter);
    String parseBuilderInterface = MethodsGenerator.parseBuilderInterfaceMethodString(testAttr, "newTestName");
    assertThat(parseBuilderInterface.contains("attributeTest") && parseBuilderInterface.contains("newTestName"), is(true));
    String parseBuilderInterfaceBuild = MethodsGenerator.parseBuilderInterfaceBuildMethodString("testname7");
    assertThat(parseBuilderInterfaceBuild.contains("Builds object of") && parseBuilderInterfaceBuild.contains("testname7"), is(true));
    String stringTypeDef = MethodsGenerator.getTypeDefConstructor(testAttr, "Testname");
    assertThat(stringTypeDef.contains("test1/test3.") && stringTypeDef.contains("Testname") && stringTypeDef.contains(UtilConstants.THIS), is(true));
}
#method_after
@Test
public void getParseBuilderInterfaceMethodConstructorTest() {
    ImportInfo forSetter = new ImportInfo();
    attrType.setDataTypeName("binary");
    attrType.getDataTypeName();
    attrType.setDataType(YangDataTypes.BINARY);
    attrType.getDataType();
    testAttr.setAttributeName("attributeTest");
    testAttr.setAttributeType(attrType);
    forSetter.setPkgInfo("test1/test3");
    forSetter.setClassInfo("This class contains");
    testAttr.setImportInfo(forSetter);
    String parseBuilderInterface = MethodsGenerator.parseBuilderInterfaceMethodString(testAttr, "newTestName");
    assertThat(parseBuilderInterface.contains("attributeTest") && parseBuilderInterface.contains("newTestName"), is(true));
    String parseBuilderInterfaceBuild = MethodsGenerator.parseBuilderInterfaceBuildMethodString("testname7");
    assertThat(parseBuilderInterfaceBuild.contains("Builds object of") && parseBuilderInterfaceBuild.contains("testname7"), is(true));
    String stringTypeDef = MethodsGenerator.getTypeDefConstructor(testAttr, "Testname");
}
#end_block

#method_before
@Override
public void generateJavaCodeEntry(String codeGenDir) throws IOException {
    YangNode parent = getParent();
    String typeDefPkg = JavaIdentifierSyntax.getPackageFromParent(parent.getPackage(), parent.getName());
    setPackage(typeDefPkg);
    CachedFileHandle handle = null;
    try {
        FileSystemUtil.createPackage(codeGenDir + getPackage(), getName());
        handle = FileSystemUtil.createSourceFiles(getPackage(), getName(), GeneratedFileType.GENERATE_TYPEDEF_CLASS);
        handle.setRelativeFilePath(getPackage().replace(".", "/"));
        handle.setCodeGenFilePath(codeGenDir);
    } catch (IOException e) {
        throw new IOException("Failed to create the source files.");
    }
    setFileHandle(handle);
    addAttributeInfo();
    addAttributeInParent();
}
#method_after
@Override
public void generateJavaCodeEntry(String codeGenDir) throws IOException {
    YangNode parent = getParent();
    String typeDefPkg = JavaIdentifierSyntax.getPackageFromParent(parent.getPackage(), parent.getName());
    typeDefPkg = JavaIdentifierSyntax.getCamelCase(typeDefPkg).toLowerCase();
    setPackage(typeDefPkg);
    CachedFileHandle handle = null;
    try {
        FileSystemUtil.createPackage(codeGenDir + getPackage(), parent.getName() + UtilConstants.CHILDREN);
        handle = FileSystemUtil.createSourceFiles(getPackage(), getName(), GeneratedFileType.GENERATE_TYPEDEF_CLASS);
        handle.setRelativeFilePath(getPackage().replace(".", "/"));
        handle.setCodeGenFilePath(codeGenDir);
    } catch (IOException e) {
        throw new IOException("Failed to create the source files.");
    }
    setFileHandle(handle);
    addAttributeInfo();
    addAttributeInParent();
}
#end_block

#method_before
@Override
public void generateJavaCodeEntry(String codeGenDir) throws IOException {
    String modPkg = JavaIdentifierSyntax.getRootPackage(getVersion(), getNameSpace().getUri(), getRevision().getRevDate());
    CachedFileHandle handle = null;
    try {
        FileSystemUtil.createPackage(codeGenDir + modPkg, getName());
        handle = FileSystemUtil.createSourceFiles(modPkg, getName(), GeneratedFileType.GENERATE_INTERFACE_WITH_BUILDER);
        handle.setCodeGenFilePath(codeGenDir);
    } catch (IOException e) {
        throw new IOException("Failed to create the source files.");
    }
    setFileHandle(handle);
    addLeavesAttributes();
    addLeafListAttributes();
}
#method_after
@Override
public void generateJavaCodeEntry(String codeGenDir) throws IOException {
    String modPkg = JavaIdentifierSyntax.getRootPackage(getVersion(), getNameSpace().getUri(), getRevision().getRevDate());
    modPkg = JavaIdentifierSyntax.getCamelCase(modPkg);
    CachedFileHandle handle = null;
    try {
        FileSystemUtil.createPackage(codeGenDir + modPkg, getName());
        handle = FileSystemUtil.createSourceFiles(modPkg, getName(), GeneratedFileType.GENERATE_INTERFACE_WITH_BUILDER);
        handle.setCodeGenFilePath(codeGenDir);
    } catch (IOException e) {
        throw new IOException("Failed to create the source files.");
    }
    setFileHandle(handle);
    addLeavesAttributes();
    addLeafListAttributes();
}
#end_block

#method_before
@Override
public void generateJavaCodeEntry(String codeGenDir) throws IOException {
    YangNode parent = getParent();
    String contPkg = JavaIdentifierSyntax.getPackageFromParent(parent.getPackage(), parent.getName());
    setPackage(contPkg);
    CachedFileHandle handle = null;
    try {
        FileSystemUtil.createPackage(codeGenDir + getPackage(), getName());
        handle = FileSystemUtil.createSourceFiles(getPackage(), getName(), GeneratedFileType.GENERATE_INTERFACE_WITH_BUILDER);
        handle.setRelativeFilePath(getPackage().replace(".", "/"));
        handle.setCodeGenFilePath(codeGenDir);
    } catch (IOException e) {
        throw new IOException("Failed to create the source files.");
    }
    setFileHandle(handle);
    addLeavesAttributes();
    addLeafListAttributes();
    addAttributeInParent();
}
#method_after
@Override
public void generateJavaCodeEntry(String codeGenDir) throws IOException {
    YangNode parent = getParent();
    String contPkg = JavaIdentifierSyntax.getPackageFromParent(parent.getPackage(), parent.getName());
    contPkg = JavaIdentifierSyntax.getCamelCase(contPkg).toLowerCase();
    setPackage(contPkg);
    CachedFileHandle handle = null;
    try {
        FileSystemUtil.createPackage(codeGenDir + getPackage(), parent.getName() + UtilConstants.CHILDREN);
        handle = FileSystemUtil.createSourceFiles(getPackage(), getName(), GeneratedFileType.GENERATE_INTERFACE_WITH_BUILDER);
        handle.setRelativeFilePath(getPackage().replace(".", "/"));
        handle.setCodeGenFilePath(codeGenDir);
    } catch (IOException e) {
        throw new IOException("Failed to create the source files.");
    }
    setFileHandle(handle);
    addLeavesAttributes();
    addLeafListAttributes();
    addAttributeInParent();
}
#end_block

#method_before
@Override
public void addAttributeInfo(YangType<?> attrType, String name, boolean isListAttr) {
    /* YANG name is mapped to java name */
    name = JavaIdentifierSyntax.getCamelCase(name);
    ImportInfo importInfo = new ImportInfo();
    boolean isImport = false;
    AttributeInfo newAttr = new AttributeInfo();
    if (attrType != null) {
        newAttr.setAttributeType(attrType);
        String importStr = AttributesJavaDataType.getJavaImportClass(attrType, isListAttr);
        if (importStr != null) {
            importInfo.setClassInfo(importStr);
            importStr = AttributesJavaDataType.getJavaImportPackage(attrType, isListAttr);
            importInfo.setPkgInfo(importStr);
            isImport = true;
        } else {
            importStr = AttributesJavaDataType.getJavaDataType(attrType);
            if (importStr == null) {
                throw new RuntimeException("not supported data type");
            // TODO: need to change to translator exception.
            }
            importInfo.setClassInfo(importStr);
        }
    } else {
        importInfo.setClassInfo(JavaIdentifierSyntax.getCaptialCase(name));
        importInfo.setPkgInfo(getRelativeFilePath().replace('/', '.') + "." + getYangName());
        isImport = true;
    }
    newAttr.setQualifiedName(false);
    if (isImport) {
        boolean isNewImport = addImportInfo(importInfo);
        if (!isNewImport) {
            newAttr.setQualifiedName(true);
        }
    }
    if (isListAttr) {
        ImportInfo listImportInfo = new ImportInfo();
        listImportInfo.setPkgInfo(UtilConstants.COLLECTION_IMPORTS);
        listImportInfo.setClassInfo(UtilConstants.LIST);
        boolean isNewImport = addImportInfo(listImportInfo);
        if (!isNewImport) {
            newAttr.setQualifiedName(true);
        }
    }
    newAttr.setAttributeName(name);
    newAttr.setListAttr(isListAttr);
    newAttr.setImportInfo(importInfo);
    if (getCachedAttributeList().size() == MAX_CACHABLE_ATTR) {
        flushCacheAttrToTempFile();
    }
    getCachedAttributeList().add(newAttr);
}
#method_after
@Override
public void addAttributeInfo(YangType<?> attrType, String name, boolean isListAttr) {
    /* YANG name is mapped to java name */
    name = JavaIdentifierSyntax.getCamelCase(name);
    ImportInfo importInfo = new ImportInfo();
    boolean isImport = false;
    AttributeInfo newAttr = new AttributeInfo();
    if (attrType != null) {
        newAttr.setAttributeType(attrType);
        String importStr = AttributesJavaDataType.getJavaImportClass(attrType, isListAttr);
        if (importStr != null) {
            importInfo.setClassInfo(importStr);
            importStr = AttributesJavaDataType.getJavaImportPackage(attrType, isListAttr);
            importInfo.setPkgInfo(importStr);
            isImport = true;
        } else {
            importStr = AttributesJavaDataType.getJavaDataType(attrType);
            if (importStr == null) {
                throw new RuntimeException("not supported data type");
            // TODO: need to change to translator exception.
            }
            importInfo.setClassInfo(importStr);
        }
    } else {
        importInfo.setClassInfo(JavaIdentifierSyntax.getCaptialCase(name));
        importInfo.setPkgInfo(getRelativeFilePath().replace('/', '.') + "." + getYangName().toLowerCase());
        isImport = true;
    }
    newAttr.setQualifiedName(false);
    if (isImport) {
        addImportInfo(importInfo);
    }
    if (isListAttr) {
        ImportInfo listImportInfo = new ImportInfo();
        listImportInfo.setPkgInfo(UtilConstants.COLLECTION_IMPORTS);
        listImportInfo.setClassInfo(UtilConstants.LIST);
        addImportInfo(listImportInfo);
    }
    /**
     * If two classes with different packages have same class info for import than use qualified name.
     */
    for (ImportInfo imports : getImportSet()) {
        if (imports.getClassInfo().equals(importInfo.getClassInfo()) && !imports.getPkgInfo().equals(importInfo.getPkgInfo())) {
            newAttr.setQualifiedName(true);
        }
    }
    newAttr.setAttributeName(name);
    newAttr.setListAttr(isListAttr);
    newAttr.setImportInfo(importInfo);
    if (getCachedAttributeList().size() == MAX_CACHABLE_ATTR) {
        flushCacheAttrToTempFile();
    }
    getCachedAttributeList().add(newAttr);
}
#end_block

#method_before
public static void parseAttributeInfo(AttributeInfo attr, int genFileType, String className, String path, CachedFileHandle handle) {
    String attrString = "";
    String getterString = "";
    String getterImplString = "";
    String setterString = "";
    String setterImplString = "";
    String constructorString = "";
    String typeDefString = "";
    String toString = "";
    String hashCodeString = "";
    String equalsString = "";
    className = JavaIdentifierSyntax.getCaptialCase(className);
    try {
        /*
             * Get the attribute definition and save attributes to temporary
             * file.
             */
        String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
        attrString = JavaCodeSnippetGen.getJavaAttributeDefination(attr.getImportInfo().getPkgInfo(), attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr());
        handle.setTempData(attrString + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION, TempDataStoreTypes.ATTRIBUTE, className, path);
        if ((genFileType & INTERFACE_MASK) != 0) {
            getterString = MethodsGenerator.getGetterString(attr);
            handle.setTempData(getterString + UtilConstants.NEW_LINE, TempDataStoreTypes.GETTER_METHODS, className, path);
        }
        if ((genFileType & BUILDER_INTERFACE_MASK) != 0) {
            setterString = MethodsGenerator.getSetterString(attr, className);
            handle.setTempData(setterString + UtilConstants.NEW_LINE, TempDataStoreTypes.SETTER_METHODS, className, path);
        }
        if ((genFileType & BUILDER_CLASS_MASK) != 0) {
            getterImplString = MethodsGenerator.getGetterForClass(attr);
            handle.setTempData(MethodsGenerator.getOverRideString() + getterImplString + UtilConstants.NEW_LINE, TempDataStoreTypes.GETTER_METHODS_IMPL, className, path);
            setterImplString = MethodsGenerator.getSetterForClass(attr, className);
            handle.setTempData(MethodsGenerator.getOverRideString() + setterImplString + UtilConstants.NEW_LINE, TempDataStoreTypes.SETTER_METHODS_IMPL, className, path);
        }
        if ((genFileType & IMPL_CLASS_MASK) != 0) {
            constructorString = MethodsGenerator.getConstructor(className, attr);
            handle.setTempData(constructorString, TempDataStoreTypes.CONSTRUCTOR, className, path);
            hashCodeString = MethodsGenerator.getHashCodeMethod(attr);
            handle.setTempData(hashCodeString + UtilConstants.NEW_LINE, TempDataStoreTypes.HASH_CODE, className, path);
            equalsString = MethodsGenerator.getEqualsMethod(attr);
            handle.setTempData(equalsString + UtilConstants.NEW_LINE, TempDataStoreTypes.EQUALS, className, path);
            toString = MethodsGenerator.getToStringMethod(attr);
            handle.setTempData(toString + UtilConstants.NEW_LINE, TempDataStoreTypes.TO_STRING, className, path);
        }
        if ((genFileType & GENERATE_TYPEDEF_CLASS) != 0) {
            typeDefString = JavaCodeSnippetGen.getJavaAttributeDefination(attr.getImportInfo().getPkgInfo(), attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr()) + UtilConstants.NEW_LINE;
            typeDefString = typeDefString + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_FIRST_LINE;
            typeDefString = typeDefString + MethodsGenerator.getDefaultConstructorString(className, UtilConstants.PRIVATE) + UtilConstants.NEW_LINE;
            typeDefString = typeDefString + JavaDocGen.getJavaDoc(JavaDocType.TYPE_DEF_CONSTRUCTOR, className) + MethodsGenerator.getTypeDefConstructor(attr, className) + UtilConstants.NEW_LINE;
            typeDefString = typeDefString + JavaDocGen.getJavaDoc(JavaDocType.OF, className) + MethodsGenerator.getOfMethod(className, attr) + UtilConstants.NEW_LINE;
            typeDefString = typeDefString + JavaDocGen.getJavaDoc(JavaDocType.GETTER, className) + MethodsGenerator.getGetterForClass(attr) + UtilConstants.NEW_LINE;
            typeDefString = typeDefString + JavaDocGen.getJavaDoc(JavaDocType.TYPE_DEF_SETTER, className) + MethodsGenerator.getSetterForTypeDefClass(attr) + UtilConstants.NEW_LINE;
            hashCodeString = hashCodeString + MethodsGenerator.getHashCodeMethodOpen() + MethodsGenerator.getHashCodeMethod(attr).replace(UtilConstants.NEW_LINE, "");
            hashCodeString = MethodsGenerator.getHashCodeMethodClose(hashCodeString) + UtilConstants.NEW_LINE;
            equalsString = equalsString + MethodsGenerator.getEqualsMethodOpen(className) + UtilConstants.NEW_LINE + MethodsGenerator.getEqualsMethod(attr);
            equalsString = MethodsGenerator.getEqualsMethodClose(equalsString) + UtilConstants.NEW_LINE;
            toString = toString + MethodsGenerator.getToStringMethodOpen() + MethodsGenerator.getToStringMethod(attr) + UtilConstants.NEW_LINE + MethodsGenerator.getToStringMethodClose() + UtilConstants.NEW_LINE;
            typeDefString = typeDefString + hashCodeString + equalsString + toString;
            handle.setTempData(typeDefString, TempDataStoreTypes.TYPE_DEF, className, path);
        }
    } catch (IOException e) {
        log.info("Failed to set data for " + attr.getAttributeName() + " in temp data files.");
    }
}
#method_after
public static void parseAttributeInfo(AttributeInfo attr, int genFileType, String className, String path, CachedFileHandle handle) {
    String attrString = "";
    String getterString = "";
    String getterImplString = "";
    String setterString = "";
    String setterImplString = "";
    String constructorString = "";
    String typeDefString = "";
    String toString = "";
    String hashCodeString = "";
    String equalsString = "";
    className = JavaIdentifierSyntax.getCaptialCase(className);
    try {
        /*
             * Get the attribute definition and save attributes to temporary
             * file.
             */
        boolean isList = attr.isListAttr();
        String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
        if (attr.isQualifiedName()) {
            attrString = JavaCodeSnippetGen.getJavaAttributeDefination(attr.getImportInfo().getPkgInfo(), attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr());
        } else {
            attrString = JavaCodeSnippetGen.getJavaAttributeDefination(null, attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr());
        }
        handle.setTempData(attrString + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION, TempDataStoreTypes.ATTRIBUTE, className, path);
        if ((genFileType & INTERFACE_MASK) != 0) {
            getterString = MethodsGenerator.getGetterString(attr);
            handle.setTempData(getterString + UtilConstants.NEW_LINE, TempDataStoreTypes.GETTER_METHODS, className, path);
        }
        if ((genFileType & BUILDER_INTERFACE_MASK) != 0) {
            setterString = MethodsGenerator.getSetterString(attr, className);
            handle.setTempData(setterString + UtilConstants.NEW_LINE, TempDataStoreTypes.SETTER_METHODS, className, path);
        }
        if ((genFileType & BUILDER_CLASS_MASK) != 0) {
            getterImplString = MethodsGenerator.getGetterForClass(attr);
            handle.setTempData(MethodsGenerator.getOverRideString() + getterImplString + UtilConstants.NEW_LINE, TempDataStoreTypes.GETTER_METHODS_IMPL, className, path);
            setterImplString = MethodsGenerator.getSetterForClass(attr, className);
            handle.setTempData(MethodsGenerator.getOverRideString() + setterImplString + UtilConstants.NEW_LINE, TempDataStoreTypes.SETTER_METHODS_IMPL, className, path);
        }
        if ((genFileType & IMPL_CLASS_MASK) != 0) {
            constructorString = MethodsGenerator.getConstructor(className, attr);
            handle.setTempData(constructorString, TempDataStoreTypes.CONSTRUCTOR, className, path);
            hashCodeString = MethodsGenerator.getHashCodeMethod(attr);
            handle.setTempData(hashCodeString + UtilConstants.NEW_LINE, TempDataStoreTypes.HASH_CODE, className, path);
            equalsString = MethodsGenerator.getEqualsMethod(attr);
            handle.setTempData(equalsString + UtilConstants.NEW_LINE, TempDataStoreTypes.EQUALS, className, path);
            toString = MethodsGenerator.getToStringMethod(attr);
            handle.setTempData(toString + UtilConstants.NEW_LINE, TempDataStoreTypes.TO_STRING, className, path);
        }
        if ((genFileType & GENERATE_TYPEDEF_CLASS) != 0) {
            if (attr.isQualifiedName()) {
                typeDefString = JavaCodeSnippetGen.getJavaAttributeDefination(attr.getImportInfo().getPkgInfo(), attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr()) + UtilConstants.NEW_LINE;
            } else {
                typeDefString = JavaCodeSnippetGen.getJavaAttributeDefination(null, attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr()) + UtilConstants.NEW_LINE;
            }
            typeDefString = typeDefString + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_FIRST_LINE;
            typeDefString = typeDefString + MethodsGenerator.getDefaultConstructorString(className, UtilConstants.PRIVATE) + UtilConstants.NEW_LINE;
            typeDefString = typeDefString + JavaDocGen.getJavaDoc(JavaDocType.TYPE_DEF_CONSTRUCTOR, className, isList) + MethodsGenerator.getTypeDefConstructor(attr, className) + UtilConstants.NEW_LINE;
            typeDefString = typeDefString + JavaDocGen.getJavaDoc(JavaDocType.OF, className, isList) + MethodsGenerator.getOfMethod(className, attr) + UtilConstants.NEW_LINE;
            typeDefString = typeDefString + JavaDocGen.getJavaDoc(JavaDocType.GETTER, className, isList) + MethodsGenerator.getGetterForClass(attr) + UtilConstants.NEW_LINE;
            typeDefString = typeDefString + JavaDocGen.getJavaDoc(JavaDocType.TYPE_DEF_SETTER, className, isList) + MethodsGenerator.getSetterForTypeDefClass(attr) + UtilConstants.NEW_LINE;
            hashCodeString = hashCodeString + MethodsGenerator.getHashCodeMethodOpen() + MethodsGenerator.getHashCodeMethod(attr).replace(UtilConstants.NEW_LINE, "");
            hashCodeString = MethodsGenerator.getHashCodeMethodClose(hashCodeString) + UtilConstants.NEW_LINE;
            equalsString = equalsString + MethodsGenerator.getEqualsMethodOpen(className) + UtilConstants.NEW_LINE + MethodsGenerator.getEqualsMethod(attr);
            equalsString = MethodsGenerator.getEqualsMethodClose(equalsString) + UtilConstants.NEW_LINE;
            toString = toString + MethodsGenerator.getToStringMethodOpen() + MethodsGenerator.getToStringMethod(attr) + UtilConstants.NEW_LINE + MethodsGenerator.getToStringMethodClose() + UtilConstants.NEW_LINE;
            typeDefString = typeDefString + hashCodeString + equalsString + toString;
            handle.setTempData(typeDefString, TempDataStoreTypes.TYPE_DEF, className, path);
        }
    } catch (IOException e) {
        log.info("Failed to set data for " + attr.getAttributeName() + " in temp data files.");
    }
}
#end_block

#method_before
private static void write(File file, String fileName, int genType, JavaDocGen.JavaDocType javaDocType) throws IOException {
    insert(file, JavaDocGen.getJavaDoc(javaDocType, fileName));
    insert(file, JavaCodeSnippetGen.getJavaClassDefStart(genType, fileName));
}
#method_after
private static void write(File file, String fileName, int genType, JavaDocGen.JavaDocType javaDocType) throws IOException {
    insert(file, JavaDocGen.getJavaDoc(javaDocType, fileName, false));
    insert(file, JavaCodeSnippetGen.getJavaClassDefStart(genType, fileName));
}
#end_block

#method_before
public static void addPackageInfo(File path, String classInfo, String pack) throws IOException {
    if (pack.contains(UtilConstants.YANG_GEN_DIR)) {
        String[] strArray = pack.split(UtilConstants.YANG_GEN_DIR);
        pack = strArray[1];
    }
    try {
        File packageInfo = new File(path + File.separator + "package-info.java");
        packageInfo.createNewFile();
        FileWriter fileWriter = null;
        BufferedWriter bufferedWriter = null;
        fileWriter = new FileWriter(packageInfo);
        bufferedWriter = new BufferedWriter(fileWriter);
        bufferedWriter.write(CopyrightHeader.getCopyrightHeader());
        bufferedWriter.write(JavaDocGen.getJavaDoc(JavaDocGen.JavaDocType.PACKAGE_INFO, classInfo));
        bufferedWriter.write(UtilConstants.PACKAGE + UtilConstants.SPACE + pack + UtilConstants.SEMI_COLAN);
        bufferedWriter.close();
    } catch (IOException e) {
        throw new IOException("Exception occured while creating package info file.");
    }
}
#method_after
public static void addPackageInfo(File path, String classInfo, String pack) throws IOException {
    if (pack.contains(UtilConstants.YANG_GEN_DIR)) {
        String[] strArray = pack.split(UtilConstants.YANG_GEN_DIR);
        pack = strArray[1];
    }
    try {
        File packageInfo = new File(path + File.separator + "package-info.java");
        packageInfo.createNewFile();
        FileWriter fileWriter = null;
        BufferedWriter bufferedWriter = null;
        fileWriter = new FileWriter(packageInfo);
        bufferedWriter = new BufferedWriter(fileWriter);
        bufferedWriter.write(CopyrightHeader.getCopyrightHeader());
        bufferedWriter.write(JavaDocGen.getJavaDoc(JavaDocGen.JavaDocType.PACKAGE_INFO, classInfo, false));
        bufferedWriter.write(UtilConstants.PACKAGE + UtilConstants.SPACE + pack + UtilConstants.SEMI_COLAN);
        bufferedWriter.close();
    } catch (IOException e) {
        throw new IOException("Exception occured while creating package info file.");
    }
}
#end_block

#method_before
public static String parseBuilderInterfaceBuildMethodString(String name) {
    return JavaDocGen.getJavaDoc(JavaDocGen.JavaDocType.BUILD, name) + getBuildForInterface(name);
}
#method_after
public static String parseBuilderInterfaceBuildMethodString(String name) {
    return JavaDocGen.getJavaDoc(JavaDocGen.JavaDocType.BUILD, name, false) + getBuildForInterface(name);
}
#end_block

#method_before
public static String getGetterString(AttributeInfo attr) {
    String returnType = "";
    if (attr.getImportInfo().getPkgInfo() != null) {
        returnType = attr.getImportInfo().getPkgInfo() + ".";
    }
    returnType = returnType + attr.getImportInfo().getClassInfo();
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    return JavaDocGen.getJavaDoc(JavaDocGen.JavaDocType.GETTER, attributeName) + getGetterForInterface(attributeName, returnType, attr.isListAttr()) + UtilConstants.NEW_LINE;
}
#method_after
public static String getGetterString(AttributeInfo attr) {
    String returnType = "";
    boolean isList = attr.isListAttr();
    if (attr.isQualifiedName() && (attr.getImportInfo().getPkgInfo() != null)) {
        returnType = attr.getImportInfo().getPkgInfo() + ".";
    }
    returnType = returnType + attr.getImportInfo().getClassInfo();
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    return JavaDocGen.getJavaDoc(JavaDocGen.JavaDocType.GETTER, attributeName, isList) + getGetterForInterface(attributeName, returnType, attr.isListAttr()) + UtilConstants.NEW_LINE;
}
#end_block

#method_before
public static String getSetterString(AttributeInfo attr, String className) {
    String attrType = "";
    if (attr.getImportInfo().getPkgInfo() != null) {
        attrType = attr.getImportInfo().getPkgInfo() + ".";
    }
    attrType = attrType + attr.getImportInfo().getClassInfo();
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    return JavaDocGen.getJavaDoc(JavaDocGen.JavaDocType.SETTER, attributeName) + getSetterForInterface(attributeName, attrType, className, attr.isListAttr()) + UtilConstants.NEW_LINE;
}
#method_after
public static String getSetterString(AttributeInfo attr, String className) {
    String attrType = "";
    boolean isList = attr.isListAttr();
    if (attr.isQualifiedName() && (attr.getImportInfo().getPkgInfo() != null)) {
        attrType = attr.getImportInfo().getPkgInfo() + ".";
    }
    attrType = attrType + attr.getImportInfo().getClassInfo();
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    return JavaDocGen.getJavaDoc(JavaDocGen.JavaDocType.SETTER, attributeName, isList) + getSetterForInterface(attributeName, attrType, className, attr.isListAttr()) + UtilConstants.NEW_LINE;
}
#end_block

#method_before
public static String getConstructorString(String name) {
    return JavaDocGen.getJavaDoc(JavaDocGen.JavaDocType.CONSTRUCTOR, name);
}
#method_after
public static String getConstructorString(String name) {
    return JavaDocGen.getJavaDoc(JavaDocGen.JavaDocType.CONSTRUCTOR, name, false);
}
#end_block

#method_before
public static String getDefaultConstructorString(String name, String modifierType) {
    return JavaDocGen.getJavaDoc(JavaDocGen.JavaDocType.DEFAULT_CONSTRUCTOR, name) + getDefaultConstructor(name, modifierType);
}
#method_after
public static String getDefaultConstructorString(String name, String modifierType) {
    return JavaDocGen.getJavaDoc(JavaDocGen.JavaDocType.DEFAULT_CONSTRUCTOR, name, false) + getDefaultConstructor(name, modifierType);
}
#end_block

#method_before
public static String getTypeDefConstructor(AttributeInfo attr, String className) {
    String attrQuaifiedType = "";
    if (attr.getImportInfo().getPkgInfo() != null) {
        attrQuaifiedType = attr.getImportInfo().getPkgInfo() + ".";
    }
    attrQuaifiedType = attrQuaifiedType + attr.getImportInfo().getClassInfo();
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    if (!attr.isListAttr()) {
        return getTypeDefConstructorString(attrQuaifiedType, attributeName, className);
    }
    String listAttr = getListString() + attrQuaifiedType + UtilConstants.DIAMOND_CLOSE_BRACKET;
    return getTypeDefConstructorString(listAttr, attributeName, className);
}
#method_after
public static String getTypeDefConstructor(AttributeInfo attr, String className) {
    String attrQuaifiedType = "";
    if (attr.isQualifiedName() && (attr.getImportInfo().getPkgInfo() != null)) {
        attrQuaifiedType = attr.getImportInfo().getPkgInfo() + ".";
    }
    attrQuaifiedType = attrQuaifiedType + attr.getImportInfo().getClassInfo();
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    if (!attr.isListAttr()) {
        return getTypeDefConstructorString(attrQuaifiedType, attributeName, className);
    }
    String listAttr = getListString() + attrQuaifiedType + UtilConstants.DIAMOND_CLOSE_BRACKET;
    return getTypeDefConstructorString(listAttr, attributeName, className);
}
#end_block

#method_before
public static String getGetterForClass(AttributeInfo attr) {
    String attrQuaifiedType = "";
    if (attr.getImportInfo().getPkgInfo() != null) {
        attrQuaifiedType = attr.getImportInfo().getPkgInfo() + ".";
    }
    attrQuaifiedType = attrQuaifiedType + attr.getImportInfo().getClassInfo();
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    if (!attr.isListAttr()) {
        return getGetter(attrQuaifiedType, attributeName);
    }
    String listAttr = getListString() + attrQuaifiedType + UtilConstants.DIAMOND_CLOSE_BRACKET;
    return getGetter(listAttr, attributeName);
}
#method_after
public static String getGetterForClass(AttributeInfo attr) {
    String attrQuaifiedType = "";
    if (attr.isQualifiedName() && (attr.getImportInfo().getPkgInfo() != null)) {
        attrQuaifiedType = attr.getImportInfo().getPkgInfo() + ".";
    }
    attrQuaifiedType = attrQuaifiedType + attr.getImportInfo().getClassInfo();
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    if (!attr.isListAttr()) {
        return getGetter(attrQuaifiedType, attributeName);
    }
    String listAttr = getListString() + attrQuaifiedType + UtilConstants.DIAMOND_CLOSE_BRACKET;
    return getGetter(listAttr, attributeName);
}
#end_block

#method_before
public static String getSetterForClass(AttributeInfo attr, String className) {
    String attrQuaifiedType = "";
    if (attr.getImportInfo().getPkgInfo() != null) {
        attrQuaifiedType = attr.getImportInfo().getPkgInfo() + ".";
    }
    attrQuaifiedType = attrQuaifiedType + attr.getImportInfo().getClassInfo();
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    if (!attr.isListAttr()) {
        return getSetter(className, attributeName, attrQuaifiedType);
    }
    String listAttr = getListString() + attrQuaifiedType + UtilConstants.DIAMOND_CLOSE_BRACKET;
    return getSetter(className, attributeName, listAttr);
}
#method_after
public static String getSetterForClass(AttributeInfo attr, String className) {
    String attrQuaifiedType = "";
    if (attr.isQualifiedName() && (attr.getImportInfo().getPkgInfo() != null)) {
        attrQuaifiedType = attr.getImportInfo().getPkgInfo() + ".";
    }
    attrQuaifiedType = attrQuaifiedType + attr.getImportInfo().getClassInfo();
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    if (!attr.isListAttr()) {
        return getSetter(className, attributeName, attrQuaifiedType);
    }
    String listAttr = getListString() + attrQuaifiedType + UtilConstants.DIAMOND_CLOSE_BRACKET;
    return getSetter(className, attributeName, listAttr);
}
#end_block

#method_before
public static String getSetterForTypeDefClass(AttributeInfo attr) {
    String attrQuaifiedType = "";
    if (attr.getImportInfo().getPkgInfo() != null) {
        attrQuaifiedType = attr.getImportInfo().getPkgInfo() + ".";
    }
    attrQuaifiedType = attrQuaifiedType + attr.getImportInfo().getClassInfo();
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    if (!attr.isListAttr()) {
        return getTypeDefSetter(attrQuaifiedType, attributeName);
    }
    String listAttr = getListString() + attrQuaifiedType + UtilConstants.DIAMOND_CLOSE_BRACKET;
    return getTypeDefSetter(listAttr, attributeName);
}
#method_after
public static String getSetterForTypeDefClass(AttributeInfo attr) {
    String attrQuaifiedType = "";
    if (attr.isQualifiedName() && (attr.getImportInfo().getPkgInfo() != null)) {
        attrQuaifiedType = attr.getImportInfo().getPkgInfo() + ".";
    }
    attrQuaifiedType = attrQuaifiedType + attr.getImportInfo().getClassInfo();
    String attributeName = JavaIdentifierSyntax.getLowerCase(attr.getAttributeName());
    if (!attr.isListAttr()) {
        return getTypeDefSetter(attrQuaifiedType, attributeName);
    }
    String listAttr = getListString() + attrQuaifiedType + UtilConstants.DIAMOND_CLOSE_BRACKET;
    return getTypeDefSetter(listAttr, attributeName);
}
#end_block

#method_before
public static String getOfMethod(String name, AttributeInfo attr) {
    String attrQuaifiedType = "";
    if (attr.getImportInfo().getPkgInfo() != null) {
        attrQuaifiedType = attr.getImportInfo().getPkgInfo() + ".";
    }
    attrQuaifiedType = attrQuaifiedType + attr.getImportInfo().getClassInfo();
    return UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.PUBLIC + UtilConstants.SPACE + UtilConstants.STATIC + UtilConstants.SPACE + name + UtilConstants.SPACE + UtilConstants.OF + UtilConstants.OPEN_PARENTHESIS + attrQuaifiedType + UtilConstants.SPACE + UtilConstants.VALUE + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE + UtilConstants.EIGHT_SPACE_INDENTATION + UtilConstants.RETURN + UtilConstants.SPACE + UtilConstants.NEW + UtilConstants.SPACE + name + UtilConstants.OPEN_PARENTHESIS + UtilConstants.VALUE + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.CLOSE_CURLY_BRACKET + UtilConstants.NEW_LINE;
}
#method_after
public static String getOfMethod(String name, AttributeInfo attr) {
    String attrQuaifiedType = "";
    if (attr.isQualifiedName() && (attr.getImportInfo().getPkgInfo() != null)) {
        attrQuaifiedType = attr.getImportInfo().getPkgInfo() + ".";
    }
    attrQuaifiedType = attrQuaifiedType + attr.getImportInfo().getClassInfo();
    return UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.PUBLIC + UtilConstants.SPACE + UtilConstants.STATIC + UtilConstants.SPACE + name + UtilConstants.SPACE + UtilConstants.OF + UtilConstants.OPEN_PARENTHESIS + attrQuaifiedType + UtilConstants.SPACE + UtilConstants.VALUE + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE + UtilConstants.EIGHT_SPACE_INDENTATION + UtilConstants.RETURN + UtilConstants.SPACE + UtilConstants.NEW + UtilConstants.SPACE + name + UtilConstants.OPEN_PARENTHESIS + UtilConstants.VALUE + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.CLOSE_CURLY_BRACKET + UtilConstants.NEW_LINE;
}
#end_block

#method_before
@Test
public void builderClassGenerationTest() {
    String builderClassJavaDoc = JavaDocGen.getJavaDoc(JavaDocType.BUILDER_CLASS, "testGeneration1");
    assertTrue(builderClassJavaDoc.contains("Provides the builder implementation of") && builderClassJavaDoc.contains(" */\n"));
}
#method_after
@Test
public void builderClassGenerationTest() {
    String builderClassJavaDoc = JavaDocGen.getJavaDoc(JavaDocType.BUILDER_CLASS, "testGeneration1", false);
    assertTrue(builderClassJavaDoc.contains("Provides the builder implementation of") && builderClassJavaDoc.contains(" */\n"));
}
#end_block

#method_before
@Test
public void builderInterfaceGenerationTest() {
    String builderInterfaceJavaDoc = JavaDocGen.getJavaDoc(JavaDocType.BUILDER_INTERFACE, "testGeneration1");
    assertTrue(builderInterfaceJavaDoc.contains("Builder for") && builderInterfaceJavaDoc.contains(" */\n"));
}
#method_after
@Test
public void builderInterfaceGenerationTest() {
    String builderInterfaceJavaDoc = JavaDocGen.getJavaDoc(JavaDocType.BUILDER_INTERFACE, "testGeneration1", false);
    assertTrue(builderInterfaceJavaDoc.contains("Builder for") && builderInterfaceJavaDoc.contains(" */\n"));
}
#end_block

#method_before
@Test
public void buildGenerationTest() {
    String buildDoc = JavaDocGen.getJavaDoc(JavaDocType.BUILD, "testGeneration1");
    assertTrue(buildDoc.contains("Builds object of") && buildDoc.contains(" */\n"));
}
#method_after
@Test
public void buildGenerationTest() {
    String buildDoc = JavaDocGen.getJavaDoc(JavaDocType.BUILD, "testGeneration1", false);
    assertTrue(buildDoc.contains("Builds object of") && buildDoc.contains(" */\n"));
}
#end_block

#method_before
@Test
public void constructorGenerationTest() {
    String constructorDoc = JavaDocGen.getJavaDoc(JavaDocType.CONSTRUCTOR, "testGeneration1");
    assertTrue(constructorDoc.contains("Construct the object of") && constructorDoc.contains("builder object of") && constructorDoc.contains("@param") && constructorDoc.contains("*/\n"));
    JavaDocType.valueOf(JavaDocType.CONSTRUCTOR.toString());
}
#method_after
@Test
public void constructorGenerationTest() {
    String constructorDoc = JavaDocGen.getJavaDoc(JavaDocType.CONSTRUCTOR, "testGeneration1", false);
    assertTrue(constructorDoc.contains("Construct the object of") && constructorDoc.contains("builder object of") && constructorDoc.contains("@param") && constructorDoc.contains("*/\n"));
    JavaDocType.valueOf(JavaDocType.CONSTRUCTOR.toString());
}
#end_block

#method_before
@Test
public void defaultConstructorGenerationTest() {
    String defaultConstructorDoc = JavaDocGen.getJavaDoc(JavaDocType.DEFAULT_CONSTRUCTOR, "testGeneration1");
    assertTrue(defaultConstructorDoc.contains("Default Constructor") && defaultConstructorDoc.contains(" */\n"));
}
#method_after
@Test
public void defaultConstructorGenerationTest() {
    String defaultConstructorDoc = JavaDocGen.getJavaDoc(JavaDocType.DEFAULT_CONSTRUCTOR, "testGeneration1", false);
    assertTrue(defaultConstructorDoc.contains("Default Constructor") && defaultConstructorDoc.contains(" */\n"));
}
#end_block

#method_before
@Test
public void getterGenerationTest() {
    String getterJavaDoc = JavaDocGen.getJavaDoc(JavaDocType.GETTER, "testGeneration1");
    assertTrue(getterJavaDoc.contains("Returns the attribute") && getterJavaDoc.contains(" */\n"));
}
#method_after
@Test
public void getterGenerationTest() {
    String getterJavaDoc = JavaDocGen.getJavaDoc(JavaDocType.GETTER, "testGeneration1", false);
    assertTrue(getterJavaDoc.contains("Returns the attribute") && getterJavaDoc.contains(" */\n"));
}
#end_block

#method_before
@Test
public void implClassGenerationTest() {
    String implClassJavaDoc = JavaDocGen.getJavaDoc(JavaDocType.IMPL_CLASS, "testGeneration1");
    assertTrue(implClassJavaDoc.contains("Provides the implementation of") && implClassJavaDoc.contains(" */\n"));
}
#method_after
@Test
public void implClassGenerationTest() {
    String implClassJavaDoc = JavaDocGen.getJavaDoc(JavaDocType.IMPL_CLASS, "testGeneration1", false);
    assertTrue(implClassJavaDoc.contains("Provides the implementation of") && implClassJavaDoc.contains(" */\n"));
}
#end_block

#method_before
@Test
public void interfaceGenerationTest() {
    String interfaceJavaDoc = JavaDocGen.getJavaDoc(JavaDocType.INTERFACE, "testGeneration1");
    assertTrue(interfaceJavaDoc.contains("Abstraction of an entity which provides functionalities of") && interfaceJavaDoc.contains(" */\n"));
}
#method_after
@Test
public void interfaceGenerationTest() {
    String interfaceJavaDoc = JavaDocGen.getJavaDoc(JavaDocType.INTERFACE, "testGeneration1", false);
    assertTrue(interfaceJavaDoc.contains("Abstraction of an entity which provides functionalities of") && interfaceJavaDoc.contains(" */\n"));
}
#end_block

#method_before
@Test
public void packageInfoGenerationTest() {
    String packageInfo = JavaDocGen.getJavaDoc(JavaDocType.PACKAGE_INFO, "testGeneration1");
    assertTrue(packageInfo.contains("Generated java code corresponding to YANG") && packageInfo.contains(" */\n"));
}
#method_after
@Test
public void packageInfoGenerationTest() {
    String packageInfo = JavaDocGen.getJavaDoc(JavaDocType.PACKAGE_INFO, "testGeneration1", false);
    assertTrue(packageInfo.contains("Generated java code corresponding to YANG") && packageInfo.contains(" */\n"));
}
#end_block

#method_before
@Test
public void setterGenerationTest() {
    String setterJavaDoc = JavaDocGen.getJavaDoc(JavaDocType.SETTER, "testGeneration1");
    assertTrue(setterJavaDoc.contains("Returns the builder object of") && setterJavaDoc.contains(" */\n"));
}
#method_after
@Test
public void setterGenerationTest() {
    String setterJavaDoc = JavaDocGen.getJavaDoc(JavaDocType.SETTER, "testGeneration1", false);
    assertTrue(setterJavaDoc.contains("Returns the builder object of") && setterJavaDoc.contains(" */\n"));
}
#end_block

#method_before
@Test
public void typeDefSetterGenerationTest() {
    String typeDefSetter = JavaDocGen.getJavaDoc(JavaDocType.TYPE_DEF_SETTER, "testGeneration1");
    assertTrue(typeDefSetter.contains("Sets the value of") && typeDefSetter.contains(" */\n"));
}
#method_after
@Test
public void typeDefSetterGenerationTest() {
    String typeDefSetter = JavaDocGen.getJavaDoc(JavaDocType.TYPE_DEF_SETTER, "testGeneration1", false);
    assertTrue(typeDefSetter.contains("Sets the value of") && typeDefSetter.contains(" */\n"));
}
#end_block

#method_before
public static String getJavaDoc(JavaDocType type, String name) {
    name = JavaIdentifierSyntax.getLowerCase(JavaIdentifierSyntax.getCamelCase(name));
    String javaDoc = "";
    if (type.equals(JavaDocType.IMPL_CLASS)) {
        javaDoc = generateForImplClass(name);
    } else if (type.equals(JavaDocType.BUILDER_CLASS)) {
        javaDoc = generateForBuilderClass(name);
    } else if (type.equals(JavaDocType.INTERFACE)) {
        javaDoc = generateForInterface(name);
    } else if (type.equals(JavaDocType.BUILDER_INTERFACE)) {
        javaDoc = generateForBuilderInterface(name);
    } else if (type.equals(JavaDocType.PACKAGE_INFO)) {
        javaDoc = generateForPackage(name);
    } else if (type.equals(JavaDocType.GETTER)) {
        javaDoc = generateForGetters(name);
    } else if (type.equals(JavaDocType.TYPE_DEF_SETTER)) {
        javaDoc = generateForTypeDefSetter(name);
    } else if (type.equals(JavaDocType.TYPE_DEF_CONSTRUCTOR)) {
        javaDoc = generateForTypeDefConstructor(name);
    } else if (type.equals(JavaDocType.SETTER)) {
        javaDoc = generateForSetters(name);
    } else if (type.equals(JavaDocType.OF)) {
        javaDoc = generateForOf(name);
    } else if (type.equals(JavaDocType.DEFAULT_CONSTRUCTOR)) {
        javaDoc = generateForDefaultConstructors();
    } else if (type.equals(JavaDocType.BUILD)) {
        javaDoc = generateForBuild(name);
    } else {
        javaDoc = generateForConstructors(name);
    }
    return javaDoc;
}
#method_after
public static String getJavaDoc(JavaDocType type, String name, boolean isList) {
    name = JavaIdentifierSyntax.getLowerCase(JavaIdentifierSyntax.getCamelCase(name));
    String javaDoc = "";
    if (type.equals(JavaDocType.IMPL_CLASS)) {
        javaDoc = generateForImplClass(name);
    } else if (type.equals(JavaDocType.BUILDER_CLASS)) {
        javaDoc = generateForBuilderClass(name);
    } else if (type.equals(JavaDocType.INTERFACE)) {
        javaDoc = generateForInterface(name);
    } else if (type.equals(JavaDocType.BUILDER_INTERFACE)) {
        javaDoc = generateForBuilderInterface(name);
    } else if (type.equals(JavaDocType.PACKAGE_INFO)) {
        javaDoc = generateForPackage(name);
    } else if (type.equals(JavaDocType.GETTER)) {
        javaDoc = generateForGetters(name, isList);
    } else if (type.equals(JavaDocType.TYPE_DEF_SETTER)) {
        javaDoc = generateForTypeDefSetter(name);
    } else if (type.equals(JavaDocType.TYPE_DEF_CONSTRUCTOR)) {
        javaDoc = generateForTypeDefConstructor(name);
    } else if (type.equals(JavaDocType.SETTER)) {
        javaDoc = generateForSetters(name, isList);
    } else if (type.equals(JavaDocType.OF)) {
        javaDoc = generateForOf(name);
    } else if (type.equals(JavaDocType.DEFAULT_CONSTRUCTOR)) {
        javaDoc = generateForDefaultConstructors();
    } else if (type.equals(JavaDocType.BUILD)) {
        javaDoc = generateForBuild(name);
    } else {
        javaDoc = generateForConstructors(name);
    }
    return javaDoc;
}
#end_block

#method_before
private static String generateForGetters(String attribute) {
    return UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_FIRST_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_GETTERS + attribute + UtilConstants.PERIOD + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.NEW_LINE_ESTRIC + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_RETURN + attribute + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_END_LINE;
}
#method_after
private static String generateForGetters(String attribute, boolean isList) {
    String getter = UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_FIRST_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_GETTERS + attribute + UtilConstants.PERIOD + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.NEW_LINE_ESTRIC + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_RETURN;
    if (isList) {
        attribute = UtilConstants.LIST.toLowerCase() + UtilConstants.SPACE + UtilConstants.OF + UtilConstants.SPACE + attribute;
    }
    getter = getter + attribute + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_END_LINE;
    return getter;
}
#end_block

#method_before
private static String generateForSetters(String attribute) {
    return UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_FIRST_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_SETTERS + attribute + UtilConstants.PERIOD + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.NEW_LINE_ESTRIC + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_PARAM + attribute + UtilConstants.SPACE + attribute + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_RETURN + UtilConstants.BUILDER_OBJECT + attribute + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_END_LINE;
}
#method_after
private static String generateForSetters(String attribute, boolean isList) {
    String setter = UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_FIRST_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_SETTERS + attribute + UtilConstants.PERIOD + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.NEW_LINE_ESTRIC + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_PARAM + attribute + UtilConstants.SPACE;
    if (isList) {
        attribute = UtilConstants.LIST.toLowerCase() + UtilConstants.SPACE + UtilConstants.OF + UtilConstants.SPACE + attribute;
    }
    setter = setter + attribute + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_RETURN + UtilConstants.BUILDER_OBJECT + attribute + UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_END_LINE;
    return setter;
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    tenantIdSet.removeListener(setListener);
    tenantIdSet.destroy();
    networkIdVirtualNetworkConsistentMap.removeListener(virtualMapListener);
    networkIdVirtualNetworkConsistentMap.destroy();
    tenantIdNetworkIdSetConsistentMap.destroy();
    deviceIdVirtualDeviceConsistentMap.destroy();
    networkIdDeviceIdSetConsistentMap.destroy();
    networkIdVirtualLinkSetConsistentMap.destroy();
    networkIdVirtualPortSetConsistentMap.destroy();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    tenantIdSet.removeListener(setListener);
    networkIdVirtualNetworkConsistentMap.removeListener(virtualMapListener);
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void addTenantId(TenantId tenantId) {
    // If the tenant id exists then remove it first.
    removeTenantId(tenantId);
    tenantIdSet.add(tenantId);
}
#method_after
@Override
public void addTenantId(TenantId tenantId) {
    tenantIdSet.add(tenantId);
}
#end_block

#method_before
@Override
public void removeTenantId(TenantId tenantId) {
    if (tenantIdSet.contains(tenantId)) {
        tenantIdSet.remove(tenantId);
    }
}
#method_after
@Override
public void removeTenantId(TenantId tenantId) {
    tenantIdSet.remove(tenantId);
}
#end_block

#method_before
@Override
public VirtualNetwork addNetwork(TenantId tenantId) {
    checkState(tenantIdSet.contains(tenantId), "The tenant has not been registered. " + tenantId.id());
    VirtualNetwork virtualNetwork = new DefaultVirtualNetwork(genNetworkId(), tenantId);
    networkIdVirtualNetworkMap.put(virtualNetwork.id(), virtualNetwork);
    Set<NetworkId> virtualNetworkSet = tenantIdNetworkIdSetMap.get(tenantId);
    if (virtualNetworkSet == null) {
        virtualNetworkSet = new HashSet<>();
    }
    virtualNetworkSet.add(virtualNetwork.id());
    tenantIdNetworkIdSetMap.put(tenantId, virtualNetworkSet);
    return virtualNetwork;
}
#method_after
@Override
public VirtualNetwork addNetwork(TenantId tenantId) {
    checkState(tenantIdSet.contains(tenantId), "The tenant has not been registered. " + tenantId.id());
    VirtualNetwork virtualNetwork = new DefaultVirtualNetwork(genNetworkId(), tenantId);
    // TODO update both maps in one transaction.
    networkIdVirtualNetworkMap.put(virtualNetwork.id(), virtualNetwork);
    Set<NetworkId> virtualNetworkSet = tenantIdNetworkIdSetMap.get(tenantId);
    if (virtualNetworkSet == null) {
        virtualNetworkSet = new HashSet<>();
    }
    virtualNetworkSet.add(virtualNetwork.id());
    tenantIdNetworkIdSetMap.put(tenantId, virtualNetworkSet);
    return virtualNetwork;
}
#end_block

#method_before
@Override
public void removeNetwork(NetworkId networkId) {
    // Make sure that the virtual network exists before attempting to remove it.
    if (networkExists(networkId)) {
        VirtualNetwork virtualNetwork = networkIdVirtualNetworkMap.remove(networkId);
        Set<NetworkId> virtualNetworkSet = tenantIdNetworkIdSetMap.get(virtualNetwork.tenantId());
        virtualNetworkSet.remove(networkId);
    }
}
#method_after
@Override
public void removeNetwork(NetworkId networkId) {
    // Make sure that the virtual network exists before attempting to remove it.
    if (networkExists(networkId)) {
        VirtualNetwork virtualNetwork = networkIdVirtualNetworkMap.get(networkId);
        if (virtualNetwork == null) {
            return;
        }
        // TODO update both maps in one transaction.
        TenantId tenantId = virtualNetwork.tenantId();
        networkIdVirtualNetworkMap.compute(networkId, (id, existingVirtualNetwork) -> null);
        Set<NetworkId> virtualNetworkSet = tenantIdNetworkIdSetMap.get(tenantId);
        tenantIdNetworkIdSetMap.compute(virtualNetwork.tenantId(), (id, existingNetworkIds) -> {
            if (existingNetworkIds == null || existingNetworkIds.isEmpty()) {
                return ImmutableSet.of();
            } else {
                return ImmutableSet.<NetworkId>builder().addAll(Sets.difference(existingNetworkIds, ImmutableSet.copyOf(virtualNetworkSet))).build();
            }
        });
    }
}
#end_block

#method_before
@Override
public VirtualDevice addDevice(NetworkId networkId, DeviceId deviceId) {
    checkState(networkExists(networkId), "The network has not been added.");
    Set<DeviceId> deviceIdSet = networkIdDeviceIdSetMap.get(networkId);
    if (deviceIdSet == null) {
        deviceIdSet = new HashSet<>();
    }
    VirtualDevice virtualDevice = new DefaultVirtualDevice(networkId, deviceId);
    deviceIdVirtualDeviceMap.put(deviceId, virtualDevice);
    deviceIdSet.add(deviceId);
    networkIdDeviceIdSetMap.put(networkId, deviceIdSet);
    return virtualDevice;
}
#method_after
@Override
public VirtualDevice addDevice(NetworkId networkId, DeviceId deviceId) {
    checkState(networkExists(networkId), "The network has not been added.");
    Set<DeviceId> deviceIdSet = networkIdDeviceIdSetMap.get(networkId);
    if (deviceIdSet == null) {
        deviceIdSet = new HashSet<>();
    }
    VirtualDevice virtualDevice = new DefaultVirtualDevice(networkId, deviceId);
    // TODO update both maps in one transaction.
    deviceIdVirtualDeviceMap.put(deviceId, virtualDevice);
    deviceIdSet.add(deviceId);
    networkIdDeviceIdSetMap.put(networkId, deviceIdSet);
    return virtualDevice;
}
#end_block

#method_before
@Override
public void removeDevice(NetworkId networkId, DeviceId deviceId) {
    checkState(networkExists(networkId), "The network has not been added.");
    Set<DeviceId> deviceIdSet = networkIdDeviceIdSetMap.get(networkId);
    if (deviceIdSet != null) {
        deviceIdSet.remove(deviceId);
        deviceIdVirtualDeviceMap.remove(deviceId);
    }
}
#method_after
@Override
public void removeDevice(NetworkId networkId, DeviceId deviceId) {
    checkState(networkExists(networkId), "The network has not been added.");
    // TODO update both maps in one transaction.
    Set<DeviceId> deviceIdSet = networkIdDeviceIdSetMap.get(networkId);
    if (deviceIdSet != null) {
        networkIdDeviceIdSetMap.compute(networkId, (id, existingDeviceIds) -> {
            if (existingDeviceIds == null || existingDeviceIds.isEmpty()) {
                return ImmutableSet.of();
            } else {
                return ImmutableSet.<DeviceId>builder().addAll(Sets.difference(existingDeviceIds, ImmutableSet.copyOf(deviceIdSet))).build();
            }
        });
        deviceIdVirtualDeviceMap.compute(deviceId, (id, existingVirtualDevice) -> null);
        log.info("The deviceIdVirtualDeviceMap size is: " + getDevices(networkId));
    }
}
#end_block

#method_before
@Override
public void removeLink(NetworkId networkId, ConnectPoint src, ConnectPoint dst) {
    checkState(networkExists(networkId), "The network has not been added.");
    Set<VirtualLink> virtualLinkSet = networkIdVirtualLinkSetMap.get(networkId);
    if (virtualLinkSet != null) {
        ImmutableSet.copyOf(virtualLinkSet).forEach(virtualLink -> removeMatchingVirtualLink(virtualLinkSet, virtualLink, src, dst));
    }
}
#method_after
@Override
public void removeLink(NetworkId networkId, ConnectPoint src, ConnectPoint dst) {
    checkState(networkExists(networkId), "The network has not been added.");
    Set<VirtualLink> virtualLinkSet = networkIdVirtualLinkSetMap.get(networkId);
    if (virtualLinkSet != null) {
        networkIdVirtualLinkSetMap.compute(networkId, (id, existingVirtualLinks) -> {
            if (existingVirtualLinks == null || existingVirtualLinks.isEmpty()) {
                return ImmutableSet.of();
            } else {
                return ImmutableSet.<VirtualLink>builder().addAll(Sets.difference(existingVirtualLinks, ImmutableSet.copyOf(virtualLinkSet))).build();
            }
        });
    }
}
#end_block

#method_before
@Override
public void removePort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber) {
    checkState(networkExists(networkId), "The network has not been added.");
    Set<VirtualPort> virtualPortSet = networkIdVirtualPortSetMap.get(networkId);
    if (virtualPortSet != null) {
        ImmutableSet.copyOf(virtualPortSet).forEach(virtualPort -> removeMatchingVirtualPort(virtualPortSet, virtualPort, deviceId, portNumber));
    }
}
#method_after
@Override
public void removePort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber) {
    checkState(networkExists(networkId), "The network has not been added.");
    Set<VirtualPort> virtualPortSet = networkIdVirtualPortSetMap.get(networkId);
    if (virtualPortSet != null) {
        networkIdVirtualPortSetMap.compute(networkId, (id, existingVirtualPorts) -> {
            if (existingVirtualPorts == null || existingVirtualPorts.isEmpty()) {
                return ImmutableSet.of();
            } else {
                return ImmutableSet.<VirtualPort>builder().addAll(Sets.difference(existingVirtualPorts, ImmutableSet.copyOf(virtualPortSet))).build();
            }
        });
    }
}
#end_block

#method_before
@Override
public void event(MapEvent<NetworkId, VirtualNetwork> event) {
    NetworkId networkId = checkNotNull(event.key());
    VirtualNetworkEvent.Type type = null;
    switch(event.type()) {
        case INSERT:
            type = VirtualNetworkEvent.Type.NETWORK_ADDED;
            break;
        case UPDATE:
            type = VirtualNetworkEvent.Type.NETWORK_UPDATED;
            break;
        case REMOVE:
            type = VirtualNetworkEvent.Type.NETWORK_REMOVED;
            break;
        default:
            log.error("Unsupported event type: " + event.type());
    }
    notifyDelegate(new VirtualNetworkEvent(type, networkId));
}
#method_after
@Override
public void event(MapEvent<NetworkId, VirtualNetwork> event) {
    NetworkId networkId = checkNotNull(event.key());
    VirtualNetworkEvent.Type type = null;
    switch(event.type()) {
        case INSERT:
            type = VirtualNetworkEvent.Type.NETWORK_ADDED;
            break;
        case UPDATE:
            if ((event.oldValue().value() != null) && (event.newValue().value() == null)) {
                type = VirtualNetworkEvent.Type.NETWORK_REMOVED;
            } else {
                type = VirtualNetworkEvent.Type.NETWORK_UPDATED;
            }
            break;
        case REMOVE:
            type = VirtualNetworkEvent.Type.NETWORK_REMOVED;
            break;
        default:
            log.error("Unsupported event type: " + event.type());
    }
    notifyDelegate(new VirtualNetworkEvent(type, networkId));
}
#end_block

#method_before
@Override
public int hashCode() {
    return super.hashCode() + networkId.hashCode();
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(networkId, realizedBy);
}
#end_block

#method_before
@Override
public int hashCode() {
    return super.hashCode() + networkId.hashCode() + tunnelId.hashCode();
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(networkId, tunnelId);
}
#end_block

#method_before
@Override
public int hashCode() {
    return 31 * super.hashCode() + networkId.hashCode();
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(networkId);
}
#end_block

#method_before
@Test
public void testRegisterUnregisterTenantId() {
    manager.unregisterTenantId(TenantId.tenantId(tenantIdValue1));
    manager.registerTenantId(TenantId.tenantId(tenantIdValue1));
    manager.registerTenantId(TenantId.tenantId(tenantIdValue2));
    Collection<TenantId> tenantIdCollection = manager.getTenantIds();
    assertEquals("The tenantId set size did not match.", 2, tenantIdCollection.size());
    manager.unregisterTenantId(TenantId.tenantId(tenantIdValue1));
    manager.unregisterTenantId(TenantId.tenantId(tenantIdValue2));
    tenantIdCollection = manager.getTenantIds();
    assertTrue("The tenantId set should be empty.", tenantIdCollection.isEmpty());
    // Validate that the events were all received in the correct order.
    validateEvents(VirtualNetworkEvent.Type.TENANT_REGISTERED, VirtualNetworkEvent.Type.TENANT_REGISTERED, VirtualNetworkEvent.Type.TENANT_UNREGISTERED, VirtualNetworkEvent.Type.TENANT_UNREGISTERED);
}
#method_after
@Test
public void testRegisterUnregisterTenantId() {
    manager.unregisterTenantId(TenantId.tenantId(tenantIdValue1));
    manager.registerTenantId(TenantId.tenantId(tenantIdValue1));
    manager.registerTenantId(TenantId.tenantId(tenantIdValue2));
    Collection<TenantId> tenantIdCollection = manager.getTenantIds();
    assertEquals("The tenantId set size did not match.", 2, tenantIdCollection.size());
    manager.unregisterTenantId(TenantId.tenantId(tenantIdValue1));
    manager.unregisterTenantId(TenantId.tenantId(tenantIdValue2));
    tenantIdCollection = manager.getTenantIds();
    assertTrue("The tenantId set should be empty.", tenantIdCollection.isEmpty());
    // Validate that the events were all received in the correct order.
    validateEvents(VirtualNetworkEvent.Type.TENANT_UNREGISTERED, VirtualNetworkEvent.Type.TENANT_REGISTERED, VirtualNetworkEvent.Type.TENANT_REGISTERED, VirtualNetworkEvent.Type.TENANT_UNREGISTERED, VirtualNetworkEvent.Type.TENANT_UNREGISTERED);
}
#end_block

#method_before
@Override
public void addNode(OpenstackNode node) {
    checkNotNull(node, "Node cannot be null");
    NodeId leaderNodeId = leadershipService.getLeader(appId.name());
    log.debug("Node init requested, localNodeId: {}, leaderNodeId: {}", localNodeId, leaderNodeId);
    if (!localNodeId.equals(leaderNodeId)) {
        log.debug("Only the leaderNode can perform addNode operation");
        return;
    }
    nodeStore.putIfAbsent(node, checkNodeState(node));
    NodeState state = checkNodeState(node);
    state.process(this, node);
}
#method_after
@Override
public void addNode(OpenstackNode node) {
    checkNotNull(node, "Node cannot be null");
    NodeId leaderNodeId = leadershipService.getLeader(appId.name());
    log.debug("Node init requested, localNodeId: {}, leaderNodeId: {}", localNodeId, leaderNodeId);
    // TODO: Fix any node can engage this operation.
    if (!localNodeId.equals(leaderNodeId)) {
        log.debug("Only the leaderNode can perform addNode operation");
        return;
    }
    nodeStore.putIfAbsent(node, checkNodeState(node));
    NodeState state = checkNodeState(node);
    state.process(this, node);
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    NodeId leaderNodeId = leadershipService.getLeader(appId.name());
    if (!localNodeId.equals(leaderNodeId)) {
        log.debug("Only the leaderNode can process events");
        return;
    }
    Device device = event.subject();
    ConnectionHandler<Device> handler = (device.type().equals(SWITCH) ? bridgeHandler : ovsdbHandler);
    switch(event.type()) {
        case PORT_ADDED:
            eventExecutor.submit(() -> bridgeHandler.portAdded(event.port()));
            break;
        case PORT_UPDATED:
            if (!event.port().isEnabled()) {
                eventExecutor.submit(() -> bridgeHandler.portRemoved(event.port()));
            }
            break;
        case DEVICE_ADDED:
        case DEVICE_AVAILABILITY_CHANGED:
            if (deviceService.isAvailable(device.id())) {
                eventExecutor.submit(() -> handler.connected(device));
            } else {
                eventExecutor.submit(() -> handler.disconnected(device));
            }
            break;
        default:
            log.debug("Unsupported event type {}", event.type().toString());
            break;
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    NodeId leaderNodeId = leadershipService.getLeader(appId.name());
    // TODO: Fix any node can engage this operation.
    if (!localNodeId.equals(leaderNodeId)) {
        log.debug("Only the leaderNode can process events");
        return;
    }
    Device device = event.subject();
    ConnectionHandler<Device> handler = (device.type().equals(SWITCH) ? bridgeHandler : ovsdbHandler);
    switch(event.type()) {
        case PORT_ADDED:
            eventExecutor.submit(() -> bridgeHandler.portAdded(event.port()));
            break;
        case PORT_UPDATED:
            if (!event.port().isEnabled()) {
                eventExecutor.submit(() -> bridgeHandler.portRemoved(event.port()));
            }
            break;
        case DEVICE_ADDED:
        case DEVICE_AVAILABILITY_CHANGED:
            if (deviceService.isAvailable(device.id())) {
                eventExecutor.submit(() -> handler.connected(device));
            } else {
                eventExecutor.submit(() -> handler.disconnected(device));
            }
            break;
        default:
            log.debug("Unsupported event type {}", event.type().toString());
            break;
    }
}
#end_block

#method_before
@Activate
protected void active() {
    appId = coreService.getAppId(CordVtnService.CORDVTN_APP_ID);
    localNodeId = clusterService.getLocalNode().id();
    leadershipService.runForLeadership(appId.name());
    nodeStore = storageService.<String, CordVtnNode>consistentMapBuilder().withSerializer(Serializer.using(NODE_SERIALIZER.build())).withName("cordvtn-nodestore").withApplicationId(appId).build();
    ruleInstaller = new CordVtnRuleInstaller(appId, flowRuleService, deviceService, driverService, groupService, DEFAULT_TUNNEL);
    deviceService.addListener(deviceListener);
    configService.addListener(configListener);
    readConfiguration();
}
#method_after
@Activate
protected void active() {
    appId = coreService.getAppId(CordVtnService.CORDVTN_APP_ID);
    localNodeId = clusterService.getLocalNode().id();
    leadershipService.runForLeadership(appId.name());
    nodeStore = storageService.<String, CordVtnNode>consistentMapBuilder().withSerializer(Serializer.using(NODE_SERIALIZER.build())).withName("cordvtn-nodestore").withApplicationId(appId).build();
    ruleInstaller = new CordVtnRuleInstaller(appId, flowRuleService, deviceService, driverService, groupService, DEFAULT_TUNNEL);
    deviceService.addListener(deviceListener);
    configService.addListener(configListener);
}
#end_block

#method_before
@Override
protected void execute() {
    CordVtnNodeManager nodeManager = AbstractShellCommand.get(CordVtnNodeManager.class);
    nodeManager.flushRules();
}
#method_after
@Override
protected void execute() {
    CordVtnNodeManager nodeManager = AbstractShellCommand.get(CordVtnNodeManager.class);
    nodeManager.flushRules();
    print("Successfully flushed");
}
#end_block

#method_before
@Override
public void registerHandler(String type, BiFunction<Endpoint, byte[], byte[]> handler, Executor executor) {
    checkPermission(CLUSTER_WRITE);
    handlers.put(type, message -> executor.execute(() -> {
        byte[] responsePayload = handler.apply(message.sender(), message.payload());
        if (responsePayload != null) {
            InternalMessage response = new InternalMessage(message.id(), localEp, REPLY_MESSAGE_TYPE, responsePayload);
            sendAsync(message.sender(), response).whenComplete((result, error) -> {
                if (error != null) {
                    log.debug("Failed to respond", error);
                }
            });
        }
    }));
}
#method_after
@Override
public void registerHandler(String type, BiFunction<Endpoint, byte[], byte[]> handler, Executor executor) {
    checkPermission(CLUSTER_WRITE);
    handlers.put(type, message -> executor.execute(() -> {
        byte[] responsePayload = null;
        Status status = Status.OK;
        try {
            responsePayload = handler.apply(message.sender(), message.payload());
        } catch (Exception e) {
            status = Status.ERROR_HANDLER_EXCEPTION;
        }
        sendReply(message, status, Optional.ofNullable(responsePayload));
    }));
}
#end_block

#method_before
@Override
public void registerHandler(String type, BiFunction<Endpoint, byte[], CompletableFuture<byte[]>> handler) {
    checkPermission(CLUSTER_WRITE);
    handlers.put(type, message -> {
        handler.apply(message.sender(), message.payload()).whenComplete((result, error) -> {
            if (error == null) {
                InternalMessage response = new InternalMessage(message.id(), localEp, REPLY_MESSAGE_TYPE, result);
                sendAsync(message.sender(), response).whenComplete((r, e) -> {
                    if (e != null) {
                        log.debug("Failed to respond", e);
                    }
                });
            }
        });
    });
}
#method_after
@Override
public void registerHandler(String type, BiFunction<Endpoint, byte[], CompletableFuture<byte[]>> handler) {
    checkPermission(CLUSTER_WRITE);
    handlers.put(type, message -> {
        handler.apply(message.sender(), message.payload()).whenComplete((result, error) -> {
            Status status = error == null ? Status.OK : Status.ERROR_HANDLER_EXCEPTION;
            sendReply(message, status, Optional.ofNullable(result));
        });
    });
}
#end_block

#method_before
private void dispatchLocally(InternalMessage message) throws IOException {
    String type = message.type();
    if (REPLY_MESSAGE_TYPE.equals(type)) {
        try {
            Callback callback = callbacks.getIfPresent(message.id());
            if (callback != null) {
                callback.complete(message.payload());
            } else {
                log.warn("Received a reply for message id:[{}]. " + " from {}. But was unable to locate the" + " request handle", message.id(), message.sender());
            }
        } finally {
            callbacks.invalidate(message.id());
        }
        return;
    }
    Consumer<InternalMessage> handler = handlers.get(type);
    if (handler != null) {
        handler.accept(message);
    } else {
        log.debug("No handler registered for {}", type);
    }
}
#method_after
private void dispatchLocally(InternalMessage message) throws IOException {
    String type = message.type();
    if (REPLY_MESSAGE_TYPE.equals(type)) {
        try {
            Callback callback = callbacks.getIfPresent(message.id());
            if (callback != null) {
                if (message.status() == Status.OK) {
                    callback.complete(message.payload());
                } else if (message.status() == Status.ERROR_NO_HANDLER) {
                    callback.completeExceptionally(new MessagingException.NoRemoteHandler());
                } else if (message.status() == Status.ERROR_HANDLER_EXCEPTION) {
                    callback.completeExceptionally(new MessagingException.RemoteHandlerFailure());
                }
            } else {
                log.debug("Received a reply for message id:[{}]. " + " from {}. But was unable to locate the" + " request handle", message.id(), message.sender());
            }
        } finally {
            callbacks.invalidate(message.id());
        }
        return;
    }
    Consumer<InternalMessage> handler = handlers.get(type);
    if (handler != null) {
        handler.accept(message);
    } else {
        log.debug("No handler for message type {}", message.type(), message.sender());
        sendReply(message, Status.ERROR_NO_HANDLER, Optional.empty());
    }
}
#end_block

#method_before
private ClusterMetadataProvider getPrimaryProvider() {
    try {
        URI uri = new URI(System.getProperty("onos.cluster.metadata.uri", "config:///cluster.json"));
        return getProvider(uri.getScheme());
    } catch (URISyntaxException e) {
        Throwables.propagate(e);
        return null;
    }
}
#method_after
private ClusterMetadataProvider getPrimaryProvider() {
    String metadataUri = System.getProperty("onos.cluster.metadata.uri");
    try {
        String protocol = metadataUri == null ? null : new URL(metadataUri).getProtocol();
        if (protocol != null && (!protocol.equals("file") && !protocol.equals("http"))) {
            return getProvider(protocol);
        }
        // file provider supports both "file" and "http" uris
        return getProvider("file");
    } catch (MalformedURLException e) {
        return null;
    }
}
#end_block

#method_before
@Activate
public void activate() {
    eventDispatcher.addSink(PartitionEvent.class, listenerRegistry);
    metadataService.getClusterMetadata().getPartitions().stream().forEach(partition -> partitions.put(partition.getId(), new StoragePartition(partition, messagingService, clusterService, CatalystSerializers.getSerializer(), new File(System.getProperty("karaf.data") + "/data/" + partition.getId()))));
    CompletableFuture<Void> openFuture = CompletableFuture.allOf(partitions.values().stream().map(StoragePartition::open).toArray(CompletableFuture[]::new));
    openFuture.join();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    eventDispatcher.addSink(PartitionEvent.class, listenerRegistry);
    currentClusterMetadata.set(metadataService.getClusterMetadata());
    metadataService.addListener(metadataListener);
    currentClusterMetadata.get().getPartitions().stream().filter(// exclude p0
    partition -> !partition.getId().equals(PartitionId.from(0))).forEach(partition -> partitions.put(partition.getId(), new StoragePartition(partition, messagingService, clusterService, CatalystSerializers.getSerializer(), new File(System.getProperty("karaf.data") + "/data/" + partition.getId()))));
    CompletableFuture<Void> openFuture = CompletableFuture.allOf(partitions.values().stream().map(StoragePartition::open).toArray(CompletableFuture[]::new));
    openFuture.join();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    eventDispatcher.removeSink(PartitionEvent.class);
    CompletableFuture<Void> closeFuture = CompletableFuture.allOf(partitions.values().stream().map(StoragePartition::close).toArray(CompletableFuture[]::new));
    closeFuture.join();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    metadataService.removeListener(metadataListener);
    eventDispatcher.removeSink(PartitionEvent.class);
    CompletableFuture<Void> closeFuture = CompletableFuture.allOf(partitions.values().stream().map(StoragePartition::close).toArray(CompletableFuture[]::new));
    closeFuture.join();
    log.info("Stopped");
}
#end_block

#method_before
@Activate
public void activate() {
    configService.registerProperties(getClass());
    intentInstaller.init(store, trackerService, flowRuleService, flowObjectiveService);
    if (skipReleaseResourcesOnWithdrawal) {
        store.setDelegate(testOnlyDelegate);
    } else {
        store.setDelegate(delegate);
    }
    trackerService.setDelegate(topoDelegate);
    eventDispatcher.addSink(IntentEvent.class, listenerRegistry);
    batchExecutor = newSingleThreadExecutor(groupedThreads("onos/intent", "batch"));
    workerExecutor = newFixedThreadPool(NUM_THREADS, groupedThreads("onos/intent", "worker-%d"));
    idGenerator = coreService.getIdGenerator("intent-ids");
    Intent.bindIdGenerator(idGenerator);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    configService.registerProperties(getClass());
    intentInstaller.init(store, trackerService, flowRuleService, flowObjectiveService);
    if (skipReleaseResourcesOnWithdrawal) {
        store.setDelegate(testOnlyDelegate);
    } else {
        store.setDelegate(delegate);
    }
    trackerService.setDelegate(topoDelegate);
    eventDispatcher.addSink(IntentEvent.class, listenerRegistry);
    batchExecutor = newSingleThreadExecutor(groupedThreads("onos/intent", "batch"));
    workerExecutor = newFixedThreadPool(numThreads, groupedThreads("onos/intent", "worker-%d"));
    idGenerator = coreService.getIdGenerator("intent-ids");
    Intent.bindIdGenerator(idGenerator);
    log.info("Started");
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    if (context == null) {
        skipReleaseResourcesOnWithdrawal = DEFAULT_SKIP_RELEASE_RESOURCES_ON_WITHDRAWAL;
        logConfig("Default config");
        return;
    }
    String s = Tools.get(context.getProperties(), "skipReleaseResourcesOnWithdrawal");
    boolean newTestEnabled = isNullOrEmpty(s) ? skipReleaseResourcesOnWithdrawal : Boolean.parseBoolean(s.trim());
    if (skipReleaseResourcesOnWithdrawal && !newTestEnabled) {
        store.unsetDelegate(testOnlyDelegate);
        store.setDelegate(delegate);
        logConfig("Reconfigured");
    } else if (!skipReleaseResourcesOnWithdrawal && newTestEnabled) {
        store.unsetDelegate(delegate);
        store.setDelegate(testOnlyDelegate);
        logConfig("Reconfigured");
    }
}
#method_after
@Modified
public void modified(ComponentContext context) {
    if (context == null) {
        skipReleaseResourcesOnWithdrawal = DEFAULT_SKIP_RELEASE_RESOURCES_ON_WITHDRAWAL;
        logConfig("Default config");
        return;
    }
    String s = Tools.get(context.getProperties(), "skipReleaseResourcesOnWithdrawal");
    boolean newTestEnabled = isNullOrEmpty(s) ? skipReleaseResourcesOnWithdrawal : Boolean.parseBoolean(s.trim());
    if (skipReleaseResourcesOnWithdrawal && !newTestEnabled) {
        store.unsetDelegate(testOnlyDelegate);
        store.setDelegate(delegate);
        skipReleaseResourcesOnWithdrawal = false;
        logConfig("Reconfigured skip release resources on withdrawal");
    } else if (!skipReleaseResourcesOnWithdrawal && newTestEnabled) {
        store.unsetDelegate(delegate);
        store.setDelegate(testOnlyDelegate);
        skipReleaseResourcesOnWithdrawal = true;
        logConfig("Reconfigured skip release resources on withdrawal");
    }
    s = Tools.get(context.getProperties(), "numThreads");
    int newNumThreads = isNullOrEmpty(s) ? numThreads : Integer.parseInt(s);
    if (newNumThreads != numThreads) {
        numThreads = newNumThreads;
        ExecutorService oldWorkerExecutor = workerExecutor;
        workerExecutor = newFixedThreadPool(numThreads, groupedThreads("onos/intent", "worker-%d"));
        if (oldWorkerExecutor != null) {
            oldWorkerExecutor.shutdown();
        }
        logConfig("Reconfigured number of worker threads");
    }
}
#end_block

#method_before
@Override
public void run() {
    try {
        Pipeliner pipeliner = getDevicePipeliner(deviceId);
        if (pipeliner != null) {
            if (objective instanceof NextObjective) {
                pipeliner.next((NextObjective) objective);
            } else if (objective instanceof ForwardingObjective) {
                pipeliner.forward((ForwardingObjective) objective);
            } else {
                pipeliner.filter((FilteringObjective) objective);
            }
        } else if (numAttempts < INSTALL_RETRY_ATTEMPTS) {
            Thread.sleep(INSTALL_RETRY_INTERVAL);
            executorService.submit(new ObjectiveInstaller(deviceId, objective, numAttempts + 1));
        } else {
            // Otherwise we've tried a few times and failed, report an
            // error back to the user.
            objective.context().ifPresent(c -> c.onError(objective, ObjectiveError.DEVICEMISSING));
        }
    } catch (Exception e) {
        log.warn("Exception while installing flow objective", e);
    }
}
#method_after
@Override
public void run() {
    try {
        Pipeliner pipeliner = getDevicePipeliner(deviceId);
        if (pipeliner != null) {
            if (objective instanceof NextObjective) {
                pipeliner.next((NextObjective) objective);
            } else if (objective instanceof ForwardingObjective) {
                pipeliner.forward((ForwardingObjective) objective);
            } else {
                pipeliner.filter((FilteringObjective) objective);
            }
        } else if (numAttempts < INSTALL_RETRY_ATTEMPTS) {
            Thread.sleep(INSTALL_RETRY_INTERVAL);
            executorService.submit(new ObjectiveInstaller(deviceId, objective, numAttempts + 1));
        } else {
            // Otherwise we've tried a few times and failed, report an
            // error back to the user.
            objective.context().ifPresent(c -> c.onError(objective, ObjectiveError.NOPIPELINER));
        }
    } catch (Exception e) {
        log.warn("Exception while installing flow objective", e);
    }
}
#end_block

#method_before
@Activate
public void activate() {
    basePrimitiveCreator = partitionService.getDistributedPrimitiveCreator(PartitionId.from(0));
    Map<PartitionId, DistributedPrimitiveCreator> partitionMap = Maps.newHashMap();
    partitionService.getAllPartitionIds().stream().filter(id -> !id.equals(PartitionId.from(0))).forEach(id -> partitionMap.put(id, partitionService.getDistributedPrimitiveCreator(id)));
    federatedPrimitiveCreator = new FederatedDistributedPrimitiveCreator(partitionMap);
    transactions = this.<TransactionId, Transaction.State>consistentMapBuilder().withName("onos-transactions").withSerializer(Serializer.using(KryoNamespaces.API, MapUpdate.class, MapUpdate.Type.class, Transaction.class, Transaction.State.class)).buildAsyncMap();
    transactionCoordinator = new TransactionCoordinator(transactions);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    Map<PartitionId, DistributedPrimitiveCreator> partitionMap = Maps.newHashMap();
    partitionService.getAllPartitionIds().stream().filter(id -> !id.equals(PartitionId.from(0))).forEach(id -> partitionMap.put(id, partitionService.getDistributedPrimitiveCreator(id)));
    federatedPrimitiveCreator = new FederatedDistributedPrimitiveCreator(partitionMap);
    transactions = this.<TransactionId, Transaction.State>consistentMapBuilder().withName("onos-transactions").withSerializer(Serializer.using(KryoNamespaces.API, MapUpdate.class, MapUpdate.Type.class, Transaction.class, Transaction.State.class)).buildAsyncMap();
    transactionCoordinator = new TransactionCoordinator(transactions);
    log.info("Started");
}
#end_block

#method_before
@Override
public <K, V> ConsistentMapBuilder<K, V> consistentMapBuilder() {
    checkPermission(STORAGE_WRITE);
    return new NewDefaultConsistentMapBuilder<>(basePrimitiveCreator, federatedPrimitiveCreator);
}
#method_after
@Override
public <K, V> ConsistentMapBuilder<K, V> consistentMapBuilder() {
    checkPermission(STORAGE_WRITE);
    return new NewDefaultConsistentMapBuilder<>(federatedPrimitiveCreator);
}
#end_block

#method_before
@Override
public AtomicCounterBuilder atomicCounterBuilder() {
    checkPermission(STORAGE_WRITE);
    return new NewDefaultAtomicCounterBuilder(basePrimitiveCreator, federatedPrimitiveCreator);
}
#method_after
@Override
public AtomicCounterBuilder atomicCounterBuilder() {
    checkPermission(STORAGE_WRITE);
    return new NewDefaultAtomicCounterBuilder(federatedPrimitiveCreator);
}
#end_block

#method_before
@Override
public <V> AtomicValueBuilder<V> atomicValueBuilder() {
    checkPermission(STORAGE_WRITE);
    Supplier<ConsistentMapBuilder<String, byte[]>> mapBuilderSupplier = () -> this.<String, byte[]>consistentMapBuilder().withName("onos-atomic-values").withMeteringDisabled().withSerializer(Serializer.using(KryoNamespaces.BASIC));
    return new DefaultAtomicValueBuilder<>(mapBuilderSupplier);
}
#method_after
@Override
public <V> AtomicValueBuilder<V> atomicValueBuilder() {
    checkPermission(STORAGE_WRITE);
    Supplier<ConsistentMapBuilder<String, byte[]>> mapBuilderSupplier = () -> this.<String, byte[]>consistentMapBuilder().withName("onos-atomic-values").withSerializer(Serializer.using(KryoNamespaces.BASIC));
    return new DefaultAtomicValueBuilder<>(mapBuilderSupplier);
}
#end_block

#method_before
@Override
public TransactionContextBuilder transactionContextBuilder() {
    checkPermission(STORAGE_WRITE);
    return new NewDefaultTransactionContextBuilder(transactionIdGenerator.get(), basePrimitiveCreator, federatedPrimitiveCreator, transactionCoordinator);
}
#method_after
@Override
public TransactionContextBuilder transactionContextBuilder() {
    checkPermission(STORAGE_WRITE);
    return new NewDefaultTransactionContextBuilder(transactionIdGenerator.get(), federatedPrimitiveCreator, transactionCoordinator);
}
#end_block

#method_before
@Override
public LeaderElectorBuilder leaderElectorBuilder() {
    checkPermission(STORAGE_WRITE);
    return new DefaultLeaderElectorBuilder(basePrimitiveCreator, federatedPrimitiveCreator);
}
#method_after
@Override
public LeaderElectorBuilder leaderElectorBuilder() {
    checkPermission(STORAGE_WRITE);
    return new DefaultLeaderElectorBuilder(federatedPrimitiveCreator);
}
#end_block

#method_before
@Override
public List<MapInfo> getMapInfo() {
    return ListUtils.union(listMapInfo(basePrimitiveCreator), listMapInfo(federatedPrimitiveCreator));
}
#method_after
@Override
public List<MapInfo> getMapInfo() {
    return listMapInfo(federatedPrimitiveCreator);
}
#end_block

#method_before
@Override
public Map<String, Long> getInMemoryDatabaseCounters() {
    return getCounters(basePrimitiveCreator);
}
#method_after
@Override
public Map<String, Long> getInMemoryDatabaseCounters() {
    return ImmutableMap.of();
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    controller.getNetconfDevices().forEach(id -> controller.removeDevice(controller.getDevicesMap().get(id).getDeviceInfo()));
    controller.removeDeviceListener(innerNodeListener);
    providerRegistry.unregister(this);
    providerService = null;
    cfgService.unregisterConfigFactory(factory);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    controller.removeDeviceListener(innerNodeListener);
    controller.getNetconfDevices().forEach(id -> controller.removeDevice(controller.getDevicesMap().get(id).getDeviceInfo()));
    providerRegistry.unregister(this);
    providerService = null;
    cfgService.unregisterConfigFactory(factory);
    log.info("Stopped");
}
#end_block

#method_before
public void run() {
    BufferedReader bufferReader = new BufferedReader(new InputStreamReader(in));
    try {
        boolean socketClosed = false;
        StringBuilder deviceReplyBuilder = new StringBuilder();
        while (!socketClosed) {
            int cInt = bufferReader.read();
            if (cInt == -1) {
                log.debug("Netconf device {}  sent error char in session," + " will need to be reopend", netconfDeviceInfo);
            }
            char c = (char) cInt;
            state = state.evaluateChar(c);
            deviceReplyBuilder.append(c);
            if (state == NetconfMessageState.END_PATTERN) {
                String deviceReply = deviceReplyBuilder.toString();
                if (deviceReply.equals(END_PATTERN)) {
                    socketClosed = true;
                    NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_UNREGISTERED, null, null, Optional.of(-1), netconfDeviceInfo);
                    netconfDeviceEventListeners.forEach(listener -> listener.event(event));
                    this.interrupt();
                } else {
                    deviceReply = deviceReply.replace(END_PATTERN, "");
                    if (deviceReply.contains(RPC_REPLY) || deviceReply.contains(RPC_ERROR) || deviceReply.contains(HELLO)) {
                        NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_REPLY, null, deviceReply, getMsgId(deviceReply), netconfDeviceInfo);
                        sessionDelegate.notify(event);
                        netconfDeviceEventListeners.forEach(listener -> listener.event(event));
                    } else if (deviceReply.contains(NOTIFICATION_LABEL)) {
                        final String finalDeviceReply = deviceReply;
                        netconfDeviceEventListeners.forEach(listener -> listener.event(new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_NOTIFICATION, null, finalDeviceReply, getMsgId(finalDeviceReply), netconfDeviceInfo)));
                    } else {
                        log.info("Error on replay from device {} ", deviceReply);
                    }
                    deviceReplyBuilder.setLength(0);
                }
            }
        }
    } catch (IOException e) {
        log.warn("Error in reading from the session for device {} ", netconfDeviceInfo, e);
        throw new RuntimeException(new NetconfException("Error in reading from the session for device {}" + netconfDeviceInfo, e));
    // TODO should we send a socket closed message to listeners ?
    }
}
#method_after
public void run() {
    BufferedReader bufferReader = new BufferedReader(new InputStreamReader(in));
    try {
        boolean socketClosed = false;
        StringBuilder deviceReplyBuilder = new StringBuilder();
        while (!socketClosed) {
            int cInt = bufferReader.read();
            if (cInt == -1) {
                log.debug("Netconf device {}  sent error char in session," + " will need to be reopend", netconfDeviceInfo);
                NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_UNREGISTERED, null, null, Optional.of(-1), netconfDeviceInfo);
                netconfDeviceEventListeners.forEach(listener -> listener.event(event));
                socketClosed = true;
            }
            char c = (char) cInt;
            state = state.evaluateChar(c);
            deviceReplyBuilder.append(c);
            if (state == NetconfMessageState.END_PATTERN) {
                String deviceReply = deviceReplyBuilder.toString();
                if (deviceReply.equals(END_PATTERN)) {
                    socketClosed = true;
                    NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_UNREGISTERED, null, null, Optional.of(-1), netconfDeviceInfo);
                    netconfDeviceEventListeners.forEach(listener -> listener.event(event));
                    this.interrupt();
                } else {
                    deviceReply = deviceReply.replace(END_PATTERN, "");
                    if (deviceReply.contains(RPC_REPLY) || deviceReply.contains(RPC_ERROR) || deviceReply.contains(HELLO)) {
                        NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_REPLY, null, deviceReply, getMsgId(deviceReply), netconfDeviceInfo);
                        sessionDelegate.notify(event);
                        netconfDeviceEventListeners.forEach(listener -> listener.event(event));
                    } else if (deviceReply.contains(NOTIFICATION_LABEL)) {
                        final String finalDeviceReply = deviceReply;
                        netconfDeviceEventListeners.forEach(listener -> listener.event(new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_NOTIFICATION, null, finalDeviceReply, getMsgId(finalDeviceReply), netconfDeviceInfo)));
                    } else {
                        log.info("Error on replay from device {} ", deviceReply);
                    }
                    deviceReplyBuilder.setLength(0);
                }
            }
        }
    } catch (IOException e) {
        log.warn("Error in reading from the session for device {} ", netconfDeviceInfo, e);
        throw new RuntimeException(new NetconfException("Error in reading from the session for device {}" + netconfDeviceInfo, e));
    // TODO should we send a socket closed message to listeners ?
    }
}
#end_block

#method_before
private static Optional<Integer> getMsgId(String reply) {
    if (reply.contains(HELLO)) {
        return Optional.of(0);
    }
    if (reply.contains(RPC_ERROR) && !reply.contains(MESSAGE_ID)) {
        return Optional.empty();
    }
    String[] outer = reply.split(MESSAGE_ID);
    Preconditions.checkArgument(outer.length != 1, "Error in retrieving the message id");
    String messageID = outer[1].substring(0, 3).replace("\"", "");
    Preconditions.checkNotNull(Integer.parseInt(messageID), "Error in retrieving the message id");
    return Optional.of(Integer.parseInt(messageID));
}
#method_after
private static Optional<Integer> getMsgId(String reply) {
    if (reply.contains(MESSAGE_ID)) {
        String[] outer = reply.split(MESSAGE_ID);
        Preconditions.checkArgument(outer.length != 1, "Error in retrieving the message id");
        String messageID = outer[1].substring(0, 3).replace("\"", "");
        Preconditions.checkNotNull(Integer.parseInt(messageID), "Error in retrieving the message id");
        return Optional.of(Integer.parseInt(messageID));
    } else if (reply.contains(HELLO)) {
        return Optional.of(0);
    }
    return Optional.empty();
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    controller.getDevices().keySet().forEach(this::deviceRemoved);
    cfgService.removeListener(cfgLister);
    providerRegistry.unregister(this);
    providerService = null;
    cfgService.unregisterConfigFactory(factory);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    cfgService.removeListener(cfgLister);
    controller.getDevices().keySet().forEach(this::deviceRemoved);
    providerRegistry.unregister(this);
    providerService = null;
    cfgService.unregisterConfigFactory(factory);
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void run() {
    if (floatingIP.portId() != null && !floatingIP.portId().equals("null")) {
        rulePopulator.populateFloatingIpRules(floatingIP);
    } else {
        rulePopulator.removeFloatingIpRules(floatingIP);
    }
}
#method_after
@Override
public void run() {
    if (associate) {
        rulePopulator.populateFloatingIpRules(floatingIP);
    } else {
        rulePopulator.removeFloatingIpRules(floatingIP, portInfo);
    }
}
#end_block

#method_before
private void populatePnatOutgoingFlowRules(long vni, Ip4Address externalIp) {
    IPv4 iPacket = (IPv4) inboundPacket.parsed().getPayload();
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchTunnelId(vni).matchIPSrc(IpPrefix.valueOf(iPacket.getSourceAddress(), 32)).matchIPDst(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    tBuilder.setEthSrc(externalInterface).setEthDst(externalRouter).setIpSrc(externalIp);
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getSourcePort())).matchTcpDst(TpPort.tpPort(tcpPacket.getDestinationPort()));
            tBuilder.setTcpSrc(TpPort.tpPort(portNum));
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getSourcePort())).matchUdpDst(TpPort.tpPort(udpPacket.getDestinationPort()));
            tBuilder.setUdpSrc(TpPort.tpPort(portNum));
            break;
        default:
            break;
    }
    Port port = checkNotNull(getPortOfExternalInterface(), PORTNOTNULL);
    tBuilder.setOutput(port.number());
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PNAT_RULE_PRIORITY).makeTemporary(PNAT_TIMEOUT).fromApp(appId).add();
    flowObjectiveService.forward(inboundPacket.receivedFrom().deviceId(), fo);
}
#method_after
private void populatePnatOutgoingFlowRules(long vni, Ip4Address externalIp) {
    IPv4 iPacket = (IPv4) inboundPacket.parsed().getPayload();
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchTunnelId(vni).matchIPSrc(IpPrefix.valueOf(iPacket.getSourceAddress(), 32)).matchIPDst(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    tBuilder.setEthSrc(externalInterface).setEthDst(externalRouter).setIpSrc(externalIp);
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getSourcePort())).matchTcpDst(TpPort.tpPort(tcpPacket.getDestinationPort()));
            tBuilder.setTcpSrc(TpPort.tpPort(portNum));
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getSourcePort())).matchUdpDst(TpPort.tpPort(udpPacket.getDestinationPort()));
            tBuilder.setUdpSrc(TpPort.tpPort(portNum));
            break;
        default:
            log.debug("Unsupported IPv4 protocol {}");
            break;
    }
    Port port = checkNotNull(getPortOfExternalInterface(), PORTNOTNULL);
    tBuilder.setOutput(port.number());
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PNAT_RULE_PRIORITY).makeTemporary(PNAT_TIMEOUT).fromApp(appId).add();
    flowObjectiveService.forward(inboundPacket.receivedFrom().deviceId(), fo);
}
#end_block

#method_before
private Port getPortOfExternalInterface() {
    return deviceService.getPorts(inboundPacket.receivedFrom().deviceId()).stream().filter(p -> p.annotations().value(PORTNAME).equals(config.gatewayExternalInterfaceName())).findAny().orElse(null);
}
#method_after
private Port getPortOfExternalInterface() {
    return deviceService.getPorts(getGatewayNode().id()).stream().filter(p -> p.annotations().value(PORTNAME).equals(config.gatewayExternalInterfaceName())).findAny().orElse(null);
}
#end_block

#method_before
private Device getDevicefromOpenstackPort(OpenstackPort openstackPort) {
    String openstackPortName = "tap" + openstackPort.id().substring(0, 11);
    Device device = StreamSupport.stream(deviceService.getDevices().spliterator(), false).filter(d -> findPortinDevice(d, openstackPortName)).findAny().orElse(null);
    checkNotNull(device, DEVICENOTNULL);
    return device;
}
#method_after
private Device getDevicefromOpenstackPort(OpenstackPort openstackPort) {
    String openstackPortName = PORTNAME_PREFIX_VM + openstackPort.id().substring(0, 11);
    Device device = StreamSupport.stream(deviceService.getDevices().spliterator(), false).filter(d -> findPortinDevice(d, openstackPortName)).findAny().orElse(null);
    checkNotNull(device, DEVICENOTNULL);
    return device;
}
#end_block

#method_before
public void removeExternalRules(OpenstackRouterInterface routerInterface) {
    OpenstackSubnet openstackSubnet = openstackService.subnet(routerInterface.subnetId());
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(getVni(openstackSubnet.networkId())).matchEthDst(GATEWAYMAC);
    StreamSupport.stream(deviceService.getDevices().spliterator(), false).forEach(d -> {
        if (checkGatewayNode(d.id())) {
            removeRule(d.id(), sBuilder, ForwardingObjective.Flag.VERSATILE);
        } else {
            removeRule(d.id(), sBuilder, ForwardingObjective.Flag.SPECIFIC);
        }
    });
}
#method_after
public void removeExternalRules(OpenstackRouterInterface routerInterface) {
    OpenstackSubnet openstackSubnet = openstackService.subnet(routerInterface.subnetId());
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(getVni(openstackSubnet.networkId())).matchEthDst(GATEWAYMAC);
    StreamSupport.stream(deviceService.getDevices().spliterator(), false).forEach(d -> {
        if (checkGatewayNode(d.id())) {
            removeRule(d.id(), sBuilder, ForwardingObjective.Flag.VERSATILE, ROUTING_RULE_PRIORITY);
        } else {
            removeRule(d.id(), sBuilder, ForwardingObjective.Flag.SPECIFIC, ROUTING_RULE_PRIORITY);
        }
    });
}
#end_block

#method_before
private void removeRule(DeviceId id, TrafficSelector.Builder sBuilder, ForwardingObjective.Flag flag) {
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(flag).withPriority(ROUTING_RULE_PRIORITY).fromApp(appId).remove();
    flowObjectiveService.forward(id, fo);
}
#method_after
private void removeRule(DeviceId id, TrafficSelector.Builder sBuilder, ForwardingObjective.Flag flag, int priority) {
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(flag).withPriority(priority).fromApp(appId).remove();
    flowObjectiveService.forward(id, fo);
}
#end_block

#method_before
private void populateFloatingIpIncomingRules(OpenstackFloatingIP floatingIP, OpenstackPort port) {
    long vni = getVni(port.networkId());
    DeviceId portDeviceId = getDevicefromOpenstackPort(port).id();
    Device gatewayNode = getGatewayNode();
    Device portNode = deviceService.getDevice(portDeviceId);
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(floatingIP.floatingIpAddress(), 32));
    tBuilder.setEthSrc(MacAddress.valueOf(config.gatewayExternalInterfaceMac())).setEthDst(port.macAddress()).setIpDst(floatingIP.fixedIpAddress()).setTunnelId(getVni(port.networkId())).extension(buildNiciraExtenstion(gatewayNode.id(), getIPAddressforDevice(portNode)), gatewayNode.id()).setOutput(getTunnelPort(gatewayNode.id()));
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PNAT_RULE_PRIORITY).fromApp(appId).add();
    flowObjectiveService.forward(getGatewayNode().id(), fo);
}
#method_after
private void populateFloatingIpIncomingRules(OpenstackFloatingIP floatingIP, OpenstackPort port) {
    DeviceId portDeviceId = getDevicefromOpenstackPort(port).id();
    Device gatewayNode = getGatewayNode();
    Device portNode = deviceService.getDevice(portDeviceId);
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(floatingIP.floatingIpAddress(), 32));
    tBuilder.setEthSrc(MacAddress.valueOf(config.gatewayExternalInterfaceMac())).setEthDst(port.macAddress()).setIpDst(floatingIP.fixedIpAddress()).setTunnelId(getVni(port.networkId())).extension(buildNiciraExtenstion(gatewayNode.id(), getIPAddressforDevice(portNode)), gatewayNode.id()).setOutput(getTunnelPort(gatewayNode.id()));
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(FLOATING_RULE_PRIORITY).fromApp(appId).add();
    flowObjectiveService.forward(getGatewayNode().id(), fo);
}
#end_block

#method_before
private void populateFloatingIpOutgoingRules(OpenstackFloatingIP floatingIP, OpenstackPort port) {
    Port outputPort = checkNotNull(getPortOfExternalInterface(), PORTNOTNULL);
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(getVni(port.networkId())).matchIPSrc(IpPrefix.valueOf(floatingIP.fixedIpAddress(), 32));
    tBuilder.setIpSrc(floatingIP.floatingIpAddress()).setEthSrc(MacAddress.valueOf(config.gatewayExternalInterfaceMac())).setEthDst(MacAddress.valueOf(config.physicalRouterMac())).setOutput(outputPort.number());
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PNAT_RULE_PRIORITY).fromApp(appId).add();
    flowObjectiveService.forward(getGatewayNode().id(), fo);
}
#method_after
private void populateFloatingIpOutgoingRules(OpenstackFloatingIP floatingIP, OpenstackPort port) {
    Port outputPort = checkNotNull(getPortOfExternalInterface(), PORTNOTNULL);
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(getVni(port.networkId())).matchIPSrc(IpPrefix.valueOf(floatingIP.fixedIpAddress(), 32));
    tBuilder.setIpSrc(floatingIP.floatingIpAddress()).setEthSrc(MacAddress.valueOf(config.gatewayExternalInterfaceMac())).setEthDst(MacAddress.valueOf(config.physicalRouterMac())).setOutput(outputPort.number());
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(FLOATING_RULE_PRIORITY).fromApp(appId).add();
    flowObjectiveService.forward(getGatewayNode().id(), fo);
}
#end_block

#method_before
public void removeFloatingIpRules(OpenstackFloatingIP floatingIP) {
    TrafficSelector.Builder sOutgoingBuilder = DefaultTrafficSelector.builder();
    TrafficSelector.Builder sIncomingBuilder = DefaultTrafficSelector.builder();
    sOutgoingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(IpPrefix.valueOf(floatingIP.floatingIpAddress(), 32));
    sIncomingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(floatingIP.floatingIpAddress(), 32));
    removeRule(getGatewayNode().id(), sOutgoingBuilder, ForwardingObjective.Flag.VERSATILE);
    removeRule(getGatewayNode().id(), sIncomingBuilder, ForwardingObjective.Flag.VERSATILE);
}
#method_after
public void removeFloatingIpRules(OpenstackFloatingIP floatingIP, OpenstackPortInfo portInfo) {
    TrafficSelector.Builder sOutgoingBuilder = DefaultTrafficSelector.builder();
    TrafficSelector.Builder sIncomingBuilder = DefaultTrafficSelector.builder();
    sOutgoingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(portInfo.vni()).matchIPSrc(IpPrefix.valueOf(portInfo.ip(), 32));
    sIncomingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(floatingIP.floatingIpAddress(), 32));
    removeRule(getGatewayNode().id(), sOutgoingBuilder, ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
    removeRule(getGatewayNode().id(), sIncomingBuilder, ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_ID);
    packetService.addProcessor(internalPacketProcessor, PacketProcessor.director(1));
    configRegistry.registerConfigFactory(configFactory);
    configService.addListener(configListener);
    readConfiguration();
    // reloadInitL3Rules();
    log.info("onos-openstackrouting started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_ID);
    packetService.addProcessor(internalPacketProcessor, PacketProcessor.director(1));
    configRegistry.registerConfigFactory(configFactory);
    configService.addListener(configListener);
    readConfiguration();
    floatingIpMap = storageService.<String, OpenstackFloatingIP>consistentMapBuilder().withSerializer(Serializer.using(FLOATING_IP_SERIALIZER.build())).withName(FLOATING_IP_MAP_NAME).withApplicationId(appId).build();
    tpPortNumMap = storageService.<Integer, String>consistentMapBuilder().withSerializer(Serializer.using(NUMBER_SERIALIZER.build())).withName(TP_PORT_MAP_NAME).withApplicationId(appId).build();
    log.info("onos-openstackrouting started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    packetService.removeProcessor(internalPacketProcessor);
    l3EventExecutorService.shutdown();
    icmpEventExecutorService.shutdown();
    arpEventExecutorService.shutdown();
    log.info("onos-openstackrouting stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    packetService.removeProcessor(internalPacketProcessor);
    l3EventExecutorService.shutdown();
    icmpEventExecutorService.shutdown();
    arpEventExecutorService.shutdown();
    floatingIpMap.clear();
    tpPortNumMap.clear();
    log.info("onos-openstackrouting stopped");
}
#end_block

#method_before
@Override
public void createFloatingIP(OpenstackFloatingIP openstackFloatingIP) {
}
#method_after
@Override
public void createFloatingIP(OpenstackFloatingIP openstackFloatingIP) {
    floatingIpMap.put(openstackFloatingIP.id(), openstackFloatingIP);
}
#end_block

#method_before
@Override
public void updateFloatingIP(OpenstackFloatingIP openstackFloatingIP) {
    l3EventExecutorService.execute(new OpenstackFloatingIPHandler(rulePopulator, openstackFloatingIP));
}
#method_after
@Override
public void updateFloatingIP(OpenstackFloatingIP openstackFloatingIP) {
    if (!floatingIpMap.containsKey(openstackFloatingIP.id())) {
        log.warn("There`s no information about {} in FloatingIpMap", openstackFloatingIP.id());
        return;
    }
    if (openstackFloatingIP.portId() == null || openstackFloatingIP.portId().equals("null")) {
        OpenstackFloatingIP floatingIP = floatingIpMap.get(openstackFloatingIP.id()).value();
        OpenstackPortInfo portInfo = openstackSwitchingService.openstackPortInfo().get(PORTNAME_PREFIX_VM.concat(floatingIP.portId().substring(0, 11)));
        if (portInfo == null) {
            log.warn("There`s no portInfo information about portId {}", floatingIP.portId());
            return;
        }
        l3EventExecutorService.execute(new OpenstackFloatingIPHandler(rulePopulator, floatingIP, false, portInfo));
        floatingIpMap.replace(floatingIP.id(), openstackFloatingIP);
    } else {
        floatingIpMap.put(openstackFloatingIP.id(), openstackFloatingIP);
        l3EventExecutorService.execute(new OpenstackFloatingIPHandler(rulePopulator, openstackFloatingIP, true, null));
    }
}
#end_block

#method_before
@Override
public void deleteFloatingIP(String id) {
}
#method_after
@Override
public void deleteFloatingIP(String id) {
    floatingIpMap.remove(id);
}
#end_block

#method_before
private Collection<OpenstackRouter> getExternalRouter(boolean b) {
    List<OpenstackRouter> routers;
    if (b) {
        routers = openstackService.routers().stream().filter(r -> (r.gatewayExternalInfo().externalFixedIps().size() > 0)).collect(Collectors.toList());
    } else {
        routers = openstackService.routers().stream().filter(r -> (r.gatewayExternalInfo().externalFixedIps().size() == 0)).collect(Collectors.toList());
    }
    return routers;
}
#method_after
private Collection<OpenstackRouter> getExternalRouter(boolean externalConnection) {
    List<OpenstackRouter> routers;
    if (externalConnection) {
        routers = openstackService.routers().stream().filter(r -> (r.gatewayExternalInfo().externalFixedIps().size() > 0)).collect(Collectors.toList());
    } else {
        routers = openstackService.routers().stream().filter(r -> (r.gatewayExternalInfo().externalFixedIps().size() == 0)).collect(Collectors.toList());
    }
    return routers;
}
#end_block

#method_before
@Override
public void deleteRouter(String id) {
// TODO
}
#method_after
@Override
public void deleteRouter(String id) {
// TODO : In now, there`s nothing to do for deleteRouter process. It is reserved.
}
#end_block

#method_before
@Override
public void removeRouterInterface(OpenstackRouterInterface routerInterface) {
    OpenstackRoutingRulePopulator rulePopulator = new OpenstackRoutingRulePopulator(appId, openstackService, flowObjectiveService, deviceService, driverService, config);
    rulePopulator.removeExternalRules(routerInterface);
}
#method_after
@Override
public void removeRouterInterface(OpenstackRouterInterface routerInterface) {
    rulePopulator.removeExternalRules(routerInterface);
}
#end_block

#method_before
private void reloadInitL3Rules() {
    openstackService.ports().stream().filter(p -> p.deviceOwner().equals(DEVICE_OWNER_ROUTER_INTERFACE)).forEach(p -> {
        OpenstackRouterInterface routerInterface = portToRouterInterface(p);
        updateRouterInterface(routerInterface);
    });
}
#method_after
private void reloadInitL3Rules() {
    l3EventExecutorService.submit(() -> openstackService.ports().stream().filter(p -> p.deviceOwner().equals(DEVICE_OWNER_ROUTER_INTERFACE)).forEach(p -> {
        OpenstackRouterInterface routerInterface = portToRouterInterface(p);
        updateRouterInterface(routerInterface);
    }));
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    } else if (!context.inPacket().receivedFrom().deviceId().toString().equals(config.gatewayBridgeId())) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet == null) {
        return;
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 iPacket = (IPv4) ethernet.getPayload();
        OpenstackRoutingRulePopulator rulePopulator = new OpenstackRoutingRulePopulator(appId, openstackService, flowObjectiveService, deviceService, driverService, config);
        switch(iPacket.getProtocol()) {
            case IPv4.PROTOCOL_ICMP:
                icmpEventExecutorService.submit(() -> openstackIcmpHandler.processIcmpPacket(context, ethernet));
                break;
            default:
                int portNum = getPortNum(ethernet.getSourceMAC(), iPacket.getDestinationAddress());
                Port port = getExternalPort(pkt.receivedFrom().deviceId(), config.gatewayExternalInterfaceName());
                if (port == null) {
                    log.warn("There`s no external interface");
                    break;
                }
                OpenstackPort openstackPort = getOpenstackPort(ethernet.getSourceMAC(), Ip4Address.valueOf(iPacket.getSourceAddress()));
                l3EventExecutorService.execute(new OpenstackPnatHandler(rulePopulator, context, portNum, openstackPort, port, config));
                break;
        }
    } else if (ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        arpEventExecutorService.submit(() -> openstackArpHandler.processArpPacketFromRouter(context, ethernet));
    }
}
#method_after
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    } else if (!context.inPacket().receivedFrom().deviceId().toString().equals(config.gatewayBridgeId())) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    // TODO: Considers IPv6 later.
    if (ethernet == null) {
        return;
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 iPacket = (IPv4) ethernet.getPayload();
        switch(iPacket.getProtocol()) {
            case IPv4.PROTOCOL_ICMP:
                icmpEventExecutorService.submit(() -> openstackIcmpHandler.processIcmpPacket(context, ethernet));
                break;
            case IPv4.PROTOCOL_UDP:
                // don't process DHCP
                UDP udpPacket = (UDP) iPacket.getPayload();
                if (udpPacket.getDestinationPort() == UDP.DHCP_SERVER_PORT && udpPacket.getSourcePort() == UDP.DHCP_CLIENT_PORT) {
                    break;
                }
            default:
                int portNum = getPortNum(ethernet.getSourceMAC(), iPacket.getDestinationAddress());
                Port port = getExternalPort(pkt.receivedFrom().deviceId(), config.gatewayExternalInterfaceName());
                if (port == null) {
                    log.warn("There`s no external interface");
                    break;
                }
                OpenstackPort openstackPort = getOpenstackPort(ethernet.getSourceMAC(), Ip4Address.valueOf(iPacket.getSourceAddress()));
                l3EventExecutorService.execute(new OpenstackPnatHandler(rulePopulator, context, portNum, openstackPort, port, config));
                break;
        }
    } else if (ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        arpEventExecutorService.submit(() -> openstackArpHandler.processArpPacketFromRouter(context, ethernet));
    }
}
#end_block

#method_before
private int getPortNum(MacAddress sourceMac, int destinationAddress) {
    int portNum = portNumMap.keySet().stream().filter(k -> portNumMap.get(k).equals("")).findFirst().orElse(0);
    portNumMap.replace(portNum, sourceMac.toString().concat(":").concat(String.valueOf(destinationAddress)));
    return portNum;
}
#method_after
private int getPortNum(MacAddress sourceMac, int destinationAddress) {
    int portNum = findUnusedPortNum();
    if (portNum == 0) {
        clearPortNumMap();
        portNum = findUnusedPortNum();
    }
    tpPortNumMap.put(portNum, sourceMac.toString().concat(":").concat(String.valueOf(destinationAddress)));
    return portNum;
}
#end_block

#method_before
private void initiateL3Rule(OpenstackRouter router, OpenstackRouterInterface routerInterface) {
    long vni = Long.parseLong(openstackService.network(openstackService.port(routerInterface.portId()).networkId()).segmentId());
    OpenstackRoutingRulePopulator rulePopulator = new OpenstackRoutingRulePopulator(appId, openstackService, flowObjectiveService, deviceService, driverService, config);
    rulePopulator.populateExternalRules(vni, router, routerInterface);
}
#method_after
private void initiateL3Rule(OpenstackRouter router, OpenstackRouterInterface routerInterface) {
    long vni = Long.parseLong(openstackService.network(openstackService.port(routerInterface.portId()).networkId()).segmentId());
    rulePopulator.populateExternalRules(vni, router, routerInterface);
}
#end_block

#method_before
private OpenstackPort getOpenstackPort(MacAddress sourceMac, Ip4Address ip4Address) {
    OpenstackPort openstackPort = openstackService.ports().stream().filter(p -> p.macAddress().equals(sourceMac)).findFirst().orElse(null);
    return checkNotNull(openstackPort.fixedIps().values().stream().findFirst().orElse(null)).equals(ip4Address) ? openstackPort : null;
}
#method_after
private OpenstackPort getOpenstackPort(MacAddress sourceMac, Ip4Address ip4Address) {
    OpenstackPort openstackPort = openstackService.ports().stream().filter(p -> p.macAddress().equals(sourceMac)).findFirst().orElse(null);
    return openstackPort.fixedIps().values().stream().filter(ip -> ip.equals(ip4Address)).count() > 0 ? openstackPort : null;
}
#end_block

#method_before
private void readConfiguration() {
    config = configService.getConfig(appId, OpenstackRoutingConfig.class);
    if (config == null) {
        log.error("No configuration found");
        return;
    }
    checkNotNull(config.physicalRouterMac());
    checkNotNull(config.gatewayBridgeId());
    checkNotNull(config.gatewayExternalInterfaceMac());
    checkNotNull(config.gatewayExternalInterfaceName());
    log.debug("Configured info: {}, {}, {}, {}", config.physicalRouterMac(), config.gatewayBridgeId(), config.gatewayExternalInterfaceMac(), config.gatewayExternalInterfaceName());
    reloadInitL3Rules();
    openstackIcmpHandler = new OpenstackIcmpHandler(packetService, deviceService, openstackService, config, openstackSwitchingService);
    openstackArpHandler = new OpenstackRoutingArpHandler(packetService, openstackService, config);
    openstackIcmpHandler.requestPacket(appId);
    openstackArpHandler.requestPacket(appId);
    log.info("OpenstackRouting configured");
}
#method_after
private void readConfiguration() {
    config = configService.getConfig(appId, OpenstackRoutingConfig.class);
    if (config == null) {
        log.error("No configuration found");
        return;
    }
    checkNotNull(config.physicalRouterMac());
    checkNotNull(config.gatewayBridgeId());
    checkNotNull(config.gatewayExternalInterfaceMac());
    checkNotNull(config.gatewayExternalInterfaceName());
    log.debug("Configured info: {}, {}, {}, {}", config.physicalRouterMac(), config.gatewayBridgeId(), config.gatewayExternalInterfaceMac(), config.gatewayExternalInterfaceName());
    rulePopulator = new OpenstackRoutingRulePopulator(appId, openstackService, flowObjectiveService, deviceService, driverService, config);
    openstackIcmpHandler = new OpenstackIcmpHandler(packetService, deviceService, openstackService, config, openstackSwitchingService);
    openstackArpHandler = new OpenstackRoutingArpHandler(packetService, openstackService, config);
    openstackIcmpHandler.requestPacket(appId);
    openstackArpHandler.requestPacket(appId);
    reloadInitL3Rules();
    log.info("OpenstackRouting configured");
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    if (!event.configClass().equals(OpenstackRoutingConfig.class)) {
        return;
    }
    switch(event.type()) {
        case CONFIG_ADDED:
        case CONFIG_UPDATED:
            l3EventExecutorService.execute(OpenstackRoutingManager.this::readConfiguration);
            rulePopulator = new OpenstackRoutingRulePopulator(appId, openstackService, flowObjectiveService, deviceService, driverService, config);
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    if (!event.configClass().equals(OpenstackRoutingConfig.class)) {
        return;
    }
    if (event.type().equals(NetworkConfigEvent.Type.CONFIG_ADDED) || event.type().equals(NetworkConfigEvent.Type.CONFIG_UPDATED)) {
        l3EventExecutorService.execute(OpenstackRoutingManager.this::readConfiguration);
        rulePopulator = new OpenstackRoutingRulePopulator(appId, openstackService, flowObjectiveService, deviceService, driverService, config);
    }
}
#end_block

#method_before
public static void processRevisionDateEntry(TreeWalkListener listener, GeneratedYangParser.RevisionDateStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, REVISION_DATE_DATA, ctx.DATE_ARG().getText(), ENTRY);
    if (!isDateValid(ctx.DATE_ARG().getText())) {
        ParserException parserException = new ParserException("YANG file error: Input date is not correct");
        parserException.setLine(ctx.DATE_ARG().getSymbol().getLine());
        parserException.setCharPosition(ctx.DATE_ARG().getSymbol().getCharPositionInLine());
        throw parserException;
    }
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getYangConstructType()) {
        case IMPORT_DATA:
            {
                YangImport importNode = (YangImport) tmpNode;
                importNode.setRevision(ctx.DATE_ARG().getText());
                break;
            }
        case INCLUDE_DATA:
            {
                YangInclude includeNode = (YangInclude) tmpNode;
                includeNode.setRevision(ctx.DATE_ARG().getText());
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, REVISION_DATE_DATA, ctx.DATE_ARG().getText(), ENTRY));
    }
}
#method_after
public static void processRevisionDateEntry(TreeWalkListener listener, GeneratedYangParser.RevisionDateStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, REVISION_DATE_DATA, ctx.dateArgumentString().getText(), ENTRY);
    String date = removeQuotesAndHandleConcat(ctx.dateArgumentString().getText());
    if (!isDateValid(date)) {
        ParserException parserException = new ParserException("YANG file error: Input date is not correct");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getYangConstructType()) {
        case IMPORT_DATA:
            {
                YangImport importNode = (YangImport) tmpNode;
                importNode.setRevision(date);
                break;
            }
        case INCLUDE_DATA:
            {
                YangInclude includeNode = (YangInclude) tmpNode;
                includeNode.setRevision(date);
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, REVISION_DATE_DATA, ctx.dateArgumentString().getText(), ENTRY));
    }
}
#end_block

#method_before
public static void processRevisionEntry(TreeWalkListener listener, GeneratedYangParser.RevisionStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, REVISION_DATA, ctx.DATE_ARG().getText(), ENTRY);
    // value.
    if (!validateRevision(listener, ctx)) {
        return;
    // TODO to be implemented.
    }
    if (!isDateValid(ctx.DATE_ARG().getText())) {
        ParserException parserException = new ParserException("YANG file error: Input date is not correct");
        parserException.setLine(ctx.DATE_ARG().getSymbol().getLine());
        parserException.setCharPosition(ctx.DATE_ARG().getSymbol().getCharPositionInLine());
        throw parserException;
    }
    YangRevision revisionNode = new YangRevision();
    revisionNode.setRevDate(ctx.DATE_ARG().getText());
    listener.getParsedDataStack().push(revisionNode);
}
#method_after
public static void processRevisionEntry(TreeWalkListener listener, GeneratedYangParser.RevisionStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, REVISION_DATA, ctx.dateArgumentString().getText(), ENTRY);
    // value.
    if (!validateRevision(listener, ctx)) {
        return;
    // TODO to be implemented.
    }
    String date = removeQuotesAndHandleConcat(ctx.dateArgumentString().getText());
    if (!isDateValid(date)) {
        ParserException parserException = new ParserException("YANG file error: Input date is not correct");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    YangRevision revisionNode = new YangRevision();
    revisionNode.setRevDate(date);
    listener.getParsedDataStack().push(revisionNode);
}
#end_block

#method_before
public static void processRevisionExit(TreeWalkListener listener, GeneratedYangParser.RevisionStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, REVISION_DATA, ctx.DATE_ARG().getText(), EXIT);
    Parsable tmpRevisionNode = listener.getParsedDataStack().peek();
    if (tmpRevisionNode instanceof YangRevision) {
        listener.getParsedDataStack().pop();
        // Check for stack to be non empty.
        checkStackIsNotEmpty(listener, MISSING_HOLDER, REVISION_DATA, ctx.DATE_ARG().getText(), EXIT);
        Parsable tmpNode = listener.getParsedDataStack().peek();
        switch(tmpNode.getYangConstructType()) {
            case MODULE_DATA:
                {
                    YangModule module = (YangModule) tmpNode;
                    module.setRevision((YangRevision) tmpRevisionNode);
                    break;
                }
            case SUB_MODULE_DATA:
                {
                    YangSubModule subModule = (YangSubModule) tmpNode;
                    subModule.setRevision((YangRevision) tmpRevisionNode);
                    break;
                }
            default:
                throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, REVISION_DATA, ctx.DATE_ARG().getText(), EXIT));
        }
    } else {
        throw new ParserException(constructListenerErrorMessage(MISSING_CURRENT_HOLDER, REVISION_DATA, ctx.DATE_ARG().getText(), EXIT));
    }
}
#method_after
public static void processRevisionExit(TreeWalkListener listener, GeneratedYangParser.RevisionStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, REVISION_DATA, ctx.dateArgumentString().getText(), EXIT);
    Parsable tmpRevisionNode = listener.getParsedDataStack().peek();
    if (tmpRevisionNode instanceof YangRevision) {
        listener.getParsedDataStack().pop();
        // Check for stack to be non empty.
        checkStackIsNotEmpty(listener, MISSING_HOLDER, REVISION_DATA, ctx.dateArgumentString().getText(), EXIT);
        Parsable tmpNode = listener.getParsedDataStack().peek();
        switch(tmpNode.getYangConstructType()) {
            case MODULE_DATA:
                {
                    YangModule module = (YangModule) tmpNode;
                    module.setRevision((YangRevision) tmpRevisionNode);
                    break;
                }
            case SUB_MODULE_DATA:
                {
                    YangSubModule subModule = (YangSubModule) tmpNode;
                    subModule.setRevision((YangRevision) tmpRevisionNode);
                    break;
                }
            default:
                throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, REVISION_DATA, ctx.dateArgumentString().getText(), EXIT));
        }
    } else {
        throw new ParserException(constructListenerErrorMessage(MISSING_CURRENT_HOLDER, REVISION_DATA, ctx.dateArgumentString().getText(), EXIT));
    }
}
#end_block

#method_before
private void startSshSession() throws NetconfException {
    try {
        sshSession = netconfConnection.openSession();
        sshSession.startSubSystem("netconf");
        t = new NetconfStreamThread(sshSession.getStdout(), sshSession.getStdin(), sshSession.getStderr(), deviceInfo, new NetconfSessionDelegateImpl());
        this.addDeviceOutputListener(new NetconfDeviceOutputEventListenerImpl(deviceInfo));
        sendHello();
    } catch (IOException e) {
        log.error("Failed to create ch.ethz.ssh2.Session session:", e);
        throw new NetconfException("Failed to create ch.ethz.ssh2.Session session with device" + deviceInfo, e);
    }
}
#method_after
private void startSshSession() throws NetconfException {
    try {
        sshSession = netconfConnection.openSession();
        sshSession.startSubSystem("netconf");
        t = new NetconfStreamThread(sshSession.getStdout(), sshSession.getStdin(), sshSession.getStderr(), deviceInfo, new NetconfSessionDelegateImpl());
        this.addDeviceOutputListener(new NetconfDeviceOutputEventListenerImpl(deviceInfo));
        sendHello();
    } catch (IOException e) {
        log.error("Failed to create ch.ethz.ssh2.Session session." + e.getMessage());
        throw new NetconfException("Failed to create ch.ethz.ssh2.Session session with device" + deviceInfo, e);
    }
}
#end_block

#method_before
public void run() {
    BufferedReader bufferReader = new BufferedReader(new InputStreamReader(in));
    try {
        boolean socketClosed = false;
        StringBuilder deviceReplyBuilder = new StringBuilder();
        while (!socketClosed) {
            int cInt = bufferReader.read();
            if (cInt == -1) {
                log.debug("Netconf device {}  sent error char in session," + " will need to be reopend", netconfDeviceInfo);
            }
            char c = (char) cInt;
            state = state.evaluateChar(c);
            deviceReplyBuilder.append(c);
            if (state == NetconfMessageState.END_PATTERN) {
                String deviceReply = deviceReplyBuilder.toString();
                if (deviceReply.equals(END_PATTERN)) {
                    socketClosed = true;
                    NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_UNREGISTERED, null, null, Optional.of(-1), netconfDeviceInfo);
                    netconfDeviceEventListeners.forEach(listener -> listener.event(event));
                } else {
                    deviceReply = deviceReply.replace(END_PATTERN, "");
                    if (deviceReply.contains(RPC_REPLY) || deviceReply.contains(RPC_ERROR) || deviceReply.contains(HELLO)) {
                        NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_REPLY, null, deviceReply, getMsgId(deviceReply), netconfDeviceInfo);
                        sessionDelegate.notify(event);
                        netconfDeviceEventListeners.forEach(listener -> listener.event(event));
                    } else if (deviceReply.contains(NOTIFICATION_LABEL)) {
                        final String finalDeviceReply = deviceReply;
                        netconfDeviceEventListeners.forEach(listener -> listener.event(new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_NOTIFICATION, null, finalDeviceReply, getMsgId(finalDeviceReply), netconfDeviceInfo)));
                    } else {
                        log.info("Error on replay from device {} ", deviceReply);
                    }
                    deviceReplyBuilder.setLength(0);
                }
            }
        }
    } catch (IOException e) {
        log.warn("Error in reading from the session for device {} ", netconfDeviceInfo, e);
        throw new RuntimeException(new NetconfException("Error in reading from the session for device {}" + netconfDeviceInfo, e));
    // TODO should we send a socket closed message to listeners ?
    }
}
#method_after
public void run() {
    BufferedReader bufferReader = new BufferedReader(new InputStreamReader(in));
    try {
        boolean socketClosed = false;
        StringBuilder deviceReplyBuilder = new StringBuilder();
        while (!socketClosed) {
            int cInt = bufferReader.read();
            if (cInt == -1) {
                log.debug("Netconf device {}  sent error char in session," + " will need to be reopend", netconfDeviceInfo);
                NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_UNREGISTERED, null, null, Optional.of(-1), netconfDeviceInfo);
                netconfDeviceEventListeners.forEach(listener -> listener.event(event));
                socketClosed = true;
            }
            char c = (char) cInt;
            state = state.evaluateChar(c);
            deviceReplyBuilder.append(c);
            if (state == NetconfMessageState.END_PATTERN) {
                String deviceReply = deviceReplyBuilder.toString();
                if (deviceReply.equals(END_PATTERN)) {
                    socketClosed = true;
                    NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_UNREGISTERED, null, null, Optional.of(-1), netconfDeviceInfo);
                    netconfDeviceEventListeners.forEach(listener -> listener.event(event));
                } else {
                    deviceReply = deviceReply.replace(END_PATTERN, "");
                    if (deviceReply.contains(RPC_REPLY) || deviceReply.contains(RPC_ERROR) || deviceReply.contains(HELLO)) {
                        NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_REPLY, null, deviceReply, getMsgId(deviceReply), netconfDeviceInfo);
                        sessionDelegate.notify(event);
                        netconfDeviceEventListeners.forEach(listener -> listener.event(event));
                    } else if (deviceReply.contains(NOTIFICATION_LABEL)) {
                        final String finalDeviceReply = deviceReply;
                        netconfDeviceEventListeners.forEach(listener -> listener.event(new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_NOTIFICATION, null, finalDeviceReply, getMsgId(finalDeviceReply), netconfDeviceInfo)));
                    } else {
                        log.info("Error on replay from device {} ", deviceReply);
                    }
                    deviceReplyBuilder.setLength(0);
                }
            }
        }
    } catch (IOException e) {
        log.warn("Error in reading from the session for device {} ", netconfDeviceInfo, e);
        throw new RuntimeException(new NetconfException("Error in reading from the session for device {}" + netconfDeviceInfo, e));
    // TODO should we send a socket closed message to listeners ?
    }
}
#end_block

#method_before
private static Optional<Integer> getMsgId(String reply) {
    if (reply.contains(HELLO)) {
        return Optional.of(0);
    }
    if (reply.contains(RPC_ERROR) && !reply.contains(MESSAGE_ID)) {
        return Optional.empty();
    }
    String[] outer = reply.split(MESSAGE_ID);
    Preconditions.checkArgument(outer.length != 1, "Error in retrieving the message id");
    String messageID = outer[1].substring(0, 3).replace("\"", "");
    Preconditions.checkNotNull(Integer.parseInt(messageID), "Error in retrieving the message id");
    return Optional.of(Integer.parseInt(messageID));
}
#method_after
private static Optional<Integer> getMsgId(String reply) {
    if (reply.contains(MESSAGE_ID)) {
        String[] outer = reply.split(MESSAGE_ID);
        Preconditions.checkArgument(outer.length != 1, "Error in retrieving the message id");
        String messageID = outer[1].substring(0, 3).replace("\"", "");
        Preconditions.checkNotNull(Integer.parseInt(messageID), "Error in retrieving the message id");
        return Optional.of(Integer.parseInt(messageID));
    } else if (reply.contains(HELLO)) {
        return Optional.of(0);
    }
    return Optional.empty();
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createFloatingIp(InputStream input) {
    checkNotNull(input);
    try {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode floatingIpNode = (ObjectNode) mapper.readTree(input);
        OpenstackFloatingIP osFloatingIp = FLOATING_IP_CODEC.decode(floatingIpNode, this);
        OpenstackRoutingService routingService = getService(OpenstackRoutingService.class);
        routingService.createFloatingIP(osFloatingIp);
        log.debug("REST API CREATE floatingip called");
        return Response.status(Response.Status.OK).build();
    } catch (Exception e) {
        log.error("updateFloatingIp failed with {}", e.toString());
        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(e.toString()).build();
    }
}
#method_after
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createFloatingIp(InputStream input) {
    checkNotNull(input);
    try {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode floatingIpNode = (ObjectNode) mapper.readTree(input);
        OpenstackFloatingIP osFloatingIp = FLOATING_IP_CODEC.decode(floatingIpNode, this);
        OpenstackRoutingService routingService = getService(OpenstackRoutingService.class);
        routingService.createFloatingIP(osFloatingIp);
        log.debug("REST API CREATE floatingip called");
        return Response.status(Response.Status.OK).build();
    } catch (Exception e) {
        log.error("createFloatingIp failed with {}", e.toString());
        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(e.toString()).build();
    }
}
#end_block

#method_before
@DELETE
@Path("{id}")
public Response deleteFloatingIp(@PathParam("id") String id) {
    checkNotNull(id);
    OpenstackRoutingService routingService = getService(OpenstackRoutingService.class);
    routingService.deleteFloatingIP(id);
    log.debug("REST API DELETE floatingip is called {}", id);
    return Response.status(Response.Status.OK).build();
}
#method_after
@DELETE
@Path("{id}")
@Produces(MediaType.APPLICATION_JSON)
public Response deleteFloatingIp(@PathParam("id") String id) {
    checkNotNull(id);
    OpenstackRoutingService routingService = getService(OpenstackRoutingService.class);
    routingService.deleteFloatingIP(id);
    log.debug("REST API DELETE floatingip is called {}", id);
    return Response.status(Response.Status.OK).build();
}
#end_block

#method_before
private void encodeL0(ObjectNode result) {
    L0ModificationInstruction l0Instruction = (L0ModificationInstruction) this.instruction;
    result.put(InstructionCodec.SUBTYPE, l0Instruction.subtype().name());
    switch(l0Instruction.subtype()) {
        case LAMBDA:
            final L0ModificationInstruction.ModLambdaInstruction modLambdaInstruction = (L0ModificationInstruction.ModLambdaInstruction) l0Instruction;
            result.put(InstructionCodec.LAMBDA, modLambdaInstruction.lambda());
            break;
        case OCH:
            L0ModificationInstruction.ModOchSignalInstruction ochSignalInstruction = (L0ModificationInstruction.ModOchSignalInstruction) l0Instruction;
            OchSignal ochSignal = ochSignalInstruction.lambda();
            result.put(InstructionCodec.GRID_TYPE, ochSignal.gridType().name());
            result.put(InstructionCodec.CHANNEL_SPACING, ochSignal.channelSpacing().name());
            result.put(InstructionCodec.SPACING_MULTIPLIER, ochSignal.spacingMultiplier());
            result.put(InstructionCodec.SLOT_GRANULARITY, ochSignal.slotGranularity());
            break;
        default:
            log.info("Cannot convert L0 subtype of {}", l0Instruction.subtype());
    }
}
#method_after
private void encodeL0(ObjectNode result) {
    L0ModificationInstruction l0Instruction = (L0ModificationInstruction) instruction;
    result.put(InstructionCodec.SUBTYPE, l0Instruction.subtype().name());
    switch(l0Instruction.subtype()) {
        case LAMBDA:
            final L0ModificationInstruction.ModLambdaInstruction modLambdaInstruction = (L0ModificationInstruction.ModLambdaInstruction) l0Instruction;
            result.put(InstructionCodec.LAMBDA, modLambdaInstruction.lambda());
            break;
        case OCH:
            L0ModificationInstruction.ModOchSignalInstruction ochSignalInstruction = (L0ModificationInstruction.ModOchSignalInstruction) l0Instruction;
            OchSignal ochSignal = ochSignalInstruction.lambda();
            result.put(InstructionCodec.GRID_TYPE, ochSignal.gridType().name());
            result.put(InstructionCodec.CHANNEL_SPACING, ochSignal.channelSpacing().name());
            result.put(InstructionCodec.SPACING_MULTIPLIER, ochSignal.spacingMultiplier());
            result.put(InstructionCodec.SLOT_GRANULARITY, ochSignal.slotGranularity());
            break;
        default:
            log.info("Cannot convert L0 subtype of {}", l0Instruction.subtype());
    }
}
#end_block

#method_before
private void encodeL1(ObjectNode result) {
    L1ModificationInstruction l1Instruction = (L1ModificationInstruction) this.instruction;
    result.put(InstructionCodec.SUBTYPE, l1Instruction.subtype().name());
    switch(l1Instruction.subtype()) {
        case ODU_SIGID:
            final L1ModificationInstruction.ModOduSignalIdInstruction oduSignalIdInstruction = (L1ModificationInstruction.ModOduSignalIdInstruction) l1Instruction;
            OduSignalId oduSignalId = oduSignalIdInstruction.oduSignalId();
            ObjectNode child = result.putObject("oduSignalId");
            child.put(InstructionCodec.TRIBUTARY_PORT_NUMBER, oduSignalId.tributaryPortNumber());
            child.put(InstructionCodec.TRIBUTARY_SLOT_LEN, oduSignalId.tributarySlotLength());
            child.put(InstructionCodec.TRIBUTARY_SLOT_BITMAP, HexString.toHexString(oduSignalId.tributarySlotBitmap()));
            break;
        default:
            log.info("Cannot convert L1 subtype of {}", l1Instruction.subtype());
            break;
    }
}
#method_after
private void encodeL1(ObjectNode result) {
    L1ModificationInstruction l1Instruction = (L1ModificationInstruction) instruction;
    result.put(InstructionCodec.SUBTYPE, l1Instruction.subtype().name());
    switch(l1Instruction.subtype()) {
        case ODU_SIGID:
            final L1ModificationInstruction.ModOduSignalIdInstruction oduSignalIdInstruction = (L1ModificationInstruction.ModOduSignalIdInstruction) l1Instruction;
            OduSignalId oduSignalId = oduSignalIdInstruction.oduSignalId();
            ObjectNode child = result.putObject("oduSignalId");
            child.put(InstructionCodec.TRIBUTARY_PORT_NUMBER, oduSignalId.tributaryPortNumber());
            child.put(InstructionCodec.TRIBUTARY_SLOT_LEN, oduSignalId.tributarySlotLength());
            child.put(InstructionCodec.TRIBUTARY_SLOT_BITMAP, HexString.toHexString(oduSignalId.tributarySlotBitmap()));
            break;
        default:
            log.info("Cannot convert L1 subtype of {}", l1Instruction.subtype());
            break;
    }
}
#end_block

#method_before
private void encodeL2(ObjectNode result) {
    L2ModificationInstruction l2Instruction = (L2ModificationInstruction) this.instruction;
    result.put(InstructionCodec.SUBTYPE, l2Instruction.subtype().name());
    switch(l2Instruction.subtype()) {
        case ETH_SRC:
        case ETH_DST:
            final L2ModificationInstruction.ModEtherInstruction modEtherInstruction = (L2ModificationInstruction.ModEtherInstruction) l2Instruction;
            result.put(InstructionCodec.MAC, modEtherInstruction.mac().toString());
            break;
        case VLAN_ID:
            final L2ModificationInstruction.ModVlanIdInstruction modVlanIdInstruction = (L2ModificationInstruction.ModVlanIdInstruction) l2Instruction;
            result.put(InstructionCodec.VLAN_ID, modVlanIdInstruction.vlanId().toShort());
            break;
        case VLAN_PCP:
            final L2ModificationInstruction.ModVlanPcpInstruction modVlanPcpInstruction = (L2ModificationInstruction.ModVlanPcpInstruction) l2Instruction;
            result.put(InstructionCodec.VLAN_PCP, modVlanPcpInstruction.vlanPcp());
            break;
        case MPLS_LABEL:
            final L2ModificationInstruction.ModMplsLabelInstruction modMplsLabelInstruction = (L2ModificationInstruction.ModMplsLabelInstruction) l2Instruction;
            result.put(InstructionCodec.MPLS_LABEL, modMplsLabelInstruction.label().toInt());
            break;
        case MPLS_PUSH:
            final L2ModificationInstruction.PushHeaderInstructions pushHeaderInstructions = (L2ModificationInstruction.PushHeaderInstructions) l2Instruction;
            result.put(InstructionCodec.ETHERNET_TYPE, pushHeaderInstructions.ethernetType().toShort());
            break;
        case TUNNEL_ID:
            final L2ModificationInstruction.ModTunnelIdInstruction modTunnelIdInstruction = (L2ModificationInstruction.ModTunnelIdInstruction) l2Instruction;
            result.put(InstructionCodec.TUNNEL_ID, modTunnelIdInstruction.tunnelId());
            break;
        default:
            log.info("Cannot convert L2 subtype of {}", l2Instruction.subtype());
            break;
    }
}
#method_after
private void encodeL2(ObjectNode result) {
    L2ModificationInstruction l2Instruction = (L2ModificationInstruction) instruction;
    result.put(InstructionCodec.SUBTYPE, l2Instruction.subtype().name());
    switch(l2Instruction.subtype()) {
        case ETH_SRC:
        case ETH_DST:
            final L2ModificationInstruction.ModEtherInstruction modEtherInstruction = (L2ModificationInstruction.ModEtherInstruction) l2Instruction;
            result.put(InstructionCodec.MAC, modEtherInstruction.mac().toString());
            break;
        case VLAN_ID:
            final L2ModificationInstruction.ModVlanIdInstruction modVlanIdInstruction = (L2ModificationInstruction.ModVlanIdInstruction) l2Instruction;
            result.put(InstructionCodec.VLAN_ID, modVlanIdInstruction.vlanId().toShort());
            break;
        case VLAN_PCP:
            final L2ModificationInstruction.ModVlanPcpInstruction modVlanPcpInstruction = (L2ModificationInstruction.ModVlanPcpInstruction) l2Instruction;
            result.put(InstructionCodec.VLAN_PCP, modVlanPcpInstruction.vlanPcp());
            break;
        case MPLS_LABEL:
            final L2ModificationInstruction.ModMplsLabelInstruction modMplsLabelInstruction = (L2ModificationInstruction.ModMplsLabelInstruction) l2Instruction;
            result.put(InstructionCodec.MPLS_LABEL, modMplsLabelInstruction.label().toInt());
            break;
        case MPLS_PUSH:
            final L2ModificationInstruction.PushHeaderInstructions pushHeaderInstructions = (L2ModificationInstruction.PushHeaderInstructions) l2Instruction;
            result.put(InstructionCodec.ETHERNET_TYPE, pushHeaderInstructions.ethernetType().toShort());
            break;
        case TUNNEL_ID:
            final L2ModificationInstruction.ModTunnelIdInstruction modTunnelIdInstruction = (L2ModificationInstruction.ModTunnelIdInstruction) l2Instruction;
            result.put(InstructionCodec.TUNNEL_ID, modTunnelIdInstruction.tunnelId());
            break;
        default:
            log.info("Cannot convert L2 subtype of {}", l2Instruction.subtype());
            break;
    }
}
#end_block

#method_before
private void encodeL3(ObjectNode result) {
    L3ModificationInstruction l3Instruction = (L3ModificationInstruction) this.instruction;
    result.put(InstructionCodec.SUBTYPE, l3Instruction.subtype().name());
    switch(l3Instruction.subtype()) {
        case IPV4_SRC:
        case IPV4_DST:
        case IPV6_SRC:
        case IPV6_DST:
            final L3ModificationInstruction.ModIPInstruction modIPInstruction = (L3ModificationInstruction.ModIPInstruction) l3Instruction;
            result.put(InstructionCodec.IP, modIPInstruction.ip().toString());
            break;
        case IPV6_FLABEL:
            final L3ModificationInstruction.ModIPv6FlowLabelInstruction modFlowLabelInstruction = (L3ModificationInstruction.ModIPv6FlowLabelInstruction) l3Instruction;
            result.put(InstructionCodec.FLOW_LABEL, modFlowLabelInstruction.flowLabel());
            break;
        default:
            log.info("Cannot convert L3 subtype of {}", l3Instruction.subtype());
            break;
    }
}
#method_after
private void encodeL3(ObjectNode result) {
    L3ModificationInstruction l3Instruction = (L3ModificationInstruction) instruction;
    result.put(InstructionCodec.SUBTYPE, l3Instruction.subtype().name());
    switch(l3Instruction.subtype()) {
        case IPV4_SRC:
        case IPV4_DST:
        case IPV6_SRC:
        case IPV6_DST:
            final L3ModificationInstruction.ModIPInstruction modIPInstruction = (L3ModificationInstruction.ModIPInstruction) l3Instruction;
            result.put(InstructionCodec.IP, modIPInstruction.ip().toString());
            break;
        case IPV6_FLABEL:
            final L3ModificationInstruction.ModIPv6FlowLabelInstruction modFlowLabelInstruction = (L3ModificationInstruction.ModIPv6FlowLabelInstruction) l3Instruction;
            result.put(InstructionCodec.FLOW_LABEL, modFlowLabelInstruction.flowLabel());
            break;
        default:
            log.info("Cannot convert L3 subtype of {}", l3Instruction.subtype());
            break;
    }
}
#end_block

#method_before
private void encodeL4(ObjectNode result) {
    L4ModificationInstruction l4Instruction = (L4ModificationInstruction) this.instruction;
    result.put(InstructionCodec.SUBTYPE, l4Instruction.subtype().name());
    switch(l4Instruction.subtype()) {
        case TCP_DST:
        case TCP_SRC:
            final L4ModificationInstruction.ModTransportPortInstruction modTcpPortInstruction = (L4ModificationInstruction.ModTransportPortInstruction) l4Instruction;
            result.put(InstructionCodec.TCP_PORT, modTcpPortInstruction.port().toInt());
            break;
        case UDP_DST:
        case UDP_SRC:
            final L4ModificationInstruction.ModTransportPortInstruction modUdpPortInstruction = (L4ModificationInstruction.ModTransportPortInstruction) l4Instruction;
            result.put(InstructionCodec.UDP_PORT, modUdpPortInstruction.port().toInt());
            break;
        default:
            log.info("Cannot convert L4 subtype of {}", l4Instruction.subtype());
            break;
    }
}
#method_after
private void encodeL4(ObjectNode result) {
    L4ModificationInstruction l4Instruction = (L4ModificationInstruction) instruction;
    result.put(InstructionCodec.SUBTYPE, l4Instruction.subtype().name());
    switch(l4Instruction.subtype()) {
        case TCP_DST:
        case TCP_SRC:
            final L4ModificationInstruction.ModTransportPortInstruction modTcpPortInstruction = (L4ModificationInstruction.ModTransportPortInstruction) l4Instruction;
            result.put(InstructionCodec.TCP_PORT, modTcpPortInstruction.port().toInt());
            break;
        case UDP_DST:
        case UDP_SRC:
            final L4ModificationInstruction.ModTransportPortInstruction modUdpPortInstruction = (L4ModificationInstruction.ModTransportPortInstruction) l4Instruction;
            result.put(InstructionCodec.UDP_PORT, modUdpPortInstruction.port().toInt());
            break;
        default:
            log.info("Cannot convert L4 subtype of {}", l4Instruction.subtype());
            break;
    }
}
#end_block

#method_before
private boolean matchGroupInstruction(JsonNode instructionJson, Description description) {
    final String jsonType = instructionJson.get("type").textValue();
    GroupInstruction instructionToMatch = (GroupInstruction) instruction;
    if (!instructionToMatch.type().name().equals(jsonType)) {
        description.appendText("type was " + jsonType);
        return false;
    }
    final int jsonGroupId = instructionJson.get("groupId").asInt();
    if (instructionToMatch.groupId().id() != jsonGroupId) {
        description.appendText("groupId was " + jsonGroupId);
        return false;
    }
    return true;
}
#method_after
private boolean matchGroupInstruction(JsonNode instructionJson, Description description) {
    final String jsonType = instructionJson.get("type").textValue();
    GroupInstruction instructionToMatch = (GroupInstruction) instruction;
    if (!instructionToMatch.type().name().equals(jsonType)) {
        description.appendText("type was " + jsonType);
        return false;
    }
    final int jsonGroupId = instructionJson.get("groupId").intValue();
    if (instructionToMatch.groupId().id() != jsonGroupId) {
        description.appendText("groupId was " + jsonGroupId);
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean matchMeterInstruction(JsonNode instructionJson, Description description) {
    final String jsonType = instructionJson.get("type").textValue();
    MeterInstruction instructionToMatch = (MeterInstruction) instruction;
    if (!instructionToMatch.type().name().equals(jsonType)) {
        description.appendText("type was " + jsonType);
        return false;
    }
    final long jsonMeterId = instructionJson.get("meterId").asLong();
    if (instructionToMatch.meterId().id() != jsonMeterId) {
        description.appendText("meterId was " + jsonMeterId);
        return false;
    }
    return true;
}
#method_after
private boolean matchMeterInstruction(JsonNode instructionJson, Description description) {
    final String jsonType = instructionJson.get("type").textValue();
    MeterInstruction instructionToMatch = (MeterInstruction) instruction;
    if (!instructionToMatch.type().name().equals(jsonType)) {
        description.appendText("type was " + jsonType);
        return false;
    }
    final long jsonMeterId = instructionJson.get("meterId").longValue();
    if (instructionToMatch.meterId().id() != jsonMeterId) {
        description.appendText("meterId was " + jsonMeterId);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("name", name).add("version", version).add("description", description).add("origin", origin).add("category", category).add("url", url).add("readme", readme).add("role", role).add("permissions", permissions).add("featuresRepo", featuresRepo).add("features", features).add("requiredApps", requiredApps).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("name", name).add("version", version).add("description", description).add("title", title).add("origin", origin).add("category", category).add("url", url).add("readme", readme).add("role", role).add("permissions", permissions).add("featuresRepo", featuresRepo).add("features", features).add("requiredApps", requiredApps).toString();
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_ID);
    serviceFunctionForwarderService = new ServiceFunctionForwarderImpl(appId);
    flowClassifierInstallerService = new FlowClassifierInstallerImpl(appId);
    vtnRscService.addListener(vtnRscListener);
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(TenantId.class).register(PortPairId.class).register(PortPairGroupId.class).register(FlowClassifierId.class).register(PortChainId.class);
    packetService.addProcessor(processor, PacketProcessor.director(SFC_PRIORITY));
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_ID);
    serviceFunctionForwarder = new ServiceFunctionForwarderImpl(appId);
    flowClassifierInstaller = new FlowClassifierInstallerImpl(appId);
    nshSpiIdGenerator = coreService.getIdGenerator(nshSpiIdTopic);
    vtnRscService.addListener(vtnRscListener);
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(TenantId.class).register(PortPairId.class).register(PortPairGroupId.class).register(FlowClassifierId.class).register(PortChainId.class);
    nshSpiPortChainMap = storageService.<PortChainId, Integer>eventuallyConsistentMapBuilder().withName("nshSpiPortChainMap").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    nshSpiIdFreeList = storageService.<Integer>setBuilder().withName("nshSpiIdDeletedList").withSerializer(Serializer.using(KryoNamespaces.API)).build().asDistributedSet();
    packetService.addProcessor(processor, PacketProcessor.director(SFC_PRIORITY));
    log.info("Started");
}
#end_block

#method_before
@Override
public void onPortChainCreated(PortChain portChain) {
    NshServicePathId nshSpi;
    log.info("onPortChainCreated");
    if (nshSpiPortChainMap.containsKey(portChain.portChainId())) {
        nshSpi = nshSpiPortChainMap.get(portChain.portChainId());
    } else {
        nshSpi = NshServicePathId.of(NshSpiIdGenerators.create());
        nshSpiPortChainMap.put(portChain.portChainId(), nshSpi);
    }
    // install in OVS.
    flowClassifierInstallerService.installFlowClassifier(portChain, nshSpi);
    serviceFunctionForwarderService.installForwardingRule(portChain, nshSpi);
}
#method_after
@Override
public void onPortChainCreated(PortChain portChain) {
    NshServicePathId nshSpi;
    log.info("onPortChainCreated");
    if (nshSpiPortChainMap.containsKey(portChain.portChainId())) {
        nshSpi = NshServicePathId.of(nshSpiPortChainMap.get(portChain.portChainId()));
    } else {
        int id = getNextNshSpi();
        if (id > MAX_NSH_SPI_ID) {
            log.error("Reached max limit of service path index." + "Failed to install SFC for port chain {}", portChain.portChainId().toString());
            return;
        }
        nshSpi = NshServicePathId.of(id);
        nshSpiPortChainMap.put(portChain.portChainId(), new Integer(id));
    }
    // Install classifier rule to send the packet to controller
    flowClassifierInstaller.installFlowClassifier(portChain, nshSpi);
}
#end_block

#method_before
@Override
public void onPortChainDeleted(PortChain portChain) {
    log.info("onPortChainDeleted");
    if (!nshSpiPortChainMap.containsKey(portChain.portChainId())) {
        throw new ItemNotFoundException("Unable to find NSH SPI");
    }
    NshServicePathId nshSpi = nshSpiPortChainMap.get(portChain.portChainId());
    // uninstall from OVS.
    flowClassifierInstallerService.unInstallFlowClassifier(portChain, nshSpi);
    serviceFunctionForwarderService.unInstallForwardingRule(portChain, nshSpi);
    // remove SPI. No longer it will be used.
    nshSpiPortChainMap.remove(nshSpi);
}
#method_after
@Override
public void onPortChainDeleted(PortChain portChain) {
    log.info("onPortChainDeleted");
    if (!nshSpiPortChainMap.containsKey(portChain.portChainId())) {
        throw new ItemNotFoundException("Unable to find NSH SPI");
    }
    int nshSpiId = nshSpiPortChainMap.get(portChain.portChainId());
    // Uninstall classifier rules
    flowClassifierInstaller.unInstallFlowClassifier(portChain, NshServicePathId.of(nshSpiId));
    // remove from nshSpiPortChainMap and add to nshSpiIdFreeList
    nshSpiPortChainMap.remove(portChain.portChainId());
    nshSpiIdFreeList.add(nshSpiId);
    // Uninstall load balanced classifier and forwarding rules.
    NshServicePathId nshSpi;
    LoadBalanceId id;
    List<LoadBalanceId> processedIdList = Lists.newArrayList();
    Set<FiveTuple> fiveTupleSet = portChain.getLoadBalanceIdMapKeys();
    for (FiveTuple fiveTuple : fiveTupleSet) {
        id = portChain.getLoadBalanceId(fiveTuple);
        if (processedIdList.contains(id)) {
            // multiple five tuple can have single path.
            continue;
        } else {
            processedIdList.add(id);
        }
        nshSpi = NshServicePathId.of(getNshServicePathId(id, nshSpiId));
        flowClassifierInstaller.unInstallLoadBalancedFlowClassifier(portChain, fiveTuple, nshSpi);
        serviceFunctionForwarder.unInstallLoadBalancedForwardingRule(portChain.getLoadBalancePath(fiveTuple), nshSpi);
    }
}
#end_block

#method_before
private PortChainId findPortChainFromFiveTuple(FiveTuple fiveTupple) {
    PortChainId portChainId = null;
    Iterable<PortChain> portChains = portChainService.getPortChains();
    if (portChains == null) {
        log.error("Could not retrive port chain list");
    }
    // Identify the port chain to which the packet belongs
    for (final PortChain portChain : portChains) {
        boolean match = false;
        Iterable<FlowClassifierId> flowClassifiers = portChain.flowClassifiers();
        // One port chain can have multiple flow classifiers.
        for (final FlowClassifierId flowClassifierId : flowClassifiers) {
            FlowClassifier flowClassifier = flowClassifierService.getFlowClassifier(flowClassifierId);
            // Check whether protocol is set in flow classfiveTuppleifier
            if (flowClassifier.protocol() != null) {
                if ((flowClassifier.protocol() == "TCP" && fiveTupple.protocol() == IPv4.PROTOCOL_TCP) || (flowClassifier.protocol() == "UDP" && fiveTupple.protocol() == IPv4.PROTOCOL_UDP)) {
                    match = true;
                } else {
                    match = false;
                }
            }
            // Check whether source ip prefix is set in flow classifier
            if (flowClassifier.srcIpPrefix() != null) {
                if (flowClassifier.srcIpPrefix().contains(fiveTupple.ipSrc())) {
                    match = true;
                } else {
                    match = false;
                }
            }
            // Check whether destination ip prefix is set in flow classifier
            if (flowClassifier.dstIpPrefix() != null) {
                if (flowClassifier.dstIpPrefix().contains(fiveTupple.ipDst())) {
                    match = true;
                } else {
                    match = false;
                }
            }
            // Check whether source port is set in flow classifier
            if (flowClassifier.minSrcPortRange() != NULL_PORT && flowClassifier.maxSrcPortRange() != NULL_PORT) {
                if (fiveTupple.portSrc().toLong() >= flowClassifier.minSrcPortRange() || fiveTupple.portSrc().toLong() <= flowClassifier.maxSrcPortRange()) {
                    match = true;
                } else {
                    match = false;
                }
            }
            // Check whether destination port is set in flow classifier
            if (flowClassifier.minDstPortRange() != NULL_PORT && flowClassifier.maxDstPortRange() != NULL_PORT) {
                if (fiveTupple.portDst().toLong() >= flowClassifier.minSrcPortRange() || fiveTupple.portDst().toLong() <= flowClassifier.maxSrcPortRange()) {
                    match = true;
                } else {
                    match = false;
                }
            }
        }
        if (match) {
            portChainId = portChain.portChainId();
            break;
        }
    }
    return portChainId;
}
#method_after
private PortChainId findPortChainFromFiveTuple(FiveTuple fiveTuple) {
    PortChainId portChainId = null;
    Iterable<PortChain> portChains = portChainService.getPortChains();
    if (portChains == null) {
        log.error("Could not retrive port chain list");
    }
    // Identify the port chain to which the packet belongs
    for (final PortChain portChain : portChains) {
        if (!portChain.tenantId().equals(fiveTuple.tenantId())) {
            continue;
        }
        Iterable<FlowClassifierId> flowClassifiers = portChain.flowClassifiers();
        // One port chain can have multiple flow classifiers.
        for (final FlowClassifierId flowClassifierId : flowClassifiers) {
            FlowClassifier flowClassifier = flowClassifierService.getFlowClassifier(flowClassifierId);
            boolean match = false;
            // Check whether protocol is set in flow classifier
            if (flowClassifier.protocol() != null) {
                if ((flowClassifier.protocol().equals("TCP") && fiveTuple.protocol() == IPv4.PROTOCOL_TCP) || (flowClassifier.protocol().equals("UDP") && fiveTuple.protocol() == IPv4.PROTOCOL_UDP)) {
                    match = true;
                } else {
                    continue;
                }
            }
            // Check whether source ip prefix is set in flow classifier
            if (flowClassifier.srcIpPrefix() != null) {
                if (flowClassifier.srcIpPrefix().contains(fiveTuple.ipSrc())) {
                    match = true;
                } else {
                    continue;
                }
            }
            // Check whether destination ip prefix is set in flow classifier
            if (flowClassifier.dstIpPrefix() != null) {
                if (flowClassifier.dstIpPrefix().contains(fiveTuple.ipDst())) {
                    match = true;
                } else {
                    continue;
                }
            }
            // Check whether source port is set in flow classifier
            if (fiveTuple.portSrc().toLong() >= flowClassifier.minSrcPortRange() || fiveTuple.portSrc().toLong() <= flowClassifier.maxSrcPortRange()) {
                match = true;
            } else {
                continue;
            }
            // Check whether destination port is set in flow classifier
            if (fiveTuple.portDst().toLong() >= flowClassifier.minSrcPortRange() || fiveTuple.portDst().toLong() <= flowClassifier.maxSrcPortRange()) {
                match = true;
            } else {
                continue;
            }
            // Check whether neutron source port is set in flow classfier
            if ((flowClassifier.srcPort() != null) && (!flowClassifier.srcPort().portId().isEmpty())) {
                match = checkIpInVirtualPort(VirtualPortId.portId(flowClassifier.srcPort().portId()), fiveTuple.ipSrc());
                if (!match) {
                    continue;
                }
            }
            // Check whether destination neutron destination port is set in flow classifier
            if ((flowClassifier.dstPort() != null) && (!flowClassifier.dstPort().portId().isEmpty())) {
                match = checkIpInVirtualPort(VirtualPortId.portId(flowClassifier.dstPort().portId()), fiveTuple.ipDst());
                if (!match) {
                    continue;
                }
            }
            if (match) {
                portChainId = portChain.portChainId();
                break;
            }
        }
    }
    return portChainId;
}
#end_block

#method_before
private LoadBalanceId loadBalanceSfc(PortChainId portChainId, FiveTuple fiveTuple) {
    // Get the port chain
    PortChain portChain = portChainService.getPortChain(portChainId);
    Map<PortPairGroupId, PortPairId> loadBalancePath = new HashMap<>();
    // Get the list of port pair groups from port chain
    Iterable<PortPairGroupId> portPairGroups = portChain.portPairGroups();
    for (final PortPairGroupId portPairGroupId : portPairGroups) {
        PortPairGroup portPairGroup = portPairGroupService.getPortPairGroup(portPairGroupId);
        // Get the list of port pair ids from port pair group.
        Iterable<PortPairId> portPairs = portPairGroup.portPairs();
        int minLoad = 0xFFF;
        PortPairId minLoadPortPairId = null;
        for (final PortPairId portPairId : portPairs) {
            int load = portPairGroup.getLoad(portPairId);
            if (load == 0) {
                minLoadPortPairId = portPairId;
                break;
            } else {
                // Check the port pair which has min load.
                if (load < minLoad) {
                    minLoad = load;
                    minLoadPortPairId = portPairId;
                }
            }
        }
        if (minLoadPortPairId != null) {
            loadBalancePath.put(portPairGroupId, minLoadPortPairId);
            portPairGroup.addLoad(minLoadPortPairId);
        }
    }
    // Check if the path already exists, if not create a new id
    LoadBalanceId id = portChain.matchPath(loadBalancePath);
    if (id == null) {
        id = LoadBalanceId.of((byte) LoadBalanceIdGenerator.create());
    }
    portChain.addLoadBalancePath(fiveTuple, id, loadBalancePath);
    return id;
}
#method_after
private LoadBalanceId loadBalanceSfc(PortChainId portChainId, FiveTuple fiveTuple) {
    // Get the port chain
    PortChain portChain = portChainService.getPortChain(portChainId);
    List<PortPairId> loadBalancePath = Lists.newArrayList();
    LoadBalanceId id;
    int paths = portChain.getLoadBalancePathSize();
    if (paths >= MAX_LOAD_BALANCE_ID) {
        log.info("Max limit reached for load balance paths. " + "Reusing the created path for port chain {} with five tuple {}", portChainId, fiveTuple);
        id = LoadBalanceId.of((byte) ((paths + 1) % MAX_LOAD_BALANCE_ID));
        portChain.addLoadBalancePath(fiveTuple, id, portChain.getLoadBalancePath(id));
    }
    // Get the list of port pair groups from port chain
    Iterable<PortPairGroupId> portPairGroups = portChain.portPairGroups();
    for (final PortPairGroupId portPairGroupId : portPairGroups) {
        PortPairGroup portPairGroup = portPairGroupService.getPortPairGroup(portPairGroupId);
        // Get the list of port pair ids from port pair group.
        Iterable<PortPairId> portPairs = portPairGroup.portPairs();
        int minLoad = 0xFFF;
        PortPairId minLoadPortPairId = null;
        for (final PortPairId portPairId : portPairs) {
            int load = portPairGroup.getLoad(portPairId);
            if (load == 0) {
                minLoadPortPairId = portPairId;
                break;
            } else {
                // Check the port pair which has min load.
                if (load < minLoad) {
                    minLoad = load;
                    minLoadPortPairId = portPairId;
                }
            }
        }
        if (minLoadPortPairId != null) {
            loadBalancePath.add(minLoadPortPairId);
            portPairGroup.addLoad(minLoadPortPairId);
        }
    }
    // Check if the path already exists, if not create a new id
    Optional<LoadBalanceId> output = portChain.matchPath(loadBalancePath);
    if (output.isPresent()) {
        id = output.get();
    } else {
        id = LoadBalanceId.of((byte) (paths + 1));
    }
    portChain.addLoadBalancePath(fiveTuple, id, loadBalancePath);
    return id;
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    Ethernet packet = context.inPacket().parsed();
    if (packet == null) {
        return;
    }
    // get the five tupple parameters for the packet
    short ethType = packet.getEtherType();
    IpAddress ipSrc = null;
    IpAddress ipDst = null;
    int portSrc = 0;
    int portDst = 0;
    byte protocol = 0;
    if (ethType == Ethernet.TYPE_IPV4) {
        IPv4 ipv4Packet = (IPv4) packet.getPayload();
        ipSrc = IpAddress.valueOf(ipv4Packet.getSourceAddress());
        ipDst = IpAddress.valueOf(ipv4Packet.getDestinationAddress());
        protocol = ipv4Packet.getProtocol();
        if (protocol == IPv4.PROTOCOL_TCP) {
            TCP tcpPacket = (TCP) ipv4Packet.getPayload();
            portSrc = tcpPacket.getSourcePort();
            portDst = tcpPacket.getDestinationPort();
        } else if (protocol == IPv4.PROTOCOL_UDP) {
            UDP udpPacket = (UDP) ipv4Packet.getPayload();
            portSrc = udpPacket.getSourcePort();
            portDst = udpPacket.getDestinationPort();
        }
    } else if (ethType == Ethernet.TYPE_IPV6) {
        IPv6 ipv6Packet = (IPv6) packet.getPayload();
        ipSrc = IpAddress.valueOf(ipv6Packet.getSourceAddress().toString());
        ipDst = IpAddress.valueOf(ipv6Packet.getDestinationAddress().toString());
    }
    FiveTuple fiveTuple = DefaultFiveTuple.builder().setIpSrc(ipSrc).setIpDst(ipDst).setPortSrc(PortNumber.portNumber(portSrc)).setPortDst(PortNumber.portNumber(portDst)).setProtocol(protocol).build();
    PortChainId portChainId = findPortChainFromFiveTuple(fiveTuple);
    if (portChainId == null) {
        log.error("Packet does not match with any classifier");
        return;
    }
    // Once the 5 tuple and port chain are identified, give this input for load balancing
    LoadBalanceId id = loadBalanceSfc(portChainId, fiveTuple);
// TODO
// download the required flow rules for classifier and forwarding
// resend the packet back to classifier
}
#method_after
@Override
public void process(PacketContext context) {
    Ethernet packet = context.inPacket().parsed();
    if (packet == null) {
        return;
    }
    // get the five tuple parameters for the packet
    short ethType = packet.getEtherType();
    IpAddress ipSrc = null;
    IpAddress ipDst = null;
    int portSrc = 0;
    int portDst = 0;
    byte protocol = 0;
    MacAddress macSrc = packet.getSourceMAC();
    TenantId tenantId = getTenantId(macSrc);
    if (ethType == Ethernet.TYPE_IPV4) {
        IPv4 ipv4Packet = (IPv4) packet.getPayload();
        ipSrc = IpAddress.valueOf(ipv4Packet.getSourceAddress());
        ipDst = IpAddress.valueOf(ipv4Packet.getDestinationAddress());
        protocol = ipv4Packet.getProtocol();
        if (protocol == IPv4.PROTOCOL_TCP) {
            TCP tcpPacket = (TCP) ipv4Packet.getPayload();
            portSrc = tcpPacket.getSourcePort();
            portDst = tcpPacket.getDestinationPort();
        } else if (protocol == IPv4.PROTOCOL_UDP) {
            UDP udpPacket = (UDP) ipv4Packet.getPayload();
            portSrc = udpPacket.getSourcePort();
            portDst = udpPacket.getDestinationPort();
        }
    } else if (ethType == Ethernet.TYPE_IPV6) {
        return;
    }
    FiveTuple fiveTuple = DefaultFiveTuple.builder().setIpSrc(ipSrc).setIpDst(ipDst).setPortSrc(PortNumber.portNumber(portSrc)).setPortDst(PortNumber.portNumber(portDst)).setProtocol(protocol).setTenantId(tenantId).build();
    PortChainId portChainId = findPortChainFromFiveTuple(fiveTuple);
    if (portChainId == null) {
        log.error("Packet does not match with any classifier");
        return;
    }
    // Once the 5 tuple and port chain are identified, give this input for load balancing
    LoadBalanceId id = loadBalanceSfc(portChainId, fiveTuple);
    // Get nsh service path index
    NshServicePathId nshSpi;
    PortChain portChain = portChainService.getPortChain(portChainId);
    if (nshSpiPortChainMap.containsKey(portChain.portChainId())) {
        int nshSpiId = nshSpiPortChainMap.get(portChain.portChainId());
        nshSpi = NshServicePathId.of(getNshServicePathId(id, nshSpiId));
    } else {
        int nshSpiId = getNextNshSpi();
        if (nshSpiId > MAX_NSH_SPI_ID) {
            log.error("Reached max limit of service path index." + "Failed to install SFC for port chain {}", portChain.portChainId());
            return;
        }
        nshSpi = NshServicePathId.of(getNshServicePathId(id, nshSpiId));
        nshSpiPortChainMap.put(portChain.portChainId(), new Integer(nshSpiId));
    }
    // download the required flow rules for classifier and forwarding
    // install in OVS.
    ConnectPoint connectPoint = flowClassifierInstaller.installLoadBalancedFlowClassifier(portChain, fiveTuple, nshSpi);
    serviceFunctionForwarder.installLoadBalancedForwardingRule(portChain.getLoadBalancePath(fiveTuple), nshSpi);
    sendPacket(context, connectPoint);
}
#end_block

#method_before
public static String getPkgFromNameSpace(String nameSpace) {
    ArrayList<String> pkgArr = new ArrayList<String>();
    nameSpace = nameSpace.replace("\"", "");
    String regex = "[ : / - @ $ # ' * + , ; = ]+";
    String properNameSpace = nameSpace.replaceAll(regex, UtilConstants.COLAN);
    String[] nameSpaceArr = properNameSpace.split(UtilConstants.COLAN);
    for (String nameSpaceString : nameSpaceArr) {
        pkgArr.add(nameSpaceString);
    }
    return getPkgFrmArr(pkgArr);
}
#method_after
public static String getPkgFromNameSpace(String nameSpace) {
    ArrayList<String> pkgArr = new ArrayList<String>();
    nameSpace = nameSpace.replace(UtilConstants.QUOTES, UtilConstants.EMPTY_STRING);
    String properNameSpace = nameSpace.replaceAll(UtilConstants.REGEX_WITH_SPECIAL_CHAR, UtilConstants.COLAN);
    String[] nameSpaceArr = properNameSpace.split(UtilConstants.COLAN);
    for (String nameSpaceString : nameSpaceArr) {
        pkgArr.add(nameSpaceString);
    }
    return getPkgFrmArr(pkgArr);
}
#end_block

#method_before
public static String getYangRevisionStr(String date) {
    String[] revisionArr = date.split(UtilConstants.HYPHEN);
    String rev = "rev";
    for (String element : revisionArr) {
        Integer val = Integer.parseInt(element);
        if (val < 10) {
            rev = rev + "0";
        }
        rev = rev + val;
    }
    return rev;
}
#method_after
public static String getYangRevisionStr(String date) throws TranslatorException {
    String[] revisionArr = date.split(UtilConstants.HYPHEN);
    String rev = "rev";
    String year = revisionArr[INDEX_ZERO];
    char[] yearBytes = year.toCharArray();
    rev = rev + yearBytes[INDEX_TWO] + yearBytes[INDEX_THREE];
    if ((Integer.parseInt(revisionArr[INDEX_ONE]) <= MAX_MONTHS) && Integer.parseInt(revisionArr[INDEX_TWO]) <= MAX_DAYS) {
        for (int i = INDEX_ONE; i < revisionArr.length; i++) {
            Integer val = Integer.parseInt(revisionArr[i]);
            if (val < 10) {
                rev = rev + "0";
            }
            rev = rev + val;
        }
        return rev;
    } else {
        throw new TranslatorException("Date in revision is not proper: " + date);
    }
}
#end_block

#method_before
public static String getPkgFrmArr(ArrayList<String> pkgArr) {
    String pkg = "";
    int size = pkgArr.size();
    int i = 0;
    for (String member : pkgArr) {
        boolean presenceOfKeyword = javaKeywords.contains(member);
        if (presenceOfKeyword || (member.matches("\\d.*"))) {
            member = "_" + member;
        }
        pkg = pkg + member;
        if (i != size - 1) {
            pkg = pkg + UtilConstants.PERIOD;
        }
        i++;
    }
    return pkg;
}
#method_after
public static String getPkgFrmArr(ArrayList<String> pkgArr) {
    String pkg = UtilConstants.EMPTY_STRING;
    int size = pkgArr.size();
    int i = 0;
    for (String member : pkgArr) {
        boolean presenceOfKeyword = UtilConstants.JAVA_KEY_WORDS.contains(member);
        if (presenceOfKeyword || (member.matches(UtilConstants.REGEX_FOR_FIRST_DIGIT))) {
            member = UtilConstants.UNDER_SCORE + member;
        }
        pkg = pkg + member;
        if (i != size - 1) {
            pkg = pkg + UtilConstants.PERIOD;
        }
        i++;
    }
    return pkg;
}
#end_block

#method_before
@Test
public void getPackageFromParentTest() {
    String pkgFromParent = JavaIdentifierSyntax.getPackageFromParent("test5.test6.test7", "test1:test2:test3");
    assertThat(pkgFromParent.equals("test5.test6.test7.test1.test2.test3"), is(true));
}
#method_after
@Test
public void getPackageFromParentTest() {
    String pkgFromParent = JavaIdentifierSyntax.getPackageFromParent(PARENT_PACKAGE, CHILD_PACKAGE);
    assertThat(pkgFromParent.equals(PARENT_WITH_PERIOD + UtilConstants.PERIOD + CHILD_WITH_PERIOD), is(true));
}
#end_block

#method_before
@Test
public void getRootPackageTest() {
    String rootPackage = JavaIdentifierSyntax.getRootPackage((byte) 0, "test1:test2:test3", "5-1-2000");
    assertThat(rootPackage.equals("org.onosproject.yang.gen.v0.test1.test2.test3.rev05012000"), is(true));
}
#method_after
@Test
public void getRootPackageTest() {
    String rootPackage = JavaIdentifierSyntax.getRootPackage((byte) 1, CHILD_PACKAGE, DATE1);
    assertThat(rootPackage.equals(UtilConstants.DEFAULT_BASE_PKG + UtilConstants.PERIOD + VERSION_NUMBER + UtilConstants.PERIOD + CHILD_WITH_PERIOD + UtilConstants.PERIOD + DATE_WITH_REV1), is(true));
}
#end_block

#method_before
@Test
public void getRootPackageWithRevTest() {
    String rootPkgWithRev = JavaIdentifierSyntax.getRootPackage((byte) 0, "test1:test2:test3", "25-01-1992");
    assertThat(rootPkgWithRev.equals("org.onosproject.yang.gen.v0.test1.test2.test3.rev25011992"), is(true));
}
#method_after
@Test
public void getRootPackageWithRevTest() {
    String rootPkgWithRev = JavaIdentifierSyntax.getRootPackage((byte) 1, CHILD_PACKAGE, DATE2);
    assertThat(rootPkgWithRev.equals(UtilConstants.DEFAULT_BASE_PKG + UtilConstants.PERIOD + VERSION_NUMBER + UtilConstants.PERIOD + CHILD_WITH_PERIOD + UtilConstants.PERIOD + DATE_WITH_REV2), is(true));
}
#end_block

#method_before
@Test
public void getCapitalCaseTest() {
    String capitalCase = JavaIdentifierSyntax.getCaptialCase("test_this");
    assertThat(capitalCase.equals("Test_this"), is(true));
}
#method_after
@Test
public void getCapitalCaseTest() {
    String capitalCase = JavaIdentifierSyntax.getCaptialCase(WITHOUT_CAPITAL);
    assertThat(capitalCase.equals(WITH_CAPITAL), is(true));
}
#end_block

#method_before
@Test
public void getCamelCaseTest() {
    String camelCase = JavaIdentifierSyntax.getCamelCase("test-camel-case-identifier");
    assertThat(camelCase.equals("testCamelCaseIdentifier"), is(true));
}
#method_after
@Test
public void getCamelCaseTest() {
    String camelCase = JavaIdentifierSyntax.getCamelCase(WITHOUT_CAMEL_CASE);
    assertThat(camelCase.equals(WITH_CAMEL_CASE), is(true));
}
#end_block

#method_before
@Override
public void detectSelfCollision(String identifierName, YangConstructType dataType) throws DataModelException {
    if (this.getName().equals(identifierName)) {
        throw new DataModelException("YANG File Error: Identifier collision detected in container \"" + this.getName() + "\"");
    }
}
#method_after
@Override
public void detectSelfCollision(String identifierName, YangConstructType dataType) throws DataModelException {
    if (this.getName().equals(identifierName)) {
        throw new DataModelException("YANG file error: Duplicate input identifier detected, same as container \"" + this.getName() + "\"");
    }
}
#end_block

#method_before
@Override
public void detectSelfCollision(String identifierName, YangConstructType dataType) throws DataModelException {
    if (getName().equals(identifierName)) {
        throw new DataModelException("YANG File Error: Identifier collision detected in list \"" + getName() + "\"");
    }
}
#method_after
@Override
public void detectSelfCollision(String identifierName, YangConstructType dataType) throws DataModelException {
    if (this.getName().equals(identifierName)) {
        throw new DataModelException("YANG file error: Duplicate input identifier detected, same as list \"" + this.getName() + "\"");
    }
}
#end_block

#method_before
public static void processTypeDefEntry(TreeWalkListener listener, GeneratedYangParser.TypedefStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, TYPEDEF_DATA, ctx.IDENTIFIER().getText(), ENTRY);
    boolean result = validateSubStatementsCardinality(ctx);
    if (!result) {
        throw new ParserException(constructListenerErrorMessage(INVALID_CARDINALITY, yangConstruct, "", ENTRY));
    }
    /*
         * Create a derived type information, the base type must be set in type
         * listener.
         */
    YangType<YangDerivedType> derivedType = new YangType<YangDerivedType>();
    derivedType.setDataType(YangDataTypes.DERIVED);
    derivedType.setDataTypeName(ctx.IDENTIFIER().getText());
    YangTypeDef typeDefNode = new YangTypeDef();
    typeDefNode.setDerivedType(derivedType);
    Parsable curData = listener.getParsedDataStack().peek();
    if (curData instanceof YangModule | curData instanceof YangSubModule | curData instanceof YangContainer | curData instanceof YangList) {
        /*
             * TODO YangGrouping, YangRpc, YangInput, YangOutput, Notification.
             */
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(typeDefNode);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, TYPEDEF_DATA, ctx.IDENTIFIER().getText(), ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(typeDefNode);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPEDEF_DATA, ctx.IDENTIFIER().getText(), ENTRY));
    }
}
#method_after
public static void processTypeDefEntry(TreeWalkListener listener, GeneratedYangParser.TypedefStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, TYPEDEF_DATA, ctx.IDENTIFIER().getText(), ENTRY);
    // Validate sub statement cardinality.
    validateSubStatementsCardinality(ctx);
    /*
         * Create a derived type information, the base type must be set in type
         * listener.
         */
    YangType<YangDerivedType> derivedType = new YangType<YangDerivedType>();
    derivedType.setDataType(YangDataTypes.DERIVED);
    derivedType.setDataTypeName(ctx.IDENTIFIER().getText());
    YangTypeDef typeDefNode = new YangTypeDef();
    typeDefNode.setDerivedType(derivedType);
    Parsable curData = listener.getParsedDataStack().peek();
    if (curData instanceof YangModule || curData instanceof YangSubModule || curData instanceof YangContainer || curData instanceof YangList) {
        /*
             * TODO YangGrouping, YangRpc, YangInput, YangOutput, Notification.
             */
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(typeDefNode);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, TYPEDEF_DATA, ctx.IDENTIFIER().getText(), ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(typeDefNode);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPEDEF_DATA, ctx.IDENTIFIER().getText(), ENTRY));
    }
}
#end_block

#method_before
private static boolean validateSubStatementsCardinality(GeneratedYangParser.TypedefStatementContext ctx) {
    if (!ctx.unitsStatement().isEmpty() && ctx.unitsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY) {
        yangConstruct = UNITS_DATA;
        return false;
    }
    if (!ctx.defaultStatement().isEmpty() && ctx.defaultStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY) {
        yangConstruct = DEFAULT_DATA;
        return false;
    }
    if (ctx.typeStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY) {
        yangConstruct = TYPE_DATA;
        return false;
    }
    if (!ctx.descriptionStatement().isEmpty() && ctx.descriptionStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY) {
        yangConstruct = DESCRIPTION_DATA;
        return false;
    }
    if (!ctx.referenceStatement().isEmpty() && ctx.referenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY) {
        yangConstruct = REFERENCE_DATA;
        return false;
    }
    if (!ctx.statusStatement().isEmpty() && ctx.statusStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY) {
        yangConstruct = STATUS_DATA;
        return false;
    }
    return true;
}
#method_after
private static void validateSubStatementsCardinality(GeneratedYangParser.TypedefStatementContext ctx) {
    validateCardinality(ctx.unitsStatement(), UNITS_DATA, TYPEDEF_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.defaultStatement(), DEFAULT_DATA, TYPEDEF_DATA, ctx.IDENTIFIER().getText());
    validateCardinalityEqualsOne(ctx.typeStatement(), TYPE_DATA, TYPEDEF_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.descriptionStatement(), DESCRIPTION_DATA, TYPEDEF_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.referenceStatement(), REFERENCE_DATA, TYPEDEF_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.statusStatement(), STATUS_DATA, TYPEDEF_DATA, ctx.IDENTIFIER().getText());
}
#end_block

#method_before
private void serviceVmAdded(Host host) {
    String vNetId = host.annotations().value(SERVICE_ID);
    if (vNetId == null) {
        // ignore this host, it is not the service VM, or it's a vSG
        return;
    }
    OpenstackNetwork vNet = openstackService.network(vNetId);
    if (vNet == null) {
        log.warn("Failed to get OpenStack network {} for VM {}({}).", vNetId, host.id(), host.annotations().value(OPENSTACK_VM_ID));
        return;
    }
    log.info("VM {} is detected, MAC: {} IP: {}", host.annotations().value(OPENSTACK_VM_ID), host.mac(), host.ipAddresses().stream().findFirst().get());
    CordService service = getCordService(vNet);
    if (service == null) {
        return;
    }
    if (service.serviceType().equals(CordService.ServiceType.MANAGEMENT)) {
        ruleInstaller.populateManagementNetworkRules(host, service);
    } else {
        // TODO check if the service needs an update on its group buckets after done CORD-433
        ruleInstaller.updateServiceGroup(service);
        arpProxy.addGateway(service.serviceIp(), privateGatewayMac);
        // sends gratuitous ARP here for the case of adding existing VMs
        // when ONOS or cordvtn app is restarted
        arpProxy.sendGratuitousArpForGateway(service.serviceIp(), Sets.newHashSet(host));
    }
    registerDhcpLease(host, service);
    ruleInstaller.populateBasicConnectionRules(host, getTunnelIp(host), vNet);
    String serviceVlan = host.annotations().value(S_TAG);
    if (serviceVlan != null) {
        log.debug("vSG VM detected {}", host.id());
        Map<IpAddress, MacAddress> vSgs = getSubscriberGateways(host);
        vSgs.entrySet().stream().forEach(entry -> addVirtualSubscriberGateway(host, entry.getKey(), entry.getValue(), serviceVlan));
        ruleInstaller.populateSubscriberGatewayRules(host, vSgs.keySet());
    }
}
#method_after
private void serviceVmAdded(Host host) {
    String vNetId = host.annotations().value(SERVICE_ID);
    if (vNetId == null) {
        // ignore this host, it is not the service VM, or it's a vSG
        return;
    }
    OpenstackNetwork vNet = openstackService.network(vNetId);
    if (vNet == null) {
        log.warn("Failed to get OpenStack network {} for VM {}({}).", vNetId, host.id(), host.annotations().value(OPENSTACK_VM_ID));
        return;
    }
    log.info("VM {} is detected, MAC: {} IP: {}", host.annotations().value(OPENSTACK_VM_ID), host.mac(), host.ipAddresses().stream().findFirst().get());
    CordService service = getCordService(vNet);
    if (service == null) {
        return;
    }
    switch(service.serviceType()) {
        case MANAGEMENT:
            ruleInstaller.populateManagementNetworkRules(host, service);
            break;
        case PRIVATE:
        case PRIVATE_INDIRECT:
        case PRIVATE_DIRECT:
            arpProxy.addGateway(service.serviceIp(), privateGatewayMac);
        case PUBLIC_INDIRECT:
        case PUBLIC_DIRECT:
        default:
            // TODO check if the service needs an update on its group buckets after done CORD-433
            ruleInstaller.updateServiceGroup(service);
            // sends gratuitous ARP here for the case of adding existing VMs
            // when ONOS or cordvtn app is restarted
            arpProxy.sendGratuitousArpForGateway(service.serviceIp(), Sets.newHashSet(host));
            break;
    }
    registerDhcpLease(host, service);
    ruleInstaller.populateBasicConnectionRules(host, getTunnelIp(host), vNet);
    String serviceVlan = host.annotations().value(S_TAG);
    if (serviceVlan != null) {
        log.debug("vSG VM detected {}", host.id());
        Map<IpAddress, MacAddress> vSgs = getSubscriberGateways(host);
        vSgs.entrySet().stream().forEach(entry -> addVirtualSubscriberGateway(host, entry.getKey(), entry.getValue(), serviceVlan));
        ruleInstaller.populateSubscriberGatewayRules(host, vSgs.keySet());
    }
}
#end_block

#method_before
private void serviceVmRemoved(Host host) {
    String vNetId = host.annotations().value(SERVICE_ID);
    if (vNetId == null) {
        // ignore it, it's not the service VM or it's a vSG
        String serviceVlan = host.annotations().value(S_TAG);
        if (serviceVlan != null) {
            log.info("vSG {} removed", host.id());
        }
        return;
    }
    OpenstackNetwork vNet = openstackService.network(vNetId);
    if (vNet == null) {
        log.warn("Failed to get OpenStack network {} for VM {}({}).", vNetId, host.id(), host.annotations().value(OPENSTACK_VM_ID));
        return;
    }
    log.info("VM {} is vanished, MAC: {} IP: {}", host.annotations().value(OPENSTACK_VM_ID), host.mac(), host.ipAddresses().stream().findFirst().get());
    ruleInstaller.removeBasicConnectionRules(host);
    dhcpService.removeStaticMapping(host.mac());
    CordService service = getCordService(vNet);
    if (service == null) {
        return;
    }
    if (service.serviceType().equals(CordService.ServiceType.MANAGEMENT)) {
        ruleInstaller.removeManagementNetworkRules(host, service);
    } else {
        // TODO check if the service needs an update on its group buckets after done CORD-433
        ruleInstaller.updateServiceGroup(service);
        if (getHostsWithOpenstackNetwork(vNet).isEmpty()) {
            arpProxy.removeGateway(service.serviceIp());
        }
    }
}
#method_after
private void serviceVmRemoved(Host host) {
    String vNetId = host.annotations().value(SERVICE_ID);
    if (vNetId == null) {
        // ignore it, it's not the service VM or it's a vSG
        String serviceVlan = host.annotations().value(S_TAG);
        if (serviceVlan != null) {
            log.info("vSG {} removed", host.id());
        }
        return;
    }
    OpenstackNetwork vNet = openstackService.network(vNetId);
    if (vNet == null) {
        log.warn("Failed to get OpenStack network {} for VM {}({}).", vNetId, host.id(), host.annotations().value(OPENSTACK_VM_ID));
        return;
    }
    log.info("VM {} is vanished, MAC: {} IP: {}", host.annotations().value(OPENSTACK_VM_ID), host.mac(), host.ipAddresses().stream().findFirst().get());
    ruleInstaller.removeBasicConnectionRules(host);
    dhcpService.removeStaticMapping(host.mac());
    CordService service = getCordService(vNet);
    if (service == null) {
        return;
    }
    switch(service.serviceType()) {
        case MANAGEMENT:
            ruleInstaller.removeManagementNetworkRules(host, service);
            break;
        case PRIVATE:
        case PRIVATE_INDIRECT:
        case PRIVATE_DIRECT:
            if (getHostsWithOpenstackNetwork(vNet).isEmpty()) {
                arpProxy.removeGateway(service.serviceIp());
            }
        case PUBLIC_INDIRECT:
        case PUBLIC_DIRECT:
        default:
            // TODO check if the service needs an update on its group buckets after done CORD-433
            ruleInstaller.updateServiceGroup(service);
            break;
    }
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_ID);
    packetService.addProcessor(internalPacketProcessor, PacketProcessor.director(1));
    reloadInitL3Rules();
    log.info("onos-openstackrouting started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_ID);
    packetService.addProcessor(internalPacketProcessor, PacketProcessor.director(1));
    log.info("onos-openstackrouting started");
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet != null && ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 iPacket = (IPv4) ethernet.getPayload();
        OpenstackRoutingRulePopulator rulePopulator = new OpenstackRoutingRulePopulator(appId, openstackService, flowObjectiveService, deviceService, driverService);
        switch(iPacket.getProtocol()) {
            case IPv4.PROTOCOL_ICMP:
                icmpEventExecutorService.execute(new OpenstackIcmpHandler(rulePopulator, context));
                break;
            default:
                int portNum = getPortNum(ethernet.getSourceMAC(), iPacket.getDestinationAddress());
                Port port = getExternalPort(pkt.receivedFrom().deviceId(), EXTERNAL_INTERFACE_NAME);
                if (port == null) {
                    log.warn("There`s no external interface");
                    break;
                }
                OpenstackPort openstackPort = getOpenstackPort(ethernet.getSourceMAC(), Ip4Address.valueOf(iPacket.getSourceAddress()));
                l3EventExecutorService.execute(new OpenstackPnatHandler(rulePopulator, context, portNum, openstackPort, port));
                break;
        }
    }
}
#method_after
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet != null && ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 iPacket = (IPv4) ethernet.getPayload();
        OpenstackRoutingRulePopulator rulePopulator = new OpenstackRoutingRulePopulator(appId, openstackService, flowObjectiveService, deviceService, driverService);
        switch(iPacket.getProtocol()) {
            case IPv4.PROTOCOL_ICMP:
                icmpEventExecutorService.execute(new OpenstackIcmpHandler(rulePopulator, context));
                break;
            case IPv4.PROTOCOL_UDP:
                // don't process DHCP
                UDP udpPacket = (UDP) iPacket.getPayload();
                if (udpPacket.getDestinationPort() == UDP.DHCP_SERVER_PORT && udpPacket.getSourcePort() == UDP.DHCP_CLIENT_PORT) {
                    break;
                }
            default:
                int portNum = getPortNum(ethernet.getSourceMAC(), iPacket.getDestinationAddress());
                Port port = getExternalPort(pkt.receivedFrom().deviceId(), EXTERNAL_INTERFACE_NAME);
                if (port == null) {
                    log.warn("There`s no external interface");
                    break;
                }
                OpenstackPort openstackPort = getOpenstackPort(ethernet.getSourceMAC(), Ip4Address.valueOf(iPacket.getSourceAddress()));
                l3EventExecutorService.execute(new OpenstackPnatHandler(rulePopulator, context, portNum, openstackPort, port));
                break;
        }
    }
}
#end_block

#method_before
@Override
public List<PcepRPObject> getRPObjList() {
    return this.llRPObjList;
}
#method_after
@Override
public List<PcepRPObject> getRPObjList() {
    return this.rpObjList;
}
#end_block

#method_before
@Override
public List<PcepLSObject> getLSObjList() {
    return this.llLSObjList;
}
#method_after
@Override
public List<PcepLSObject> getLSObjList() {
    return this.lsObjList;
}
#end_block

#method_before
@Override
public List<PcepErrorObject> getErrorObjList() {
    return this.llErrObjList;
}
#method_after
@Override
public List<PcepErrorObject> getErrorObjList() {
    return this.errObjList;
}
#end_block

#method_before
public void parseRPList(ChannelBuffer cb) throws PcepParseException {
    byte yObjClass;
    byte yObjType;
    llRPObjList = new LinkedList<>();
    // caller should verify for RP object
    if (cb.readableBytes() < OBJECT_HEADER_LENGTH) {
        log.debug("Unable to find RP Object");
        return;
    }
    cb.markReaderIndex();
    PcepObjectHeader tempObjHeader = PcepObjectHeader.read(cb);
    cb.resetReaderIndex();
    yObjClass = tempObjHeader.getObjClass();
    yObjType = tempObjHeader.getObjType();
    PcepRPObject rpObj;
    while ((yObjClass == PcepRPObjectVer1.RP_OBJ_CLASS) && (yObjType == PcepRPObjectVer1.RP_OBJ_TYPE)) {
        rpObj = PcepRPObjectVer1.read(cb);
        llRPObjList.add(rpObj);
        if (cb.readableBytes() > OBJECT_HEADER_LENGTH) {
            cb.markReaderIndex();
            tempObjHeader = PcepObjectHeader.read(cb);
            cb.resetReaderIndex();
            yObjClass = tempObjHeader.getObjClass();
            yObjType = tempObjHeader.getObjType();
        } else {
            break;
        }
    }
}
#method_after
public void parseRPList(ChannelBuffer cb) throws PcepParseException {
    byte yObjClass;
    byte yObjType;
    rpObjList = new LinkedList<>();
    // caller should verify for RP object
    if (cb.readableBytes() < OBJECT_HEADER_LENGTH) {
        log.debug("Unable to find RP Object");
        return;
    }
    cb.markReaderIndex();
    PcepObjectHeader tempObjHeader = PcepObjectHeader.read(cb);
    cb.resetReaderIndex();
    yObjClass = tempObjHeader.getObjClass();
    yObjType = tempObjHeader.getObjType();
    PcepRPObject rpObj;
    while ((yObjClass == PcepRPObjectVer1.RP_OBJ_CLASS) && (yObjType == PcepRPObjectVer1.RP_OBJ_TYPE)) {
        rpObj = PcepRPObjectVer1.read(cb);
        rpObjList.add(rpObj);
        if (cb.readableBytes() > OBJECT_HEADER_LENGTH) {
            cb.markReaderIndex();
            tempObjHeader = PcepObjectHeader.read(cb);
            cb.resetReaderIndex();
            yObjClass = tempObjHeader.getObjClass();
            yObjType = tempObjHeader.getObjType();
        } else {
            break;
        }
    }
}
#end_block

#method_before
public void parseLSList(ChannelBuffer cb) throws PcepParseException {
    byte yObjClass;
    byte yObjType;
    llLSObjList = new LinkedList<>();
    // caller should verify for LS object
    if (cb.readableBytes() < OBJECT_HEADER_LENGTH) {
        log.debug("Unable to find LS Object");
        return;
    }
    cb.markReaderIndex();
    PcepObjectHeader tempObjHeader = PcepObjectHeader.read(cb);
    cb.resetReaderIndex();
    yObjClass = tempObjHeader.getObjClass();
    yObjType = tempObjHeader.getObjType();
    PcepLSObject lsObj;
    while ((yObjClass == PcepLSObjectVer1.LS_OBJ_CLASS) && ((yObjType == PcepLSObjectVer1.LS_OBJ_TYPE_NODE_VALUE) || (yObjType == PcepLSObjectVer1.LS_OBJ_TYPE_LINK_VALUE))) {
        lsObj = PcepLSObjectVer1.read(cb);
        llLSObjList.add(lsObj);
        if (cb.readableBytes() > OBJECT_HEADER_LENGTH) {
            cb.markReaderIndex();
            tempObjHeader = PcepObjectHeader.read(cb);
            cb.resetReaderIndex();
            yObjClass = tempObjHeader.getObjClass();
            yObjType = tempObjHeader.getObjType();
        } else {
            break;
        }
    }
}
#method_after
public void parseLSList(ChannelBuffer cb) throws PcepParseException {
    byte yObjClass;
    byte yObjType;
    lsObjList = new LinkedList<>();
    // caller should verify for LS object
    if (cb.readableBytes() < OBJECT_HEADER_LENGTH) {
        log.debug("Unable to find LS Object");
        return;
    }
    cb.markReaderIndex();
    PcepObjectHeader tempObjHeader = PcepObjectHeader.read(cb);
    cb.resetReaderIndex();
    yObjClass = tempObjHeader.getObjClass();
    yObjType = tempObjHeader.getObjType();
    PcepLSObject lsObj;
    while ((yObjClass == PcepLSObjectVer1.LS_OBJ_CLASS) && ((yObjType == PcepLSObjectVer1.LS_OBJ_TYPE_NODE_VALUE) || (yObjType == PcepLSObjectVer1.LS_OBJ_TYPE_LINK_VALUE))) {
        lsObj = PcepLSObjectVer1.read(cb);
        lsObjList.add(lsObj);
        if (cb.readableBytes() > OBJECT_HEADER_LENGTH) {
            cb.markReaderIndex();
            tempObjHeader = PcepObjectHeader.read(cb);
            cb.resetReaderIndex();
            yObjClass = tempObjHeader.getObjClass();
            yObjType = tempObjHeader.getObjType();
        } else {
            break;
        }
    }
}
#end_block

#method_before
public void parseErrObjList(ChannelBuffer cb) throws PcepParseException {
    byte yObjClass;
    byte yObjType;
    boolean bIsErrorObjFound = false;
    llErrObjList = new LinkedList<>();
    // caller should verify for RP object
    if (cb.readableBytes() < OBJECT_HEADER_LENGTH) {
        throw new PcepParseException("Unable to find PCEP-ERROR Object");
    }
    cb.markReaderIndex();
    PcepObjectHeader tempObjHeader = PcepObjectHeader.read(cb);
    cb.resetReaderIndex();
    yObjClass = tempObjHeader.getObjClass();
    yObjType = tempObjHeader.getObjType();
    PcepErrorObject errorObject;
    while ((yObjClass == PcepErrorObjectVer1.ERROR_OBJ_CLASS) && (yObjType == PcepErrorObjectVer1.ERROR_OBJ_TYPE)) {
        errorObject = PcepErrorObjectVer1.read(cb);
        llErrObjList.add(errorObject);
        bIsErrorObjFound = true;
        if (cb.readableBytes() > OBJECT_HEADER_LENGTH) {
            cb.markReaderIndex();
            tempObjHeader = PcepObjectHeader.read(cb);
            cb.resetReaderIndex();
            yObjClass = tempObjHeader.getObjClass();
            yObjType = tempObjHeader.getObjType();
        } else {
            break;
        }
    }
    if (!bIsErrorObjFound) {
        throw new PcepParseException("At least one PCEP-ERROR Object should be present.");
    }
}
#method_after
public void parseErrObjList(ChannelBuffer cb) throws PcepParseException {
    byte yObjClass;
    byte yObjType;
    boolean bIsErrorObjFound = false;
    errObjList = new LinkedList<>();
    // caller should verify for RP object
    if (cb.readableBytes() < OBJECT_HEADER_LENGTH) {
        throw new PcepParseException("Unable to find PCEP-ERROR Object");
    }
    cb.markReaderIndex();
    PcepObjectHeader tempObjHeader = PcepObjectHeader.read(cb);
    cb.resetReaderIndex();
    yObjClass = tempObjHeader.getObjClass();
    yObjType = tempObjHeader.getObjType();
    PcepErrorObject errorObject;
    while ((yObjClass == PcepErrorObjectVer1.ERROR_OBJ_CLASS) && (yObjType == PcepErrorObjectVer1.ERROR_OBJ_TYPE)) {
        errorObject = PcepErrorObjectVer1.read(cb);
        errObjList.add(errorObject);
        bIsErrorObjFound = true;
        if (cb.readableBytes() > OBJECT_HEADER_LENGTH) {
            cb.markReaderIndex();
            tempObjHeader = PcepObjectHeader.read(cb);
            cb.resetReaderIndex();
            yObjClass = tempObjHeader.getObjClass();
            yObjType = tempObjHeader.getObjType();
        } else {
            break;
        }
    }
    if (!bIsErrorObjFound) {
        throw new PcepParseException("At least one PCEP-ERROR Object should be present.");
    }
}
#end_block

#method_before
@Override
public int write(ChannelBuffer cb) throws PcepParseException {
    int iLenStartIndex = cb.writerIndex();
    // RPlist is optional
    if (this.isErroInfoSet) {
        ListIterator<PcepRPObject> rpObjlistIterator = this.llRPObjList.listIterator();
        while (rpObjlistIterator.hasNext()) {
            rpObjlistIterator.next().write(cb);
        }
    }
    // LSlist is optional
    if (this.isLSObjListSet) {
        ListIterator<PcepLSObject> teObjlistIterator = this.llLSObjList.listIterator();
        while (teObjlistIterator.hasNext()) {
            teObjlistIterator.next().write(cb);
        }
    }
    // ErrList is mandatory
    ListIterator<PcepErrorObject> errlistIterator = this.llErrObjList.listIterator();
    while (errlistIterator.hasNext()) {
        errlistIterator.next().write(cb);
    }
    return cb.writerIndex() - iLenStartIndex;
}
#method_after
@Override
public int write(ChannelBuffer cb) throws PcepParseException {
    int iLenStartIndex = cb.writerIndex();
    // RPlist is optional
    if (this.isErroInfoSet) {
        ListIterator<PcepRPObject> rpObjlistIterator = this.rpObjList.listIterator();
        while (rpObjlistIterator.hasNext()) {
            rpObjlistIterator.next().write(cb);
        }
    }
    // LSlist is optional
    if (this.isLSObjListSet) {
        ListIterator<PcepLSObject> teObjlistIterator = this.lsObjList.listIterator();
        while (teObjlistIterator.hasNext()) {
            teObjlistIterator.next().write(cb);
        }
    }
    // ErrList is mandatory
    ListIterator<PcepErrorObject> errlistIterator = this.errObjList.listIterator();
    while (errlistIterator.hasNext()) {
        errlistIterator.next().write(cb);
    }
    return cb.writerIndex() - iLenStartIndex;
}
#end_block

#method_before
@Override
public PcepError build() {
    return new PcepErrorVer1(llRPObjList, llLSObjList, llErrObjList);
}
#method_after
@Override
public PcepError build() {
    return new PcepErrorVer1(rpObjList, lsObjList, errObjList);
}
#end_block

#method_before
@Override
public List<PcepRPObject> getRPObjList() {
    return this.llRPObjList;
}
#method_after
@Override
public List<PcepRPObject> getRPObjList() {
    return this.rpObjList;
}
#end_block

#method_before
@Override
public Builder setRPObjList(List<PcepRPObject> llRPObjList) {
    this.llRPObjList = llRPObjList;
    return this;
}
#method_after
@Override
public Builder setRPObjList(List<PcepRPObject> rpObjList) {
    this.rpObjList = rpObjList;
    return this;
}
#end_block

#method_before
@Override
public List<PcepLSObject> getLSObjList() {
    return this.llLSObjList;
}
#method_after
@Override
public List<PcepLSObject> getLSObjList() {
    return this.lsObjList;
}
#end_block

#method_before
@Override
public Builder setLSObjList(List<PcepLSObject> llLSObjList) {
    this.llLSObjList = llLSObjList;
    return this;
}
#method_after
@Override
public Builder setLSObjList(List<PcepLSObject> lsObjList) {
    this.lsObjList = lsObjList;
    return this;
}
#end_block

#method_before
@Override
public List<PcepErrorObject> getErrorObjList() {
    return this.llErrObjList;
}
#method_after
@Override
public List<PcepErrorObject> getErrorObjList() {
    return this.errObjList;
}
#end_block

#method_before
@Override
public Builder setErrorObjList(List<PcepErrorObject> llErrObjList) {
    this.llErrObjList = llErrObjList;
    return this;
}
#method_after
@Override
public Builder setErrorObjList(List<PcepErrorObject> errObjList) {
    this.errObjList = errObjList;
    return this;
}
#end_block

#method_before
@Override
public void setRPObjList(List<PcepRPObject> llRPObjList) {
    this.llRPObjList = llRPObjList;
}
#method_after
@Override
public void setRPObjList(List<PcepRPObject> rpObjList) {
    this.rpObjList = rpObjList;
}
#end_block

#method_before
@Override
public void setLSObjList(List<PcepLSObject> llLSObjList) {
    this.llLSObjList = llLSObjList;
}
#method_after
@Override
public void setLSObjList(List<PcepLSObject> lsObjList) {
    this.lsObjList = lsObjList;
}
#end_block

#method_before
@Override
public void setErrorObjList(List<PcepErrorObject> llErrObjList) {
    this.llErrObjList = llErrObjList;
}
#method_after
@Override
public void setErrorObjList(List<PcepErrorObject> errObjList) {
    this.errObjList = errObjList;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().add("RpObjectList", llRPObjList).add("LsObjectList", llLSObjList).add("ErrorObjectList", llErrObjList).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().add("RpObjectList", rpObjList).add("LsObjectList", lsObjList).add("ErrorObjectList", errObjList).toString();
}
#end_block

#method_before
@Override
public LinkedList<PcepValueType> getSubObjects() {
    return this.llSubObjects;
}
#method_after
@Override
public LinkedList<PcepValueType> getSubObjects() {
    return this.subObjectList;
}
#end_block

#method_before
@Override
public void setSubObjects(LinkedList<PcepValueType> llSubObjects) {
    this.llSubObjects = llSubObjects;
}
#method_after
@Override
public void setSubObjects(LinkedList<PcepValueType> subObjectList) {
    this.subObjectList = subObjectList;
}
#end_block

#method_before
public static PcepEroObject read(ChannelBuffer cb) throws PcepParseException {
    PcepObjectHeader eroObjHeader;
    LinkedList<PcepValueType> llSubObjects = new LinkedList<>();
    eroObjHeader = PcepObjectHeader.read(cb);
    if (eroObjHeader.getObjClass() != PcepEroObjectVer1.ERO_OBJ_CLASS) {
        log.debug("ErrorType:" + PcepErrorDetailInfo.ERROR_TYPE_6 + " ErrorValue:" + PcepErrorDetailInfo.ERROR_VALUE_9);
        throw new PcepParseException(PcepErrorDetailInfo.ERROR_TYPE_6, PcepErrorDetailInfo.ERROR_VALUE_9);
    }
    if (eroObjHeader.getObjLen() > OBJECT_HEADER_LENGTH) {
        ChannelBuffer tempCb = cb.readBytes(eroObjHeader.getObjLen() - OBJECT_HEADER_LENGTH);
        llSubObjects = parseSubObjects(tempCb);
    }
    return new PcepEroObjectVer1(eroObjHeader, llSubObjects);
}
#method_after
public static PcepEroObject read(ChannelBuffer cb) throws PcepParseException {
    PcepObjectHeader eroObjHeader;
    LinkedList<PcepValueType> subObjectList = new LinkedList<>();
    eroObjHeader = PcepObjectHeader.read(cb);
    if (eroObjHeader.getObjClass() != PcepEroObjectVer1.ERO_OBJ_CLASS) {
        log.debug("ErrorType:" + PcepErrorDetailInfo.ERROR_TYPE_6 + " ErrorValue:" + PcepErrorDetailInfo.ERROR_VALUE_9);
        throw new PcepParseException(PcepErrorDetailInfo.ERROR_TYPE_6, PcepErrorDetailInfo.ERROR_VALUE_9);
    }
    if (eroObjHeader.getObjLen() > OBJECT_HEADER_LENGTH) {
        ChannelBuffer tempCb = cb.readBytes(eroObjHeader.getObjLen() - OBJECT_HEADER_LENGTH);
        subObjectList = parseSubObjects(tempCb);
    }
    return new PcepEroObjectVer1(eroObjHeader, subObjectList);
}
#end_block

#method_before
protected static LinkedList<PcepValueType> parseSubObjects(ChannelBuffer cb) throws PcepParseException {
    LinkedList<PcepValueType> llSubObjects = new LinkedList<>();
    while (0 < cb.readableBytes()) {
        // check the Type of the TLV
        short type = cb.readByte();
        type = (short) (type & (YTYPE_SHIFT_VALUE));
        byte hLength = cb.readByte();
        PcepValueType subObj;
        switch(type) {
            case IPv4SubObject.TYPE:
                subObj = IPv4SubObject.read(cb);
                break;
            case IPv6SubObject.TYPE:
                byte[] ipv6Value = new byte[IPv6SubObject.VALUE_LENGTH];
                cb.readBytes(ipv6Value, 0, IPv6SubObject.VALUE_LENGTH);
                subObj = new IPv6SubObject(ipv6Value);
                break;
            case AutonomousSystemNumberSubObject.TYPE:
                subObj = AutonomousSystemNumberSubObject.read(cb);
                break;
            case PathKeySubObject.TYPE:
                subObj = PathKeySubObject.read(cb);
                break;
            case SrEroSubObject.TYPE:
                subObj = SrEroSubObject.read(cb);
                break;
            default:
                throw new PcepParseException("Unexpected sub object. Type: " + (int) type);
        }
        // Check for the padding
        int pad = hLength % 4;
        if (0 < pad) {
            pad = 4 - pad;
            if (pad <= cb.readableBytes()) {
                cb.skipBytes(pad);
            }
        }
        llSubObjects.add(subObj);
    }
    if (0 < cb.readableBytes()) {
        throw new PcepParseException("Subobject parsing error. Extra bytes received.");
    }
    return llSubObjects;
}
#method_after
protected static LinkedList<PcepValueType> parseSubObjects(ChannelBuffer cb) throws PcepParseException {
    LinkedList<PcepValueType> subObjectList = new LinkedList<>();
    while (0 < cb.readableBytes()) {
        // check the Type of the TLV
        short type = cb.readByte();
        type = (short) (type & (TYPE_SHIFT_VALUE));
        byte hLength = cb.readByte();
        PcepValueType subObj;
        switch(type) {
            case IPv4SubObject.TYPE:
                subObj = IPv4SubObject.read(cb);
                break;
            case IPv6SubObject.TYPE:
                byte[] ipv6Value = new byte[IPv6SubObject.VALUE_LENGTH];
                cb.readBytes(ipv6Value, 0, IPv6SubObject.VALUE_LENGTH);
                subObj = new IPv6SubObject(ipv6Value);
                break;
            case AutonomousSystemNumberSubObject.TYPE:
                subObj = AutonomousSystemNumberSubObject.read(cb);
                break;
            case PathKeySubObject.TYPE:
                subObj = PathKeySubObject.read(cb);
                break;
            case SrEroSubObject.TYPE:
                subObj = SrEroSubObject.read(cb);
                break;
            default:
                throw new PcepParseException("Unexpected sub object. Type: " + (int) type);
        }
        // Check for the padding
        int pad = hLength % 4;
        if (0 < pad) {
            pad = 4 - pad;
            if (pad <= cb.readableBytes()) {
                cb.skipBytes(pad);
            }
        }
        subObjectList.add(subObj);
    }
    if (0 < cb.readableBytes()) {
        throw new PcepParseException("Subobject parsing error. Extra bytes received.");
    }
    return subObjectList;
}
#end_block

#method_before
@Override
public int write(ChannelBuffer cb) throws PcepParseException {
    // write Object header
    int objStartIndex = cb.writerIndex();
    int objLenIndex = eroObjHeader.write(cb);
    if (objLenIndex <= 0) {
        throw new PcepParseException("Failed to write ERO object header. Index " + objLenIndex);
    }
    ListIterator<PcepValueType> listIterator = llSubObjects.listIterator();
    while (listIterator.hasNext()) {
        listIterator.next().write(cb);
    }
    // Update object length now
    int length = cb.writerIndex() - objStartIndex;
    cb.setShort(objLenIndex, (short) length);
    // will be helpful during print().
    eroObjHeader.setObjLen((short) length);
    // As per RFC the length of object should be multiples of 4
    int pad = length % 4;
    if (pad != 0) {
        pad = 4 - pad;
        for (int i = 0; i < pad; i++) {
            cb.writeByte((byte) 0);
        }
        length = length + pad;
    }
    objLenIndex = cb.writerIndex();
    return objLenIndex;
}
#method_after
@Override
public int write(ChannelBuffer cb) throws PcepParseException {
    // write Object header
    int objStartIndex = cb.writerIndex();
    int objLenIndex = eroObjHeader.write(cb);
    if (objLenIndex <= 0) {
        throw new PcepParseException("Failed to write ERO object header. Index " + objLenIndex);
    }
    ListIterator<PcepValueType> listIterator = subObjectList.listIterator();
    while (listIterator.hasNext()) {
        listIterator.next().write(cb);
    }
    // Update object length now
    int length = cb.writerIndex() - objStartIndex;
    cb.setShort(objLenIndex, (short) length);
    // will be helpful during print().
    eroObjHeader.setObjLen((short) length);
    // As per RFC the length of object should be multiples of 4
    int pad = length % 4;
    if (pad != 0) {
        pad = 4 - pad;
        for (int i = 0; i < pad; i++) {
            cb.writeByte((byte) 0);
        }
        length = length + pad;
    }
    objLenIndex = cb.writerIndex();
    return objLenIndex;
}
#end_block

#method_before
@Override
public PcepEroObject build() {
    PcepObjectHeader eroObjHeader = this.bIsHeaderSet ? this.eroObjHeader : DEFAULT_ERO_OBJECT_HEADER;
    if (bIsPFlagSet) {
        eroObjHeader.setPFlag(bPFlag);
    }
    if (bIsIFlagSet) {
        eroObjHeader.setIFlag(bIFlag);
    }
    return new PcepEroObjectVer1(eroObjHeader, this.llSubObjects);
}
#method_after
@Override
public PcepEroObject build() {
    PcepObjectHeader eroObjHeader = this.bIsHeaderSet ? this.eroObjHeader : DEFAULT_ERO_OBJECT_HEADER;
    if (bIsPFlagSet) {
        eroObjHeader.setPFlag(bPFlag);
    }
    if (bIsIFlagSet) {
        eroObjHeader.setIFlag(bIFlag);
    }
    return new PcepEroObjectVer1(eroObjHeader, this.subObjectList);
}
#end_block

#method_before
@Override
public LinkedList<PcepValueType> getSubObjects() {
    return this.llSubObjects;
}
#method_after
@Override
public LinkedList<PcepValueType> getSubObjects() {
    return this.subObjectList;
}
#end_block

#method_before
@Override
public Builder setSubObjects(LinkedList<PcepValueType> llSubObjects) {
    this.llSubObjects = llSubObjects;
    return this;
}
#method_after
@Override
public Builder setSubObjects(LinkedList<PcepValueType> subObjectList) {
    this.subObjectList = subObjectList;
    return this;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("EroObjHeader", eroObjHeader).add("SubObjects", llSubObjects).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().add("EroObjHeader", eroObjHeader).add("SubObjects", subObjectList).toString();
}
#end_block

#method_before
@Test
public void errorMessageTest1() throws PcepParseException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x34, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // OPEN object header
    0x00, // OPEN object header
    0x00, // OPEN object header
    0x01, // OPEN object header
    0x01, // OPEN object header
    0x01, // OPEN object header
    0x10, // OPEN object header
    0x00, // OPEN object header
    0x28, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // LS Capability TLV
    0x00, // LS Capability TLV
    0x00, // LS Capability TLV
    0x00, // LS Capability TLV
    0x03, // LS Capability TLV
    (byte) 0xFF, // LS Capability TLV
    (byte) 0x00, // LS Capability TLV
    0x00, // LS Capability TLV
    0x04, 0x00, 0x00, 0x00, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#method_after
@Test
public void errorMessageTest1() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x34, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // OPEN object header
    0x00, // OPEN object header
    0x00, // OPEN object header
    0x01, // OPEN object header
    0x01, // OPEN object header
    0x01, // OPEN object header
    0x10, // OPEN object header
    0x00, // OPEN object header
    0x28, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // LS Capability TLV
    0x00, // LS Capability TLV
    0x00, // LS Capability TLV
    0x00, // LS Capability TLV
    0x03, // LS Capability TLV
    (byte) 0xFF, // LS Capability TLV
    (byte) 0x00, // LS Capability TLV
    0x00, // LS Capability TLV
    0x04, 0x00, 0x00, 0x00, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#end_block

#method_before
@Test
public void errorMessageTest2() throws PcepParseException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x3C, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x01, // PCERR Object Header
    0x01, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // OPEN object header
    0x00, // OPEN object header
    0x00, // OPEN object header
    0x01, // OPEN object header
    0x03, // OPEN object header
    0x01, // OPEN object header
    0x10, // OPEN object header
    0x00, // OPEN object header
    0x28, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // LS Capability TLV
    0x00, // LS Capability TLV
    0x00, // LS Capability TLV
    0x00, // LS Capability TLV
    0x03, // LS Capability TLV
    (byte) 0xFF, // LS Capability TLV
    (byte) 0x00, // LS Capability TLV
    0x00, // LS Capability TLV
    0x04, 0x00, 0x00, 0x00, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#method_after
@Test
public void errorMessageTest2() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x3C, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x01, // PCERR Object Header
    0x01, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // OPEN object header
    0x00, // OPEN object header
    0x00, // OPEN object header
    0x01, // OPEN object header
    0x03, // OPEN object header
    0x01, // OPEN object header
    0x10, // OPEN object header
    0x00, // OPEN object header
    0x28, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // LS Capability TLV
    0x00, // LS Capability TLV
    0x00, // LS Capability TLV
    0x00, // LS Capability TLV
    0x03, // LS Capability TLV
    (byte) 0xFF, // LS Capability TLV
    (byte) 0x00, // LS Capability TLV
    0x00, // LS Capability TLV
    0x04, 0x00, 0x00, 0x00, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#end_block

#method_before
@Test
public void errorMessageTest3() throws PcepParseException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x34, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x01, // PCERR Object Header
    0x01, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // OPEN object header
    0x00, // OPEN object header
    0x00, // OPEN object header
    0x01, // OPEN object header
    0x03, // OPEN object header
    0x01, // OPEN object header
    0x10, // OPEN object header
    0x00, // OPEN object header
    0x20, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, 0x00, 0x00, 0x00, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#method_after
@Test
public void errorMessageTest3() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x34, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x01, // PCERR Object Header
    0x01, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // OPEN object header
    0x00, // OPEN object header
    0x00, // OPEN object header
    0x01, // OPEN object header
    0x03, // OPEN object header
    0x01, // OPEN object header
    0x10, // OPEN object header
    0x00, // OPEN object header
    0x20, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, 0x00, 0x00, 0x00, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#end_block

#method_before
@Test
public void errorMessageTest4() throws PcepParseException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x2c, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x01, // PCERR Object Header
    0x01, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // OPEN object header
    0x00, // OPEN object header
    0x00, // OPEN object header
    0x01, // OPEN object header
    0x03, // OPEN object header
    0x01, // OPEN object header
    0x10, // OPEN object header
    0x00, // OPEN object header
    0x18, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, 0x00, 0x00, 0x00, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#method_after
@Test
public void errorMessageTest4() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x2c, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x01, // PCERR Object Header
    0x01, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // OPEN object header
    0x00, // OPEN object header
    0x00, // OPEN object header
    0x01, // OPEN object header
    0x03, // OPEN object header
    0x01, // OPEN object header
    0x10, // OPEN object header
    0x00, // OPEN object header
    0x18, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, 0x00, 0x00, 0x00, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#end_block

#method_before
@Test
public void errorMessageTest5() throws PcepParseException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x24, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x01, // PCERR Object Header
    0x01, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // OPEN object header
    0x00, // OPEN object header
    0x00, // OPEN object header
    0x01, // OPEN object header
    0x03, // OPEN object header
    0x01, // OPEN object header
    0x10, // OPEN object header
    0x00, // OPEN object header
    0x10, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, 0x00, 0x00, 0x00, 0x05 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#method_after
@Test
public void errorMessageTest5() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x24, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x01, // PCERR Object Header
    0x01, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // OPEN object header
    0x00, // OPEN object header
    0x00, // OPEN object header
    0x01, // OPEN object header
    0x03, // OPEN object header
    0x01, // OPEN object header
    0x10, // OPEN object header
    0x00, // OPEN object header
    0x10, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, 0x00, 0x00, 0x00, 0x05 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#end_block

#method_before
@Test
public void errorMessageTest6() throws PcepParseException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x1C, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x01, // PCERR Object Header
    0x01, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // OPEN object header
    0x00, // OPEN object header
    0x00, // OPEN object header
    0x01, // OPEN object header
    0x03, // OPEN object header
    0x01, // OPEN object header
    0x10, // OPEN object header
    0x00, // OPEN object header
    0x08, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#method_after
@Test
public void errorMessageTest6() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x1C, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x01, // PCERR Object Header
    0x01, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // OPEN object header
    0x00, // OPEN object header
    0x00, // OPEN object header
    0x01, // OPEN object header
    0x03, // OPEN object header
    0x01, // OPEN object header
    0x10, // OPEN object header
    0x00, // OPEN object header
    0x08, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#end_block

#method_before
@Test
public void errorMessageTest7() throws PcepParseException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x14, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // OPEN object header
    0x00, // OPEN object header
    0x00, // OPEN object header
    0x01, // OPEN object header
    0x01, // OPEN object header
    0x01, // OPEN object header
    0x10, // OPEN object header
    0x00, // OPEN object header
    0x08, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#method_after
@Test
public void errorMessageTest7() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x14, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // OPEN object header
    0x00, // OPEN object header
    0x00, // OPEN object header
    0x01, // OPEN object header
    0x01, // OPEN object header
    0x01, // OPEN object header
    0x10, // OPEN object header
    0x00, // OPEN object header
    0x08, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#end_block

#method_before
@Test
public void errorMessageTest8() throws PcepParseException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x20, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x01, // RP Object Header
    0x01, // RP Object Header
    0x02, // RP Object Header
    0x10, // RP Object Header
    0x00, // RP Object Header
    0x0C, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x03, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, 0x00, 0x00, 0x01, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#method_after
@Test
public void errorMessageTest8() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x20, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x01, // RP Object Header
    0x01, // RP Object Header
    0x02, // RP Object Header
    0x10, // RP Object Header
    0x00, // RP Object Header
    0x0C, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x03, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, 0x00, 0x00, 0x01, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#end_block

#method_before
@Test
public void errorMessageTest9() throws PcepParseException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x14, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x01, // PCEP-ERROR Object Header
    0x01, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, 0x00, 0x00, 0x01, 0x01 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#method_after
@Test
public void errorMessageTest9() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x14, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x01, // PCEP-ERROR Object Header
    0x01, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, 0x00, 0x00, 0x01, 0x01 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#end_block

#method_before
@Test
public void errorMessageTest10() throws PcepParseException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x14, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x01, // PCEP-ERROR Object Header
    0x01, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, 0x00, 0x00, 0x01, 0x01 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#method_after
@Test
public void errorMessageTest10() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x14, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x01, // PCEP-ERROR Object Header
    0x01, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, 0x00, 0x00, 0x01, 0x01 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#end_block

#method_before
@Test
public void errorMessageTest11() throws PcepParseException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x1C, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x13, // LS Object Header
    0x00, // LS Object Header
    0x10, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, 0x00, 0x00, 0x00, 0x10, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, 0x00, 0x00, 0x01, 0x01 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#method_after
@Test
public void errorMessageTest11() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x1C, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x13, // LS Object Header
    0x00, // LS Object Header
    0x10, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, 0x00, 0x00, 0x00, 0x10, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, 0x00, 0x00, 0x01, 0x01 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#end_block

#method_before
@Test
public void errorMessageTest12() throws PcepParseException {
    // RP Object, PCEP-ERROR Object
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x18, // RP Object Header
    0x02, // RP Object Header
    0x10, // RP Object Header
    0x00, // RP Object Header
    0x0C, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x03, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, 0x00, 0x00, 0x01, 0x01 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#method_after
@Test
public void errorMessageTest12() throws PcepParseException, PcepOutOfBoundMessageException {
    // RP Object, PCEP-ERROR Object
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x18, // RP Object Header
    0x02, // RP Object Header
    0x10, // RP Object Header
    0x00, // RP Object Header
    0x0C, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x03, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, 0x00, 0x00, 0x01, 0x01 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#end_block

#method_before
@Test
public void errorMessageTest13() throws PcepParseException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x24, // RP Object Header
    0x02, // RP Object Header
    0x10, // RP Object Header
    0x00, // RP Object Header
    0x0C, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x03, // RP Object Header
    0x02, // RP Object Header
    0x10, // RP Object Header
    0x00, // RP Object Header
    0x0C, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x04, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, 0x00, 0x00, 0x01, 0x01 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#method_after
@Test
public void errorMessageTest13() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x24, // RP Object Header
    0x02, // RP Object Header
    0x10, // RP Object Header
    0x00, // RP Object Header
    0x0C, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x03, // RP Object Header
    0x02, // RP Object Header
    0x10, // RP Object Header
    0x00, // RP Object Header
    0x0C, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x04, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, 0x00, 0x00, 0x01, 0x01 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#end_block

#method_before
@Test
public void errorMessageTest14() throws PcepParseException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x2C, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x10, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x10, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, 0x00, 0x00, 0x01, 0x01 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#method_after
@Test
public void errorMessageTest14() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x2C, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x10, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x10, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, 0x00, 0x00, 0x01, 0x01 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#end_block

#method_before
@Test
public void errorMessageTest15() throws PcepParseException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x24, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, 0x00, 0x00, 0x01, 0x01, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x10, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, 0x00, 0x00, 0x01, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#method_after
@Test
public void errorMessageTest15() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x24, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, 0x00, 0x00, 0x01, 0x01, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x10, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, 0x00, 0x00, 0x01, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#end_block

#method_before
@Test
public void errorMessageTest16() throws PcepParseException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x2C, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x01, // RP Object Header
    0x01, // RP Object Header
    0x02, // RP Object Header
    0x10, // RP Object Header
    0x00, // RP Object Header
    0x0C, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x03, // RP Object Header
    0x02, // RP Object Header
    0x10, // RP Object Header
    0x00, // RP Object Header
    0x0C, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x04, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, 0x00, 0x00, 0x01, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#method_after
@Test
public void errorMessageTest16() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x2C, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x01, // RP Object Header
    0x01, // RP Object Header
    0x02, // RP Object Header
    0x10, // RP Object Header
    0x00, // RP Object Header
    0x0C, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x03, // RP Object Header
    0x02, // RP Object Header
    0x10, // RP Object Header
    0x00, // RP Object Header
    0x0C, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x04, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, 0x00, 0x00, 0x01, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#end_block

#method_before
@Test
public void errorMessageTest17() throws PcepParseException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x34, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, 0x00, 0x00, 0x01, 0x01, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x10, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x10, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, 0x00, 0x00, 0x01, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#method_after
@Test
public void errorMessageTest17() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x34, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, 0x00, 0x00, 0x01, 0x01, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x10, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x10, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, 0x00, 0x00, 0x01, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#end_block

#method_before
@Test
public void errorMessageTest18() throws PcepParseException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x3C, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x01, // PCEP-ERROR Object Header
    0x01, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x01, // RP Object Header
    0x03, // RP Object Header
    0x02, // RP Object Header
    0x10, // RP Object Header
    0x00, // RP Object Header
    0x0C, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x03, // RP Object Header
    0x02, // RP Object Header
    0x10, // RP Object Header
    0x00, // RP Object Header
    0x0C, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x04, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x01, // PCEP-ERROR Object Header
    0x04, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, 0x00, 0x00, 0x01, 0x06 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#method_after
@Test
public void errorMessageTest18() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x3C, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x01, // PCEP-ERROR Object Header
    0x01, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x01, // RP Object Header
    0x03, // RP Object Header
    0x02, // RP Object Header
    0x10, // RP Object Header
    0x00, // RP Object Header
    0x0C, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x03, // RP Object Header
    0x02, // RP Object Header
    0x10, // RP Object Header
    0x00, // RP Object Header
    0x0C, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x04, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x01, // PCEP-ERROR Object Header
    0x04, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, 0x00, 0x00, 0x01, 0x06 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#end_block

#method_before
@Test
public void errorMessageTest19() throws PcepParseException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x44, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, 0x00, 0x00, 0x01, 0x01, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, 0x00, 0x00, 0x01, 0x03, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x10, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x10, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x01, // PCERR Object Header
    0x04, 0x0D, 0x10, 0x00, 0x08, 0x00, 0x00, 0x01, 0x06 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#method_after
@Test
public void errorMessageTest19() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x44, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, 0x00, 0x00, 0x01, 0x01, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, 0x00, 0x00, 0x01, 0x03, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x10, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x10, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x01, // PCERR Object Header
    0x04, 0x0D, 0x10, 0x00, 0x08, 0x00, 0x00, 0x01, 0x06 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#end_block

#method_before
@Test
public void errorMessageTest20() throws PcepParseException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x4C, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x01, // RP Object Header
    0x01, // RP Object Header
    0x02, // RP Object Header
    0x10, // RP Object Header
    0x00, // RP Object Header
    0x0C, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x03, // RP Object Header
    0x02, // RP Object Header
    0x10, // RP Object Header
    0x00, // RP Object Header
    0x0C, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x04, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x01, // PCERR Object Header
    0x04, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // LS Object Header
    0x00, // LS Object Header
    0x00, // LS Object Header
    0x01, // LS Object Header
    0x06, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x10, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, 0x00, 0x00, 0x01, 0x06 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#method_after
@Test
public void errorMessageTest20() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] errorMsg = new byte[] { // common header
    0x20, // common header
    0x06, // common header
    0x00, // common header
    0x4C, // PCEP-ERROR Object Header
    0x0D, // PCEP-ERROR Object Header
    0x10, // PCEP-ERROR Object Header
    0x00, // PCEP-ERROR Object Header
    0x08, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x01, // RP Object Header
    0x01, // RP Object Header
    0x02, // RP Object Header
    0x10, // RP Object Header
    0x00, // RP Object Header
    0x0C, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x00, // RP Object Header
    0x03, // RP Object Header
    0x02, // RP Object Header
    0x10, // RP Object Header
    0x00, // RP Object Header
    0x0C, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x04, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // PCERR Object Header
    0x00, // PCERR Object Header
    0x00, // PCERR Object Header
    0x01, // PCERR Object Header
    0x04, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, // LS Object Header
    0x00, // LS Object Header
    0x00, // LS Object Header
    0x01, // LS Object Header
    0x06, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x10, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // PCERR Object Header
    0x0D, // PCERR Object Header
    0x10, // PCERR Object Header
    0x00, // PCERR Object Header
    0x08, 0x00, 0x00, 0x01, 0x06 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(errorMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testErrorMsg = { 0 };
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    assertThat(message, instanceOf(PcepErrorMsg.class));
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testErrorMsg = new byte[iReadLen];
    buf.readBytes(testErrorMsg, 0, iReadLen);
    assertThat(testErrorMsg, is(errorMsg));
}
#end_block

#method_before
@Test
public void labelUpdateMessageTest1() throws PcepParseException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    (byte) 0xE2, // common header
    0x00, // common header
    0x24, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    assertThat(message, instanceOf(PcepLabelUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    assertThat(testLabelUpdateMsg, is(labelUpdate));
}
#method_after
@Test
public void labelUpdateMessageTest1() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    (byte) 0xE2, // common header
    0x00, // common header
    0x24, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    assertThat(message, instanceOf(PcepLabelUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    assertThat(testLabelUpdateMsg, is(labelUpdate));
}
#end_block

#method_before
@Test
public void labelUpdateMessageTest2() throws PcepParseException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    (byte) 0xE2, // common header
    0x00, // common header
    0x30, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    assertThat(message, instanceOf(PcepLabelUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    assertThat(testLabelUpdateMsg, is(labelUpdate));
}
#method_after
@Test
public void labelUpdateMessageTest2() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    (byte) 0xE2, // common header
    0x00, // common header
    0x30, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    assertThat(message, instanceOf(PcepLabelUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    assertThat(testLabelUpdateMsg, is(labelUpdate));
}
#end_block

#method_before
@Test
public void labelUpdateMessageTest3() throws PcepParseException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    (byte) 0xE2, // common header
    0x00, // common header
    0x24, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    (byte) 0xE2, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0B, 0x0B };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    assertThat(message, instanceOf(PcepLabelUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    assertThat(testLabelUpdateMsg, is(labelUpdate));
}
#method_after
@Test
public void labelUpdateMessageTest3() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    (byte) 0xE2, // common header
    0x00, // common header
    0x24, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    (byte) 0xE2, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0B, 0x0B };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    assertThat(message, instanceOf(PcepLabelUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    assertThat(testLabelUpdateMsg, is(labelUpdate));
}
#end_block

#method_before
@Test
public void labelUpdateMessageTest4() throws PcepParseException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    (byte) 0xE2, // common header
    0x00, // common header
    0x50, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x02, 0x00, 0x00, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    assertThat(message, instanceOf(PcepLabelUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    assertThat(testLabelUpdateMsg, is(labelUpdate));
}
#method_after
@Test
public void labelUpdateMessageTest4() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    (byte) 0xE2, // common header
    0x00, // common header
    0x50, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x02, 0x00, 0x00, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    assertThat(message, instanceOf(PcepLabelUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    assertThat(testLabelUpdateMsg, is(labelUpdate));
}
#end_block

#method_before
@Test
public void labelUpdateMessageTest5() throws PcepParseException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    (byte) 0xE2, // common header
    0x00, // common header
    0x44, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    (byte) 0xE2, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0B, 0x0B, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    (byte) 0xE2, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0C, 0x0C };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    assertThat(message, instanceOf(PcepLabelUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    assertThat(testLabelUpdateMsg, is(labelUpdate));
}
#method_after
@Test
public void labelUpdateMessageTest5() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    (byte) 0xE2, // common header
    0x00, // common header
    0x44, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    (byte) 0xE2, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0B, 0x0B, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    (byte) 0xE2, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0C, 0x0C };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    assertThat(message, instanceOf(PcepLabelUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    assertThat(testLabelUpdateMsg, is(labelUpdate));
}
#end_block

#method_before
@Test
public void labelUpdateMessageTest6() throws PcepParseException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    (byte) 0xE2, // common header
    0x00, // common header
    0x50, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    (byte) 0xE2, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0D, 0x0D };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    assertThat(message, instanceOf(PcepLabelUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    assertThat(testLabelUpdateMsg, is(labelUpdate));
}
#method_after
@Test
public void labelUpdateMessageTest6() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    (byte) 0xE2, // common header
    0x00, // common header
    0x50, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    (byte) 0xE2, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0D, 0x0D };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    assertThat(message, instanceOf(PcepLabelUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    assertThat(testLabelUpdateMsg, is(labelUpdate));
}
#end_block

#method_before
@Test
public void labelUpdateMessageTest7() throws PcepParseException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    (byte) 0xE2, // common header
    0x00, // common header
    0x50, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    (byte) 0xE2, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0D, 0x0D, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    assertThat(message, instanceOf(PcepLabelUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    assertThat(testLabelUpdateMsg, is(labelUpdate));
}
#method_after
@Test
public void labelUpdateMessageTest7() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    (byte) 0xE2, // common header
    0x00, // common header
    0x50, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    (byte) 0xE2, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0D, 0x0D, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    assertThat(message, instanceOf(PcepLabelUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    assertThat(testLabelUpdateMsg, is(labelUpdate));
}
#end_block

#method_before
@Test
public void labelUpdateMessageTest8() throws PcepParseException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    (byte) 0xE2, // common header
    0x00, // common header
    0x7C, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    (byte) 0xE2, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0D, 0x0D, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    assertThat(message, instanceOf(PcepLabelUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    assertThat(testLabelUpdateMsg, is(labelUpdate));
}
#method_after
@Test
public void labelUpdateMessageTest8() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    (byte) 0xE2, // common header
    0x00, // common header
    0x7C, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    (byte) 0xE2, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0D, 0x0D, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    (byte) 0xE1, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    assertThat(message, instanceOf(PcepLabelUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    assertThat(testLabelUpdateMsg, is(labelUpdate));
}
#end_block

#method_before
@Override
public String toString() {
    ToStringHelper toStrHelper = MoreObjects.toStringHelper(getClass());
    if ((errObjListWithOpen != null) && (errObjListWithOpen.isErrorObjListWithOpenPresent())) {
        toStrHelper.add("ErrorObjectListWithOpen", errObjListWithOpen);
    }
    if ((errInfo != null) && (errInfo.isErrorInfoPresent())) {
        toStrHelper.add("ErrorInfo", errInfo);
    }
    return toStrHelper.toString();
}
#method_after
@Override
public String toString() {
    ToStringHelper toStrHelper = MoreObjects.toStringHelper(getClass()).omitNullValues();
    if ((errObjListWithOpen != null) && (errObjListWithOpen.isErrorObjListWithOpenPresent())) {
        toStrHelper.add("ErrorObjectListWithOpen", errObjListWithOpen);
    }
    if ((errInfo != null) && (errInfo.isErrorInfoPresent())) {
        toStrHelper.add("ErrorInfo", errInfo);
    }
    return toStrHelper.toString();
}
#end_block

#method_before
@Override
public PcepMessage readFrom(ChannelBuffer cb) throws PcepParseException {
    if (cb.readableBytes() < MINIMUM_LENGTH) {
        throw new PcepParseException("Packet should have minimum length: " + MINIMUM_LENGTH);
    }
    try {
        int start = cb.readerIndex();
        // fixed value property version == 1
        byte version = cb.readByte();
        version = (byte) (version >> PcepMessageVer1.SHIFT_FLAG);
        if (version != (byte) PACKET_VERSION) {
            throw new PcepParseException("Wrong version. Expected=PcepVersion.Message_1(1), got=" + version);
        }
        byte type = cb.readByte();
        short length = cb.readShort();
        cb.readerIndex(start);
        if (type == (byte) PcepType.OPEN.getType()) {
            log.debug("OPEN MESSAGE is received");
            return PcepOpenMsgVer1.READER.readFrom(cb.readBytes(length));
        } else if (type == (byte) PcepType.KEEP_ALIVE.getType()) {
            log.debug("KEEPALIVE MESSAGE is received");
            return PcepKeepaliveMsgVer1.READER.readFrom(cb.readBytes(length));
        } else if (type == (byte) PcepType.ERROR.getType()) {
            log.debug("ERROR MESSAGE is received");
            return PcepErrorMsgVer1.READER.readFrom(cb.readBytes(length));
        } else if (type == (byte) PcepType.CLOSE.getType()) {
            log.debug("CLOSE MESSAGE is received");
            return PcepCloseMsgVer1.READER.readFrom(cb.readBytes(length));
        } else if (type == (byte) PcepType.REPORT.getType()) {
            log.debug("REPORT MESSAGE is received");
            return PcepReportMsgVer1.READER.readFrom(cb.readBytes(length));
        } else if (type == (byte) PcepType.UPDATE.getType()) {
            log.debug("UPDATE MESSAGE is received");
            return PcepUpdateMsgVer1.READER.readFrom(cb.readBytes(length));
        } else if (type == (byte) PcepType.INITIATE.getType()) {
            log.debug("INITIATE MESSAGE is received");
            return PcepInitiateMsgVer1.READER.readFrom(cb.readBytes(length));
        } else if (type == (byte) PcepType.LS_REPORT.getType()) {
            log.debug("LS REPORT MESSAGE is received");
            return PcepLSReportMsgVer1.READER.readFrom(cb.readBytes(length));
        } else if (type == (byte) PcepType.LABEL_RANGE_RESERV.getType()) {
            log.debug("LABEL RANGE RESERVE MESSAGE is received");
            return PcepLabelRangeResvMsgVer1.READER.readFrom(cb.readBytes(length));
        } else if (type == (byte) PcepType.LABEL_UPDATE.getType()) {
            log.debug("LABEL UPDATE MESSAGE is received");
            return PcepLabelUpdateMsgVer1.READER.readFrom(cb.readBytes(length));
        } else {
            throw new PcepParseException("ERROR: UNKNOWN MESSAGE is received. Msg Type: " + type);
        }
    } catch (IndexOutOfBoundsException e) {
        throw new PcepParseException(PcepErrorDetailInfo.ERROR_TYPE_1, PcepErrorDetailInfo.ERROR_VALUE_1);
    }
}
#method_after
@Override
public PcepMessage readFrom(ChannelBuffer cb) throws PcepParseException, PcepOutOfBoundMessageException {
    if (cb.readableBytes() < MINIMUM_LENGTH) {
        throw new PcepParseException("Packet should have minimum length: " + MINIMUM_LENGTH);
    }
    try {
        int start = cb.readerIndex();
        // fixed value property version == 1
        byte version = cb.readByte();
        version = (byte) (version >> PcepMessageVer1.SHIFT_FLAG);
        if (version != (byte) PACKET_VERSION) {
            throw new PcepParseException("Wrong version. Expected=PcepVersion.Message_1(1), got=" + version);
        }
        byte type = cb.readByte();
        short length = cb.readShort();
        cb.readerIndex(start);
        // If the message is out-of-bound then throw PcepOutOfBoundException.
        if ((length - MINIMUM_COMMON_HEADER_LENGTH) > cb.readableBytes()) {
            throw new PcepOutOfBoundMessageException("Message is out-of-bound.");
        }
        if (type == (byte) PcepType.OPEN.getType()) {
            log.debug("OPEN MESSAGE is received");
            return PcepOpenMsgVer1.READER.readFrom(cb.readBytes(length));
        } else if (type == (byte) PcepType.KEEP_ALIVE.getType()) {
            log.debug("KEEPALIVE MESSAGE is received");
            return PcepKeepaliveMsgVer1.READER.readFrom(cb.readBytes(length));
        } else if (type == (byte) PcepType.ERROR.getType()) {
            log.debug("ERROR MESSAGE is received");
            return PcepErrorMsgVer1.READER.readFrom(cb.readBytes(length));
        } else if (type == (byte) PcepType.CLOSE.getType()) {
            log.debug("CLOSE MESSAGE is received");
            return PcepCloseMsgVer1.READER.readFrom(cb.readBytes(length));
        } else if (type == (byte) PcepType.REPORT.getType()) {
            log.debug("REPORT MESSAGE is received");
            return PcepReportMsgVer1.READER.readFrom(cb.readBytes(length));
        } else if (type == (byte) PcepType.UPDATE.getType()) {
            log.debug("UPDATE MESSAGE is received");
            return PcepUpdateMsgVer1.READER.readFrom(cb.readBytes(length));
        } else if (type == (byte) PcepType.INITIATE.getType()) {
            log.debug("INITIATE MESSAGE is received");
            return PcepInitiateMsgVer1.READER.readFrom(cb.readBytes(length));
        } else if (type == (byte) PcepType.LS_REPORT.getType()) {
            log.debug("LS REPORT MESSAGE is received");
            return PcepLSReportMsgVer1.READER.readFrom(cb.readBytes(length));
        } else if (type == (byte) PcepType.LABEL_RANGE_RESERV.getType()) {
            log.debug("LABEL RANGE RESERVE MESSAGE is received");
            return PcepLabelRangeResvMsgVer1.READER.readFrom(cb.readBytes(length));
        } else if (type == (byte) PcepType.LABEL_UPDATE.getType()) {
            log.debug("LABEL UPDATE MESSAGE is received");
            return PcepLabelUpdateMsgVer1.READER.readFrom(cb.readBytes(length));
        } else {
            throw new PcepParseException("ERROR: UNKNOWN MESSAGE is received. Msg Type: " + type);
        }
    } catch (IndexOutOfBoundsException e) {
        throw new PcepParseException(PcepErrorDetailInfo.ERROR_TYPE_1, PcepErrorDetailInfo.ERROR_VALUE_1);
    }
}
#end_block

#method_before
@Test
public void lsReportMessageTest1() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x2C, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x28, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x08, // AutonomousSystem Tlv
    0x00, // AutonomousSystem Tlv
    0x01, // AutonomousSystem Tlv
    0x00, // AutonomousSystem Tlv
    0x04, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest1() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x2C, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x28, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x08, // AutonomousSystem Tlv
    0x00, // AutonomousSystem Tlv
    0x01, // AutonomousSystem Tlv
    0x00, // AutonomousSystem Tlv
    0x04, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest2() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x2C, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x28, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x08, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest2() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x2C, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x28, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x08, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest3() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x20, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x1C, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest3() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x20, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x1C, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest4() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x48, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x44, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OspfAreaIdSubTlv
    0x00, // OspfAreaIdSubTlv
    0x03, // OspfAreaIdSubTlv
    0x00, // OspfAreaIdSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest4() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x48, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x44, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OspfAreaIdSubTlv
    0x00, // OspfAreaIdSubTlv
    0x03, // OspfAreaIdSubTlv
    0x00, // OspfAreaIdSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest5() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x40, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x3C, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x1C, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest5() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x40, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x3C, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x1C, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest6() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x38, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x34, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x14, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest6() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x38, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x34, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x14, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest7() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x30, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x2C, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x0C, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest7() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x30, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x2C, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x0C, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest8() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x24, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x20, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest8() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x24, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x20, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest9() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x70, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x6C, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest9() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x70, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x6C, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest10() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x68, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x64, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x1C, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest10() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x68, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x64, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x1C, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest11() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x60, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x5C, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x14, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest11() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x60, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x5C, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x14, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest12() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x58, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x54, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x0c, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest12() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x58, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x54, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x0c, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest13() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x4C, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x48, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest13() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    0x4C, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    0x48, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest14() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    (byte) 0x90, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    (byte) 0x8C, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x1C, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x06, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x07, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest14() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    (byte) 0x90, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    (byte) 0x8C, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x1C, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x06, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x07, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest15() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    (byte) 0x84, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    (byte) 0x80, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x10, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x07, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest15() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    (byte) 0x84, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    (byte) 0x80, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x10, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x07, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest16() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    (byte) 0x7C, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    (byte) 0x78, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest16() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    (byte) 0x7C, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    (byte) 0x78, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest17() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    (byte) 0x74, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    (byte) 0x70, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest17() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    (byte) 0x74, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    (byte) 0x70, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest18() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    (byte) 0xC4, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    (byte) 0xC0, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x1C, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x06, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x07, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeAttributesTlv
    (byte) 0xFF, // NodeAttributesTlv
    0x05, // NodeAttributesTlv
    0x00, // NodeAttributesTlv
    0x30, // NodeFlagBitsSubTlv
    0x00, // NodeFlagBitsSubTlv
    0x0D, // NodeFlagBitsSubTlv
    0x00, // NodeFlagBitsSubTlv
    0x01, (byte) 0x90, 0x00, 0x00, 0x00, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x0E, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeNameSubTlv
    0x00, // NodeNameSubTlv
    0x0F, // NodeNameSubTlv
    0x00, // NodeNameSubTlv
    0x08, 0x08, 0x00, 0x01, 0x09, 0x08, 0x00, 0x01, 0x09, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x11, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x04, 0x00, 0x01, 0x01, 0x02 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest18() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    (byte) 0xC4, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    (byte) 0xC0, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x1C, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x06, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x07, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeAttributesTlv
    (byte) 0xFF, // NodeAttributesTlv
    0x05, // NodeAttributesTlv
    0x00, // NodeAttributesTlv
    0x30, // NodeFlagBitsSubTlv
    0x00, // NodeFlagBitsSubTlv
    0x0D, // NodeFlagBitsSubTlv
    0x00, // NodeFlagBitsSubTlv
    0x01, (byte) 0x90, 0x00, 0x00, 0x00, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x0E, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeNameSubTlv
    0x00, // NodeNameSubTlv
    0x0F, // NodeNameSubTlv
    0x00, // NodeNameSubTlv
    0x08, 0x08, 0x00, 0x01, 0x09, 0x08, 0x00, 0x01, 0x09, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x11, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x04, 0x00, 0x01, 0x01, 0x02 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest19() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    (byte) 0xC4, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    (byte) 0xC0, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x1C, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x06, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x07, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeAttributesTlv
    (byte) 0xFF, // NodeAttributesTlv
    0x05, // NodeAttributesTlv
    0x00, // NodeAttributesTlv
    0x30, // NodeFlagBitsSubTlv
    0x00, // NodeFlagBitsSubTlv
    0x0D, // NodeFlagBitsSubTlv
    0x00, // NodeFlagBitsSubTlv
    0x01, (byte) 0x90, 0x00, 0x00, 0x00, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x0E, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeNameSubTlv
    0x00, // NodeNameSubTlv
    0x0F, // NodeNameSubTlv
    0x00, // NodeNameSubTlv
    0x08, 0x08, 0x00, 0x01, 0x09, 0x08, 0x00, 0x01, 0x09, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x11, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x04, 0x00, 0x01, 0x01, 0x02 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest19() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    (byte) 0xC4, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    (byte) 0xC0, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x1C, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x06, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x07, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeAttributesTlv
    (byte) 0xFF, // NodeAttributesTlv
    0x05, // NodeAttributesTlv
    0x00, // NodeAttributesTlv
    0x30, // NodeFlagBitsSubTlv
    0x00, // NodeFlagBitsSubTlv
    0x0D, // NodeFlagBitsSubTlv
    0x00, // NodeFlagBitsSubTlv
    0x01, (byte) 0x90, 0x00, 0x00, 0x00, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x0E, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeNameSubTlv
    0x00, // NodeNameSubTlv
    0x0F, // NodeNameSubTlv
    0x00, // NodeNameSubTlv
    0x08, 0x08, 0x00, 0x01, 0x09, 0x08, 0x00, 0x01, 0x09, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x11, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x04, 0x00, 0x01, 0x01, 0x02 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest20() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    (byte) 0xBC, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    (byte) 0xB8, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x1C, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x06, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x07, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeAttributesTlv
    (byte) 0xFF, // NodeAttributesTlv
    0x05, // NodeAttributesTlv
    0x00, // NodeAttributesTlv
    0x28, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x0E, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeNameSubTlv
    0x00, // NodeNameSubTlv
    0x0F, // NodeNameSubTlv
    0x00, // NodeNameSubTlv
    0x08, 0x08, 0x00, 0x01, 0x09, 0x08, 0x00, 0x01, 0x09, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x11, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x04, 0x00, 0x01, 0x01, 0x02 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest20() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    (byte) 0xBC, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    (byte) 0xB8, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x1C, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x06, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x07, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeAttributesTlv
    (byte) 0xFF, // NodeAttributesTlv
    0x05, // NodeAttributesTlv
    0x00, // NodeAttributesTlv
    0x28, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x0E, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeNameSubTlv
    0x00, // NodeNameSubTlv
    0x0F, // NodeNameSubTlv
    0x00, // NodeNameSubTlv
    0x08, 0x08, 0x00, 0x01, 0x09, 0x08, 0x00, 0x01, 0x09, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x11, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x04, 0x00, 0x01, 0x01, 0x02 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest21() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    (byte) 0xB0, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    (byte) 0xAC, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x1C, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x06, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x07, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeAttributesTlv
    (byte) 0xFF, // NodeAttributesTlv
    0x05, // NodeAttributesTlv
    0x00, // NodeAttributesTlv
    0x1C, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x0E, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x11, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x04, 0x00, 0x01, 0x01, 0x02 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest21() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    (byte) 0xB0, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    (byte) 0xAC, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x1C, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x06, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x07, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeAttributesTlv
    (byte) 0xFF, // NodeAttributesTlv
    0x05, // NodeAttributesTlv
    0x00, // NodeAttributesTlv
    0x1C, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x0E, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x11, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x04, 0x00, 0x01, 0x01, 0x02 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest22() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x01, // common header
    0x18, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x01, // LS Object Header
    0x14, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x1C, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x06, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x07, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeAttributesTlv
    (byte) 0xFF, // NodeAttributesTlv
    0x05, // NodeAttributesTlv
    0x00, // NodeAttributesTlv
    0x1C, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x0E, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x11, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x04, 0x00, 0x01, 0x01, 0x02, // LinkAttributesTlv
    (byte) 0xFF, // LinkAttributesTlv
    0x06, // LinkAttributesTlv
    0x00, // LinkAttributesTlv
    0x64, // IPv4RouterIdOfRemoteNodeSubTlv
    0x00, // IPv4RouterIdOfRemoteNodeSubTlv
    0x13, // IPv4RouterIdOfRemoteNodeSubTlv
    0x00, // IPv4RouterIdOfRemoteNodeSubTlv
    0x04, 0x00, 0x07, 0x08, 0x00, // AdministrativeGroupSubTlv
    0x00, // AdministrativeGroupSubTlv
    0x16, // AdministrativeGroupSubTlv
    0x00, // AdministrativeGroupSubTlv
    0x04, 0x00, 0x09, 0x08, 0x00, // MaximumLinkBandwidthSubTlv
    0x00, // MaximumLinkBandwidthSubTlv
    0x17, // MaximumLinkBandwidthSubTlv
    0x00, // MaximumLinkBandwidthSubTlv
    0x04, 0x00, 0x09, 0x00, 0x00, // MaximumReservableLinkBandwidthSubTlv
    0x00, // MaximumReservableLinkBandwidthSubTlv
    0x18, // MaximumReservableLinkBandwidthSubTlv
    0x00, // MaximumReservableLinkBandwidthSubTlv
    0x04, 0x00, 0x10, 0x00, 0x00, // UnreservedBandwidthSubTlv
    0x00, // UnreservedBandwidthSubTlv
    0x19, // UnreservedBandwidthSubTlv
    0x00, // UnreservedBandwidthSubTlv
    0x04, 0x00, 0x00, (byte) 0x90, 0x00, // TEDefaultMetricSubTlv
    0x00, // TEDefaultMetricSubTlv
    0x1A, // TEDefaultMetricSubTlv
    0x00, // TEDefaultMetricSubTlv
    0x04, 0x00, (byte) 0x99, 0x09, 0x00, // LinkProtectionTypeSubTlv
    0x00, // LinkProtectionTypeSubTlv
    0x1B, // LinkProtectionTypeSubTlv
    0x00, // LinkProtectionTypeSubTlv
    0x02, 0x09, 0x00, 0x00, 0x00, // MPLSProtocolMaskSubTlv
    0x00, // MPLSProtocolMaskSubTlv
    0x1C, // MPLSProtocolMaskSubTlv
    0x00, // MPLSProtocolMaskSubTlv
    0x01, (byte) 0x80, 0x00, 0x00, 0x00, // IgpMetricSubTlv
    0x00, // IgpMetricSubTlv
    0x1D, // IgpMetricSubTlv
    0x00, // IgpMetricSubTlv
    0x04, 0x09, (byte) 0x89, 0x07, 0x00, // SharedRiskLinkGroupSubTlv
    0x00, // SharedRiskLinkGroupSubTlv
    0x1E, // SharedRiskLinkGroupSubTlv
    0x00, // SharedRiskLinkGroupSubTlv
    0x04, 0x04, 0x47, 0x00, 0x03, // OpaqueLinkAttributeSubTlv
    0x00, // OpaqueLinkAttributeSubTlv
    0x1F, // OpaqueLinkAttributeSubTlv
    0x00, // OpaqueLinkAttributeSubTlv
    0x08, 0x04, 0x49, 0x00, 0x04, 0x04, 0x47, 0x00, 0x03, // LinkNameAttributeSubTlv
    0x00, // LinkNameAttributeSubTlv
    0x20, // LinkNameAttributeSubTlv
    0x00, // LinkNameAttributeSubTlv
    0x04, 0x04, 0x47, 0x00, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest22() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x01, // common header
    0x18, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x01, // LS Object Header
    0x14, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x1C, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x06, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x07, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeAttributesTlv
    (byte) 0xFF, // NodeAttributesTlv
    0x05, // NodeAttributesTlv
    0x00, // NodeAttributesTlv
    0x1C, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x0E, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x11, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x04, 0x00, 0x01, 0x01, 0x02, // LinkAttributesTlv
    (byte) 0xFF, // LinkAttributesTlv
    0x06, // LinkAttributesTlv
    0x00, // LinkAttributesTlv
    0x64, // IPv4RouterIdOfRemoteNodeSubTlv
    0x00, // IPv4RouterIdOfRemoteNodeSubTlv
    0x13, // IPv4RouterIdOfRemoteNodeSubTlv
    0x00, // IPv4RouterIdOfRemoteNodeSubTlv
    0x04, 0x00, 0x07, 0x08, 0x00, // AdministrativeGroupSubTlv
    0x00, // AdministrativeGroupSubTlv
    0x16, // AdministrativeGroupSubTlv
    0x00, // AdministrativeGroupSubTlv
    0x04, 0x00, 0x09, 0x08, 0x00, // MaximumLinkBandwidthSubTlv
    0x00, // MaximumLinkBandwidthSubTlv
    0x17, // MaximumLinkBandwidthSubTlv
    0x00, // MaximumLinkBandwidthSubTlv
    0x04, 0x00, 0x09, 0x00, 0x00, // MaximumReservableLinkBandwidthSubTlv
    0x00, // MaximumReservableLinkBandwidthSubTlv
    0x18, // MaximumReservableLinkBandwidthSubTlv
    0x00, // MaximumReservableLinkBandwidthSubTlv
    0x04, 0x00, 0x10, 0x00, 0x00, // UnreservedBandwidthSubTlv
    0x00, // UnreservedBandwidthSubTlv
    0x19, // UnreservedBandwidthSubTlv
    0x00, // UnreservedBandwidthSubTlv
    0x04, 0x00, 0x00, (byte) 0x90, 0x00, // TEDefaultMetricSubTlv
    0x00, // TEDefaultMetricSubTlv
    0x1A, // TEDefaultMetricSubTlv
    0x00, // TEDefaultMetricSubTlv
    0x04, 0x00, (byte) 0x99, 0x09, 0x00, // LinkProtectionTypeSubTlv
    0x00, // LinkProtectionTypeSubTlv
    0x1B, // LinkProtectionTypeSubTlv
    0x00, // LinkProtectionTypeSubTlv
    0x02, 0x09, 0x00, 0x00, 0x00, // MPLSProtocolMaskSubTlv
    0x00, // MPLSProtocolMaskSubTlv
    0x1C, // MPLSProtocolMaskSubTlv
    0x00, // MPLSProtocolMaskSubTlv
    0x01, (byte) 0x80, 0x00, 0x00, 0x00, // IgpMetricSubTlv
    0x00, // IgpMetricSubTlv
    0x1D, // IgpMetricSubTlv
    0x00, // IgpMetricSubTlv
    0x04, 0x09, (byte) 0x89, 0x07, 0x00, // SharedRiskLinkGroupSubTlv
    0x00, // SharedRiskLinkGroupSubTlv
    0x1E, // SharedRiskLinkGroupSubTlv
    0x00, // SharedRiskLinkGroupSubTlv
    0x04, 0x04, 0x47, 0x00, 0x03, // OpaqueLinkAttributeSubTlv
    0x00, // OpaqueLinkAttributeSubTlv
    0x1F, // OpaqueLinkAttributeSubTlv
    0x00, // OpaqueLinkAttributeSubTlv
    0x08, 0x04, 0x49, 0x00, 0x04, 0x04, 0x47, 0x00, 0x03, // LinkNameAttributeSubTlv
    0x00, // LinkNameAttributeSubTlv
    0x20, // LinkNameAttributeSubTlv
    0x00, // LinkNameAttributeSubTlv
    0x04, 0x04, 0x47, 0x00, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest23() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x01, // common header
    0x10, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x01, // LS Object Header
    0x0C, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x1C, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x06, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x07, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeAttributesTlv
    (byte) 0xFF, // NodeAttributesTlv
    0x05, // NodeAttributesTlv
    0x00, // NodeAttributesTlv
    0x1C, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x0E, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x11, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x04, 0x00, 0x01, 0x01, 0x02, // LinkAttributesTlv
    (byte) 0xFF, // LinkAttributesTlv
    0x06, // LinkAttributesTlv
    0x00, // LinkAttributesTlv
    0x5C, // IPv4RouterIdOfRemoteNodeSubTlv
    0x00, // IPv4RouterIdOfRemoteNodeSubTlv
    0x13, // IPv4RouterIdOfRemoteNodeSubTlv
    0x00, // IPv4RouterIdOfRemoteNodeSubTlv
    0x04, 0x00, 0x07, 0x08, 0x00, // AdministrativeGroupSubTlv
    0x00, // AdministrativeGroupSubTlv
    0x16, // AdministrativeGroupSubTlv
    0x00, // AdministrativeGroupSubTlv
    0x04, 0x00, 0x09, 0x08, 0x00, // MaximumLinkBandwidthSubTlv
    0x00, // MaximumLinkBandwidthSubTlv
    0x17, // MaximumLinkBandwidthSubTlv
    0x00, // MaximumLinkBandwidthSubTlv
    0x04, 0x00, 0x09, 0x00, 0x00, // MaximumReservableLinkBandwidthSubTlv
    0x00, // MaximumReservableLinkBandwidthSubTlv
    0x18, // MaximumReservableLinkBandwidthSubTlv
    0x00, // MaximumReservableLinkBandwidthSubTlv
    0x04, 0x00, 0x10, 0x00, 0x00, // UnreservedBandwidthSubTlv
    0x00, // UnreservedBandwidthSubTlv
    0x19, // UnreservedBandwidthSubTlv
    0x00, // UnreservedBandwidthSubTlv
    0x04, 0x00, 0x00, (byte) 0x90, 0x00, // TEDefaultMetricSubTlv
    0x00, // TEDefaultMetricSubTlv
    0x1A, // TEDefaultMetricSubTlv
    0x00, // TEDefaultMetricSubTlv
    0x04, 0x00, (byte) 0x99, 0x09, 0x00, // LinkProtectionTypeSubTlv
    0x00, // LinkProtectionTypeSubTlv
    0x1B, // LinkProtectionTypeSubTlv
    0x00, // LinkProtectionTypeSubTlv
    0x02, 0x09, 0x00, 0x00, 0x00, // MPLSProtocolMaskSubTlv
    0x00, // MPLSProtocolMaskSubTlv
    0x1C, // MPLSProtocolMaskSubTlv
    0x00, // MPLSProtocolMaskSubTlv
    0x01, (byte) 0x80, 0x00, 0x00, 0x00, // IgpMetricSubTlv
    0x00, // IgpMetricSubTlv
    0x1D, // IgpMetricSubTlv
    0x00, // IgpMetricSubTlv
    0x04, 0x09, (byte) 0x89, 0x07, 0x00, // SharedRiskLinkGroupSubTlv
    0x00, // SharedRiskLinkGroupSubTlv
    0x1E, // SharedRiskLinkGroupSubTlv
    0x00, // SharedRiskLinkGroupSubTlv
    0x04, 0x04, 0x47, 0x00, 0x03, // OpaqueLinkAttributeSubTlv
    0x00, // OpaqueLinkAttributeSubTlv
    0x1F, // OpaqueLinkAttributeSubTlv
    0x00, // OpaqueLinkAttributeSubTlv
    0x08, 0x04, 0x49, 0x00, 0x04, 0x04, 0x47, 0x00, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest23() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x01, // common header
    0x10, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x01, // LS Object Header
    0x0C, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x1C, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x06, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x07, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeAttributesTlv
    (byte) 0xFF, // NodeAttributesTlv
    0x05, // NodeAttributesTlv
    0x00, // NodeAttributesTlv
    0x1C, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x0E, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x11, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x04, 0x00, 0x01, 0x01, 0x02, // LinkAttributesTlv
    (byte) 0xFF, // LinkAttributesTlv
    0x06, // LinkAttributesTlv
    0x00, // LinkAttributesTlv
    0x5C, // IPv4RouterIdOfRemoteNodeSubTlv
    0x00, // IPv4RouterIdOfRemoteNodeSubTlv
    0x13, // IPv4RouterIdOfRemoteNodeSubTlv
    0x00, // IPv4RouterIdOfRemoteNodeSubTlv
    0x04, 0x00, 0x07, 0x08, 0x00, // AdministrativeGroupSubTlv
    0x00, // AdministrativeGroupSubTlv
    0x16, // AdministrativeGroupSubTlv
    0x00, // AdministrativeGroupSubTlv
    0x04, 0x00, 0x09, 0x08, 0x00, // MaximumLinkBandwidthSubTlv
    0x00, // MaximumLinkBandwidthSubTlv
    0x17, // MaximumLinkBandwidthSubTlv
    0x00, // MaximumLinkBandwidthSubTlv
    0x04, 0x00, 0x09, 0x00, 0x00, // MaximumReservableLinkBandwidthSubTlv
    0x00, // MaximumReservableLinkBandwidthSubTlv
    0x18, // MaximumReservableLinkBandwidthSubTlv
    0x00, // MaximumReservableLinkBandwidthSubTlv
    0x04, 0x00, 0x10, 0x00, 0x00, // UnreservedBandwidthSubTlv
    0x00, // UnreservedBandwidthSubTlv
    0x19, // UnreservedBandwidthSubTlv
    0x00, // UnreservedBandwidthSubTlv
    0x04, 0x00, 0x00, (byte) 0x90, 0x00, // TEDefaultMetricSubTlv
    0x00, // TEDefaultMetricSubTlv
    0x1A, // TEDefaultMetricSubTlv
    0x00, // TEDefaultMetricSubTlv
    0x04, 0x00, (byte) 0x99, 0x09, 0x00, // LinkProtectionTypeSubTlv
    0x00, // LinkProtectionTypeSubTlv
    0x1B, // LinkProtectionTypeSubTlv
    0x00, // LinkProtectionTypeSubTlv
    0x02, 0x09, 0x00, 0x00, 0x00, // MPLSProtocolMaskSubTlv
    0x00, // MPLSProtocolMaskSubTlv
    0x1C, // MPLSProtocolMaskSubTlv
    0x00, // MPLSProtocolMaskSubTlv
    0x01, (byte) 0x80, 0x00, 0x00, 0x00, // IgpMetricSubTlv
    0x00, // IgpMetricSubTlv
    0x1D, // IgpMetricSubTlv
    0x00, // IgpMetricSubTlv
    0x04, 0x09, (byte) 0x89, 0x07, 0x00, // SharedRiskLinkGroupSubTlv
    0x00, // SharedRiskLinkGroupSubTlv
    0x1E, // SharedRiskLinkGroupSubTlv
    0x00, // SharedRiskLinkGroupSubTlv
    0x04, 0x04, 0x47, 0x00, 0x03, // OpaqueLinkAttributeSubTlv
    0x00, // OpaqueLinkAttributeSubTlv
    0x1F, // OpaqueLinkAttributeSubTlv
    0x00, // OpaqueLinkAttributeSubTlv
    0x08, 0x04, 0x49, 0x00, 0x04, 0x04, 0x47, 0x00, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest24() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x01, // common header
    0x08, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x01, // LS Object Header
    0x04, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x1C, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x06, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x07, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeAttributesTlv
    (byte) 0xFF, // NodeAttributesTlv
    0x05, // NodeAttributesTlv
    0x00, // NodeAttributesTlv
    0x1C, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x0E, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x11, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x04, 0x00, 0x01, 0x01, 0x02, // LinkAttributesTlv
    (byte) 0xFF, // LinkAttributesTlv
    0x06, // LinkAttributesTlv
    0x00, // LinkAttributesTlv
    0x54, // IPv4RouterIdOfRemoteNodeSubTlv
    0x00, // IPv4RouterIdOfRemoteNodeSubTlv
    0x13, // IPv4RouterIdOfRemoteNodeSubTlv
    0x00, // IPv4RouterIdOfRemoteNodeSubTlv
    0x04, 0x00, 0x07, 0x08, 0x00, // AdministrativeGroupSubTlv
    0x00, // AdministrativeGroupSubTlv
    0x16, // AdministrativeGroupSubTlv
    0x00, // AdministrativeGroupSubTlv
    0x04, 0x00, 0x09, 0x08, 0x00, // MaximumLinkBandwidthSubTlv
    0x00, // MaximumLinkBandwidthSubTlv
    0x17, // MaximumLinkBandwidthSubTlv
    0x00, // MaximumLinkBandwidthSubTlv
    0x04, 0x00, 0x09, 0x00, 0x00, // MaximumReservableLinkBandwidthSubTlv
    0x00, // MaximumReservableLinkBandwidthSubTlv
    0x18, // MaximumReservableLinkBandwidthSubTlv
    0x00, // MaximumReservableLinkBandwidthSubTlv
    0x04, 0x00, 0x10, 0x00, 0x00, // UnreservedBandwidthSubTlv
    0x00, // UnreservedBandwidthSubTlv
    0x19, // UnreservedBandwidthSubTlv
    0x00, // UnreservedBandwidthSubTlv
    0x04, 0x00, 0x00, (byte) 0x90, 0x00, // TEDefaultMetricSubTlv
    0x00, // TEDefaultMetricSubTlv
    0x1A, // TEDefaultMetricSubTlv
    0x00, // TEDefaultMetricSubTlv
    0x04, 0x00, (byte) 0x99, 0x09, 0x00, // LinkProtectionTypeSubTlv
    0x00, // LinkProtectionTypeSubTlv
    0x1B, // LinkProtectionTypeSubTlv
    0x00, // LinkProtectionTypeSubTlv
    0x02, 0x09, 0x00, 0x00, 0x00, // MPLSProtocolMaskSubTlv
    0x00, // MPLSProtocolMaskSubTlv
    0x1C, // MPLSProtocolMaskSubTlv
    0x00, // MPLSProtocolMaskSubTlv
    0x01, (byte) 0x80, 0x00, 0x00, 0x00, // IgpMetricSubTlv
    0x00, // IgpMetricSubTlv
    0x1D, // IgpMetricSubTlv
    0x00, // IgpMetricSubTlv
    0x04, 0x09, (byte) 0x89, 0x07, 0x00, // SharedRiskLinkGroupSubTlv
    0x00, // SharedRiskLinkGroupSubTlv
    0x1E, // SharedRiskLinkGroupSubTlv
    0x00, // SharedRiskLinkGroupSubTlv
    0x08, 0x04, 0x47, 0x00, 0x03, 0x04, 0x47, 0x00, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest24() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x01, // common header
    0x08, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x01, // LS Object Header
    0x04, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x1C, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x06, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x07, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeAttributesTlv
    (byte) 0xFF, // NodeAttributesTlv
    0x05, // NodeAttributesTlv
    0x00, // NodeAttributesTlv
    0x1C, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x0E, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x11, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x04, 0x00, 0x01, 0x01, 0x02, // LinkAttributesTlv
    (byte) 0xFF, // LinkAttributesTlv
    0x06, // LinkAttributesTlv
    0x00, // LinkAttributesTlv
    0x54, // IPv4RouterIdOfRemoteNodeSubTlv
    0x00, // IPv4RouterIdOfRemoteNodeSubTlv
    0x13, // IPv4RouterIdOfRemoteNodeSubTlv
    0x00, // IPv4RouterIdOfRemoteNodeSubTlv
    0x04, 0x00, 0x07, 0x08, 0x00, // AdministrativeGroupSubTlv
    0x00, // AdministrativeGroupSubTlv
    0x16, // AdministrativeGroupSubTlv
    0x00, // AdministrativeGroupSubTlv
    0x04, 0x00, 0x09, 0x08, 0x00, // MaximumLinkBandwidthSubTlv
    0x00, // MaximumLinkBandwidthSubTlv
    0x17, // MaximumLinkBandwidthSubTlv
    0x00, // MaximumLinkBandwidthSubTlv
    0x04, 0x00, 0x09, 0x00, 0x00, // MaximumReservableLinkBandwidthSubTlv
    0x00, // MaximumReservableLinkBandwidthSubTlv
    0x18, // MaximumReservableLinkBandwidthSubTlv
    0x00, // MaximumReservableLinkBandwidthSubTlv
    0x04, 0x00, 0x10, 0x00, 0x00, // UnreservedBandwidthSubTlv
    0x00, // UnreservedBandwidthSubTlv
    0x19, // UnreservedBandwidthSubTlv
    0x00, // UnreservedBandwidthSubTlv
    0x04, 0x00, 0x00, (byte) 0x90, 0x00, // TEDefaultMetricSubTlv
    0x00, // TEDefaultMetricSubTlv
    0x1A, // TEDefaultMetricSubTlv
    0x00, // TEDefaultMetricSubTlv
    0x04, 0x00, (byte) 0x99, 0x09, 0x00, // LinkProtectionTypeSubTlv
    0x00, // LinkProtectionTypeSubTlv
    0x1B, // LinkProtectionTypeSubTlv
    0x00, // LinkProtectionTypeSubTlv
    0x02, 0x09, 0x00, 0x00, 0x00, // MPLSProtocolMaskSubTlv
    0x00, // MPLSProtocolMaskSubTlv
    0x1C, // MPLSProtocolMaskSubTlv
    0x00, // MPLSProtocolMaskSubTlv
    0x01, (byte) 0x80, 0x00, 0x00, 0x00, // IgpMetricSubTlv
    0x00, // IgpMetricSubTlv
    0x1D, // IgpMetricSubTlv
    0x00, // IgpMetricSubTlv
    0x04, 0x09, (byte) 0x89, 0x07, 0x00, // SharedRiskLinkGroupSubTlv
    0x00, // SharedRiskLinkGroupSubTlv
    0x1E, // SharedRiskLinkGroupSubTlv
    0x00, // SharedRiskLinkGroupSubTlv
    0x08, 0x04, 0x47, 0x00, 0x03, 0x04, 0x47, 0x00, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Test
public void lsReportMessageTest25() throws PcepParseException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    (byte) 0xFC, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    (byte) 0xF8, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x1C, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x06, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x07, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeAttributesTlv
    (byte) 0xFF, // NodeAttributesTlv
    0x05, // NodeAttributesTlv
    0x00, // NodeAttributesTlv
    0x1C, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x0E, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x11, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x04, 0x00, 0x01, 0x01, 0x02, // LinkAttributesTlv
    (byte) 0xFF, // LinkAttributesTlv
    0x06, // LinkAttributesTlv
    0x00, // LinkAttributesTlv
    0x48, // IPv4RouterIdOfRemoteNodeSubTlv
    0x00, // IPv4RouterIdOfRemoteNodeSubTlv
    0x13, // IPv4RouterIdOfRemoteNodeSubTlv
    0x00, // IPv4RouterIdOfRemoteNodeSubTlv
    0x04, 0x00, 0x07, 0x08, 0x00, // AdministrativeGroupSubTlv
    0x00, // AdministrativeGroupSubTlv
    0x16, // AdministrativeGroupSubTlv
    0x00, // AdministrativeGroupSubTlv
    0x04, 0x00, 0x09, 0x08, 0x00, // MaximumLinkBandwidthSubTlv
    0x00, // MaximumLinkBandwidthSubTlv
    0x17, // MaximumLinkBandwidthSubTlv
    0x00, // MaximumLinkBandwidthSubTlv
    0x04, 0x00, 0x09, 0x00, 0x00, // MaximumReservableLinkBandwidthSubTlv
    0x00, // MaximumReservableLinkBandwidthSubTlv
    0x18, // MaximumReservableLinkBandwidthSubTlv
    0x00, // MaximumReservableLinkBandwidthSubTlv
    0x04, 0x00, 0x10, 0x00, 0x00, // UnreservedBandwidthSubTlv
    0x00, // UnreservedBandwidthSubTlv
    0x19, // UnreservedBandwidthSubTlv
    0x00, // UnreservedBandwidthSubTlv
    0x04, 0x00, 0x00, (byte) 0x90, 0x00, // TEDefaultMetricSubTlv
    0x00, // TEDefaultMetricSubTlv
    0x1A, // TEDefaultMetricSubTlv
    0x00, // TEDefaultMetricSubTlv
    0x04, 0x00, (byte) 0x99, 0x09, 0x00, // LinkProtectionTypeSubTlv
    0x00, // LinkProtectionTypeSubTlv
    0x1B, // LinkProtectionTypeSubTlv
    0x00, // LinkProtectionTypeSubTlv
    0x02, 0x09, 0x00, 0x00, 0x00, // MPLSProtocolMaskSubTlv
    0x00, // MPLSProtocolMaskSubTlv
    0x1C, // MPLSProtocolMaskSubTlv
    0x00, // MPLSProtocolMaskSubTlv
    0x01, (byte) 0x80, 0x00, 0x00, 0x00, // IgpMetricSubTlv
    0x00, // IgpMetricSubTlv
    0x1D, // IgpMetricSubTlv
    0x00, // IgpMetricSubTlv
    0x04, 0x09, (byte) 0x89, 0x07, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#method_after
@Test
public void lsReportMessageTest25() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] lsReportMsg = new byte[] { // common header
    0x20, // common header
    (byte) 0xE0, // common header
    0x00, // common header
    (byte) 0xFC, // LS Object Header
    (byte) 0xE0, // LS Object Header
    0x10, // LS Object Header
    0x00, // LS Object Header
    (byte) 0xF8, // LS-ID
    0x01, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x03, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x00, // LS-ID
    0x10, // Routing Universe TLV
    (byte) 0xFF, // Routing Universe TLV
    0x01, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local Node Descriptors TLV
    (byte) 0xFF, // Local Node Descriptors TLV
    0x02, // Local Node Descriptors TLV
    0x00, // Local Node Descriptors TLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteNodeDescriptorsTLV
    (byte) 0xFF, // RemoteNodeDescriptorsTLV
    0x03, // RemoteNodeDescriptorsTLV
    0x00, // RemoteNodeDescriptorsTLV
    0x24, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x01, // AutonomousSystemSubTlv
    0x00, // AutonomousSystemSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x02, // BGPLSidentifierSubTlv
    0x00, // BGPLSidentifierSubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x03, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x04, // IgpRouterIdSubTlv
    0x00, // IgpRouterIdSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // LinkDescriptorsTLV
    (byte) 0xFF, // LinkDescriptorsTLV
    0x04, // LinkDescriptorsTLV
    0x00, // LinkDescriptorsTLV
    0x1C, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x06, // LinkLocalRemoteIdentifiersSubTlv
    0x00, // LinkLocalRemoteIdentifiersSubTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x07, // IPv4InterfaceAddressSubTlv
    0x00, // IPv4InterfaceAddressSubTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x08, // IPv4NeighborAddressSubTlv
    0x00, // IPv4NeighborAddressSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeAttributesTlv
    (byte) 0xFF, // NodeAttributesTlv
    0x05, // NodeAttributesTlv
    0x00, // NodeAttributesTlv
    0x1C, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x0E, // OpaqueNodePropertiesSubTlv
    0x00, // OpaqueNodePropertiesSubTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x10, // ISISAreaIdentifierSubTlv
    0x00, // ISISAreaIdentifierSubTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x11, // IPv4RouterIdOfLocalNodeSubTlv
    0x00, // IPv4RouterIdOfLocalNodeSubTlv
    0x04, 0x00, 0x01, 0x01, 0x02, // LinkAttributesTlv
    (byte) 0xFF, // LinkAttributesTlv
    0x06, // LinkAttributesTlv
    0x00, // LinkAttributesTlv
    0x48, // IPv4RouterIdOfRemoteNodeSubTlv
    0x00, // IPv4RouterIdOfRemoteNodeSubTlv
    0x13, // IPv4RouterIdOfRemoteNodeSubTlv
    0x00, // IPv4RouterIdOfRemoteNodeSubTlv
    0x04, 0x00, 0x07, 0x08, 0x00, // AdministrativeGroupSubTlv
    0x00, // AdministrativeGroupSubTlv
    0x16, // AdministrativeGroupSubTlv
    0x00, // AdministrativeGroupSubTlv
    0x04, 0x00, 0x09, 0x08, 0x00, // MaximumLinkBandwidthSubTlv
    0x00, // MaximumLinkBandwidthSubTlv
    0x17, // MaximumLinkBandwidthSubTlv
    0x00, // MaximumLinkBandwidthSubTlv
    0x04, 0x00, 0x09, 0x00, 0x00, // MaximumReservableLinkBandwidthSubTlv
    0x00, // MaximumReservableLinkBandwidthSubTlv
    0x18, // MaximumReservableLinkBandwidthSubTlv
    0x00, // MaximumReservableLinkBandwidthSubTlv
    0x04, 0x00, 0x10, 0x00, 0x00, // UnreservedBandwidthSubTlv
    0x00, // UnreservedBandwidthSubTlv
    0x19, // UnreservedBandwidthSubTlv
    0x00, // UnreservedBandwidthSubTlv
    0x04, 0x00, 0x00, (byte) 0x90, 0x00, // TEDefaultMetricSubTlv
    0x00, // TEDefaultMetricSubTlv
    0x1A, // TEDefaultMetricSubTlv
    0x00, // TEDefaultMetricSubTlv
    0x04, 0x00, (byte) 0x99, 0x09, 0x00, // LinkProtectionTypeSubTlv
    0x00, // LinkProtectionTypeSubTlv
    0x1B, // LinkProtectionTypeSubTlv
    0x00, // LinkProtectionTypeSubTlv
    0x02, 0x09, 0x00, 0x00, 0x00, // MPLSProtocolMaskSubTlv
    0x00, // MPLSProtocolMaskSubTlv
    0x1C, // MPLSProtocolMaskSubTlv
    0x00, // MPLSProtocolMaskSubTlv
    0x01, (byte) 0x80, 0x00, 0x00, 0x00, // IgpMetricSubTlv
    0x00, // IgpMetricSubTlv
    0x1D, // IgpMetricSubTlv
    0x00, // IgpMetricSubTlv
    0x04, 0x09, (byte) 0x89, 0x07, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(lsReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    assertThat(message, instanceOf(PcepLSReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(lsReportMsg));
}
#end_block

#method_before
@Override
public void setProtocolId(byte yProtId) {
    this.protocolId = yProtId;
}
#method_after
@Override
public void setProtocolId(byte protId) {
    this.protocolId = protId;
}
#end_block

#method_before
@Override
public List<PcepValueType> getOptionalTlv() {
    return this.llOptionalTlv;
}
#method_after
@Override
public List<PcepValueType> getOptionalTlv() {
    return this.optionalTlvList;
}
#end_block

#method_before
@Override
public void setOptionalTlv(List<PcepValueType> llOptionalTlv) {
    this.llOptionalTlv = llOptionalTlv;
}
#method_after
@Override
public void setOptionalTlv(List<PcepValueType> optionalTlvList) {
    this.optionalTlvList = optionalTlvList;
}
#end_block

#method_before
public static PcepLSObject read(ChannelBuffer cb) throws PcepParseException {
    log.debug("read");
    PcepObjectHeader lsObjHeader;
    byte protocolId;
    // 2-flags
    boolean rFlag;
    boolean sFlag;
    long lsId;
    List<PcepValueType> llOptionalTlv;
    lsObjHeader = PcepObjectHeader.read(cb);
    // take only LSObject buffer.
    ChannelBuffer tempCb = cb.readBytes(lsObjHeader.getObjLen() - OBJECT_HEADER_LENGTH);
    protocolId = tempCb.readByte();
    // ignore first two bytes of Flags
    tempCb.readShort();
    // read 3rd byte Flag
    Integer iTemp = (int) tempCb.readByte();
    sFlag = (iTemp & FLAG_SET_S_FLAG) == FLAG_SET_S_FLAG;
    rFlag = (iTemp & FLAG_SET_R_FLAG) == FLAG_SET_R_FLAG;
    lsId = tempCb.readLong();
    // parse optional TLV
    llOptionalTlv = parseOptionalTlv(tempCb);
    return new PcepLSObjectVer1(lsObjHeader, protocolId, rFlag, sFlag, lsId, llOptionalTlv);
}
#method_after
public static PcepLSObject read(ChannelBuffer cb) throws PcepParseException {
    log.debug("read");
    PcepObjectHeader lsObjHeader;
    byte protocolId;
    // 2-flags
    boolean removeFlag;
    boolean syncFlag;
    long lsId;
    List<PcepValueType> optionalTlvList;
    lsObjHeader = PcepObjectHeader.read(cb);
    // take only LSObject buffer.
    ChannelBuffer tempCb = cb.readBytes(lsObjHeader.getObjLen() - OBJECT_HEADER_LENGTH);
    protocolId = tempCb.readByte();
    // ignore first two bytes of Flags
    tempCb.readShort();
    // read 3rd byte Flag
    Integer iTemp = (int) tempCb.readByte();
    syncFlag = (iTemp & FLAG_SET_S_FLAG) == FLAG_SET_S_FLAG;
    removeFlag = (iTemp & FLAG_SET_R_FLAG) == FLAG_SET_R_FLAG;
    lsId = tempCb.readLong();
    // parse optional TLV
    optionalTlvList = parseOptionalTlv(tempCb);
    return new PcepLSObjectVer1(lsObjHeader, protocolId, removeFlag, syncFlag, lsId, optionalTlvList);
}
#end_block

#method_before
@Override
public int write(ChannelBuffer cb) throws PcepParseException {
    // write Object header
    int objStartIndex = cb.writerIndex();
    int objLenIndex = lsObjHeader.write(cb);
    if (objLenIndex <= 0) {
        throw new PcepParseException("ObjectLength Index is " + objLenIndex);
    }
    // write Protocol ID
    cb.writeByte(this.protocolId);
    // write Flag
    cb.writeShort(0);
    byte bTemp = 0;
    if (sFlag) {
        bTemp = FLAG_SET_S_FLAG;
    }
    if (rFlag) {
        bTemp = (byte) (bTemp | FLAG_SET_R_FLAG);
    }
    cb.writeByte(bTemp);
    // write LSId
    cb.writeLong(lsId);
    // Add optional TLV
    packOptionalTlv(cb);
    // Update object length now
    int length = cb.writerIndex() - objStartIndex;
    // will be helpful during print().
    lsObjHeader.setObjLen((short) length);
    cb.setShort(objLenIndex, (short) length);
    return cb.writerIndex();
}
#method_after
@Override
public int write(ChannelBuffer cb) throws PcepParseException {
    // write Object header
    int objStartIndex = cb.writerIndex();
    int objLenIndex = lsObjHeader.write(cb);
    if (objLenIndex <= 0) {
        throw new PcepParseException("ObjectLength Index is " + objLenIndex);
    }
    // write Protocol ID
    cb.writeByte(this.protocolId);
    // write Flag
    cb.writeShort(0);
    byte bTemp = 0;
    if (syncFlag) {
        bTemp = FLAG_SET_S_FLAG;
    }
    if (removeFlag) {
        bTemp = (byte) (bTemp | FLAG_SET_R_FLAG);
    }
    cb.writeByte(bTemp);
    // write LSId
    cb.writeLong(lsId);
    // Add optional TLV
    packOptionalTlv(cb);
    // Update object length now
    int length = cb.writerIndex() - objStartIndex;
    // will be helpful during print().
    lsObjHeader.setObjLen((short) length);
    cb.setShort(objLenIndex, (short) length);
    return cb.writerIndex();
}
#end_block

#method_before
protected int packOptionalTlv(ChannelBuffer cb) {
    ListIterator<PcepValueType> listIterator = llOptionalTlv.listIterator();
    while (listIterator.hasNext()) {
        PcepValueType tlv = listIterator.next();
        if (tlv == null) {
            log.debug("TLV is null from OptionalTlv list");
            continue;
        }
        tlv.write(cb);
        // need to take care of padding
        int pad = tlv.getLength() % 4;
        if (0 != pad) {
            pad = 4 - pad;
            for (int i = 0; i < pad; ++i) {
                cb.writeByte((byte) 0);
            }
        }
    }
    return cb.writerIndex();
}
#method_after
protected int packOptionalTlv(ChannelBuffer cb) {
    ListIterator<PcepValueType> listIterator = optionalTlvList.listIterator();
    while (listIterator.hasNext()) {
        PcepValueType tlv = listIterator.next();
        if (tlv == null) {
            log.debug("TLV is null from OptionalTlv list");
            continue;
        }
        tlv.write(cb);
        // need to take care of padding
        int pad = tlv.getLength() % 4;
        if (0 != pad) {
            pad = 4 - pad;
            for (int i = 0; i < pad; ++i) {
                cb.writeByte((byte) 0);
            }
        }
    }
    return cb.writerIndex();
}
#end_block

#method_before
@Override
public PcepLSObject build() {
    PcepObjectHeader lsObjHeader = this.bIsHeaderSet ? this.lsObjHeader : DEFAULT_LS_OBJECT_HEADER;
    byte protocolId = this.bIsProtocolIdSet ? this.protocolId : DEFAULT_PROTOCOL_ID;
    boolean rFlag = this.bIsRFlagSet ? this.rFlag : DEFAULT_R_FLAG;
    boolean sFlag = this.bIsSFlagSet ? this.sFlag : DEFAULT_S_FLAG;
    long lsId = this.bIsLSIdSet ? this.lsId : DEFAULT_LS_ID;
    if (bIsPFlagSet) {
        lsObjHeader.setPFlag(bPFlag);
    }
    if (bIsIFlagSet) {
        lsObjHeader.setIFlag(bIFlag);
    }
    return new PcepLSObjectVer1(lsObjHeader, protocolId, rFlag, sFlag, lsId, llOptionalTlv);
}
#method_after
@Override
public PcepLSObject build() {
    PcepObjectHeader lsObjHeader = this.isHeaderSet ? this.lsObjHeader : DEFAULT_LS_OBJECT_HEADER;
    byte protocolId = this.isProtocolIdSet ? this.protocolId : DEFAULT_PROTOCOL_ID;
    boolean removeFlag = this.isRemoveFlagSet ? this.removeFlag : DEFAULT_R_FLAG;
    boolean syncFlag = this.isSyncFlagSet ? this.syncFlag : DEFAULT_S_FLAG;
    long lsId = this.isLSIdSet ? this.lsId : DEFAULT_LS_ID;
    if (isProcRuleFlagSet) {
        lsObjHeader.setPFlag(procRuleFlag);
    }
    if (isIgnoreFlagSet) {
        lsObjHeader.setIFlag(ignoreFlag);
    }
    return new PcepLSObjectVer1(lsObjHeader, protocolId, removeFlag, syncFlag, lsId, optionalTlvList);
}
#end_block

#method_before
@Override
public Builder setLSObjHeader(PcepObjectHeader obj) {
    this.lsObjHeader = obj;
    this.bIsHeaderSet = true;
    return this;
}
#method_after
@Override
public Builder setLSObjHeader(PcepObjectHeader obj) {
    this.lsObjHeader = obj;
    this.isHeaderSet = true;
    return this;
}
#end_block

#method_before
@Override
public Builder setProtocolId(byte yProtId) {
    this.protocolId = yProtId;
    this.bIsProtocolIdSet = true;
    return this;
}
#method_after
@Override
public Builder setProtocolId(byte protId) {
    this.protocolId = protId;
    this.isProtocolIdSet = true;
    return this;
}
#end_block

#method_before
@Override
public Builder setLSId(long lsId) {
    this.lsId = lsId;
    this.bIsLSIdSet = true;
    return this;
}
#method_after
@Override
public Builder setLSId(long lsId) {
    this.lsId = lsId;
    this.isLSIdSet = true;
    return this;
}
#end_block

#method_before
@Override
public List<PcepValueType> getOptionalTlv() {
    return this.llOptionalTlv;
}
#method_after
@Override
public List<PcepValueType> getOptionalTlv() {
    return this.optionalTlvList;
}
#end_block

#method_before
@Override
public Builder setOptionalTlv(List<PcepValueType> llOptionalTlv) {
    this.llOptionalTlv = llOptionalTlv;
    return this;
}
#method_after
@Override
public Builder setOptionalTlv(List<PcepValueType> optionalTlvList) {
    this.optionalTlvList = optionalTlvList;
    return this;
}
#end_block

#method_before
@Override
public Builder setPFlag(boolean value) {
    this.bPFlag = value;
    this.bIsPFlagSet = true;
    return this;
}
#method_after
@Override
public Builder setPFlag(boolean value) {
    this.procRuleFlag = value;
    this.isProcRuleFlagSet = true;
    return this;
}
#end_block

#method_before
@Override
public Builder setIFlag(boolean value) {
    this.bIFlag = value;
    this.bIsIFlagSet = true;
    return this;
}
#method_after
@Override
public Builder setIFlag(boolean value) {
    this.ignoreFlag = value;
    this.isIgnoreFlagSet = true;
    return this;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("ObjectHeader", lsObjHeader).add("ProtocolId", protocolId).add("RFlag", (rFlag) ? 1 : 0).add("SFlag", (sFlag) ? 1 : 0).add("LsId", lsId).add("OptionalTlv", llOptionalTlv).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().add("ObjectHeader", lsObjHeader).add("ProtocolId", protocolId).add("RFlag", (removeFlag) ? 1 : 0).add("SFlag", (syncFlag) ? 1 : 0).add("LsId", lsId).add("OptionalTlv", optionalTlvList).toString();
}
#end_block

#method_before
@Test
public void initiateMessageTest1() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
    // StatefulLspErrorCodeTlv, StatefulRsvpErrorSpecTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC-LIST.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0xA4, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x20, 0x10, 0x00, 0x38, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Metric object
    0x06, // Metric object
    0x10, // Metric object
    0x00, // Metric object
    0x0c, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x02, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x01, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest1() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
    // StatefulLspErrorCodeTlv, StatefulRsvpErrorSpecTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC-LIST.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0xA4, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x20, 0x10, 0x00, 0x38, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Metric object
    0x06, // Metric object
    0x10, // Metric object
    0x00, // Metric object
    0x0c, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x02, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x01, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest2() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
    // StatefulLspErrorCodeTlv, StatefulRsvpErrorSpecTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0xA8, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x48, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // StatefulRsvpErrorSpecTlv
    0x00, // StatefulRsvpErrorSpecTlv
    0x15, // StatefulRsvpErrorSpecTlv
    0x00, // StatefulRsvpErrorSpecTlv
    0x0c, 0x00, 0x0c, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x05, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest2() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
    // StatefulLspErrorCodeTlv, StatefulRsvpErrorSpecTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0xA8, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x48, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // StatefulRsvpErrorSpecTlv
    0x00, // StatefulRsvpErrorSpecTlv
    0x15, // StatefulRsvpErrorSpecTlv
    0x00, // StatefulRsvpErrorSpecTlv
    0x0c, 0x00, 0x0c, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x05, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest3() throws PcepParseException {
    // SRP, LSP (StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
    // StatefulLspErrorCodeTlv, StatefulRsvpErrorSpecTlv), END-POINTS, ERO, LSPA, BANDWIDTH.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x8c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest3() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
    // StatefulLspErrorCodeTlv, StatefulRsvpErrorSpecTlv), END-POINTS, ERO, LSPA, BANDWIDTH.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x8c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest4() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
    // StatefulLspErrorCodeTlv, StatefulRsvpErrorSpecTlv), END-POINTS, ERO, LSPA.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest4() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
    // StatefulLspErrorCodeTlv, StatefulRsvpErrorSpecTlv), END-POINTS, ERO, LSPA.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest5() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
    // StatefulLspErrorCodeTlv), END-POINTS, ERO, LSPA.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest5() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
    // StatefulLspErrorCodeTlv), END-POINTS, ERO, LSPA.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest6() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
    // StatefulLspErrorCodeTlv), END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x8c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest6() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
    // StatefulLspErrorCodeTlv), END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x8c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest7() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
    // StatefulLspErrorCodeTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x98, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest7() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
    // StatefulLspErrorCodeTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x98, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest8() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv),
    // END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x90, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x30, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest8() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv),
    // END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x90, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x30, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest9() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv),
    // END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x30, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest9() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv),
    // END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x30, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest10() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv),
    // END-POINTS, ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x70, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x20, 0x10, 0x00, 0x24, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest10() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv),
    // END-POINTS, ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x70, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x20, 0x10, 0x00, 0x24, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest11() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv),
    // END-POINTS, ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x7C, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x20, 0x10, 0x00, 0x30, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest11() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv),
    // END-POINTS, ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x7C, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x20, 0x10, 0x00, 0x30, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest12() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv),
    // END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x78, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x20, 0x10, 0x00, 0x24, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest12() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv),
    // END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x78, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x20, 0x10, 0x00, 0x24, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest13() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv),
    // END-POINTS, ERO, LSPA, BANDWIDTH , METRIC OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x20, 0x10, 0x00, 0x24, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest13() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv),
    // END-POINTS, ERO, LSPA, BANDWIDTH , METRIC OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x20, 0x10, 0x00, 0x24, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest14() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv),
    // END-POINTS, ERO, LSPA, BANDWIDTH , METRIC OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x7c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest14() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv),
    // END-POINTS, ERO, LSPA, BANDWIDTH , METRIC OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x7c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest15() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv),
    // END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x70, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest15() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv),
    // END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x70, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest16() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv),
    // END-POINTS, ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x68, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest16() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv),
    // END-POINTS, ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x68, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest17() throws PcepParseException {
    // SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x60, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest17() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x60, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest18() throws PcepParseException {
    // SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x68, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, 0x20, 0x10, 0x00, 0x1c, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest18() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x68, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, 0x20, 0x10, 0x00, 0x1c, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest19() throws PcepParseException {
    // SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x74, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest19() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x74, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest20() throws PcepParseException {
    // SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x64, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest20() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x64, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest21() throws PcepParseException {
    // SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, 0x07, 0x10, 0x00, 0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest21() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, 0x07, 0x10, 0x00, 0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest22() throws PcepParseException {
    // SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x50, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest22() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x50, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest23() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest23() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest25() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA BANDWIDTH OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x60, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest25() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA BANDWIDTH OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x60, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest26() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv), END-POINTS,
    // ERO, LSPA, BANDWIDTH, METRIC OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x6C, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // Metric object
    0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest26() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv), END-POINTS,
    // ERO, LSPA, BANDWIDTH, METRIC OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x6C, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // Metric object
    0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest27() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, SymbolicPathNameTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x60, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // Metric object
    0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest27() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, SymbolicPathNameTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x60, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // Metric object
    0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest28() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, SymbolicPathNameTlv), END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest28() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, SymbolicPathNameTlv), END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest29() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, SymbolicPathNameTlv), END-POINTS, ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x4C, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest29() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, SymbolicPathNameTlv), END-POINTS, ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x4C, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest30() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv, SymbolicPathNameTlv), END-POINTS, ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x5C, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest30() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv, SymbolicPathNameTlv), END-POINTS, ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x5C, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest31() throws PcepParseException {
    // SRP, LSP (SymbolicPathNameTlv), END-POINTS, ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest31() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP (SymbolicPathNameTlv), END-POINTS, ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest32() throws PcepParseException {
    // SRP, LSP ( StatefulLspDbVerTlv), END-POINTS,
    // ERO, LSPA, BANDWIDTH, METRIC OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x64, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // Metric object
    0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest32() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP ( StatefulLspDbVerTlv), END-POINTS,
    // ERO, LSPA, BANDWIDTH, METRIC OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x64, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // Metric object
    0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest33() throws PcepParseException {
    // SRP, LSP ( StatefulLspDbVerTlv), END-POINTS,
    // ERO, LSPA, BANDWIDTH OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest33() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP ( StatefulLspDbVerTlv), END-POINTS,
    // ERO, LSPA, BANDWIDTH OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest34() throws PcepParseException {
    // SRP, LSP ( StatefulLspDbVerTlv), END-POINTS,
    // ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x50, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest34() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP ( StatefulLspDbVerTlv), END-POINTS,
    // ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x50, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest35() throws PcepParseException {
    // SRP, LSP ( StatefulLspDbVerTlv), END-POINTS,
    // ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x60, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest35() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP ( StatefulLspDbVerTlv), END-POINTS,
    // ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x60, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest36() throws PcepParseException {
    // SRP, LSP ( StatefulLspDbVerTlv), END-POINTS,
    // ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest36() throws PcepParseException, PcepOutOfBoundMessageException {
    // SRP, LSP ( StatefulLspDbVerTlv), END-POINTS,
    // ERO, LSPA OBJECT.
    // 
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void openMessageTest1() throws PcepParseException {
    byte[] openMsg = new byte[] { 0x20, 0x01, 0x00, 0x24, 0x01, 0x10, 0x00, 0x20, 0x20, 0x1e, 0x78, (byte) 0xbd, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x0f, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0e, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x07 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#method_after
@Test
public void openMessageTest1() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] openMsg = new byte[] { 0x20, 0x01, 0x00, 0x24, 0x01, 0x10, 0x00, 0x20, 0x20, 0x1e, 0x78, (byte) 0xbd, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x0f, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0e, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x07 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest2() throws PcepParseException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x14, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x10, // OPEN object
    0x20, // OPEN object
    0x1E, // OPEN object
    0x78, // OPEN object
    0x01, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, // STATEFUL-PCE-CAPABILITY
    0x0f };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#method_after
@Test
public void openMessageTest2() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x14, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x10, // OPEN object
    0x20, // OPEN object
    0x1E, // OPEN object
    0x78, // OPEN object
    0x01, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, // STATEFUL-PCE-CAPABILITY
    0x0f };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest3() throws PcepParseException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x14, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x10, // OPEN object
    0x20, // OPEN object
    0x1E, // OPEN object
    0x78, // OPEN object
    0x01, 0x00, 0x0e, 0x00, 0x04, 0x00, 0x00, 0x00, // GMPLS-CAPABILITY-TLV
    0x00 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#method_after
@Test
public void openMessageTest3() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x14, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x10, // OPEN object
    0x20, // OPEN object
    0x1E, // OPEN object
    0x78, // OPEN object
    0x01, 0x00, 0x0e, 0x00, 0x04, 0x00, 0x00, 0x00, // GMPLS-CAPABILITY-TLV
    0x00 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest4() throws PcepParseException {
    byte[] openMsg = new byte[] { 0x20, 0x01, 0x00, 0x18, 0x01, 0x10, 0x00, 0x14, 0x20, 0x1e, 0x78, 0x20, 0x00, 0x17, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // StatefulLspDbVerTlv
    0x02 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#method_after
@Test
public void openMessageTest4() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] openMsg = new byte[] { 0x20, 0x01, 0x00, 0x18, 0x01, 0x10, 0x00, 0x14, 0x20, 0x1e, 0x78, 0x20, 0x00, 0x17, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // StatefulLspDbVerTlv
    0x02 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest5() throws PcepParseException {
    byte[] openMsg = new byte[] { 0x20, 0x01, 0x00, 0x0C, 0x01, 0x10, 0x00, 0x08, 0x20, 0x1e, 0x78, // no Tlvs in open messsage
    (byte) 0xbd };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#method_after
@Test
public void openMessageTest5() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] openMsg = new byte[] { 0x20, 0x01, 0x00, 0x0C, 0x01, 0x10, 0x00, 0x08, 0x20, 0x1e, 0x78, // no Tlvs in open messsage
    (byte) 0xbd };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest6() throws PcepParseException {
    byte[] openMsg = new byte[] { // p bit not set & i bit set
    0x20, // p bit not set & i bit set
    0x01, // p bit not set & i bit set
    0x00, // p bit not set & i bit set
    0x24, // p bit not set & i bit set
    0x01, // p bit not set & i bit set
    0x11, // p bit not set & i bit set
    0x00, // p bit not set & i bit set
    0x20, 0x20, 0x1e, 0x78, (byte) 0xbd, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x0f, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0e, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x07 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#method_after
@Test
public void openMessageTest6() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] openMsg = new byte[] { // p bit not set & i bit set
    0x20, // p bit not set & i bit set
    0x01, // p bit not set & i bit set
    0x00, // p bit not set & i bit set
    0x24, // p bit not set & i bit set
    0x01, // p bit not set & i bit set
    0x11, // p bit not set & i bit set
    0x00, // p bit not set & i bit set
    0x20, 0x20, 0x1e, 0x78, (byte) 0xbd, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x0f, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0e, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x07 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest7() throws PcepParseException {
    byte[] openMsg = new byte[] { // p bit set & i bit not set
    0x20, // p bit set & i bit not set
    0x01, // p bit set & i bit not set
    0x00, // p bit set & i bit not set
    0x24, // p bit set & i bit not set
    0x01, // p bit set & i bit not set
    0x12, // p bit set & i bit not set
    0x00, // p bit set & i bit not set
    0x20, 0x20, 0x1e, 0x78, (byte) 0xbd, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x0f, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0e, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x07 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#method_after
@Test
public void openMessageTest7() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] openMsg = new byte[] { // p bit set & i bit not set
    0x20, // p bit set & i bit not set
    0x01, // p bit set & i bit not set
    0x00, // p bit set & i bit not set
    0x24, // p bit set & i bit not set
    0x01, // p bit set & i bit not set
    0x12, // p bit set & i bit not set
    0x00, // p bit set & i bit not set
    0x20, 0x20, 0x1e, 0x78, (byte) 0xbd, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x0f, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0e, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x07 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest8() throws PcepParseException {
    /* OPEN OBJECT (STATEFUL-PCE-CAPABILITY, GMPLS-CAPABILITY-TLV, PCECC-CAPABILITY-TLV)
        with p bit set & i bit set.
         */
    byte[] openMsg = new byte[] { // p bit set & i bit set
    0x20, // p bit set & i bit set
    0x01, // p bit set & i bit set
    0x00, // p bit set & i bit set
    0x24, // p bit set & i bit set
    0x01, // p bit set & i bit set
    0x13, // p bit set & i bit set
    0x00, // p bit set & i bit set
    0x20, 0x20, 0x1e, 0x78, (byte) 0xbd, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x0f, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0e, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x07 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#method_after
@Test
public void openMessageTest8() throws PcepParseException, PcepOutOfBoundMessageException {
    /* OPEN OBJECT (STATEFUL-PCE-CAPABILITY, GMPLS-CAPABILITY-TLV, PCECC-CAPABILITY-TLV)
        with p bit set & i bit set.
         */
    byte[] openMsg = new byte[] { // p bit set & i bit set
    0x20, // p bit set & i bit set
    0x01, // p bit set & i bit set
    0x00, // p bit set & i bit set
    0x24, // p bit set & i bit set
    0x01, // p bit set & i bit set
    0x13, // p bit set & i bit set
    0x00, // p bit set & i bit set
    0x20, 0x20, 0x1e, 0x78, (byte) 0xbd, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x0f, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0e, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x07 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest9() throws PcepParseException {
    byte[] openMsg = new byte[] { // p bit set & i bit set
    0x20, // p bit set & i bit set
    0x01, // p bit set & i bit set
    0x00, // p bit set & i bit set
    0x24, // p bit set & i bit set
    0x01, // p bit set & i bit set
    0x13, // p bit set & i bit set
    0x00, // p bit set & i bit set
    0x20, // invalid sessionID
    0x20, // invalid sessionID
    0x1e, // invalid sessionID
    0x78, // invalid sessionID
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x0f, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0e, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x07 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#method_after
@Test
public void openMessageTest9() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] openMsg = new byte[] { // p bit set & i bit set
    0x20, // p bit set & i bit set
    0x01, // p bit set & i bit set
    0x00, // p bit set & i bit set
    0x24, // p bit set & i bit set
    0x01, // p bit set & i bit set
    0x13, // p bit set & i bit set
    0x00, // p bit set & i bit set
    0x20, // invalid sessionID
    0x20, // invalid sessionID
    0x1e, // invalid sessionID
    0x78, // invalid sessionID
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x0f, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0e, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x07 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest10() throws PcepParseException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x1C, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x18, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, 0x00, 0x00, 0x00, 0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, 0x00, 0x00, 0x00, 0x00 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#method_after
@Test
public void openMessageTest10() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x1C, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x18, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, 0x00, 0x00, 0x00, 0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, 0x00, 0x00, 0x00, 0x00 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest11() throws PcepParseException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x2C, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x28, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // LS Capability TLV
    0x00, // LS Capability TLV
    0x00, // LS Capability TLV
    0x00, // LS Capability TLV
    0x03, // LS Capability TLV
    (byte) 0xFF, // LS Capability TLV
    (byte) 0x00, // LS Capability TLV
    0x00, // LS Capability TLV
    0x04, 0x00, 0x00, 0x00, 0x00 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#method_after
@Test
public void openMessageTest11() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x2C, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x28, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, // LS Capability TLV
    0x00, // LS Capability TLV
    0x00, // LS Capability TLV
    0x00, // LS Capability TLV
    0x03, // LS Capability TLV
    (byte) 0xFF, // LS Capability TLV
    (byte) 0x00, // LS Capability TLV
    0x00, // LS Capability TLV
    0x04, 0x00, 0x00, 0x00, 0x00 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest12() throws PcepParseException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x24, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x20, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, 0x00, 0x00, 0x00, 0x03 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#method_after
@Test
public void openMessageTest12() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x24, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x20, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x20, // PCECC-CAPABILITY-TLV
    0x00, // PCECC-CAPABILITY-TLV
    0x04, 0x00, 0x00, 0x00, 0x03 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest13() throws PcepParseException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x1c, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x18, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, 0x00, 0x00, 0x00, 0x00 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#method_after
@Test
public void openMessageTest13() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x1c, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x18, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x05, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x0E, // GMPLS-CAPABILITY-TLV
    0x00, // GMPLS-CAPABILITY-TLV
    0x04, 0x00, 0x00, 0x00, 0x00 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest14() throws PcepParseException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x14, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x10, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, 0x00, 0x00, 0x00, 0x05 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#method_after
@Test
public void openMessageTest14() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x14, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x10, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x10, // STATEFUL-PCE-CAPABILITY
    0x00, // STATEFUL-PCE-CAPABILITY
    0x04, 0x00, 0x00, 0x00, 0x05 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Test
public void openMessageTest15() throws PcepParseException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x0c, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x08, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#method_after
@Test
public void openMessageTest15() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] openMsg = new byte[] { // common header
    0x20, // common header
    0x01, // common header
    0x00, // common header
    0x0c, // common object header
    0x01, // common object header
    0x10, // common object header
    0x00, // common object header
    0x08, // OPEN object
    0x20, // OPEN object
    0x05, // OPEN object
    0x1E, // OPEN object
    0x01 };
    byte[] testOpenMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(openMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepOpenMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testOpenMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testOpenMsg = new byte[readLen];
    buf.readBytes(testOpenMsg, 0, readLen);
    assertThat(testOpenMsg, is(openMsg));
}
#end_block

#method_before
@Deactivate
public void deactivate(ComponentContext context) {
    log.info("deactivating for snmp devices ...");
    cfgService.unregisterProperties(getClass(), false);
    try {
        snmpDeviceMap.entrySet().stream().forEach((deviceEntry) -> {
            deviceBuilder.submit(new DeviceCreator(deviceEntry.getValue(), false));
        });
        deviceBuilder.awaitTermination(1000, TimeUnit.MILLISECONDS);
    } catch (InterruptedException e) {
        log.error("Device builder did not terminate");
    }
    deviceBuilder.shutdownNow();
    snmpDeviceMap.clear();
    providerRegistry.unregister(this);
    providerService = null;
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate(ComponentContext context) {
    log.info("deactivating for snmp devices ...");
    cfgService.unregisterProperties(getClass(), false);
    try {
        snmpDeviceMap.entrySet().stream().forEach((deviceEntry) -> {
            deviceBuilder.execute(new DeviceCreator(deviceEntry.getValue(), false));
        });
        deviceBuilder.awaitTermination(1000, TimeUnit.MILLISECONDS);
    } catch (InterruptedException e) {
        log.error("Device builder did not terminate");
    }
    deviceBuilder.shutdownNow();
    snmpDeviceMap.clear();
    providerRegistry.unregister(this);
    providerService = null;
    log.info("Stopped");
}
#end_block

#method_before
private void addOrRemoveDevicesConfig(String deviceConfig) {
    for (String deviceEntry : deviceConfig.split(",")) {
        SnmpDevice device = processDeviceEntry(deviceEntry);
        if (device != null) {
            log.info("Device Detail:host={}, port={}, state={}", new Object[] { device.getSnmpHost(), device.getSnmpPort(), device.getDeviceState().name() });
            if (device.isActive()) {
                deviceBuilder.submit(new DeviceCreator(device, true));
            } else {
                deviceBuilder.submit(new DeviceCreator(device, false));
            }
        }
    }
}
#method_after
private void addOrRemoveDevicesConfig(String deviceConfig) {
    for (String deviceEntry : deviceConfig.split(",")) {
        SnmpDevice device = processDeviceEntry(deviceEntry);
        if (device != null) {
            log.info("Device Detail:host={}, port={}, state={}", new Object[] { device.getSnmpHost(), device.getSnmpPort(), device.getDeviceState().name() });
            if (device.isActive()) {
                deviceBuilder.execute(new DeviceCreator(device, true));
            } else {
                deviceBuilder.execute(new DeviceCreator(device, false));
            }
        }
    }
}
#end_block

#method_before
private void advertiseDevices() {
    try {
        if (device == null) {
            log.warn("The Request SNMP Device is null, cannot proceed further");
            return;
        }
        device.init();
        DeviceId did = getDeviceId();
        ChassisId cid = new ChassisId();
        DeviceDescription desc = new DefaultDeviceDescription(did.uri(), Device.Type.OTHER, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, cid);
        desc = populateDescriptionFromDevice(did, desc);
        log.info("Persisting Device " + did.uri().toString());
        snmpDeviceMap.put(did, device);
        providerService.deviceConnected(did, desc);
        log.info("Done with Device Info Creation on ONOS core. Device Info: " + device.deviceInfo() + " " + did.uri().toString());
        // Do port discovery if driver supports it
        Device d = deviceService.getDevice(did);
        if (d.is(PortDiscovery.class)) {
            PortDiscovery portConfig = d.as(PortDiscovery.class);
            if (portConfig != null) {
                providerService.updatePorts(did, portConfig.getPorts());
            }
        } else {
            log.warn("No port discovery behaviour for device {}", did);
        }
        delay(EVENTINTERVAL);
    } catch (URISyntaxException e) {
        log.error("Syntax Error while creating URI for the device: " + device.deviceInfo() + " couldn't persist the device onto the store", e);
    } catch (Exception e) {
        log.error("Error while initializing session for the device: " + (device != null ? device.deviceInfo() : null), e);
    }
}
#method_after
private void advertiseDevices() {
    try {
        if (device == null) {
            log.warn("The Request SNMP Device is null, cannot proceed further");
            return;
        }
        device.init();
        DeviceId did = getDeviceId();
        ChassisId cid = new ChassisId();
        SparseAnnotations annotations = DefaultAnnotations.builder().set(AnnotationKeys.PROTOCOL, SCHEME.toUpperCase()).build();
        DeviceDescription desc = new DefaultDeviceDescription(did.uri(), Device.Type.OTHER, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, cid, annotations);
        desc = populateDescriptionFromDevice(did, desc);
        log.info("Persisting Device " + did.uri().toString());
        snmpDeviceMap.put(did, device);
        providerService.deviceConnected(did, desc);
        log.info("Done with Device Info Creation on ONOS core. Device Info: " + device.deviceInfo() + " " + did.uri().toString());
        // Do port discovery if driver supports it
        Device d = deviceService.getDevice(did);
        if (d.is(PortDiscovery.class)) {
            PortDiscovery portConfig = d.as(PortDiscovery.class);
            if (portConfig != null) {
                providerService.updatePorts(did, portConfig.getPorts());
            }
        } else {
            log.warn("No port discovery behaviour for device {}", did);
        }
        delay(EVENTINTERVAL);
    } catch (URISyntaxException e) {
        log.error("Syntax Error while creating URI for the device: " + device.deviceInfo() + " couldn't persist the device onto the store", e);
    } catch (Exception e) {
        log.error("Error while initializing session for the device: " + (device != null ? device.deviceInfo() : null), e);
    }
}
#end_block

#method_before
@Override
public DeviceDescription populateDescription(ISnmpSession session, DeviceDescription description) {
    NetworkDevice networkDevice = new NetworkDevice(CLASS_REGISTRY, session.getAddress().getHostAddress());
    try {
        session.walkDevice(networkDevice, Arrays.asList(new OID[] { CLASS_REGISTRY.getClassToOidMap().get(com.btisystems.mibbler.mibs.bti7000.bti7000_13_2_0.mib_2.System.class) }));
        com.btisystems.mibbler.mibs.bti7000.bti7000_13_2_0.mib_2.System systemTree = (com.btisystems.mibbler.mibs.bti7000.bti7000_13_2_0.mib_2.System) networkDevice.getRootObject().getEntity(CLASS_REGISTRY.getClassToOidMap().get(com.btisystems.mibbler.mibs.bti7000.bti7000_13_2_0.mib_2.System.class));
        if (systemTree != null) {
            String[] systemComponents = systemTree.getSysDescr().split(";");
            return new DefaultDeviceDescription(description.deviceUri(), description.type(), systemComponents[0], systemComponents[2], systemComponents[3], UNKNOWN, description.chassisId());
        }
    } catch (IOException ex) {
        log.error("Error reading details for device {}.", session.getAddress(), ex);
    }
    return description;
}
#method_after
@Override
public DeviceDescription populateDescription(ISnmpSession session, DeviceDescription description) {
    NetworkDevice networkDevice = new NetworkDevice(CLASS_REGISTRY, session.getAddress().getHostAddress());
    try {
        session.walkDevice(networkDevice, Arrays.asList(new OID[] { CLASS_REGISTRY.getClassToOidMap().get(com.btisystems.mibbler.mibs.bti7000.bti7000_13_2_0.mib_2.System.class) }));
        com.btisystems.mibbler.mibs.bti7000.bti7000_13_2_0.mib_2.System systemTree = (com.btisystems.mibbler.mibs.bti7000.bti7000_13_2_0.mib_2.System) networkDevice.getRootObject().getEntity(CLASS_REGISTRY.getClassToOidMap().get(com.btisystems.mibbler.mibs.bti7000.bti7000_13_2_0.mib_2.System.class));
        if (systemTree != null) {
            String[] systemComponents = systemTree.getSysDescr().split(";");
            return new DefaultDeviceDescription(description.deviceUri(), description.type(), systemComponents[0], systemComponents[2], systemComponents[3], UNKNOWN, description.chassisId(), description.annotations());
        }
    } catch (IOException ex) {
        log.error("Error reading details for device {}.", session.getAddress(), ex);
    }
    return description;
}
#end_block

#method_before
@Override
public DeviceDescription populateDescription(ISnmpSession session, DeviceDescription description) {
    return new DefaultDeviceDescription(description.deviceUri(), Device.Type.ROADM, "Lumentum", "SDN ROADM", "1.0", "v1", description.chassisId());
}
#method_after
@Override
public DeviceDescription populateDescription(ISnmpSession session, DeviceDescription description) {
    return new DefaultDeviceDescription(description.deviceUri(), Device.Type.ROADM, "Lumentum", "SDN ROADM", "1.0", "v1", description.chassisId(), description.annotations());
}
#end_block

#method_before
@Override
public final void sendMsg(List<OFMessage> msgs) {
    /*
           It is possible that in this block, we transition to SLAVE/EQUAL.
           If this is the case, the supplied messages will race with the
           RoleRequest message, and they could be rejected by the switch.
           In the interest of performance, we will not protect this block with
           a synchronization primitive, because the message would have just been
           dropped anyway.
        */
    if (role == RoleState.MASTER) {
        // fast path send when we are master
        sendMsgsOnChannel(msgs);
        return;
    }
    // check to see if mastership transition is in progress
    synchronized (messagesPendingMastership) {
        /*
               messagesPendingMastership is used as synchronization variable for
               all mastership related changes. In this block, mastership (including
               role update) will have either occurred or not.
            */
        if (role == RoleState.MASTER) {
            // transition to MASTER complete, send messages
            sendMsgsOnChannel(msgs);
            return;
        }
        List<OFMessage> messages = messagesPendingMastership.get();
        if (messages != null) {
            // we are transitioning to MASTER, so add messages to queue
            messages.addAll(msgs);
            log.debug("Enqueue message for switch {}. queue size after is {}", dpid, messages.size());
        } else {
            // not transitioning to MASTER
            log.warn("Dropping message for switch {} (role: {}, connected: {}): {}", dpid, role, channel.isConnected(), msgs);
        }
    }
    // listen to outgoing control messages only if listeners are registered
    if (ofOutgoingMsgListener.size() != 0) {
        msgs.forEach(m -> {
            if (m.getType() == OFType.PACKET_OUT || m.getType() == OFType.FLOW_MOD || m.getType() == OFType.STATS_REQUEST) {
                executorMsgs.submit(new OFMessageHandler(dpid, m));
            }
        });
    }
}
#method_after
@Override
public final void sendMsg(List<OFMessage> msgs) {
    /*
           It is possible that in this block, we transition to SLAVE/EQUAL.
           If this is the case, the supplied messages will race with the
           RoleRequest message, and they could be rejected by the switch.
           In the interest of performance, we will not protect this block with
           a synchronization primitive, because the message would have just been
           dropped anyway.
        */
    if (role == RoleState.MASTER) {
        // fast path send when we are master
        sendMsgsOnChannel(msgs);
        return;
    }
    // check to see if mastership transition is in progress
    synchronized (messagesPendingMastership) {
        /*
               messagesPendingMastership is used as synchronization variable for
               all mastership related changes. In this block, mastership (including
               role update) will have either occurred or not.
            */
        if (role == RoleState.MASTER) {
            // transition to MASTER complete, send messages
            sendMsgsOnChannel(msgs);
            return;
        }
        List<OFMessage> messages = messagesPendingMastership.get();
        if (messages != null) {
            // we are transitioning to MASTER, so add messages to queue
            messages.addAll(msgs);
            log.debug("Enqueue message for switch {}. queue size after is {}", dpid, messages.size());
        } else {
            // not transitioning to MASTER
            log.warn("Dropping message for switch {} (role: {}, connected: {}): {}", dpid, role, channel.isConnected(), msgs);
        }
    }
    // listen to outgoing control messages only if listeners are registered
    if (ofOutgoingMsgListener.size() != 0) {
        msgs.forEach(m -> {
            if (m.getType() == OFType.PACKET_OUT || m.getType() == OFType.FLOW_MOD || m.getType() == OFType.STATS_REQUEST) {
                executorMsgs.execute(new OFMessageHandler(dpid, m));
            }
        });
    }
}
#end_block

#method_before
@Override
public DeviceDescription populateDescription(ISnmpSession session, DeviceDescription description) {
    NetworkDevice networkDevice = new NetworkDevice(CLASS_REGISTRY, session.getAddress().getHostAddress());
    try {
        session.walkDevice(networkDevice, Arrays.asList(new OID[] { CLASS_REGISTRY.getClassToOidMap().get(com.btisystems.mibbler.mibs.netsnmp.netsnmp.mib_2.System.class) }));
        com.btisystems.mibbler.mibs.netsnmp.netsnmp.mib_2.System systemTree = (com.btisystems.mibbler.mibs.netsnmp.netsnmp.mib_2.System) networkDevice.getRootObject().getEntity(CLASS_REGISTRY.getClassToOidMap().get(com.btisystems.mibbler.mibs.netsnmp.netsnmp.mib_2.System.class));
        if (systemTree != null) {
            // TODO SNMP sys-contacts may be verbose; ONOS-GUI doesn't abbreviate fields neatly;
            // so cut it here until supported in prop displayer
            String manufacturer = StringUtils.abbreviate(systemTree.getSysContact(), 20);
            return new DefaultDeviceDescription(description.deviceUri(), description.type(), manufacturer, UNKNOWN, UNKNOWN, UNKNOWN, description.chassisId());
        }
    } catch (IOException ex) {
        log.error("Error reading details for device {}.", session.getAddress(), ex);
    }
    return description;
}
#method_after
@Override
public DeviceDescription populateDescription(ISnmpSession session, DeviceDescription description) {
    NetworkDevice networkDevice = new NetworkDevice(CLASS_REGISTRY, session.getAddress().getHostAddress());
    try {
        session.walkDevice(networkDevice, Arrays.asList(new OID[] { CLASS_REGISTRY.getClassToOidMap().get(com.btisystems.mibbler.mibs.netsnmp.netsnmp.mib_2.System.class) }));
        com.btisystems.mibbler.mibs.netsnmp.netsnmp.mib_2.System systemTree = (com.btisystems.mibbler.mibs.netsnmp.netsnmp.mib_2.System) networkDevice.getRootObject().getEntity(CLASS_REGISTRY.getClassToOidMap().get(com.btisystems.mibbler.mibs.netsnmp.netsnmp.mib_2.System.class));
        if (systemTree != null) {
            // TODO SNMP sys-contacts may be verbose; ONOS-GUI doesn't abbreviate fields neatly;
            // so cut it here until supported in prop displayer
            String manufacturer = StringUtils.abbreviate(systemTree.getSysContact(), 20);
            return new DefaultDeviceDescription(description.deviceUri(), description.type(), manufacturer, UNKNOWN, UNKNOWN, UNKNOWN, description.chassisId(), description.annotations());
        }
    } catch (IOException ex) {
        log.error("Error reading details for device {}.", session.getAddress(), ex);
    }
    return description;
}
#end_block

#method_before
public static ThreadFactory groupedThreads(String groupName, String pattern) {
    return new ThreadFactoryBuilder().setThreadFactory(groupedThreadFactory(groupName)).setNameFormat(groupName.replace(GroupedThreadFactory.DELIMITER, "-") + "-" + pattern).setUncaughtExceptionHandler((t, e) -> log.error("Uncaught exception on " + t.getName(), e)).build();
}
#method_after
public static ThreadFactory groupedThreads(String groupName, String pattern) {
    return groupedThreads(groupName, pattern, log);
}
#end_block

#method_before
public static ThreadFactory groupedThreads(String groupName, String pattern, Logger logger) {
    return new ThreadFactoryBuilder().setThreadFactory(groupedThreadFactory(groupName)).setNameFormat(groupName.replace(GroupedThreadFactory.DELIMITER, "-") + "-" + pattern).setUncaughtExceptionHandler((t, e) -> logger.error("Uncaught exception on " + t.getName(), e)).build();
}
#method_after
public static ThreadFactory groupedThreads(String groupName, String pattern, Logger logger) {
    if (logger == null) {
        return groupedThreads(groupName, pattern);
    }
    return new ThreadFactoryBuilder().setThreadFactory(groupedThreadFactory(groupName)).setNameFormat(groupName.replace(GroupedThreadFactory.DELIMITER, "-") + "-" + pattern).setUncaughtExceptionHandler((t, e) -> logger.error("Uncaught exception on " + t.getName(), e)).build();
}
#end_block

#method_before
public void addBitInfo(YangBit bitInfo) throws DataModelException {
    if (!getBitSet().add(bitInfo)) {
        throw new DataModelException("YANG Bit already exists");
    }
}
#method_after
public void addBitInfo(YangBit bitInfo) throws DataModelException {
    if (!getBitSet().add(bitInfo)) {
        throw new DataModelException("YANG file error: Duplicate identifier detected, same as bit \"" + bitInfo.getBitName() + "\"");
    }
}
#end_block

#method_before
public static void processVersionEntry(TreeWalkListener listener, GeneratedYangParser.YangVersionStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, VERSION_DATA, ctx.INTEGER().getText(), ENTRY);
    Integer version = Integer.valueOf(ctx.INTEGER().getText());
    if (!isVersionValid(version)) {
        ParserException parserException = new ParserException("Input version not supported");
        parserException.setLine(ctx.INTEGER().getSymbol().getLine());
        parserException.setCharPosition(ctx.INTEGER().getSymbol().getCharPositionInLine());
        throw parserException;
    }
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getYangConstructType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                module.setVersion((byte) 1);
                break;
            }
        case SUB_MODULE_DATA:
            {
                YangSubModule subModule = (YangSubModule) tmpNode;
                subModule.setVersion((byte) 1);
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, VERSION_DATA, ctx.INTEGER().getText(), ENTRY));
    }
}
#method_after
public static void processVersionEntry(TreeWalkListener listener, GeneratedYangParser.YangVersionStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, VERSION_DATA, ctx.INTEGER().getText(), ENTRY);
    Integer version = Integer.valueOf(ctx.INTEGER().getText());
    if (!isVersionValid(version)) {
        ParserException parserException = new ParserException("YANG file error: Input version not supported");
        parserException.setLine(ctx.INTEGER().getSymbol().getLine());
        parserException.setCharPosition(ctx.INTEGER().getSymbol().getCharPositionInLine());
        throw parserException;
    }
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getYangConstructType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                module.setVersion((byte) 1);
                break;
            }
        case SUB_MODULE_DATA:
            {
                YangSubModule subModule = (YangSubModule) tmpNode;
                subModule.setVersion((byte) 1);
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, VERSION_DATA, ctx.INTEGER().getText(), ENTRY));
    }
}
#end_block

#method_before
public static void processListEntry(TreeWalkListener listener, GeneratedYangParser.ListStatementContext ctx) {
    YangNode curNode;
    checkStackIsNotEmpty(listener, MISSING_HOLDER, LIST_DATA, ctx.IDENTIFIER().getText(), ENTRY);
    boolean result = validateSubStatementsCardinality(ctx);
    if (!result) {
        throw new ParserException(constructListenerErrorMessage(INVALID_CARDINALITY, yangConstruct, "", ENTRY));
    }
    // Check for identifier collision
    int line = ctx.IDENTIFIER().getSymbol().getLine();
    int charPositionInLine = ctx.IDENTIFIER().getSymbol().getCharPositionInLine();
    String identifierName = ctx.IDENTIFIER().getText();
    detectCollidingChildUtil(listener, line, charPositionInLine, identifierName, LIST_DATA);
    YangList yangList = new YangList(YangNodeType.LIST_NODE);
    yangList.setName(ctx.IDENTIFIER().getText());
    /*
         * If "config" is not specified, the default is the same as the parent
         * schema node's "config" value.
         */
    if (ctx.configStatement().isEmpty()) {
        boolean parentConfig = ListenerValidation.getParentNodeConfig(listener);
        yangList.setConfig(parentConfig);
    }
    Parsable curData = listener.getParsedDataStack().peek();
    if ((curData instanceof YangModule) || (curData instanceof YangContainer) || (curData instanceof YangList)) {
        curNode = (YangNode) curData;
        try {
            curNode.addChild(yangList);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, LIST_DATA, ctx.IDENTIFIER().getText(), ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(yangList);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, LIST_DATA, ctx.IDENTIFIER().getText(), ENTRY));
    }
}
#method_after
public static void processListEntry(TreeWalkListener listener, GeneratedYangParser.ListStatementContext ctx) {
    YangNode curNode;
    checkStackIsNotEmpty(listener, MISSING_HOLDER, LIST_DATA, ctx.IDENTIFIER().getText(), ENTRY);
    // Validate sub statement cardinality.
    validateSubStatementsCardinality(ctx);
    // Check for identifier collision
    int line = ctx.IDENTIFIER().getSymbol().getLine();
    int charPositionInLine = ctx.IDENTIFIER().getSymbol().getCharPositionInLine();
    String identifierName = ctx.IDENTIFIER().getText();
    detectCollidingChildUtil(listener, line, charPositionInLine, identifierName, LIST_DATA);
    YangList yangList = new YangList(YangNodeType.LIST_NODE);
    yangList.setName(ctx.IDENTIFIER().getText());
    /*
         * If "config" is not specified, the default is the same as the parent
         * schema node's "config" value.
         */
    if (ctx.configStatement().isEmpty()) {
        boolean parentConfig = ListenerValidation.getParentNodeConfig(listener);
        yangList.setConfig(parentConfig);
    }
    Parsable curData = listener.getParsedDataStack().peek();
    if ((curData instanceof YangModule) || (curData instanceof YangContainer) || (curData instanceof YangList)) {
        curNode = (YangNode) curData;
        try {
            curNode.addChild(yangList);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, LIST_DATA, ctx.IDENTIFIER().getText(), ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(yangList);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, LIST_DATA, ctx.IDENTIFIER().getText(), ENTRY));
    }
}
#end_block

#method_before
private static boolean validateSubStatementsCardinality(GeneratedYangParser.ListStatementContext ctx) {
    if ((!ctx.keyStatement().isEmpty()) && (ctx.keyStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.KEY_DATA;
        return false;
    }
    if ((!ctx.configStatement().isEmpty()) && (ctx.configStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.CONFIG_DATA;
        return false;
    }
    if ((!ctx.maxElementsStatement().isEmpty()) && (ctx.maxElementsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.MAX_ELEMENT_DATA;
        return false;
    }
    if ((!ctx.minElementsStatement().isEmpty()) && (ctx.minElementsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.MIN_ELEMENT_DATA;
        return false;
    }
    if ((!ctx.descriptionStatement().isEmpty()) && (ctx.descriptionStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.DESCRIPTION_DATA;
        return false;
    }
    if ((!ctx.referenceStatement().isEmpty()) && (ctx.referenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.REFERENCE_DATA;
        return false;
    }
    if ((!ctx.statusStatement().isEmpty()) && (ctx.statusStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.STATUS_DATA;
        return false;
    }
    if (ctx.dataDefStatement().isEmpty()) {
        yangConstruct = YangConstructType.LIST_DATA;
        return false;
    }
    return true;
}
#method_after
private static void validateSubStatementsCardinality(GeneratedYangParser.ListStatementContext ctx) {
    validateCardinality(ctx.keyStatement(), KEY_DATA, LIST_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.configStatement(), CONFIG_DATA, LIST_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.maxElementsStatement(), MAX_ELEMENT_DATA, LIST_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.minElementsStatement(), MIN_ELEMENT_DATA, LIST_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.descriptionStatement(), DESCRIPTION_DATA, LIST_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.referenceStatement(), REFERENCE_DATA, LIST_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.statusStatement(), STATUS_DATA, LIST_DATA, ctx.IDENTIFIER().getText());
    validateCardinalityNonNull(ctx.dataDefStatement(), DATA_DEF_DATA, LIST_DATA, ctx.IDENTIFIER().getText());
// TODO when, typedef, grouping, unique
}
#end_block

#method_before
public static void processLeafEntry(TreeWalkListener listener, GeneratedYangParser.LeafStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, LEAF_DATA, ctx.IDENTIFIER().getText(), ENTRY);
    boolean result = validateSubStatementsCardinality(ctx);
    if (!result) {
        throw new ParserException(constructListenerErrorMessage(INVALID_CARDINALITY, yangConstruct, "", ENTRY));
    }
    // Check for identifier collision
    int line = ctx.IDENTIFIER().getSymbol().getLine();
    int charPositionInLine = ctx.IDENTIFIER().getSymbol().getCharPositionInLine();
    String identifierName = ctx.IDENTIFIER().getText();
    detectCollidingChildUtil(listener, line, charPositionInLine, identifierName, LEAF_DATA);
    YangLeaf leaf = new YangLeaf();
    leaf.setLeafName(ctx.IDENTIFIER().getText());
    Parsable tmpData = listener.getParsedDataStack().peek();
    YangLeavesHolder leaves;
    if (tmpData instanceof YangLeavesHolder) {
        leaves = (YangLeavesHolder) tmpData;
        leaves.addLeaf(leaf);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, LEAF_DATA, ctx.IDENTIFIER().getText(), ENTRY));
    }
    listener.getParsedDataStack().push(leaf);
}
#method_after
public static void processLeafEntry(TreeWalkListener listener, GeneratedYangParser.LeafStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, LEAF_DATA, ctx.IDENTIFIER().getText(), ENTRY);
    // Validate sub statement cardinality.
    validateSubStatementsCardinality(ctx);
    // Check for identifier collision
    int line = ctx.IDENTIFIER().getSymbol().getLine();
    int charPositionInLine = ctx.IDENTIFIER().getSymbol().getCharPositionInLine();
    String identifierName = ctx.IDENTIFIER().getText();
    detectCollidingChildUtil(listener, line, charPositionInLine, identifierName, LEAF_DATA);
    YangLeaf leaf = new YangLeaf();
    leaf.setLeafName(ctx.IDENTIFIER().getText());
    Parsable tmpData = listener.getParsedDataStack().peek();
    YangLeavesHolder leaves;
    if (tmpData instanceof YangLeavesHolder) {
        leaves = (YangLeavesHolder) tmpData;
        leaves.addLeaf(leaf);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, LEAF_DATA, ctx.IDENTIFIER().getText(), ENTRY));
    }
    listener.getParsedDataStack().push(leaf);
}
#end_block

#method_before
private static boolean validateSubStatementsCardinality(GeneratedYangParser.LeafStatementContext ctx) {
    if (ctx.typeStatement().isEmpty() || (ctx.typeStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.TYPE_DATA;
        return false;
    }
    if ((!ctx.unitsStatement().isEmpty()) && (ctx.unitsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.UNITS_DATA;
        return false;
    }
    if ((!ctx.configStatement().isEmpty()) && (ctx.configStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.CONFIG_DATA;
        return false;
    }
    if ((!ctx.mandatoryStatement().isEmpty()) && (ctx.mandatoryStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.MANDATORY_DATA;
        return false;
    }
    if ((!ctx.descriptionStatement().isEmpty()) && (ctx.descriptionStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.DESCRIPTION_DATA;
        return false;
    }
    if ((!ctx.referenceStatement().isEmpty()) && (ctx.referenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.REFERENCE_DATA;
        return false;
    }
    if ((!ctx.statusStatement().isEmpty()) && (ctx.statusStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.STATUS_DATA;
        return false;
    }
    return true;
}
#method_after
private static void validateSubStatementsCardinality(GeneratedYangParser.LeafStatementContext ctx) {
    validateCardinalityEqualsOne(ctx.typeStatement(), TYPE_DATA, LEAF_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.unitsStatement(), UNITS_DATA, LEAF_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.configStatement(), CONFIG_DATA, LEAF_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.mandatoryStatement(), MANDATORY_DATA, LEAF_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.descriptionStatement(), DESCRIPTION_DATA, LEAF_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.referenceStatement(), REFERENCE_DATA, LEAF_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.statusStatement(), STATUS_DATA, LEAF_DATA, ctx.IDENTIFIER().getText());
// TODO when.
}
#end_block

#method_before
public static void processNamespaceEntry(TreeWalkListener listener, GeneratedYangParser.NamespaceStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, NAMESPACE_DATA, ctx.string().getText(), ENTRY);
    if (!validateUriValue(ctx.string().getText())) {
        ParserException parserException = new ParserException("Invalid namespace URI");
        parserException.setLine(ctx.string().STRING(0).getSymbol().getLine());
        parserException.setCharPosition(ctx.string().STRING(0).getSymbol().getCharPositionInLine());
        throw parserException;
    }
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getYangConstructType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                YangNameSpace uri = new YangNameSpace();
                uri.setUri(ctx.string().getText());
                module.setNameSpace(uri);
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, NAMESPACE_DATA, ctx.string().getText(), ENTRY));
    }
}
#method_after
public static void processNamespaceEntry(TreeWalkListener listener, GeneratedYangParser.NamespaceStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, NAMESPACE_DATA, ctx.string().getText(), ENTRY);
    if (!validateUriValue(ctx.string().getText())) {
        ParserException parserException = new ParserException("YANG file error: Invalid namespace URI");
        parserException.setLine(ctx.string().STRING(0).getSymbol().getLine());
        parserException.setCharPosition(ctx.string().STRING(0).getSymbol().getCharPositionInLine());
        throw parserException;
    }
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getYangConstructType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                YangNameSpace uri = new YangNameSpace();
                uri.setUri(ctx.string().getText());
                module.setNameSpace(uri);
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, NAMESPACE_DATA, ctx.string().getText(), ENTRY));
    }
}
#end_block

#method_before
/**
 * Checks parsed data stack is empty.
 *
 * @param listener Listener's object.
 * @param errorType error type needs to be set in error message.
 * @param yangConstructType type of parsable data in which error occurred.
 * @param parsableDataTypeName name of parsable data type in which error
 *            occurred.
 * @param errorLocation location where error occurred.
 */
public static void checkStackIsEmpty(TreeWalkListener listener, ListenerErrorType errorType, YangConstructType yangConstructType, String parsableDataTypeName, ListenerErrorLocation errorLocation) {
    if (!listener.getParsedDataStack().empty()) {
        /*
             * If stack is empty it indicates error condition, value of
             * parsableDataTypeName will be null in case there is no name
             * attached to parsable data type.
             */
        String message = constructListenerErrorMessage(errorType, yangConstructType, parsableDataTypeName, errorLocation);
        throw new ParserException(message);
    }
}
#method_after
public static void checkStackIsEmpty(TreeWalkListener listener, ListenerErrorType errorType, YangConstructType yangConstructType, String parsableDataTypeName, ListenerErrorLocation errorLocation) {
    if (!listener.getParsedDataStack().empty()) {
        /*
             * If stack is empty it indicates error condition, value of
             * parsableDataTypeName will be null in case there is no name
             * attached to parsable data type.
             */
        String message = constructListenerErrorMessage(errorType, yangConstructType, parsableDataTypeName, errorLocation);
        throw new ParserException(message);
    }
}
#end_block

#method_before
@Override
public void detectSelfCollision(String identifierName, YangConstructType dataType) throws DataModelException {
    if (this.getName().equals(identifierName)) {
        throw new DataModelException("YANG File Error: Identifier collision detected in list \"" + this.getName() + "\"");
    }
}
#method_after
@Override
public void detectSelfCollision(String identifierName, YangConstructType dataType) throws DataModelException {
    if (this.getName().equals(identifierName)) {
        throw new DataModelException("YANG file error: Duplicate input identifier detected, same as list \"" + this.getName() + "\"");
    }
}
#end_block

#method_before
private static boolean isBitPositionValid(TreeWalkListener listener, GeneratedYangParser.PositionStatementContext ctx) {
    Parsable bitNode = listener.getParsedDataStack().pop();
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, POSITION_DATA, ctx.INTEGER().getText(), ENTRY);
    if (Integer.valueOf(ctx.INTEGER().getText()) < 0) {
        errMsg = "Negative value of position is invalid";
        listener.getParsedDataStack().push(bitNode);
        return false;
    }
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getYangConstructType()) {
        case BITS_DATA:
            {
                YangBits yangBits = (YangBits) tmpNode;
                for (YangBit curBit : yangBits.getBitSet()) {
                    if (Integer.valueOf(ctx.INTEGER().getText()) == curBit.getPosition()) {
                        errMsg = "Duplicate value of position is invalid";
                        listener.getParsedDataStack().push(bitNode);
                        return false;
                    }
                }
                listener.getParsedDataStack().push(bitNode);
                return true;
            }
        default:
            listener.getParsedDataStack().push(bitNode);
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, POSITION_DATA, ctx.INTEGER().getText(), ENTRY));
    }
}
#method_after
private static boolean isBitPositionValid(TreeWalkListener listener, GeneratedYangParser.PositionStatementContext ctx) {
    Parsable bitNode = listener.getParsedDataStack().pop();
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, POSITION_DATA, ctx.INTEGER().getText(), ENTRY);
    if (Integer.valueOf(ctx.INTEGER().getText()) < 0) {
        errMsg = "YANG file error: Negative value of position is invalid.";
        listener.getParsedDataStack().push(bitNode);
        return false;
    }
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getYangConstructType()) {
        case BITS_DATA:
            {
                YangBits yangBits = (YangBits) tmpNode;
                for (YangBit curBit : yangBits.getBitSet()) {
                    if (Integer.valueOf(ctx.INTEGER().getText()) == curBit.getPosition()) {
                        errMsg = "YANG file error: Duplicate value of position is invalid.";
                        listener.getParsedDataStack().push(bitNode);
                        return false;
                    }
                }
                listener.getParsedDataStack().push(bitNode);
                return true;
            }
        default:
            listener.getParsedDataStack().push(bitNode);
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, POSITION_DATA, ctx.INTEGER().getText(), ENTRY));
    }
}
#end_block

#method_before
public static void processRevisionDateEntry(TreeWalkListener listener, GeneratedYangParser.RevisionDateStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, REVISION_DATE_DATA, ctx.DATE_ARG().getText(), ENTRY);
    if (!isDateValid(ctx.DATE_ARG().getText())) {
        ParserException parserException = new ParserException("Input date is not correct");
        parserException.setLine(ctx.DATE_ARG().getSymbol().getLine());
        parserException.setCharPosition(ctx.DATE_ARG().getSymbol().getCharPositionInLine());
        throw parserException;
    }
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getYangConstructType()) {
        case IMPORT_DATA:
            {
                YangImport importNode = (YangImport) tmpNode;
                importNode.setRevision(ctx.DATE_ARG().getText());
                break;
            }
        case INCLUDE_DATA:
            {
                YangInclude includeNode = (YangInclude) tmpNode;
                includeNode.setRevision(ctx.DATE_ARG().getText());
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, REVISION_DATE_DATA, ctx.DATE_ARG().getText(), ENTRY));
    }
}
#method_after
public static void processRevisionDateEntry(TreeWalkListener listener, GeneratedYangParser.RevisionDateStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, REVISION_DATE_DATA, ctx.DATE_ARG().getText(), ENTRY);
    if (!isDateValid(ctx.DATE_ARG().getText())) {
        ParserException parserException = new ParserException("YANG file error: Input date is not correct");
        parserException.setLine(ctx.DATE_ARG().getSymbol().getLine());
        parserException.setCharPosition(ctx.DATE_ARG().getSymbol().getCharPositionInLine());
        throw parserException;
    }
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getYangConstructType()) {
        case IMPORT_DATA:
            {
                YangImport importNode = (YangImport) tmpNode;
                importNode.setRevision(ctx.DATE_ARG().getText());
                break;
            }
        case INCLUDE_DATA:
            {
                YangInclude includeNode = (YangInclude) tmpNode;
                includeNode.setRevision(ctx.DATE_ARG().getText());
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, REVISION_DATE_DATA, ctx.DATE_ARG().getText(), ENTRY));
    }
}
#end_block

#method_before
public static void detectCollidingChildUtil(String identifierName, YangConstructType dataType, YangNode node) throws DataModelException {
    if (((YangLeavesHolder) node).getListOfLeaf() != null) {
        for (YangLeaf leaf : ((YangLeavesHolder) node).getListOfLeaf()) {
            if (leaf.getLeafName().equals(identifierName)) {
                throw new DataModelException("Identifier collides with leaf \"" + leaf.getLeafName() + "\"");
            }
        }
    }
    if (((YangLeavesHolder) node).getListOfLeafList() != null) {
        for (YangLeafList leafList : ((YangLeavesHolder) node).getListOfLeafList()) {
            if (leafList.getLeafName().equals(identifierName)) {
                throw new DataModelException("Identifier collides with leaf list \"" + leafList.getLeafName() + "\"");
            }
        }
    }
    node = node.getChild();
    while ((node != null)) {
        if (node instanceof CollisionDetector) {
            ((CollisionDetector) node).detectSelfCollision(identifierName, dataType);
        }
        node = node.getNextSibling();
    }
}
#method_after
public static void detectCollidingChildUtil(String identifierName, YangConstructType dataType, YangNode node) throws DataModelException {
    if (((YangLeavesHolder) node).getListOfLeaf() != null) {
        for (YangLeaf leaf : ((YangLeavesHolder) node).getListOfLeaf()) {
            if (leaf.getLeafName().equals(identifierName)) {
                throw new DataModelException("YANG file error: Duplicate input identifier detected, same as leaf \"" + leaf.getLeafName() + "\"");
            }
        }
    }
    if (((YangLeavesHolder) node).getListOfLeafList() != null) {
        for (YangLeafList leafList : ((YangLeavesHolder) node).getListOfLeafList()) {
            if (leafList.getLeafName().equals(identifierName)) {
                throw new DataModelException("YANG file error: Duplicate input identifier detected, same as leaf " + "list \"" + leafList.getLeafName() + "\"");
            }
        }
    }
    node = node.getChild();
    while ((node != null)) {
        if (node instanceof CollisionDetector) {
            ((CollisionDetector) node).detectSelfCollision(identifierName, dataType);
        }
        node = node.getNextSibling();
    }
}
#end_block

#method_before
public static void processContainerEntry(TreeWalkListener listener, GeneratedYangParser.ContainerStatementContext ctx) {
    YangNode parentNode;
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, CONTAINER_DATA, ctx.IDENTIFIER().getText(), ENTRY);
    boolean result = validateSubStatementsCardinality(ctx);
    if (!result) {
        throw new ParserException(constructListenerErrorMessage(INVALID_CARDINALITY, yangConstruct, "", ENTRY));
    }
    // Check for identifier collision
    int line = ctx.IDENTIFIER().getSymbol().getLine();
    int charPositionInLine = ctx.IDENTIFIER().getSymbol().getCharPositionInLine();
    String identifierName = ctx.IDENTIFIER().getText();
    detectCollidingChildUtil(listener, line, charPositionInLine, identifierName, CONTAINER_DATA);
    YangContainer container = new YangContainer();
    container.setName(ctx.IDENTIFIER().getText());
    /*
         * If "config" is not specified, the default is the same as the parent
         * schema node's "config" value.
         */
    if (ctx.configStatement().isEmpty()) {
        boolean parentConfig = ListenerValidation.getParentNodeConfig(listener);
        container.setConfig(parentConfig);
    }
    Parsable curData = listener.getParsedDataStack().peek();
    if ((curData instanceof YangModule) || (curData instanceof YangContainer) || (curData instanceof YangList)) {
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(container);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, CONTAINER_DATA, ctx.IDENTIFIER().getText(), ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(container);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, CONTAINER_DATA, ctx.IDENTIFIER().getText(), ENTRY));
    }
}
#method_after
public static void processContainerEntry(TreeWalkListener listener, GeneratedYangParser.ContainerStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, CONTAINER_DATA, ctx.IDENTIFIER().getText(), ENTRY);
    // Validate sub statement cardinality.
    validateSubStatementsCardinality(ctx);
    // Check for identifier collision
    int line = ctx.IDENTIFIER().getSymbol().getLine();
    int charPositionInLine = ctx.IDENTIFIER().getSymbol().getCharPositionInLine();
    String identifierName = ctx.IDENTIFIER().getText();
    detectCollidingChildUtil(listener, line, charPositionInLine, identifierName, CONTAINER_DATA);
    YangContainer container = new YangContainer();
    container.setName(ctx.IDENTIFIER().getText());
    /*
         * If "config" is not specified, the default is the same as the parent
         * schema node's "config" value.
         */
    if (ctx.configStatement().isEmpty()) {
        boolean parentConfig = ListenerValidation.getParentNodeConfig(listener);
        container.setConfig(parentConfig);
    }
    Parsable curData = listener.getParsedDataStack().peek();
    if ((curData instanceof YangModule) || (curData instanceof YangContainer) || (curData instanceof YangList)) {
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(container);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, CONTAINER_DATA, ctx.IDENTIFIER().getText(), ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(container);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, CONTAINER_DATA, ctx.IDENTIFIER().getText(), ENTRY));
    }
}
#end_block

#method_before
private static boolean validateSubStatementsCardinality(GeneratedYangParser.ContainerStatementContext ctx) {
    if ((!ctx.presenceStatement().isEmpty()) && (ctx.presenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.PRESENCE_DATA;
        return false;
    }
    if ((!ctx.configStatement().isEmpty()) && (ctx.configStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.CONFIG_DATA;
        return false;
    }
    if ((!ctx.descriptionStatement().isEmpty()) && (ctx.descriptionStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.DESCRIPTION_DATA;
        return false;
    }
    if ((!ctx.referenceStatement().isEmpty()) && (ctx.referenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.REFERENCE_DATA;
        return false;
    }
    if ((!ctx.statusStatement().isEmpty()) && (ctx.statusStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.STATUS_DATA;
        return false;
    }
    return true;
}
#method_after
private static void validateSubStatementsCardinality(GeneratedYangParser.ContainerStatementContext ctx) {
    validateCardinality(ctx.presenceStatement(), PRESENCE_DATA, CONTAINER_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.configStatement(), CONFIG_DATA, CONTAINER_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.descriptionStatement(), DESCRIPTION_DATA, CONTAINER_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.referenceStatement(), REFERENCE_DATA, CONTAINER_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.statusStatement(), STATUS_DATA, CONTAINER_DATA, ctx.IDENTIFIER().getText());
// TODO when, grouping, typedef.
}
#end_block

#method_before
public static void processTypeDefEntry(TreeWalkListener listener, GeneratedYangParser.TypedefStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, TYPEDEF_DATA, ctx.IDENTIFIER().getText(), ENTRY);
    boolean result = validateSubStatementsCardinality(ctx);
    if (!result) {
        throw new ParserException(constructListenerErrorMessage(INVALID_CARDINALITY, yangConstruct, "", ENTRY));
    }
    /*
         * Create a derived type information, the base type must be set in type
         * listener.
         */
    YangType<YangDerivedType> derivedType = new YangType<YangDerivedType>();
    derivedType.setDataType(YangDataTypes.DERIVED);
    derivedType.setDataTypeName(ctx.IDENTIFIER().getText());
    YangTypeDef typeDefNode = new YangTypeDef();
    typeDefNode.setDerivedType(derivedType);
    Parsable curData = listener.getParsedDataStack().peek();
    if ((curData instanceof YangModule) | (curData instanceof YangSubModule) | (curData instanceof YangContainer) | (curData instanceof YangList)) {
        /*
             * TODO YangGrouping, YangRpc, YangInput, YangOutput, Notification.
             */
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(typeDefNode);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, TYPEDEF_DATA, ctx.IDENTIFIER().getText(), ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(typeDefNode);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPEDEF_DATA, ctx.IDENTIFIER().getText(), ENTRY));
    }
}
#method_after
public static void processTypeDefEntry(TreeWalkListener listener, GeneratedYangParser.TypedefStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, TYPEDEF_DATA, ctx.IDENTIFIER().getText(), ENTRY);
    // Validate sub statement cardinality.
    validateSubStatementsCardinality(ctx);
    /*
         * Create a derived type information, the base type must be set in type
         * listener.
         */
    YangType<YangDerivedType> derivedType = new YangType<YangDerivedType>();
    derivedType.setDataType(YangDataTypes.DERIVED);
    derivedType.setDataTypeName(ctx.IDENTIFIER().getText());
    YangTypeDef typeDefNode = new YangTypeDef();
    typeDefNode.setDerivedType(derivedType);
    Parsable curData = listener.getParsedDataStack().peek();
    if ((curData instanceof YangModule) | (curData instanceof YangSubModule) | (curData instanceof YangContainer) | (curData instanceof YangList)) {
        /*
             * TODO YangGrouping, YangRpc, YangInput, YangOutput, Notification.
             */
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(typeDefNode);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, TYPEDEF_DATA, ctx.IDENTIFIER().getText(), ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(typeDefNode);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPEDEF_DATA, ctx.IDENTIFIER().getText(), ENTRY));
    }
}
#end_block

#method_before
private static boolean validateSubStatementsCardinality(GeneratedYangParser.TypedefStatementContext ctx) {
    if ((!ctx.unitsStatement().isEmpty()) && (ctx.unitsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = UNITS_DATA;
        return false;
    }
    if ((!ctx.defaultStatement().isEmpty()) && (ctx.defaultStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = DEFAULT_DATA;
        return false;
    }
    if (ctx.typeStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY) {
        yangConstruct = TYPE_DATA;
        return false;
    }
    if ((!ctx.descriptionStatement().isEmpty()) && (ctx.descriptionStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = DESCRIPTION_DATA;
        return false;
    }
    if ((!ctx.referenceStatement().isEmpty()) && (ctx.referenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = REFERENCE_DATA;
        return false;
    }
    if ((!ctx.statusStatement().isEmpty()) && (ctx.statusStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = STATUS_DATA;
        return false;
    }
    return true;
}
#method_after
private static void validateSubStatementsCardinality(GeneratedYangParser.TypedefStatementContext ctx) {
    validateCardinality(ctx.unitsStatement(), UNITS_DATA, TYPEDEF_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.defaultStatement(), DEFAULT_DATA, TYPEDEF_DATA, ctx.IDENTIFIER().getText());
    validateCardinalityEqualsOne(ctx.typeStatement(), TYPE_DATA, TYPEDEF_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.descriptionStatement(), DESCRIPTION_DATA, TYPEDEF_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.referenceStatement(), REFERENCE_DATA, TYPEDEF_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.statusStatement(), STATUS_DATA, TYPEDEF_DATA, ctx.IDENTIFIER().getText());
}
#end_block

#method_before
@Test
public void processLeafConfigInvalidCardinality() throws IOException, ParserException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("Internal parser error detected: Invalid cardinality in config before processing.");
    YangNode node = manager.getDataModel("src/test/resources/LeafConfigInvalidCardinality.yang");
}
#method_after
@Test
public void processLeafConfigInvalidCardinality() throws IOException, ParserException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("YANG file error: Invalid cardinality of config in leaf \"invalid-interval\".");
    YangNode node = manager.getDataModel("src/test/resources/LeafConfigInvalidCardinality.yang");
}
#end_block

#method_before
@Test
public void processLeafMandatoryInvalidCardinality() throws IOException, ParserException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("Internal parser error detected: Invalid cardinality in mandatory before processing.");
    YangNode node = manager.getDataModel("src/test/resources/LeafMandatoryInvalidCardinality.yang");
}
#method_after
@Test
public void processLeafMandatoryInvalidCardinality() throws IOException, ParserException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("YANG file error: Invalid cardinality of mandatory in leaf \"invalid-interval\".");
    YangNode node = manager.getDataModel("src/test/resources/LeafMandatoryInvalidCardinality.yang");
}
#end_block

#method_before
@Override
public void detectSelfCollision(String identifierName, YangConstructType dataType) throws DataModelException {
    if (this.getName().equals(identifierName)) {
        throw new DataModelException("YANG File Error: Identifier collision detected in container \"" + this.getName() + "\"");
    }
}
#method_after
@Override
public void detectSelfCollision(String identifierName, YangConstructType dataType) throws DataModelException {
    if (this.getName().equals(identifierName)) {
        throw new DataModelException("YANG file error: Duplicate input identifier detected, same as container \"" + this.getName() + "\"");
    }
}
#end_block

#method_before
public static void processRevisionEntry(TreeWalkListener listener, GeneratedYangParser.RevisionStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, REVISION_DATA, ctx.DATE_ARG().getText(), ENTRY);
    // value.
    if (!validateRevision(listener, ctx)) {
        return;
    // TODO to be implemented.
    }
    if (!isDateValid(ctx.DATE_ARG().getText())) {
        ParserException parserException = new ParserException("Input date is not correct");
        parserException.setLine(ctx.DATE_ARG().getSymbol().getLine());
        parserException.setCharPosition(ctx.DATE_ARG().getSymbol().getCharPositionInLine());
        throw parserException;
    }
    YangRevision revisionNode = new YangRevision();
    revisionNode.setRevDate(ctx.DATE_ARG().getText());
    listener.getParsedDataStack().push(revisionNode);
}
#method_after
public static void processRevisionEntry(TreeWalkListener listener, GeneratedYangParser.RevisionStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, REVISION_DATA, ctx.DATE_ARG().getText(), ENTRY);
    // value.
    if (!validateRevision(listener, ctx)) {
        return;
    // TODO to be implemented.
    }
    if (!isDateValid(ctx.DATE_ARG().getText())) {
        ParserException parserException = new ParserException("YANG file error: Input date is not correct");
        parserException.setLine(ctx.DATE_ARG().getSymbol().getLine());
        parserException.setCharPosition(ctx.DATE_ARG().getSymbol().getCharPositionInLine());
        throw parserException;
    }
    YangRevision revisionNode = new YangRevision();
    revisionNode.setRevDate(ctx.DATE_ARG().getText());
    listener.getParsedDataStack().push(revisionNode);
}
#end_block

#method_before
@Test
public void processContainerSubStatementCardinality() throws IOException, ParserException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("Internal parser error detected: Invalid cardinality in reference before processing.");
    YangNode node = manager.getDataModel("src/test/resources/ContainerSubStatementCardinality.yang");
}
#method_after
@Test
public void processContainerSubStatementCardinality() throws IOException, ParserException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("YANG file error: Invalid cardinality of reference in container \"valid\".");
    YangNode node = manager.getDataModel("src/test/resources/ContainerSubStatementCardinality.yang");
}
#end_block

#method_before
public static void processLeafListEntry(TreeWalkListener listener, GeneratedYangParser.LeafListStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, LEAF_LIST_DATA, ctx.IDENTIFIER().getText(), ENTRY);
    boolean result = validateSubStatementsCardinality(ctx);
    if (!result) {
        throw new ParserException(constructListenerErrorMessage(INVALID_CARDINALITY, yangConstruct, "", ENTRY));
    }
    // Check for identifier collision
    int line = ctx.IDENTIFIER().getSymbol().getLine();
    int charPositionInLine = ctx.IDENTIFIER().getSymbol().getCharPositionInLine();
    String identifierName = ctx.IDENTIFIER().getText();
    detectCollidingChildUtil(listener, line, charPositionInLine, identifierName, LEAF_LIST_DATA);
    YangLeafList leafList = new YangLeafList();
    leafList.setLeafName(ctx.IDENTIFIER().getText());
    Parsable tmpData = listener.getParsedDataStack().peek();
    YangLeavesHolder leaves;
    if (tmpData instanceof YangLeavesHolder) {
        leaves = (YangLeavesHolder) tmpData;
        leaves.addLeafList(leafList);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, LEAF_LIST_DATA, ctx.IDENTIFIER().getText(), ENTRY));
    }
    listener.getParsedDataStack().push(leafList);
}
#method_after
public static void processLeafListEntry(TreeWalkListener listener, GeneratedYangParser.LeafListStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, LEAF_LIST_DATA, ctx.IDENTIFIER().getText(), ENTRY);
    // Validate sub statement cardinality.
    validateSubStatementsCardinality(ctx);
    // Check for identifier collision
    int line = ctx.IDENTIFIER().getSymbol().getLine();
    int charPositionInLine = ctx.IDENTIFIER().getSymbol().getCharPositionInLine();
    String identifierName = ctx.IDENTIFIER().getText();
    detectCollidingChildUtil(listener, line, charPositionInLine, identifierName, LEAF_LIST_DATA);
    YangLeafList leafList = new YangLeafList();
    leafList.setLeafName(ctx.IDENTIFIER().getText());
    Parsable tmpData = listener.getParsedDataStack().peek();
    YangLeavesHolder leaves;
    if (tmpData instanceof YangLeavesHolder) {
        leaves = (YangLeavesHolder) tmpData;
        leaves.addLeafList(leafList);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, LEAF_LIST_DATA, ctx.IDENTIFIER().getText(), ENTRY));
    }
    listener.getParsedDataStack().push(leafList);
}
#end_block

#method_before
private static boolean validateSubStatementsCardinality(GeneratedYangParser.LeafListStatementContext ctx) {
    if (ctx.typeStatement().isEmpty() || (ctx.typeStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.TYPE_DATA;
        return false;
    }
    if ((!ctx.unitsStatement().isEmpty()) && (ctx.unitsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.UNITS_DATA;
        return false;
    }
    if ((!ctx.configStatement().isEmpty()) && (ctx.configStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.CONFIG_DATA;
        return false;
    }
    if ((!ctx.maxElementsStatement().isEmpty()) && (ctx.maxElementsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.MAX_ELEMENT_DATA;
        return false;
    }
    if ((!ctx.minElementsStatement().isEmpty()) && (ctx.minElementsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.MIN_ELEMENT_DATA;
        return false;
    }
    if ((!ctx.descriptionStatement().isEmpty()) && (ctx.descriptionStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.DESCRIPTION_DATA;
        return false;
    }
    if ((!ctx.referenceStatement().isEmpty()) && (ctx.referenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.REFERENCE_DATA;
        return false;
    }
    if ((!ctx.statusStatement().isEmpty()) && (ctx.statusStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = YangConstructType.STATUS_DATA;
        return false;
    }
    return true;
}
#method_after
private static void validateSubStatementsCardinality(GeneratedYangParser.LeafListStatementContext ctx) {
    validateCardinalityEqualsOne(ctx.typeStatement(), TYPE_DATA, LEAF_LIST_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.unitsStatement(), UNITS_DATA, LEAF_LIST_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.configStatement(), CONFIG_DATA, LEAF_LIST_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.maxElementsStatement(), MAX_ELEMENT_DATA, LEAF_LIST_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.minElementsStatement(), MIN_ELEMENT_DATA, LEAF_LIST_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.descriptionStatement(), DESCRIPTION_DATA, LEAF_LIST_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.referenceStatement(), REFERENCE_DATA, LEAF_LIST_DATA, ctx.IDENTIFIER().getText());
    validateCardinality(ctx.statusStatement(), STATUS_DATA, LEAF_LIST_DATA, ctx.IDENTIFIER().getText());
// TODO ordered by
}
#end_block

#method_before
@Test
public void membership() {
    Region r = store.createRegion(RID1, "R1", METRO, MASTERS);
    assertTrue("no devices expected", store.getRegionDevices(RID1).isEmpty());
    assertNull("no region expected", store.getRegionForDevice(DID1));
    store.addDevices(RID1, ImmutableSet.of(DID1, DID2));
    Set<DeviceId> deviceIds = store.getRegionDevices(RID1);
    assertEquals("incorrect device count", 2, deviceIds.size());
    assertTrue("missing d1", deviceIds.contains(DID1));
    assertTrue("missing d2", deviceIds.contains(DID2));
    assertEquals("wrong region", r, store.getRegionForDevice(DID1));
    store.addDevices(RID1, ImmutableSet.of(DID3));
    deviceIds = store.getRegionDevices(RID1);
    assertEquals("incorrect device count", 3, deviceIds.size());
    assertTrue("missing d3", deviceIds.contains(DID3));
    store.addDevices(RID1, ImmutableSet.of(DID3, DID1));
    deviceIds = store.getRegionDevices(RID1);
    assertEquals("incorrect device count", 3, deviceIds.size());
    // Test adding DID3 to RID2 but it is already in RID1.
    // DID3 will be removed from RID1 and added to RID2.
    store.addDevices(RID2, ImmutableSet.of(DID3));
    deviceIds = store.getRegionDevices(RID1);
    assertEquals("incorrect device count", 2, deviceIds.size());
    deviceIds = store.getRegionDevices(RID2);
    assertEquals("incorrect device count", 1, deviceIds.size());
    store.removeDevices(RID1, ImmutableSet.of(DID2, DID3));
    deviceIds = store.getRegionDevices(RID1);
    assertEquals("incorrect device count", 1, deviceIds.size());
    assertTrue("missing d1", deviceIds.contains(DID1));
    store.removeDevices(RID1, ImmutableSet.of(DID1, DID3));
    assertTrue("no devices expected", store.getRegionDevices(RID1).isEmpty());
    store.removeDevices(RID1, ImmutableSet.of(DID2));
    assertTrue("no devices expected", store.getRegionDevices(RID1).isEmpty());
}
#method_after
@Test
public void membership() {
    Region r = store.createRegion(RID1, "R1", METRO, MASTERS);
    assertTrue("no devices expected", store.getRegionDevices(RID1).isEmpty());
    assertNull("no region expected", store.getRegionForDevice(DID1));
    store.addDevices(RID1, ImmutableSet.of(DID1, DID2));
    Set<DeviceId> deviceIds = store.getRegionDevices(RID1);
    assertEquals("incorrect device count", 2, deviceIds.size());
    assertTrue("missing d1", deviceIds.contains(DID1));
    assertTrue("missing d2", deviceIds.contains(DID2));
    assertEquals("wrong region", r, store.getRegionForDevice(DID1));
    store.addDevices(RID1, ImmutableSet.of(DID3));
    deviceIds = store.getRegionDevices(RID1);
    assertEquals("incorrect device count", 3, deviceIds.size());
    assertTrue("missing d3", deviceIds.contains(DID3));
    store.addDevices(RID1, ImmutableSet.of(DID3, DID1));
    deviceIds = store.getRegionDevices(RID1);
    assertEquals("incorrect device count", 3, deviceIds.size());
    // Test adding DID3 to RID2 but it is already in RID1.
    // DID3 will be removed from RID1 and added to RID2.
    Region r2 = store.createRegion(RID2, "R2", CAMPUS, MASTERS);
    store.addDevices(RID2, ImmutableSet.of(DID3));
    deviceIds = store.getRegionDevices(RID1);
    assertEquals("incorrect device count", 2, deviceIds.size());
    deviceIds = store.getRegionDevices(RID2);
    assertEquals("incorrect device count", 1, deviceIds.size());
    store.removeDevices(RID1, ImmutableSet.of(DID2, DID3));
    deviceIds = store.getRegionDevices(RID1);
    assertEquals("incorrect device count", 1, deviceIds.size());
    assertTrue("missing d1", deviceIds.contains(DID1));
    store.removeDevices(RID1, ImmutableSet.of(DID1, DID3));
    assertTrue("no devices expected", store.getRegionDevices(RID1).isEmpty());
    store.removeDevices(RID1, ImmutableSet.of(DID2));
    assertTrue("no devices expected", store.getRegionDevices(RID1).isEmpty());
}
#end_block

#method_before
private String addInterfaceToVlanBuilder(String intf, VlanId vlanId) {
    StringBuilder rpc = new StringBuilder("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
    rpc.append("<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" ");
    rpc.append("xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">");
    rpc.append("<edit-config>");
    rpc.append("<target>");
    rpc.append("<running/>");
    rpc.append("</target>");
    rpc.append("<config>");
    rpc.append("<xml-config-data>");
    rpc.append("<Device-Configuration><interface><Param>");
    rpc.append(intf);
    rpc.append("</Param>");
    rpc.append("<ConfigIf-Configuration>");
    rpc.append("<switchport><access><vlan><VLANIDVLANPortAccessMode>");
    rpc.append(vlanId);
    rpc.append("</VLANIDVLANPortAccessMode></vlan></access></switchport>");
    rpc.append("<switchport><mode><access/></mode></switchport>");
    rpc.append("</ConfigIf-Configuration>");
    rpc.append("</interface>");
    rpc.append("</Device-Configuration>");
    rpc.append("</xml-config-data>");
    rpc.append("</config>");
    rpc.append("</edit-config>");
    rpc.append("</rpc>");
    return rpc.toString();
}
#method_after
private String addInterfaceToVlanBuilder(String intf, VlanId vlanId) {
    StringBuilder rpc = new StringBuilder("<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" ");
    rpc.append("xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">");
    rpc.append("<edit-config>");
    rpc.append("<target>");
    rpc.append("<running/>");
    rpc.append("</target>");
    rpc.append("<config>");
    rpc.append("<xml-config-data>");
    rpc.append("<Device-Configuration><interface><Param>");
    rpc.append(intf);
    rpc.append("</Param>");
    rpc.append("<ConfigIf-Configuration>");
    rpc.append("<switchport><access><vlan><VLANIDVLANPortAccessMode>");
    rpc.append(vlanId);
    rpc.append("</VLANIDVLANPortAccessMode></vlan></access></switchport>");
    rpc.append("<switchport><mode><access/></mode></switchport>");
    rpc.append("</ConfigIf-Configuration>");
    rpc.append("</interface>");
    rpc.append("</Device-Configuration>");
    rpc.append("</xml-config-data>");
    rpc.append("</config>");
    rpc.append("</edit-config>");
    rpc.append("</rpc>");
    return rpc.toString();
}
#end_block

#method_before
private String removeInterfaceFromVlanBuilder(String intf, VlanId vlanId) {
    StringBuilder rpc = new StringBuilder("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
    rpc.append("<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" ");
    rpc.append("xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">");
    rpc.append("<edit-config>");
    rpc.append("<target>");
    rpc.append("<running/>");
    rpc.append("</target>");
    rpc.append("<config>");
    rpc.append("<xml-config-data>");
    rpc.append("<Device-Configuration><interface><Param>");
    rpc.append(intf);
    rpc.append("</Param>");
    rpc.append("<ConfigIf-Configuration>");
    rpc.append("<switchport operation=\"delete\"><access><vlan><VLANIDVLANPortAccessMode>");
    rpc.append(vlanId);
    rpc.append("</VLANIDVLANPortAccessMode></vlan></access></switchport>");
    rpc.append("<switchport operation=\"delete\"><mode><access/></mode></switchport>");
    rpc.append("</ConfigIf-Configuration>");
    rpc.append("</interface>");
    rpc.append("</Device-Configuration>");
    rpc.append("</xml-config-data>");
    rpc.append("</config>");
    rpc.append("</edit-config>");
    rpc.append("</rpc>");
    return rpc.toString();
}
#method_after
private String removeInterfaceFromVlanBuilder(String intf, VlanId vlanId) {
    StringBuilder rpc = new StringBuilder("<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" ");
    rpc.append("xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">");
    rpc.append("<edit-config>");
    rpc.append("<target>");
    rpc.append("<running/>");
    rpc.append("</target>");
    rpc.append("<config>");
    rpc.append("<xml-config-data>");
    rpc.append("<Device-Configuration><interface><Param>");
    rpc.append(intf);
    rpc.append("</Param>");
    rpc.append("<ConfigIf-Configuration>");
    rpc.append("<switchport operation=\"delete\"><access><vlan><VLANIDVLANPortAccessMode>");
    rpc.append(vlanId);
    rpc.append("</VLANIDVLANPortAccessMode></vlan></access></switchport>");
    rpc.append("<switchport operation=\"delete\"><mode><access/></mode></switchport>");
    rpc.append("</ConfigIf-Configuration>");
    rpc.append("</interface>");
    rpc.append("</Device-Configuration>");
    rpc.append("</xml-config-data>");
    rpc.append("</config>");
    rpc.append("</edit-config>");
    rpc.append("</rpc>");
    return rpc.toString();
}
#end_block

#method_before
private String addTrunkInterfaceBuilder(String intf, VlanId vlanId) {
    StringBuilder rpc = new StringBuilder("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
    rpc.append("<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" ");
    rpc.append("xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">");
    rpc.append("<edit-config>");
    rpc.append("<target>");
    rpc.append("<running/>");
    rpc.append("</target>");
    rpc.append("<config>");
    rpc.append("<xml-config-data>");
    rpc.append("<Device-Configuration><interface><Param>");
    rpc.append(intf);
    rpc.append("</Param>");
    rpc.append("<ConfigIf-Configuration>");
    rpc.append("<switchport><trunk><encapsulation><dot1q/></encapsulation>");
    rpc.append("</trunk></switchport><switchport><trunk><allowed><vlan>");
    rpc.append("<VLANIDsAllowedVLANsPortTrunkingMode>");
    rpc.append(vlanId);
    rpc.append("</VLANIDsAllowedVLANsPortTrunkingMode></vlan></allowed></trunk>");
    rpc.append("</switchport><switchport><mode><trunk/></mode></switchport>");
    rpc.append("</ConfigIf-Configuration>");
    rpc.append("</interface>");
    rpc.append("</Device-Configuration>");
    rpc.append("</xml-config-data>");
    rpc.append("</config>");
    rpc.append("</edit-config>");
    rpc.append("</rpc>");
    return rpc.toString();
}
#method_after
private String addTrunkInterfaceBuilder(String intf, VlanId vlanId) {
    StringBuilder rpc = new StringBuilder("<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" ");
    rpc.append("xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">");
    rpc.append("<edit-config>");
    rpc.append("<target>");
    rpc.append("<running/>");
    rpc.append("</target>");
    rpc.append("<config>");
    rpc.append("<xml-config-data>");
    rpc.append("<Device-Configuration><interface><Param>");
    rpc.append(intf);
    rpc.append("</Param>");
    rpc.append("<ConfigIf-Configuration>");
    rpc.append("<switchport><trunk><encapsulation><dot1q/></encapsulation>");
    rpc.append("</trunk></switchport><switchport><trunk><allowed><vlan>");
    rpc.append("<VLANIDsAllowedVLANsPortTrunkingMode>");
    rpc.append(vlanId);
    rpc.append("</VLANIDsAllowedVLANsPortTrunkingMode></vlan></allowed></trunk>");
    rpc.append("</switchport><switchport><mode><trunk/></mode></switchport>");
    rpc.append("</ConfigIf-Configuration>");
    rpc.append("</interface>");
    rpc.append("</Device-Configuration>");
    rpc.append("</xml-config-data>");
    rpc.append("</config>");
    rpc.append("</edit-config>");
    rpc.append("</rpc>");
    return rpc.toString();
}
#end_block

#method_before
private String removeTrunkInterfaceBuilder(String intf, VlanId vlanId) {
    StringBuilder rpc = new StringBuilder("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
    rpc.append("<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" ");
    rpc.append("xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">");
    rpc.append("<edit-config>");
    rpc.append("<target>");
    rpc.append("<running/>");
    rpc.append("</target>");
    rpc.append("<config>");
    rpc.append("<xml-config-data>");
    rpc.append("<Device-Configuration><interface><Param>");
    rpc.append(intf);
    rpc.append("</Param>");
    rpc.append("<ConfigIf-Configuration>");
    rpc.append("<switchport><mode operation=\"delete\"><trunk/></mode></switchport>");
    rpc.append("<switchport><trunk operation=\"delete\"><encapsulation>");
    rpc.append("<dot1q/></encapsulation></trunk></switchport>");
    rpc.append("<switchport><trunk operation=\"delete\"><allowed><vlan>");
    rpc.append("<VLANIDsAllowedVLANsPortTrunkingMode>");
    rpc.append(vlanId);
    rpc.append("</VLANIDsAllowedVLANsPortTrunkingMode></vlan></allowed>");
    rpc.append("</trunk></switchport></ConfigIf-Configuration>");
    rpc.append("</interface>");
    rpc.append("</Device-Configuration>");
    rpc.append("</xml-config-data>");
    rpc.append("</config>");
    rpc.append("</edit-config>");
    rpc.append("</rpc>");
    return rpc.toString();
}
#method_after
private String removeTrunkInterfaceBuilder(String intf, VlanId vlanId) {
    StringBuilder rpc = new StringBuilder("<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" ");
    rpc.append("xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">");
    rpc.append("<edit-config>");
    rpc.append("<target>");
    rpc.append("<running/>");
    rpc.append("</target>");
    rpc.append("<config>");
    rpc.append("<xml-config-data>");
    rpc.append("<Device-Configuration><interface><Param>");
    rpc.append(intf);
    rpc.append("</Param>");
    rpc.append("<ConfigIf-Configuration>");
    rpc.append("<switchport><mode operation=\"delete\"><trunk/></mode></switchport>");
    rpc.append("<switchport><trunk operation=\"delete\"><encapsulation>");
    rpc.append("<dot1q/></encapsulation></trunk></switchport>");
    rpc.append("<switchport><trunk operation=\"delete\"><allowed><vlan>");
    rpc.append("<VLANIDsAllowedVLANsPortTrunkingMode>");
    rpc.append(vlanId);
    rpc.append("</VLANIDsAllowedVLANsPortTrunkingMode></vlan></allowed>");
    rpc.append("</trunk></switchport></ConfigIf-Configuration>");
    rpc.append("</interface>");
    rpc.append("</Device-Configuration>");
    rpc.append("</xml-config-data>");
    rpc.append("</config>");
    rpc.append("</edit-config>");
    rpc.append("</rpc>");
    return rpc.toString();
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(type, permanent, timeout, appId, priority, key, conditions, id, op, context, meta);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(type, permanent, timeout, appId, priority, key, conditions, op, meta);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof DefaultFilteringObjective) {
        final DefaultFilteringObjective other = (DefaultFilteringObjective) obj;
        return Objects.equals(this.type, other.type) && Objects.equals(this.permanent, other.permanent) && Objects.equals(this.timeout, other.timeout) && Objects.equals(this.appId, other.appId) && Objects.equals(this.priority, other.priority) && Objects.equals(this.key, other.key) && Objects.equals(this.conditions, other.conditions) && Objects.equals(this.id, other.id) && Objects.equals(this.op, other.op) && Objects.equals(this.context, other.context) && Objects.equals(this.meta, other.meta);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof DefaultFilteringObjective) {
        final DefaultFilteringObjective other = (DefaultFilteringObjective) obj;
        return Objects.equals(this.type, other.type) && Objects.equals(this.permanent, other.permanent) && Objects.equals(this.timeout, other.timeout) && Objects.equals(this.appId, other.appId) && Objects.equals(this.priority, other.priority) && Objects.equals(this.key, other.key) && Objects.equals(this.conditions, other.conditions) && Objects.equals(this.op, other.op) && Objects.equals(this.meta, other.meta);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof DefaultForwardingObjective)) {
        return false;
    }
    final DefaultForwardingObjective other = (DefaultForwardingObjective) obj;
    boolean nextEq = false, treatmentEq = false;
    if (this.selector.equals(other.selector) && this.flag == other.flag && this.permanent == other.permanent && this.timeout == other.timeout && this.appId.equals(other.appId) && this.priority == other.priority && this.op == other.op) {
        if (this.nextId != null && other.nextId != null) {
            nextEq = Objects.equals(this.nextId, other.nextId);
        }
        if (this.treatment != null && other.treatment != null) {
            treatmentEq = this.treatment.equals(other.treatment);
        }
        if (nextEq && treatmentEq) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof DefaultForwardingObjective) {
        final DefaultForwardingObjective other = (DefaultForwardingObjective) obj;
        return Objects.equals(this.selector, other.selector) && Objects.equals(this.flag, other.flag) && Objects.equals(this.permanent, other.permanent) && Objects.equals(this.timeout, other.timeout) && Objects.equals(this.appId, other.appId) && Objects.equals(this.priority, other.priority) && Objects.equals(this.nextId, other.nextId) && Objects.equals(this.treatment, other.treatment) && Objects.equals(this.op, other.op);
    }
    return false;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(treatments, appId, type, id, op, context, meta);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(treatments, appId, type, id, op, meta);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof DefaultNextObjective) {
        final DefaultNextObjective other = (DefaultNextObjective) obj;
        return Objects.equals(this.treatments, other.treatments) && Objects.equals(this.appId, other.appId) && Objects.equals(this.type, other.type) && Objects.equals(this.id, other.id) && Objects.equals(this.op, other.op) && Objects.equals(this.context, other.context) && Objects.equals(this.meta, other.meta);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof DefaultNextObjective) {
        final DefaultNextObjective other = (DefaultNextObjective) obj;
        return Objects.equals(this.treatments, other.treatments) && Objects.equals(this.appId, other.appId) && Objects.equals(this.type, other.type) && Objects.equals(this.id, other.id) && Objects.equals(this.op, other.op) && Objects.equals(this.meta, other.meta);
    }
    return false;
}
#end_block

#method_before
@Override
protected void execute() {
    RegionService regionService = get(RegionService.class);
    RegionAdminService regionAdminService = get(RegionAdminService.class);
    RegionId regionId = RegionId.regionId(id);
    if (regionService.getRegion(regionId) == null) {
        print("The region with id %s does not exist.", regionId.toString());
        return;
    }
    Set<NodeId> nodeIds = masters.stream().map(s -> NodeId.nodeId(s)).collect(Collectors.toSet());
    List<Set<NodeId>> masters = Lists.newArrayList();
    masters.add(nodeIds);
    regionAdminService.updateRegion(regionId, name, REGION_TYPE_MAP.get(type), masters);
    print("Region with id %s is successfully updated.", regionId.toString());
}
#method_after
@Override
protected void execute() {
    RegionService regionService = get(RegionService.class);
    RegionAdminService regionAdminService = get(RegionAdminService.class);
    RegionId regionId = RegionId.regionId(id);
    if (regionService.getRegion(regionId) == null) {
        print("The region with id %s does not exist.", regionId);
        return;
    }
    Set<NodeId> nodeIds = masters.stream().map(s -> NodeId.nodeId(s)).collect(Collectors.toSet());
    List<Set<NodeId>> masters = Lists.newArrayList();
    masters.add(nodeIds);
    regionAdminService.updateRegion(regionId, name, REGION_TYPE_MAP.get(type), masters);
    print("Region with id %s is successfully updated.", regionId);
}
#end_block

#method_before
@Override
protected void execute() {
    RegionAdminService service = get(RegionAdminService.class);
    RegionId regionId = RegionId.regionId(id);
    service.removeRegion(regionId);
}
#method_after
@Override
protected void execute() {
    RegionAdminService service = get(RegionAdminService.class);
    RegionId regionId = RegionId.regionId(id);
    service.removeRegion(regionId);
    print("Region with id %s is successfully removed.", regionId);
}
#end_block

#method_before
public boolean isMulticast() {
    return isIp4() ? Ip4Prefix.valueOf("224.0.0.0/4").contains(this.getIp4Address()) : Ip6Prefix.valueOf("ff00::/8").contains(this.getIp6Address());
}
#method_after
public boolean isMulticast() {
    return isIp4() ? Ip4Prefix.IPV4_MULTICAST_RANGE.contains(this.getIp4Address()) : Ip6Prefix.IPV6_MULTICAST_RANGE.contains(this.getIp6Address());
}
#end_block

#method_before
@Override
public DeviceKey decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    DeviceKeyId id = DeviceKeyId.deviceKeyId(json.get(ID).asText());
    DeviceKey.Type type = DeviceKey.Type.valueOf(json.get(TYPE).asText());
    String label = json.get(LABEL) == null ? null : json.get(LABEL).asText();
    if (type.equals(DeviceKey.Type.COMMUNITY_NAME)) {
        String communityName = json.get(COMMUNITY_NAME) == null ? null : json.get(COMMUNITY_NAME).asText();
        return DeviceKey.createDeviceKeyUsingCommunityName(id, label, communityName);
    } else if (type.equals(DeviceKey.Type.USERNAME_PASSWORD)) {
        String username = json.get(USERNAME) == null ? null : json.get(USERNAME).asText();
        String password = json.get(PASSWORD) == null ? null : json.get(PASSWORD).asText();
        return DeviceKey.createDeviceKeyUsingUsernamePassword(id, label, username, password);
    } else {
        log.error("Unknown device key type: ", type);
        return null;
    }
}
#method_after
@Override
public DeviceKey decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    DeviceKeyId id = DeviceKeyId.deviceKeyId(json.get(ID).asText());
    DeviceKey.Type type = DeviceKey.Type.valueOf(json.get(TYPE).asText());
    String label = extract(json, LABEL);
    if (type.equals(DeviceKey.Type.COMMUNITY_NAME)) {
        String communityName = extract(json, COMMUNITY_NAME);
        return DeviceKey.createDeviceKeyUsingCommunityName(id, label, communityName);
    } else if (type.equals(DeviceKey.Type.USERNAME_PASSWORD)) {
        String username = extract(json, USERNAME);
        String password = extract(json, PASSWORD);
        return DeviceKey.createDeviceKeyUsingUsernamePassword(id, label, username, password);
    } else {
        log.error("Unknown device key type: ", type);
        return null;
    }
}
#end_block

#method_before
public void authorizeAccess() throws StateMachineException {
    states[currentState].radiusAccepted();
    // move to the next state
    next(TRANSITION_AUTHORIZE_ACCESS);
    if (voltService != null) {
        voltService.addTenant(VoltTenant.builder().withHumanReadableName("VCPE-" + this.identifier).withId(this.identifier).withProviderService(1).withServiceSpecificId(String.valueOf(this.identifier)).withPort(this.supplicantConnectpoint).withVlanId(String.valueOf(this.vlanId)).build());
    }
    deleteIdentifier();
}
#method_after
public void authorizeAccess() throws StateMachineException {
    states[currentState].radiusAccepted();
    // move to the next state
    next(TRANSITION_AUTHORIZE_ACCESS);
    // TODO: put in calls to launch vSG here
    deleteIdentifier();
}
#end_block

#method_before
@Override
public boolean register(List<Resource> resources) {
    checkNotNull(resources);
    if (log.isTraceEnabled()) {
        resources.forEach(r -> log.trace("registering {}", r));
    }
    TransactionContext tx = service.transactionContextBuilder().build();
    tx.begin();
    TransactionalMap<DiscreteResourceId, Set<Resource>> childTxMap = tx.getTransactionalMap(CHILD_MAP, SERIALIZER);
    // the order is preserved by LinkedHashMap
    Map<DiscreteResource, List<Resource>> resourceMap = resources.stream().filter(x -> x.parent().isPresent()).collect(Collectors.groupingBy(x -> x.parent().get(), LinkedHashMap::new, Collectors.toList()));
    for (Map.Entry<DiscreteResource, List<Resource>> entry : resourceMap.entrySet()) {
        if (!lookup(childTxMap, entry.getKey().id()).isPresent()) {
            return abortTransaction(tx);
        }
        if (!appendValues(childTxMap, entry.getKey().id(), entry.getValue())) {
            return abortTransaction(tx);
        }
    }
    boolean success = tx.commit();
    if (success) {
        log.debug("Transaction commit succeeded: resources={}");
        List<ResourceEvent> events = resources.stream().filter(x -> x.parent().isPresent()).map(x -> new ResourceEvent(RESOURCE_ADDED, x)).collect(Collectors.toList());
        notifyDelegate(events);
    } else {
        log.debug("Transaction commit failed: resources={}", resources);
    }
    return success;
}
#method_after
@Override
public boolean register(List<Resource> resources) {
    checkNotNull(resources);
    if (log.isTraceEnabled()) {
        resources.forEach(r -> log.trace("registering {}", r));
    }
    TransactionContext tx = service.transactionContextBuilder().build();
    tx.begin();
    TransactionalMap<DiscreteResourceId, Set<Resource>> childTxMap = tx.getTransactionalMap(CHILD_MAP, SERIALIZER);
    // the order is preserved by LinkedHashMap
    Map<DiscreteResource, List<Resource>> resourceMap = resources.stream().filter(x -> x.parent().isPresent()).collect(Collectors.groupingBy(x -> x.parent().get(), LinkedHashMap::new, Collectors.toList()));
    for (Map.Entry<DiscreteResource, List<Resource>> entry : resourceMap.entrySet()) {
        if (!lookup(childTxMap, entry.getKey().id()).isPresent()) {
            return abortTransaction(tx);
        }
        if (!appendValues(childTxMap, entry.getKey().id(), entry.getValue())) {
            return abortTransaction(tx);
        }
    }
    boolean success = tx.commit();
    if (success) {
        log.trace("Transaction commit succeeded on registration: resources={}", resources);
        List<ResourceEvent> events = resources.stream().filter(x -> x.parent().isPresent()).map(x -> new ResourceEvent(RESOURCE_ADDED, x)).collect(Collectors.toList());
        notifyDelegate(events);
    } else {
        log.debug("Transaction commit failed on registration: resources={}", resources);
    }
    return success;
}
#end_block

#method_before
@Activate
public void activate() {
    intentInstaller.init(store, trackerService, flowRuleService, flowObjectiveService);
    if (testEnabled) {
        store.setDelegate(testOnlyDelegate);
    } else {
        store.setDelegate(delegate);
    }
    trackerService.setDelegate(topoDelegate);
    eventDispatcher.addSink(IntentEvent.class, listenerRegistry);
    batchExecutor = newSingleThreadExecutor(groupedThreads("onos/intent", "batch"));
    workerExecutor = newFixedThreadPool(NUM_THREADS, groupedThreads("onos/intent", "worker-%d"));
    idGenerator = coreService.getIdGenerator("intent-ids");
    Intent.bindIdGenerator(idGenerator);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    intentInstaller.init(store, trackerService, flowRuleService, flowObjectiveService);
    if (skipReleaseResourcesOnWithdrawal) {
        store.setDelegate(testOnlyDelegate);
    } else {
        store.setDelegate(delegate);
    }
    trackerService.setDelegate(topoDelegate);
    eventDispatcher.addSink(IntentEvent.class, listenerRegistry);
    batchExecutor = newSingleThreadExecutor(groupedThreads("onos/intent", "batch"));
    workerExecutor = newFixedThreadPool(NUM_THREADS, groupedThreads("onos/intent", "worker-%d"));
    idGenerator = coreService.getIdGenerator("intent-ids");
    Intent.bindIdGenerator(idGenerator);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    intentInstaller.init(null, null, null, null);
    if (testEnabled) {
        store.unsetDelegate(testOnlyDelegate);
    } else {
        store.unsetDelegate(delegate);
    }
    trackerService.unsetDelegate(topoDelegate);
    eventDispatcher.removeSink(IntentEvent.class);
    batchExecutor.shutdown();
    workerExecutor.shutdown();
    Intent.unbindIdGenerator(idGenerator);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    intentInstaller.init(null, null, null, null);
    if (skipReleaseResourcesOnWithdrawal) {
        store.unsetDelegate(testOnlyDelegate);
    } else {
        store.unsetDelegate(delegate);
    }
    trackerService.unsetDelegate(topoDelegate);
    eventDispatcher.removeSink(IntentEvent.class);
    batchExecutor.shutdown();
    workerExecutor.shutdown();
    Intent.unbindIdGenerator(idGenerator);
    log.info("Stopped");
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    if (context == null) {
        testEnabled = DEFAULT_TEST_ENABLED;
        logConfig("Default config");
        return;
    }
    String s = Tools.get(context.getProperties(), "testEnabled");
    boolean newTestEnabled = isNullOrEmpty(s) ? testEnabled : Boolean.parseBoolean(s.trim());
    if (testEnabled && !newTestEnabled) {
        store.unsetDelegate(testOnlyDelegate);
        store.setDelegate(delegate);
        logConfig("Reconfigured");
    } else if (!testEnabled && newTestEnabled) {
        store.unsetDelegate(delegate);
        store.setDelegate(testOnlyDelegate);
        logConfig("Reconfigured");
    }
}
#method_after
@Modified
public void modified(ComponentContext context) {
    if (context == null) {
        skipReleaseResourcesOnWithdrawal = DEFAULT_SKIP_RELEASE_RESOURCES_ON_WITHDRAWAL;
        logConfig("Default config");
        return;
    }
    String s = Tools.get(context.getProperties(), "skipReleaseResourcesOnWithdrawal");
    boolean newTestEnabled = isNullOrEmpty(s) ? skipReleaseResourcesOnWithdrawal : Boolean.parseBoolean(s.trim());
    if (skipReleaseResourcesOnWithdrawal && !newTestEnabled) {
        store.unsetDelegate(testOnlyDelegate);
        store.setDelegate(delegate);
        logConfig("Reconfigured");
    } else if (!skipReleaseResourcesOnWithdrawal && newTestEnabled) {
        store.unsetDelegate(delegate);
        store.setDelegate(testOnlyDelegate);
        logConfig("Reconfigured");
    }
}
#end_block

#method_before
private void logConfig(String prefix) {
    log.info("{} with testEnabled = {}", prefix, testEnabled);
}
#method_after
private void logConfig(String prefix) {
    log.info("{} with skipReleaseResourcesOnWithdrawal = {}", prefix, skipReleaseResourcesOnWithdrawal);
}
#end_block

#method_before
@Override
public ObjectNode encode(Region region, CodecContext context) {
    checkNotNull(region, REGION_NOT_NULL_MSG);
    ObjectNode result = context.mapper().createObjectNode().put(REGION_ID, region.id().toString()).put(NAME, region.name()).put(TYPE, region.type().toString());
    ArrayNode masters = context.mapper().createArrayNode();
    region.masters().forEach(sets -> {
        ArrayNode setsJson = context.mapper().createArrayNode();
        sets.forEach(nodeId -> {
            ObjectNode nodeIdJson = encodeNodeId(nodeId, context);
            setsJson.add(nodeIdJson);
        });
        masters.add(setsJson);
    });
    result.set(MASTERS, masters);
    return result;
}
#method_after
@Override
public ObjectNode encode(Region region, CodecContext context) {
    checkNotNull(region, REGION_NOT_NULL_MSG);
    ObjectNode result = context.mapper().createObjectNode().put(REGION_ID, region.id().toString()).put(NAME, region.name()).put(TYPE, region.type().toString());
    ArrayNode masters = context.mapper().createArrayNode();
    region.masters().forEach(sets -> {
        ArrayNode setsJson = context.mapper().createArrayNode();
        sets.forEach(nodeId -> setsJson.add(nodeId.toString()));
        masters.add(setsJson);
    });
    result.set(MASTERS, masters);
    return result;
}
#end_block

#method_before
@Override
public Region decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    // parse masters
    List<Set<NodeId>> masters = new ArrayList<>();
    JsonNode mastersJson = json.get(MASTERS);
    checkNotNull(mastersJson);
    if (mastersJson != null) {
        IntStream.range(0, mastersJson.size()).forEach(i -> {
            ObjectNode setsJson = get(mastersJson, i);
            final Set<NodeId> nodeIds = Sets.newHashSet();
            if (setsJson != null && setsJson.isArray()) {
                Set<NodeId> localNodeIds = Sets.newHashSet();
                IntStream.range(0, mastersJson.size()).forEach(j -> {
                    ObjectNode nodeIdJson = get(setsJson, j);
                    localNodeIds.add(decodeNodeId(nodeIdJson));
                });
                nodeIds.addAll(localNodeIds);
            }
            masters.add(nodeIds);
        });
    }
    // parse region id
    RegionId regionId = RegionId.regionId(nullIsIllegal(json.get(REGION_ID), REGION_ID + MISSING_MEMBER_MESSAGE).asText());
    // parse region name
    String name = nullIsIllegal(json.get(NAME), NAME + MISSING_MEMBER_MESSAGE).asText();
    // parse region type
    String typeText = nullIsIllegal(json.get(TYPE), TYPE + MISSING_MEMBER_MESSAGE).asText();
    Region.Type type = null;
    switch(typeText) {
        case "CONTINENT":
            type = Region.Type.CONTINENT;
            break;
        case "COUNTRY":
            type = Region.Type.COUNTRY;
            break;
        case "METRO":
            type = Region.Type.METRO;
            break;
        case "CAMPUS":
            type = Region.Type.CAMPUS;
            break;
        case "BUILDING":
            type = Region.Type.BUILDING;
            break;
        case "FLOOR":
            type = Region.Type.FLOOR;
            break;
        case "ROOM":
            type = Region.Type.ROOM;
            break;
        case "RACK":
            type = Region.Type.RACK;
            break;
        case "LOGICAL_GROUP":
            type = Region.Type.LOGICAL_GROUP;
            break;
        default:
            log.warn("The requested type {} is not defined for region.", typeText);
    }
    return new DefaultRegion(regionId, name, type, masters);
}
#method_after
@Override
public Region decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    // parse masters
    List<Set<NodeId>> masters = new ArrayList<>();
    JsonNode mastersJson = json.get(MASTERS);
    checkNotNull(mastersJson);
    if (mastersJson != null) {
        IntStream.range(0, mastersJson.size()).forEach(i -> {
            ObjectNode setsJson = get(mastersJson, i);
            final Set<NodeId> nodeIds = Sets.newHashSet();
            if (setsJson != null && setsJson.isArray()) {
                Set<NodeId> localNodeIds = Sets.newHashSet();
                IntStream.range(0, mastersJson.size()).forEach(j -> {
                    ObjectNode nodeIdJson = get(setsJson, j);
                    localNodeIds.add(decodeNodeId(nodeIdJson));
                });
                nodeIds.addAll(localNodeIds);
            }
            masters.add(nodeIds);
        });
    }
    // parse region id
    RegionId regionId = RegionId.regionId(nullIsIllegal(json.get(REGION_ID), REGION_ID + MISSING_MEMBER_MESSAGE).asText());
    // parse region name
    String name = nullIsIllegal(json.get(NAME), NAME + MISSING_MEMBER_MESSAGE).asText();
    // parse region type
    String typeText = nullIsIllegal(json.get(TYPE), TYPE + MISSING_MEMBER_MESSAGE).asText();
    Region.Type type = REGION_TYPE_MAP.get(typeText);
    return new DefaultRegion(regionId, name, type, masters);
}
#end_block

#method_before
private NodeId decodeNodeId(ObjectNode json) {
    if (json == null || !json.isObject()) {
        return null;
    }
    NodeId nodeId = NodeId.nodeId(nullIsIllegal(json.get(NODE_ID), NODE_ID + MISSING_MEMBER_MESSAGE).asText());
    return nodeId;
}
#method_after
private NodeId decodeNodeId(ObjectNode json) {
    NodeId nodeId = NodeId.nodeId(nullIsIllegal(json, NODE_ID + MISSING_MEMBER_MESSAGE).asText());
    return nodeId;
}
#end_block

#method_before
public TrafficTreatment.Builder packTrafficTreatment(PortPair portPair, boolean isSameOvs) {
    MacAddress srcMacAddress = null;
    // Check the treatment whether destination SF is on same OVS or in
    // different OVS.
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    if (isSameOvs) {
        srcMacAddress = virtualPortService.getPort(VirtualPortId.portId(portPair.ingress())).macAddress();
        Host host = hostService.getHost(HostId.hostId(srcMacAddress));
        PortNumber port = host.location().port();
        treatment.setOutput(port);
    } else {
        // Vxlan tunnel port for NSH header(Vxlan + NSH).
        TpPort nshDstPort = TpPort.tpPort(6633);
        VlanId vlanId = VlanId.vlanId(Short.parseShort((vtnRscService.getL3vni(portPair.tenantId()).toString())));
        treatment.setVlanId(vlanId);
        treatment.setUdpDst(nshDstPort);
    }
    return treatment;
}
#method_after
public TrafficTreatment.Builder packTrafficTreatment(PortPair portPair, boolean isSameOvs) {
    MacAddress srcMacAddress = null;
    // Check the treatment whether destination SF is on same OVS or in
    // different OVS.
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    if (isSameOvs) {
        srcMacAddress = virtualPortService.getPort(VirtualPortId.portId(portPair.ingress())).macAddress();
        Host host = hostService.getHost(HostId.hostId(srcMacAddress));
        PortNumber port = host.location().port();
        treatment.setOutput(port);
    } else {
        // Vxlan tunnel port for NSH header(Vxlan + NSH).
        TpPort nshDstPort = TpPort.tpPort(6633);
        // TODO check whether this logic is correct
        VlanId vlanId = VlanId.vlanId(Short.parseShort((vtnRscService.getL3vni(portPair.tenantId()).toString())));
        treatment.setVlanId(vlanId);
        treatment.setUdpDst(nshDstPort);
    }
    return treatment;
}
#end_block

#method_before
public void sendServiceFunctionForwarder(TrafficSelector.Builder selector, TrafficTreatment.Builder treatment, DeviceId deviceId, Objective.Operation type) {
    log.debug("Sending serfice-function-forwarder");
    log.debug("Selector: ", selector.toString());
    log.debug("Treatment: ", treatment.toString());
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector.build()).fromApp(appId).makePermanent().withFlag(Flag.VERSATILE);
    if (type.equals(Objective.Operation.ADD)) {
        log.debug("ADD");
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        log.debug("REMOVE");
        flowObjectiveService.forward(deviceId, objective.remove());
    }
}
#method_after
public void sendServiceFunctionForwarder(TrafficSelector.Builder selector, TrafficTreatment.Builder treatment, DeviceId deviceId, Objective.Operation type) {
    log.info("Sending flow to serfice-function-forwarder. Selector {}, Treatment {}", selector.toString(), treatment.toString());
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector.build()).fromApp(appId).makePermanent().withFlag(Flag.VERSATILE);
    if (type.equals(Objective.Operation.ADD)) {
        log.debug("ADD");
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        log.debug("REMOVE");
        flowObjectiveService.forward(deviceId, objective.remove());
    }
}
#end_block

#method_before
@Override
public DriverHandler handler() {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public DriverHandler handler() {
    return null;
}
#end_block

#method_before
@Override
public void setHandler(DriverHandler handler) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void setHandler(DriverHandler handler) {
}
#end_block

#method_before
@Override
public DriverData data() {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public DriverData data() {
    return null;
}
#end_block

#method_before
@Override
public void setData(DriverData data) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void setData(DriverData data) {
}
#end_block

#method_before
@Override
public boolean isServiceFunction(VirtualPortId portId) {
    // TODO Auto-generated method stub
    return false;
}
#method_after
@Override
public boolean isServiceFunction(VirtualPortId portId) {
    return false;
}
#end_block

#method_before
@Override
public <T> void setPropertyValue(String key, T value) throws ExtensionPropertyException {
// TODO Auto-generated method stub
}
#method_after
@Override
public <T> void setPropertyValue(String key, T value) throws ExtensionPropertyException {
}
#end_block

#method_before
@Override
public <T> T getPropertyValue(String key) throws ExtensionPropertyException {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public <T> T getPropertyValue(String key) throws ExtensionPropertyException {
    return null;
}
#end_block

#method_before
@Override
public List<String> getProperties() {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public List<String> getProperties() {
    return null;
}
#end_block

#method_before
@Override
public byte[] serialize() {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public byte[] serialize() {
    return null;
}
#end_block

#method_before
@Override
public void deserialize(byte[] data) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void deserialize(byte[] data) {
}
#end_block

#method_before
@Override
public ExtensionSelectorType type() {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public ExtensionSelectorType type() {
    return null;
}
#end_block

#method_before
@Override
public <T> void setPropertyValue(String key, T value) throws ExtensionPropertyException {
// TODO Auto-generated method stub
}
#method_after
@Override
public <T> void setPropertyValue(String key, T value) throws ExtensionPropertyException {
}
#end_block

#method_before
@Override
public <T> T getPropertyValue(String key) throws ExtensionPropertyException {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public <T> T getPropertyValue(String key) throws ExtensionPropertyException {
    return null;
}
#end_block

#method_before
@Override
public List<String> getProperties() {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public List<String> getProperties() {
    return null;
}
#end_block

#method_before
@Override
public byte[] serialize() {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public byte[] serialize() {
    return null;
}
#end_block

#method_before
@Override
public void deserialize(byte[] data) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void deserialize(byte[] data) {
}
#end_block

#method_before
@Override
public ExtensionTreatmentType type() {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public ExtensionTreatmentType type() {
    return null;
}
#end_block

#method_before
@Override
public DriverHandler handler() {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public DriverHandler handler() {
    return null;
}
#end_block

#method_before
@Override
public void setHandler(DriverHandler handler) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void setHandler(DriverHandler handler) {
}
#end_block

#method_before
@Override
public DriverData data() {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public DriverData data() {
    return null;
}
#end_block

#method_before
@Override
public void setData(DriverData data) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void setData(DriverData data) {
}
#end_block

#method_before
@Override
public Driver driver() {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public Driver driver() {
    return null;
}
#end_block

#method_before
@Override
public DriverData data() {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public DriverData data() {
    return null;
}
#end_block

#method_before
@Override
public <T> T get(Class<T> serviceClass) {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public <T> T get(Class<T> serviceClass) {
    return null;
}
#end_block

#method_before
@Override
public boolean matchesSafely(JsonNode jsonInstruction, Description description) {
    // check type
    final JsonNode jsonTypeNode = jsonInstruction.get("type");
    final String jsonType = jsonTypeNode.textValue();
    final String type = instruction.type().name();
    if (!jsonType.equals(type)) {
        description.appendText("type was " + type);
        return false;
    }
    if (instruction instanceof PushHeaderInstructions) {
        return matchPushHeaderInstruction(jsonInstruction, description);
    } else if (instruction instanceof DropInstruction) {
        return true;
    } else if (instruction instanceof OutputInstruction) {
        return matchOutputInstruction(jsonInstruction, description);
    } else if (instruction instanceof ModLambdaInstruction) {
        return matchModLambdaInstruction(jsonInstruction, description);
    } else if (instruction instanceof ModOchSignalInstruction) {
        return matchModOchSingalInstruction(jsonInstruction, description);
    } else if (instruction instanceof ModEtherInstruction) {
        return matchModEtherInstruction(jsonInstruction, description);
    } else if (instruction instanceof ModVlanIdInstruction) {
        return matchModVlanIdInstruction(jsonInstruction, description);
    } else if (instruction instanceof ModVlanPcpInstruction) {
        return matchModVlanPcpInstruction(jsonInstruction, description);
    } else if (instruction instanceof ModIPInstruction) {
        return matchModIpInstruction(jsonInstruction, description);
    } else if (instruction instanceof ModIPv6FlowLabelInstruction) {
        return matchModIPv6FlowLabelInstruction(jsonInstruction, description);
    } else if (instruction instanceof ModMplsLabelInstruction) {
        return matchModMplsLabelInstruction(jsonInstruction, description);
    } else if (instruction instanceof ModOduSignalIdInstruction) {
        return matchModOduSingalIdInstruction(jsonInstruction, description);
    } else if (instruction instanceof NoActionInstruction) {
        return true;
    }
    return false;
}
#method_after
@Override
public boolean matchesSafely(JsonNode jsonInstruction, Description description) {
    // check type
    final JsonNode jsonTypeNode = jsonInstruction.get("type");
    final String jsonType = jsonTypeNode.textValue();
    final String type = instruction.type().name();
    if (!jsonType.equals(type)) {
        description.appendText("type was " + type);
        return false;
    }
    if (instruction instanceof PushHeaderInstructions) {
        return matchPushHeaderInstruction(jsonInstruction, description);
    } else if (instruction instanceof OutputInstruction) {
        return matchOutputInstruction(jsonInstruction, description);
    } else if (instruction instanceof ModLambdaInstruction) {
        return matchModLambdaInstruction(jsonInstruction, description);
    } else if (instruction instanceof ModOchSignalInstruction) {
        return matchModOchSingalInstruction(jsonInstruction, description);
    } else if (instruction instanceof ModEtherInstruction) {
        return matchModEtherInstruction(jsonInstruction, description);
    } else if (instruction instanceof ModVlanIdInstruction) {
        return matchModVlanIdInstruction(jsonInstruction, description);
    } else if (instruction instanceof ModVlanPcpInstruction) {
        return matchModVlanPcpInstruction(jsonInstruction, description);
    } else if (instruction instanceof ModIPInstruction) {
        return matchModIpInstruction(jsonInstruction, description);
    } else if (instruction instanceof ModIPv6FlowLabelInstruction) {
        return matchModIPv6FlowLabelInstruction(jsonInstruction, description);
    } else if (instruction instanceof ModMplsLabelInstruction) {
        return matchModMplsLabelInstruction(jsonInstruction, description);
    } else if (instruction instanceof ModOduSignalIdInstruction) {
        return matchModOduSingalIdInstruction(jsonInstruction, description);
    } else if (instruction instanceof NoActionInstruction) {
        return true;
    }
    return false;
}
#end_block

#method_before
@Test
public void testImmutabilityOfInstructions() {
    assertThatClassIsImmutable(Instructions.DropInstruction.class);
    assertThatClassIsImmutable(Instructions.OutputInstruction.class);
    assertThatClassIsImmutable(L0ModificationInstruction.ModLambdaInstruction.class);
    assertThatClassIsImmutable(L0ModificationInstruction.ModOchSignalInstruction.class);
    assertThatClassIsImmutable(L1ModificationInstruction.ModOduSignalIdInstruction.class);
    assertThatClassIsImmutable(L2ModificationInstruction.ModEtherInstruction.class);
    assertThatClassIsImmutable(L2ModificationInstruction.ModVlanIdInstruction.class);
    assertThatClassIsImmutable(L2ModificationInstruction.ModVlanPcpInstruction.class);
    assertThatClassIsImmutable(L2ModificationInstruction.PopVlanInstruction.class);
    assertThatClassIsImmutable(L3ModificationInstruction.ModIPInstruction.class);
    assertThatClassIsImmutable(L3ModificationInstruction.ModIPv6FlowLabelInstruction.class);
    assertThatClassIsImmutable(L2ModificationInstruction.ModMplsLabelInstruction.class);
    assertThatClassIsImmutable(L2ModificationInstruction.PushHeaderInstructions.class);
    assertThatClassIsImmutable(L2ModificationInstruction.ModMplsBosInstruction.class);
    assertThatClassIsImmutable(L2ModificationInstruction.ModMplsTtlInstruction.class);
    assertThatClassIsImmutable(L2ModificationInstruction.ModTunnelIdInstruction.class);
}
#method_after
@Test
public void testImmutabilityOfInstructions() {
    assertThatClassIsImmutable(Instructions.OutputInstruction.class);
    assertThatClassIsImmutable(L0ModificationInstruction.ModLambdaInstruction.class);
    assertThatClassIsImmutable(L0ModificationInstruction.ModOchSignalInstruction.class);
    assertThatClassIsImmutable(L1ModificationInstruction.ModOduSignalIdInstruction.class);
    assertThatClassIsImmutable(L2ModificationInstruction.ModEtherInstruction.class);
    assertThatClassIsImmutable(L2ModificationInstruction.ModVlanIdInstruction.class);
    assertThatClassIsImmutable(L2ModificationInstruction.ModVlanPcpInstruction.class);
    assertThatClassIsImmutable(L2ModificationInstruction.PopVlanInstruction.class);
    assertThatClassIsImmutable(L3ModificationInstruction.ModIPInstruction.class);
    assertThatClassIsImmutable(L3ModificationInstruction.ModIPv6FlowLabelInstruction.class);
    assertThatClassIsImmutable(L2ModificationInstruction.ModMplsLabelInstruction.class);
    assertThatClassIsImmutable(L2ModificationInstruction.PushHeaderInstructions.class);
    assertThatClassIsImmutable(L2ModificationInstruction.ModMplsBosInstruction.class);
    assertThatClassIsImmutable(L2ModificationInstruction.ModMplsTtlInstruction.class);
    assertThatClassIsImmutable(L2ModificationInstruction.ModTunnelIdInstruction.class);
}
#end_block

#method_before
@Activate
public void activate() {
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(MultiValuedTimestamp.class).register(InternalState.class);
    tunnelIdAsKeyStore = storageService.<TunnelId, Tunnel>eventuallyConsistentMapBuilder().withName("all_tunnel").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    tunnelNameAsKeyStore = storageService.<TunnelName, Set<TunnelId>>eventuallyConsistentMapBuilder().withName("tunnel_name_tunnel").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    srcAndDstKeyStore = storageService.<TunnelKey, Set<TunnelId>>eventuallyConsistentMapBuilder().withName("src_dst_tunnel").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    typeKeyStore = storageService.<Tunnel.Type, Set<TunnelId>>eventuallyConsistentMapBuilder().withName("type_tunnel").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    orderRelationship = storageService.<ApplicationId, Set<TunnelSubscription>>eventuallyConsistentMapBuilder().withName("type_tunnel").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    idGenerator = coreService.getIdGenerator(tunnelOpTopoic);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(MultiValuedTimestamp.class).register(InternalState.class);
    tunnelIdAsKeyStore = storageService.<TunnelId, Tunnel>eventuallyConsistentMapBuilder().withName("all_tunnel").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    tunnelNameAsKeyStore = storageService.<TunnelName, Set<TunnelId>>eventuallyConsistentMapBuilder().withName("tunnel_name_tunnel").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    srcAndDstKeyStore = storageService.<TunnelKey, Set<TunnelId>>eventuallyConsistentMapBuilder().withName("src_dst_tunnel").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    typeKeyStore = storageService.<Tunnel.Type, Set<TunnelId>>eventuallyConsistentMapBuilder().withName("type_tunnel").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    orderRelationship = storageService.<ApplicationId, Set<TunnelSubscription>>eventuallyConsistentMapBuilder().withName("type_tunnel").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    idGenerator = coreService.getIdGenerator(tunnelOpTopic);
    log.info("Started");
}
#end_block

#method_before
private PortChainId findPortChainFromFiveTuple(FiveTuple fiveTupple) {
    PortChainId portChainId = null;
    Iterable<PortChain> portChains = portChainService.getPortChains();
    if (portChains == null) {
        log.error("Could not retrive port chain list");
    }
    // Identify the port chain to which the packet belongs
    for (final PortChain portChain : portChains) {
        boolean match = false;
        Iterable<FlowClassifierId> flowClassifiers = portChain.flowClassifiers();
        // One port chain can have multiple flow classifiers.
        for (final FlowClassifierId flowClassifierId : flowClassifiers) {
            FlowClassifier flowClassifier = flowClassifierService.getFlowClassifier(flowClassifierId);
            // Check whether protocol is set in flow classfiveTuppleifier
            if (flowClassifier.protocol() != null) {
                if ((flowClassifier.protocol() == "TCP" && fiveTupple.protocol() == IPv4.PROTOCOL_TCP) || (flowClassifier.protocol() == "UDP" && fiveTupple.protocol() == IPv4.PROTOCOL_UDP)) {
                    match = true;
                } else {
                    match = false;
                }
            }
            // Check whether source ip prefix is set in flow classifier
            if (flowClassifier.srcIpPrefix() != null) {
                if (flowClassifier.srcIpPrefix().contains(fiveTupple.ipSrc())) {
                    match = true;
                } else {
                    match = false;
                }
            }
            // Check whether destination ip prefix is set in flow classifier
            if (flowClassifier.dstIpPrefix() != null) {
                if (flowClassifier.dstIpPrefix().contains(fiveTupple.ipDst())) {
                    match = true;
                } else {
                    match = false;
                }
            }
            // Check whether source port is set in flow classifier
            if (flowClassifier.minSrcPortRange() != NULL_PORT && flowClassifier.maxSrcPortRange() != NULL_PORT) {
                if (fiveTupple.portSrc().toLong() >= flowClassifier.minSrcPortRange() || fiveTupple.portSrc().toLong() <= flowClassifier.maxSrcPortRange()) {
                    match = true;
                } else {
                    match = false;
                }
            }
            // Check whether destination port is set in flow classifier
            if (flowClassifier.minDstPortRange() != NULL_PORT && flowClassifier.maxDstPortRange() != NULL_PORT) {
                if (fiveTupple.portDst().toLong() >= flowClassifier.minSrcPortRange() || fiveTupple.portDst().toLong() <= flowClassifier.maxSrcPortRange()) {
                    match = true;
                } else {
                    match = false;
                }
            }
        }
        if (match) {
            portChainId = portChain.portChainId();
            break;
        }
    }
    return portChainId;
}
#method_after
private PortChainId findPortChainFromFiveTuple(FiveTuple fiveTuple) {
    PortChainId portChainId = null;
    Iterable<PortChain> portChains = portChainService.getPortChains();
    if (portChains == null) {
        log.error("Could not retrive port chain list");
    }
    // Identify the port chain to which the packet belongs
    for (final PortChain portChain : portChains) {
        Iterable<FlowClassifierId> flowClassifiers = portChain.flowClassifiers();
        // One port chain can have multiple flow classifiers.
        for (final FlowClassifierId flowClassifierId : flowClassifiers) {
            FlowClassifier flowClassifier = flowClassifierService.getFlowClassifier(flowClassifierId);
            boolean match = false;
            // Check whether protocol is set in flow classifier
            if (flowClassifier.protocol() != null) {
                if ((flowClassifier.protocol().equals("TCP") && fiveTuple.protocol() == IPv4.PROTOCOL_TCP) || (flowClassifier.protocol().equals("UDP") && fiveTuple.protocol() == IPv4.PROTOCOL_UDP)) {
                    match = true;
                } else {
                    continue;
                }
            }
            // Check whether source ip prefix is set in flow classifier
            if (flowClassifier.srcIpPrefix() != null) {
                if (flowClassifier.srcIpPrefix().contains(fiveTuple.ipSrc())) {
                    match = true;
                } else {
                    continue;
                }
            }
            // Check whether destination ip prefix is set in flow classifier
            if (flowClassifier.dstIpPrefix() != null) {
                if (flowClassifier.dstIpPrefix().contains(fiveTuple.ipDst())) {
                    match = true;
                } else {
                    continue;
                }
            }
            // Check whether source port is set in flow classifier
            if (fiveTuple.portSrc().toLong() >= flowClassifier.minSrcPortRange() || fiveTuple.portSrc().toLong() <= flowClassifier.maxSrcPortRange()) {
                match = true;
            } else {
                continue;
            }
            // Check whether destination port is set in flow classifier
            if (fiveTuple.portDst().toLong() >= flowClassifier.minSrcPortRange() || fiveTuple.portDst().toLong() <= flowClassifier.maxSrcPortRange()) {
                match = true;
            } else {
                continue;
            }
            // Check whether neutron source port is set in flow classfier
            if ((flowClassifier.srcPort() != null) && (!flowClassifier.srcPort().portId().isEmpty())) {
                match = checkIpInVirtualPort(VirtualPortId.portId(flowClassifier.srcPort().portId()), fiveTuple.ipSrc());
                if (!match) {
                    continue;
                }
            }
            // Check whether destination neutron destination port is set in flow classifier
            if ((flowClassifier.dstPort() != null) && (!flowClassifier.dstPort().portId().isEmpty())) {
                match = checkIpInVirtualPort(VirtualPortId.portId(flowClassifier.dstPort().portId()), fiveTuple.ipDst());
                if (!match) {
                    continue;
                }
            }
            if (match) {
                portChainId = portChain.portChainId();
                break;
            }
        }
    }
    return portChainId;
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    Ethernet packet = context.inPacket().parsed();
    if (packet == null) {
        return;
    }
    // get the five tupple parameters for the packet
    short ethType = packet.getEtherType();
    IpAddress ipSrc = null;
    IpAddress ipDst = null;
    int portSrc = 0;
    int portDst = 0;
    byte protocol = 0;
    if (ethType == Ethernet.TYPE_IPV4) {
        IPv4 ipv4Packet = (IPv4) packet.getPayload();
        ipSrc = IpAddress.valueOf(ipv4Packet.getSourceAddress());
        ipDst = IpAddress.valueOf(ipv4Packet.getDestinationAddress());
        protocol = ipv4Packet.getProtocol();
        if (protocol == IPv4.PROTOCOL_TCP) {
            TCP tcpPacket = (TCP) ipv4Packet.getPayload();
            portSrc = tcpPacket.getSourcePort();
            portDst = tcpPacket.getDestinationPort();
        } else if (protocol == IPv4.PROTOCOL_UDP) {
            UDP udpPacket = (UDP) ipv4Packet.getPayload();
            portSrc = udpPacket.getSourcePort();
            portDst = udpPacket.getDestinationPort();
        }
    } else if (ethType == Ethernet.TYPE_IPV6) {
        IPv6 ipv6Packet = (IPv6) packet.getPayload();
        ipSrc = IpAddress.valueOf(ipv6Packet.getSourceAddress().toString());
        ipDst = IpAddress.valueOf(ipv6Packet.getDestinationAddress().toString());
    }
    FiveTuple fiveTuple = DefaultFiveTuple.builder().setIpSrc(ipSrc).setIpDst(ipDst).setPortSrc(PortNumber.portNumber(portSrc)).setPortDst(PortNumber.portNumber(portDst)).setProtocol(protocol).build();
    PortChainId portChainId = findPortChainFromFiveTuple(fiveTuple);
    if (portChainId == null) {
        log.error("Packet does not match with any classifier");
        return;
    }
// TODO
// download the required flow rules for classifier and forwarding
// resend the packet back to classifier
}
#method_after
@Override
public void process(PacketContext context) {
    Ethernet packet = context.inPacket().parsed();
    if (packet == null) {
        return;
    }
    // get the five tuple parameters for the packet
    short ethType = packet.getEtherType();
    IpAddress ipSrc = null;
    IpAddress ipDst = null;
    int portSrc = 0;
    int portDst = 0;
    byte protocol = 0;
    MacAddress macSrc = packet.getSourceMAC();
    TenantId tenantId = getTenantId(macSrc);
    if (ethType == Ethernet.TYPE_IPV4) {
        IPv4 ipv4Packet = (IPv4) packet.getPayload();
        ipSrc = IpAddress.valueOf(ipv4Packet.getSourceAddress());
        ipDst = IpAddress.valueOf(ipv4Packet.getDestinationAddress());
        protocol = ipv4Packet.getProtocol();
        if (protocol == IPv4.PROTOCOL_TCP) {
            TCP tcpPacket = (TCP) ipv4Packet.getPayload();
            portSrc = tcpPacket.getSourcePort();
            portDst = tcpPacket.getDestinationPort();
        } else if (protocol == IPv4.PROTOCOL_UDP) {
            UDP udpPacket = (UDP) ipv4Packet.getPayload();
            portSrc = udpPacket.getSourcePort();
            portDst = udpPacket.getDestinationPort();
        }
    } else if (ethType == Ethernet.TYPE_IPV6) {
        return;
    }
    FiveTuple fiveTuple = DefaultFiveTuple.builder().setIpSrc(ipSrc).setIpDst(ipDst).setPortSrc(PortNumber.portNumber(portSrc)).setPortDst(PortNumber.portNumber(portDst)).setProtocol(protocol).setTenantId(tenantId).build();
    PortChainId portChainId = findPortChainFromFiveTuple(fiveTuple);
    if (portChainId == null) {
        log.error("Packet does not match with any classifier");
        return;
    }
// TODO
// download the required flow rules for classifier and forwarding
// resend the packet back to classifier
}
#end_block

#method_before
private boolean isPrintTarget(Resource resource) {
    if (typesToPrint.isEmpty()) {
        return true;
    }
    String resourceName = resource.simpleTypeName();
    if (resource instanceof DiscreteResource) {
        // This should be merged with the one in printResource()
        if (!resourceService.getRegisteredResources(((DiscreteResource) resource).id()).isEmpty()) {
            // resource which has children should be printed
            return true;
        }
    } else {
        log.warn("Unexpected resource class: {}", resource.getClass().getSimpleName());
        return false;
    }
    return typesToPrint.contains(resourceName);
}
#method_after
private boolean isPrintTarget(Resource resource) {
    if (typesToPrint.isEmpty()) {
        return true;
    }
    String resourceName = resource.simpleTypeName();
    if (resource instanceof DiscreteResource) {
        // This should be merged with the one in printResource()
        if (!resourceService.getRegisteredResources(((DiscreteResource) resource).id()).isEmpty()) {
            // resource which has children should be printed
            return true;
        }
    } else if (!(resource instanceof ContinuousResource)) {
        log.warn("Unexpected resource class: {}", resource.getClass().getSimpleName());
        return false;
    }
    return typesToPrint.contains(resourceName);
}
#end_block

#method_before
@Override
public Collection<OpenstackPort> ports(String networkId) {
    return null;
}
#method_after
@Override
public Collection<OpenstackPort> ports(String networkId) {
    return getPorts().stream().filter(port -> port.networkId().equals(networkId)).collect(Collectors.toList());
}
#end_block

#method_before
@Override
public void setConfigurations(String neutronUrl, String keystoneUrl, String userName, String pass) {
    this.neutronUrl = neutronUrl;
    this.keystoneUrl = keystoneUrl;
    this.userName = userName;
    this.pass = pass;
}
#method_after
@Override
public void setConfigurations(String neutronUrl, String keystoneUrl, String userName, String pass) {
    this.neutronUrl = checkNotNull(neutronUrl);
    this.keystoneUrl = checkNotNull(keystoneUrl);
    this.userName = checkNotNull(userName);
    this.pass = checkNotNull(pass);
}
#end_block

#method_before
@Path("{portUUID}")
@DELETE
public Response deletePorts(@PathParam("portUUID") String id) {
    OpenstackSwitchingService switchingService = getService(OpenstackSwitchingService.class);
    switchingService.deletePort(id);
    return Response.status(Response.Status.OK).build();
}
#method_after
@Path("{portUUID}")
@Produces(MediaType.APPLICATION_JSON)
@DELETE
public Response deletePorts(@PathParam("portUUID") String id) {
    OpenstackSwitchingService switchingService = getService(OpenstackSwitchingService.class);
    switchingService.removePort(id);
    return Response.status(Response.Status.OK).build();
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o instanceof OpenstackSecurityGroup) {
        OpenstackSecurityGroup that = (OpenstackSecurityGroup) o;
        return this.description.equals(that.description) && this.tenantId.equals(that.tenantId) && this.id.equals(that.id) && this.name.equals(that.name) && this.rules.containsAll(that.rules);
    }
    return true;
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o instanceof OpenstackSecurityGroup) {
        OpenstackSecurityGroup that = (OpenstackSecurityGroup) o;
        return this.description.equals(that.description) && this.tenantId.equals(that.tenantId) && this.id.equals(that.id) && this.name.equals(that.name) && this.rules.containsAll(that.rules);
    }
    return false;
}
#end_block

#method_before
@Override
public OpenstackSubnet decode(ObjectNode json, CodecContext context) {
    JsonNode subnetInfo = json.get(SUBNET);
    if (subnetInfo == null) {
        subnetInfo = json;
    }
    String name = subnetInfo.path(NAME).asText();
    boolean enableDhcp = subnetInfo.path(ENABLE_DHCP).asBoolean();
    String networkId = subnetInfo.path(NETWORK_ID).asText();
    String tenantId = subnetInfo.path(TENANT_ID).asText();
    ArrayNode dnsNameservsers = (ArrayNode) subnetInfo.path(DNS_NAMESERVERS);
    List<Ip4Address> dnsList = Lists.newArrayList();
    if (dnsNameservsers != null && !dnsNameservsers.isMissingNode()) {
        dnsNameservsers.forEach(dns -> dnsList.add(Ip4Address.valueOf(dns.asText())));
    }
    String gatewayIp = subnetInfo.path(GATEWAY_IP).asText();
    String cidr = subnetInfo.path(CIDR).asText();
    String id = subnetInfo.path(ID).asText();
    OpenstackSubnet openstackSubnet = OpenstackSubnet.builder().setName(name).setEnableDhcp(enableDhcp).setNetworkId(networkId).setTenantId(tenantId).setDnsNameservers(dnsList).setGatewayIp(gatewayIp).setCidr(cidr).setId(id).build();
    return openstackSubnet;
}
#method_after
@Override
public OpenstackSubnet decode(ObjectNode json, CodecContext context) {
    checkNotNull(json);
    JsonNode subnetInfo = json.get(SUBNET);
    if (subnetInfo == null) {
        subnetInfo = json;
    }
    String name = subnetInfo.path(NAME).asText();
    boolean enableDhcp = subnetInfo.path(ENABLE_DHCP).asBoolean();
    String networkId = subnetInfo.path(NETWORK_ID).asText();
    String tenantId = subnetInfo.path(TENANT_ID).asText();
    ArrayNode dnsNameservsers = (ArrayNode) subnetInfo.path(DNS_NAMESERVERS);
    List<Ip4Address> dnsList = Lists.newArrayList();
    if (dnsNameservsers != null && !dnsNameservsers.isMissingNode()) {
        dnsNameservsers.forEach(dns -> dnsList.add(Ip4Address.valueOf(dns.asText())));
    }
    String gatewayIp = subnetInfo.path(GATEWAY_IP).asText();
    String cidr = subnetInfo.path(CIDR).asText();
    String id = subnetInfo.path(ID).asText();
    OpenstackSubnet openstackSubnet = OpenstackSubnet.builder().setName(name).setEnableDhcp(enableDhcp).setNetworkId(networkId).setTenantId(tenantId).setDnsNameservers(dnsList).setGatewayIp(gatewayIp).setCidr(cidr).setId(id).build();
    return openstackSubnet;
}
#end_block

#method_before
public void init(DeviceId deviceId, String dpIntf, IpAddress dpIp) {
    // default is drop packets which can be accomplished without
    // a table miss entry for all table.
    PortNumber tunnelPort = getTunnelPort(deviceId);
    PortNumber dpPort = getDpPort(deviceId, dpIntf);
    processFirstTable(deviceId, dpPort, dpIp);
    processInPortTable(deviceId, tunnelPort, dpPort);
    processAccessTypeTable(deviceId, dpPort);
}
#method_after
public void init(DeviceId deviceId, String dpIntf, IpAddress dpIp) {
    // default is drop packets which can be accomplished without
    // a table miss entry for all table.
    PortNumber tunnelPort = getTunnelPort(deviceId);
    PortNumber dpPort = getDpPort(deviceId, dpIntf);
    processFirstTable(deviceId, dpPort, dpIp);
    processInPortTable(deviceId, tunnelPort, dpPort);
    processAccessTypeTable(deviceId, dpPort);
    processQInQTable(deviceId, dpPort);
}
#end_block

#method_before
public void removeBasicConnectionRules(Host host) {
    checkNotNull(host);
    DeviceId deviceId = host.location().deviceId();
    MacAddress mac = host.mac();
    PortNumber port = host.location().port();
    IpAddress ip = host.ipAddresses().stream().findFirst().orElse(null);
    if (!mastershipService.isLocalMaster(deviceId)) {
        return;
    }
    for (FlowRule flowRule : flowRuleService.getFlowRulesById(appId)) {
        if (flowRule.deviceId().equals(deviceId)) {
            PortNumber inPort = getInPort(flowRule);
            if (inPort != null && inPort.equals(port)) {
                processFlowRule(false, flowRule);
                continue;
            }
        }
        MacAddress dstMac = getDstMacFromTreatment(flowRule);
        if (dstMac != null && dstMac.equals(mac)) {
            processFlowRule(false, flowRule);
            continue;
        }
        dstMac = getDstMacFromSelector(flowRule);
        if (dstMac != null && dstMac.equals(mac)) {
            processFlowRule(false, flowRule);
            continue;
        }
        IpPrefix dstIp = getDstIpFromSelector(flowRule);
        if (dstIp != null && dstIp.equals(ip.toIpPrefix())) {
            processFlowRule(false, flowRule);
        }
    }
// TODO uninstall same network access rule in access table if no vm exists in the network
}
#method_after
public void removeBasicConnectionRules(Host host) {
    checkNotNull(host);
    DeviceId deviceId = host.location().deviceId();
    MacAddress mac = host.mac();
    PortNumber port = host.location().port();
    IpAddress ip = host.ipAddresses().stream().findFirst().orElse(null);
    if (!mastershipService.isLocalMaster(deviceId)) {
        return;
    }
    for (FlowRule flowRule : flowRuleService.getFlowRulesById(appId)) {
        if (flowRule.deviceId().equals(deviceId)) {
            PortNumber inPort = getInPort(flowRule);
            if (inPort != null && inPort.equals(port)) {
                processFlowRule(false, flowRule);
                continue;
            }
            PortNumber output = getOutputFromTreatment(flowRule);
            if (output != null && output.equals(host.location().port())) {
                processFlowRule(false, flowRule);
            }
        }
        MacAddress dstMac = getDstMacFromTreatment(flowRule);
        if (dstMac != null && dstMac.equals(mac)) {
            processFlowRule(false, flowRule);
            continue;
        }
        dstMac = getDstMacFromSelector(flowRule);
        if (dstMac != null && dstMac.equals(mac)) {
            processFlowRule(false, flowRule);
            continue;
        }
        IpPrefix dstIp = getDstIpFromSelector(flowRule);
        if (dstIp != null && dstIp.equals(ip.toIpPrefix())) {
            processFlowRule(false, flowRule);
        }
    }
// TODO uninstall same network access rule in access table if no vm exists in the network
}
#end_block

#method_before
public void populateManagementNetworkRules(Host host, CordService mService) {
    checkNotNull(mService);
    DeviceId deviceId = host.location().deviceId();
    IpAddress hostIp = host.ipAddresses().stream().findFirst().get();
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_ARP).matchArpTpa(mService.serviceIp().getIp4Address()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(MANAGEMENT_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    selector = DefaultTrafficSelector.builder().matchInPort(PortNumber.LOCAL).matchEthType(Ethernet.TYPE_ARP).matchArpTpa(hostIp.getIp4Address()).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(host.location().port()).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(MANAGEMENT_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    selector = DefaultTrafficSelector.builder().matchInPort(PortNumber.LOCAL).matchEthType(Ethernet.TYPE_IPV4).matchIPDst(mService.serviceIpRange()).build();
    treatment = DefaultTrafficTreatment.builder().transition(TABLE_DST_IP).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(MANAGEMENT_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(mService.serviceIp().toIpPrefix()).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(MANAGEMENT_PRIORITY).forDevice(deviceId).forTable(TABLE_ACCESS_TYPE).makePermanent().build();
    processFlowRule(true, flowRule);
}
#method_after
public void populateManagementNetworkRules(Host host, CordService mService) {
    checkNotNull(mService);
    DeviceId deviceId = host.location().deviceId();
    IpAddress hostIp = host.ipAddresses().stream().findFirst().get();
    if (!mastershipService.isLocalMaster(deviceId)) {
        return;
    }
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_ARP).matchArpTpa(mService.serviceIp().getIp4Address()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(MANAGEMENT_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    selector = DefaultTrafficSelector.builder().matchInPort(PortNumber.LOCAL).matchEthType(Ethernet.TYPE_ARP).matchArpTpa(hostIp.getIp4Address()).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(host.location().port()).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(MANAGEMENT_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    selector = DefaultTrafficSelector.builder().matchInPort(PortNumber.LOCAL).matchEthType(Ethernet.TYPE_IPV4).matchIPDst(mService.serviceIpRange()).build();
    treatment = DefaultTrafficTreatment.builder().transition(TABLE_DST_IP).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(MANAGEMENT_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(mService.serviceIp().toIpPrefix()).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(MANAGEMENT_PRIORITY).forDevice(deviceId).forTable(TABLE_ACCESS_TYPE).makePermanent().build();
    processFlowRule(true, flowRule);
}
#end_block

#method_before
public void removeManagementNetworkRules(Host host, CordService mService) {
    checkNotNull(mService);
    for (FlowRule flowRule : flowRuleService.getFlowRulesById(appId)) {
        if (flowRule.deviceId().equals(host.location().deviceId())) {
            PortNumber port = getOutputFromTreatment(flowRule);
            if (port != null && port.equals(host.location().port())) {
                processFlowRule(false, flowRule);
            }
        }
    // TODO remove the other rules if mgmt network is not in use
    }
}
#method_after
public void removeManagementNetworkRules(Host host, CordService mService) {
    checkNotNull(mService);
    if (!mastershipService.isLocalMaster(host.location().deviceId())) {
        return;
    }
// TODO remove management network specific rules
}
#end_block

#method_before
private void processFirstTable(DeviceId deviceId, PortNumber dpPort, IpAddress dpIp) {
    // take vxlan packet out onto the physical port
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(PortNumber.LOCAL).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(dpPort).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take a vxlan encap'd packet through the Linux stack
    selector = DefaultTrafficSelector.builder().matchInPort(dpPort).matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_UDP).matchUdpDst(TpPort.tpPort(VXLAN_UDP_PORT)).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take a packet to the data plane ip through Linux stack
    selector = DefaultTrafficSelector.builder().matchInPort(dpPort).matchEthType(Ethernet.TYPE_IPV4).matchIPDst(dpIp.toIpPrefix()).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take an arp packet from physical through Linux stack
    selector = DefaultTrafficSelector.builder().matchInPort(dpPort).matchEthType(Ethernet.TYPE_ARP).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take all else to the next table
    selector = DefaultTrafficSelector.builder().build();
    treatment = DefaultTrafficTreatment.builder().transition(TABLE_IN_PORT).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(LOWEST_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
}
#method_after
private void processFirstTable(DeviceId deviceId, PortNumber dpPort, IpAddress dpIp) {
    // take vxlan packet out onto the physical port
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(PortNumber.LOCAL).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(dpPort).build();
    FlowRule flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take a vxlan encap'd packet through the Linux stack
    selector = DefaultTrafficSelector.builder().matchInPort(dpPort).matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_UDP).matchUdpDst(TpPort.tpPort(VXLAN_UDP_PORT)).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take a packet to the data plane ip through Linux stack
    selector = DefaultTrafficSelector.builder().matchInPort(dpPort).matchEthType(Ethernet.TYPE_IPV4).matchIPDst(dpIp.toIpPrefix()).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take an arp packet from physical through Linux stack
    selector = DefaultTrafficSelector.builder().matchInPort(dpPort).matchEthType(Ethernet.TYPE_ARP).matchArpTpa(dpIp.getIp4Address()).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.LOCAL).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(HIGH_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take all else to the next table
    selector = DefaultTrafficSelector.builder().build();
    treatment = DefaultTrafficTreatment.builder().transition(TABLE_IN_PORT).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(LOWEST_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
    // take all vlan tagged packet to the Q_IN_Q table
    selector = DefaultTrafficSelector.builder().matchVlanId(VlanId.ANY).build();
    treatment = DefaultTrafficTreatment.builder().transition(TABLE_Q_IN_Q).build();
    flowRule = DefaultFlowRule.builder().fromApp(appId).withSelector(selector).withTreatment(treatment).withPriority(VSG_PRIORITY).forDevice(deviceId).forTable(TABLE_FIRST).makePermanent().build();
    processFlowRule(true, flowRule);
}
#end_block

#method_before
private PortNumber getDpPort(DeviceId deviceId, String dpIntf) {
    Port port = deviceService.getPorts(deviceId).stream().filter(p -> p.annotations().value(PORT_NAME).contains(dpIntf) && p.isEnabled()).findFirst().orElse(null);
    return port == null ? null : port.number();
}
#method_after
private PortNumber getDpPort(Host host) {
    String portName = host.annotations().value(DATA_PLANE_INTF);
    return portName == null ? null : getDpPort(host.location().deviceId(), portName);
}
#end_block

#method_before
private PortNumber getExternalPort(DeviceId deviceId) {
    return null;
}
#method_after
private PortNumber getExternalPort(DeviceId deviceId) {
    // TODO
    return null;
}
#end_block

#method_before
private MacAddress getExternalInterfaceMacAddress() {
    return null;
}
#method_after
private MacAddress getExternalInterfaceMacAddress() {
    // TODO
    return null;
}
#end_block

#method_before
private MacAddress getExternalRouterMacAddress() {
    return null;
}
#method_after
private MacAddress getExternalRouterMacAddress() {
    // TODO
    return null;
}
#end_block

#method_before
@Override
public OpenstackPort decode(ObjectNode json, CodecContext context) {
    HashMap<String, Ip4Address> fixedIpMap = new HashMap<>();
    JsonNode portInfo = json.get(PORT);
    if (portInfo == null) {
        portInfo = json;
    }
    String status = portInfo.path(STATUS).asText();
    String name = portInfo.path(NAME).asText();
    boolean adminStateUp = portInfo.path(ADMIN_STATUS).asBoolean();
    String networkId = portInfo.path(NETWORK_ID).asText();
    String tenantId = portInfo.path(TENANT_ID).asText();
    String deviceOwner = portInfo.path(DEVICE_OWNER).asText();
    String macStr = portInfo.path(MAC_ADDRESS).asText();
    ArrayNode fixedIpList = (ArrayNode) portInfo.path(FIXED_IPS);
    for (JsonNode fixedIpInfo : fixedIpList) {
        String subnetId = fixedIpInfo.path(SUBNET_ID).asText();
        String ipAddressStr = fixedIpInfo.path(IP_ADDRESS).asText();
        if (!fixedIpInfo.path(IP_ADDRESS).isMissingNode() && ipAddressStr != null) {
            Ip4Address ipAddress = Ip4Address.valueOf(ipAddressStr);
            fixedIpMap.put(subnetId, ipAddress);
        }
    }
    String id = portInfo.path(ID).asText();
    ArrayNode securityGroupList = (ArrayNode) portInfo.path(SECURITY_GROUPS);
    Collection<String> securityGroupIdList = Lists.newArrayList();
    securityGroupList.forEach(securityGroup -> securityGroupIdList.add(securityGroup.asText()));
    String deviceId = portInfo.path(DEVICE_ID).asText();
    OpenstackPort.Builder openstackPortBuilder = OpenstackPort.builder();
    OpenstackPort.PortStatus portStatus = status.equals("N/A") ? OpenstackPort.PortStatus.NA : OpenstackPort.PortStatus.valueOf(status);
    openstackPortBuilder.portStatus(portStatus).name(name).adminState(adminStateUp).netwrokId(networkId).tenantId(tenantId).deviceOwner(deviceOwner).macAddress(MacAddress.valueOf(macStr)).fixedIps(fixedIpMap).id(id).deviceId(deviceId).securityGroup(securityGroupIdList);
    OpenstackPort openstackPort = openstackPortBuilder.build();
    return openstackPort;
}
#method_after
@Override
public OpenstackPort decode(ObjectNode json, CodecContext context) {
    checkNotNull(json);
    HashMap<String, Ip4Address> fixedIpMap = new HashMap<>();
    JsonNode portInfo = json.get(PORT);
    if (portInfo == null) {
        portInfo = json;
    }
    String status = portInfo.path(STATUS).asText();
    String name = portInfo.path(NAME).asText();
    boolean adminStateUp = portInfo.path(ADMIN_STATUS).asBoolean();
    String networkId = portInfo.path(NETWORK_ID).asText();
    String tenantId = portInfo.path(TENANT_ID).asText();
    String deviceOwner = portInfo.path(DEVICE_OWNER).asText();
    String macStr = portInfo.path(MAC_ADDRESS).asText();
    ArrayNode fixedIpList = (ArrayNode) portInfo.path(FIXED_IPS);
    for (JsonNode fixedIpInfo : fixedIpList) {
        String subnetId = fixedIpInfo.path(SUBNET_ID).asText();
        String ipAddressStr = fixedIpInfo.path(IP_ADDRESS).asText();
        if (!fixedIpInfo.path(IP_ADDRESS).isMissingNode() && ipAddressStr != null) {
            Ip4Address ipAddress = Ip4Address.valueOf(ipAddressStr);
            fixedIpMap.put(subnetId, ipAddress);
        }
    }
    String id = portInfo.path(ID).asText();
    ArrayNode securityGroupList = (ArrayNode) portInfo.path(SECURITY_GROUPS);
    Collection<String> securityGroupIdList = Lists.newArrayList();
    securityGroupList.forEach(securityGroup -> securityGroupIdList.add(securityGroup.asText()));
    String deviceId = portInfo.path(DEVICE_ID).asText();
    Map<IpAddress, MacAddress> addressPairs = Maps.newHashMap();
    for (JsonNode addrPair : (ArrayNode) portInfo.path(ADDRESS_PAIR)) {
        try {
            addressPairs.put(IpAddress.valueOf(addrPair.path(IP_ADDRESS).asText()), MacAddress.valueOf(addrPair.path(MAC_ADDRESS).asText()));
        } catch (IllegalArgumentException e) {
            log.debug("Invalid address pair {}", addrPair.toString());
        }
    }
    OpenstackPort.Builder openstackPortBuilder = OpenstackPort.builder();
    OpenstackPort.PortStatus portStatus = status.equals(NA) ? OpenstackPort.PortStatus.NA : OpenstackPort.PortStatus.valueOf(status);
    openstackPortBuilder.portStatus(portStatus).name(name).adminState(adminStateUp).netwrokId(networkId).tenantId(tenantId).deviceOwner(deviceOwner).macAddress(MacAddress.valueOf(macStr)).fixedIps(fixedIpMap).id(id).deviceId(deviceId).securityGroup(securityGroupIdList);
    if (!addressPairs.isEmpty()) {
        openstackPortBuilder.allowedAddressPairs(addressPairs);
    }
    OpenstackPort openstackPort = openstackPortBuilder.build();
    return openstackPort;
}
#end_block

#method_before
@Override
public void addServiceVm(CordVtnNode node, ConnectPoint connectPoint) {
    Port port = deviceService.getPort(connectPoint.deviceId(), connectPoint.port());
    OpenstackPort vPort = openstackService.port(port);
    if (vPort == null) {
        log.warn("Failed to get OpenstackPort for {}", getPortName(port));
        return;
    }
    MacAddress mac = vPort.macAddress();
    HostId hostId = HostId.hostId(mac);
    Host host = hostService.getHost(hostId);
    if (host != null) {
        // Host is already known to the system, no HOST_ADDED event is triggered in this case.
        // It happens when the application is restarted.
        String vmId = host.annotations().value(OPENSTACK_VM_ID);
        if (vmId != null && vmId.equals(vPort.deviceId())) {
            serviceVmAdded(host);
            return;
        } else {
            hostProvider.hostVanished(host.id());
        }
    }
    Set<IpAddress> ip = Sets.newHashSet(vPort.fixedIps().values());
    SparseAnnotations annotations = DefaultAnnotations.builder().set(OPENSTACK_VM_ID, vPort.deviceId()).set(SERVICE_ID, vPort.networkId()).set(LOCATION_IP, node.dpIp().ip().toString()).build();
    HostDescription hostDesc = new DefaultHostDescription(mac, VlanId.NONE, new HostLocation(connectPoint, System.currentTimeMillis()), ip, annotations);
    hostProvider.hostDetected(hostId, hostDesc, false);
}
#method_after
@Override
public void addServiceVm(CordVtnNode node, ConnectPoint connectPoint) {
    Port port = deviceService.getPort(connectPoint.deviceId(), connectPoint.port());
    OpenstackPort vPort = openstackService.port(port);
    if (vPort == null) {
        log.warn("Failed to get OpenstackPort for {}", getPortName(port));
        return;
    }
    MacAddress mac = vPort.macAddress();
    HostId hostId = HostId.hostId(mac);
    Host host = hostService.getHost(hostId);
    if (host != null) {
        // Host is already known to the system, no HOST_ADDED event is triggered in this case.
        // It happens when the application is restarted.
        String vmId = host.annotations().value(OPENSTACK_VM_ID);
        if (vmId != null && vmId.equals(vPort.deviceId())) {
            serviceVmAdded(host);
            return;
        } else {
            hostProvider.hostVanished(host.id());
        }
    }
    Set<IpAddress> ip = Sets.newHashSet(vPort.fixedIps().values());
    DefaultAnnotations.Builder annotations = DefaultAnnotations.builder().set(SERVICE_ID, vPort.networkId()).set(OPENSTACK_VM_ID, vPort.deviceId()).set(OPENSTACK_PORT_ID, vPort.id()).set(DATA_PLANE_IP, node.dpIp().ip().toString()).set(DATA_PLANE_INTF, node.dpIntf());
    String serviceVlan = getServiceVlan(vPort);
    if (serviceVlan != null) {
        annotations.set(S_TAG, serviceVlan);
    }
    HostDescription hostDesc = new DefaultHostDescription(mac, VlanId.NONE, new HostLocation(connectPoint, System.currentTimeMillis()), ip, annotations.build());
    hostProvider.hostDetected(hostId, hostDesc, false);
}
#end_block

#method_before
@Override
public void removeServiceVm(ConnectPoint connectPoint) {
    Host host = hostService.getConnectedHosts(connectPoint).stream().findFirst().orElse(null);
    if (host == null) {
        log.debug("No host is connected on {}", connectPoint.toString());
        return;
    }
    hostProvider.hostVanished(host.id());
}
#method_after
@Override
public void removeServiceVm(ConnectPoint connectPoint) {
    hostService.getConnectedHosts(connectPoint).stream().forEach(host -> hostProvider.hostVanished(host.id()));
}
#end_block

#method_before
private IpAddress getTunnelIp(Host host) {
    return IpAddress.valueOf(host.annotations().value(LOCATION_IP));
}
#method_after
private IpAddress getTunnelIp(Host host) {
    String ip = host.annotations().value(DATA_PLANE_IP);
    return ip == null ? null : IpAddress.valueOf(ip);
}
#end_block

#method_before
private void serviceVmAdded(Host host) {
    String vNetId = host.annotations().value(SERVICE_ID);
    OpenstackNetwork vNet = openstackService.network(vNetId);
    if (vNet == null) {
        log.warn("Failed to get OpenStack network {} for VM {}({}).", vNetId, host.id(), host.annotations().value(OPENSTACK_VM_ID));
        return;
    }
    log.info("VM {} is detected, MAC: {} IP: {}", host.annotations().value(OPENSTACK_VM_ID), host.mac(), host.ipAddresses().stream().findFirst().get());
    CordService service = getCordService(vNet);
    if (service == null) {
        return;
    }
    if (service.serviceType().equals(CordService.ServiceType.MANAGEMENT)) {
        ruleInstaller.populateManagementNetworkRules(host, service);
    } else {
        // TODO check if the service needs an update on its group buckets after done CORD-433
        ruleInstaller.updateServiceGroup(service);
        arpProxy.addServiceIp(service.serviceIp());
        // sends gratuitous ARP here for the case of adding existing VMs
        // when ONOS or cordvtn app is restarted
        arpProxy.sendGratuitousArp(service.serviceIp(), gatewayMac, Sets.newHashSet(host));
    }
    ruleInstaller.populateBasicConnectionRules(host, getTunnelIp(host), vNet);
    registerDhcpLease(host, service);
}
#method_after
private void serviceVmAdded(Host host) {
    String vNetId = host.annotations().value(SERVICE_ID);
    if (vNetId == null) {
        // ignore this host, it is not the service VM, or it's a vSG
        return;
    }
    OpenstackNetwork vNet = openstackService.network(vNetId);
    if (vNet == null) {
        log.warn("Failed to get OpenStack network {} for VM {}({}).", vNetId, host.id(), host.annotations().value(OPENSTACK_VM_ID));
        return;
    }
    log.info("VM {} is detected, MAC: {} IP: {}", host.annotations().value(OPENSTACK_VM_ID), host.mac(), host.ipAddresses().stream().findFirst().get());
    CordService service = getCordService(vNet);
    if (service == null) {
        return;
    }
    if (service.serviceType().equals(CordService.ServiceType.MANAGEMENT)) {
        ruleInstaller.populateManagementNetworkRules(host, service);
    } else {
        // TODO check if the service needs an update on its group buckets after done CORD-433
        ruleInstaller.updateServiceGroup(service);
        arpProxy.addGateway(service.serviceIp(), privateGatewayMac);
        // sends gratuitous ARP here for the case of adding existing VMs
        // when ONOS or cordvtn app is restarted
        arpProxy.sendGratuitousArpForGateway(service.serviceIp(), Sets.newHashSet(host));
    }
    registerDhcpLease(host, service);
    ruleInstaller.populateBasicConnectionRules(host, getTunnelIp(host), vNet);
    String serviceVlan = host.annotations().value(S_TAG);
    if (serviceVlan != null) {
        log.debug("vSG VM detected {}", host.id());
        Map<IpAddress, MacAddress> vSgs = getSubscriberGateways(host);
        vSgs.entrySet().stream().forEach(entry -> addVirtualSubscriberGateway(host, entry.getKey(), entry.getValue(), serviceVlan));
        ruleInstaller.populateSubscriberGatewayRules(host, vSgs.keySet());
    }
}
#end_block

#method_before
private void serviceVmRemoved(Host host) {
    if (host.annotations().value(OPENSTACK_VM_ID) == null) {
        // this host was not injected from CordVtn, just return
        return;
    }
    String vNetId = host.annotations().value(SERVICE_ID);
    OpenstackNetwork vNet = openstackService.network(host.annotations().value(SERVICE_ID));
    if (vNet == null) {
        log.warn("Failed to get OpenStack network {} for VM {}({}).", vNetId, host.id(), host.annotations().value(OPENSTACK_VM_ID));
        return;
    }
    log.info("VM {} is vanished, MAC: {} IP: {}", host.annotations().value(OPENSTACK_VM_ID), host.mac(), host.ipAddresses().stream().findFirst().get());
    ruleInstaller.removeBasicConnectionRules(host);
    dhcpService.removeStaticMapping(host.mac());
    CordService service = getCordService(vNet);
    if (service == null) {
        return;
    }
    if (service.serviceType().equals(CordService.ServiceType.MANAGEMENT)) {
        ruleInstaller.removeManagementNetworkRules(host, service);
    } else {
        // TODO check if the service needs an update on its group buckets after done CORD-433
        ruleInstaller.updateServiceGroup(service);
        if (getHostsWithOpenstackNetwork(vNet).isEmpty()) {
            arpProxy.removeServiceIp(service.serviceIp());
        }
    }
}
#method_after
private void serviceVmRemoved(Host host) {
    String vNetId = host.annotations().value(SERVICE_ID);
    if (vNetId == null) {
        // ignore it, it's not the service VM or it's a vSG
        String serviceVlan = host.annotations().value(S_TAG);
        if (serviceVlan != null) {
            log.info("vSG {} removed", host.id());
        }
        return;
    }
    OpenstackNetwork vNet = openstackService.network(vNetId);
    if (vNet == null) {
        log.warn("Failed to get OpenStack network {} for VM {}({}).", vNetId, host.id(), host.annotations().value(OPENSTACK_VM_ID));
        return;
    }
    log.info("VM {} is vanished, MAC: {} IP: {}", host.annotations().value(OPENSTACK_VM_ID), host.mac(), host.ipAddresses().stream().findFirst().get());
    ruleInstaller.removeBasicConnectionRules(host);
    dhcpService.removeStaticMapping(host.mac());
    CordService service = getCordService(vNet);
    if (service == null) {
        return;
    }
    if (service.serviceType().equals(CordService.ServiceType.MANAGEMENT)) {
        ruleInstaller.removeManagementNetworkRules(host, service);
    } else {
        // TODO check if the service needs an update on its group buckets after done CORD-433
        ruleInstaller.updateServiceGroup(service);
        if (getHostsWithOpenstackNetwork(vNet).isEmpty()) {
            arpProxy.removeGateway(service.serviceIp());
        }
    }
}
#end_block

#method_before
private void readConfiguration() {
    CordVtnConfig config = configRegistry.getConfig(appId, CordVtnConfig.class);
    if (config == null) {
        log.debug("No configuration found");
        return;
    }
    setServiceGatewayMac(config.gatewayMac());
}
#method_after
private void readConfiguration() {
    CordVtnConfig config = configRegistry.getConfig(appId, CordVtnConfig.class);
    if (config == null) {
        log.debug("No configuration found");
        return;
    }
    setPrivateGatewayMac(config.privateGatewayMac());
    setPublicGatewayMac(config.publicGateways());
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    Ethernet ethPacket = context.inPacket().parsed();
    if (ethPacket == null || ethPacket.getEtherType() != Ethernet.TYPE_ARP) {
        return;
    }
    arpProxy.processArpPacket(context, ethPacket, gatewayMac);
}
#method_after
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    Ethernet ethPacket = context.inPacket().parsed();
    if (ethPacket == null || ethPacket.getEtherType() != Ethernet.TYPE_ARP) {
        return;
    }
    arpProxy.processArpPacket(context, ethPacket);
}
#end_block

#method_before
public OpenstackPort build() {
    return new OpenstackPort(status, name, adminStateUp, networkId, networkId, deviceOwner, macAddress, fixedIps, id, securityGroups, deviceId);
}
#method_after
public OpenstackPort build() {
    return new OpenstackPort(status, name, allowedAddressPairs, adminStateUp, networkId, networkId, deviceOwner, macAddress, fixedIps, id, securityGroups, deviceId);
}
#end_block

#method_before
@Override
public OpenstackRouter decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    JsonNode routerInfo = json.get(ROUTER);
    if (routerInfo == null) {
        routerInfo = json;
    }
    String tenantId = checkNotNull(routerInfo.path(TENANT_ID).asText());
    String id = checkNotNull(routerInfo.path(ID).asText());
    String name = checkNotNull(routerInfo.path(NAME).asText());
    String status = checkNotNull(routerInfo.path(STATUS).asText());
    String adminStateUp = checkNotNull(routerInfo.path(ADMIN_STATE_UP).asText());
    OpenstackExternalGateway.Builder osExtBuiler = OpenstackExternalGateway.builder();
    if (!routerInfo.path(EXTERNAL_GW_INFO).isMissingNode()) {
        String externalGatewayNetId = checkNotNull(routerInfo.path(EXTERNAL_GW_INFO).path(NETWORK_ID).asText());
        Map<String, Ip4Address> fixedIpMap = Maps.newHashMap();
        if (!routerInfo.path(EXTERNAL_GW_INFO).path(EXTERNAL_FIXED_IPS).isMissingNode()) {
            ArrayNode fixedIpList = (ArrayNode) routerInfo.path(EXTERNAL_GW_INFO).path(EXTERNAL_FIXED_IPS);
            for (JsonNode fixedIpInfo : fixedIpList) {
                String subnetId = checkNotNull(fixedIpInfo.path(SUBNET_ID).asText());
                String ipAddressStr = checkNotNull(fixedIpInfo.path(IP_ADDRESS).asText());
                if (!fixedIpInfo.path(IP_ADDRESS).isMissingNode() && ipAddressStr != null) {
                    fixedIpMap.put(subnetId, Ip4Address.valueOf(ipAddressStr));
                }
            }
        }
        osExtBuiler.networkId(externalGatewayNetId).enablePnat(true).externalFixedIps(fixedIpMap);
    }
    OpenstackRouter.Builder osBuilder = new OpenstackRouter.Builder().tenantId(tenantId).id(id).name(name).status(OpenstackRouter.RouterStatus.valueOf(status)).adminStateUp(Boolean.valueOf(adminStateUp)).gatewayExternalInfo(osExtBuiler.build());
    return osBuilder.build();
}
#method_after
@Override
public OpenstackRouter decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    JsonNode routerInfo = json.get(ROUTER);
    if (routerInfo == null) {
        routerInfo = json;
    }
    String tenantId = checkNotNull(routerInfo.path(TENANT_ID).asText());
    String id = checkNotNull(routerInfo.path(ID).asText());
    String name = checkNotNull(routerInfo.path(NAME).asText());
    String status = checkNotNull(routerInfo.path(STATUS).asText());
    String adminStateUp = checkNotNull(routerInfo.path(ADMIN_STATE_UP).asText());
    OpenstackExternalGateway.Builder osExtBuiler = new OpenstackExternalGateway.Builder();
    if (!routerInfo.path(EXTERNAL_GW_INFO).isMissingNode()) {
        String externalGatewayNetId = checkNotNull(routerInfo.path(EXTERNAL_GW_INFO).path(NETWORK_ID).asText());
        Map<String, Ip4Address> fixedIpMap = Maps.newHashMap();
        if (!routerInfo.path(EXTERNAL_GW_INFO).path(EXTERNAL_FIXED_IPS).isMissingNode()) {
            ArrayNode fixedIpList = (ArrayNode) routerInfo.path(EXTERNAL_GW_INFO).path(EXTERNAL_FIXED_IPS);
            for (JsonNode fixedIpInfo : fixedIpList) {
                String subnetId = checkNotNull(fixedIpInfo.path(SUBNET_ID).asText());
                String ipAddressStr = checkNotNull(fixedIpInfo.path(IP_ADDRESS).asText());
                if (!fixedIpInfo.path(IP_ADDRESS).isMissingNode() && ipAddressStr != null) {
                    fixedIpMap.put(subnetId, Ip4Address.valueOf(ipAddressStr));
                }
            }
        }
        osExtBuiler.networkId(externalGatewayNetId).enablePnat(true).externalFixedIps(fixedIpMap);
    }
    OpenstackRouter.Builder osBuilder = new OpenstackRouter.Builder().tenantId(tenantId).id(id).name(name).status(OpenstackRouter.RouterStatus.valueOf(status)).adminStateUp(Boolean.valueOf(adminStateUp)).gatewayExternalInfo(osExtBuiler.build());
    return osBuilder.build();
}
#end_block

#method_before
@PUT
@Path("{subnetUUID}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response updateSubnet(@PathParam("id") String id, final InputStream input) {
    return Response.status(Response.Status.OK).build();
}
#method_after
@PUT
@Path("{subnetId}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response updateSubnet(@PathParam("subnetId") String id, final InputStream input) {
    return Response.status(Response.Status.OK).build();
}
#end_block

#method_before
@DELETE
@Path("{subnetUUID}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response deleteSubnet(@PathParam("id") String id, final InputStream input) {
    return Response.status(Response.Status.OK).build();
}
#method_after
@DELETE
@Path("{subnetId}")
@Produces(MediaType.APPLICATION_JSON)
public Response deleteSubnet(@PathParam("subnetId") String id) {
    return Response.status(Response.Status.OK).build();
}
#end_block

#method_before
public void processPacketIn(InboundPacket pkt, Collection<OpenstackPortInfo> openstackPortInfoCollection) {
    Ethernet ethRequest = pkt.parsed();
    ARP arp = (ARP) ethRequest.getPayload();
    if (arp.getOpCode() != ARP.OP_REQUEST) {
        return;
    }
    IpAddress sourceIp = Ip4Address.valueOf(arp.getSenderProtocolAddress());
    MacAddress srcMac = MacAddress.valueOf(arp.getSenderHardwareAddress());
    IpAddress gatewayIp = openstackPortInfoCollection.stream().filter(p -> p.ip().equals(sourceIp) && p.mac().equals(srcMac)).findFirst().orElse(null).gatewayIP();
    IpAddress targetIp = Ip4Address.valueOf(arp.getTargetProtocolAddress());
    MacAddress dstMac;
    if (targetIp.equals(gatewayIp)) {
        dstMac = GATEWAY_MAC;
    } else {
        dstMac = getMacFromHostService(targetIp);
        if (dstMac == null) {
            dstMac = getMacFromOpenstack(targetIp);
        }
    }
    if (dstMac == null) {
        log.debug("Failed to find MAC address for {}", targetIp.toString());
        return;
    }
    Ethernet ethReply = ARP.buildArpReply(targetIp.getIp4Address(), dstMac, ethRequest);
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(pkt.receivedFrom().port()).build();
    packetService.emit(new DefaultOutboundPacket(pkt.receivedFrom().deviceId(), treatment, ByteBuffer.wrap(ethReply.serialize())));
}
#method_after
public void processPacketIn(InboundPacket pkt, Collection<OpenstackPortInfo> openstackPortInfoCollection) {
    Ethernet ethRequest = pkt.parsed();
    ARP arp = (ARP) ethRequest.getPayload();
    if (arp.getOpCode() != ARP.OP_REQUEST) {
        return;
    }
    IpAddress sourceIp = Ip4Address.valueOf(arp.getSenderProtocolAddress());
    MacAddress srcMac = MacAddress.valueOf(arp.getSenderHardwareAddress());
    OpenstackPortInfo portInfo = openstackPortInfoCollection.stream().filter(p -> p.ip().equals(sourceIp) && p.mac().equals(srcMac)).findFirst().orElse(null);
    IpAddress targetIp = Ip4Address.valueOf(arp.getTargetProtocolAddress());
    MacAddress dstMac;
    if (targetIp.equals(portInfo == null ? null : portInfo.gatewayIP())) {
        dstMac = GATEWAY_MAC;
    } else {
        dstMac = getMacFromHostService(targetIp);
        if (dstMac == null) {
            dstMac = getMacFromOpenstack(targetIp);
        }
    }
    if (dstMac == null) {
        log.debug("Failed to find MAC address for {}", targetIp.toString());
        return;
    }
    Ethernet ethReply = ARP.buildArpReply(targetIp.getIp4Address(), dstMac, ethRequest);
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(pkt.receivedFrom().port()).build();
    packetService.emit(new DefaultOutboundPacket(pkt.receivedFrom().deviceId(), treatment, ByteBuffer.wrap(ethReply.serialize())));
}
#end_block

#method_before
@DELETE
@Path("{id}")
public Response deleteRouter(@PathParam("id") String id) {
    checkNotNull(id);
    OpenstackRoutingService routingService = getService(OpenstackRoutingService.class);
    routingService.deleteRouter(id);
    log.debug("REST API DELETE routers is called {}", id);
    return Response.status(Response.Status.OK).build();
}
#method_after
@DELETE
@Path("{id}")
@Produces(MediaType.APPLICATION_JSON)
public Response deleteRouter(@PathParam("id") String id) {
    checkNotNull(id);
    OpenstackRoutingService routingService = getService(OpenstackRoutingService.class);
    routingService.deleteRouter(id);
    log.debug("REST API DELETE routers is called {}", id);
    return Response.status(Response.Status.OK).build();
}
#end_block

#method_before
@Override
public OpenstackSecurityGroup decode(ObjectNode json, CodecContext context) {
    JsonNode securityGroupNode = json.get(SECURITY_GROUP);
    if (securityGroupNode == null) {
        log.warn("SecurityGroup Json data is null");
        return null;
    }
    String description = securityGroupNode.path(DESCRIPTION).asText();
    String id = securityGroupNode.path(ID).asText();
    String name = securityGroupNode.path(NAME).asText();
    ArrayNode ruleInfoList = (ArrayNode) securityGroupNode.path(SECURITY_GROUP_RULES);
    Collection<OpenstackSecurityGroupRule> rules = Lists.newArrayList();
    for (JsonNode ruleInfo : ruleInfoList) {
        OpenstackSecurityGroupRule openstackSecurityGroupRule = OpenstackSecurityGroupRule.builder().direction(ruleInfo.path(DIRECTION).asText()).etherType(ruleInfo.path(EHTERTYPE).asText()).id(ruleInfo.path(ID).asText()).portRangeMax(ruleInfo.path(PORT_RANGE_MAX).asText()).portRangeMin(ruleInfo.path(PORT_RANGE_MIN).asText()).protocol(ruleInfo.path(PROTOCOL).asText()).remoteGroupId(ruleInfo.path(REMOTE_GROUP_ID).asText()).remoteIpPrefix(ruleInfo.path(REMOTE_IP_PREFIX).asText()).securityGroupId(ruleInfo.path(SECURITY_GROUP_ID).asText()).tenantId(ruleInfo.path(TENAN_ID).asText()).build();
        rules.add(openstackSecurityGroupRule);
    }
    String tenantId = securityGroupNode.path(TENAN_ID).asText();
    OpenstackSecurityGroup openstackSecurityGroup = OpenstackSecurityGroup.builder().description(description).id(id).name(name).rules(rules).tenantId(tenantId).build();
    return openstackSecurityGroup;
}
#method_after
@Override
public OpenstackSecurityGroup decode(ObjectNode json, CodecContext context) {
    JsonNode securityGroupNode = json.get(SECURITY_GROUP);
    if (securityGroupNode == null) {
        log.warn("SecurityGroup Json data is null");
        return null;
    }
    String description = securityGroupNode.path(DESCRIPTION).asText();
    String id = securityGroupNode.path(ID).asText();
    String name = securityGroupNode.path(NAME).asText();
    ArrayNode ruleInfoList = (ArrayNode) securityGroupNode.path(SECURITY_GROUP_RULES);
    Collection<OpenstackSecurityGroupRule> rules = Lists.newArrayList();
    for (JsonNode ruleInfo : ruleInfoList) {
        OpenstackSecurityGroupRule openstackSecurityGroupRule = new OpenstackSecurityGroupRule.Builder().direction(ruleInfo.path(DIRECTION).asText()).etherType(ruleInfo.path(EHTERTYPE).asText()).id(ruleInfo.path(ID).asText()).portRangeMax(ruleInfo.path(PORT_RANGE_MAX).asText()).portRangeMin(ruleInfo.path(PORT_RANGE_MIN).asText()).protocol(ruleInfo.path(PROTOCOL).asText()).remoteGroupId(ruleInfo.path(REMOTE_GROUP_ID).asText()).remoteIpPrefix(ruleInfo.path(REMOTE_IP_PREFIX).asText()).securityGroupId(ruleInfo.path(SECURITY_GROUP_ID).asText()).tenantId(ruleInfo.path(TENAN_ID).asText()).build();
        rules.add(openstackSecurityGroupRule);
    }
    String tenantId = securityGroupNode.path(TENAN_ID).asText();
    OpenstackSecurityGroup openstackSecurityGroup = OpenstackSecurityGroup.builder().description(description).id(id).name(name).rules(rules).tenantId(tenantId).build();
    return openstackSecurityGroup;
}
#end_block

#method_before
@Override
public FlowClassifier build() {
    checkNotNull(flowClassifierId, FLOW_CLASSIFIER_ID_NOT_NULL);
    checkNotNull(tenantId, TENANT_ID_NOT_NULL);
    checkNotNull(name, NAME_NOT_NULL);
    checkNotNull(etherType, ETHER_TYPE_NOT_NULL);
    String description = null;
    String protocol = null;
    int minSrcPortRange = NULL_PORT;
    int maxSrcPortRange = NULL_PORT;
    int minDstPortRange = NULL_PORT;
    int maxDstPortRange = NULL_PORT;
    IpPrefix srcIpPrefix = null;
    IpPrefix dstIpPrefix = null;
    VirtualPortId srcPort = null;
    VirtualPortId dstPort = null;
    if (isFlowClassifierDescriptionSet) {
        description = this.description;
    }
    if (isProtocolSet) {
        protocol = this.protocol;
    }
    if (isMinSrcPortRangeSet) {
        minSrcPortRange = this.minSrcPortRange;
        if (!isMaxSrcPortRangeSet) {
            maxSrcPortRange = this.minSrcPortRange;
        }
    }
    if (isMaxSrcPortRangeSet) {
        maxSrcPortRange = this.maxSrcPortRange;
        if (!isMinSrcPortRangeSet) {
            minSrcPortRange = this.maxSrcPortRange;
        }
    }
    if (isMinDstPortRangeSet) {
        minDstPortRange = this.minDstPortRange;
        if (!isMaxDstPortRangeSet) {
            maxDstPortRange = this.minDstPortRange;
        }
    }
    if (isMaxDstPortRangeSet) {
        maxDstPortRange = this.maxDstPortRange;
        if (!isMinDstPortRangeSet) {
            minDstPortRange = this.maxDstPortRange;
        }
    }
    if (isSrcIpPrefixSet) {
        srcIpPrefix = this.srcIpPrefix;
    }
    if (isDstIpPrefixSet) {
        dstIpPrefix = this.dstIpPrefix;
    }
    if (isSrcPortSet) {
        srcPort = this.srcPort;
    }
    if (isDstPortSet) {
        dstPort = this.dstPort;
    }
    return new DefaultFlowClassifier(flowClassifierId, tenantId, name, description, etherType, protocol, minSrcPortRange, maxSrcPortRange, minDstPortRange, maxDstPortRange, srcIpPrefix, dstIpPrefix, srcPort, dstPort);
}
#method_after
@Override
public FlowClassifier build() {
    checkNotNull(flowClassifierId, FLOW_CLASSIFIER_ID_NOT_NULL);
    checkNotNull(tenantId, TENANT_ID_NOT_NULL);
    checkNotNull(name, NAME_NOT_NULL);
    checkNotNull(etherType, ETHER_TYPE_NOT_NULL);
    String description = null;
    String protocol = null;
    int minSrcPortRange = NULL_PORT;
    int maxSrcPortRange = NULL_PORT;
    int minDstPortRange = NULL_PORT;
    int maxDstPortRange = NULL_PORT;
    IpPrefix srcIpPrefix = null;
    IpPrefix dstIpPrefix = null;
    VirtualPortId srcPort = null;
    VirtualPortId dstPort = null;
    if (isFlowClassifierDescriptionSet) {
        description = this.description;
    }
    if (isProtocolSet) {
        protocol = this.protocol;
    }
    if (isMinSrcPortRangeSet) {
        minSrcPortRange = this.minSrcPortRange;
    }
    if (isMaxSrcPortRangeSet) {
        maxSrcPortRange = this.maxSrcPortRange;
    }
    if (isMinDstPortRangeSet) {
        minDstPortRange = this.minDstPortRange;
    }
    if (isMaxDstPortRangeSet) {
        maxDstPortRange = this.maxDstPortRange;
    }
    if (isSrcIpPrefixSet) {
        srcIpPrefix = this.srcIpPrefix;
    }
    if (isDstIpPrefixSet) {
        dstIpPrefix = this.dstIpPrefix;
    }
    if (isSrcPortSet) {
        srcPort = this.srcPort;
    }
    if (isDstPortSet) {
        dstPort = this.dstPort;
    }
    return new DefaultFlowClassifier(flowClassifierId, tenantId, name, description, etherType, protocol, minSrcPortRange, maxSrcPortRange, minDstPortRange, maxDstPortRange, srcIpPrefix, dstIpPrefix, srcPort, dstPort);
}
#end_block

#method_before
@Test
public void testLoadBalanceIdMap() {
    final PortChain portChain = getPortChain();
    final FiveTuple fiveTuple1 = DefaultFiveTuple.builder().setIpSrc(IpAddress.valueOf("1.1.1.1")).setIpDst(IpAddress.valueOf("2.2.2.2")).setPortSrc(PortNumber.portNumber(500)).setPortDst(PortNumber.portNumber(1000)).setProtocol(IPv4.PROTOCOL_TCP).build();
    PortPairId portPairId = PortPairId.of("a4444444-4a56-2a6e-cd3a-9dee4e2ec345");
    PortPairGroupId portPairGroupId = PortPairGroupId.of("73333333-fc23-aeb6-f44b-56dc5e2fb3ae");
    final LoadBalanceId id1 = LoadBalanceId.of((byte) 1);
    Map<PortPairGroupId, PortPairId> map = new HashMap<>();
    map.put(portPairGroupId, portPairId);
    portChain.addLoadBalancePath(fiveTuple1, id1, map);
    Set<FiveTuple> keys = portChain.getLoadBalancePathKeys();
    List<PortPairId> path = portChain.getLoadBalancePath(fiveTuple1);
    assertThat(portChain.getLoadBalancePath(fiveTuple1), is(path));
    assertThat(portChain.getLoadBalancePath(id1), is(path));
    assertThat(portChain.getLoadBalanceId(fiveTuple1), is(id1));
    assertThat(keys.contains(fiveTuple1), is(true));
    assertThat(path.contains(portPairId), is(true));
}
#method_after
@Test
public void testLoadBalanceIdMap() {
    final PortChain portChain = getPortChain();
    final FiveTuple fiveTuple1 = DefaultFiveTuple.builder().setIpSrc(IpAddress.valueOf("1.1.1.1")).setIpDst(IpAddress.valueOf("2.2.2.2")).setPortSrc(PortNumber.portNumber(500)).setPortDst(PortNumber.portNumber(1000)).setProtocol(IPv4.PROTOCOL_TCP).build();
    PortPairId portPairId = PortPairId.of("a4444444-4a56-2a6e-cd3a-9dee4e2ec345");
    final LoadBalanceId id1 = LoadBalanceId.of((byte) 1);
    List<PortPairId> tempPath = Lists.newArrayList();
    tempPath.add(portPairId);
    portChain.addLoadBalancePath(fiveTuple1, id1, tempPath);
    Set<FiveTuple> keys = portChain.getLoadBalanceIdMapKeys();
    List<PortPairId> path = portChain.getLoadBalancePath(fiveTuple1);
    assertThat(portChain.getLoadBalancePath(fiveTuple1), is(path));
    assertThat(portChain.getLoadBalancePath(id1), is(path));
    assertThat(portChain.getLoadBalanceId(fiveTuple1), is(id1));
    assertThat(keys.contains(fiveTuple1), is(true));
    assertThat(path.contains(portPairId), is(true));
}
#end_block

#method_before
private boolean comparePath(Collection<PortPairId> path1, Collection<PortPairId> path2) {
    Iterator it = path1.iterator();
    for (PortPairId portPairId : path2) {
        if (!portPairId.equals(it.next())) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean comparePath(List<PortPairId> path1, List<PortPairId> path2) {
    Iterator it = path1.iterator();
    for (PortPairId portPairId : path2) {
        if (!portPairId.equals(it.next())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public void addLoadBalancePath(FiveTuple fiveTupple, LoadBalanceId id, Map<PortPairGroupId, PortPairId> map) {
    this.sfcLoadBalanceIdMap.put(fiveTupple, id);
    this.sfcLoadBalancePathMap.put(id, map);
}
#method_after
@Override
public void addLoadBalancePath(FiveTuple fiveTuple, LoadBalanceId id, List<PortPairId> path) {
    this.sfcLoadBalanceIdMap.put(fiveTuple, id);
    this.sfcLoadBalancePathMap.put(id, path);
}
#end_block

#method_before
@Override
public List<PortPairId> getLoadBalancePath(LoadBalanceId id) {
    return ImmutableList.copyOf(this.sfcLoadBalancePathMap.get(id).values());
}
#method_after
@Override
public List<PortPairId> getLoadBalancePath(LoadBalanceId id) {
    return ImmutableList.copyOf(this.sfcLoadBalancePathMap.get(id));
}
#end_block

#method_before
@Override
public List<PortPairId> getLoadBalancePath(FiveTuple fiveTuple) {
    return ImmutableList.copyOf(this.sfcLoadBalancePathMap.get(this.sfcLoadBalanceIdMap.get(fiveTuple)).values());
}
#method_after
@Override
public List<PortPairId> getLoadBalancePath(FiveTuple fiveTuple) {
    return ImmutableList.copyOf(this.sfcLoadBalancePathMap.get(this.sfcLoadBalanceIdMap.get(fiveTuple)));
}
#end_block

#method_before
@Override
public LoadBalanceId matchPath(Map<PortPairGroupId, PortPairId> pathMap) {
    LoadBalanceId id = null;
    Collection<PortPairId> path = pathMap.values();
    for (Map.Entry<LoadBalanceId, Map<PortPairGroupId, PortPairId>> entry : sfcLoadBalancePathMap.entrySet()) {
        Map<PortPairGroupId, PortPairId> tempMap = entry.getValue();
        Collection<PortPairId> tempPath = tempMap.values();
        if (comparePath(path, tempPath)) {
            id = entry.getKey();
            break;
        }
    }
    return id;
}
#method_after
@Override
public Optional<LoadBalanceId> matchPath(List<PortPairId> path) {
    LoadBalanceId id = null;
    for (Map.Entry<LoadBalanceId, List<PortPairId>> entry : sfcLoadBalancePathMap.entrySet()) {
        List<PortPairId> tempPath = entry.getValue();
        if (comparePath(path, tempPath)) {
            id = entry.getKey();
            break;
        }
    }
    return Optional.of(id);
}
#end_block

#method_before
@Override
public void addLoadBalancePath(FiveTuple fiveTupple, LoadBalanceId id, Map<PortPairGroupId, PortPairId> map) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void addLoadBalancePath(FiveTuple fiveTuple, LoadBalanceId id, List<PortPairId> path) {
// TODO Auto-generated method stub
}
#end_block

#method_before
@Override
public LoadBalanceId matchPath(Map<PortPairGroupId, PortPairId> pathMap) {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public Optional<LoadBalanceId> matchPath(List<PortPairId> path) {
    // TODO Auto-generated method stub
    return null;
}
#end_block

#method_before
public static void processLeafEntry(TreeWalkListener listener, GeneratedYangParser.LeafStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, ParsableDataType.LEAF_DATA, ctx.IDENTIFIER().getText(), ENTRY);
    boolean result = validateSubStatementsCardinality(ctx);
    if (!result) {
        throw new ParserException(constructListenerErrorMessage(INVALID_CARDINALITY, yangConstruct, "", ENTRY));
    }
    YangLeaf leaf = new YangLeaf();
    leaf.setLeafName(ctx.IDENTIFIER().getText());
    Parsable tmpData = listener.getParsedDataStack().peek();
    YangLeavesHolder leaves;
    if (tmpData instanceof YangLeavesHolder) {
        leaves = (YangLeavesHolder) tmpData;
        leaves.addLeaf(leaf);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, ParsableDataType.LEAF_DATA, ctx.IDENTIFIER().getText(), ENTRY));
    }
    listener.getParsedDataStack().push(leaf);
}
#method_after
public static void processLeafEntry(TreeWalkListener listener, GeneratedYangParser.LeafStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, LEAF_DATA, ctx.IDENTIFIER().getText(), ENTRY);
    boolean result = validateSubStatementsCardinality(ctx);
    if (!result) {
        throw new ParserException(constructListenerErrorMessage(INVALID_CARDINALITY, yangConstruct, "", ENTRY));
    }
    YangLeaf leaf = new YangLeaf();
    leaf.setLeafName(ctx.IDENTIFIER().getText());
    Parsable tmpData = listener.getParsedDataStack().peek();
    YangLeavesHolder leaves;
    if (tmpData instanceof YangLeavesHolder) {
        leaves = (YangLeavesHolder) tmpData;
        leaves.addLeaf(leaf);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, LEAF_DATA, ctx.IDENTIFIER().getText(), ENTRY));
    }
    listener.getParsedDataStack().push(leaf);
}
#end_block

#method_before
public static void processLeafExit(TreeWalkListener listener, GeneratedYangParser.LeafStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, ParsableDataType.LEAF_DATA, ctx.IDENTIFIER().getText(), EXIT);
    if (listener.getParsedDataStack().peek() instanceof YangLeaf) {
        listener.getParsedDataStack().pop();
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, ParsableDataType.LEAF_DATA, ctx.IDENTIFIER().getText(), EXIT));
    }
}
#method_after
public static void processLeafExit(TreeWalkListener listener, GeneratedYangParser.LeafStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, LEAF_DATA, ctx.IDENTIFIER().getText(), EXIT);
    if (listener.getParsedDataStack().peek() instanceof YangLeaf) {
        listener.getParsedDataStack().pop();
    } else {
        throw new ParserException(constructListenerErrorMessage(MISSING_CURRENT_HOLDER, LEAF_DATA, ctx.IDENTIFIER().getText(), EXIT));
    }
}
#end_block

#method_before
public static boolean validateSubStatementsCardinality(GeneratedYangParser.LeafStatementContext ctx) {
    if (ctx.typeStatement().isEmpty() || (ctx.typeStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.TYPE_DATA;
        return false;
    }
    if ((!ctx.unitsStatement().isEmpty()) && (ctx.unitsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.UNITS_DATA;
        return false;
    }
    if ((!ctx.configStatement().isEmpty()) && (ctx.configStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.CONFIG_DATA;
        return false;
    }
    if ((!ctx.mandatoryStatement().isEmpty()) && (ctx.mandatoryStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.MANDATORY_DATA;
        return false;
    }
    if ((!ctx.descriptionStatement().isEmpty()) && (ctx.descriptionStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.DESCRIPTION_DATA;
        return false;
    }
    if ((!ctx.referenceStatement().isEmpty()) && (ctx.referenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.REFERENCE_DATA;
        return false;
    }
    if ((!ctx.statusStatement().isEmpty()) && (ctx.statusStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.STATUS_DATA;
        return false;
    }
    return true;
}
#method_after
private static boolean validateSubStatementsCardinality(GeneratedYangParser.LeafStatementContext ctx) {
    if (ctx.typeStatement().isEmpty() || (ctx.typeStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.TYPE_DATA;
        return false;
    }
    if ((!ctx.unitsStatement().isEmpty()) && (ctx.unitsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.UNITS_DATA;
        return false;
    }
    if ((!ctx.configStatement().isEmpty()) && (ctx.configStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.CONFIG_DATA;
        return false;
    }
    if ((!ctx.mandatoryStatement().isEmpty()) && (ctx.mandatoryStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.MANDATORY_DATA;
        return false;
    }
    if ((!ctx.descriptionStatement().isEmpty()) && (ctx.descriptionStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.DESCRIPTION_DATA;
        return false;
    }
    if ((!ctx.referenceStatement().isEmpty()) && (ctx.referenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.REFERENCE_DATA;
        return false;
    }
    if ((!ctx.statusStatement().isEmpty()) && (ctx.statusStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.STATUS_DATA;
        return false;
    }
    return true;
}
#end_block

#method_before
public static void processContainerEntry(TreeWalkListener listener, GeneratedYangParser.ContainerStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, ParsableDataType.CONTAINER_DATA, ctx.IDENTIFIER().getText(), ENTRY);
    boolean result = validateSubStatementsCardinality(ctx);
    if (!result) {
        throw new ParserException(constructListenerErrorMessage(INVALID_CARDINALITY, yangConstruct, "", ENTRY));
    }
    YangContainer container = new YangContainer();
    container.setName(ctx.IDENTIFIER().getText());
    Parsable curData = listener.getParsedDataStack().peek();
    if (curData instanceof YangNode) {
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(container);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, ParsableDataType.CONTAINER_DATA, ctx.IDENTIFIER().getText(), ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(container);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, ParsableDataType.CONTAINER_DATA, ctx.IDENTIFIER().getText(), ENTRY));
    }
}
#method_after
public static void processContainerEntry(TreeWalkListener listener, GeneratedYangParser.ContainerStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, CONTAINER_DATA, ctx.IDENTIFIER().getText(), ENTRY);
    boolean result = validateSubStatementsCardinality(ctx);
    if (!result) {
        throw new ParserException(constructListenerErrorMessage(INVALID_CARDINALITY, yangConstruct, "", ENTRY));
    }
    YangContainer container = new YangContainer();
    container.setName(ctx.IDENTIFIER().getText());
    Parsable curData = listener.getParsedDataStack().peek();
    if ((curData instanceof YangModule) || (curData instanceof YangContainer) || (curData instanceof YangList)) {
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(container);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, CONTAINER_DATA, ctx.IDENTIFIER().getText(), ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(container);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, CONTAINER_DATA, ctx.IDENTIFIER().getText(), ENTRY));
    }
}
#end_block

#method_before
public static void processContainerExit(TreeWalkListener listener, GeneratedYangParser.ContainerStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, ParsableDataType.CONTAINER_DATA, ctx.IDENTIFIER().getText(), EXIT);
    if (listener.getParsedDataStack().peek() instanceof YangContainer) {
        listener.getParsedDataStack().pop();
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, ParsableDataType.CONTAINER_DATA, ctx.IDENTIFIER().getText(), EXIT));
    }
}
#method_after
public static void processContainerExit(TreeWalkListener listener, GeneratedYangParser.ContainerStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, CONTAINER_DATA, ctx.IDENTIFIER().getText(), EXIT);
    if (listener.getParsedDataStack().peek() instanceof YangContainer) {
        listener.getParsedDataStack().pop();
    } else {
        throw new ParserException(constructListenerErrorMessage(MISSING_CURRENT_HOLDER, CONTAINER_DATA, ctx.IDENTIFIER().getText(), EXIT));
    }
}
#end_block

#method_before
public static boolean validateSubStatementsCardinality(GeneratedYangParser.ContainerStatementContext ctx) {
    if ((!ctx.presenceStatement().isEmpty()) && (ctx.presenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.PRESENCE_DATA;
        return false;
    }
    if ((!ctx.configStatement().isEmpty()) && (ctx.configStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.CONFIG_DATA;
        return false;
    }
    if ((!ctx.descriptionStatement().isEmpty()) && (ctx.descriptionStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.DESCRIPTION_DATA;
        return false;
    }
    if ((!ctx.referenceStatement().isEmpty()) && (ctx.referenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.REFERENCE_DATA;
        return false;
    }
    if ((!ctx.statusStatement().isEmpty()) && (ctx.statusStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.STATUS_DATA;
        return false;
    }
    return true;
}
#method_after
private static boolean validateSubStatementsCardinality(GeneratedYangParser.ContainerStatementContext ctx) {
    if ((!ctx.presenceStatement().isEmpty()) && (ctx.presenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.PRESENCE_DATA;
        return false;
    }
    if ((!ctx.configStatement().isEmpty()) && (ctx.configStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.CONFIG_DATA;
        return false;
    }
    if ((!ctx.descriptionStatement().isEmpty()) && (ctx.descriptionStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.DESCRIPTION_DATA;
        return false;
    }
    if ((!ctx.referenceStatement().isEmpty()) && (ctx.referenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.REFERENCE_DATA;
        return false;
    }
    if ((!ctx.statusStatement().isEmpty()) && (ctx.statusStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.STATUS_DATA;
        return false;
    }
    return true;
}
#end_block

#method_before
public static void processLeafListEntry(TreeWalkListener listener, GeneratedYangParser.LeafListStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, ParsableDataType.LEAF_LIST_DATA, ctx.IDENTIFIER().getText(), ENTRY);
    boolean result = validateSubStatementsCardinality(ctx);
    if (!result) {
        throw new ParserException(constructListenerErrorMessage(INVALID_CARDINALITY, yangConstruct, "", ENTRY));
    }
    YangLeafList leafList = new YangLeafList();
    leafList.setLeafName(ctx.IDENTIFIER().getText());
    Parsable tmpData = listener.getParsedDataStack().peek();
    YangLeavesHolder leaves;
    if (tmpData instanceof YangLeavesHolder) {
        leaves = (YangLeavesHolder) tmpData;
        leaves.addLeafList(leafList);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, ParsableDataType.LEAF_LIST_DATA, ctx.IDENTIFIER().getText(), ENTRY));
    }
    listener.getParsedDataStack().push(leafList);
}
#method_after
public static void processLeafListEntry(TreeWalkListener listener, GeneratedYangParser.LeafListStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, LEAF_LIST_DATA, ctx.IDENTIFIER().getText(), ENTRY);
    boolean result = validateSubStatementsCardinality(ctx);
    if (!result) {
        throw new ParserException(constructListenerErrorMessage(INVALID_CARDINALITY, yangConstruct, "", ENTRY));
    }
    YangLeafList leafList = new YangLeafList();
    leafList.setLeafName(ctx.IDENTIFIER().getText());
    Parsable tmpData = listener.getParsedDataStack().peek();
    YangLeavesHolder leaves;
    if (tmpData instanceof YangLeavesHolder) {
        leaves = (YangLeavesHolder) tmpData;
        leaves.addLeafList(leafList);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, LEAF_LIST_DATA, ctx.IDENTIFIER().getText(), ENTRY));
    }
    listener.getParsedDataStack().push(leafList);
}
#end_block

#method_before
public static void processLeafListExit(TreeWalkListener listener, GeneratedYangParser.LeafListStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, ParsableDataType.LEAF_LIST_DATA, ctx.IDENTIFIER().getText(), EXIT);
    if (listener.getParsedDataStack().peek() instanceof YangLeafList) {
        listener.getParsedDataStack().pop();
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, ParsableDataType.LEAF_LIST_DATA, ctx.IDENTIFIER().getText(), EXIT));
    }
}
#method_after
public static void processLeafListExit(TreeWalkListener listener, GeneratedYangParser.LeafListStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, LEAF_LIST_DATA, ctx.IDENTIFIER().getText(), EXIT);
    if (listener.getParsedDataStack().peek() instanceof YangLeafList) {
        listener.getParsedDataStack().pop();
    } else {
        throw new ParserException(constructListenerErrorMessage(MISSING_CURRENT_HOLDER, LEAF_LIST_DATA, ctx.IDENTIFIER().getText(), EXIT));
    }
}
#end_block

#method_before
public static boolean validateSubStatementsCardinality(GeneratedYangParser.LeafListStatementContext ctx) {
    if (ctx.typeStatement().isEmpty() || (ctx.typeStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.TYPE_DATA;
        return false;
    }
    if ((!ctx.unitsStatement().isEmpty()) && (ctx.unitsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.UNITS_DATA;
        return false;
    }
    if ((!ctx.configStatement().isEmpty()) && (ctx.configStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.CONFIG_DATA;
        return false;
    }
    if ((!ctx.maxElementsStatement().isEmpty()) && (ctx.maxElementsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.MAX_ELEMENT_DATA;
        return false;
    }
    if ((!ctx.minElementsStatement().isEmpty()) && (ctx.minElementsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.MIN_ELEMENT_DATA;
        return false;
    }
    if ((!ctx.descriptionStatement().isEmpty()) && (ctx.descriptionStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.DESCRIPTION_DATA;
        return false;
    }
    if ((!ctx.referenceStatement().isEmpty()) && (ctx.referenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.REFERENCE_DATA;
        return false;
    }
    if ((!ctx.statusStatement().isEmpty()) && (ctx.statusStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.STATUS_DATA;
        return false;
    }
    return true;
}
#method_after
private static boolean validateSubStatementsCardinality(GeneratedYangParser.LeafListStatementContext ctx) {
    if (ctx.typeStatement().isEmpty() || (ctx.typeStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.TYPE_DATA;
        return false;
    }
    if ((!ctx.unitsStatement().isEmpty()) && (ctx.unitsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.UNITS_DATA;
        return false;
    }
    if ((!ctx.configStatement().isEmpty()) && (ctx.configStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.CONFIG_DATA;
        return false;
    }
    if ((!ctx.maxElementsStatement().isEmpty()) && (ctx.maxElementsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.MAX_ELEMENT_DATA;
        return false;
    }
    if ((!ctx.minElementsStatement().isEmpty()) && (ctx.minElementsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.MIN_ELEMENT_DATA;
        return false;
    }
    if ((!ctx.descriptionStatement().isEmpty()) && (ctx.descriptionStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.DESCRIPTION_DATA;
        return false;
    }
    if ((!ctx.referenceStatement().isEmpty()) && (ctx.referenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.REFERENCE_DATA;
        return false;
    }
    if ((!ctx.statusStatement().isEmpty()) && (ctx.statusStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.STATUS_DATA;
        return false;
    }
    return true;
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication("org.onosproject.openstacknode");
    nodeStore = storageService.<OpenstackNode, NodeState>consistentMapBuilder().withSerializer(Serializer.using(NODE_SERIALIZER.build())).withName("openstacknode-nodestore").withApplicationId(appId).build();
    deviceService.addListener(deviceListener);
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(OPENSTACK_NODEMANAGER_ID);
    nodeStore = storageService.<OpenstackNode, NodeState>consistentMapBuilder().withSerializer(Serializer.using(NODE_SERIALIZER.build())).withName(OPENSTACK_NODESTORE).withApplicationId(appId).build();
    deviceService.addListener(deviceListener);
    configRegistry.registerConfigFactory(configFactory);
    configService.addListener(configListener);
    readConfiguration();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    deviceService.removeListener(deviceListener);
    eventExecutor.shutdown();
    nodeStore.clear();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    deviceService.removeListener(deviceListener);
    eventExecutor.shutdown();
    nodeStore.clear();
    configRegistry.unregisterConfigFactory(configFactory);
    configService.removeListener(configListener);
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void addNode(OpenstackNode node) {
    checkNotNull(node);
    nodeStore.putIfAbsent(node, checkNodeState(node));
    NodeState state = checkNodeState(node);
    state.process(this, node);
}
#method_after
@Override
public void addNode(OpenstackNode node) {
    checkNotNull(node, "Node cannot be null");
    nodeStore.putIfAbsent(node, checkNodeState(node));
    NodeState state = checkNodeState(node);
    state.process(this, node);
}
#end_block

#method_before
@Override
public void deleteNode(OpenstackNode node) {
    checkNotNull(node);
    if (getOvsdbConnectionState(node)) {
        disconnect(node);
    }
    nodeStore.remove(node);
}
#method_after
@Override
public void deleteNode(OpenstackNode node) {
    checkNotNull(node, "Node cannot be null");
    if (getOvsdbConnectionState(node)) {
        disconnect(node);
    }
    nodeStore.remove(node);
}
#end_block

#method_before
private NodeState checkNodeState(OpenstackNode node) {
    checkNotNull(node);
    if (checkIntegrationBridge(node) && checkTunnelInterface(node)) {
        return NodeState.COMPLETE;
    } else if (checkIntegrationBridge(node)) {
        return NodeState.BRIDGE_CREATED;
    } else if (getOvsdbConnectionState(node)) {
        return NodeState.OVSDB_CONNECTED;
    } else {
        return NodeState.INIT;
    }
}
#method_after
private NodeState checkNodeState(OpenstackNode node) {
    checkNotNull(node, "Node cannot be null");
    if (checkIntegrationBridge(node) && checkTunnelInterface(node)) {
        return NodeState.COMPLETE;
    } else if (checkIntegrationBridge(node)) {
        return NodeState.BRIDGE_CREATED;
    } else if (getOvsdbConnectionState(node)) {
        return NodeState.OVSDB_CONNECTED;
    } else {
        return NodeState.INIT;
    }
}
#end_block

#method_before
private boolean checkTunnelInterface(OpenstackNode node) {
    try {
        deviceService.getPorts(node.intBrId()).stream().filter(p -> p.annotations().value(PORT_NAME).contains(DEFAULT_TUNNEL) && p.isEnabled()).findAny().get();
        return true;
    } catch (NoSuchElementException e) {
        return false;
    }
}
#method_after
private boolean checkTunnelInterface(OpenstackNode node) {
    checkNotNull(node, "Node cannot be null");
    return deviceService.getPorts(node.intBrId()).stream().filter(p -> p.annotations().value(PORT_NAME).contains(DEFAULT_TUNNEL) && p.isEnabled()).findAny().isPresent();
}
#end_block

#method_before
private boolean getOvsdbConnectionState(OpenstackNode node) {
    checkNotNull(node);
    OvsdbClientService ovsdbClient = getOvsdbClient(node);
    return deviceService.isAvailable(node.ovsdbId()) && ovsdbClient != null && ovsdbClient.isConnected();
}
#method_after
private boolean getOvsdbConnectionState(OpenstackNode node) {
    checkNotNull(node, "Node cannot be null");
    OvsdbClientService ovsdbClient = getOvsdbClient(node);
    return deviceService.isAvailable(node.ovsdbId()) && ovsdbClient != null && ovsdbClient.isConnected();
}
#end_block

#method_before
private OvsdbClientService getOvsdbClient(OpenstackNode node) {
    checkNotNull(node);
    OvsdbClientService ovsdbClient = controller.getOvsdbClient(new OvsdbNodeId(node.ovsdbIp(), node.ovsdbPort().toInt()));
    if (ovsdbClient == null) {
        log.debug("Couldn't find OVSDB client for {}", node.hostname());
    }
    return ovsdbClient;
}
#method_after
private OvsdbClientService getOvsdbClient(OpenstackNode node) {
    checkNotNull(node, "Node cannot be null");
    OvsdbClientService ovsdbClient = controller.getOvsdbClient(new OvsdbNodeId(node.ovsdbIp(), node.ovsdbPort().toInt()));
    if (ovsdbClient == null) {
        log.debug("Couldn't find OVSDB client for {}", node.hostName());
    }
    return ovsdbClient;
}
#end_block

#method_before
private void connect(OpenstackNode node) {
    checkNotNull(node);
    if (!nodeStore.containsKey(node)) {
        log.warn("Node {} does not exist", node.hostname());
        return;
    }
    if (!getOvsdbConnectionState(node)) {
        controller.connect(node.ovsdbIp(), node.ovsdbPort());
    }
}
#method_after
private void connect(OpenstackNode node) {
    checkNotNull(node, "Node cannot be null");
    if (!nodeStore.containsKey(node)) {
        log.warn("Node {} does not exist", node.hostName());
        return;
    }
    if (!getOvsdbConnectionState(node)) {
        controller.connect(node.ovsdbIp(), node.ovsdbPort());
    }
}
#end_block

#method_before
private void postInit(OpenstackNode node) {
    checkNotNull(node);
    if (!nodeStore.containsKey(node)) {
        log.warn("Node {} does not exist", node.hostname());
        return;
    }
    OvsdbClientService ovsdbClient = getOvsdbClient(node);
    if (ovsdbClient != null) {
        ovsdbClient.disconnect();
    }
    log.info("Finished initializing {}", node.hostname());
}
#method_after
private void postInit(OpenstackNode node) {
    disconnect(node);
    log.info("Finished initializing {}", node.hostName());
}
#end_block

#method_before
private void setNodeState(OpenstackNode node, NodeState newState) {
    checkNotNull(node);
    log.debug("Changed {} state: {}", node.hostname(), newState.toString());
    nodeStore.put(node, newState);
    newState.process(this, node);
}
#method_after
private void setNodeState(OpenstackNode node, NodeState newState) {
    checkNotNull(node, "Node cannot be null");
    log.debug("Changed {} state: {}", node.hostName(), newState.toString());
    nodeStore.put(node, newState);
    newState.process(this, node);
}
#end_block

#method_before
private OpenstackNode getNodeByOvsdbId(DeviceId ovsdbId) {
    try {
        return getNodesAll().stream().filter(node -> node.ovsdbId().equals(ovsdbId)).findFirst().get();
    } catch (NoSuchElementException e) {
        log.debug("Couldn't find node information for {}", ovsdbId);
        return null;
    }
}
#method_after
private OpenstackNode getNodeByOvsdbId(DeviceId ovsdbId) {
    return getNodesAll().stream().filter(node -> node.ovsdbId().equals(ovsdbId)).findFirst().orElse(null);
}
#end_block

#method_before
private OpenstackNode getNodeByBridgeId(DeviceId bridgeId) {
    try {
        return getNodesAll().stream().filter(node -> node.intBrId().equals(bridgeId)).findFirst().get();
    } catch (NoSuchElementException e) {
        log.debug("Couldn't find node information for {}", bridgeId);
        return null;
    }
}
#method_after
private OpenstackNode getNodeByBridgeId(DeviceId bridgeId) {
    return getNodesAll().stream().filter(node -> node.intBrId().equals(bridgeId)).findFirst().orElse(null);
}
#end_block

#method_before
private void disconnect(OpenstackNode node) {
    checkNotNull(node);
    if (!nodeStore.containsKey(node)) {
        log.warn("Node {} does not exist", node.hostname());
        return;
    }
    if (getOvsdbConnectionState(node)) {
        OvsdbClientService ovsdbClient = getOvsdbClient(node);
        ovsdbClient.disconnect();
    }
}
#method_after
private void disconnect(OpenstackNode node) {
    checkNotNull(node, "Node cannot be null");
    if (!nodeStore.containsKey(node)) {
        log.warn("Node {} does not exist", node.hostName());
        return;
    }
    if (getOvsdbConnectionState(node)) {
        OvsdbClientService ovsdbClient = getOvsdbClient(node);
        ovsdbClient.disconnect();
    }
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    ConnectionHandler<Device> handler = (device.type().equals(SWITCH) ? bridgeHandler : ovsdbHandler);
    switch(event.type()) {
        case PORT_ADDED:
            eventExecutor.submit(() -> bridgeHandler.portAdded(event.port()));
            break;
        case PORT_UPDATED:
            if (!event.port().isEnabled()) {
                eventExecutor.submit(() -> bridgeHandler.portRemoved(event.port()));
            }
            break;
        case DEVICE_ADDED:
        case DEVICE_AVAILABILITY_CHANGED:
            if (deviceService.isAvailable(device.id())) {
                eventExecutor.submit(() -> handler.connected(device));
            } else {
                eventExecutor.submit(() -> handler.disconnected(device));
            }
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    ConnectionHandler<Device> handler = (device.type().equals(SWITCH) ? bridgeHandler : ovsdbHandler);
    switch(event.type()) {
        case PORT_ADDED:
            eventExecutor.submit(() -> bridgeHandler.portAdded(event.port()));
            break;
        case PORT_UPDATED:
            if (!event.port().isEnabled()) {
                eventExecutor.submit(() -> bridgeHandler.portRemoved(event.port()));
            }
            break;
        case DEVICE_ADDED:
        case DEVICE_AVAILABILITY_CHANGED:
            if (deviceService.isAvailable(device.id())) {
                eventExecutor.submit(() -> handler.connected(device));
            } else {
                eventExecutor.submit(() -> handler.disconnected(device));
            }
            break;
        default:
            log.debug("Unsupported event type {}", event.type().toString());
            break;
    }
}
#end_block

#method_before
@Override
public void disconnected(Device device) {
    OpenstackNode node = getNodeByBridgeId(device.id());
    if (node != null) {
        log.debug("Integration Bridge is disconnected from {}", node.hostname());
        setNodeState(node, NodeState.INCOMPLETE);
    }
}
#method_after
@Override
public void disconnected(Device device) {
    OpenstackNode node = getNodeByBridgeId(device.id());
    if (node != null) {
        log.debug("Integration Bridge is disconnected from {}", node.hostName());
        setNodeState(node, NodeState.INCOMPLETE);
    }
}
#end_block

#method_before
public void portRemoved(Port port) {
    if (!port.annotations().value(PORT_NAME).contains(DEFAULT_TUNNEL)) {
        return;
    }
    OpenstackNode node = getNodeByBridgeId((DeviceId) port.element().id());
    if (node != null) {
        log.info("Tunnel interface is removed from {}", node.hostname());
        setNodeState(node, NodeState.INCOMPLETE);
    }
}
#method_after
public void portRemoved(Port port) {
    if (!port.annotations().value(PORT_NAME).contains(DEFAULT_TUNNEL)) {
        return;
    }
    OpenstackNode node = getNodeByBridgeId((DeviceId) port.element().id());
    if (node != null) {
        log.info("Tunnel interface is removed from {}", node.hostName());
        setNodeState(node, NodeState.INCOMPLETE);
    }
}
#end_block

#method_before
public DeviceId ovsdbId() {
    return DeviceId.deviceId("ovsdb:" + this.ovsdbIp.toString());
}
#method_after
public DeviceId ovsdbId() {
    return DeviceId.deviceId(OVSDB.concat(this.ovsdbIp.toString()));
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof OpenstackNode) {
        OpenstackNode that = (OpenstackNode) obj;
        if (Objects.equals(hostname, that.hostname) && Objects.equals(ovsdbIp, that.ovsdbIp) && Objects.equals(ovsdbPort, that.ovsdbPort) && Objects.equals(bridgeId, that.bridgeId) && Objects.equals(openstackNodeType, that.openstackNodeType)) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof OpenstackNode) {
        OpenstackNode that = (OpenstackNode) obj;
        if (Objects.equals(hostName, that.hostName) && Objects.equals(ovsdbIp, that.ovsdbIp) && Objects.equals(ovsdbPort, that.ovsdbPort) && Objects.equals(bridgeId, that.bridgeId) && Objects.equals(openstackNodeType, that.openstackNodeType)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(hostname, ovsdbIp, ovsdbPort);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(hostName, ovsdbIp, ovsdbPort, bridgeId, openstackNodeType);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("host", hostname).add("ip", ovsdbIp).add("port", ovsdbPort).add("bridgeId", bridgeId).add("openstacknodetype", openstackNodeType).toString();
}
#method_after
@Override
public String toString() {
    if (openstackNodeType == OpenstackNodeService.OpenstackNodeType.COMPUTENODE) {
        return MoreObjects.toStringHelper(getClass()).add("host", hostName).add("ip", ovsdbIp).add("port", ovsdbPort).add("bridgeId", bridgeId).add("openstacknodetype", openstackNodeType).toString();
    } else {
        return MoreObjects.toStringHelper(getClass()).add("host", hostName).add("ip", ovsdbIp).add("port", ovsdbPort).add("bridgeId", bridgeId).add("openstacknodetype", openstackNodeType).add("gatewayExternalInterfaceName", gatewayExternalInterfaceName).add("gatewayExternalInterfaceMac", gatewayExternalInterfaceMac).toString();
    }
}
#end_block

#method_before
public Map<String, Ip4Address> externalFixedIps() {
    return externalFixedIps;
}
#method_after
public Map<String, Ip4Address> externalFixedIps() {
    return ImmutableMap.copyOf(externalFixedIps);
}
#end_block

#method_before
@Override
public void createPorts(OpenstackPort openstackPort) {
    if (!openstackPort.deviceOwner().equals(ROUTER_INTERFACE)) {
        if (!openstackPort.fixedIps().isEmpty()) {
            registerDhcpInfo(openstackPort);
        }
    }
/*if (openstackPort.deviceOwner().equals(ROUTER_INTERFACE)) {
            OpenstackRouterInterface.Builder osBuilder = new OpenstackRouterInterface.Builder();

            OpenstackSubnet openstackSubnet = restHandler.getSubnets().stream()
                    .filter(s -> s.networkId().equals(openstackPort.networkId()))
                    .findAny().get();

            updateRouterInterface(osBuilder.id(openstackPort.deviceId())
                    .portId(openstackPort.id())
                    .subnetId(openstackSubnet.id())
                    .tenantId(openstackSubnet.tenantId())
                    .build());
            updateRouter(router(openstackPort.deviceId()));
        }*/
}
#method_after
@Override
public void createPorts(OpenstackPort openstackPort) {
    if (!openstackPort.deviceOwner().equals(ROUTER_INTERFACE) && !openstackPort.deviceOwner().equals(DEVICE_OWNER_GATEWAY)) {
        if (!openstackPort.fixedIps().isEmpty()) {
            registerDhcpInfo(openstackPort);
        }
    }
    if (!openstackPort.securityGroups().isEmpty()) {
        openstackPort.securityGroups().forEach(sgId -> {
            OpenstackSecurityGroup sg = restHandler.getSecurityGroup(sgId);
            log.debug("SecurityGroup : {}", sg.toString());
        });
    }
}
#end_block

#method_before
@Override
public void deletePort(String uuid) {
}
#method_after
@Override
public void deletePort(String uuid) {
    // When VMs are remvoed, the flow rules for the VMs are removed using ONOS port update event.
    // But, when router is removed, no ONOS port event occurs and we need to use Neutron port event.
    // Here we should not touch any rules for VMs.
    log.debug("port {} was removed", uuid);
    String routerPortName = PORTNAME_PREFIX_ROUTER + uuid.substring(0, 11);
    OpenstackPortInfo routerPortInfo = openstackPortInfoMap.get(routerPortName);
    if (routerPortInfo != null) {
        dhcpService.removeStaticMapping(routerPortInfo.mac());
        if (!doNotPushFlows) {
            deviceService.getPorts(routerPortInfo.deviceId()).forEach(port -> {
                String pName = port.annotations().value("portName");
                if (pName.equals(routerPortName)) {
                    OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, restHandler, driverService);
                    rulePopulator.removeSwitchingRules(doNotPushFlows, port, openstackPortInfoMap);
                    openstackPortInfoMap.remove(routerPortName);
                    return;
                }
            });
        }
    }
}
#end_block

#method_before
private void processPortUpdated(Device device, Port port) {
    if (!port.annotations().value(PORTNAME).equals(PORTNAME_PREFIX_TUNNEL) && !doNotPushFlows) {
        if (port.isEnabled() || port.annotations().value(PORTNAME).startsWith(PORTNAME_PREFIX_ROUTER)) {
            OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, restHandler, driverService);
            rulePopulator.populateSwitchingRules(device, port);
            updatePortMap(device.id(), port, restHandler.getNetworks(), rulePopulator.openstackPort(port));
        // In case portupdate event is driven by vm shutoff from openstack
        } else if (!port.isEnabled() && openstackPortInfoMap.containsKey(port.annotations().value(PORTNAME))) {
            log.debug("Flowrules according to the port {} were removed", port.number().toString());
            OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, restHandler, driverService);
            openstackPortInfoMap.get(port.annotations().value(PORTNAME));
            rulePopulator.removeSwitchingRules(port, openstackPortInfoMap);
            openstackPortInfoMap.remove(port.annotations().value(PORTNAME));
        }
    }
}
#method_after
private void processPortUpdated(Device device, Port port) {
    if (!port.annotations().value(PORTNAME).equals(PORTNAME_PREFIX_TUNNEL) && !doNotPushFlows) {
        if (port.isEnabled() || port.annotations().value(PORTNAME).startsWith(PORTNAME_PREFIX_ROUTER)) {
            OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, restHandler, driverService);
            rulePopulator.populateSwitchingRules(doNotPushFlows, device, port);
            updatePortMap(device.id(), port, restHandler.getNetworks(), restHandler.getSubnets(), rulePopulator.openstackPort(port));
        // In case portupdate event is driven by vm shutoff from openstack
        } else if (!port.isEnabled() && openstackPortInfoMap.containsKey(port.annotations().value(PORTNAME))) {
            log.debug("Flowrules according to the port {} were removed", port.number().toString());
            OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, restHandler, driverService);
            rulePopulator.removeSwitchingRules(doNotPushFlows, port, openstackPortInfoMap);
            dhcpService.removeStaticMapping(openstackPortInfoMap.get(port.annotations().value(PORTNAME)).mac());
            openstackPortInfoMap.remove(port.annotations().value(PORTNAME));
        }
    }
}
#end_block

#method_before
private void initializeFlowRules() {
    OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, restHandler, driverService);
    Collection<OpenstackNetwork> networks = restHandler.getNetworks();
    deviceService.getDevices().forEach(device -> {
        log.debug("device {} num of ports {} ", device.id(), deviceService.getPorts(device.id()).size());
        deviceService.getPorts(device.id()).stream().filter(port -> port.annotations().value(PORTNAME).startsWith(PORTNAME_PREFIX_VM) || port.annotations().value(PORTNAME).startsWith(PORTNAME_PREFIX_ROUTER)).forEach(vmPort -> {
            OpenstackPort osPort = rulePopulator.openstackPort(vmPort);
            if (osPort != null) {
                if (!doNotPushFlows) {
                    rulePopulator.populateSwitchingRules(device, vmPort);
                    updatePortMap(device.id(), vmPort, networks, osPort);
                }
                registerDhcpInfo(osPort);
            } else {
                log.warn("No openstackPort information for port {}", vmPort);
            }
        });
    });
}
#method_after
private void initializeFlowRules() {
    OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, restHandler, driverService);
    Collection<OpenstackNetwork> networks = restHandler.getNetworks();
    Collection<OpenstackSubnet> subnets = restHandler.getSubnets();
    deviceService.getDevices().forEach(device -> {
        log.debug("device {} num of ports {} ", device.id(), deviceService.getPorts(device.id()).size());
        deviceService.getPorts(device.id()).stream().filter(port -> port.annotations().value(PORTNAME).startsWith(PORTNAME_PREFIX_VM) || port.annotations().value(PORTNAME).startsWith(PORTNAME_PREFIX_ROUTER)).forEach(vmPort -> {
            OpenstackPort osPort = rulePopulator.openstackPort(vmPort);
            if (osPort != null && !osPort.deviceOwner().equals(DEVICE_OWNER_GATEWAY)) {
                if (!doNotPushFlows) {
                    rulePopulator.populateSwitchingRules(doNotPushFlows, device, vmPort);
                    updatePortMap(device.id(), vmPort, networks, subnets, osPort);
                }
                registerDhcpInfo(osPort);
            } else {
                log.warn("No openstackPort information for port {}", vmPort);
            }
        });
    });
}
#end_block

#method_before
private void updatePortMap(DeviceId deviceId, Port port, Collection<OpenstackNetwork> networks, OpenstackPort openstackPort) {
    long vni = Long.parseLong(networks.stream().filter(n -> n.id().equals(openstackPort.networkId())).findAny().orElse(null).segmentId());
    OpenstackPortInfo.Builder portBuilder = OpenstackPortInfo.builder().setDeviceId(deviceId).setHostIp((Ip4Address) openstackPort.fixedIps().values().stream().findFirst().orElse(null)).setVni(vni).setGatewayMac(openstackPort.macAddress());
    openstackPortInfoMap.putIfAbsent(port.annotations().value(PORTNAME), portBuilder.build());
}
#method_after
private void updatePortMap(DeviceId deviceId, Port port, Collection<OpenstackNetwork> networks, Collection<OpenstackSubnet> subnets, OpenstackPort openstackPort) {
    long vni = Long.parseLong(networks.stream().filter(n -> n.id().equals(openstackPort.networkId())).findAny().orElse(null).segmentId());
    OpenstackSubnet openstackSubnet = subnets.stream().filter(n -> n.networkId().equals(openstackPort.networkId())).findFirst().get();
    Ip4Address gatewayIPAddress = Ip4Address.valueOf(openstackSubnet.gatewayIp());
    OpenstackPortInfo.Builder portBuilder = OpenstackPortInfo.builder().setDeviceId(deviceId).setHostIp((Ip4Address) openstackPort.fixedIps().values().stream().findFirst().orElse(null)).setHostMac(openstackPort.macAddress()).setVni(vni).setGatewayIP(gatewayIPAddress);
    openstackPortInfoMap.putIfAbsent(port.annotations().value(PORTNAME), portBuilder.build());
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet != null && ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        arpHandler.processPacketIn(pkt);
    }
}
#method_after
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet != null && ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        arpHandler.processPacketIn(pkt, openstackPortInfoMap.values());
    }
}
#end_block

#method_before
@Override
public void run() {
    if (event instanceof DeviceEvent) {
        DeviceEvent deviceEvent = (DeviceEvent) event;
        switch(deviceEvent.type()) {
            case DEVICE_ADDED:
                processDeviceAdded((Device) deviceEvent.subject());
                break;
            case DEVICE_UPDATED:
                Port port = (Port) deviceEvent.subject();
                if (port.isEnabled()) {
                    processPortUpdated((Device) deviceEvent.subject(), deviceEvent.port());
                }
                break;
            case DEVICE_AVAILABILITY_CHANGED:
                Device device = (Device) deviceEvent.subject();
                if (deviceService.isAvailable(device.id())) {
                    processDeviceAdded(device);
                }
                break;
            case PORT_ADDED:
                processPortUpdated((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            case PORT_UPDATED:
                processPortUpdated((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            case PORT_REMOVED:
                processPortRemoved((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            default:
                break;
        }
    } else if (event instanceof HostEvent) {
        HostEvent hostEvent = (HostEvent) event;
        switch(hostEvent.type()) {
            case HOST_REMOVED:
                processHostRemoved((Host) hostEvent.subject());
                break;
            default:
                break;
        }
    }
}
#method_after
@Override
public void run() {
    if (event instanceof DeviceEvent) {
        DeviceEvent deviceEvent = (DeviceEvent) event;
        switch(deviceEvent.type()) {
            case DEVICE_ADDED:
                processDeviceAdded((Device) deviceEvent.subject());
                break;
            case DEVICE_AVAILABILITY_CHANGED:
                Device device = (Device) deviceEvent.subject();
                if (deviceService.isAvailable(device.id())) {
                    processDeviceAdded(device);
                }
                break;
            case PORT_ADDED:
                processPortUpdated((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            case PORT_UPDATED:
                processPortUpdated((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            case PORT_REMOVED:
                processPortRemoved((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            default:
                break;
        }
    } else if (event instanceof HostEvent) {
        HostEvent hostEvent = (HostEvent) event;
        switch(hostEvent.type()) {
            case HOST_REMOVED:
                processHostRemoved((Host) hostEvent.subject());
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
public void configureNetwork() {
    OpenstackSwitchingConfig cfg = cfgService.getConfig(appId, OpenstackSwitchingConfig.class);
    if (cfg == null) {
        log.error("There is no openstack server information in config.");
        return;
    }
    doNotPushFlows = cfg.doNotPushFlows();
    restHandler = new OpenstackRestHandler(cfg);
    arpHandler = new OpenstackArpHandler(restHandler, packetService, hostService);
    initializeFlowRules();
}
#method_after
public void configureNetwork() {
    OpenstackSwitchingConfig cfg = cfgService.getConfig(appId, OpenstackSwitchingConfig.class);
    if (cfg == null) {
        log.error("There is no openstack server information in config.");
        return;
    }
    doNotPushFlows = cfg.doNotPushFlows();
    physicalRouterMac = cfg.physicalRouterMac();
    restHandler = new OpenstackRestHandler(cfg);
    arpHandler = new OpenstackArpHandler(restHandler, packetService, hostService);
    initializeFlowRules();
}
#end_block

#method_before
@Override
public OpenstackRouter decode(ObjectNode json, CodecContext context) {
    JsonNode routerInfo = json.get(ROUTER);
    if (routerInfo == null) {
        routerInfo = json;
    }
    String tenantId = routerInfo.path(TENANT_ID).asText();
    String id = routerInfo.path(ID).asText();
    String name = routerInfo.path(NAME).asText();
    String status = routerInfo.path(STATUS).asText();
    String adminStateUp = routerInfo.path(ADMIN_STATE_UP).asText();
    OpenstackExternalGateway.Builder osExtBuiler = OpenstackExternalGateway.builder();
    if (!routerInfo.path(EXTERNAL_GW_INFO).isMissingNode()) {
        String externalGatewayNetId = routerInfo.path(EXTERNAL_GW_INFO).path(NETWORK_ID).asText();
        Map<String, Ip4Address> fixedIpMap = Maps.newHashMap();
        if (!routerInfo.path(EXTERNAL_GW_INFO).path(EXTERNAL_FIXED_IPS).isMissingNode()) {
            ArrayNode fixedIpList = (ArrayNode) routerInfo.path(EXTERNAL_FIXED_IPS);
            for (JsonNode fixedIpInfo : fixedIpList) {
                String subnetId = fixedIpInfo.path(SUBNET_ID).asText();
                String ipAddressStr = fixedIpInfo.path(IP_ADDRESS).asText();
                if (!fixedIpInfo.path(IP_ADDRESS).isMissingNode() && ipAddressStr != null) {
                    Ip4Address ipAddress = Ip4Address.valueOf(ipAddressStr);
                    fixedIpMap.put(subnetId, ipAddress);
                }
            }
        }
        osExtBuiler.networkId(externalGatewayNetId).enablePnat(true).externalFixedIps(fixedIpMap);
    }
    OpenstackRouter.Builder osBuilder = new OpenstackRouter.Builder().tenantId(tenantId).id(id).name(name).status(OpenstackRouter.RouterStatus.valueOf(status)).adminStateUp(Boolean.valueOf(adminStateUp)).gatewayExternalInfo(osExtBuiler.build());
    return osBuilder.build();
}
#method_after
@Override
public OpenstackRouter decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    JsonNode routerInfo = json.get(ROUTER);
    if (routerInfo == null) {
        routerInfo = json;
    }
    String tenantId = checkNotNull(routerInfo.path(TENANT_ID).asText());
    String id = checkNotNull(routerInfo.path(ID).asText());
    String name = checkNotNull(routerInfo.path(NAME).asText());
    String status = checkNotNull(routerInfo.path(STATUS).asText());
    String adminStateUp = checkNotNull(routerInfo.path(ADMIN_STATE_UP).asText());
    OpenstackExternalGateway.Builder osExtBuiler = OpenstackExternalGateway.builder();
    if (!routerInfo.path(EXTERNAL_GW_INFO).isMissingNode()) {
        String externalGatewayNetId = checkNotNull(routerInfo.path(EXTERNAL_GW_INFO).path(NETWORK_ID).asText());
        Map<String, Ip4Address> fixedIpMap = Maps.newHashMap();
        if (!routerInfo.path(EXTERNAL_GW_INFO).path(EXTERNAL_FIXED_IPS).isMissingNode()) {
            ArrayNode fixedIpList = (ArrayNode) routerInfo.path(EXTERNAL_GW_INFO).path(EXTERNAL_FIXED_IPS);
            for (JsonNode fixedIpInfo : fixedIpList) {
                String subnetId = checkNotNull(fixedIpInfo.path(SUBNET_ID).asText());
                String ipAddressStr = checkNotNull(fixedIpInfo.path(IP_ADDRESS).asText());
                if (!fixedIpInfo.path(IP_ADDRESS).isMissingNode() && ipAddressStr != null) {
                    fixedIpMap.put(subnetId, Ip4Address.valueOf(ipAddressStr));
                }
            }
        }
        osExtBuiler.networkId(externalGatewayNetId).enablePnat(true).externalFixedIps(fixedIpMap);
    }
    OpenstackRouter.Builder osBuilder = new OpenstackRouter.Builder().tenantId(tenantId).id(id).name(name).status(OpenstackRouter.RouterStatus.valueOf(status)).adminStateUp(Boolean.valueOf(adminStateUp)).gatewayExternalInfo(osExtBuiler.build());
    return osBuilder.build();
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createRouter(InputStream input) {
    log.debug("REST API CREATE routers is called {}", input.toString());
    return Response.status(Response.Status.OK).build();
}
#method_after
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createRouter(InputStream input) {
    checkNotNull(input);
    try {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode routerNode = (ObjectNode) mapper.readTree(input);
        OpenstackRouter openstackRouter = ROUTER_CODEC.decode(routerNode, this);
        OpenstackSwitchingService switchingService = getService(OpenstackSwitchingService.class);
        switchingService.createRouter(openstackRouter);
        log.debug("REST API CREATE router is called {}", input.toString());
        return Response.status(Response.Status.OK).build();
    } catch (Exception e) {
        log.error("Create Router failed because of exception {}", e.toString());
        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(e.toString()).build();
    }
}
#end_block

#method_before
@PUT
@Path("{id}/add_router_interface")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response addRouterInterface(java.io.InputStream input) {
    try {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode routerIfNode = (ObjectNode) mapper.readTree(input);
        OpenstackRouterInterface openstackRouterInterface = ROUTER_INTERFACE_CODEC.decode(routerIfNode, this);
        OpenstackSwitchingService switchingService = getService(OpenstackSwitchingService.class);
        switchingService.updateRouterInterface(openstackRouterInterface);
        log.info("REST API AddInterfaceToRouter is called from router {} portId: {}, subnetId: {}, tenantId: {}", openstackRouterInterface.id(), openstackRouterInterface.portId(), openstackRouterInterface.subnetId(), openstackRouterInterface.tenantId());
        /*OpenstackRouter openstackRouter = switchingService.router(openstackRouterInterface.id());

            log.info("Router Details: id: {}, name: {}, status: {}, tenantId: {}", openstackRouter.id(),
                    openstackRouter.name(), openstackRouter.status(), openstackRouter.tenantId());
            if (openstackRouter.gatewayExternalInfo().networkId() != null) {
                log.info("netId: {}, enabledPNAT: {}", openstackRouter.gatewayExternalInfo().networkId(),
                        String.valueOf(openstackRouter.gatewayExternalInfo().isEnablePnat()));

                if (openstackRouter.gatewayExternalInfo().externalFixedIps() != null) {
                    openstackRouter.gatewayExternalInfo().externalFixedIps().forEach((k, v) ->
                    logprint(k, v));
                }
            }*/
        return Response.status(Response.Status.OK).build();
    } catch (Exception e) {
        log.error("AddRouterInterface failed because of exception {}", e.toString());
        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(e.toString()).build();
    }
}
#method_after
@PUT
@Path("{id}/add_router_interface")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response addRouterInterface(InputStream input) {
    checkNotNull(input);
    try {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode routerIfNode = (ObjectNode) mapper.readTree(input);
        OpenstackRouterInterface openstackRouterInterface = ROUTER_INTERFACE_CODEC.decode(routerIfNode, this);
        OpenstackSwitchingService switchingService = getService(OpenstackSwitchingService.class);
        switchingService.updateRouterInterface(openstackRouterInterface);
        log.debug("REST API AddRouterInterface is called from router {} portId: {}, subnetId: {}, tenantId: {}", openstackRouterInterface.id(), openstackRouterInterface.portId(), openstackRouterInterface.subnetId(), openstackRouterInterface.tenantId());
        return Response.status(Response.Status.OK).build();
    } catch (Exception e) {
        log.error("AddRouterInterface failed because of exception {}", e.toString());
        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(e.toString()).build();
    }
}
#end_block

#method_before
@PUT
@Path("{id}/remove_router_interface")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response removeRouterInterface(@PathParam("id") String id, java.io.InputStream input) {
    try {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode routerIfNode = (ObjectNode) mapper.readTree(input);
        OpenstackRouterInterface openstackRouterInterface = ROUTER_INTERFACE_CODEC.decode(routerIfNode, this);
        OpenstackSwitchingService switchingService = getService(OpenstackSwitchingService.class);
        switchingService.removeRouterInterface(openstackRouterInterface);
        log.info("REST API removeInterfaceToRouter is called from router {} portId: {}, subnetId: {}, tenantId: {}", openstackRouterInterface.id(), openstackRouterInterface.portId(), openstackRouterInterface.subnetId(), openstackRouterInterface.tenantId());
        return Response.status(Response.Status.OK).build();
    } catch (Exception e) {
        log.error("AddRouterInterface failed because of exception {}", e.toString());
        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(e.toString()).build();
    }
}
#method_after
@PUT
@Path("{id}/remove_router_interface")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response removeRouterInterface(@PathParam("id") String id, InputStream input) {
    checkNotNull(id);
    checkNotNull(input);
    try {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode routerIfNode = (ObjectNode) mapper.readTree(input);
        OpenstackRouterInterface openstackRouterInterface = ROUTER_INTERFACE_CODEC.decode(routerIfNode, this);
        OpenstackSwitchingService switchingService = getService(OpenstackSwitchingService.class);
        switchingService.removeRouterInterface(openstackRouterInterface);
        log.debug("REST API RemoveRouterInterface is called from router {} portId: {}, subnetId: {}," + "tenantId: {}", openstackRouterInterface.id(), openstackRouterInterface.portId(), openstackRouterInterface.subnetId(), openstackRouterInterface.tenantId());
        return Response.status(Response.Status.OK).build();
    } catch (Exception e) {
        log.error("RemoveRouterInterface failed because of exception {}", e.toString());
        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(e.toString()).build();
    }
}
#end_block

#method_before
public void populateSwitchingRules(Device device, Port port) {
    populateFlowRulesForTunnelTag(device, port);
    populateFlowRulesForTrafficToSameCnode(device, port);
    populateFlowRulesForTrafficToDifferentCnode(device, port);
}
#method_after
public void populateSwitchingRules(boolean doNotPushFlow, Device device, Port port) {
    if (doNotPushFlow) {
        return;
    }
    populateFlowRulesForTunnelTag(device, port);
    populateFlowRulesForTrafficToSameCnode(device, port);
    populateFlowRulesForTrafficToDifferentCnode(device, port);
}
#end_block

#method_before
public void removeSwitchingRules(Port removedPort, Map<String, OpenstackPortInfo> openstackPortInfoMap) {
    OpenstackPortInfo openstackPortInfo = openstackPortInfoMap.get(removedPort.annotations().value("portName"));
    DeviceId deviceId = openstackPortInfo.deviceId();
    Ip4Address vmIp = openstackPortInfo.ip();
    PortNumber portNumber = removedPort.number();
    long vni = openstackPortInfo.vni();
    removeFlowRuleForTunnelTag(deviceId, portNumber);
    removeFlowRuleForVMsInSameCnode(deviceId, vmIp, vni);
    removeFlowRuleForVMsInDiffrentCnode(removedPort, deviceId, vmIp, vni, openstackPortInfoMap);
}
#method_after
public void removeSwitchingRules(boolean doNotPushFlows, Port removedPort, Map<String, OpenstackPortInfo> openstackPortInfoMap) {
    if (doNotPushFlows) {
        return;
    }
    OpenstackPortInfo openstackPortInfo = openstackPortInfoMap.get(removedPort.annotations().value("portName"));
    DeviceId deviceId = openstackPortInfo.deviceId();
    Ip4Address vmIp = openstackPortInfo.ip();
    PortNumber portNumber = removedPort.number();
    long vni = openstackPortInfo.vni();
    removeFlowRuleForTunnelTag(deviceId, portNumber);
    removeFlowRuleForVMsInSameCnode(deviceId, vmIp, vni);
    removeFlowRuleForVMsInDiffrentCnode(removedPort, deviceId, vmIp, vni, openstackPortInfoMap);
}
#end_block

#method_before
public OpenstackRouterInterface decode(ObjectNode json, CodecContext context) {
    JsonNode routerIfInfo = json;
    String id = routerIfInfo.path(ID).asText();
    String tenantId = routerIfInfo.path(TENANT_ID).asText();
    String subnetId = routerIfInfo.path(SUBNET_ID).asText();
    String portId = routerIfInfo.path(PORT_ID).asText();
    OpenstackRouterInterface.Builder osBuilder = new OpenstackRouterInterface.Builder().id(id).tenantId(tenantId).subnetId(subnetId).portId(portId);
    return osBuilder.build();
}
#method_after
@Override
public OpenstackRouterInterface decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    JsonNode routerIfInfo = json;
    String id = checkNotNull(routerIfInfo.path(ID).asText());
    String tenantId = checkNotNull(routerIfInfo.path(TENANT_ID).asText());
    String subnetId = checkNotNull(routerIfInfo.path(SUBNET_ID).asText());
    String portId = checkNotNull(routerIfInfo.path(PORT_ID).asText());
    OpenstackRouterInterface.Builder osBuilder = new OpenstackRouterInterface.Builder().id(id).tenantId(tenantId).subnetId(subnetId).portId(portId);
    return osBuilder.build();
}
#end_block

#method_before
public Collection<OpenstackNetwork> getNetworks() {
    WebResource.Builder builder = getClientBuilder(neutronUrl + NETWORKS);
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header(X_AUTH_TOKENS, getToken()).get(String.class);
    log.debug("networks response:" + response);
    ObjectMapper mapper = new ObjectMapper();
    List<OpenstackNetwork> openstackNetworks = Lists.newArrayList();
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        ArrayNode networkList = (ArrayNode) node.path(NETWORKS);
        OpenstackNetworkCodec networkCodec = new OpenstackNetworkCodec();
        networkList.forEach(n -> openstackNetworks.add(networkCodec.decode((ObjectNode) n, null)));
    } catch (IOException e) {
        log.warn("getNetworks()", e);
    }
    openstackNetworks.removeAll(Collections.singleton(null));
    openstackNetworks.forEach(n -> log.debug("network ID: {}", n.id()));
    return openstackNetworks;
}
#method_after
public Collection<OpenstackNetwork> getNetworks() {
    WebResource.Builder builder = getClientBuilder(neutronUrl + URI_NETWORKS);
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header(HEADER_AUTH_TOKEN, getToken()).get(String.class);
    log.debug("networks response:" + response);
    ObjectMapper mapper = new ObjectMapper();
    List<OpenstackNetwork> openstackNetworks = Lists.newArrayList();
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        ArrayNode networkList = (ArrayNode) node.path(PATH_NETWORKS);
        OpenstackNetworkCodec networkCodec = new OpenstackNetworkCodec();
        networkList.forEach(n -> openstackNetworks.add(networkCodec.decode((ObjectNode) n, null)));
    } catch (IOException e) {
        log.warn("getNetworks()", e);
    }
    openstackNetworks.removeAll(Collections.singleton(null));
    openstackNetworks.forEach(n -> log.debug("network ID: {}", n.id()));
    return openstackNetworks;
}
#end_block

#method_before
public Collection<OpenstackPort> getPorts() {
    WebResource.Builder builder = getClientBuilder(neutronUrl + PORTS);
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header(X_AUTH_TOKENS, getToken()).get(String.class);
    ObjectMapper mapper = new ObjectMapper();
    List<OpenstackPort> openstackPorts = Lists.newArrayList();
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        ArrayNode portList = (ArrayNode) node.path(PORTS);
        OpenstackPortCodec portCodec = new OpenstackPortCodec();
        portList.forEach(p -> openstackPorts.add(portCodec.decode((ObjectNode) p, null)));
    } catch (IOException e) {
        log.warn("getPorts()", e);
    }
    log.debug("port response:" + response);
    openstackPorts.forEach(n -> log.debug("port ID: {}", n.id()));
    return openstackPorts;
}
#method_after
public Collection<OpenstackPort> getPorts() {
    WebResource.Builder builder = getClientBuilder(neutronUrl + URI_PORTS);
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header(HEADER_AUTH_TOKEN, getToken()).get(String.class);
    ObjectMapper mapper = new ObjectMapper();
    List<OpenstackPort> openstackPorts = Lists.newArrayList();
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        ArrayNode portList = (ArrayNode) node.path(PATH_PORTS);
        OpenstackPortCodec portCodec = new OpenstackPortCodec();
        portList.forEach(p -> openstackPorts.add(portCodec.decode((ObjectNode) p, null)));
    } catch (IOException e) {
        log.warn("getPorts()", e);
    }
    log.debug("port response:" + response);
    openstackPorts.forEach(n -> log.debug("port ID: {}", n.id()));
    return openstackPorts;
}
#end_block

#method_before
public Collection<OpenstackRouter> getRouters() {
    WebResource.Builder builder = getClientBuilder(neutronUrl + ROUTERS);
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header(X_AUTH_TOKENS, getToken()).get(String.class);
    ObjectMapper mapper = new ObjectMapper();
    List<OpenstackRouter> openstackRouters = Lists.newArrayList();
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        ArrayNode routerList = (ArrayNode) node.path(ROUTERS);
        OpenstackRouterCodec openstackRouterCodec = new OpenstackRouterCodec();
        routerList.forEach(r -> openstackRouters.add(openstackRouterCodec.decode((ObjectNode) r, null)));
    } catch (IOException e) {
        log.warn("getRouters()", e);
    }
    log.debug("router response:" + response);
    openstackRouters.forEach(r -> log.debug("router ID: {}", r.id()));
    return openstackRouters;
}
#method_after
public Collection<OpenstackRouter> getRouters() {
    WebResource.Builder builder = getClientBuilder(neutronUrl + PATH_ROUTERS);
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header(HEADER_AUTH_TOKEN, getToken()).get(String.class);
    ObjectMapper mapper = new ObjectMapper();
    List<OpenstackRouter> openstackRouters = Lists.newArrayList();
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        ArrayNode routerList = (ArrayNode) node.path(PATH_ROUTERS);
        OpenstackRouterCodec openstackRouterCodec = new OpenstackRouterCodec();
        routerList.forEach(r -> openstackRouters.add(openstackRouterCodec.decode((ObjectNode) r, null)));
    } catch (IOException e) {
        log.warn("getRouters()", e);
    }
    log.debug("router response:" + response);
    openstackRouters.forEach(r -> log.debug("router ID: {}", r.id()));
    return openstackRouters;
}
#end_block

#method_before
public Collection<OpenstackSubnet> getSubnets() {
    WebResource.Builder builder = getClientBuilder(neutronUrl + SUBNETS);
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header(X_AUTH_TOKENS, getToken()).get(String.class);
    ObjectMapper mapper = new ObjectMapper();
    List<OpenstackSubnet> subnets = Lists.newArrayList();
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        ArrayNode subnetList = (ArrayNode) node.path(SUBNETS);
        OpenstackSubnetCodec subnetCodec = new OpenstackSubnetCodec();
        subnetList.forEach(s -> subnets.add(subnetCodec.decode((ObjectNode) s, null)));
    } catch (IOException e) {
        log.warn("getSubnets()", e);
    }
    log.debug("subnets response:" + response);
    subnets.forEach(s -> log.debug("subnet ID: {}", s.id()));
    return subnets;
}
#method_after
public Collection<OpenstackSubnet> getSubnets() {
    WebResource.Builder builder = getClientBuilder(neutronUrl + URI_SUBNETS);
    String response = builder.accept(MediaType.APPLICATION_JSON_TYPE).header(HEADER_AUTH_TOKEN, getToken()).get(String.class);
    ObjectMapper mapper = new ObjectMapper();
    List<OpenstackSubnet> subnets = Lists.newArrayList();
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
        ArrayNode subnetList = (ArrayNode) node.path(PATH_SUBNETS);
        OpenstackSubnetCodec subnetCodec = new OpenstackSubnetCodec();
        subnetList.forEach(s -> subnets.add(subnetCodec.decode((ObjectNode) s, null)));
    } catch (IOException e) {
        log.warn("getSubnets()", e);
    }
    log.debug("subnets response:" + response);
    subnets.forEach(s -> log.debug("subnet ID: {}", s.id()));
    return subnets;
}
#end_block

#method_before
private String getToken() {
    if (isTokenInvalid()) {
        String request = "{\"auth\": {\"tenantName\": \"admin\", " + "\"passwordCredentials\":  {\"username\": \"" + userName + "\",\"password\": \"" + pass + "\"}}}";
        WebResource.Builder builder = getClientBuilder(keystoneUrl + "tokens");
        String response = builder.accept(MediaType.APPLICATION_JSON).post(String.class, request);
        ObjectMapper mapper = new ObjectMapper();
        try {
            ObjectNode node = (ObjectNode) mapper.readTree(response);
            tokenId = node.path("access").path("token").path("id").asText();
        } catch (IOException e) {
            log.warn("getToken()", e);
        }
        log.debug("token response:" + response);
    }
    return tokenId;
}
#method_after
private String getToken() {
    if (isTokenInvalid()) {
        String request = "{\"auth\": {\"tenantName\": \"admin\", " + "\"passwordCredentials\":  {\"username\": \"" + userName + "\",\"password\": \"" + pass + "\"}}}";
        WebResource.Builder builder = getClientBuilder(keystoneUrl + URI_TOKENS);
        String response = builder.accept(MediaType.APPLICATION_JSON).post(String.class, request);
        ObjectMapper mapper = new ObjectMapper();
        try {
            ObjectNode node = (ObjectNode) mapper.readTree(response);
            tokenId = node.path(PATH_ACCESS).path(PATH_TOKEN).path(PATH_ID).asText();
        } catch (IOException e) {
            log.warn("getToken()", e);
        }
        log.debug("token response:" + response);
    }
    return tokenId;
}
#end_block

#method_before
@Test
public void testGetDeviceKeysEmptyArray() {
    replay(mockDeviceKeyService);
    replay(mockDeviceKeyAdminService);
    WebResource rs = resource();
    String response = rs.path("device-key").get(String.class);
    assertThat(response, is("{\"device-key\":[]}"));
}
#method_after
@Test
public void testGetDeviceKeysEmptyArray() {
    replay(mockDeviceKeyService);
    replay(mockDeviceKeyAdminService);
    WebResource rs = resource();
    String response = rs.path("keys").get(String.class);
    assertThat(response, is("{\"keys\":[]}"));
}
#end_block

#method_before
@Test
public void testGetDeviceKeysArray() {
    replay(mockDeviceKeyService);
    replay(mockDeviceKeyAdminService);
    deviceKeySet.add(deviceKey1);
    deviceKeySet.add(deviceKey2);
    WebResource rs = resource();
    String response = rs.path("device-key").get(String.class);
    assertThat(response, containsString("{\"device-key\":["));
    final JsonObject result = Json.parse(response).asObject();
    assertThat(result, notNullValue());
    assertThat(result.names(), hasSize(1));
    assertThat(result.names().get(0), is("device-key"));
    final JsonArray deviceKeys = result.get("device-key").asArray();
    assertThat(deviceKeys, notNullValue());
    assertEquals("Device keys array is not the correct size.", 2, deviceKeys.size());
    assertThat(deviceKeys, hasDeviceKey(deviceKey1));
    assertThat(deviceKeys, hasDeviceKey(deviceKey2));
}
#method_after
@Test
public void testGetDeviceKeysArray() {
    replay(mockDeviceKeyService);
    replay(mockDeviceKeyAdminService);
    deviceKeySet.add(deviceKey1);
    deviceKeySet.add(deviceKey2);
    WebResource rs = resource();
    String response = rs.path("keys").get(String.class);
    assertThat(response, containsString("{\"keys\":["));
    final JsonObject result = Json.parse(response).asObject();
    assertThat(result, notNullValue());
    assertThat(result.names(), hasSize(1));
    assertThat(result.names().get(0), is("keys"));
    final JsonArray deviceKeys = result.get("keys").asArray();
    assertThat(deviceKeys, notNullValue());
    assertEquals("Device keys array is not the correct size.", 2, deviceKeys.size());
    assertThat(deviceKeys, hasDeviceKey(deviceKey1));
    assertThat(deviceKeys, hasDeviceKey(deviceKey2));
}
#end_block

#method_before
@Test
public void testGetDeviceKeyById() {
    deviceKeySet.add(deviceKey1);
    expect(mockDeviceKeyService.getDeviceKey(DeviceKeyId.deviceKeyId(deviceKeyId1))).andReturn(deviceKey1).anyTimes();
    replay(mockDeviceKeyService);
    replay(mockDeviceKeyAdminService);
    WebResource rs = resource();
    String response = rs.path("device-key/" + deviceKeyId1).get(String.class);
    final JsonObject result = Json.parse(response).asObject();
    assertThat(result, notNullValue());
    assertThat(result, matchesDeviceKey(deviceKey1));
}
#method_after
@Test
public void testGetDeviceKeyById() {
    deviceKeySet.add(deviceKey1);
    expect(mockDeviceKeyService.getDeviceKey(DeviceKeyId.deviceKeyId(deviceKeyId1))).andReturn(deviceKey1).anyTimes();
    replay(mockDeviceKeyService);
    replay(mockDeviceKeyAdminService);
    WebResource rs = resource();
    String response = rs.path("keys/" + deviceKeyId1).get(String.class);
    final JsonObject result = Json.parse(response).asObject();
    assertThat(result, notNullValue());
    assertThat(result, matchesDeviceKey(deviceKey1));
}
#end_block

#method_before
@Test
public void testGetNonExistentDeviceKey() {
    expect(mockDeviceKeyService.getDeviceKey(DeviceKeyId.deviceKeyId(deviceKeyId1))).andReturn(null).anyTimes();
    replay(mockDeviceKeyService);
    replay(mockDeviceKeyAdminService);
    WebResource rs = resource();
    try {
        String response = rs.path("device-key/" + deviceKeyId1).get(String.class);
        fail("GET of a non-existent device key did not throw an exception");
    } catch (UniformInterfaceException ex) {
        assertThat(ex.getMessage(), containsString("returned a response status of"));
    }
}
#method_after
@Test
public void testGetNonExistentDeviceKey() {
    expect(mockDeviceKeyService.getDeviceKey(DeviceKeyId.deviceKeyId(deviceKeyId1))).andReturn(null).anyTimes();
    replay(mockDeviceKeyService);
    replay(mockDeviceKeyAdminService);
    WebResource rs = resource();
    try {
        String response = rs.path("keys/" + deviceKeyId1).get(String.class);
        fail("GET of a non-existent device key did not throw an exception");
    } catch (UniformInterfaceException ex) {
        assertThat(ex.getMessage(), containsString("returned a response status of"));
    }
}
#end_block

#method_before
@Test
public void testPost() {
    mockDeviceKeyAdminService.addKey(anyObject());
    expectLastCall();
    replay(mockDeviceKeyService);
    replay(mockDeviceKeyAdminService);
    WebResource rs = resource();
    InputStream jsonStream = DeviceKeyWebResourceTest.class.getResourceAsStream("post-device-key.json");
    ClientResponse response = rs.path("device-key").type(MediaType.APPLICATION_JSON_TYPE).post(ClientResponse.class, jsonStream);
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_CREATED));
    String location = response.getLocation().getPath();
    assertThat(location, Matchers.startsWith("/device-key/" + deviceKeyId3));
}
#method_after
@Test
public void testPost() {
    mockDeviceKeyAdminService.addKey(anyObject());
    expectLastCall();
    replay(mockDeviceKeyService);
    replay(mockDeviceKeyAdminService);
    WebResource rs = resource();
    InputStream jsonStream = DeviceKeyWebResourceTest.class.getResourceAsStream("post-device-key.json");
    ClientResponse response = rs.path("keys").type(MediaType.APPLICATION_JSON_TYPE).post(ClientResponse.class, jsonStream);
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_CREATED));
    String location = response.getLocation().getPath();
    assertThat(location, Matchers.startsWith("/keys/" + deviceKeyId3));
}
#end_block

#method_before
@Test
public void testPostNullDeviceKey() {
    replay(mockDeviceKeyService);
    replay(mockDeviceKeyAdminService);
    WebResource rs = resource();
    try {
        String response = rs.path("device-key").type(MediaType.APPLICATION_JSON_TYPE).post(String.class);
        fail("POST of null device key did not throw an exception");
    } catch (UniformInterfaceException ex) {
        assertThat(ex.getMessage(), containsString("returned a response status of"));
    }
}
#method_after
@Test
public void testPostNullDeviceKey() {
    replay(mockDeviceKeyService);
    replay(mockDeviceKeyAdminService);
    WebResource rs = resource();
    try {
        String response = rs.path("keys").type(MediaType.APPLICATION_JSON_TYPE).post(String.class);
        fail("POST of null device key did not throw an exception");
    } catch (UniformInterfaceException ex) {
        assertThat(ex.getMessage(), containsString("returned a response status of"));
    }
}
#end_block

#method_before
@Test
public void testDelete() {
    expect(mockDeviceKeyService.getDeviceKey(DeviceKeyId.deviceKeyId(deviceKeyId2))).andReturn(deviceKey2).anyTimes();
    mockDeviceKeyAdminService.removeKey(anyObject());
    expectLastCall();
    replay(mockDeviceKeyService);
    replay(mockDeviceKeyAdminService);
    WebResource rs = resource();
    ClientResponse response = rs.path("device-key/" + deviceKeyId2).type(MediaType.APPLICATION_JSON_TYPE).delete(ClientResponse.class);
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_OK));
}
#method_after
@Test
public void testDelete() {
    expect(mockDeviceKeyService.getDeviceKey(DeviceKeyId.deviceKeyId(deviceKeyId2))).andReturn(deviceKey2).anyTimes();
    mockDeviceKeyAdminService.removeKey(anyObject());
    expectLastCall();
    replay(mockDeviceKeyService);
    replay(mockDeviceKeyAdminService);
    WebResource rs = resource();
    ClientResponse response = rs.path("keys/" + deviceKeyId2).type(MediaType.APPLICATION_JSON_TYPE).delete(ClientResponse.class);
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_OK));
}
#end_block

#method_before
@Test
public void testDeleteNonExistentDeviceKey() {
    expect(mockDeviceKeyService.getDeviceKey(anyObject())).andReturn(null).anyTimes();
    expectLastCall();
    replay(mockDeviceKeyService);
    replay(mockDeviceKeyAdminService);
    WebResource rs = resource();
    try {
        String response = rs.path("device-key/" + "NON_EXISTENT_DEVICE_KEY").delete(String.class);
        fail("Delete of a non-existent device key did not throw an exception");
    } catch (UniformInterfaceException ex) {
        assertThat(ex.getMessage(), containsString("returned a response status of"));
    }
}
#method_after
@Test
public void testDeleteNonExistentDeviceKey() {
    expect(mockDeviceKeyService.getDeviceKey(anyObject())).andReturn(null).anyTimes();
    expectLastCall();
    replay(mockDeviceKeyService);
    replay(mockDeviceKeyAdminService);
    WebResource rs = resource();
    try {
        String response = rs.path("keys/" + "NON_EXISTENT_DEVICE_KEY").delete(String.class);
        fail("Delete of a non-existent device key did not throw an exception");
    } catch (UniformInterfaceException ex) {
        assertThat(ex.getMessage(), containsString("returned a response status of"));
    }
}
#end_block

#method_before
@GET
public Response getDeviceKeys() {
    Iterable<DeviceKey> deviceKeys = get(DeviceKeyService.class).getDeviceKeys();
    return ok(encodeArray(DeviceKey.class, "device-key", deviceKeys)).build();
}
#method_after
@GET
public Response getDeviceKeys() {
    Iterable<DeviceKey> deviceKeys = get(DeviceKeyService.class).getDeviceKeys();
    return ok(encodeArray(DeviceKey.class, "keys", deviceKeys)).build();
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response addDeviceKey(InputStream stream) {
    try {
        DeviceKeyAdminService service = get(DeviceKeyAdminService.class);
        ObjectNode root = (ObjectNode) mapper().readTree(stream);
        DeviceKey deviceKey = codec(DeviceKey.class).decode(root, this);
        service.addKey(deviceKey);
        UriBuilder locationBuilder = uriInfo.getBaseUriBuilder().path("device-key").path(deviceKey.deviceKeyId().id());
        return Response.created(locationBuilder.build()).build();
    } catch (IOException ioe) {
        throw new IllegalArgumentException(ioe);
    }
}
#method_after
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response addDeviceKey(InputStream stream) {
    try {
        DeviceKeyAdminService service = get(DeviceKeyAdminService.class);
        ObjectNode root = (ObjectNode) mapper().readTree(stream);
        DeviceKey deviceKey = codec(DeviceKey.class).decode(root, this);
        service.addKey(deviceKey);
        UriBuilder locationBuilder = uriInfo.getBaseUriBuilder().path("keys").path(deviceKey.deviceKeyId().id());
        return Response.created(locationBuilder.build()).build();
    } catch (IOException ioe) {
        throw new IllegalArgumentException(ioe);
    }
}
#end_block

#method_before
@Test
public void basics() {
    Region r1 = store.createRegion(RID1, "R1", METRO, ImmutableList.of(NID1));
    assertEquals("incorrect id", RID1, r1.id());
    assertEquals("incorrect event", REGION_ADDED, event.type());
    Region r2 = store.createRegion(RID2, "R2", CAMPUS, ImmutableList.of(NID1));
    assertEquals("incorrect id", RID2, r2.id());
    assertEquals("incorrect type", CAMPUS, r2.type());
    assertEquals("incorrect event", REGION_ADDED, event.type());
    r2 = store.updateRegion(RID2, "R2", COUNTRY, ImmutableList.of(NID1));
    assertEquals("incorrect type", COUNTRY, r2.type());
    assertEquals("incorrect event", REGION_UPDATED, event.type());
    Set<Region> regions = store.getRegions();
    assertEquals("incorrect size", 2, regions.size());
    assertTrue("missing r1", regions.contains(r1));
    assertTrue("missing r2", regions.contains(r2));
    r1 = store.getRegion(RID1);
    assertEquals("incorrect id", RID1, r1.id());
    store.removeRegion(RID1);
    regions = store.getRegions();
    assertEquals("incorrect size", 1, regions.size());
    assertTrue("missing r2", regions.contains(r2));
    assertEquals("incorrect event", REGION_REMOVED, event.type());
}
#method_after
@Test
public void basics() {
    Region r1 = store.createRegion(RID1, "R1", METRO, MASTERS);
    assertEquals("incorrect id", RID1, r1.id());
    assertEquals("incorrect event", REGION_ADDED, event.type());
    Region r2 = store.createRegion(RID2, "R2", CAMPUS, MASTERS);
    assertEquals("incorrect id", RID2, r2.id());
    assertEquals("incorrect type", CAMPUS, r2.type());
    assertEquals("incorrect event", REGION_ADDED, event.type());
    r2 = store.updateRegion(RID2, "R2", COUNTRY, MASTERS);
    assertEquals("incorrect type", COUNTRY, r2.type());
    assertEquals("incorrect event", REGION_UPDATED, event.type());
    Set<Region> regions = store.getRegions();
    assertEquals("incorrect size", 2, regions.size());
    assertTrue("missing r1", regions.contains(r1));
    assertTrue("missing r2", regions.contains(r2));
    r1 = store.getRegion(RID1);
    assertEquals("incorrect id", RID1, r1.id());
    store.removeRegion(RID1);
    regions = store.getRegions();
    assertEquals("incorrect size", 1, regions.size());
    assertTrue("missing r2", regions.contains(r2));
    assertEquals("incorrect event", REGION_REMOVED, event.type());
}
#end_block

#method_before
@Test(expected = IllegalArgumentException.class)
public void duplicateCreate() {
    store.createRegion(RID1, "R1", METRO, ImmutableList.of(NID1));
    store.createRegion(RID1, "R2", CAMPUS, ImmutableList.of(NID1));
}
#method_after
@Test(expected = IllegalArgumentException.class)
public void duplicateCreate() {
    store.createRegion(RID1, "R1", METRO, MASTERS);
    store.createRegion(RID1, "R2", CAMPUS, MASTERS);
}
#end_block

#method_before
@Test(expected = ItemNotFoundException.class)
public void missingUpdate() {
    store.updateRegion(RID1, "R1", METRO, ImmutableList.of(NID1));
}
#method_after
@Test(expected = ItemNotFoundException.class)
public void missingUpdate() {
    store.updateRegion(RID1, "R1", METRO, MASTERS);
}
#end_block

#method_before
@Test
public void membership() {
    Region r = store.createRegion(RID1, "R1", METRO, ImmutableList.of(NID1));
    assertTrue("no devices expected", store.getRegionDevices(RID1).isEmpty());
    assertNull("no region expected", store.getRegionForDevice(DID1));
    store.addDevices(RID1, ImmutableSet.of(DID1, DID2));
    Set<DeviceId> deviceIds = store.getRegionDevices(RID1);
    assertEquals("incorrect device count", 2, deviceIds.size());
    assertTrue("missing d1", deviceIds.contains(DID1));
    assertTrue("missing d2", deviceIds.contains(DID2));
    assertEquals("wrong region", r, store.getRegionForDevice(DID1));
    store.addDevices(RID1, ImmutableSet.of(DID3));
    deviceIds = store.getRegionDevices(RID1);
    assertEquals("incorrect device count", 3, deviceIds.size());
    assertTrue("missing d3", deviceIds.contains(DID3));
    store.addDevices(RID1, ImmutableSet.of(DID3, DID1));
    deviceIds = store.getRegionDevices(RID1);
    assertEquals("incorrect device count", 3, deviceIds.size());
    store.removeDevices(RID1, ImmutableSet.of(DID2, DID3));
    deviceIds = store.getRegionDevices(RID1);
    assertEquals("incorrect device count", 1, deviceIds.size());
    assertTrue("missing d1", deviceIds.contains(DID1));
    store.removeDevices(RID1, ImmutableSet.of(DID1, DID3));
    assertTrue("no devices expected", store.getRegionDevices(RID1).isEmpty());
    store.removeDevices(RID1, ImmutableSet.of(DID2));
    assertTrue("no devices expected", store.getRegionDevices(RID1).isEmpty());
}
#method_after
@Test
public void membership() {
    Region r = store.createRegion(RID1, "R1", METRO, MASTERS);
    assertTrue("no devices expected", store.getRegionDevices(RID1).isEmpty());
    assertNull("no region expected", store.getRegionForDevice(DID1));
    store.addDevices(RID1, ImmutableSet.of(DID1, DID2));
    Set<DeviceId> deviceIds = store.getRegionDevices(RID1);
    assertEquals("incorrect device count", 2, deviceIds.size());
    assertTrue("missing d1", deviceIds.contains(DID1));
    assertTrue("missing d2", deviceIds.contains(DID2));
    assertEquals("wrong region", r, store.getRegionForDevice(DID1));
    store.addDevices(RID1, ImmutableSet.of(DID3));
    deviceIds = store.getRegionDevices(RID1);
    assertEquals("incorrect device count", 3, deviceIds.size());
    assertTrue("missing d3", deviceIds.contains(DID3));
    store.addDevices(RID1, ImmutableSet.of(DID3, DID1));
    deviceIds = store.getRegionDevices(RID1);
    assertEquals("incorrect device count", 3, deviceIds.size());
    store.removeDevices(RID1, ImmutableSet.of(DID2, DID3));
    deviceIds = store.getRegionDevices(RID1);
    assertEquals("incorrect device count", 1, deviceIds.size());
    assertTrue("missing d1", deviceIds.contains(DID1));
    store.removeDevices(RID1, ImmutableSet.of(DID1, DID3));
    assertTrue("no devices expected", store.getRegionDevices(RID1).isEmpty());
    store.removeDevices(RID1, ImmutableSet.of(DID2));
    assertTrue("no devices expected", store.getRegionDevices(RID1).isEmpty());
}
#end_block

#method_before
@Override
public List<NodeId> masters() {
    return masters;
}
#method_after
@Override
public List<Set<NodeId>> masters() {
    return masters;
}
#end_block

#method_before
@Test
public void basics() {
    Region r1 = service.createRegion(RID1, "R1", METRO, ImmutableList.of(NID1));
    assertEquals("incorrect id", RID1, r1.id());
    assertEquals("incorrect event", REGION_ADDED, listener.event.type());
    Region r2 = service.createRegion(RID2, "R2", CAMPUS, ImmutableList.of(NID1));
    assertEquals("incorrect id", RID2, r2.id());
    assertEquals("incorrect type", CAMPUS, r2.type());
    assertEquals("incorrect event", REGION_ADDED, listener.event.type());
    r2 = service.updateRegion(RID2, "R2", COUNTRY, ImmutableList.of(NID1));
    assertEquals("incorrect type", COUNTRY, r2.type());
    assertEquals("incorrect event", REGION_UPDATED, listener.event.type());
    Set<Region> regions = service.getRegions();
    assertEquals("incorrect size", 2, regions.size());
    assertTrue("missing r1", regions.contains(r1));
    assertTrue("missing r2", regions.contains(r2));
    r1 = service.getRegion(RID1);
    assertEquals("incorrect id", RID1, r1.id());
    service.removeRegion(RID1);
    regions = service.getRegions();
    assertEquals("incorrect size", 1, regions.size());
    assertTrue("missing r2", regions.contains(r2));
    assertEquals("incorrect event", REGION_REMOVED, listener.event.type());
}
#method_after
@Test
public void basics() {
    Region r1 = service.createRegion(RID1, "R1", METRO, MASTERS);
    assertEquals("incorrect id", RID1, r1.id());
    assertEquals("incorrect event", REGION_ADDED, listener.event.type());
    Region r2 = service.createRegion(RID2, "R2", CAMPUS, MASTERS);
    assertEquals("incorrect id", RID2, r2.id());
    assertEquals("incorrect type", CAMPUS, r2.type());
    assertEquals("incorrect event", REGION_ADDED, listener.event.type());
    r2 = service.updateRegion(RID2, "R2", COUNTRY, MASTERS);
    assertEquals("incorrect type", COUNTRY, r2.type());
    assertEquals("incorrect event", REGION_UPDATED, listener.event.type());
    Set<Region> regions = service.getRegions();
    assertEquals("incorrect size", 2, regions.size());
    assertTrue("missing r1", regions.contains(r1));
    assertTrue("missing r2", regions.contains(r2));
    r1 = service.getRegion(RID1);
    assertEquals("incorrect id", RID1, r1.id());
    service.removeRegion(RID1);
    regions = service.getRegions();
    assertEquals("incorrect size", 1, regions.size());
    assertTrue("missing r2", regions.contains(r2));
    assertEquals("incorrect event", REGION_REMOVED, listener.event.type());
}
#end_block

#method_before
@Test(expected = IllegalArgumentException.class)
public void duplicateCreate() {
    service.createRegion(RID1, "R1", METRO, ImmutableList.of(NID1));
    service.createRegion(RID1, "R2", CAMPUS, ImmutableList.of(NID1));
}
#method_after
@Test(expected = IllegalArgumentException.class)
public void duplicateCreate() {
    service.createRegion(RID1, "R1", METRO, MASTERS);
    service.createRegion(RID1, "R2", CAMPUS, MASTERS);
}
#end_block

#method_before
@Test(expected = ItemNotFoundException.class)
public void missingUpdate() {
    service.updateRegion(RID1, "R1", METRO, ImmutableList.of(NID1));
}
#method_after
@Test(expected = ItemNotFoundException.class)
public void missingUpdate() {
    service.updateRegion(RID1, "R1", METRO, MASTERS);
}
#end_block

#method_before
@Test
public void membership() {
    Region r = service.createRegion(RID1, "R1", METRO, ImmutableList.of(NID1));
    assertTrue("no devices expected", service.getRegionDevices(RID1).isEmpty());
    assertNull("no region expected", service.getRegionForDevice(DID1));
    service.addDevices(RID1, ImmutableSet.of(DID1, DID2));
    Set<DeviceId> deviceIds = service.getRegionDevices(RID1);
    assertEquals("incorrect device count", 2, deviceIds.size());
    assertTrue("missing d1", deviceIds.contains(DID1));
    assertTrue("missing d2", deviceIds.contains(DID2));
    assertEquals("wrong region", r, service.getRegionForDevice(DID1));
    assertEquals("incorrect event", REGION_MEMBERSHIP_CHANGED, listener.event.type());
    service.addDevices(RID1, ImmutableSet.of(DID3));
    deviceIds = service.getRegionDevices(RID1);
    assertEquals("incorrect device count", 3, deviceIds.size());
    assertTrue("missing d3", deviceIds.contains(DID3));
    assertEquals("incorrect event", REGION_MEMBERSHIP_CHANGED, listener.event.type());
    service.addDevices(RID1, ImmutableSet.of(DID3, DID1));
    deviceIds = service.getRegionDevices(RID1);
    assertEquals("incorrect device count", 3, deviceIds.size());
    service.removeDevices(RID1, ImmutableSet.of(DID2, DID3));
    deviceIds = service.getRegionDevices(RID1);
    assertEquals("incorrect device count", 1, deviceIds.size());
    assertTrue("missing d1", deviceIds.contains(DID1));
    service.removeDevices(RID1, ImmutableSet.of(DID1, DID3));
    assertTrue("no devices expected", service.getRegionDevices(RID1).isEmpty());
    service.removeDevices(RID1, ImmutableSet.of(DID2));
    assertTrue("no devices expected", service.getRegionDevices(RID1).isEmpty());
}
#method_after
@Test
public void membership() {
    Region r = service.createRegion(RID1, "R1", METRO, MASTERS);
    assertTrue("no devices expected", service.getRegionDevices(RID1).isEmpty());
    assertNull("no region expected", service.getRegionForDevice(DID1));
    service.addDevices(RID1, ImmutableSet.of(DID1, DID2));
    Set<DeviceId> deviceIds = service.getRegionDevices(RID1);
    assertEquals("incorrect device count", 2, deviceIds.size());
    assertTrue("missing d1", deviceIds.contains(DID1));
    assertTrue("missing d2", deviceIds.contains(DID2));
    assertEquals("wrong region", r, service.getRegionForDevice(DID1));
    assertEquals("incorrect event", REGION_MEMBERSHIP_CHANGED, listener.event.type());
    service.addDevices(RID1, ImmutableSet.of(DID3));
    deviceIds = service.getRegionDevices(RID1);
    assertEquals("incorrect device count", 3, deviceIds.size());
    assertTrue("missing d3", deviceIds.contains(DID3));
    assertEquals("incorrect event", REGION_MEMBERSHIP_CHANGED, listener.event.type());
    service.addDevices(RID1, ImmutableSet.of(DID3, DID1));
    deviceIds = service.getRegionDevices(RID1);
    assertEquals("incorrect device count", 3, deviceIds.size());
    service.removeDevices(RID1, ImmutableSet.of(DID2, DID3));
    deviceIds = service.getRegionDevices(RID1);
    assertEquals("incorrect device count", 1, deviceIds.size());
    assertTrue("missing d1", deviceIds.contains(DID1));
    service.removeDevices(RID1, ImmutableSet.of(DID1, DID3));
    assertTrue("no devices expected", service.getRegionDevices(RID1).isEmpty());
    service.removeDevices(RID1, ImmutableSet.of(DID2));
    assertTrue("no devices expected", service.getRegionDevices(RID1).isEmpty());
}
#end_block

#method_before
@Override
public Region createRegion(RegionId regionId, String name, Region.Type type, List<NodeId> masterNodeIds) {
    return regionsRepo.compute(regionId, (id, region) -> {
        checkArgument(region == null, DUPLICATE_REGION);
        return new DefaultRegion(regionId, name, type, masterNodeIds);
    }).value();
}
#method_after
@Override
public Region createRegion(RegionId regionId, String name, Region.Type type, List<Set<NodeId>> masterNodeIds) {
    return regionsRepo.compute(regionId, (id, region) -> {
        checkArgument(region == null, DUPLICATE_REGION);
        return new DefaultRegion(regionId, name, type, masterNodeIds);
    }).value();
}
#end_block

#method_before
@Override
public Region updateRegion(RegionId regionId, String name, Region.Type type, List<NodeId> masterNodeIds) {
    return regionsRepo.compute(regionId, (id, region) -> {
        nullIsNotFound(region, NO_REGION);
        return new DefaultRegion(regionId, name, type, masterNodeIds);
    }).value();
}
#method_after
@Override
public Region updateRegion(RegionId regionId, String name, Region.Type type, List<Set<NodeId>> masterNodeIds) {
    return regionsRepo.compute(regionId, (id, region) -> {
        nullIsNotFound(region, NO_REGION);
        return new DefaultRegion(regionId, name, type, masterNodeIds);
    }).value();
}
#end_block

#method_before
@Test
public void basics() {
    ImmutableList<NodeId> masters = ImmutableList.of(new NodeId("n1"), new NodeId("n2"));
    Region r = new DefaultRegion(ID1, "R1", METRO, masters);
    assertEquals("incorrect id", ID1, r.id());
    assertEquals("incorrect name", "R1", r.name());
    assertEquals("incorrect type", METRO, r.type());
    assertEquals("incorrect masters", masters, r.masters());
}
#method_after
@Test
public void basics() {
    ImmutableList<Set<NodeId>> masters = ImmutableList.of(ImmutableSet.of(nodeId("n1"), nodeId("n2")), ImmutableSet.of(nodeId("n3"), nodeId("n4")));
    Region r = new DefaultRegion(ID1, "R1", METRO, masters);
    assertEquals("incorrect id", ID1, r.id());
    assertEquals("incorrect name", "R1", r.name());
    assertEquals("incorrect type", METRO, r.type());
    assertEquals("incorrect masters", masters, r.masters());
}
#end_block

#method_before
@Override
public Region createRegion(RegionId regionId, String name, Region.Type type, List<NodeId> masterNodeIds) {
    checkNotNull(regionId, REGION_ID_NULL);
    checkNotNull(name, NAME_NULL);
    checkNotNull(name, REGION_TYPE_NULL);
    return store.createRegion(regionId, name, type, masterNodeIds == null ? of() : masterNodeIds);
}
#method_after
@Override
public Region createRegion(RegionId regionId, String name, Region.Type type, List<Set<NodeId>> masterNodeIds) {
    checkNotNull(regionId, REGION_ID_NULL);
    checkNotNull(name, NAME_NULL);
    checkNotNull(name, REGION_TYPE_NULL);
    return store.createRegion(regionId, name, type, masterNodeIds == null ? of() : masterNodeIds);
}
#end_block

#method_before
@Override
public Region updateRegion(RegionId regionId, String name, Region.Type type, List<NodeId> masterNodeIds) {
    checkNotNull(regionId, REGION_ID_NULL);
    checkNotNull(name, NAME_NULL);
    checkNotNull(name, REGION_TYPE_NULL);
    return store.updateRegion(regionId, name, type, masterNodeIds == null ? of() : masterNodeIds);
}
#method_after
@Override
public Region updateRegion(RegionId regionId, String name, Region.Type type, List<Set<NodeId>> masterNodeIds) {
    checkNotNull(regionId, REGION_ID_NULL);
    checkNotNull(name, NAME_NULL);
    checkNotNull(name, REGION_TYPE_NULL);
    return store.updateRegion(regionId, name, type, masterNodeIds == null ? of() : masterNodeIds);
}
#end_block

#method_before
@Override
@SuppressWarnings("rawtypes")
public void addAttributeInfo(YangType attrType, String name, boolean isListAttr) {
    AttributeInfo newAttr = new AttributeInfo();
    attrType.setDataTypeName(attrType.getDataTypeName().replace("\"", ""));
    if (attrType.getDataTypeName().equals("string")) {
        attrType.setDataTypeName(attrType.getDataTypeName().substring(0, 1).toUpperCase() + attrType.getDataTypeName().substring(1));
    }
    newAttr.setAttributeType(attrType);
    newAttr.setAttributeName(name);
    newAttr.setListAttr(isListAttr);
    if (getCachedAttributeList() != null) {
        if (getCachedAttributeList().size() == MAX_CACHABLE_ATTR) {
            flushCacheAttrToSerFile();
        }
        getCachedAttributeList().add(newAttr);
    } else {
        List<AttributeInfo> newAttributeInfo = new LinkedList<>();
        newAttributeInfo.add(newAttr);
        setCachedAttributeList(newAttributeInfo);
    }
    name = JavaIdentifierSyntax.getCamelCase(name);
    JavaCodeSnippetGen.setAttributes(name);
}
#method_after
@Override
public void addAttributeInfo(YangType<?> attrType, String name, boolean isListAttr) {
    AttributeInfo newAttr = new AttributeInfo();
    attrType.setDataTypeName(attrType.getDataTypeName().replace("\"", ""));
    if (attrType.getDataTypeName().equals("string")) {
        attrType.setDataTypeName(attrType.getDataTypeName().substring(0, 1).toUpperCase() + attrType.getDataTypeName().substring(1));
    }
    newAttr.setAttributeType(attrType);
    newAttr.setAttributeName(name);
    newAttr.setListAttr(isListAttr);
    if (getCachedAttributeList() != null) {
        if (getCachedAttributeList().size() == MAX_CACHABLE_ATTR) {
            flushCacheAttrToSerFile();
        }
        getCachedAttributeList().add(newAttr);
    } else {
        List<AttributeInfo> newAttributeInfo = new LinkedList<>();
        newAttributeInfo.add(newAttr);
        setCachedAttributeList(newAttributeInfo);
    }
    name = JavaIdentifierSyntax.getCamelCase(name);
}
#end_block

#method_before
@Override
public void close() throws IOException {
    String className = getYangName();
    className = (className.substring(0, 1).toUpperCase() + className.substring(1));
    String packagePath = getPackage();
    String filePath = UtilConstants.YANG_GEN_DIR + packagePath.replace(".", "/");
    GeneratedFileType fileType = getGeneratedFileTypes();
    /**
     * Create interface file.
     */
    String interfaceFileName = className + JAVA_FILE_EXTENSION;
    File interfaceFile = new File(filePath + File.separator + interfaceFileName);
    /**
     * Create temp builder interface file.
     */
    String builderInterfaceFileName = interfaceFileName + TEMP_FILE_EXTENSION;
    File builderInterfaceFile = new File(filePath + File.separator + builderInterfaceFileName);
    /**
     * Create builder class file.
     */
    String builderFileName = className + UtilConstants.BUILDER + JAVA_FILE_EXTENSION;
    File builderFile = new File(filePath + File.separator + builderFileName);
    MethodsGenerator.setBuilderClassName(className + UtilConstants.BUILDER);
    /**
     * Create temp impl class file.
     */
    String implFileName = className + UtilConstants.IMPL + TEMP_FILE_EXTENSION;
    File implTempFile = new File(filePath + File.separator + implFileName);
    if (fileType.equals(GeneratedFileType.INTERFACE) || fileType.equals(GeneratedFileType.ALL)) {
        try {
            interfaceFile.createNewFile();
            appendContents(interfaceFile, className, GeneratedFileType.INTERFACE);
        } catch (IOException e) {
            throw new IOException("Failed to create interface file.");
        }
    }
    if (fileType.equals(GeneratedFileType.BUILDER_CLASS) || fileType.equals(GeneratedFileType.ALL)) {
        try {
            builderFile.createNewFile();
            appendContents(builderFile, className, GeneratedFileType.BUILDER_CLASS);
        } catch (IOException e) {
            throw new IOException("Failed to create builder class file.");
        }
    }
    if (fileType.equals(GeneratedFileType.IMPL) || fileType.equals(GeneratedFileType.ALL)) {
        try {
            implTempFile.createNewFile();
            appendContents(implTempFile, className, GeneratedFileType.IMPL);
        } catch (IOException e) {
            throw new IOException("Failed to create impl class file.");
        }
    }
    if (fileType.equals(GeneratedFileType.BUILDER_INTERFACE) || fileType.equals(GeneratedFileType.ALL)) {
        try {
            builderInterfaceFile.createNewFile();
            appendContents(builderInterfaceFile, className, GeneratedFileType.BUILDER_INTERFACE);
        } catch (IOException e) {
            throw new IOException("Failed to create builder interface class file.");
        }
    }
    /*
         * TODO: add the file header using
         * JavaCodeSnippetGen.getFileHeaderComment
         */
    /*
         * TODO: get the import list using getImportText and add to the
         * generated java file using JavaCodeSnippetGen.getImportText
         */
    List<String> attributes = new LinkedList<>();
    List<String> interfaceMethods = new LinkedList<>();
    List<String> builderInterfaceMethods = new LinkedList<>();
    List<String> builderClassMethods = new LinkedList<>();
    List<String> implClassMethods = new LinkedList<>();
    // TODO: Handle imports for the attributes.
    try {
        attributes = SerializedDataStore.getSerializeData(SerializedDataStore.SerializedDataStoreType.ATTRIBUTE);
        interfaceMethods = SerializedDataStore.getSerializeData(SerializedDataStore.SerializedDataStoreType.INTERFACE_METHODS);
        builderInterfaceMethods = SerializedDataStore.getSerializeData(SerializedDataStore.SerializedDataStoreType.BUILDER_INTERFACE_METHODS);
        builderClassMethods = SerializedDataStore.getSerializeData(SerializedDataStore.SerializedDataStoreType.BUILDER_METHODS);
        implClassMethods = SerializedDataStore.getSerializeData(SerializedDataStore.SerializedDataStoreType.IMPL_METHODS);
    // TODO:imports = SerializedDataStore.getSerializeData(SerializedDataStore.SerializedDataStoreType.IMPORT);
    } catch (ClassNotFoundException | IOException e) {
        log.info("There is no attribute info of " + className + " YANG file in the serialized files.");
    }
    if (getCachedAttributeList() != null) {
        for (AttributeInfo attr : getCachedAttributeList()) {
            attributes.add(getAttributeString(attr));
            interfaceMethods.add(MethodsGenerator.getMethodString(attr, GeneratedFileType.INTERFACE));
            builderClassMethods.add(MethodsGenerator.getMethodString(attr, GeneratedFileType.BUILDER_CLASS));
            builderInterfaceMethods.add(MethodsGenerator.getMethodString(attr, GeneratedFileType.BUILDER_INTERFACE));
            implClassMethods.add(MethodsGenerator.getMethodString(attr, GeneratedFileType.IMPL));
        }
        getCachedAttributeList().clear();
    }
    builderInterfaceMethods.add(MethodsGenerator.parseBuilderInterfaceBuildMethodString(className));
    builderClassMethods.add(UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_FIRST_LINE + MethodsGenerator.getDefaultConstructorString(GeneratedFileType.BUILDER_CLASS, className));
    builderClassMethods.add(MethodsGenerator.getBuildString(className));
    implClassMethods.add(UtilConstants.JAVA_DOC_FIRST_LINE + MethodsGenerator.getDefaultConstructorString(GeneratedFileType.IMPL, className));
    implClassMethods.add(MethodsGenerator.getConstructorString(className));
    /**
     * Add attributes to the file.
     */
    for (String attribute : attributes) {
        insert(builderFile, UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + attribute);
        insert(implTempFile, UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + attribute);
    }
    insert(builderFile, UtilConstants.NEW_LINE);
    insert(implTempFile, UtilConstants.NEW_LINE);
    /**
     * Add getter methods to interface file.
     */
    for (String method : interfaceMethods) {
        appendMethod(interfaceFile, method + UtilConstants.NEW_LINE);
    }
    /**
     * Add getters and setters in builder interface.
     */
    for (String method : builderInterfaceMethods) {
        appendMethod(builderInterfaceFile, UtilConstants.FOUR_SPACE_INDENTATION + method + UtilConstants.NEW_LINE);
    }
    insert(builderInterfaceFile, UtilConstants.CLOSE_CURLY_BRACKET + UtilConstants.NEW_LINE);
    /**
     * Add methods in builder class.
     */
    for (String method : builderClassMethods) {
        appendMethod(builderFile, method + UtilConstants.NEW_LINE);
    }
    /**
     * Add methods in impl class.
     */
    for (String method : implClassMethods) {
        appendMethod(implTempFile, UtilConstants.FOUR_SPACE_INDENTATION + method + UtilConstants.NEW_LINE);
    }
    insert(implTempFile, UtilConstants.CLOSE_CURLY_BRACKET + UtilConstants.NEW_LINE);
    /**
     * Append builder interface file to interface file and close it.
     */
    appendFileContents(builderInterfaceFile, interfaceFile);
    insert(interfaceFile, closeFile(GeneratedFileType.INTERFACE, interfaceFileName));
    /**
     * Append impl class to builder class and close it.
     */
    appendFileContents(implTempFile, builderFile);
    insert(builderFile, closeFile(GeneratedFileType.BUILDER_CLASS, builderFileName));
    /**
     * Remove temp files.
     */
    clean(implTempFile);
    clean(builderInterfaceFile);
}
#method_after
@Override
public void close() throws IOException {
    String className = getYangName();
    className = (className.substring(0, 1).toUpperCase() + className.substring(1));
    String packagePath = getPackage();
    String filePath = UtilConstants.YANG_GEN_DIR + packagePath.replace(".", "/");
    GeneratedFileType fileType = getGeneratedFileTypes();
    /**
     * Create interface file.
     */
    String interfaceFileName = className + JAVA_FILE_EXTENSION;
    File interfaceFile = new File(filePath + File.separator + interfaceFileName);
    /**
     * Create temp builder interface file.
     */
    String builderInterfaceFileName = interfaceFileName + TEMP_FILE_EXTENSION;
    File builderInterfaceFile = new File(filePath + File.separator + builderInterfaceFileName);
    /**
     * Create builder class file.
     */
    String builderFileName = className + UtilConstants.BUILDER + JAVA_FILE_EXTENSION;
    File builderFile = new File(filePath + File.separator + builderFileName);
    MethodsGenerator.setBuilderClassName(className + UtilConstants.BUILDER);
    /**
     * Create temp impl class file.
     */
    String implFileName = className + UtilConstants.IMPL + TEMP_FILE_EXTENSION;
    File implTempFile = new File(filePath + File.separator + implFileName);
    if (fileType.equals(GeneratedFileType.INTERFACE) || fileType.equals(GeneratedFileType.ALL)) {
        try {
            interfaceFile.createNewFile();
            appendContents(interfaceFile, className, GeneratedFileType.INTERFACE);
        } catch (IOException e) {
            throw new IOException("Failed to create interface file.");
        }
    }
    if (fileType.equals(GeneratedFileType.BUILDER_CLASS) || fileType.equals(GeneratedFileType.ALL)) {
        try {
            builderFile.createNewFile();
            appendContents(builderFile, className, GeneratedFileType.BUILDER_CLASS);
        } catch (IOException e) {
            throw new IOException("Failed to create builder class file.");
        }
    }
    if (fileType.equals(GeneratedFileType.IMPL) || fileType.equals(GeneratedFileType.ALL)) {
        try {
            implTempFile.createNewFile();
            appendContents(implTempFile, className, GeneratedFileType.IMPL);
        } catch (IOException e) {
            throw new IOException("Failed to create impl class file.");
        }
    }
    if (fileType.equals(GeneratedFileType.BUILDER_INTERFACE) || fileType.equals(GeneratedFileType.ALL)) {
        try {
            builderInterfaceFile.createNewFile();
            appendContents(builderInterfaceFile, className, GeneratedFileType.BUILDER_INTERFACE);
        } catch (IOException e) {
            throw new IOException("Failed to create builder interface class file.");
        }
    }
    /*
         * TODO: add the file header using
         * JavaCodeSnippetGen.getFileHeaderComment
         */
    /*
         * TODO: get the import list using getImportText and add to the
         * generated java file using JavaCodeSnippetGen.getImportText
         */
    List<String> attributes = new LinkedList<>();
    List<String> interfaceMethods = new LinkedList<>();
    List<String> builderInterfaceMethods = new LinkedList<>();
    List<String> builderClassMethods = new LinkedList<>();
    List<String> implClassMethods = new LinkedList<>();
    // TODO: Handle imports for the attributes.
    try {
        attributes = SerializedDataStore.getSerializeData(SerializedDataStore.SerializedDataStoreType.ATTRIBUTE);
        interfaceMethods = SerializedDataStore.getSerializeData(SerializedDataStore.SerializedDataStoreType.INTERFACE_METHODS);
        builderInterfaceMethods = SerializedDataStore.getSerializeData(SerializedDataStore.SerializedDataStoreType.BUILDER_INTERFACE_METHODS);
        builderClassMethods = SerializedDataStore.getSerializeData(SerializedDataStore.SerializedDataStoreType.BUILDER_METHODS);
        implClassMethods = SerializedDataStore.getSerializeData(SerializedDataStore.SerializedDataStoreType.IMPL_METHODS);
    // TODO:imports = SerializedDataStore.getSerializeData(SerializedDataStore.SerializedDataStoreType.IMPORT);
    } catch (ClassNotFoundException | IOException e) {
        log.info("There is no attribute info of " + className + " YANG file in the serialized files.");
    }
    if (getCachedAttributeList() != null) {
        MethodsGenerator.setAttrInfo(getCachedAttributeList());
        for (AttributeInfo attr : getCachedAttributeList()) {
            attributes.add(getAttributeString(attr));
            interfaceMethods.add(MethodsGenerator.getMethodString(attr, GeneratedFileType.INTERFACE));
            builderClassMethods.add(MethodsGenerator.getMethodString(attr, GeneratedFileType.BUILDER_CLASS));
            builderInterfaceMethods.add(MethodsGenerator.getMethodString(attr, GeneratedFileType.BUILDER_INTERFACE));
            implClassMethods.add(MethodsGenerator.getMethodString(attr, GeneratedFileType.IMPL));
        }
    }
    builderInterfaceMethods.add(MethodsGenerator.parseBuilderInterfaceBuildMethodString(className));
    builderClassMethods.add(UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.JAVA_DOC_FIRST_LINE + MethodsGenerator.getDefaultConstructorString(GeneratedFileType.BUILDER_CLASS, className));
    builderClassMethods.add(MethodsGenerator.getBuildString(className));
    implClassMethods.add(UtilConstants.JAVA_DOC_FIRST_LINE + MethodsGenerator.getDefaultConstructorString(GeneratedFileType.IMPL, className));
    implClassMethods.add(MethodsGenerator.getConstructorString(className));
    /**
     * Add attributes to the file.
     */
    for (String attribute : attributes) {
        insert(builderFile, UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + attribute);
        insert(implTempFile, UtilConstants.NEW_LINE + UtilConstants.FOUR_SPACE_INDENTATION + attribute);
    }
    insert(builderFile, UtilConstants.NEW_LINE);
    insert(implTempFile, UtilConstants.NEW_LINE);
    /**
     * Add getter methods to interface file.
     */
    for (String method : interfaceMethods) {
        appendMethod(interfaceFile, method + UtilConstants.NEW_LINE);
    }
    /**
     * Add getters and setters in builder interface.
     */
    for (String method : builderInterfaceMethods) {
        appendMethod(builderInterfaceFile, UtilConstants.FOUR_SPACE_INDENTATION + method + UtilConstants.NEW_LINE);
    }
    insert(builderInterfaceFile, UtilConstants.CLOSE_CURLY_BRACKET + UtilConstants.NEW_LINE);
    /**
     * Add methods in builder class.
     */
    for (String method : builderClassMethods) {
        appendMethod(builderFile, method + UtilConstants.NEW_LINE);
    }
    /**
     * Add methods in impl class.
     */
    for (String method : implClassMethods) {
        appendMethod(implTempFile, UtilConstants.FOUR_SPACE_INDENTATION + method + UtilConstants.NEW_LINE);
    }
    insert(implTempFile, UtilConstants.CLOSE_CURLY_BRACKET + UtilConstants.NEW_LINE);
    /**
     * Append builder interface file to interface file and close it.
     */
    appendFileContents(builderInterfaceFile, interfaceFile);
    insert(interfaceFile, closeFile(GeneratedFileType.INTERFACE, interfaceFileName));
    /**
     * Append impl class to builder class and close it.
     */
    appendFileContents(implTempFile, builderFile);
    insert(builderFile, closeFile(GeneratedFileType.BUILDER_CLASS, builderFileName));
    /**
     * Remove temp files.
     */
    clean(implTempFile);
    clean(builderInterfaceFile);
}
#end_block

#method_before
private static String getConstructor(String yangName) {
    String builderAttribute = (yangName.substring(0, 1).toLowerCase() + yangName.substring(1));
    String constructor = UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.PUBLIC + UtilConstants.SPACE + yangName + UtilConstants.IMPL + UtilConstants.OPEN_PARENTHESIS + yangName + UtilConstants.BUILDER + UtilConstants.SPACE + builderAttribute + UtilConstants.OBJECT + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE;
    List<String> attributes = JavaCodeSnippetGen.getAttributes();
    for (String attribute : attributes) {
        constructor = constructor + UtilConstants.TWELVE_SPACE_INDENTATION + UtilConstants.THIS + UtilConstants.PERIOD + attribute + UtilConstants.SPACE + UtilConstants.EQUAL + UtilConstants.SPACE + builderAttribute + UtilConstants.OBJECT + UtilConstants.PERIOD + UtilConstants.GET_METHOD_PREFIX + attribute + UtilConstants.OPEN_PARENTHESIS + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE;
    }
    JavaCodeSnippetGen.getAttributes().clear();
    return constructor + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.CLOSE_CURLY_BRACKET + UtilConstants.NEW_LINE;
}
#method_after
private static String getConstructor(String yangName) {
    String builderAttribute = (yangName.substring(0, 1).toLowerCase() + yangName.substring(1));
    String constructor = UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.PUBLIC + UtilConstants.SPACE + yangName + UtilConstants.IMPL + UtilConstants.OPEN_PARENTHESIS + yangName + UtilConstants.BUILDER + UtilConstants.SPACE + builderAttribute + UtilConstants.OBJECT + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SPACE + UtilConstants.OPEN_CURLY_BRACKET + UtilConstants.NEW_LINE;
    if (getAttrInfo() != null) {
        for (AttributeInfo attribute : getAttrInfo()) {
            attribute.setAttributeName(JavaIdentifierSyntax.getCamelCase(attribute.getAttributeName()));
            constructor = constructor + UtilConstants.TWELVE_SPACE_INDENTATION + UtilConstants.THIS + UtilConstants.PERIOD + attribute.getAttributeName() + UtilConstants.SPACE + UtilConstants.EQUAL + UtilConstants.SPACE + builderAttribute + UtilConstants.OBJECT + UtilConstants.PERIOD + UtilConstants.GET_METHOD_PREFIX + attribute.getAttributeName() + UtilConstants.OPEN_PARENTHESIS + UtilConstants.CLOSE_PARENTHESIS + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE;
        }
        getAttrInfo().clear();
    }
    return constructor + UtilConstants.FOUR_SPACE_INDENTATION + UtilConstants.CLOSE_CURLY_BRACKET + UtilConstants.NEW_LINE;
}
#end_block

#method_before
public String getDescription() {
    return description;
}
#method_after
@Override
public String getDescription() {
    return description;
}
#end_block

#method_before
public void setDescription(String description) {
    this.description = description;
}
#method_after
@Override
public void setDescription(String description) {
    this.description = description;
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
public List<YangLeaf> getListOfLeaf() {
    return listOfLeaf;
}
#method_after
@Override
public List<YangLeaf<?>> getListOfLeaf() {
    return listOfLeaf;
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
private void setListOfLeaf(List<YangLeaf> leafsList) {
    listOfLeaf = leafsList;
}
#method_after
private void setListOfLeaf(List<YangLeaf<?>> leafsList) {
    listOfLeaf = leafsList;
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
public void addLeaf(YangLeaf<?> leaf) {
    if (getListOfLeaf() == null) {
        setListOfLeaf(new LinkedList<YangLeaf>());
    }
    getListOfLeaf().add(leaf);
}
#method_after
@Override
public void addLeaf(YangLeaf<?> leaf) {
    if (getListOfLeaf() == null) {
        setListOfLeaf(new LinkedList<YangLeaf<?>>());
    }
    getListOfLeaf().add(leaf);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
public List<YangLeafList> getListOfLeafList() {
    return listOfLeafList;
}
#method_after
@Override
public List<YangLeafList<?>> getListOfLeafList() {
    return listOfLeafList;
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
private void setListOfLeafList(List<YangLeafList> listOfLeafList) {
    this.listOfLeafList = listOfLeafList;
}
#method_after
private void setListOfLeafList(List<YangLeafList<?>> listOfLeafList) {
    this.listOfLeafList = listOfLeafList;
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
public void addLeafList(YangLeafList<?> leafList) {
    if (getListOfLeafList() == null) {
        setListOfLeafList(new LinkedList<YangLeafList>());
    }
    getListOfLeafList().add(leafList);
}
#method_after
@Override
public void addLeafList(YangLeafList<?> leafList) {
    if (getListOfLeafList() == null) {
        setListOfLeafList(new LinkedList<YangLeafList<?>>());
    }
    getListOfLeafList().add(leafList);
}
#end_block

#method_before
public String getReference() {
    return reference;
}
#method_after
@Override
public String getReference() {
    return reference;
}
#end_block

#method_before
public void setReference(String reference) {
    this.reference = reference;
}
#method_after
@Override
public void setReference(String reference) {
    this.reference = reference;
}
#end_block

#method_before
public YangStatusType getStatus() {
    return status;
}
#method_after
@Override
public YangStatusType getStatus() {
    return status;
}
#end_block

#method_before
public void setStatus(YangStatusType status) {
    this.status = status;
}
#method_after
@Override
public void setStatus(YangStatusType status) {
    this.status = status;
}
#end_block

#method_before
public ParsableDataType getParsableDataType() {
    return ParsableDataType.CONTAINER_DATA;
}
#method_after
@Override
public ParsableDataType getParsableDataType() {
    return ParsableDataType.CONTAINER_DATA;
}
#end_block

#method_before
public void validateDataOnEntry() throws DataModelException {
// TODO auto-generated method stub, to be implemented by parser
}
#method_after
@Override
public void validateDataOnEntry() throws DataModelException {
// TODO auto-generated method stub, to be implemented by parser
}
#end_block

#method_before
public void validateDataOnExit() throws DataModelException {
// TODO auto-generated method stub, to be implemented by parser
}
#method_after
@Override
public void validateDataOnExit() throws DataModelException {
// TODO auto-generated method stub, to be implemented by parser
}
#end_block

#method_before
@Override
public void generateJavaCodeEntry() throws IOException {
    YangNode parent = getParent();
    String modPkg = JavaIdentifierSyntax.getPackageFromParent(parent.getPackage(), getName());
    setPackage(modPkg);
    CachedFileHandle handle = null;
    try {
        FileSystemUtil.createPackage(getPackage(), getName());
        handle = FileSystemUtil.createSourceFiles(getPackage(), getName(), GeneratedFileType.ALL);
    } catch (IOException e) {
        throw new IOException("Failed to create the source files.");
    }
    setFileHandle(handle);
    @SuppressWarnings("rawtypes")
    List<YangLeaf> leaves = getListOfLeaf();
    if (leaves != null) {
        for (@SuppressWarnings("rawtypes") YangLeaf leaf : leaves) {
            getFileHandle().addAttributeInfo(leaf.getDataType(), leaf.getLeafName(), false);
        }
    }
    @SuppressWarnings("rawtypes")
    List<YangLeafList> leavesList = getListOfLeafList();
    if (leavesList != null) {
        for (@SuppressWarnings("rawtypes") YangLeafList leafList : leavesList) {
            getFileHandle().addAttributeInfo(leafList.getDataType(), leafList.getLeafName(), true);
        }
    }
    return;
}
#method_after
@Override
public void generateJavaCodeEntry() throws IOException {
    YangNode parent = getParent();
    String modPkg = JavaIdentifierSyntax.getPackageFromParent(parent.getPackage(), getName());
    setPackage(modPkg);
    CachedFileHandle handle = null;
    try {
        FileSystemUtil.createPackage(getPackage(), getName());
        handle = FileSystemUtil.createSourceFiles(getPackage(), getName(), GeneratedFileType.ALL);
    } catch (IOException e) {
        throw new IOException("Failed to create the source files.");
    }
    setFileHandle(handle);
    addLavesAttributes();
    addLeafListAttributes();
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
public YangType getAttributeType() {
    return attrType;
}
#method_after
public YangType<?> getAttributeType() {
    return attrType;
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
public void setAttributeType(YangType type) {
    attrType = type;
}
#method_after
public void setAttributeType(YangType<?> type) {
    attrType = type;
}
#end_block

#method_before
public String getDescription() {
    return description;
}
#method_after
@Override
public String getDescription() {
    return description;
}
#end_block

#method_before
public void setDescription(String description) {
    this.description = description;
}
#method_after
@Override
public void setDescription(String description) {
    this.description = description;
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
public List<YangLeaf> getListOfLeaf() {
    return listOfLeaf;
}
#method_after
@Override
public List<YangLeaf<?>> getListOfLeaf() {
    return listOfLeaf;
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
private void setListOfLeaf(List<YangLeaf> leafsList) {
    listOfLeaf = leafsList;
}
#method_after
private void setListOfLeaf(List<YangLeaf<?>> leafsList) {
    listOfLeaf = leafsList;
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
public void addLeaf(YangLeaf<?> leaf) {
    if (getListOfLeaf() == null) {
        setListOfLeaf(new LinkedList<YangLeaf>());
    }
    getListOfLeaf().add(leaf);
}
#method_after
@Override
public void addLeaf(YangLeaf<?> leaf) {
    if (getListOfLeaf() == null) {
        setListOfLeaf(new LinkedList<YangLeaf<?>>());
    }
    getListOfLeaf().add(leaf);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
public List<YangLeafList> getListOfLeafList() {
    return listOfLeafList;
}
#method_after
@Override
public List<YangLeafList<?>> getListOfLeafList() {
    return listOfLeafList;
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
private void setListOfLeafList(List<YangLeafList> listOfLeafList) {
    this.listOfLeafList = listOfLeafList;
}
#method_after
private void setListOfLeafList(List<YangLeafList<?>> listOfLeafList) {
    this.listOfLeafList = listOfLeafList;
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
public void addLeafList(YangLeafList<?> leafList) {
    if (getListOfLeafList() == null) {
        setListOfLeafList(new LinkedList<YangLeafList>());
    }
    getListOfLeafList().add(leafList);
}
#method_after
@Override
public void addLeafList(YangLeafList<?> leafList) {
    if (getListOfLeafList() == null) {
        setListOfLeafList(new LinkedList<YangLeafList<?>>());
    }
    getListOfLeafList().add(leafList);
}
#end_block

#method_before
public String getReference() {
    return reference;
}
#method_after
@Override
public String getReference() {
    return reference;
}
#end_block

#method_before
public void setReference(String reference) {
    this.reference = reference;
}
#method_after
@Override
public void setReference(String reference) {
    this.reference = reference;
}
#end_block

#method_before
public ParsableDataType getParsableDataType() {
    return ParsableDataType.MODULE_DATA;
}
#method_after
@Override
public ParsableDataType getParsableDataType() {
    return ParsableDataType.MODULE_DATA;
}
#end_block

#method_before
public void validateDataOnEntry() throws DataModelException {
// TODO auto-generated method stub, to be implemented by parser
}
#method_after
@Override
public void validateDataOnEntry() throws DataModelException {
// TODO auto-generated method stub, to be implemented by parser
}
#end_block

#method_before
public void validateDataOnExit() throws DataModelException {
// TODO auto-generated method stub, to be implemented by parser
}
#method_after
@Override
public void validateDataOnExit() throws DataModelException {
// TODO auto-generated method stub, to be implemented by parser
}
#end_block

#method_before
@Override
public void generateJavaCodeEntry() throws IOException {
    String modPkg = JavaIdentifierSyntax.getRootPackage(getVersion(), getNameSpace().getUri(), getRevision().getRevDate());
    setPackage(modPkg);
    CachedFileHandle handle = null;
    try {
        FileSystemUtil.createPackage(getPackage(), getName());
        handle = FileSystemUtil.createSourceFiles(getPackage(), getName(), GeneratedFileType.ALL);
    } catch (IOException e) {
        throw new IOException("Failed to create the source files.");
    }
    setFileHandle(handle);
    @SuppressWarnings("rawtypes")
    List<YangLeaf> leaves = getListOfLeaf();
    if (leaves != null) {
        for (@SuppressWarnings("rawtypes") YangLeaf leaf : leaves) {
            getFileHandle().addAttributeInfo(leaf.getDataType(), leaf.getLeafName(), false);
        }
    }
    @SuppressWarnings("rawtypes")
    List<YangLeafList> leavesList = getListOfLeafList();
    if (leavesList != null) {
        for (@SuppressWarnings("rawtypes") YangLeafList leafList : leavesList) {
            getFileHandle().addAttributeInfo(leafList.getDataType(), leafList.getLeafName(), true);
        }
    }
}
#method_after
@Override
public void generateJavaCodeEntry() throws IOException {
    String modPkg = JavaIdentifierSyntax.getRootPackage(getVersion(), getNameSpace().getUri(), getRevision().getRevDate());
    setPackage(modPkg);
    CachedFileHandle handle = null;
    try {
        FileSystemUtil.createPackage(getPackage(), getName());
        handle = FileSystemUtil.createSourceFiles(getPackage(), getName(), GeneratedFileType.ALL);
    } catch (IOException e) {
        throw new IOException("Failed to create the source files.");
    }
    setFileHandle(handle);
    addLavesAttributes();
    addLeafListAttributes();
}
#end_block

#method_before
public void ageLsaAndFlood() {
    // evry 5 mins checksum validation
    checkAges();
    // evry 30 mins - flood lsa
    refreshLsa();
    // evry 60 mins - flood lsa
    maxAgeLsa();
    if (ageCounter == OspfParameters.MAXAGE) {
        ageCounter = 0;
        ageCounterRollOver++;
    } else {
        // increment age bin
        ageCounter++;
    }
}
#method_after
public void ageLsaAndFlood() {
    // every 5 mins checksum validation
    checkAges();
    // every 30 mins - flood LSA
    refreshLsa();
    // every 60 mins - flood LSA
    maxAgeLsa();
    if (ageCounter == OspfParameters.MAXAGE) {
        ageCounter = 0;
        ageCounterRollOver++;
    } else {
        // increment age bin
        ageCounter++;
    }
}
#end_block

#method_before
public void interfaceUp() throws Exception {
    log.debug("OSPFInterfaceChannelHandler::interfaceUp...!!!");
    // set it to point to point
    if (ospfInterface.interfaceType() == OspfInterfaceType.POINT_TO_POINT.value()) {
        ((OspfInterfaceImpl) ospfInterface).setState(OspfInterfaceState.POINT2POINT);
        log.debug("OSPFInterfaceChannelHandler::InterfaceType {} state {} ", ospfInterface.interfaceType(), ((OspfInterfaceImpl) ospfInterface).state());
    } else if (ospfInterface.interfaceType() == OspfInterfaceType.BROADCAST.value()) {
        // if router priority is 0, move the state to DROther
        if (ospfInterface.routerPriority() == 0) {
            ((OspfInterfaceImpl) ospfInterface).setState(OspfInterfaceState.DROTHER);
        } else {
            log.debug("OSPFInterfaceChannelHandler::InterfaceType {} state {} RouterPriority {}", ospfInterface.interfaceType(), ((OspfInterfaceImpl) ospfInterface).state(), ospfInterface.routerPriority());
            ((OspfInterfaceImpl) ospfInterface).setState(OspfInterfaceState.WAITING);
            // start wait timer - like inactivity timer with router deadInterval
            startWaitTimer();
        }
    }
    // Start hello timer with interval from config - convert seconds to milliseconds
    startHelloTimer(ospfInterface.helloIntervalTime());
    ospfArea.refreshArea(ospfInterface);
}
#method_after
public void interfaceUp() throws Exception {
    log.debug("OSPFInterfaceChannelHandler::interfaceUp...!!!");
    if (ospfInterface.interfaceType() == OspfInterfaceType.POINT_TO_POINT.value()) {
        ((OspfInterfaceImpl) ospfInterface).setState(OspfInterfaceState.POINT2POINT);
        log.debug("OSPFInterfaceChannelHandler::InterfaceType {} state {} ", ospfInterface.interfaceType(), ((OspfInterfaceImpl) ospfInterface).state());
    } else if (ospfInterface.interfaceType() == OspfInterfaceType.BROADCAST.value()) {
        // if router priority is 0, move the state to DROther
        if (ospfInterface.routerPriority() == 0) {
            ((OspfInterfaceImpl) ospfInterface).setState(OspfInterfaceState.DROTHER);
        } else {
            log.debug("OSPFInterfaceChannelHandler::InterfaceType {} state {} RouterPriority {}", ospfInterface.interfaceType(), ((OspfInterfaceImpl) ospfInterface).state(), ospfInterface.routerPriority());
            ((OspfInterfaceImpl) ospfInterface).setState(OspfInterfaceState.WAITING);
            // start wait timer - like inactivity timer with router deadInterval
            startWaitTimer();
        }
    }
    // Start hello timer with interval from config - convert seconds to milliseconds
    startHelloTimer(ospfInterface.helloIntervalTime());
    ospfArea.refreshArea(ospfInterface);
}
#end_block

#method_before
@Override
public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent evt) {
    // as soon as the channel gets disconnected with C program
    // Stop the timers
    interfaceDown();
    stopDelayedAckTimer();
    log.debug("OspfChannelHandler::channelDisconnected...!!!");
}
#method_after
@Override
public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent evt) {
    interfaceDown();
    stopDelayedAckTimer();
    log.debug("OspfChannelHandler::channelDisconnected...!!!");
}
#end_block

#method_before
public List<OspfEligibleRouter> calculateListOfEligibleRouters(OspfEligibleRouter electedDr) {
    log.debug("OSPFNbr::calculateListOfEligibleRouters ");
    Set<String> neighborIdList;
    List<OspfEligibleRouter> eligibleRouters = new ArrayList<>();
    neighborIdList = ospfInterface.listOfNeighbors().keySet();
    for (String routerId : neighborIdList) {
        OspfNbrImpl nbr = (OspfNbrImpl) ospfInterface.neighbouringRouter(routerId);
        if (nbr.getState().getValue() >= OspfNeighborState.TWOWAY.getValue() && nbr.routerPriority() > 0) {
            OspfEligibleRouter router = new OspfEligibleRouter();
            router.setIpAddress(nbr.neighborIpAddr());
            router.setRouterId(nbr.neighborId());
            router.setRouterPriority(nbr.routerPriority());
            if (nbr.neighborDr().equals(nbr.neighborIpAddr()) || electedDr.getIpAddress().equals(nbr.neighborIpAddr())) {
                router.setIsDr(true);
            } else if (nbr.neighborBdr().equals(nbr.neighborIpAddr())) {
                router.setIsBdr(true);
            }
            eligibleRouters.add(router);
        }
    }
    // interface doesnot have states like two and all
    if (ospfInterface.routerPriority() > 0) {
        OspfEligibleRouter router = new OspfEligibleRouter();
        router.setIpAddress(ospfInterface.ipAddress());
        router.setRouterId(ospfArea.routerId());
        router.setRouterPriority(ospfInterface.routerPriority());
        if (ospfInterface.dr().equals(ospfInterface.ipAddress()) || electedDr.getIpAddress().equals(ospfInterface.ipAddress())) {
            router.setIsDr(true);
        } else if (ospfInterface.bdr().equals(ospfInterface.ipAddress()) && !ospfInterface.dr().equals(ospfInterface.ipAddress())) {
            router.setIsBdr(true);
        }
        eligibleRouters.add(router);
    }
    return eligibleRouters;
}
#method_after
public List<OspfEligibleRouter> calculateListOfEligibleRouters(OspfEligibleRouter electedDr) {
    log.debug("OSPFNbr::calculateListOfEligibleRouters ");
    Set<String> neighborIdList;
    List<OspfEligibleRouter> eligibleRouters = new ArrayList<>();
    neighborIdList = ospfInterface.listOfNeighbors().keySet();
    for (String routerId : neighborIdList) {
        OspfNbrImpl nbr = (OspfNbrImpl) ospfInterface.neighbouringRouter(routerId);
        if (nbr.getState().getValue() >= OspfNeighborState.TWOWAY.getValue() && nbr.routerPriority() > 0) {
            OspfEligibleRouter router = new OspfEligibleRouter();
            router.setIpAddress(nbr.neighborIpAddr());
            router.setRouterId(nbr.neighborId());
            router.setRouterPriority(nbr.routerPriority());
            if (nbr.neighborDr().equals(nbr.neighborIpAddr()) || electedDr.getIpAddress().equals(nbr.neighborIpAddr())) {
                router.setIsDr(true);
            } else if (nbr.neighborBdr().equals(nbr.neighborIpAddr())) {
                router.setIsBdr(true);
            }
            eligibleRouters.add(router);
        }
    }
    // interface does not have states like two and all
    if (ospfInterface.routerPriority() > 0) {
        OspfEligibleRouter router = new OspfEligibleRouter();
        router.setIpAddress(ospfInterface.ipAddress());
        router.setRouterId(ospfArea.routerId());
        router.setRouterPriority(ospfInterface.routerPriority());
        if (ospfInterface.dr().equals(ospfInterface.ipAddress()) || electedDr.getIpAddress().equals(ospfInterface.ipAddress())) {
            router.setIsDr(true);
        } else if (ospfInterface.bdr().equals(ospfInterface.ipAddress()) && !ospfInterface.dr().equals(ospfInterface.ipAddress())) {
            router.setIsBdr(true);
        }
        eligibleRouters.add(router);
    }
    return eligibleRouters;
}
#end_block

#method_before
private void processVerifyChecksum(LsaWrapper wrapper) throws Exception {
    ChecksumCalculator checkSum = new ChecksumCalculator();
    if (!checkSum.isValidLsaCheckSum(wrapper.ospfLsa(), ((LsaWrapperImpl) wrapper).lsaHeader().lsType(), OspfUtil.LSAPACKET_CHECKSUM_POS1, OspfUtil.LSAPACKET_CHECKSUM_POS2)) {
        log.debug("LSAQueueConsumer::Checksum mismatch. Received LSA packet type {} ", ((LsaWrapperImpl) wrapper).lsaHeader().lsType());
    // Checksum Invalid
    // RFC #156 Restart the Router.
    // Currently we are not restarting. We are not handling this case.
    }
}
#method_after
private void processVerifyChecksum(LsaWrapper wrapper) throws Exception {
    ChecksumCalculator checkSum = new ChecksumCalculator();
    if (!checkSum.isValidLsaCheckSum(wrapper.ospfLsa(), ((LsaWrapperImpl) wrapper).lsaHeader().lsType(), OspfUtil.LSAPACKET_CHECKSUM_POS1, OspfUtil.LSAPACKET_CHECKSUM_POS2)) {
        log.debug("LSAQueueConsumer::Checksum mismatch. Received LSA packet type {} ", ((LsaWrapperImpl) wrapper).lsaHeader().lsType());
    // Checksum Invalid
    // RFC 2328 Restart the Router.
    // Currently we are not restarting. We are not handling this case.
    }
}
#end_block

#method_before
@Override
public boolean equals(Object other) {
    if (!(other instanceof OspfInterfaceImpl)) {
        return false;
    }
    OspfAreaAddressRangeImpl otherAreaAddressRange = (OspfAreaAddressRangeImpl) other;
    return ipAddress.equals(otherAreaAddressRange.ipAddress) && mask.equals(otherAreaAddressRange.mask) && advertise == otherAreaAddressRange.advertise;
}
#method_after
@Override
public boolean equals(Object other) {
    if (!(other instanceof OspfAreaAddressRangeImpl)) {
        return false;
    }
    OspfAreaAddressRangeImpl otherAreaAddressRange = (OspfAreaAddressRangeImpl) other;
    return Objects.equal(ipAddress, otherAreaAddressRange.ipAddress) && Objects.equal(mask, otherAreaAddressRange.mask) && Objects.equal(advertise, otherAreaAddressRange.advertise);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(ipAddress, mask, advertise);
}
#method_after
@Override
public int hashCode() {
    return Objects.hashCode(ipAddress, mask, advertise);
}
#end_block

#method_before
@Override
public List<Intent> compile(OpticalConnectivityIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    // Check if source and destination are optical OCh ports
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    Port srcPort = deviceService.getPort(src.deviceId(), src.port());
    Port dstPort = deviceService.getPort(dst.deviceId(), dst.port());
    checkArgument(srcPort instanceof OchPort);
    checkArgument(dstPort instanceof OchPort);
    log.debug("Compiling optical connectivity intent between {} and {}", src, dst);
    // In case of recompile due to intent restoration: first release all intent resources
    resourceService.release(intent.id());
    // Reserve OCh ports
    Resource srcPortResource = Resource.discrete(src.deviceId(), src.port());
    Resource dstPortResource = Resource.discrete(dst.deviceId(), dst.port());
    List<org.onosproject.net.newresource.ResourceAllocation> allocation = resourceService.allocate(intent.id(), srcPortResource, dstPortResource);
    if (allocation.isEmpty()) {
        throw new IntentCompilationException("Unable to reserve ports for intent " + intent);
    }
    // Calculate available light paths
    Set<Path> paths = getOpticalPaths(intent);
    // Use first path that can be successfully reserved
    for (Path path : paths) {
        // Static or dynamic lambda allocation
        String staticLambda = srcPort.annotations().value(AnnotationKeys.STATIC_LAMBDA);
        OchPort srcOchPort = (OchPort) srcPort;
        OchPort dstOchPort = (OchPort) dstPort;
        OchSignal ochSignal;
        // FIXME: need to actually reserve the lambda for static lambda's
        if (staticLambda != null) {
            ochSignal = new OchSignal(Frequency.ofHz(Long.parseLong(staticLambda)), srcOchPort.lambda().channelSpacing(), srcOchPort.lambda().slotGranularity());
        } else if (!srcOchPort.isTunable() || !dstOchPort.isTunable()) {
            // FIXME: also check destination OCh port
            ochSignal = srcOchPort.lambda();
        } else {
            // Request and reserve lambda on path
            List<OchSignal> lambdas = assignWavelength(intent, path);
            if (lambdas.isEmpty()) {
                continue;
            }
            ochSignal = OchSignal.toFixedGrid(lambdas, ChannelSpacing.CHL_50GHZ);
        }
        // Create installable optical path intent
        // Only support fixed grid for now
        OchSignalType signalType = OchSignalType.FIXED_GRID;
        Intent newIntent = OpticalPathIntent.builder().appId(intent.appId()).src(intent.getSrc()).dst(intent.getDst()).path(path).lambda(ochSignal).signalType(signalType).bidirectional(intent.isBidirectional()).build();
        return ImmutableList.of(newIntent);
    }
    // Release port allocations if unsuccessful
    resourceService.release(intent.id());
    throw new IntentCompilationException("Unable to find suitable lightpath for intent " + intent);
}
#method_after
@Override
public List<Intent> compile(OpticalConnectivityIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    // Check if source and destination are optical OCh ports
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    Port srcPort = deviceService.getPort(src.deviceId(), src.port());
    Port dstPort = deviceService.getPort(dst.deviceId(), dst.port());
    checkArgument(srcPort instanceof OchPort);
    checkArgument(dstPort instanceof OchPort);
    log.debug("Compiling optical connectivity intent between {} and {}", src, dst);
    // Release of intent resources here is only a temporary solution for handling the
    // case of recompiling due to intent restoration (when intent state is FAILED).
    // TODO: try to release intent resources in IntentManager.
    resourceService.release(intent.id());
    // Reserve OCh ports
    Resource srcPortResource = Resources.discrete(src.deviceId(), src.port()).resource();
    Resource dstPortResource = Resources.discrete(dst.deviceId(), dst.port()).resource();
    List<ResourceAllocation> allocation = resourceService.allocate(intent.id(), srcPortResource, dstPortResource);
    if (allocation.isEmpty()) {
        throw new IntentCompilationException("Unable to reserve ports for intent " + intent);
    }
    // Calculate available light paths
    Set<Path> paths = getOpticalPaths(intent);
    // Static or dynamic lambda allocation
    String staticLambda = srcPort.annotations().value(AnnotationKeys.STATIC_LAMBDA);
    OchPort srcOchPort = (OchPort) srcPort;
    OchPort dstOchPort = (OchPort) dstPort;
    OchSignal ochSignal;
    // Use first path that can be successfully reserved
    for (Path path : paths) {
        // FIXME: need to actually reserve the lambda for static lambda's
        if (staticLambda != null) {
            ochSignal = new OchSignal(Frequency.ofHz(Long.parseLong(staticLambda)), srcOchPort.lambda().channelSpacing(), srcOchPort.lambda().slotGranularity());
        } else if (!srcOchPort.isTunable() || !dstOchPort.isTunable()) {
            // FIXME: also check destination OCh port
            ochSignal = srcOchPort.lambda();
        } else {
            // Request and reserve lambda on path
            List<OchSignal> lambdas = assignWavelength(intent, path);
            if (lambdas.isEmpty()) {
                continue;
            }
            ochSignal = OchSignal.toFixedGrid(lambdas, ChannelSpacing.CHL_50GHZ);
        }
        // Create installable optical path intent
        // Only support fixed grid for now
        OchSignalType signalType = OchSignalType.FIXED_GRID;
        Intent newIntent = OpticalPathIntent.builder().appId(intent.appId()).src(intent.getSrc()).dst(intent.getDst()).path(path).lambda(ochSignal).signalType(signalType).bidirectional(intent.isBidirectional()).build();
        return ImmutableList.of(newIntent);
    }
    // Release port allocations if unsuccessful
    resourceService.release(intent.id());
    throw new IntentCompilationException("Unable to find suitable lightpath for intent " + intent);
}
#end_block

#method_before
private List<OchSignal> assignWavelength(Intent intent, Path path) {
    Set<OchSignal> lambdas = findCommonLambdasOverLinks(path.links());
    if (lambdas.isEmpty()) {
        return Collections.emptyList();
    }
    List<OchSignal> minLambda = findFirstLambda(lambdas, slotCount());
    List<Resource> lambdaResources = path.links().stream().flatMap(x -> Stream.of(Resource.discrete(x.src().deviceId(), x.src().port()), Resource.discrete(x.dst().deviceId(), x.dst().port()))).flatMap(x -> minLambda.stream().map(l -> x.child(l))).collect(Collectors.toList());
    List<ResourceAllocation> allocations = resourceService.allocate(intent.id(), lambdaResources);
    if (allocations.isEmpty()) {
        log.info("Resource allocation for {} failed (resource request: {})", intent, lambdaResources);
        return Collections.emptyList();
    }
    return minLambda;
}
#method_after
private List<OchSignal> assignWavelength(Intent intent, Path path) {
    Set<OchSignal> lambdas = findCommonLambdasOverLinks(path.links());
    if (lambdas.isEmpty()) {
        return Collections.emptyList();
    }
    List<OchSignal> minLambda = findFirstLambda(lambdas, slotCount());
    List<Resource> lambdaResources = path.links().stream().flatMap(x -> Stream.of(Resources.discrete(x.src().deviceId(), x.src().port()).resource(), Resources.discrete(x.dst().deviceId(), x.dst().port()).resource())).flatMap(x -> minLambda.stream().map(l -> x.child(l))).collect(Collectors.toList());
    List<ResourceAllocation> allocations = resourceService.allocate(intent.id(), lambdaResources);
    if (allocations.isEmpty()) {
        log.info("Resource allocation for {} failed (resource request: {})", intent, lambdaResources);
        return Collections.emptyList();
    }
    return minLambda;
}
#end_block

#method_before
private Set<OchSignal> findCommonLambdasOverLinks(List<Link> links) {
    return links.stream().flatMap(x -> Stream.of(Resource.discrete(x.src().deviceId(), x.src().port()), Resource.discrete(x.dst().deviceId(), x.dst().port()))).map(resourceService::getAvailableResources).map(x -> Iterables.filter(x, r -> r.last() instanceof OchSignal)).map(x -> Iterables.transform(x, r -> (OchSignal) r.last())).map(x -> (Set<OchSignal>) ImmutableSet.copyOf(x)).reduce(Sets::intersection).orElse(Collections.emptySet());
}
#method_after
private Set<OchSignal> findCommonLambdasOverLinks(List<Link> links) {
    return links.stream().flatMap(x -> Stream.of(Resources.discrete(x.src().deviceId(), x.src().port()).id(), Resources.discrete(x.dst().deviceId(), x.dst().port()).id())).map(x -> resourceService.getAvailableResourceValues(x, OchSignal.class)).map(x -> (Set<OchSignal>) ImmutableSet.copyOf(x)).reduce(Sets::intersection).orElse(Collections.emptySet());
}
#end_block

#method_before
@Override
public List<Intent> compile(OpticalCircuitIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    // Check if ports are OduClt ports
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    Port srcPort = deviceService.getPort(src.deviceId(), src.port());
    Port dstPort = deviceService.getPort(dst.deviceId(), dst.port());
    checkArgument(srcPort instanceof OduCltPort);
    checkArgument(dstPort instanceof OduCltPort);
    log.debug("Compiling optical circuit intent between {} and {}", src, dst);
    // In case of recompile due to intent restoration: first release all intent resources
    resourceService.release(intent.id());
    // Reserve OduClt ports
    Resource srcPortResource = Resource.discrete(src.deviceId(), src.port());
    Resource dstPortResource = Resource.discrete(dst.deviceId(), dst.port());
    List<ResourceAllocation> allocation = resourceService.allocate(intent.id(), srcPortResource, dstPortResource);
    if (allocation.isEmpty()) {
        throw new IntentCompilationException("Unable to reserve ports for intent " + intent);
    }
    // Check if both devices support multiplexing (usage of TributarySlots)
    boolean multiplexingSupported = isMultiplexingSupported(intent);
    LinkedList<Intent> intents = new LinkedList<>();
    // used only for devices supporting multiplexing
    Set<TributarySlot> slots = Collections.emptySet();
    FlowRuleIntent circuitIntent;
    OpticalConnectivityIntent connIntent = findOpticalConnectivityIntent(intent, multiplexingSupported);
    if ((connIntent != null) && multiplexingSupported) {
        // Allocate TributarySlots on existing OCH ports
        slots = assignTributarySlots(intent, getOchPorts(connIntent));
    }
    // Create optical connectivity intent if needed - no optical intent or not enough slots available
    if (connIntent == null || (multiplexingSupported && slots.isEmpty())) {
        // Find OCh ports with available resources
        Pair<OchPort, OchPort> ochPorts = findPorts(intent);
        if (ochPorts == null) {
            // Release port allocations if unsuccessful
            resourceService.release(intent.id());
            throw new IntentCompilationException("Unable to find suitable OCH ports for intent " + intent);
        }
        if (multiplexingSupported) {
            // Allocate TributarySlots on OCH ports
            final List<OchPort> ports = Arrays.asList(ochPorts.getLeft(), ochPorts.getRight());
            slots = assignTributarySlots(intent, ports);
            if (slots.isEmpty()) {
                // Release port allocations if unsuccessful
                resourceService.release(intent.id());
                throw new IntentCompilationException("Unable to find Tributary Slots for intent " + intent);
            }
        }
        // Create optical connectivity intent
        ConnectPoint srcCP = new ConnectPoint(src.elementId(), ochPorts.getLeft().number());
        ConnectPoint dstCP = new ConnectPoint(dst.elementId(), ochPorts.getRight().number());
        OduSignalType signalType = ochPorts.getLeft().signalType();
        connIntent = OpticalConnectivityIntent.builder().appId(appId).src(srcCP).dst(dstCP).signalType(signalType).bidirectional(intent.isBidirectional()).build();
        intentService.submit(connIntent);
    }
    // Create optical circuit intent
    List<FlowRule> rules = new LinkedList<>();
    // at the source: ODUCLT port mapping to OCH port
    rules.add(connectPortsSrc(src, connIntent.getSrc(), intent.priority(), slots));
    // at the destination: OCH port mapping to ODUCLT port
    rules.add(connectPortsDst(connIntent.getDst(), dst, intent.priority(), slots));
    // Create flow rules for reverse path
    if (intent.isBidirectional()) {
        // at the source: ODUCLT port mapping to OCH port
        rules.add(connectPortsSrc(dst, connIntent.getDst(), intent.priority(), slots));
        // at the destination: OCH port mapping to ODUCLT port
        rules.add(connectPortsDst(connIntent.getSrc(), src, intent.priority(), slots));
    }
    circuitIntent = new FlowRuleIntent(appId, rules, intent.resources());
    // Save circuit to connectivity intent mapping
    intentSetMultimap.allocateMapping(connIntent.id(), intent.id());
    intents.add(circuitIntent);
    return intents;
}
#method_after
@Override
public List<Intent> compile(OpticalCircuitIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    // Check if ports are OduClt ports
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    Port srcPort = deviceService.getPort(src.deviceId(), src.port());
    Port dstPort = deviceService.getPort(dst.deviceId(), dst.port());
    checkArgument(srcPort instanceof OduCltPort);
    checkArgument(dstPort instanceof OduCltPort);
    log.debug("Compiling optical circuit intent between {} and {}", src, dst);
    // Release of intent resources here is only a temporary solution for handling the
    // case of recompiling due to intent restoration (when intent state is FAILED).
    // TODO: try to release intent resources in IntentManager.
    resourceService.release(intent.id());
    // Reserve OduClt ports
    Resource srcPortResource = Resources.discrete(src.deviceId(), src.port()).resource();
    Resource dstPortResource = Resources.discrete(dst.deviceId(), dst.port()).resource();
    List<ResourceAllocation> allocation = resourceService.allocate(intent.id(), srcPortResource, dstPortResource);
    if (allocation.isEmpty()) {
        throw new IntentCompilationException("Unable to reserve ports for intent " + intent);
    }
    // Check if both devices support multiplexing (usage of TributarySlots)
    boolean multiplexingSupported = isMultiplexingSupported(intent);
    LinkedList<Intent> intents = new LinkedList<>();
    // slots are used only for devices supporting multiplexing
    Set<TributarySlot> slots = Collections.emptySet();
    OpticalConnectivityIntent connIntent = findOpticalConnectivityIntent(intent, multiplexingSupported);
    if ((connIntent != null) && multiplexingSupported) {
        // Allocate TributarySlots on existing OCH ports
        slots = assignTributarySlots(intent, Pair.of(connIntent.getSrc(), connIntent.getDst()));
    }
    // Create optical connectivity intent if needed - no optical intent or not enough slots available
    if (connIntent == null || (multiplexingSupported && slots.isEmpty())) {
        // Find OCh ports with available resources
        Pair<OchPort, OchPort> ochPorts = findPorts(intent);
        if (ochPorts == null) {
            // Release port allocations if unsuccessful
            resourceService.release(intent.id());
            throw new IntentCompilationException("Unable to find suitable OCH ports for intent " + intent);
        }
        ConnectPoint srcCP = new ConnectPoint(src.elementId(), ochPorts.getLeft().number());
        ConnectPoint dstCP = new ConnectPoint(dst.elementId(), ochPorts.getRight().number());
        if (multiplexingSupported) {
            // Allocate TributarySlots on OCH ports
            slots = assignTributarySlots(intent, Pair.of(srcCP, dstCP));
            if (slots.isEmpty()) {
                // Release port allocations if unsuccessful
                resourceService.release(intent.id());
                throw new IntentCompilationException("Unable to find Tributary Slots for intent " + intent);
            }
        }
        // Create optical connectivity intent
        OduSignalType signalType = ochPorts.getLeft().signalType();
        connIntent = OpticalConnectivityIntent.builder().appId(appId).src(srcCP).dst(dstCP).signalType(signalType).bidirectional(intent.isBidirectional()).build();
        intentService.submit(connIntent);
    }
    // Create optical circuit intent
    List<FlowRule> rules = new LinkedList<>();
    // at the source: ODUCLT port mapping to OCH port
    rules.add(connectPorts(src, connIntent.getSrc(), intent.priority(), slots));
    // at the destination: OCH port mapping to ODUCLT port
    rules.add(connectPorts(connIntent.getDst(), dst, intent.priority(), slots));
    // Create flow rules for reverse path
    if (intent.isBidirectional()) {
        // at the destination: OCH port mapping to ODUCLT port
        rules.add(connectPorts(connIntent.getSrc(), src, intent.priority(), slots));
        // at the source: ODUCLT port mapping to OCH port
        rules.add(connectPorts(dst, connIntent.getDst(), intent.priority(), slots));
    }
    FlowRuleIntent circuitIntent = new FlowRuleIntent(appId, rules, intent.resources());
    // Save circuit to connectivity intent mapping
    intentSetMultimap.allocateMapping(connIntent.id(), intent.id());
    intents.add(circuitIntent);
    return intents;
}
#end_block

#method_before
private OpticalConnectivityIntent findOpticalConnectivityIntent(OpticalCircuitIntent circuitIntent, boolean multiplexingSupported) {
    int requestedTsNum = (multiplexingSupported ? (circuitIntent.getSignalType()).toOduSignalType().tributarySlots() : 0);
    for (Intent intent : intentService.getIntents()) {
        if (!(intent instanceof OpticalConnectivityIntent)) {
            continue;
        }
        OpticalConnectivityIntent connIntent = (OpticalConnectivityIntent) intent;
        ConnectPoint src = circuitIntent.getSrc();
        ConnectPoint dst = circuitIntent.getDst();
        // Ignore if the intents don't have identical src and dst devices
        if (!src.deviceId().equals(connIntent.getSrc().deviceId()) || !dst.deviceId().equals(connIntent.getDst().deviceId())) {
            continue;
        }
        if (!isAllowed(circuitIntent, connIntent)) {
            continue;
        }
        if (!isAvailable(connIntent.id())) {
            continue;
        }
        if (multiplexingSupported) {
            if (!isAvalableTributarySlots(connIntent, requestedTsNum)) {
                continue;
            }
        }
        return connIntent;
    }
    return null;
}
#method_after
private OpticalConnectivityIntent findOpticalConnectivityIntent(OpticalCircuitIntent circuitIntent, boolean multiplexingSupported) {
    OduSignalType oduSignalType = mappingCltSignalTypeToOduSignalType(circuitIntent.getSignalType());
    for (Intent intent : intentService.getIntents()) {
        if (!(intent instanceof OpticalConnectivityIntent)) {
            continue;
        }
        OpticalConnectivityIntent connIntent = (OpticalConnectivityIntent) intent;
        ConnectPoint src = circuitIntent.getSrc();
        ConnectPoint dst = circuitIntent.getDst();
        // Ignore if the intents don't have identical src and dst devices
        if (!src.deviceId().equals(connIntent.getSrc().deviceId()) || !dst.deviceId().equals(connIntent.getDst().deviceId())) {
            continue;
        }
        if (!isAllowed(circuitIntent, connIntent)) {
            continue;
        }
        if (!isAvailable(connIntent.id())) {
            continue;
        }
        if (multiplexingSupported) {
            if (!isAvailableTributarySlots(connIntent, oduSignalType.tributarySlots())) {
                continue;
            }
        }
        return connIntent;
    }
    return null;
}
#end_block

#method_before
private Set<TributarySlot> assignTributarySlots(OpticalCircuitIntent intent, List<OchPort> ports) {
    int requestedTsNum = (intent.getSignalType()).toOduSignalType().tributarySlots();
    Set<TributarySlot> commonTributarySlots = findCommonTributarySlotsOverPorts(ports);
    if (commonTributarySlots.isEmpty()) {
        return Collections.emptySet();
    }
    if (commonTributarySlots.size() < requestedTsNum) {
        return Collections.emptySet();
    }
    Set<TributarySlot> tributarySlots = commonTributarySlots.stream().limit(requestedTsNum).collect(Collectors.toSet());
    List<Resource> tributarySlotResources = ports.stream().flatMap(port -> tributarySlots.stream().map(ts -> Resource.discrete(((Device) port.element()).id(), port.number()).child(ts))).collect(Collectors.toList());
    List<ResourceAllocation> allocations = resourceService.allocate(intent.id(), tributarySlotResources);
    if (allocations.isEmpty()) {
        log.info("Resource allocation for {} failed (resource request: {})", intent, tributarySlotResources);
        return Collections.emptySet();
    }
    return tributarySlots;
}
#method_after
private Set<TributarySlot> assignTributarySlots(OpticalCircuitIntent intent, Pair<ConnectPoint, ConnectPoint> ports) {
    OduSignalType oduSignalType = mappingCltSignalTypeToOduSignalType(intent.getSignalType());
    int requestedTsNum = oduSignalType.tributarySlots();
    Set<TributarySlot> commonTributarySlots = findCommonTributarySlotsOnCps(ports.getLeft(), ports.getRight());
    if (commonTributarySlots.isEmpty()) {
        return Collections.emptySet();
    }
    if (commonTributarySlots.size() < requestedTsNum) {
        return Collections.emptySet();
    }
    Set<TributarySlot> tributarySlots = commonTributarySlots.stream().limit(requestedTsNum).collect(Collectors.toSet());
    final List<ConnectPoint> portsList = ImmutableList.of(ports.getLeft(), ports.getRight());
    List<Resource> tributarySlotResources = portsList.stream().flatMap(cp -> tributarySlots.stream().map(ts -> Resources.discrete(cp.deviceId(), cp.port()).resource().child(ts))).collect(Collectors.toList());
    List<ResourceAllocation> allocations = resourceService.allocate(intent.id(), tributarySlotResources);
    if (allocations.isEmpty()) {
        log.debug("Resource allocation for {} failed (resource request: {})", intent, tributarySlotResources);
        return Collections.emptySet();
    }
    return tributarySlots;
}
#end_block

#method_before
private OchPort findAvailableOchPort(ConnectPoint oduPort, OduSignalType ochPortSignalType) {
    // First see if the port mappings are constrained
    ConnectPoint ochCP = staticPort(oduPort);
    if (ochCP != null) {
        OchPort ochPort = (OchPort) deviceService.getPort(ochCP.deviceId(), ochCP.port());
        Optional<IntentId> intentId = resourceService.getResourceAllocation(Resource.discrete(ochCP.deviceId(), ochCP.port())).stream().map(ResourceAllocation::consumer).filter(x -> x instanceof IntentId).map(x -> (IntentId) x).findAny();
        if (isAvailable(intentId.orElse(null))) {
            return ochPort;
        }
        return null;
    }
    // No port constraints, so find any port that works
    List<Port> ports = deviceService.getPorts(oduPort.deviceId());
    for (Port port : ports) {
        if (!(port instanceof OchPort)) {
            continue;
        }
        // This should be the first allocation on the OCH port
        if (!resourceService.isAvailable(Resource.discrete(oduPort.deviceId(), port.number()))) {
            continue;
        }
        // OchPort is required to have the requested oduSignalType
        if (((OchPort) port).signalType() != ochPortSignalType) {
            continue;
        }
        Optional<IntentId> intentId = resourceService.getResourceAllocation(Resource.discrete(oduPort.deviceId(), port.number())).stream().map(ResourceAllocation::consumer).filter(x -> x instanceof IntentId).map(x -> (IntentId) x).findAny();
        if (isAvailable(intentId.orElse(null))) {
            return (OchPort) port;
        }
    }
    return null;
}
#method_after
private OchPort findAvailableOchPort(ConnectPoint oduPort, OduSignalType ochPortSignalType) {
    // First see if the port mappings are constrained
    ConnectPoint ochCP = staticPort(oduPort);
    if (ochCP != null) {
        OchPort ochPort = (OchPort) deviceService.getPort(ochCP.deviceId(), ochCP.port());
        Optional<IntentId> intentId = resourceService.getResourceAllocations(Resources.discrete(ochCP.deviceId(), ochCP.port()).id()).stream().map(ResourceAllocation::consumer).filter(x -> x instanceof IntentId).map(x -> (IntentId) x).findAny();
        if (isAvailable(intentId.orElse(null))) {
            return ochPort;
        }
        return null;
    }
    // No port constraints, so find any port that works
    List<Port> ports = deviceService.getPorts(oduPort.deviceId());
    for (Port port : ports) {
        if (!(port instanceof OchPort)) {
            continue;
        }
        // This should be the first allocation on the OCH port
        if (!resourceService.isAvailable(Resources.discrete(oduPort.deviceId(), port.number()).resource())) {
            continue;
        }
        // OchPort is required to have the requested oduSignalType
        if (((OchPort) port).signalType() != ochPortSignalType) {
            continue;
        }
        Optional<IntentId> intentId = resourceService.getResourceAllocations(Resources.discrete(oduPort.deviceId(), port.number()).id()).stream().map(ResourceAllocation::consumer).filter(x -> x instanceof IntentId).map(x -> (IntentId) x).findAny();
        if (isAvailable(intentId.orElse(null))) {
            return (OchPort) port;
        }
    }
    return null;
}
#end_block

#method_before
boolean isTributarySlotBehaviourSupported(DeviceId deviceId) {
    Driver driver = driverService.getDriver(deviceId);
    return (driver != null && driver.hasBehaviour(TributarySlotQuery.class));
}
#method_after
private boolean isTributarySlotBehaviourSupported(DeviceId deviceId) {
    Driver driver = driverService.getDriver(deviceId);
    return (driver != null && driver.hasBehaviour(TributarySlotQuery.class));
}
#end_block

#method_before
boolean isMultiplexingSupported(OpticalCircuitIntent intent) {
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    if (!isTributarySlotBehaviourSupported(src.deviceId()) || !isTributarySlotBehaviourSupported(dst.deviceId())) {
        return false;
    }
    ConnectPoint srcStaticPort = staticPort(src);
    if (srcStaticPort != null) {
        return false;
    }
    ConnectPoint dstStaticPort = staticPort(dst);
    if (dstStaticPort != null) {
        return false;
    }
    return true;
}
#method_after
private boolean isMultiplexingSupported(OpticalCircuitIntent intent) {
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    if (!isTributarySlotBehaviourSupported(src.deviceId()) || !isTributarySlotBehaviourSupported(dst.deviceId())) {
        return false;
    }
    ConnectPoint srcStaticPort = staticPort(src);
    if (srcStaticPort != null) {
        return false;
    }
    ConnectPoint dstStaticPort = staticPort(dst);
    if (dstStaticPort != null) {
        return false;
    }
    return true;
}
#end_block

#method_before
public static void processSubModuleEntry(TreeWalkListener listener, GeneratedYangParser.SubModuleStatementContext ctx) {
    // Check if stack is empty.
    checkStackIsEmpty(listener, ListenerErrorType.INVALID_HOLDER, ParsableDataType.SUB_MODULE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY);
    YangSubModule yangSubModule = new YangSubModule();
    yangSubModule.setName(ctx.IDENTIFIER().getText());
    listener.getParsedDataStack().push(yangSubModule);
}
#method_after
public static void processSubModuleEntry(TreeWalkListener listener, GeneratedYangParser.SubModuleStatementContext ctx) {
    // Check if stack is empty.
    checkStackIsEmpty(listener, INVALID_HOLDER, SUB_MODULE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ENTRY);
    YangSubModule yangSubModule = new YangSubModule();
    yangSubModule.setName(ctx.IDENTIFIER().getText());
    listener.getParsedDataStack().push(yangSubModule);
}
#end_block

#method_before
public static void processSubModuleExit(TreeWalkListener listener, GeneratedYangParser.SubModuleStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.SUB_MODULE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT);
    if (!(listener.getParsedDataStack().peek() instanceof YangSubModule)) {
        throw new ParserException(constructListenerErrorMessage(ListenerErrorType.MISSING_CURRENT_HOLDER, ParsableDataType.SUB_MODULE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
    }
}
#method_after
public static void processSubModuleExit(TreeWalkListener listener, GeneratedYangParser.SubModuleStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, SUB_MODULE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), EXIT);
    if (!(listener.getParsedDataStack().peek() instanceof YangSubModule)) {
        throw new ParserException(constructListenerErrorMessage(MISSING_CURRENT_HOLDER, SUB_MODULE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), EXIT));
    }
}
#end_block

#method_before
public static void processOrganizationEntry(TreeWalkListener listener, GeneratedYangParser.OrganizationStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.ORGANIZATION_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY);
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                module.setOrganization(String.valueOf(ctx.string().getText()));
                break;
            }
        case SUB_MODULE_DATA:
            {
                YangSubModule subModule = (YangSubModule) tmpNode;
                subModule.setOrganization(String.valueOf(ctx.string().getText()));
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.ORGANIZATION_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY));
    }
}
#method_after
public static void processOrganizationEntry(TreeWalkListener listener, GeneratedYangParser.OrganizationStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, ORGANIZATION_DATA, String.valueOf(ctx.string().getText()), ENTRY);
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                module.setOrganization(String.valueOf(ctx.string().getText()));
                break;
            }
        case SUB_MODULE_DATA:
            {
                YangSubModule subModule = (YangSubModule) tmpNode;
                subModule.setOrganization(String.valueOf(ctx.string().getText()));
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, ORGANIZATION_DATA, String.valueOf(ctx.string().getText()), ENTRY));
    }
}
#end_block

#method_before
public static void processBelongsToEntry(TreeWalkListener listener, GeneratedYangParser.BelongstoStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.BELONGS_TO_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY);
    YangBelongsTo belongstoNode = new YangBelongsTo();
    belongstoNode.setBelongsToModuleName(String.valueOf(ctx.IDENTIFIER().getText()));
    // Push belongsto into the stack.
    listener.getParsedDataStack().push(belongstoNode);
}
#method_after
public static void processBelongsToEntry(TreeWalkListener listener, GeneratedYangParser.BelongstoStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, BELONGS_TO_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ENTRY);
    YangBelongsTo belongstoNode = new YangBelongsTo();
    belongstoNode.setBelongsToModuleName(String.valueOf(ctx.IDENTIFIER().getText()));
    // Push belongsto into the stack.
    listener.getParsedDataStack().push(belongstoNode);
}
#end_block

#method_before
public static void processBelongsToExit(TreeWalkListener listener, GeneratedYangParser.BelongstoStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.BELONGS_TO_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT);
    Parsable tmpBelongstoNode = listener.getParsedDataStack().peek();
    if (tmpBelongstoNode instanceof YangBelongsTo) {
        listener.getParsedDataStack().pop();
        // Check for stack to be empty.
        checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.BELONGS_TO_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT);
        Parsable tmpNode = listener.getParsedDataStack().peek();
        switch(tmpNode.getParsableDataType()) {
            case SUB_MODULE_DATA:
                {
                    YangSubModule subModule = (YangSubModule) tmpNode;
                    subModule.setBelongsTo((YangBelongsTo) tmpBelongstoNode);
                    break;
                }
            default:
                throw new ParserException(constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.BELONGS_TO_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
        }
    } else {
        throw new ParserException(constructListenerErrorMessage(ListenerErrorType.MISSING_CURRENT_HOLDER, ParsableDataType.BELONGS_TO_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
    }
}
#method_after
public static void processBelongsToExit(TreeWalkListener listener, GeneratedYangParser.BelongstoStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, BELONGS_TO_DATA, String.valueOf(ctx.IDENTIFIER().getText()), EXIT);
    Parsable tmpBelongstoNode = listener.getParsedDataStack().peek();
    if (tmpBelongstoNode instanceof YangBelongsTo) {
        listener.getParsedDataStack().pop();
        // Check for stack to be empty.
        checkStackIsNotEmpty(listener, MISSING_HOLDER, BELONGS_TO_DATA, String.valueOf(ctx.IDENTIFIER().getText()), EXIT);
        Parsable tmpNode = listener.getParsedDataStack().peek();
        switch(tmpNode.getParsableDataType()) {
            case SUB_MODULE_DATA:
                {
                    YangSubModule subModule = (YangSubModule) tmpNode;
                    subModule.setBelongsTo((YangBelongsTo) tmpBelongstoNode);
                    break;
                }
            default:
                throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, BELONGS_TO_DATA, String.valueOf(ctx.IDENTIFIER().getText()), EXIT));
        }
    } else {
        throw new ParserException(constructListenerErrorMessage(MISSING_CURRENT_HOLDER, BELONGS_TO_DATA, String.valueOf(ctx.IDENTIFIER().getText()), EXIT));
    }
}
#end_block

#method_before
@Test
public void checkErrorMsgConstructionWithName() {
    // Create an test error message
    String testErrorMessage = constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.CONTACT_DATA, "Test Instance", ListenerErrorLocation.ENTRY);
    // Check message.
    assertThat(testErrorMessage, is("Internal parser error detected: Invalid holder for contact " + "\"Test Instance\" before processing."));
}
#method_after
@Test
public void checkErrorMsgConstructionWithName() {
    // Create an test error message
    String testErrorMessage = constructListenerErrorMessage(INVALID_HOLDER, CONTACT_DATA, "Test Instance", ENTRY);
    // Check message.
    assertThat(testErrorMessage, is("Internal parser error detected: Invalid holder for contact " + "\"Test Instance\" before processing."));
}
#end_block

#method_before
@Test
public void checkErrorMsgConstructionWithoutName() {
    // Create an test error message
    String testErrorMessage = constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.CONTACT_DATA, "Test Instance", ListenerErrorLocation.ENTRY);
    // Check message.
    assertThat(testErrorMessage, is("Internal parser error detected: Invalid holder for contact \"Test Instance\"" + " before processing."));
}
#method_after
@Test
public void checkErrorMsgConstructionWithoutName() {
    // Create an test error message
    String testErrorMessage = constructListenerErrorMessage(INVALID_HOLDER, CONTACT_DATA, "Test Instance", ENTRY);
    // Check message.
    assertThat(testErrorMessage, is("Internal parser error detected: Invalid holder for contact \"Test Instance\"" + " before processing."));
}
#end_block

#method_before
@Test
public void checkExtendedErrorMsgConstructionWithName() {
    // Create an test error message
    String testErrorMessage = constructExtendedListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.CONTACT_DATA, "Test Instance", ListenerErrorLocation.ENTRY, "Extended Information");
    // Check message.
    assertThat(testErrorMessage, is("Internal parser error detected: Invalid holder for contact \"Test Instance\"" + " before processing.\n" + "Error Information: Extended Information"));
}
#method_after
@Test
public void checkExtendedErrorMsgConstructionWithName() {
    // Create an test error message
    String testErrorMessage = constructExtendedListenerErrorMessage(INVALID_HOLDER, CONTACT_DATA, "Test Instance", ENTRY, "Extended Information");
    // Check message.
    assertThat(testErrorMessage, is("Internal parser error detected: Invalid holder for contact \"Test Instance\"" + " before processing.\n" + "Error Information: Extended Information"));
}
#end_block

#method_before
@Test
public void checkExtendedErrorMsgConstructionWithoutName() {
    // Create an test error message
    String testErrorMessage = constructExtendedListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.CONTACT_DATA, "", ListenerErrorLocation.ENTRY, "Extended Information");
    // Check message.
    assertThat(testErrorMessage, is("Internal parser error detected: Invalid holder for contact" + " before processing.\n" + "Error Information: Extended Information"));
}
#method_after
@Test
public void checkExtendedErrorMsgConstructionWithoutName() {
    // Create an test error message
    String testErrorMessage = constructExtendedListenerErrorMessage(INVALID_HOLDER, CONTACT_DATA, "", ENTRY, "Extended Information");
    // Check message.
    assertThat(testErrorMessage, is("Internal parser error detected: Invalid holder for contact" + " before processing.\n" + "Error Information: Extended Information"));
}
#end_block

#method_before
public static String constructListenerErrorMessage(ListenerErrorType errorType, ParsableDataType parsableDataType, String parsableDataTypeName, ListenerErrorLocation errorLocation) {
    String errorMessage;
    errorMessage = "Internal parser error detected: " + ListenerErrorType.getErrorType(errorType) + " " + ParsableDataType.getParsableDataType(parsableDataType);
    if (!parsableDataTypeName.isEmpty()) {
        errorMessage = errorMessage + " \"" + parsableDataTypeName + "\" ";
    } else {
        errorMessage = errorMessage + " ";
    }
    errorMessage = errorMessage + ListenerErrorLocation.getErrorLocationMessage(errorLocation) + " processing.";
    return errorMessage;
}
#method_after
public static String constructListenerErrorMessage(ListenerErrorType errorType, ParsableDataType parsableDataType, String parsableDataTypeName, ListenerErrorLocation errorLocation) {
    String errorMessage;
    errorMessage = "Internal parser error detected: " + getErrorType(errorType) + " " + getParsableDataType(parsableDataType);
    if (!parsableDataTypeName.isEmpty()) {
        errorMessage = errorMessage + " \"" + parsableDataTypeName + "\" ";
    } else {
        errorMessage = errorMessage + " ";
    }
    errorMessage = errorMessage + getErrorLocationMessage(errorLocation) + " processing.";
    return errorMessage;
}
#end_block

#method_before
public static void checkStackIsNotEmpty(TreeWalkListener listener, ListenerErrorType errorType, ParsableDataType parsableDataType, String parsableDataTypeName, ListenerErrorLocation errorLocation) {
    if (listener.getParsedDataStack().empty()) {
        /*
             * If stack is empty it indicates error condition, value of
             * parsableDataTypeName will be null in case there is no name
             * attached to parsable data type.
             */
        String message = ListenerErrorMessageConstruction.constructListenerErrorMessage(errorType, parsableDataType, parsableDataTypeName, errorLocation);
        throw new ParserException(message);
    }
}
#method_after
public static void checkStackIsNotEmpty(TreeWalkListener listener, ListenerErrorType errorType, ParsableDataType parsableDataType, String parsableDataTypeName, ListenerErrorLocation errorLocation) {
    if (listener.getParsedDataStack().empty()) {
        /*
             * If stack is empty it indicates error condition, value of
             * parsableDataTypeName will be null in case there is no name
             * attached to parsable data type.
             */
        String message = constructListenerErrorMessage(errorType, parsableDataType, parsableDataTypeName, errorLocation);
        throw new ParserException(message);
    }
}
#end_block

#method_before
/**
 * Checks parsed data stack is empty.
 *
 * @param listener Listener's object.
 * @param errorType error type needs to be set in error message.
 * @param parsableDataType type of parsable data in which error occurred.
 * @param parsableDataTypeName name of parsable data type in which error
 *            occurred.
 * @param errorLocation location where error occurred.
 */
public static void checkStackIsEmpty(TreeWalkListener listener, ListenerErrorType errorType, ParsableDataType parsableDataType, String parsableDataTypeName, ListenerErrorLocation errorLocation) {
    if (!listener.getParsedDataStack().empty()) {
        /*
             * If stack is empty it indicates error condition, value of
             * parsableDataTypeName will be null in case there is no name
             * attached to parsable data type.
             */
        String message = ListenerErrorMessageConstruction.constructListenerErrorMessage(errorType, parsableDataType, parsableDataTypeName, errorLocation);
        throw new ParserException(message);
    }
}
#method_after
/**
 * Checks parsed data stack is empty.
 *
 * @param listener Listener's object.
 * @param errorType error type needs to be set in error message.
 * @param parsableDataType type of parsable data in which error occurred.
 * @param parsableDataTypeName name of parsable data type in which error
 *            occurred.
 * @param errorLocation location where error occurred.
 */
public static void checkStackIsEmpty(TreeWalkListener listener, ListenerErrorType errorType, ParsableDataType parsableDataType, String parsableDataTypeName, ListenerErrorLocation errorLocation) {
    if (!listener.getParsedDataStack().empty()) {
        /*
             * If stack is empty it indicates error condition, value of
             * parsableDataTypeName will be null in case there is no name
             * attached to parsable data type.
             */
        String message = constructListenerErrorMessage(errorType, parsableDataType, parsableDataTypeName, errorLocation);
        throw new ParserException(message);
    }
}
#end_block

#method_before
public static void processContactEntry(TreeWalkListener listener, GeneratedYangParser.ContactStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.CONTACT_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY);
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                module.setContact(String.valueOf(ctx.string().getText()));
                break;
            }
        case SUB_MODULE_DATA:
            {
                YangSubModule subModule = (YangSubModule) tmpNode;
                subModule.setContact(String.valueOf(ctx.string().getText()));
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.CONTACT_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY));
    }
}
#method_after
public static void processContactEntry(TreeWalkListener listener, GeneratedYangParser.ContactStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, CONTACT_DATA, String.valueOf(ctx.string().getText()), ENTRY);
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                module.setContact(String.valueOf(ctx.string().getText()));
                break;
            }
        case SUB_MODULE_DATA:
            {
                YangSubModule subModule = (YangSubModule) tmpNode;
                subModule.setContact(String.valueOf(ctx.string().getText()));
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, CONTACT_DATA, String.valueOf(ctx.string().getText()), ENTRY));
    }
}
#end_block

#method_before
public static void processImportEntry(TreeWalkListener listener, GeneratedYangParser.ImportStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.IMPORT_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY);
    YangImport importNode = new YangImport();
    importNode.setModuleName(String.valueOf(ctx.IDENTIFIER().getText()));
    // Push import node to the stack.
    listener.getParsedDataStack().push(importNode);
}
#method_after
public static void processImportEntry(TreeWalkListener listener, GeneratedYangParser.ImportStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, IMPORT_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ENTRY);
    YangImport importNode = new YangImport();
    importNode.setModuleName(String.valueOf(ctx.IDENTIFIER().getText()));
    // Push import node to the stack.
    listener.getParsedDataStack().push(importNode);
}
#end_block

#method_before
public static void processImportExit(TreeWalkListener listener, GeneratedYangParser.ImportStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.IMPORT_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT);
    Parsable tmpImportNode = listener.getParsedDataStack().peek();
    if (tmpImportNode instanceof YangImport) {
        listener.getParsedDataStack().pop();
        // Check for stack to be non empty.
        checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.IMPORT_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT);
        Parsable tmpNode = listener.getParsedDataStack().peek();
        switch(tmpNode.getParsableDataType()) {
            case MODULE_DATA:
                {
                    YangModule module = (YangModule) tmpNode;
                    module.addImportedInfo((YangImport) tmpImportNode);
                    break;
                }
            case SUB_MODULE_DATA:
                {
                    YangSubModule subModule = (YangSubModule) tmpNode;
                    subModule.addImportedInfo((YangImport) tmpImportNode);
                    break;
                }
            default:
                throw new ParserException(constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.IMPORT_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
        }
    } else {
        throw new ParserException(constructListenerErrorMessage(ListenerErrorType.MISSING_CURRENT_HOLDER, ParsableDataType.IMPORT_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
    }
}
#method_after
public static void processImportExit(TreeWalkListener listener, GeneratedYangParser.ImportStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, IMPORT_DATA, String.valueOf(ctx.IDENTIFIER().getText()), EXIT);
    Parsable tmpImportNode = listener.getParsedDataStack().peek();
    if (tmpImportNode instanceof YangImport) {
        listener.getParsedDataStack().pop();
        // Check for stack to be non empty.
        checkStackIsNotEmpty(listener, MISSING_HOLDER, IMPORT_DATA, String.valueOf(ctx.IDENTIFIER().getText()), EXIT);
        Parsable tmpNode = listener.getParsedDataStack().peek();
        switch(tmpNode.getParsableDataType()) {
            case MODULE_DATA:
                {
                    YangModule module = (YangModule) tmpNode;
                    module.addImportedInfo((YangImport) tmpImportNode);
                    break;
                }
            case SUB_MODULE_DATA:
                {
                    YangSubModule subModule = (YangSubModule) tmpNode;
                    subModule.addImportedInfo((YangImport) tmpImportNode);
                    break;
                }
            default:
                throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, IMPORT_DATA, String.valueOf(ctx.IDENTIFIER().getText()), EXIT));
        }
    } else {
        throw new ParserException(constructListenerErrorMessage(MISSING_CURRENT_HOLDER, IMPORT_DATA, String.valueOf(ctx.IDENTIFIER().getText()), EXIT));
    }
}
#end_block

#method_before
public static void processNamespaceEntry(TreeWalkListener listener, GeneratedYangParser.NamespaceStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.NAMESPACE_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY);
    if (!validateUriValue(String.valueOf(ctx.string().getText()))) {
        ParserException parserException = new ParserException("Invalid namespace URI");
        parserException.setLine(ctx.string().STRING(0).getSymbol().getLine());
        parserException.setCharPosition(ctx.string().STRING(0).getSymbol().getCharPositionInLine());
        throw parserException;
    }
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                YangNameSpace uri = new YangNameSpace();
                uri.setUri(String.valueOf(ctx.string().getText()));
                module.setNameSpace(uri);
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.NAMESPACE_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY));
    }
}
#method_after
public static void processNamespaceEntry(TreeWalkListener listener, GeneratedYangParser.NamespaceStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, NAMESPACE_DATA, String.valueOf(ctx.string().getText()), ENTRY);
    if (!validateUriValue(String.valueOf(ctx.string().getText()))) {
        ParserException parserException = new ParserException("Invalid namespace URI");
        parserException.setLine(ctx.string().STRING(0).getSymbol().getLine());
        parserException.setCharPosition(ctx.string().STRING(0).getSymbol().getCharPositionInLine());
        throw parserException;
    }
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                YangNameSpace uri = new YangNameSpace();
                uri.setUri(String.valueOf(ctx.string().getText()));
                module.setNameSpace(uri);
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, NAMESPACE_DATA, String.valueOf(ctx.string().getText()), ENTRY));
    }
}
#end_block

#method_before
public static void processPrefixEntry(TreeWalkListener listener, GeneratedYangParser.PrefixStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.PREFIX_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY);
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                module.setPrefix(ctx.IDENTIFIER().getText());
                break;
            }
        case IMPORT_DATA:
            {
                YangImport importNode = (YangImport) tmpNode;
                importNode.setPrefixId(ctx.IDENTIFIER().getText());
                break;
            }
        case BELONGS_TO_DATA:
            {
                YangBelongsTo belongstoNode = (YangBelongsTo) tmpNode;
                belongstoNode.setPrefix(ctx.IDENTIFIER().getText());
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.PREFIX_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY));
    }
}
#method_after
public static void processPrefixEntry(TreeWalkListener listener, GeneratedYangParser.PrefixStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, PREFIX_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ENTRY);
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                module.setPrefix(ctx.IDENTIFIER().getText());
                break;
            }
        case IMPORT_DATA:
            {
                YangImport importNode = (YangImport) tmpNode;
                importNode.setPrefixId(ctx.IDENTIFIER().getText());
                break;
            }
        case BELONGS_TO_DATA:
            {
                YangBelongsTo belongstoNode = (YangBelongsTo) tmpNode;
                belongstoNode.setPrefix(ctx.IDENTIFIER().getText());
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, PREFIX_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ENTRY));
    }
}
#end_block

#method_before
public static void processYangFileEntry(TreeWalkListener listener, GeneratedYangParser.YangfileContext ctx) {
    // Check if stack is empty.
    checkStackIsEmpty(listener, ListenerErrorType.INVALID_HOLDER, ParsableDataType.YANGBASE_DATA, "", ListenerErrorLocation.ENTRY);
}
#method_after
public static void processYangFileEntry(TreeWalkListener listener, GeneratedYangParser.YangfileContext ctx) {
    // Check if stack is empty.
    checkStackIsEmpty(listener, INVALID_HOLDER, YANGBASE_DATA, "", ENTRY);
}
#end_block

#method_before
public static void processYangFileExit(TreeWalkListener listener, GeneratedYangParser.YangfileContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.YANGBASE_DATA, "", ListenerErrorLocation.EXIT);
    // Data Model tree root node is set.
    if (listener.getParsedDataStack().peek() instanceof YangModule || listener.getParsedDataStack().peek() instanceof YangSubModule) {
        listener.setRootNode((YangNode) listener.getParsedDataStack().pop());
    } else {
        throw new ParserException(constructListenerErrorMessage(ListenerErrorType.INVALID_CHILD, ParsableDataType.YANGBASE_DATA, "", ListenerErrorLocation.EXIT));
    }
    // Check if stack is empty.
    checkStackIsEmpty(listener, ListenerErrorType.INVALID_HOLDER, ParsableDataType.YANGBASE_DATA, "", ListenerErrorLocation.EXIT);
}
#method_after
public static void processYangFileExit(TreeWalkListener listener, GeneratedYangParser.YangfileContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, YANGBASE_DATA, "", EXIT);
    // Data Model tree root node is set.
    if (listener.getParsedDataStack().peek() instanceof YangModule || listener.getParsedDataStack().peek() instanceof YangSubModule) {
        listener.setRootNode((YangNode) listener.getParsedDataStack().pop());
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_CHILD, YANGBASE_DATA, "", EXIT));
    }
    // Check if stack is empty.
    checkStackIsEmpty(listener, INVALID_HOLDER, YANGBASE_DATA, "", EXIT);
}
#end_block

#method_before
public static void processRevisionDateEntry(TreeWalkListener listener, GeneratedYangParser.RevisionDateStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.REVISION_DATE_DATA, String.valueOf(ctx.DATE_ARG().getText()), ListenerErrorLocation.ENTRY);
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case IMPORT_DATA:
            {
                YangImport importNode = (YangImport) tmpNode;
                importNode.setRevision(String.valueOf(ctx.DATE_ARG().getText()));
                break;
            }
        case INCLUDE_DATA:
            {
                YangInclude includeNode = (YangInclude) tmpNode;
                includeNode.setRevision(String.valueOf(ctx.DATE_ARG().getText()));
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.REVISION_DATE_DATA, String.valueOf(ctx.DATE_ARG().getText()), ListenerErrorLocation.ENTRY));
    }
}
#method_after
public static void processRevisionDateEntry(TreeWalkListener listener, GeneratedYangParser.RevisionDateStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, REVISION_DATE_DATA, String.valueOf(ctx.DATE_ARG().getText()), ENTRY);
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case IMPORT_DATA:
            {
                YangImport importNode = (YangImport) tmpNode;
                importNode.setRevision(String.valueOf(ctx.DATE_ARG().getText()));
                break;
            }
        case INCLUDE_DATA:
            {
                YangInclude includeNode = (YangInclude) tmpNode;
                includeNode.setRevision(String.valueOf(ctx.DATE_ARG().getText()));
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, REVISION_DATE_DATA, String.valueOf(ctx.DATE_ARG().getText()), ENTRY));
    }
}
#end_block

#method_before
@Test
public void validateStackIsNotEmptyForEmptyStack() {
    String expectedError = constructListenerErrorMessage(ListenerErrorType.MISSING_HOLDER, ParsableDataType.YANGBASE_DATA, "", ListenerErrorLocation.EXIT);
    // Get the exception occurred during parsing.
    thrown.expect(ParserException.class);
    thrown.expectMessage(expectedError);
    // Create test walker and assign test error to it.
    TreeWalkListener testWalker = new TreeWalkListener();
    checkStackIsNotEmpty(testWalker, ListenerErrorType.MISSING_HOLDER, ParsableDataType.YANGBASE_DATA, "", ListenerErrorLocation.EXIT);
}
#method_after
@Test
public void validateStackIsNotEmptyForEmptyStack() {
    String expectedError = constructListenerErrorMessage(MISSING_HOLDER, YANGBASE_DATA, "", EXIT);
    // Get the exception occurred during parsing.
    thrown.expect(ParserException.class);
    thrown.expectMessage(expectedError);
    // Create test walker and assign test error to it.
    TreeWalkListener testWalker = new TreeWalkListener();
    checkStackIsNotEmpty(testWalker, MISSING_HOLDER, YANGBASE_DATA, "", EXIT);
}
#end_block

#method_before
@Test
public void validateStackIsNotEmptyForNonEmptyStack() {
    // Create test walker and assign test error to it.
    TreeWalkListener testWalker = new TreeWalkListener();
    // Create a temporary node of parsable.
    YangRevision tmpNode = new YangRevision();
    testWalker.getParsedDataStack().push(tmpNode);
    checkStackIsNotEmpty(testWalker, ListenerErrorType.MISSING_HOLDER, ParsableDataType.YANGBASE_DATA, "", ListenerErrorLocation.EXIT);
}
#method_after
@Test
public void validateStackIsNotEmptyForNonEmptyStack() {
    // Create test walker and assign test error to it.
    TreeWalkListener testWalker = new TreeWalkListener();
    // Create a temporary node of parsable.
    YangRevision tmpNode = new YangRevision();
    testWalker.getParsedDataStack().push(tmpNode);
    checkStackIsNotEmpty(testWalker, MISSING_HOLDER, YANGBASE_DATA, "", EXIT);
}
#end_block

#method_before
@Test
public void validateStackIsEmptyForNonEmptyStack() {
    String expectedError = constructListenerErrorMessage(ListenerErrorType.MISSING_HOLDER, ParsableDataType.YANGBASE_DATA, "", ListenerErrorLocation.EXIT);
    // Get the exception occurred during parsing.
    thrown.expect(ParserException.class);
    thrown.expectMessage(expectedError);
    // Create test walker and assign test error to it.
    TreeWalkListener testWalker = new TreeWalkListener();
    // Create a temporary node of parsable.
    YangRevision tmpNode = new YangRevision();
    testWalker.getParsedDataStack().push(tmpNode);
    checkStackIsEmpty(testWalker, ListenerErrorType.MISSING_HOLDER, ParsableDataType.YANGBASE_DATA, "", ListenerErrorLocation.EXIT);
}
#method_after
@Test
public void validateStackIsEmptyForNonEmptyStack() {
    String expectedError = constructListenerErrorMessage(MISSING_HOLDER, YANGBASE_DATA, "", EXIT);
    // Get the exception occurred during parsing.
    thrown.expect(ParserException.class);
    thrown.expectMessage(expectedError);
    // Create test walker and assign test error to it.
    TreeWalkListener testWalker = new TreeWalkListener();
    // Create a temporary node of parsable.
    YangRevision tmpNode = new YangRevision();
    testWalker.getParsedDataStack().push(tmpNode);
    checkStackIsEmpty(testWalker, MISSING_HOLDER, YANGBASE_DATA, "", EXIT);
}
#end_block

#method_before
@Test
public void validateStackIsEmptyForEmptyStack() {
    // Create test walker and assign test error to it.
    TreeWalkListener testWalker = new TreeWalkListener();
    checkStackIsEmpty(testWalker, ListenerErrorType.MISSING_HOLDER, ParsableDataType.YANGBASE_DATA, "", ListenerErrorLocation.EXIT);
}
#method_after
@Test
public void validateStackIsEmptyForEmptyStack() {
    // Create test walker and assign test error to it.
    TreeWalkListener testWalker = new TreeWalkListener();
    checkStackIsEmpty(testWalker, MISSING_HOLDER, YANGBASE_DATA, "", EXIT);
}
#end_block

#method_before
public static void processVersionEntry(TreeWalkListener listener, GeneratedYangParser.YangVersionStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.VERSION_DATA, String.valueOf(ctx.INTEGER().getText()), ListenerErrorLocation.ENTRY);
    Integer version = Integer.valueOf(ctx.INTEGER().getText());
    if (!isVersionValid(version)) {
        ParserException parserException = new ParserException("Input version not supported");
        parserException.setLine(ctx.INTEGER().getSymbol().getLine());
        parserException.setCharPosition(ctx.INTEGER().getSymbol().getCharPositionInLine());
        throw parserException;
    }
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                module.setVersion((byte) 1);
                break;
            }
        case SUB_MODULE_DATA:
            {
                YangSubModule subModule = (YangSubModule) tmpNode;
                subModule.setVersion((byte) 1);
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.VERSION_DATA, String.valueOf(ctx.INTEGER().getText()), ListenerErrorLocation.ENTRY));
    }
}
#method_after
public static void processVersionEntry(TreeWalkListener listener, GeneratedYangParser.YangVersionStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, VERSION_DATA, String.valueOf(ctx.INTEGER().getText()), ENTRY);
    Integer version = Integer.valueOf(ctx.INTEGER().getText());
    if (!isVersionValid(version)) {
        ParserException parserException = new ParserException("Input version not supported");
        parserException.setLine(ctx.INTEGER().getSymbol().getLine());
        parserException.setCharPosition(ctx.INTEGER().getSymbol().getCharPositionInLine());
        throw parserException;
    }
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                module.setVersion((byte) 1);
                break;
            }
        case SUB_MODULE_DATA:
            {
                YangSubModule subModule = (YangSubModule) tmpNode;
                subModule.setVersion((byte) 1);
                break;
            }
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, VERSION_DATA, String.valueOf(ctx.INTEGER().getText()), ENTRY));
    }
}
#end_block

#method_before
public static void processIncludeEntry(TreeWalkListener listener, GeneratedYangParser.IncludeStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.INCLUDE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY);
    YangInclude includeNode = new YangInclude();
    includeNode.setSubModuleName(String.valueOf(ctx.IDENTIFIER().getText()));
    listener.getParsedDataStack().push(includeNode);
}
#method_after
public static void processIncludeEntry(TreeWalkListener listener, GeneratedYangParser.IncludeStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, INCLUDE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ENTRY);
    YangInclude includeNode = new YangInclude();
    includeNode.setSubModuleName(String.valueOf(ctx.IDENTIFIER().getText()));
    listener.getParsedDataStack().push(includeNode);
}
#end_block

#method_before
public static void processIncludeExit(TreeWalkListener listener, GeneratedYangParser.IncludeStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.INCLUDE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT);
    Parsable tmpIncludeNode = listener.getParsedDataStack().peek();
    if (tmpIncludeNode instanceof YangInclude) {
        listener.getParsedDataStack().pop();
        // Check for stack to be non empty.
        checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.INCLUDE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT);
        Parsable tmpNode = listener.getParsedDataStack().peek();
        switch(tmpNode.getParsableDataType()) {
            case MODULE_DATA:
                {
                    YangModule module = (YangModule) tmpNode;
                    module.addIncludedInfo((YangInclude) tmpIncludeNode);
                    break;
                }
            case SUB_MODULE_DATA:
                {
                    YangSubModule subModule = (YangSubModule) tmpNode;
                    subModule.addIncludedInfo((YangInclude) tmpIncludeNode);
                    break;
                }
            default:
                throw new ParserException(constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.INCLUDE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
        }
    } else {
        throw new ParserException(constructListenerErrorMessage(ListenerErrorType.MISSING_CURRENT_HOLDER, ParsableDataType.INCLUDE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
    }
}
#method_after
public static void processIncludeExit(TreeWalkListener listener, GeneratedYangParser.IncludeStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, INCLUDE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), EXIT);
    Parsable tmpIncludeNode = listener.getParsedDataStack().peek();
    if (tmpIncludeNode instanceof YangInclude) {
        listener.getParsedDataStack().pop();
        // Check for stack to be non empty.
        checkStackIsNotEmpty(listener, MISSING_HOLDER, INCLUDE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), EXIT);
        Parsable tmpNode = listener.getParsedDataStack().peek();
        switch(tmpNode.getParsableDataType()) {
            case MODULE_DATA:
                {
                    YangModule module = (YangModule) tmpNode;
                    module.addIncludedInfo((YangInclude) tmpIncludeNode);
                    break;
                }
            case SUB_MODULE_DATA:
                {
                    YangSubModule subModule = (YangSubModule) tmpNode;
                    subModule.addIncludedInfo((YangInclude) tmpIncludeNode);
                    break;
                }
            default:
                throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, INCLUDE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), EXIT));
        }
    } else {
        throw new ParserException(constructListenerErrorMessage(MISSING_CURRENT_HOLDER, INCLUDE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), EXIT));
    }
}
#end_block

#method_before
public static void processRevisionEntry(TreeWalkListener listener, GeneratedYangParser.RevisionStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.REVISION_DATA, String.valueOf(ctx.DATE_ARG().getText()), ListenerErrorLocation.ENTRY);
    // value.
    if (!validateRevision(listener, ctx)) {
        return;
    // TODO to be implemented.
    }
    YangRevision revisionNode = new YangRevision();
    revisionNode.setRevDate(String.valueOf(ctx.DATE_ARG().getText()));
    listener.getParsedDataStack().push(revisionNode);
}
#method_after
public static void processRevisionEntry(TreeWalkListener listener, GeneratedYangParser.RevisionStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, REVISION_DATA, String.valueOf(ctx.DATE_ARG().getText()), ENTRY);
    // value.
    if (!validateRevision(listener, ctx)) {
        return;
    // TODO to be implemented.
    }
    YangRevision revisionNode = new YangRevision();
    revisionNode.setRevDate(String.valueOf(ctx.DATE_ARG().getText()));
    listener.getParsedDataStack().push(revisionNode);
}
#end_block

#method_before
public static void processRevisionExit(TreeWalkListener listener, GeneratedYangParser.RevisionStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.REVISION_DATA, String.valueOf(ctx.DATE_ARG().getText()), ListenerErrorLocation.EXIT);
    Parsable tmpRevisionNode = listener.getParsedDataStack().peek();
    if (tmpRevisionNode instanceof YangRevision) {
        listener.getParsedDataStack().pop();
        // Check for stack to be non empty.
        checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.REVISION_DATA, String.valueOf(ctx.DATE_ARG().getText()), ListenerErrorLocation.EXIT);
        Parsable tmpNode = listener.getParsedDataStack().peek();
        switch(tmpNode.getParsableDataType()) {
            case MODULE_DATA:
                {
                    YangModule module = (YangModule) tmpNode;
                    module.setRevision((YangRevision) tmpRevisionNode);
                    break;
                }
            case SUB_MODULE_DATA:
                {
                    YangSubModule subModule = (YangSubModule) tmpNode;
                    subModule.setRevision((YangRevision) tmpRevisionNode);
                    break;
                }
            default:
                throw new ParserException(constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.REVISION_DATA, String.valueOf(ctx.DATE_ARG().getText()), ListenerErrorLocation.EXIT));
        }
    } else {
        throw new ParserException(constructListenerErrorMessage(ListenerErrorType.MISSING_CURRENT_HOLDER, ParsableDataType.REVISION_DATA, String.valueOf(ctx.DATE_ARG().getText()), ListenerErrorLocation.EXIT));
    }
}
#method_after
public static void processRevisionExit(TreeWalkListener listener, GeneratedYangParser.RevisionStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, REVISION_DATA, String.valueOf(ctx.DATE_ARG().getText()), EXIT);
    Parsable tmpRevisionNode = listener.getParsedDataStack().peek();
    if (tmpRevisionNode instanceof YangRevision) {
        listener.getParsedDataStack().pop();
        // Check for stack to be non empty.
        checkStackIsNotEmpty(listener, MISSING_HOLDER, REVISION_DATA, String.valueOf(ctx.DATE_ARG().getText()), EXIT);
        Parsable tmpNode = listener.getParsedDataStack().peek();
        switch(tmpNode.getParsableDataType()) {
            case MODULE_DATA:
                {
                    YangModule module = (YangModule) tmpNode;
                    module.setRevision((YangRevision) tmpRevisionNode);
                    break;
                }
            case SUB_MODULE_DATA:
                {
                    YangSubModule subModule = (YangSubModule) tmpNode;
                    subModule.setRevision((YangRevision) tmpRevisionNode);
                    break;
                }
            default:
                throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, REVISION_DATA, String.valueOf(ctx.DATE_ARG().getText()), EXIT));
        }
    } else {
        throw new ParserException(constructListenerErrorMessage(MISSING_CURRENT_HOLDER, REVISION_DATA, String.valueOf(ctx.DATE_ARG().getText()), EXIT));
    }
}
#end_block

#method_before
public static void processModuleEntry(TreeWalkListener listener, GeneratedYangParser.ModuleStatementContext ctx) {
    // Check if stack is empty.
    checkStackIsEmpty(listener, ListenerErrorType.INVALID_HOLDER, ParsableDataType.MODULE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY);
    YangModule yangModule = new YangModule();
    yangModule.setName(ctx.IDENTIFIER().getText());
    listener.getParsedDataStack().push(yangModule);
}
#method_after
public static void processModuleEntry(TreeWalkListener listener, GeneratedYangParser.ModuleStatementContext ctx) {
    // Check if stack is empty.
    checkStackIsEmpty(listener, INVALID_HOLDER, MODULE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ENTRY);
    YangModule yangModule = new YangModule();
    yangModule.setName(ctx.IDENTIFIER().getText());
    listener.getParsedDataStack().push(yangModule);
}
#end_block

#method_before
public static void processModuleExit(TreeWalkListener listener, GeneratedYangParser.ModuleStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.MODULE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT);
    if (!(listener.getParsedDataStack().peek() instanceof YangModule)) {
        throw new ParserException(constructListenerErrorMessage(ListenerErrorType.MISSING_CURRENT_HOLDER, ParsableDataType.MODULE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
    }
}
#method_after
public static void processModuleExit(TreeWalkListener listener, GeneratedYangParser.ModuleStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, MODULE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), EXIT);
    if (!(listener.getParsedDataStack().peek() instanceof YangModule)) {
        throw new ParserException(constructListenerErrorMessage(MISSING_CURRENT_HOLDER, MODULE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), EXIT));
    }
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    Integer poolSize = getIntegerProperty(properties, "sharedThreadPoolSize");
    if (poolSize != null && poolSize > 1) {
        sharedThreadPoolSize = poolSize;
        SharedExecutors.setPoolSize(sharedThreadPoolSize);
    } else if (poolSize != null) {
        log.warn("sharedThreadPoolSize must be greater than 1");
    }
    Integer timeLimit = getIntegerProperty(properties, "maxEventTimeLimit");
    if (timeLimit != null && timeLimit > 1) {
        maxEventTimeLimit = timeLimit;
        eventDeliveryService.setDispatchTimeLimit(maxEventTimeLimit);
    } else if (timeLimit != null) {
        log.warn("maxEventTimeLimit must be greater than 1");
    }
    Boolean performanceCheck = isPropertyEnabled(properties, "sharedThreadPerformanceCheck");
    if (performanceCheck != null) {
        calculatePoolPerformance = performanceCheck;
        SharedExecutors.setCalculatePoolPerformance(calculatePoolPerformance);
    }
    log.info("Settings: sharedThreadPoolSize={}, maxEventTimeLimit={}, calculatePoolPerformance={}", sharedThreadPoolSize, maxEventTimeLimit, calculatePoolPerformance);
}
#method_after
@Modified
public void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    Integer poolSize = getIntegerProperty(properties, "sharedThreadPoolSize");
    if (poolSize != null && poolSize > 1) {
        sharedThreadPoolSize = poolSize;
        SharedExecutors.setPoolSize(sharedThreadPoolSize);
    } else if (poolSize != null) {
        log.warn("sharedThreadPoolSize must be greater than 1");
    }
    Integer timeLimit = getIntegerProperty(properties, "maxEventTimeLimit");
    if (timeLimit != null && timeLimit > 1) {
        maxEventTimeLimit = timeLimit;
        eventDeliveryService.setDispatchTimeLimit(maxEventTimeLimit);
    } else if (timeLimit != null) {
        log.warn("maxEventTimeLimit must be greater than 1");
    }
    Boolean performanceCheck = isPropertyEnabled(properties, "sharedThreadPerformanceCheck");
    if (performanceCheck != null) {
        calculatePoolPerformance = performanceCheck;
        SharedExecutors.setCalculatePoolPerformance(calculatePoolPerformance, metricsService);
    }
    log.info("Settings: sharedThreadPoolSize={}, maxEventTimeLimit={}, calculatePoolPerformance={}", sharedThreadPoolSize, maxEventTimeLimit, calculatePoolPerformance);
}
#end_block

#method_before
@Override
public <T> Future<T> submit(Callable<T> task) {
    Counter taskcounter = new Counter();
    taskcounter.reset();
    return executor.submit(() -> {
        T t = null;
        long queuewaittime = (long) taskcounter.duration();
        String classname;
        if (task instanceof CallableExtended) {
            classname = ((CallableExtended) task).getRunnable().getClass().toString();
        } else {
            classname = task.getClass().toString();
        }
        if (queuemetrics != null) {
            queuemetrics.update(queuewaittime, TimeUnit.SECONDS);
        }
        taskcounter.reset();
        try {
            t = task.call();
        } catch (Exception e) {
        }
        long taskwaittime = (long) taskcounter.duration();
        if (delaymetrics != null) {
            delaymetrics.update(taskwaittime, TimeUnit.SECONDS);
        }
        return t;
    });
}
#method_after
@Override
public <T> Future<T> submit(Callable<T> task) {
    Counter taskCounter = new Counter();
    taskCounter.reset();
    return executor.submit(() -> {
        T t = null;
        long queueWaitTime = (long) taskCounter.duration();
        String className;
        if (task instanceof CallableExtended) {
            className = ((CallableExtended) task).getRunnable().getClass().toString();
        } else {
            className = task.getClass().toString();
        }
        if (queueMetrics != null) {
            queueMetrics.update(queueWaitTime, TimeUnit.SECONDS);
        }
        taskCounter.reset();
        try {
            t = task.call();
        } catch (Exception e) {
        }
        long taskwaittime = (long) taskCounter.duration();
        if (delayMetrics != null) {
            delayMetrics.update(taskwaittime, TimeUnit.SECONDS);
        }
        return t;
    });
}
#end_block

#method_before
public void setCalculatePoolPerformance(boolean calculatePoolPerformance) {
    if (calculatePoolPerformance) {
        if (metricsService != null) {
            executormetrics = metricsService.registerComponent("SharedExecutor");
            MetricsFeature mf = executormetrics.registerFeature("*");
            queuemetrics = metricsService.createTimer(executormetrics, mf, "Queue");
            delaymetrics = metricsService.createTimer(executormetrics, mf, "Delay");
        }
    } else {
        queuemetrics = null;
        delaymetrics = null;
    }
}
#method_after
public void setCalculatePoolPerformance(boolean calculatePoolPerformance, MetricsService metricsSrv) {
    this.metricsService = metricsSrv;
    if (calculatePoolPerformance) {
        if (metricsService != null) {
            executorMetrics = metricsService.registerComponent("SharedExecutor");
            MetricsFeature mf = executorMetrics.registerFeature("*");
            queueMetrics = metricsService.createTimer(executorMetrics, mf, "Queue");
            delayMetrics = metricsService.createTimer(executorMetrics, mf, "Delay");
        }
    } else {
        metricsService = null;
        queueMetrics = null;
        delayMetrics = null;
    }
}
#end_block

#method_before
public static void setCalculatePoolPerformance(boolean calculatePoolPerformance) {
    poolThreadExecutor.setCalculatePoolPerformance(calculatePoolPerformance);
}
#method_after
public static void setCalculatePoolPerformance(boolean calculatePoolPerformance, MetricsService metricsService) {
    poolThreadExecutor.setCalculatePoolPerformance(calculatePoolPerformance, metricsService);
}
#end_block

#method_before
private void processHostAddedEvent(HostEvent event) {
    MacAddress mac = event.subject().mac();
    VlanId vlanId = event.subject().vlan();
    DeviceId deviceId = event.subject().location().deviceId();
    PortNumber port = event.subject().location().port();
    Set<IpAddress> ips = event.subject().ipAddresses();
    log.info("Host {}/{} is added at {}:{}", mac, vlanId, deviceId, port);
    // Populate bridging table entry
    log.debug("Populate L2 table entry for host {} at {}:{}", mac, deviceId, port);
    ForwardingObjective.Builder fob = getForwardingObjectiveBuilder(deviceId, mac, vlanId, port);
    flowObjectiveService.forward(deviceId, fob.add(new BridgingTableObjectiveContext(mac, vlanId)));
    // Populate IP table entry
    ips.forEach(ip -> {
        if (ip.isIp4()) {
            routingRulePopulator.populateIpRuleForHost(deviceId, ip.getIp4Address(), mac, port);
        }
    });
}
#method_after
private void processHostAddedEvent(HostEvent event) {
    MacAddress mac = event.subject().mac();
    VlanId vlanId = event.subject().vlan();
    DeviceId deviceId = event.subject().location().deviceId();
    PortNumber port = event.subject().location().port();
    Set<IpAddress> ips = event.subject().ipAddresses();
    log.info("Host {}/{} is added at {}:{}", mac, vlanId, deviceId, port);
    if (!deviceConfiguration.excludedPorts().contains(new ConnectPoint(deviceId, port))) {
        // Populate bridging table entry
        log.debug("Populate L2 table entry for host {} at {}:{}", mac, deviceId, port);
        ForwardingObjective.Builder fob = getForwardingObjectiveBuilder(deviceId, mac, vlanId, port);
        flowObjectiveService.forward(deviceId, fob.add(new BridgingTableObjectiveContext(mac, vlanId)));
        // Populate IP table entry
        ips.forEach(ip -> {
            if (ip.isIp4()) {
                routingRulePopulator.populateIpRuleForHost(deviceId, ip.getIp4Address(), mac, port);
            }
        });
    }
}
#end_block

#method_before
private void processHostRemoveEvent(HostEvent event) {
    MacAddress mac = event.subject().mac();
    VlanId vlanId = event.subject().vlan();
    DeviceId deviceId = event.subject().location().deviceId();
    PortNumber port = event.subject().location().port();
    Set<IpAddress> ips = event.subject().ipAddresses();
    log.debug("Host {}/{} is removed from {}:{}", mac, vlanId, deviceId, port);
    // Revoke bridging table entry
    ForwardingObjective.Builder fob = getForwardingObjectiveBuilder(deviceId, mac, vlanId, port);
    flowObjectiveService.forward(deviceId, fob.remove(new BridgingTableObjectiveContext(mac, vlanId)));
    // Revoke IP table entry
    ips.forEach(ip -> {
        if (ip.isIp4()) {
            routingRulePopulator.revokeIpRuleForHost(deviceId, ip.getIp4Address(), mac, port);
        }
    });
}
#method_after
private void processHostRemoveEvent(HostEvent event) {
    MacAddress mac = event.subject().mac();
    VlanId vlanId = event.subject().vlan();
    DeviceId deviceId = event.subject().location().deviceId();
    PortNumber port = event.subject().location().port();
    Set<IpAddress> ips = event.subject().ipAddresses();
    log.debug("Host {}/{} is removed from {}:{}", mac, vlanId, deviceId, port);
    if (!deviceConfiguration.excludedPorts().contains(new ConnectPoint(deviceId, port))) {
        // Revoke bridging table entry
        ForwardingObjective.Builder fob = getForwardingObjectiveBuilder(deviceId, mac, vlanId, port);
        flowObjectiveService.forward(deviceId, fob.remove(new BridgingTableObjectiveContext(mac, vlanId)));
        // Revoke IP table entry
        ips.forEach(ip -> {
            if (ip.isIp4()) {
                routingRulePopulator.revokeIpRuleForHost(deviceId, ip.getIp4Address(), mac, port);
            }
        });
    }
}
#end_block

#method_before
private void processHostMovedEvent(HostEvent event) {
    MacAddress mac = event.subject().mac();
    VlanId vlanId = event.subject().vlan();
    DeviceId prevDeviceId = event.prevSubject().location().deviceId();
    PortNumber prevPort = event.prevSubject().location().port();
    Set<IpAddress> prevIps = event.prevSubject().ipAddresses();
    DeviceId newDeviceId = event.subject().location().deviceId();
    PortNumber newPort = event.subject().location().port();
    Set<IpAddress> newIps = event.subject().ipAddresses();
    log.debug("Host {}/{} is moved from {}:{} to {}:{}", mac, vlanId, prevDeviceId, prevPort, newDeviceId, newPort);
    // Revoke previous bridging table entry
    ForwardingObjective.Builder prevFob = getForwardingObjectiveBuilder(prevDeviceId, mac, vlanId, prevPort);
    flowObjectiveService.forward(prevDeviceId, prevFob.remove(new BridgingTableObjectiveContext(mac, vlanId)));
    // Revoke previous IP table entry
    prevIps.forEach(ip -> {
        if (ip.isIp4()) {
            routingRulePopulator.revokeIpRuleForHost(prevDeviceId, ip.getIp4Address(), mac, prevPort);
        }
    });
    // Populate new bridging table entry
    ForwardingObjective.Builder newFob = getForwardingObjectiveBuilder(newDeviceId, mac, vlanId, newPort);
    flowObjectiveService.forward(newDeviceId, newFob.add(new BridgingTableObjectiveContext(mac, vlanId)));
    // Populate new IP table entry
    newIps.forEach(ip -> {
        if (ip.isIp4()) {
            routingRulePopulator.populateIpRuleForHost(newDeviceId, ip.getIp4Address(), mac, newPort);
        }
    });
}
#method_after
private void processHostMovedEvent(HostEvent event) {
    MacAddress mac = event.subject().mac();
    VlanId vlanId = event.subject().vlan();
    DeviceId prevDeviceId = event.prevSubject().location().deviceId();
    PortNumber prevPort = event.prevSubject().location().port();
    Set<IpAddress> prevIps = event.prevSubject().ipAddresses();
    DeviceId newDeviceId = event.subject().location().deviceId();
    PortNumber newPort = event.subject().location().port();
    Set<IpAddress> newIps = event.subject().ipAddresses();
    log.debug("Host {}/{} is moved from {}:{} to {}:{}", mac, vlanId, prevDeviceId, prevPort, newDeviceId, newPort);
    if (!deviceConfiguration.excludedPorts().contains(new ConnectPoint(prevDeviceId, prevPort))) {
        // Revoke previous bridging table entry
        ForwardingObjective.Builder prevFob = getForwardingObjectiveBuilder(prevDeviceId, mac, vlanId, prevPort);
        flowObjectiveService.forward(prevDeviceId, prevFob.remove(new BridgingTableObjectiveContext(mac, vlanId)));
        // Revoke previous IP table entry
        prevIps.forEach(ip -> {
            if (ip.isIp4()) {
                routingRulePopulator.revokeIpRuleForHost(prevDeviceId, ip.getIp4Address(), mac, prevPort);
            }
        });
    }
    if (!deviceConfiguration.excludedPorts().contains(new ConnectPoint(newDeviceId, newPort))) {
        // Populate new bridging table entry
        ForwardingObjective.Builder newFob = getForwardingObjectiveBuilder(newDeviceId, mac, vlanId, newPort);
        flowObjectiveService.forward(newDeviceId, newFob.add(new BridgingTableObjectiveContext(mac, vlanId)));
        // Populate new IP table entry
        newIps.forEach(ip -> {
            if (ip.isIp4()) {
                routingRulePopulator.populateIpRuleForHost(newDeviceId, ip.getIp4Address(), mac, newPort);
            }
        });
    }
}
#end_block

#method_before
private void processHostUpdatedEvent(HostEvent event) {
    MacAddress mac = event.subject().mac();
    VlanId vlanId = event.subject().vlan();
    DeviceId prevDeviceId = event.prevSubject().location().deviceId();
    PortNumber prevPort = event.prevSubject().location().port();
    Set<IpAddress> prevIps = event.prevSubject().ipAddresses();
    DeviceId newDeviceId = event.subject().location().deviceId();
    PortNumber newPort = event.subject().location().port();
    Set<IpAddress> newIps = event.subject().ipAddresses();
    log.debug("Host {}/{} is updated", mac, vlanId);
    // Revoke previous IP table entry
    prevIps.forEach(ip -> {
        if (ip.isIp4()) {
            routingRulePopulator.revokeIpRuleForHost(prevDeviceId, ip.getIp4Address(), mac, prevPort);
        }
    });
    // Populate new IP table entry
    newIps.forEach(ip -> {
        if (ip.isIp4()) {
            routingRulePopulator.populateIpRuleForHost(newDeviceId, ip.getIp4Address(), mac, newPort);
        }
    });
}
#method_after
private void processHostUpdatedEvent(HostEvent event) {
    MacAddress mac = event.subject().mac();
    VlanId vlanId = event.subject().vlan();
    DeviceId prevDeviceId = event.prevSubject().location().deviceId();
    PortNumber prevPort = event.prevSubject().location().port();
    Set<IpAddress> prevIps = event.prevSubject().ipAddresses();
    DeviceId newDeviceId = event.subject().location().deviceId();
    PortNumber newPort = event.subject().location().port();
    Set<IpAddress> newIps = event.subject().ipAddresses();
    log.debug("Host {}/{} is updated", mac, vlanId);
    if (!deviceConfiguration.excludedPorts().contains(new ConnectPoint(prevDeviceId, prevPort))) {
        // Revoke previous IP table entry
        prevIps.forEach(ip -> {
            if (ip.isIp4()) {
                routingRulePopulator.revokeIpRuleForHost(prevDeviceId, ip.getIp4Address(), mac, prevPort);
            }
        });
    }
    if (!deviceConfiguration.excludedPorts().contains(new ConnectPoint(newDeviceId, newPort))) {
        // Populate new IP table entry
        newIps.forEach(ip -> {
            if (ip.isIp4()) {
                routingRulePopulator.populateIpRuleForHost(newDeviceId, ip.getIp4Address(), mac, newPort);
            }
        });
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    ApplicationId subject = APP_ID;
    String key = SegmentRoutingService.SR_APP_ID;
    ObjectMapper mapper = new ObjectMapper();
    JsonNode jsonNode = mapper.readTree(jsonString);
    ConfigApplyDelegate delegate = new MockDelegate();
    config = new SegmentRoutingAppConfig();
    config.init(subject, key, jsonNode, mapper, delegate);
}
#method_after
@Before
public void setUp() throws Exception {
    ApplicationId subject = APP_ID;
    String key = SegmentRoutingService.SR_APP_ID;
    ObjectMapper mapper = new ObjectMapper();
    JsonNode jsonNode = mapper.readTree(JSON_STRING);
    JsonNode invalidJsonNode = mapper.readTree(INVALID_JSON_STRING);
    ConfigApplyDelegate delegate = new MockDelegate();
    config = new SegmentRoutingAppConfig();
    config.init(subject, key, jsonNode, mapper, delegate);
    invalidConfig = new SegmentRoutingAppConfig();
    invalidConfig.init(subject, key, invalidJsonNode, mapper, delegate);
}
#end_block

#method_before
@Test
public void testVRouters() throws Exception {
    assertTrue(config.isValid());
    Set<MacAddress> vRouters = config.vRouterMacs();
    assertThat(vRouters.size(), is(2));
    assertTrue(vRouters.contains(routerMac1));
    assertTrue(vRouters.contains(routerMac2));
}
#method_after
@Test
public void testVRouters() throws Exception {
    Set<MacAddress> vRouters = config.vRouterMacs();
    assertThat(vRouters.size(), is(2));
    assertTrue(vRouters.contains(ROUTER_MAC_1));
    assertTrue(vRouters.contains(ROUTER_MAC_2));
}
#end_block

#method_before
@Test
public void testSetVRouters() throws Exception {
    ImmutableSet.Builder<MacAddress> builder = ImmutableSet.builder();
    builder.add(routerMac3);
    config.setVRouterMacs(builder.build());
    Set<MacAddress> macs = config.vRouterMacs();
    assertThat(macs.size(), is(1));
    assertTrue(macs.contains(routerMac3));
}
#method_after
@Test
public void testSetVRouters() throws Exception {
    ImmutableSet.Builder<MacAddress> builder = ImmutableSet.builder();
    builder.add(ROUTER_MAC_3);
    config.setVRouterMacs(builder.build());
    Set<MacAddress> macs = config.vRouterMacs();
    assertThat(macs.size(), is(1));
    assertTrue(macs.contains(ROUTER_MAC_3));
}
#end_block

#method_before
@Test
public void testExcludePorts() throws Exception {
    assertTrue(config.isValid());
    Set<String> excludePorts = config.excludePorts();
    assertThat(excludePorts.size(), is(2));
    assertTrue(excludePorts.contains(portName1));
    assertTrue(excludePorts.contains(portName2));
}
#method_after
@Test
public void testExcludePorts() throws Exception {
    Set<String> excludePorts = config.excludePorts();
    assertThat(excludePorts.size(), is(2));
    assertTrue(excludePorts.contains(PORT_NAME_1));
    assertTrue(excludePorts.contains(PORT_NAME_2));
}
#end_block

#method_before
@Test
public void testSetExcludePorts() throws Exception {
    ImmutableSet.Builder<String> builder = ImmutableSet.builder();
    builder.add(portName3);
    config.setExcludePorts(builder.build());
    Set<String> excludePorts = config.excludePorts();
    assertThat(excludePorts.size(), is(1));
    assertTrue(excludePorts.contains(portName3));
}
#method_after
@Test
public void testSetExcludePorts() throws Exception {
    ImmutableSet.Builder<String> builder = ImmutableSet.builder();
    builder.add(PORT_NAME_3);
    config.setExcludePorts(builder.build());
    Set<String> excludePorts = config.excludePorts();
    assertThat(excludePorts.size(), is(1));
    assertTrue(excludePorts.contains(PORT_NAME_3));
}
#end_block

#method_before
@Override
public boolean isValid() {
    return hasOnlyFields(VROUTER_MACS, EXCLUDE_PORTS) && vRouterMacs() != null && excludePorts() != null;
}
#method_after
@Override
public boolean isValid() {
    return hasOnlyFields(VROUTER_MACS, VROUTER_ID, EXCLUDE_PORTS) && vRouterMacs() != null && vRouterId() != null && excludePorts() != null;
}
#end_block

#method_before
public Set<Ip4Prefix> getSubnets(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getSubnets for device{} is {}", deviceId, srinfo.subnets.values());
        return ImmutableSet.copyOf(srinfo.subnets.values());
    }
    return null;
}
#method_after
public Set<Ip4Prefix> getSubnets(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getSubnets for device{} is {}", deviceId, srinfo.subnets.values());
        ImmutableSet.Builder<Ip4Prefix> builder = ImmutableSet.builder();
        builder.addAll(srinfo.subnets.values());
        if (deviceId.equals(appConfig.vRouterId())) {
            builder.add(Ip4Prefix.valueOf("0.0.0.0/0"));
        }
        return builder.build();
    }
    return null;
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    // TODO move this part to NetworkConfigEventHandler
    if (event.configClass().equals(SegmentRoutingConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                log.info("Segment Routing Config added.");
                configureNetwork();
                break;
            case CONFIG_UPDATED:
                log.info("Segment Routing Config updated.");
                // TODO support dynamic configuration
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(VRouterConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                netcfgHandler.processVRouterConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                netcfgHandler.processVRouterConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                netcfgHandler.processVRouterConfigRemoved(event);
                break;
            default:
                break;
        }
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    // TODO move this part to NetworkConfigEventHandler
    if (event.configClass().equals(SegmentRoutingDeviceConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                log.info("Segment Routing Config added.");
                configureNetwork();
                break;
            case CONFIG_UPDATED:
                log.info("Segment Routing Config updated.");
                // TODO support dynamic configuration
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(SegmentRoutingAppConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                netcfgHandler.processVRouterConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                netcfgHandler.processVRouterConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                netcfgHandler.processVRouterConfigRemoved(event);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
protected Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.info("Processing versatile forwarding objective");
    EthTypeCriterion ethType = (EthTypeCriterion) fwd.selector().getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective must include ethType");
        fail(fwd, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    if (fwd.nextId() == null && fwd.treatment() == null) {
        log.error("Forwarding objective {} from {} must contain " + "nextId or Treatment", fwd.selector(), fwd.appId());
        return Collections.emptySet();
    }
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    fwd.selector().criteria().forEach(criterion -> {
        if (criterion instanceof VlanIdCriterion) {
            VlanId vlanId = ((VlanIdCriterion) criterion).vlanId();
            // match untagged packets this way in the ACL table.
            if (vlanId.equals(VlanId.NONE)) {
                return;
            }
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vlanId);
            sbuilder.extension(ofdpaMatchVlanVid, deviceId);
        } else {
            sbuilder.add(criterion);
        }
    });
    // XXX driver does not currently do type checking as per Tables 65-67 in
    // OFDPA 2.0 spec. The only allowed treatment is a punt to the controller.
    TrafficTreatment.Builder ttBuilder = DefaultTrafficTreatment.builder();
    if (fwd.treatment() != null) {
        for (Instruction ins : fwd.treatment().allInstructions()) {
            if (ins instanceof OutputInstruction) {
                OutputInstruction o = (OutputInstruction) ins;
                if (o.port() == PortNumber.CONTROLLER) {
                    ttBuilder.add(o);
                } else {
                    log.warn("Only allowed treatments in versatile forwarding " + "objectives are punts to the controller");
                }
            } else {
                log.warn("Cannot process instruction in versatile fwd {}", ins);
            }
        }
    }
    if (fwd.nextId() != null) {
        // overide case
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
        // we only need the top level group's key to point the flow to it
        Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
        if (group == null) {
            log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
            fail(fwd, ObjectiveError.GROUPMISSING);
            return Collections.emptySet();
        }
        ttBuilder.deferred().group(group.id());
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(sbuilder.build()).withTreatment(ttBuilder.build()).makePermanent().forTable(ACL_TABLE);
    return Collections.singletonList(ruleBuilder.build());
}
#method_after
protected Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.info("Processing versatile forwarding objective");
    EthTypeCriterion ethType = (EthTypeCriterion) fwd.selector().getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective must include ethType");
        fail(fwd, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    if (fwd.nextId() == null && fwd.treatment() == null) {
        log.error("Forwarding objective {} from {} must contain " + "nextId or Treatment", fwd.selector(), fwd.appId());
        fail(fwd, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    fwd.selector().criteria().forEach(criterion -> {
        if (criterion instanceof VlanIdCriterion) {
            VlanId vlanId = ((VlanIdCriterion) criterion).vlanId();
            // match untagged packets this way in the ACL table.
            if (vlanId.equals(VlanId.NONE)) {
                return;
            }
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vlanId);
            sbuilder.extension(ofdpaMatchVlanVid, deviceId);
        } else {
            sbuilder.add(criterion);
        }
    });
    // XXX driver does not currently do type checking as per Tables 65-67 in
    // OFDPA 2.0 spec. The only allowed treatment is a punt to the controller.
    TrafficTreatment.Builder ttBuilder = DefaultTrafficTreatment.builder();
    if (fwd.treatment() != null) {
        for (Instruction ins : fwd.treatment().allInstructions()) {
            if (ins instanceof OutputInstruction) {
                OutputInstruction o = (OutputInstruction) ins;
                if (o.port() == PortNumber.CONTROLLER) {
                    ttBuilder.add(o);
                } else {
                    log.warn("Only allowed treatments in versatile forwarding " + "objectives are punts to the controller");
                }
            } else {
                log.warn("Cannot process instruction in versatile fwd {}", ins);
            }
        }
    }
    if (fwd.nextId() != null) {
        // overide case
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
        // we only need the top level group's key to point the flow to it
        Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
        if (group == null) {
            log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
            fail(fwd, ObjectiveError.GROUPMISSING);
            return Collections.emptySet();
        }
        ttBuilder.deferred().group(group.id());
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(sbuilder.build()).withTreatment(ttBuilder.build()).makePermanent().forTable(ACL_TABLE);
    return Collections.singletonList(ruleBuilder.build());
}
#end_block

#method_before
protected static void pass(Objective obj) {
    if (obj.context().isPresent()) {
        obj.context().get().onSuccess(obj);
    }
}
#method_after
protected static void pass(Objective obj) {
    obj.context().ifPresent(context -> context.onSuccess(obj));
}
#end_block

#method_before
protected static void fail(Objective obj, ObjectiveError error) {
    if (obj.context().isPresent()) {
        obj.context().get().onError(obj, error);
    }
}
#method_after
protected static void fail(Objective obj, ObjectiveError error) {
    obj.context().ifPresent(context -> context.onError(obj, error));
}
#end_block

#method_before
protected void processVRouterConfigAdded(NetworkConfigEvent event) {
    log.info("Processing vRouter CONFIG_ADDED");
    VRouterConfig config = (VRouterConfig) event.config().get();
    deviceService.getAvailableDevices().forEach(device -> {
        populateVRouter(device.id(), getMacAddresses(config));
    });
}
#method_after
protected void processVRouterConfigAdded(NetworkConfigEvent event) {
    log.info("Processing vRouter CONFIG_ADDED");
    SegmentRoutingAppConfig config = (SegmentRoutingAppConfig) event.config().get();
    deviceService.getAvailableDevices().forEach(device -> {
        populateVRouter(device.id(), getMacAddresses(config));
    });
}
#end_block

#method_before
protected void processVRouterConfigUpdated(NetworkConfigEvent event) {
    log.info("Processing vRouter CONFIG_UPDATED");
    VRouterConfig config = (VRouterConfig) event.config().get();
    VRouterConfig prevConfig = (VRouterConfig) event.prevConfig().get();
    deviceService.getAvailableDevices().forEach(device -> {
        Set<MacAddress> macAddresses = getMacAddresses(config);
        Set<MacAddress> prevMacAddresses = getMacAddresses(prevConfig);
        // Avoid removing and re-adding unchanged MAC addresses since
        // FlowObjective does not guarantee the execution order.
        Set<MacAddress> sameMacAddresses = new HashSet<>(macAddresses);
        sameMacAddresses.retainAll(prevMacAddresses);
        macAddresses.removeAll(sameMacAddresses);
        prevMacAddresses.removeAll(sameMacAddresses);
        revokeVRouter(device.id(), prevMacAddresses);
        populateVRouter(device.id(), macAddresses);
    });
}
#method_after
protected void processVRouterConfigUpdated(NetworkConfigEvent event) {
    log.info("Processing vRouter CONFIG_UPDATED");
    SegmentRoutingAppConfig config = (SegmentRoutingAppConfig) event.config().get();
    SegmentRoutingAppConfig prevConfig = (SegmentRoutingAppConfig) event.prevConfig().get();
    deviceService.getAvailableDevices().forEach(device -> {
        Set<MacAddress> macAddresses = getMacAddresses(config);
        Set<MacAddress> prevMacAddresses = getMacAddresses(prevConfig);
        // Avoid removing and re-adding unchanged MAC addresses since
        // FlowObjective does not guarantee the execution order.
        Set<MacAddress> sameMacAddresses = new HashSet<>(macAddresses);
        sameMacAddresses.retainAll(prevMacAddresses);
        macAddresses.removeAll(sameMacAddresses);
        prevMacAddresses.removeAll(sameMacAddresses);
        revokeVRouter(device.id(), prevMacAddresses);
        populateVRouter(device.id(), macAddresses);
    });
}
#end_block

#method_before
protected void processVRouterConfigRemoved(NetworkConfigEvent event) {
    log.info("Processing vRouter CONFIG_REMOVED");
    VRouterConfig prevConfig = (VRouterConfig) event.prevConfig().get();
    deviceService.getAvailableDevices().forEach(device -> {
        revokeVRouter(device.id(), getMacAddresses(prevConfig));
    });
}
#method_after
protected void processVRouterConfigRemoved(NetworkConfigEvent event) {
    log.info("Processing vRouter CONFIG_REMOVED");
    SegmentRoutingAppConfig prevConfig = (SegmentRoutingAppConfig) event.prevConfig().get();
    deviceService.getAvailableDevices().forEach(device -> {
        revokeVRouter(device.id(), getMacAddresses(prevConfig));
    });
}
#end_block

#method_before
public void initVRouters(DeviceId deviceId) {
    VRouterConfig config = srManager.cfgService.getConfig(srManager.appId, VRouterConfig.class);
    populateVRouter(deviceId, getMacAddresses(config));
}
#method_after
public void initVRouters(DeviceId deviceId) {
    SegmentRoutingAppConfig config = srManager.cfgService.getConfig(srManager.appId, SegmentRoutingAppConfig.class);
    populateVRouter(deviceId, getMacAddresses(config));
}
#end_block

#method_before
private Set<MacAddress> getMacAddresses(VRouterConfig config) {
    if (config == null) {
        return ImmutableSet.of();
    }
    HashSet<MacAddress> macAddresses = new HashSet<>();
    config.vRouters().forEach(vRouter -> {
        macAddresses.add(vRouter.mac());
    });
    return ImmutableSet.copyOf(macAddresses);
}
#method_after
private Set<MacAddress> getMacAddresses(SegmentRoutingAppConfig config) {
    if (config == null) {
        return ImmutableSet.of();
    }
    HashSet<MacAddress> macAddresses = new HashSet<>();
    config.vRouterMacs().forEach(mac -> {
        macAddresses.add(mac);
    });
    return ImmutableSet.copyOf(macAddresses);
}
#end_block

#method_before
private ForwardingObjective.Builder getForwardingObjectiveBuilder(DeviceId deviceId, Ip4Address hostIp, MacAddress hostMac, PortNumber outPort) throws DeviceConfigNotFoundException {
    MacAddress deviceMac;
    deviceMac = config.getDeviceMac(deviceId);
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    sbuilder.matchEthType(Ethernet.TYPE_IPV4);
    sbuilder.matchIPDst(IpPrefix.valueOf(hostIp, IpPrefix.MAX_INET_MASK_LENGTH));
    TrafficSelector selector = sbuilder.build();
    tbuilder.deferred().setEthDst(hostMac).setEthSrc(deviceMac).setOutput(outPort);
    TrafficTreatment treatment = tbuilder.build();
    // All forwarding is via Groups. Drivers can re-purpose to flow-actions if needed.
    // for switch pipelines that need it, provide outgoing vlan as metadata
    VlanId outvlan = null;
    Ip4Prefix subnet = srManager.deviceConfiguration.getPortSubnet(deviceId, outPort);
    if (subnet == null) {
        outvlan = VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET);
    } else {
        outvlan = srManager.getSubnetAssignedVlanId(deviceId, subnet);
    }
    TrafficSelector meta = DefaultTrafficSelector.builder().matchVlanId(outvlan).build();
    int portNextObjId = srManager.getPortNextObjectiveId(deviceId, outPort, treatment, meta);
    return DefaultForwardingObjective.builder().withSelector(selector).nextStep(portNextObjId).fromApp(srManager.appId).makePermanent().withPriority(SegmentRoutingService.DEFAULT_PRIORITY).withFlag(ForwardingObjective.Flag.SPECIFIC);
}
#method_after
private ForwardingObjective.Builder getForwardingObjectiveBuilder(DeviceId deviceId, Ip4Address hostIp, MacAddress hostMac, PortNumber outPort) throws DeviceConfigNotFoundException {
    MacAddress deviceMac;
    deviceMac = config.getDeviceMac(deviceId);
    int priority;
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    sbuilder.matchEthType(Ethernet.TYPE_IPV4);
    // Special case for default route
    if (hostIp.isZero()) {
        sbuilder.matchIPDst(IpPrefix.valueOf(hostIp, 0));
        priority = SegmentRoutingService.MIN_IP_PRIORITY;
    } else {
        Ip4Prefix hostIpPrefix = Ip4Prefix.valueOf(hostIp, IpPrefix.MAX_INET_MASK_LENGTH);
        sbuilder.matchIPDst(hostIpPrefix);
        priority = getPriorityFromPrefix(hostIpPrefix);
    }
    TrafficSelector selector = sbuilder.build();
    tbuilder.deferred().setEthDst(hostMac).setEthSrc(deviceMac).setOutput(outPort);
    TrafficTreatment treatment = tbuilder.build();
    // All forwarding is via Groups. Drivers can re-purpose to flow-actions if needed.
    // for switch pipelines that need it, provide outgoing vlan as metadata
    VlanId outvlan = null;
    Ip4Prefix subnet = srManager.deviceConfiguration.getPortSubnet(deviceId, outPort);
    if (subnet == null) {
        outvlan = VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET);
    } else {
        outvlan = srManager.getSubnetAssignedVlanId(deviceId, subnet);
    }
    TrafficSelector meta = DefaultTrafficSelector.builder().matchVlanId(outvlan).build();
    int portNextObjId = srManager.getPortNextObjectiveId(deviceId, outPort, treatment, meta);
    return DefaultForwardingObjective.builder().withSelector(selector).nextStep(portNextObjId).fromApp(srManager.appId).makePermanent().withPriority(priority).withFlag(ForwardingObjective.Flag.SPECIFIC);
}
#end_block

#method_before
public boolean populateIpRuleForRouter(DeviceId deviceId, IpPrefix ipPrefix, DeviceId destSw, Set<DeviceId> nextHops) {
    int segmentId;
    try {
        segmentId = config.getSegmentId(destSw);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateIpRuleForRouter.");
        return false;
    }
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    sbuilder.matchIPDst(ipPrefix);
    sbuilder.matchEthType(Ethernet.TYPE_IPV4);
    TrafficSelector selector = sbuilder.build();
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    NeighborSet ns;
    TrafficTreatment treatment;
    // is not set.
    if (nextHops.size() == 1 && nextHops.toArray()[0].equals(destSw)) {
        tbuilder.immediate().decNwTtl();
        ns = new NeighborSet(nextHops);
        treatment = tbuilder.build();
    } else {
        ns = new NeighborSet(nextHops, segmentId);
        treatment = null;
    }
    // setup metadata to pass to nextObjective - indicate the vlan on egress
    // if needed by the switch pipeline. Since neighbor sets are always to
    // other neighboring routers, there is no subnet assigned on those ports.
    TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder(selector);
    metabuilder.matchVlanId(VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET));
    int nextId = srManager.getNextObjectiveId(deviceId, ns, metabuilder.build());
    if (nextId <= 0) {
        log.warn("No next objective in {} for ns: {}", deviceId, ns);
        return false;
    }
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().fromApp(srManager.appId).makePermanent().nextStep(nextId).withSelector(selector).withPriority(2000 * ipPrefix.prefixLength() + SegmentRoutingService.MIN_IP_PRIORITY).withFlag(ForwardingObjective.Flag.SPECIFIC);
    if (treatment != null) {
        fwdBuilder.withTreatment(treatment);
    }
    log.debug("Installing IPv4 forwarding objective " + "for router IP/subnet {} in switch {}", ipPrefix, deviceId);
    srManager.flowObjectiveService.forward(deviceId, fwdBuilder.add(new SRObjectiveContext(deviceId, SRObjectiveContext.ObjectiveType.FORWARDING)));
    rulePopulationCounter.incrementAndGet();
    return true;
}
#method_after
public boolean populateIpRuleForRouter(DeviceId deviceId, IpPrefix ipPrefix, DeviceId destSw, Set<DeviceId> nextHops) {
    int segmentId;
    try {
        segmentId = config.getSegmentId(destSw);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateIpRuleForRouter.");
        return false;
    }
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    sbuilder.matchIPDst(ipPrefix);
    sbuilder.matchEthType(Ethernet.TYPE_IPV4);
    TrafficSelector selector = sbuilder.build();
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    NeighborSet ns;
    TrafficTreatment treatment;
    // is not set.
    if (nextHops.size() == 1 && nextHops.toArray()[0].equals(destSw)) {
        tbuilder.immediate().decNwTtl();
        ns = new NeighborSet(nextHops);
        treatment = tbuilder.build();
    } else {
        ns = new NeighborSet(nextHops, segmentId);
        treatment = null;
    }
    // setup metadata to pass to nextObjective - indicate the vlan on egress
    // if needed by the switch pipeline. Since neighbor sets are always to
    // other neighboring routers, there is no subnet assigned on those ports.
    TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder(selector);
    metabuilder.matchVlanId(VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET));
    int nextId = srManager.getNextObjectiveId(deviceId, ns, metabuilder.build());
    if (nextId <= 0) {
        log.warn("No next objective in {} for ns: {}", deviceId, ns);
        return false;
    }
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().fromApp(srManager.appId).makePermanent().nextStep(nextId).withSelector(selector).withPriority(getPriorityFromPrefix(ipPrefix)).withFlag(ForwardingObjective.Flag.SPECIFIC);
    if (treatment != null) {
        fwdBuilder.withTreatment(treatment);
    }
    log.debug("Installing IPv4 forwarding objective " + "for router IP/subnet {} in switch {}", ipPrefix, deviceId);
    srManager.flowObjectiveService.forward(deviceId, fwdBuilder.add(new SRObjectiveContext(deviceId, SRObjectiveContext.ObjectiveType.FORWARDING)));
    rulePopulationCounter.incrementAndGet();
    return true;
}
#end_block

#method_before
public void populateRouterIpPunts(DeviceId deviceId) {
    Ip4Address routerIp;
    try {
        routerIp = config.getRouterIp(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateRouterIpPunts.");
        return;
    }
    if (!srManager.mastershipService.isLocalMaster(deviceId)) {
        log.debug("Not installing port-IP punts - not the master for dev:{} ", deviceId);
        return;
    }
    ForwardingObjective.Builder puntIp = DefaultForwardingObjective.builder();
    Set<Ip4Address> allIps = new HashSet<>();
    allIps.add(routerIp);
    for (Ip4Address ipaddr : allIps) {
        TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
        TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
        sbuilder.matchEthType(Ethernet.TYPE_IPV4);
        sbuilder.matchIPDst(IpPrefix.valueOf(ipaddr, IpPrefix.MAX_INET_MASK_LENGTH));
        tbuilder.setOutput(PortNumber.CONTROLLER);
        puntIp.withSelector(sbuilder.build());
        puntIp.withTreatment(tbuilder.build());
        puntIp.withFlag(Flag.VERSATILE).withPriority(SegmentRoutingService.HIGHEST_PRIORITY).makePermanent().fromApp(srManager.appId);
        log.debug("Installing forwarding objective to punt port IP addresses");
        srManager.flowObjectiveService.forward(deviceId, puntIp.add(new SRObjectiveContext(deviceId, SRObjectiveContext.ObjectiveType.FORWARDING)));
    }
}
#method_after
public void populateRouterIpPunts(DeviceId deviceId) {
    Ip4Address routerIp;
    try {
        routerIp = config.getRouterIp(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateRouterIpPunts.");
        return;
    }
    if (!srManager.mastershipService.isLocalMaster(deviceId)) {
        log.debug("Not installing port-IP punts - not the master for dev:{} ", deviceId);
        return;
    }
    ForwardingObjective.Builder puntIp = DefaultForwardingObjective.builder();
    Set<Ip4Address> allIps = new HashSet<>(config.getPortIPs(deviceId));
    allIps.add(routerIp);
    for (Ip4Address ipaddr : allIps) {
        TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
        TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
        sbuilder.matchEthType(Ethernet.TYPE_IPV4);
        sbuilder.matchIPDst(IpPrefix.valueOf(ipaddr, IpPrefix.MAX_INET_MASK_LENGTH));
        tbuilder.setOutput(PortNumber.CONTROLLER);
        puntIp.withSelector(sbuilder.build());
        puntIp.withTreatment(tbuilder.build());
        puntIp.withFlag(Flag.VERSATILE).withPriority(SegmentRoutingService.HIGHEST_PRIORITY).makePermanent().fromApp(srManager.appId);
        log.debug("Installing forwarding objective to punt port IP addresses");
        srManager.flowObjectiveService.forward(deviceId, puntIp.add(new SRObjectiveContext(deviceId, SRObjectiveContext.ObjectiveType.FORWARDING)));
    }
}
#end_block

#method_before
public static void processDescriptionEntry(TreeWalkListener listener, GeneratedYangParser.DescriptionStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.DESCRIPTION_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY)) {
        return;
    }
    Parsable tmpData = listener.getParsedDataStack().peek();
    if (tmpData instanceof YangDesc) {
        YangDesc description = (YangDesc) tmpData;
        description.setDescription(ctx.string().getText());
    } else {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_HOLDER, ParsableDataType.DESCRIPTION_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY));
    }
}
#method_after
public static void processDescriptionEntry(TreeWalkListener listener, GeneratedYangParser.DescriptionStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.DESCRIPTION_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY);
    Parsable tmpData = listener.getParsedDataStack().peek();
    if (tmpData instanceof YangDesc) {
        YangDesc description = (YangDesc) tmpData;
        description.setDescription(ctx.string().getText());
    } else {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.DESCRIPTION_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY));
    }
}
#end_block

#method_before
public static void processListEntry(TreeWalkListener listener, GeneratedYangParser.ListStatementContext ctx) {
    YangNode curNode;
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.LIST_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY)) {
        return;
    }
    boolean result = validateSubStatementsCardinality(listener, ctx);
    if (!result) {
        return;
    }
    YangList yangList = new YangList(YangNodeType.LIST_NODE);
    yangList.setName(ctx.IDENTIFIER().getText());
    Parsable curData = listener.getParsedDataStack().peek();
    if (curData instanceof YangNode) {
        curNode = (YangNode) curData;
        try {
            curNode.addChild(yangList);
        } catch (DataModelException e) {
            listener.getErrorInformation().setErrorFlag(true);
            listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerAddChildErrorMsg(ListenerErrorType.INVALID_HOLDER, ParsableDataType.LIST_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY, e.getMessage()));
            return;
        }
        listener.getParsedDataStack().push(yangList);
    } else {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_HOLDER, ParsableDataType.LIST_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY));
    }
}
#method_after
public static void processListEntry(TreeWalkListener listener, GeneratedYangParser.ListStatementContext ctx) {
    YangNode curNode;
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.LIST_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY);
    boolean result = validateSubStatementsCardinality(ctx);
    if (!result) {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_CARDINALITY, yangConstruct, "", ListenerErrorLocation.ENTRY));
    }
    YangList yangList = new YangList(YangNodeType.LIST_NODE);
    yangList.setName(ctx.IDENTIFIER().getText());
    Parsable curData = listener.getParsedDataStack().peek();
    if (curData instanceof YangNode) {
        curNode = (YangNode) curData;
        try {
            curNode.addChild(yangList);
        } catch (DataModelException e) {
            throw new ParserException(ListenerErrorMessageConstruction.constructExtendedListenerErrorMessage(ListenerErrorType.UNHANDLED_PARSED_DATA, ParsableDataType.LIST_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(yangList);
    } else {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.LIST_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY));
    }
}
#end_block

#method_before
public static void processListExit(TreeWalkListener listener, GeneratedYangParser.ListStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.LIST_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT)) {
        return;
    }
    if (listener.getParsedDataStack().peek() instanceof YangList) {
        listener.getParsedDataStack().pop();
    } else {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_HOLDER, ParsableDataType.LIST_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
    }
}
#method_after
public static void processListExit(TreeWalkListener listener, GeneratedYangParser.ListStatementContext ctx) {
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.LIST_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT);
    if (listener.getParsedDataStack().peek() instanceof YangList) {
        listener.getParsedDataStack().pop();
    } else {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.LIST_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
    }
}
#end_block

#method_before
public static boolean validateSubStatementsCardinality(TreeWalkListener listener, GeneratedYangParser.ListStatementContext ctx) {
    if ((!ctx.keyStatement().isEmpty()) && (ctx.keyStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.KEY_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.configStatement().isEmpty()) && (ctx.configStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.CONFIG_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.maxElementsStatement().isEmpty()) && (ctx.maxElementsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.MAX_ELEMENT_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.minElementsStatement().isEmpty()) && (ctx.minElementsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.MIN_ELEMENT_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.descriptionStatement().isEmpty()) && (ctx.descriptionStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.DESCRIPTION_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.referenceStatement().isEmpty()) && (ctx.referenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.REFERENCE_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.statusStatement().isEmpty()) && (ctx.statusStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.STATUS_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if (ctx.dataDefStatement().isEmpty()) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.LIST_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    return true;
}
#method_after
public static boolean validateSubStatementsCardinality(GeneratedYangParser.ListStatementContext ctx) {
    if ((!ctx.keyStatement().isEmpty()) && (ctx.keyStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.KEY_DATA;
        return false;
    }
    if ((!ctx.configStatement().isEmpty()) && (ctx.configStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.CONFIG_DATA;
        return false;
    }
    if ((!ctx.maxElementsStatement().isEmpty()) && (ctx.maxElementsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.MAX_ELEMENT_DATA;
        return false;
    }
    if ((!ctx.minElementsStatement().isEmpty()) && (ctx.minElementsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.MIN_ELEMENT_DATA;
        return false;
    }
    if ((!ctx.descriptionStatement().isEmpty()) && (ctx.descriptionStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.DESCRIPTION_DATA;
        return false;
    }
    if ((!ctx.referenceStatement().isEmpty()) && (ctx.referenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.REFERENCE_DATA;
        return false;
    }
    if ((!ctx.statusStatement().isEmpty()) && (ctx.statusStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.STATUS_DATA;
        return false;
    }
    if (ctx.dataDefStatement().isEmpty()) {
        yangConstruct = ParsableDataType.LIST_DATA;
        return false;
    }
    return true;
}
#end_block

#method_before
public static void processUnitsEntry(TreeWalkListener listener, GeneratedYangParser.UnitsStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.UNITS_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY)) {
        return;
    }
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getParsableDataType()) {
        case LEAF_DATA:
            YangLeaf leaf = (YangLeaf) tmpData;
            leaf.setUnits(ctx.string().getText());
            break;
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setUnits(ctx.string().getText());
            break;
        case TYPEDEF_DATA:
            // TODO
            break;
        default:
            listener.getErrorInformation().setErrorFlag(true);
            listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_HOLDER, ParsableDataType.UNITS_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY));
            break;
    }
}
#method_after
public static void processUnitsEntry(TreeWalkListener listener, GeneratedYangParser.UnitsStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.UNITS_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY);
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getParsableDataType()) {
        case LEAF_DATA:
            YangLeaf leaf = (YangLeaf) tmpData;
            leaf.setUnits(ctx.string().getText());
            break;
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setUnits(ctx.string().getText());
            break;
        case TYPEDEF_DATA:
            // TODO
            break;
        default:
            throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.UNITS_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY));
    }
}
#end_block

#method_before
public static void processStatusEntry(TreeWalkListener listener, GeneratedYangParser.StatusStatementContext ctx) {
    YangStatusType status;
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.STATUS_DATA, "", ListenerErrorLocation.ENTRY)) {
        return;
    }
    if (ctx.CURRENT_KEYWORD() != null) {
        status = YangStatusType.CURRENT.CURRENT;
    } else if (ctx.DEPRECATED_KEYWORD() != null) {
        status = YangStatusType.DEPRECATED;
    } else {
        status = YangStatusType.OBSOLETE.OBSOLETE;
    }
    Parsable tmpData = listener.getParsedDataStack().peek();
    if (tmpData instanceof YangStatus) {
        YangStatus yangStatus = (YangStatus) tmpData;
        yangStatus.setStatus(status);
    } else {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_HOLDER, ParsableDataType.STATUS_DATA, "", ListenerErrorLocation.ENTRY));
    }
}
#method_after
public static void processStatusEntry(TreeWalkListener listener, GeneratedYangParser.StatusStatementContext ctx) {
    YangStatusType status;
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.STATUS_DATA, "", ListenerErrorLocation.ENTRY);
    if (ctx.CURRENT_KEYWORD() != null) {
        status = YangStatusType.CURRENT.CURRENT;
    } else if (ctx.DEPRECATED_KEYWORD() != null) {
        status = YangStatusType.DEPRECATED;
    } else {
        status = YangStatusType.OBSOLETE.OBSOLETE;
    }
    Parsable tmpData = listener.getParsedDataStack().peek();
    if (tmpData instanceof YangStatus) {
        YangStatus yangStatus = (YangStatus) tmpData;
        yangStatus.setStatus(status);
    } else {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.STATUS_DATA, "", ListenerErrorLocation.ENTRY));
    }
}
#end_block

#method_before
public static void processLeafEntry(TreeWalkListener listener, GeneratedYangParser.LeafStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.LEAF_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY)) {
        return;
    }
    boolean result = validateSubStatementsCardinality(listener, ctx);
    if (!result) {
        return;
    }
    YangLeaf leaf = new YangLeaf();
    leaf.setLeafName(ctx.IDENTIFIER().getText());
    Parsable tmpData = listener.getParsedDataStack().peek();
    YangLeavesHolder leaves;
    if (tmpData instanceof YangLeavesHolder) {
        leaves = (YangLeavesHolder) tmpData;
        leaves.addLeaf(leaf);
    } else {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_HOLDER, ParsableDataType.LEAF_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY));
        return;
    }
    listener.getParsedDataStack().push(leaf);
}
#method_after
public static void processLeafEntry(TreeWalkListener listener, GeneratedYangParser.LeafStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.LEAF_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY);
    boolean result = validateSubStatementsCardinality(ctx);
    if (!result) {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_CARDINALITY, yangConstruct, "", ListenerErrorLocation.ENTRY));
    }
    YangLeaf leaf = new YangLeaf();
    leaf.setLeafName(ctx.IDENTIFIER().getText());
    Parsable tmpData = listener.getParsedDataStack().peek();
    YangLeavesHolder leaves;
    if (tmpData instanceof YangLeavesHolder) {
        leaves = (YangLeavesHolder) tmpData;
        leaves.addLeaf(leaf);
    } else {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.LEAF_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY));
    }
    listener.getParsedDataStack().push(leaf);
}
#end_block

#method_before
public static void processLeafExit(TreeWalkListener listener, GeneratedYangParser.LeafStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.LEAF_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT)) {
        return;
    }
    if (listener.getParsedDataStack().peek() instanceof YangLeaf) {
        listener.getParsedDataStack().pop();
    } else {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_HOLDER, ParsableDataType.LEAF_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
    }
}
#method_after
public static void processLeafExit(TreeWalkListener listener, GeneratedYangParser.LeafStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.LEAF_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT);
    if (listener.getParsedDataStack().peek() instanceof YangLeaf) {
        listener.getParsedDataStack().pop();
    } else {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.LEAF_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
    }
}
#end_block

#method_before
public static boolean validateSubStatementsCardinality(TreeWalkListener listener, GeneratedYangParser.LeafStatementContext ctx) {
    if (ctx.typeStatement().isEmpty()) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.PRESENCE_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if (ctx.typeStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.TYPE_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.unitsStatement().isEmpty()) && (ctx.unitsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.UNITS_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.configStatement().isEmpty()) && (ctx.configStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.CONFIG_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.mandatoryStatement().isEmpty()) && (ctx.mandatoryStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.MANDATORY_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.descriptionStatement().isEmpty()) && (ctx.descriptionStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.DESCRIPTION_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.referenceStatement().isEmpty()) && (ctx.referenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.REFERENCE_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.statusStatement().isEmpty()) && (ctx.statusStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.STATUS_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    return true;
}
#method_after
public static boolean validateSubStatementsCardinality(GeneratedYangParser.LeafStatementContext ctx) {
    if (ctx.typeStatement().isEmpty() || (ctx.typeStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.TYPE_DATA;
        return false;
    }
    if ((!ctx.unitsStatement().isEmpty()) && (ctx.unitsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.UNITS_DATA;
        return false;
    }
    if ((!ctx.configStatement().isEmpty()) && (ctx.configStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.CONFIG_DATA;
        return false;
    }
    if ((!ctx.mandatoryStatement().isEmpty()) && (ctx.mandatoryStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.MANDATORY_DATA;
        return false;
    }
    if ((!ctx.descriptionStatement().isEmpty()) && (ctx.descriptionStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.DESCRIPTION_DATA;
        return false;
    }
    if ((!ctx.referenceStatement().isEmpty()) && (ctx.referenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.REFERENCE_DATA;
        return false;
    }
    if ((!ctx.statusStatement().isEmpty()) && (ctx.statusStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.STATUS_DATA;
        return false;
    }
    return true;
}
#end_block

#method_before
public static void processReferenceEntry(TreeWalkListener listener, GeneratedYangParser.ReferenceStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.REFERENCE_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY)) {
        return;
    }
    Parsable tmpData = listener.getParsedDataStack().peek();
    if (tmpData instanceof YangReference) {
        YangReference reference = (YangReference) tmpData;
        reference.setReference(ctx.string().getText());
    } else {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_HOLDER, ParsableDataType.REFERENCE_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY));
    }
}
#method_after
public static void processReferenceEntry(TreeWalkListener listener, GeneratedYangParser.ReferenceStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.REFERENCE_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY);
    Parsable tmpData = listener.getParsedDataStack().peek();
    if (tmpData instanceof YangReference) {
        YangReference reference = (YangReference) tmpData;
        reference.setReference(ctx.string().getText());
    } else {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.REFERENCE_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY));
    }
}
#end_block

#method_before
public static void processLeafListEntry(TreeWalkListener listener, GeneratedYangParser.LeafListStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.LEAF_LIST_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY)) {
        return;
    }
    boolean result = validateSubStatementsCardinality(listener, ctx);
    if (!result) {
        return;
    }
    YangLeafList leafList = new YangLeafList();
    leafList.setLeafName(ctx.IDENTIFIER().getText());
    Parsable tmpData = listener.getParsedDataStack().peek();
    YangLeavesHolder leaves;
    if (tmpData instanceof YangLeavesHolder) {
        leaves = (YangLeavesHolder) tmpData;
        leaves.addLeafList(leafList);
    } else {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_HOLDER, ParsableDataType.LEAF_LIST_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY));
        return;
    }
    listener.getParsedDataStack().push(leafList);
}
#method_after
public static void processLeafListEntry(TreeWalkListener listener, GeneratedYangParser.LeafListStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.LEAF_LIST_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY);
    boolean result = validateSubStatementsCardinality(ctx);
    if (!result) {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_CARDINALITY, yangConstruct, "", ListenerErrorLocation.ENTRY));
    }
    YangLeafList leafList = new YangLeafList();
    leafList.setLeafName(ctx.IDENTIFIER().getText());
    Parsable tmpData = listener.getParsedDataStack().peek();
    YangLeavesHolder leaves;
    if (tmpData instanceof YangLeavesHolder) {
        leaves = (YangLeavesHolder) tmpData;
        leaves.addLeafList(leafList);
    } else {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.LEAF_LIST_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY));
    }
    listener.getParsedDataStack().push(leafList);
}
#end_block

#method_before
public static void processLeafListExit(TreeWalkListener listener, GeneratedYangParser.LeafListStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.LEAF_LIST_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT)) {
        return;
    }
    if (listener.getParsedDataStack().peek() instanceof YangLeafList) {
        listener.getParsedDataStack().pop();
    } else {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_HOLDER, ParsableDataType.LEAF_LIST_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
    }
}
#method_after
public static void processLeafListExit(TreeWalkListener listener, GeneratedYangParser.LeafListStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.LEAF_LIST_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT);
    if (listener.getParsedDataStack().peek() instanceof YangLeafList) {
        listener.getParsedDataStack().pop();
    } else {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.LEAF_LIST_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
    }
}
#end_block

#method_before
public static boolean validateSubStatementsCardinality(TreeWalkListener listener, GeneratedYangParser.LeafListStatementContext ctx) {
    if (ctx.typeStatement().isEmpty()) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.TYPE_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if (ctx.typeStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.TYPE_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.unitsStatement().isEmpty()) && (ctx.unitsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.UNITS_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.configStatement().isEmpty()) && (ctx.configStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.CONFIG_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.maxElementsStatement().isEmpty()) && (ctx.maxElementsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.MAX_ELEMENT_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.minElementsStatement().isEmpty()) && (ctx.minElementsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.MIN_ELEMENT_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.descriptionStatement().isEmpty()) && (ctx.descriptionStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.DESCRIPTION_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.referenceStatement().isEmpty()) && (ctx.referenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.REFERENCE_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.statusStatement().isEmpty()) && (ctx.statusStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.STATUS_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    return true;
}
#method_after
public static boolean validateSubStatementsCardinality(GeneratedYangParser.LeafListStatementContext ctx) {
    if (ctx.typeStatement().isEmpty() || (ctx.typeStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.TYPE_DATA;
        return false;
    }
    if ((!ctx.unitsStatement().isEmpty()) && (ctx.unitsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.UNITS_DATA;
        return false;
    }
    if ((!ctx.configStatement().isEmpty()) && (ctx.configStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.CONFIG_DATA;
        return false;
    }
    if ((!ctx.maxElementsStatement().isEmpty()) && (ctx.maxElementsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.MAX_ELEMENT_DATA;
        return false;
    }
    if ((!ctx.minElementsStatement().isEmpty()) && (ctx.minElementsStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.MIN_ELEMENT_DATA;
        return false;
    }
    if ((!ctx.descriptionStatement().isEmpty()) && (ctx.descriptionStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.DESCRIPTION_DATA;
        return false;
    }
    if ((!ctx.referenceStatement().isEmpty()) && (ctx.referenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.REFERENCE_DATA;
        return false;
    }
    if ((!ctx.statusStatement().isEmpty()) && (ctx.statusStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.STATUS_DATA;
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public YangNode getDataModel(String yangFile) throws IOException, ParserException {
    /**
     * Create a char stream that reads from YANG file. Throws an exception
     * in case input YANG file is either null or non existent.
     */
    ANTLRInputStream input = null;
    try {
        input = new ANTLRFileStream(yangFile);
    } catch (IOException e) {
        e.printStackTrace();
        throw e;
    }
    // Create a lexer that feeds off of input char stream.
    GeneratedYangLexer lexer = new GeneratedYangLexer(input);
    // Create a buffer of tokens pulled from the lexer.
    CommonTokenStream tokens = new CommonTokenStream(lexer);
    // Create a parser that feeds off the tokens buffer.
    GeneratedYangParser parser = new GeneratedYangParser(tokens);
    // Remove console error listener.
    parser.removeErrorListeners();
    // Create instance of customized error listener.
    ParseTreeErrorListener parseTreeErrorListener = new ParseTreeErrorListener();
    // Add customized error listener to catch errors during parsing.
    parser.addErrorListener(parseTreeErrorListener);
    // Begin parsing YANG file and generate parse tree.
    ParseTree tree = parser.yangfile();
    /**
     * Throws an parser Exception if exception flag is set i.e. exception has
     * occurred during parsing.
     */
    if (parseTreeErrorListener.isExceptionFlag()) {
        // Get the exception occurred during parsing.
        ParserException parserException = parseTreeErrorListener.getParserException();
        parserException.setFileName(yangFile);
        throw parserException;
    }
    // Create a walker to walk the parse tree.
    ParseTreeWalker walker = new ParseTreeWalker();
    // Create a listener implementation class object.
    TreeWalkListener treeWalker = new TreeWalkListener();
    /**
     * Walk parse tree, provide call backs to methods in listener and
     * build data model tree.
     */
    walker.walk(treeWalker, tree);
    // Throws an parser exception which has occurred during listener walk.
    if (treeWalker.getErrorInformation().isErrorFlag()) {
        // Create object of listener exception
        ParserException listenerException = new ParserException();
        listenerException.setMsg(treeWalker.getErrorInformation().getErrorMsg());
        listenerException.setFileName(yangFile);
        throw listenerException;
    }
    // Returns the Root Node of the constructed data model tree.
    return treeWalker.getRootNode();
}
#method_after
@Override
public YangNode getDataModel(String yangFile) throws IOException, ParserException {
    /**
     * Create a char stream that reads from YANG file. Throws an exception
     * in case input YANG file is either null or non existent.
     */
    ANTLRInputStream input = null;
    try {
        input = new ANTLRFileStream(yangFile);
    } catch (IOException e) {
        e.printStackTrace();
        throw e;
    }
    // Create a lexer that feeds off of input char stream.
    GeneratedYangLexer lexer = new GeneratedYangLexer(input);
    // Create a buffer of tokens pulled from the lexer.
    CommonTokenStream tokens = new CommonTokenStream(lexer);
    // Create a parser that feeds off the tokens buffer.
    GeneratedYangParser parser = new GeneratedYangParser(tokens);
    // Remove console error listener.
    parser.removeErrorListeners();
    // Create instance of customized error listener.
    ParseTreeErrorListener parseTreeErrorListener = new ParseTreeErrorListener();
    // Add customized error listener to catch errors during parsing.
    parser.addErrorListener(parseTreeErrorListener);
    ParseTree tree;
    try {
        // Begin parsing YANG file and generate parse tree.
        tree = parser.yangfile();
    } catch (ParserException parserException) {
        parserException.setFileName(yangFile);
        throw parserException;
    }
    // Create a walker to walk the parse tree.
    ParseTreeWalker walker = new ParseTreeWalker();
    // Create a listener implementation class object.
    TreeWalkListener treeWalker = new TreeWalkListener();
    /**
     * Walk parse tree, provide call backs to methods in listener and
     * build data model tree.
     */
    try {
        walker.walk(treeWalker, tree);
    } catch (ParserException listenerException) {
        // TODO free incomplete data model tree.
        listenerException.setFileName(yangFile);
        throw listenerException;
    } finally {
    // TODO free parsable stack
    }
    // Returns the Root Node of the constructed data model tree.
    return treeWalker.getRootNode();
}
#end_block

#method_before
public static void processKeyEntry(TreeWalkListener listener, GeneratedYangParser.KeyStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.KEY_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY)) {
        return;
    }
    Parsable tmpData = listener.getParsedDataStack().peek();
    if (listener.getParsedDataStack().peek() instanceof YangList) {
        YangList yangList = (YangList) tmpData;
        String tmpKeyValue = ctx.string().getText().replace("\"", "");
        if (tmpKeyValue.contains(" ")) {
            String[] keyValues = tmpKeyValue.split(" ");
            for (String keyValue : keyValues) {
                yangList.addKey(keyValue);
            }
        } else {
            yangList.addKey(tmpKeyValue);
        }
    } else {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_HOLDER, ParsableDataType.KEY_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY));
    }
}
#method_after
public static void processKeyEntry(TreeWalkListener listener, GeneratedYangParser.KeyStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.KEY_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY);
    Parsable tmpData = listener.getParsedDataStack().peek();
    if (listener.getParsedDataStack().peek() instanceof YangList) {
        YangList yangList = (YangList) tmpData;
        String tmpKeyValue = ctx.string().getText().replace("\"", "");
        if (tmpKeyValue.contains(" ")) {
            String[] keyValues = tmpKeyValue.split(" ");
            for (String keyValue : keyValues) {
                yangList.addKey(keyValue);
            }
        } else {
            yangList.addKey(tmpKeyValue);
        }
    } else {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.KEY_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY));
    }
}
#end_block

#method_before
public static void processMinElementsEntry(TreeWalkListener listener, GeneratedYangParser.MinElementsStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.MIN_ELEMENT_DATA, "", ListenerErrorLocation.ENTRY)) {
        return;
    }
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getParsableDataType()) {
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setMinElements(Integer.parseInt(ctx.INTEGER().getText()));
            break;
        case LIST_DATA:
            YangList yangList = (YangList) tmpData;
            yangList.setMinElements(Integer.parseInt(ctx.INTEGER().getText()));
            break;
        default:
            listener.getErrorInformation().setErrorFlag(true);
            listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_HOLDER, ParsableDataType.MIN_ELEMENT_DATA, "", ListenerErrorLocation.ENTRY));
            break;
    }
}
#method_after
public static void processMinElementsEntry(TreeWalkListener listener, GeneratedYangParser.MinElementsStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.MIN_ELEMENT_DATA, String.valueOf(ctx.INTEGER().getText()), ListenerErrorLocation.ENTRY);
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getParsableDataType()) {
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setMinElements(Integer.parseInt(ctx.INTEGER().getText()));
            break;
        case LIST_DATA:
            YangList yangList = (YangList) tmpData;
            yangList.setMinElements(Integer.parseInt(ctx.INTEGER().getText()));
            break;
        default:
            throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.MIN_ELEMENT_DATA, String.valueOf(ctx.INTEGER().getText()), ListenerErrorLocation.ENTRY));
    }
}
#end_block

#method_before
public static void processPresenceEntry(TreeWalkListener listener, GeneratedYangParser.PresenceStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.PRESENCE_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY)) {
        return;
    }
    Parsable tmpData = listener.getParsedDataStack().peek();
    if (tmpData.getParsableDataType() == ParsableDataType.CONTAINER_DATA) {
        YangContainer container = (YangContainer) tmpData;
        container.setPresence(ctx.string().getText());
    } else {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_HOLDER, ParsableDataType.PRESENCE_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY));
    }
}
#method_after
public static void processPresenceEntry(TreeWalkListener listener, GeneratedYangParser.PresenceStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.PRESENCE_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY);
    Parsable tmpData = listener.getParsedDataStack().peek();
    if (tmpData.getParsableDataType() == ParsableDataType.CONTAINER_DATA) {
        YangContainer container = (YangContainer) tmpData;
        container.setPresence(ctx.string().getText());
    } else {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.PRESENCE_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY));
    }
}
#end_block

#method_before
public static void processContainerEntry(TreeWalkListener listener, GeneratedYangParser.ContainerStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.CONTAINER_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY)) {
        return;
    }
    boolean result = validateSubStatementsCardinality(listener, ctx);
    if (!result) {
        return;
    }
    YangContainer container = new YangContainer();
    container.setName(ctx.IDENTIFIER().getText());
    Parsable curData = listener.getParsedDataStack().peek();
    if (curData instanceof YangNode) {
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(container);
        } catch (DataModelException e) {
            listener.getErrorInformation().setErrorFlag(true);
            listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerAddChildErrorMsg(ListenerErrorType.INVALID_HOLDER, ParsableDataType.CONTAINER_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY, e.getMessage()));
            return;
        }
        listener.getParsedDataStack().push(container);
    } else {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_HOLDER, ParsableDataType.CONTAINER_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY));
    }
}
#method_after
public static void processContainerEntry(TreeWalkListener listener, GeneratedYangParser.ContainerStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.CONTAINER_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY);
    boolean result = validateSubStatementsCardinality(ctx);
    if (!result) {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_CARDINALITY, yangConstruct, "", ListenerErrorLocation.ENTRY));
    }
    YangContainer container = new YangContainer();
    container.setName(ctx.IDENTIFIER().getText());
    Parsable curData = listener.getParsedDataStack().peek();
    if (curData instanceof YangNode) {
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(container);
        } catch (DataModelException e) {
            throw new ParserException(ListenerErrorMessageConstruction.constructExtendedListenerErrorMessage(ListenerErrorType.UNHANDLED_PARSED_DATA, ParsableDataType.CONTAINER_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(container);
    } else {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.CONTAINER_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY));
    }
}
#end_block

#method_before
public static void processContainerExit(TreeWalkListener listener, GeneratedYangParser.ContainerStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.CONTAINER_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT)) {
        return;
    }
    if (listener.getParsedDataStack().peek() instanceof YangContainer) {
        listener.getParsedDataStack().pop();
    } else {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_HOLDER, ParsableDataType.CONTAINER_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
    }
}
#method_after
public static void processContainerExit(TreeWalkListener listener, GeneratedYangParser.ContainerStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.CONTAINER_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT);
    if (listener.getParsedDataStack().peek() instanceof YangContainer) {
        listener.getParsedDataStack().pop();
    } else {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.CONTAINER_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
    }
}
#end_block

#method_before
public static boolean validateSubStatementsCardinality(TreeWalkListener listener, GeneratedYangParser.ContainerStatementContext ctx) {
    if ((!ctx.presenceStatement().isEmpty()) && (ctx.presenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.PRESENCE_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.configStatement().isEmpty()) && (ctx.configStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.CONFIG_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.descriptionStatement().isEmpty()) && (ctx.descriptionStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.DESCRIPTION_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.referenceStatement().isEmpty()) && (ctx.referenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.REFERENCE_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    if ((!ctx.statusStatement().isEmpty()) && (ctx.statusStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_CARDINALITY, ParsableDataType.STATUS_DATA, "", ListenerErrorLocation.ENTRY));
        return false;
    }
    return true;
}
#method_after
public static boolean validateSubStatementsCardinality(GeneratedYangParser.ContainerStatementContext ctx) {
    if ((!ctx.presenceStatement().isEmpty()) && (ctx.presenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.PRESENCE_DATA;
        return false;
    }
    if ((!ctx.configStatement().isEmpty()) && (ctx.configStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.CONFIG_DATA;
        return false;
    }
    if ((!ctx.descriptionStatement().isEmpty()) && (ctx.descriptionStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.DESCRIPTION_DATA;
        return false;
    }
    if ((!ctx.referenceStatement().isEmpty()) && (ctx.referenceStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.REFERENCE_DATA;
        return false;
    }
    if ((!ctx.statusStatement().isEmpty()) && (ctx.statusStatement().size() != YangUtilsParserManager.SUB_STATEMENT_CARDINALITY)) {
        yangConstruct = ParsableDataType.STATUS_DATA;
        return false;
    }
    return true;
}
#end_block

#method_before
public static void processMandatoryEntry(TreeWalkListener listener, GeneratedYangParser.MandatoryStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.MANDATORY_DATA, "", ListenerErrorLocation.ENTRY)) {
        return;
    }
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case LEAF_DATA:
            YangLeaf leaf = (YangLeaf) tmpNode;
            if (ctx.TRUE_KEYWORD() != null) {
                leaf.setMandatory(true);
            } else {
                leaf.setMandatory(false);
            }
            break;
        case // TODO
        CHOICE_DATA:
            break;
        default:
            listener.getErrorInformation().setErrorFlag(true);
            listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_HOLDER, ParsableDataType.MANDATORY_DATA, "", ListenerErrorLocation.ENTRY));
            break;
    }
}
#method_after
public static void processMandatoryEntry(TreeWalkListener listener, GeneratedYangParser.MandatoryStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.MANDATORY_DATA, "", ListenerErrorLocation.ENTRY);
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case LEAF_DATA:
            YangLeaf leaf = (YangLeaf) tmpNode;
            if (ctx.TRUE_KEYWORD() != null) {
                leaf.setMandatory(true);
            } else {
                leaf.setMandatory(false);
            }
            break;
        case // TODO
        CHOICE_DATA:
            break;
        default:
            throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.MANDATORY_DATA, "", ListenerErrorLocation.ENTRY));
    }
}
#end_block

#method_before
public static void processMaxElementsEntry(TreeWalkListener listener, GeneratedYangParser.MaxElementsStatementContext ctx) {
    int maxElementsValue;
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.MAX_ELEMENT_DATA, "", ListenerErrorLocation.ENTRY)) {
        return;
    }
    if (ctx.maxValueArgument().UNBOUNDED_KEYWORD() != null) {
        maxElementsValue = YangUtilsParserManager.MAX_INT_VALUE;
    } else {
        maxElementsValue = Integer.parseInt(ctx.maxValueArgument().INTEGER().getText());
    }
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getParsableDataType()) {
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setMaxElelements(maxElementsValue);
            break;
        case LIST_DATA:
            YangList yangList = (YangList) tmpData;
            yangList.setMaxElelements(maxElementsValue);
            break;
        default:
            listener.getErrorInformation().setErrorFlag(true);
            listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_HOLDER, ParsableDataType.MAX_ELEMENT_DATA, "", ListenerErrorLocation.ENTRY));
            break;
    }
}
#method_after
public static void processMaxElementsEntry(TreeWalkListener listener, GeneratedYangParser.MaxElementsStatementContext ctx) {
    int maxElementsValue;
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.MAX_ELEMENT_DATA, "", ListenerErrorLocation.ENTRY);
    if (ctx.maxValueArgument().UNBOUNDED_KEYWORD() != null) {
        maxElementsValue = Integer.MAX_VALUE;
    } else {
        maxElementsValue = Integer.parseInt(ctx.maxValueArgument().INTEGER().getText());
    }
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getParsableDataType()) {
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setMaxElelements(maxElementsValue);
            break;
        case LIST_DATA:
            YangList yangList = (YangList) tmpData;
            yangList.setMaxElelements(maxElementsValue);
            break;
        default:
            throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.MAX_ELEMENT_DATA, "", ListenerErrorLocation.ENTRY));
    }
}
#end_block

#method_before
public static void processTypeEntry(TreeWalkListener listener, GeneratedYangParser.TypeStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.TYPE_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY)) {
        return;
    }
    YangType type = new YangType();
    YangDataTypes yangDataTypes = YangDataTypes.getType(ctx.string().getText());
    type.setDataTypeName(ctx.string().getText());
    type.setDataType(yangDataTypes);
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getParsableDataType()) {
        case LEAF_DATA:
            YangLeaf leaf = (YangLeaf) tmpData;
            leaf.setDataType(type);
            break;
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setDataType(type);
            break;
        case // TODO
        TYPEDEF_DATA:
            break;
        default:
            listener.getErrorInformation().setErrorFlag(true);
            listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_HOLDER, ParsableDataType.TYPE_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY));
            break;
    }
}
#method_after
public static void processTypeEntry(TreeWalkListener listener, GeneratedYangParser.TypeStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.TYPE_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY);
    YangType type = new YangType();
    YangDataTypes yangDataTypes = YangDataTypes.getType(ctx.string().getText());
    type.setDataTypeName(ctx.string().getText());
    type.setDataType(yangDataTypes);
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getParsableDataType()) {
        case LEAF_DATA:
            YangLeaf leaf = (YangLeaf) tmpData;
            leaf.setDataType(type);
            break;
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setDataType(type);
            break;
        case // TODO
        TYPEDEF_DATA:
            break;
        default:
            throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.TYPE_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY));
    }
}
#end_block

#method_before
public static void processConfigEntry(TreeWalkListener listener, GeneratedYangParser.ConfigStatementContext ctx) {
    boolean isConfig = false;
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.CONFIG_DATA, "", ListenerErrorLocation.ENTRY)) {
        return;
    }
    if (ctx.TRUE_KEYWORD() != null) {
        isConfig = true;
    }
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getParsableDataType()) {
        case LEAF_DATA:
            YangLeaf leaf = (YangLeaf) tmpData;
            leaf.setConfig(isConfig);
            break;
        case CONTAINER_DATA:
            YangContainer container = (YangContainer) tmpData;
            container.setConfig(isConfig);
            break;
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setConfig(isConfig);
            break;
        case LIST_DATA:
            YangList yangList = (YangList) tmpData;
            yangList.setConfig(isConfig);
            break;
        case // TODO
        CHOICE_DATA:
            break;
        default:
            listener.getErrorInformation().setErrorFlag(true);
            listener.getErrorInformation().setErrorMsg(ListenerErrorMessageConstruction.constructListenerErrorMsg(ListenerErrorType.INVALID_HOLDER, ParsableDataType.CONFIG_DATA, "", ListenerErrorLocation.ENTRY));
            break;
    }
}
#method_after
public static void processConfigEntry(TreeWalkListener listener, GeneratedYangParser.ConfigStatementContext ctx) {
    boolean isConfig = false;
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.CONFIG_DATA, "", ListenerErrorLocation.ENTRY);
    if (ctx.TRUE_KEYWORD() != null) {
        isConfig = true;
    }
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getParsableDataType()) {
        case LEAF_DATA:
            YangLeaf leaf = (YangLeaf) tmpData;
            leaf.setConfig(isConfig);
            break;
        case CONTAINER_DATA:
            YangContainer container = (YangContainer) tmpData;
            container.setConfig(isConfig);
            break;
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setConfig(isConfig);
            break;
        case LIST_DATA:
            YangList yangList = (YangList) tmpData;
            yangList.setConfig(isConfig);
            break;
        case // TODO
        CHOICE_DATA:
            break;
        default:
            throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.CONFIG_DATA, "", ListenerErrorLocation.ENTRY));
    }
}
#end_block

#method_before
public static void processNamespaceEntry(TreeWalkListener listener, GeneratedYangParser.NamespaceStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, "namespace")) {
        return;
    }
    if (!validateUriValue(String.valueOf(ctx.string().getText()))) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg("Value of namespace is not correct");
        return;
    }
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                YangNameSpace uri = new YangNameSpace();
                uri.setUri(String.valueOf(ctx.string().getText()));
                module.setNameSpace(uri);
                break;
            }
        default:
            listener.getErrorInformation().setErrorFlag(true);
            listener.getErrorInformation().setErrorMsg("Namespace associated with YANG construct other" + "than module");
            break;
    }
}
#method_after
public static void processNamespaceEntry(TreeWalkListener listener, GeneratedYangParser.NamespaceStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.NAMESPACE_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY);
    if (!validateUriValue(String.valueOf(ctx.string().getText()))) {
        ParserException parserException = new ParserException("Invalid namespace URI");
        parserException.setLine(ctx.string().STRING(0).getSymbol().getLine());
        parserException.setCharPosition(ctx.string().STRING(0).getSymbol().getCharPositionInLine());
        throw parserException;
    }
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                YangNameSpace uri = new YangNameSpace();
                uri.setUri(String.valueOf(ctx.string().getText()));
                module.setNameSpace(uri);
                break;
            }
        default:
            throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.NAMESPACE_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY));
    }
}
#end_block

#method_before
@Test(expected = ParserException.class)
public void processNamespaceNoEntryTest() throws IOException, ParserException {
    out.write("module Test {\n");
    out.write("prefix On;\n");
    out.write("}\n");
    out.close();
    YangNode node = manager.getDataModel("demo.yang");
}
#method_after
@Test(expected = ParserException.class)
public void processNamespaceNoEntryTest() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/NamespaceNoEntryTest.yang");
}
#end_block

#method_before
public static void processBelongsToEntry(TreeWalkListener listener, GeneratedYangParser.BelongstoStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, "belongsto")) {
        return;
    }
    YangBelongsTo belongstoNode = new YangBelongsTo();
    belongstoNode.setBelongsToModuleName(String.valueOf(ctx.IDENTIFIER().getText()));
    try {
        belongstoNode.validateDataOnEntry();
    } catch (DataModelException e) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(e.getMessage());
    }
    // Push belongsto into the stack.
    listener.getParsedDataStack().push(belongstoNode);
}
#method_after
public static void processBelongsToEntry(TreeWalkListener listener, GeneratedYangParser.BelongstoStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.BELONGS_TO_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY);
    YangBelongsTo belongstoNode = new YangBelongsTo();
    belongstoNode.setBelongsToModuleName(String.valueOf(ctx.IDENTIFIER().getText()));
    // Push belongsto into the stack.
    listener.getParsedDataStack().push(belongstoNode);
}
#end_block

#method_before
public static void processBelongsToExit(TreeWalkListener listener, GeneratedYangParser.BelongstoStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, "belongsto")) {
        return;
    }
    Parsable tmpBelongstoNode = listener.getParsedDataStack().peek();
    if (tmpBelongstoNode instanceof YangBelongsTo) {
        try {
            tmpBelongstoNode.validateDataOnExit();
        } catch (DataModelException e) {
            listener.getErrorInformation().setErrorFlag(true);
            listener.getErrorInformation().setErrorMsg(e.getMessage());
        }
        listener.getParsedDataStack().pop();
        Parsable tmpNode = listener.getParsedDataStack().peek();
        switch(tmpNode.getParsableDataType()) {
            case SUB_MODULE_DATA:
                {
                    YangSubModule subModule = (YangSubModule) tmpNode;
                    subModule.setBelongsTo((YangBelongsTo) tmpBelongstoNode);
                    break;
                }
            default:
                listener.getErrorInformation().setErrorFlag(true);
                listener.getErrorInformation().setErrorMsg("Belongsto associated with incorrect YANG construct");
                break;
        }
    }
}
#method_after
public static void processBelongsToExit(TreeWalkListener listener, GeneratedYangParser.BelongstoStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.BELONGS_TO_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT);
    Parsable tmpBelongstoNode = listener.getParsedDataStack().peek();
    if (tmpBelongstoNode instanceof YangBelongsTo) {
        listener.getParsedDataStack().pop();
        // Check for stack to be empty.
        ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.BELONGS_TO_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT);
        Parsable tmpNode = listener.getParsedDataStack().peek();
        switch(tmpNode.getParsableDataType()) {
            case SUB_MODULE_DATA:
                {
                    YangSubModule subModule = (YangSubModule) tmpNode;
                    subModule.setBelongsTo((YangBelongsTo) tmpBelongstoNode);
                    break;
                }
            default:
                throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.BELONGS_TO_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
        }
    } else {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.MISSING_CURRENT_HOLDER, ParsableDataType.BELONGS_TO_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
    }
}
#end_block

#method_before
public static void processImportEntry(TreeWalkListener listener, GeneratedYangParser.ImportStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, "import")) {
        return;
    }
    YangImport importNode = new YangImport();
    importNode.setModuleName(String.valueOf(ctx.IDENTIFIER().getText()));
    try {
        importNode.validateDataOnEntry();
    } catch (DataModelException e) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(e.getMessage());
    }
    // Push import node to the stack.
    listener.getParsedDataStack().push(importNode);
}
#method_after
public static void processImportEntry(TreeWalkListener listener, GeneratedYangParser.ImportStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.IMPORT_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY);
    YangImport importNode = new YangImport();
    importNode.setModuleName(String.valueOf(ctx.IDENTIFIER().getText()));
    // Push import node to the stack.
    listener.getParsedDataStack().push(importNode);
}
#end_block

#method_before
public static void processImportExit(TreeWalkListener listener, GeneratedYangParser.ImportStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, "belongsto")) {
        return;
    }
    Parsable tmpImportNode = listener.getParsedDataStack().peek();
    if (tmpImportNode instanceof YangImport) {
        try {
            tmpImportNode.validateDataOnExit();
        } catch (DataModelException e) {
            listener.getErrorInformation().setErrorFlag(true);
            listener.getErrorInformation().setErrorMsg(e.getMessage());
        }
        listener.getParsedDataStack().pop();
        Parsable tmpNode = listener.getParsedDataStack().peek();
        switch(tmpNode.getParsableDataType()) {
            case MODULE_DATA:
                {
                    YangModule module = (YangModule) tmpNode;
                    module.addImportedInfo((YangImport) tmpImportNode);
                    break;
                }
            case SUB_MODULE_DATA:
                {
                    YangSubModule subModule = (YangSubModule) tmpNode;
                    subModule.addImportedInfo((YangImport) tmpImportNode);
                    break;
                }
            default:
                listener.getErrorInformation().setErrorFlag(true);
                listener.getErrorInformation().setErrorMsg("Import associated with incorrect YANG construct");
                break;
        }
    }
}
#method_after
public static void processImportExit(TreeWalkListener listener, GeneratedYangParser.ImportStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.IMPORT_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT);
    Parsable tmpImportNode = listener.getParsedDataStack().peek();
    if (tmpImportNode instanceof YangImport) {
        listener.getParsedDataStack().pop();
        // Check for stack to be non empty.
        ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.IMPORT_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT);
        Parsable tmpNode = listener.getParsedDataStack().peek();
        switch(tmpNode.getParsableDataType()) {
            case MODULE_DATA:
                {
                    YangModule module = (YangModule) tmpNode;
                    module.addImportedInfo((YangImport) tmpImportNode);
                    break;
                }
            case SUB_MODULE_DATA:
                {
                    YangSubModule subModule = (YangSubModule) tmpNode;
                    subModule.addImportedInfo((YangImport) tmpImportNode);
                    break;
                }
            default:
                throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.IMPORT_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
        }
    } else {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.MISSING_CURRENT_HOLDER, ParsableDataType.IMPORT_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
    }
}
#end_block

#method_before
public static void processRevisionEntry(TreeWalkListener listener, GeneratedYangParser.RevisionStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, "revision")) {
        return;
    }
    // Validate for reverse chronological order of revision.
    if (!validateRevisionOrder(listener, ctx)) {
        return;
    }
    YangRevision revisionNode = new YangRevision();
    revisionNode.setRevDate(String.valueOf(ctx.DATE_ARG().getText()));
    try {
        revisionNode.validateDataOnEntry();
    } catch (DataModelException e) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(e.getMessage());
    }
    if (ctx.STMTEND() != null) {
        // Obtain the node of the stack.
        Parsable tmpNode = listener.getParsedDataStack().peek();
        switch(tmpNode.getParsableDataType()) {
            case MODULE_DATA:
                {
                    YangModule module = (YangModule) tmpNode;
                    module.setRevision(revisionNode);
                    break;
                }
            case SUB_MODULE_DATA:
                {
                    YangSubModule submodule = (YangSubModule) tmpNode;
                    submodule.setRevision(revisionNode);
                    break;
                }
            default:
                listener.getErrorInformation().setErrorFlag(true);
                listener.getErrorInformation().setErrorMsg("Revision associated with incorrect YANG construct");
                break;
        }
    } else {
        // Push revisionnode into the stack.
        listener.getParsedDataStack().push(revisionNode);
    }
}
#method_after
public static void processRevisionEntry(TreeWalkListener listener, GeneratedYangParser.RevisionStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.REVISION_DATA, String.valueOf(ctx.DATE_ARG().getText()), ListenerErrorLocation.ENTRY);
    // Validate for reverse chronological order of revision & for revision value.
    if (!validateRevision(listener, ctx)) {
        return;
    // TODO to be implemented.
    }
    YangRevision revisionNode = new YangRevision();
    revisionNode.setRevDate(String.valueOf(ctx.DATE_ARG().getText()));
    listener.getParsedDataStack().push(revisionNode);
}
#end_block

#method_before
public static void processRevisionExit(TreeWalkListener listener, GeneratedYangParser.RevisionStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, "belongsto")) {
        return;
    }
    Parsable tmpRevisionNode = listener.getParsedDataStack().peek();
    if (tmpRevisionNode instanceof YangRevision) {
        try {
            tmpRevisionNode.validateDataOnExit();
        } catch (DataModelException e) {
            listener.getErrorInformation().setErrorFlag(true);
            listener.getErrorInformation().setErrorMsg(e.getMessage());
        }
        listener.getParsedDataStack().pop();
        Parsable tmpNode = listener.getParsedDataStack().peek();
        switch(tmpNode.getParsableDataType()) {
            case MODULE_DATA:
                {
                    YangModule module = (YangModule) tmpNode;
                    module.setRevision((YangRevision) tmpRevisionNode);
                    break;
                }
            case SUB_MODULE_DATA:
                {
                    YangSubModule subModule = (YangSubModule) tmpNode;
                    subModule.setRevision((YangRevision) tmpRevisionNode);
                    break;
                }
            default:
                listener.getErrorInformation().setErrorFlag(true);
                listener.getErrorInformation().setErrorMsg("Revision associated with incorrect YANG construct");
                break;
        }
    }
}
#method_after
public static void processRevisionExit(TreeWalkListener listener, GeneratedYangParser.RevisionStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.REVISION_DATA, String.valueOf(ctx.DATE_ARG().getText()), ListenerErrorLocation.EXIT);
    Parsable tmpRevisionNode = listener.getParsedDataStack().peek();
    if (tmpRevisionNode instanceof YangRevision) {
        listener.getParsedDataStack().pop();
        // Check for stack to be non empty.
        ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.REVISION_DATA, String.valueOf(ctx.DATE_ARG().getText()), ListenerErrorLocation.EXIT);
        Parsable tmpNode = listener.getParsedDataStack().peek();
        switch(tmpNode.getParsableDataType()) {
            case MODULE_DATA:
                {
                    YangModule module = (YangModule) tmpNode;
                    module.setRevision((YangRevision) tmpRevisionNode);
                    break;
                }
            case SUB_MODULE_DATA:
                {
                    YangSubModule subModule = (YangSubModule) tmpNode;
                    subModule.setRevision((YangRevision) tmpRevisionNode);
                    break;
                }
            default:
                throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.REVISION_DATA, String.valueOf(ctx.DATE_ARG().getText()), ListenerErrorLocation.EXIT));
        }
    } else {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.MISSING_CURRENT_HOLDER, ParsableDataType.REVISION_DATA, String.valueOf(ctx.DATE_ARG().getText()), ListenerErrorLocation.EXIT));
    }
}
#end_block

#method_before
public static void processOrganizationEntry(TreeWalkListener listener, GeneratedYangParser.OrganizationStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, "organization")) {
        return;
    }
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                module.setOrganization(String.valueOf(ctx.string().getText()));
                break;
            }
        case SUB_MODULE_DATA:
            {
                YangSubModule subModule = (YangSubModule) tmpNode;
                subModule.setOrganization(String.valueOf(ctx.string().getText()));
                break;
            }
        default:
            listener.getErrorInformation().setErrorFlag(true);
            listener.getErrorInformation().setErrorMsg("Organization associated with invalid " + "YANG construct");
            break;
    }
}
#method_after
public static void processOrganizationEntry(TreeWalkListener listener, GeneratedYangParser.OrganizationStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.ORGANIZATION_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY);
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                module.setOrganization(String.valueOf(ctx.string().getText()));
                break;
            }
        case SUB_MODULE_DATA:
            {
                YangSubModule subModule = (YangSubModule) tmpNode;
                subModule.setOrganization(String.valueOf(ctx.string().getText()));
                break;
            }
        default:
            throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.ORGANIZATION_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY));
    }
}
#end_block

#method_before
public static void processContactEntry(TreeWalkListener listener, GeneratedYangParser.ContactStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, "contact")) {
        return;
    }
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                module.setContact(String.valueOf(ctx.string().getText()));
                break;
            }
        case SUB_MODULE_DATA:
            {
                YangSubModule subModule = (YangSubModule) tmpNode;
                subModule.setContact(String.valueOf(ctx.string().getText()));
                break;
            }
        default:
            listener.getErrorInformation().setErrorFlag(true);
            listener.getErrorInformation().setErrorMsg("Contact associated with invalid " + "YANG construct");
            break;
    }
}
#method_after
public static void processContactEntry(TreeWalkListener listener, GeneratedYangParser.ContactStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.CONTACT_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY);
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                module.setContact(String.valueOf(ctx.string().getText()));
                break;
            }
        case SUB_MODULE_DATA:
            {
                YangSubModule subModule = (YangSubModule) tmpNode;
                subModule.setContact(String.valueOf(ctx.string().getText()));
                break;
            }
        default:
            throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.CONTACT_DATA, String.valueOf(ctx.string().getText()), ListenerErrorLocation.ENTRY));
    }
}
#end_block

#method_before
public static void processRevisionDateEntry(TreeWalkListener listener, GeneratedYangParser.RevisionDateStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, "RevisionDate")) {
        return;
    }
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case IMPORT_DATA:
            {
                YangImport importNode = (YangImport) tmpNode;
                importNode.setRevision(String.valueOf(ctx.DATE_ARG().getText()));
                break;
            }
        case INCLUDE_DATA:
            {
                YangInclude includeNode = (YangInclude) tmpNode;
                includeNode.setRevision(String.valueOf(ctx.DATE_ARG().getText()));
                break;
            }
        default:
            listener.getErrorInformation().setErrorFlag(true);
            listener.getErrorInformation().setErrorMsg("Revision Date associated with incorrect YANG construct");
            break;
    }
}
#method_after
public static void processRevisionDateEntry(TreeWalkListener listener, GeneratedYangParser.RevisionDateStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.REVISION_DATE_DATA, String.valueOf(ctx.DATE_ARG().getText()), ListenerErrorLocation.ENTRY);
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case IMPORT_DATA:
            {
                YangImport importNode = (YangImport) tmpNode;
                importNode.setRevision(String.valueOf(ctx.DATE_ARG().getText()));
                break;
            }
        case INCLUDE_DATA:
            {
                YangInclude includeNode = (YangInclude) tmpNode;
                includeNode.setRevision(String.valueOf(ctx.DATE_ARG().getText()));
                break;
            }
        default:
            throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.REVISION_DATE_DATA, String.valueOf(ctx.DATE_ARG().getText()), ListenerErrorLocation.ENTRY));
    }
}
#end_block

#method_before
@Test
public void processYangFileExitStackErrorExtraEntryTest() {
    YangModule tmpModule = new YangModule();
    YangModule tmpModule2 = new YangModule();
    TreeWalkListener listener = new TreeWalkListener();
    listener.getParsedDataStack().push(tmpModule);
    listener.getParsedDataStack().push(tmpModule2);
    GeneratedYangParser.YangfileContext ctx = null;
    BaseFileListener.processYangFileExit(listener, ctx);
    assertThat(listener.getErrorInformation().isErrorFlag(), is(true));
    assertThat(listener.getErrorInformation().getErrorMsg(), is("YANG File contains multiple module/sub-module"));
}
#method_after
@Test
public void processYangFileExitStackErrorExtraEntryTest() {
    thrown.expect(ParserException.class);
    thrown.expectMessage("Internal parser error detected: Invalid holder for yangbase after processing.");
    YangModule tmpModule = new YangModule();
    YangModule tmpModule2 = new YangModule();
    TreeWalkListener listener = new TreeWalkListener();
    listener.getParsedDataStack().push(tmpModule);
    listener.getParsedDataStack().push(tmpModule2);
    GeneratedYangParser.YangfileContext ctx = null;
    BaseFileListener.processYangFileExit(listener, ctx);
}
#end_block

#method_before
public static void processPrefixEntry(TreeWalkListener listener, GeneratedYangParser.PrefixStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, "prefix")) {
        return;
    }
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                module.setPrefix(ctx.IDENTIFIER().getText());
                break;
            }
        case IMPORT_DATA:
            {
                YangImport importNode = (YangImport) tmpNode;
                importNode.setPrefixId(ctx.IDENTIFIER().getText());
                break;
            }
        case BELONGS_TO_DATA:
            {
                YangBelongsTo belongstoNode = (YangBelongsTo) tmpNode;
                belongstoNode.setPrefix(ctx.IDENTIFIER().getText());
                break;
            }
        default:
            listener.getErrorInformation().setErrorFlag(true);
            listener.getErrorInformation().setErrorMsg("Prefix associated with incorrect YANG construct");
            break;
    }
}
#method_after
public static void processPrefixEntry(TreeWalkListener listener, GeneratedYangParser.PrefixStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.PREFIX_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY);
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                module.setPrefix(ctx.IDENTIFIER().getText());
                break;
            }
        case IMPORT_DATA:
            {
                YangImport importNode = (YangImport) tmpNode;
                importNode.setPrefixId(ctx.IDENTIFIER().getText());
                break;
            }
        case BELONGS_TO_DATA:
            {
                YangBelongsTo belongstoNode = (YangBelongsTo) tmpNode;
                belongstoNode.setPrefix(ctx.IDENTIFIER().getText());
                break;
            }
        default:
            throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.PREFIX_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY));
    }
}
#end_block

#method_before
public static void processYangFileEntry(TreeWalkListener listener, GeneratedYangParser.YangfileContext ctx) {
    // If stack is not empty it indicates error condition
    if (!listener.getParsedDataStack().empty()) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg("Incorrect YANG file");
    }
}
#method_after
public static void processYangFileEntry(TreeWalkListener listener, GeneratedYangParser.YangfileContext ctx) {
    // Check if stack is empty.
    ListenerValidation.checkStackIsEmpty(listener, ListenerErrorType.INVALID_HOLDER, ParsableDataType.YANGBASE_DATA, "", ListenerErrorLocation.ENTRY);
}
#end_block

#method_before
public static void processYangFileExit(TreeWalkListener listener, GeneratedYangParser.YangfileContext ctx) {
    // Check whether error found while walking YANG file, if yes return.
    if (listener.getErrorInformation().isErrorFlag()) {
        return;
    }
    // If stack is empty it indicates error condition
    if (listener.getParsedDataStack().empty()) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg("YANG file is not walked correctly");
        return;
    }
    // Data Model tree root node is set.
    listener.setRootNode((YangNode) listener.getParsedDataStack().pop());
    // If stack is not empty it indicates error condition
    if (!listener.getParsedDataStack().empty()) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg("YANG File contains multiple module/sub-module");
    }
}
#method_after
public static void processYangFileExit(TreeWalkListener listener, GeneratedYangParser.YangfileContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.YANGBASE_DATA, "", ListenerErrorLocation.EXIT);
    // Data Model tree root node is set.
    if (listener.getParsedDataStack().peek() instanceof YangModule | listener.getParsedDataStack().peek() instanceof YangSubModule) {
        listener.setRootNode((YangNode) listener.getParsedDataStack().pop());
    } else {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_CHILD, ParsableDataType.YANGBASE_DATA, "", ListenerErrorLocation.EXIT));
    }
    // Check if stack is empty.
    ListenerValidation.checkStackIsEmpty(listener, ListenerErrorType.INVALID_HOLDER, ParsableDataType.YANGBASE_DATA, "", ListenerErrorLocation.EXIT);
}
#end_block

#method_before
public static void processIncludeEntry(TreeWalkListener listener, GeneratedYangParser.IncludeStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, "include")) {
        return;
    }
    YangInclude includeNode = new YangInclude();
    includeNode.setSubModuleName(String.valueOf(ctx.IDENTIFIER().getText()));
    try {
        includeNode.validateDataOnEntry();
    } catch (DataModelException e) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(e.getMessage());
    }
    if (ctx.STMTEND() != null) {
        // Obtain the node of the stack.
        Parsable tmpNode = listener.getParsedDataStack().peek();
        switch(tmpNode.getParsableDataType()) {
            case MODULE_DATA:
                {
                    YangModule module = (YangModule) tmpNode;
                    module.addIncludedInfo(includeNode);
                    break;
                }
            case SUB_MODULE_DATA:
                {
                    YangSubModule subModule = (YangSubModule) tmpNode;
                    subModule.addIncludedInfo(includeNode);
                    break;
                }
            default:
                listener.getErrorInformation().setErrorFlag(true);
                listener.getErrorInformation().setErrorMsg("Include associated with incorrect YANG construct");
                break;
        }
    } else {
        // Push import node to the stack.
        listener.getParsedDataStack().push(includeNode);
    }
}
#method_after
public static void processIncludeEntry(TreeWalkListener listener, GeneratedYangParser.IncludeStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.INCLUDE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY);
    YangInclude includeNode = new YangInclude();
    includeNode.setSubModuleName(String.valueOf(ctx.IDENTIFIER().getText()));
    listener.getParsedDataStack().push(includeNode);
}
#end_block

#method_before
public static void processIncludeExit(TreeWalkListener listener, GeneratedYangParser.IncludeStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, "belongsto")) {
        return;
    }
    Parsable tmpIncludeNode = listener.getParsedDataStack().peek();
    if (tmpIncludeNode instanceof YangInclude) {
        try {
            tmpIncludeNode.validateDataOnExit();
        } catch (DataModelException e) {
            listener.getErrorInformation().setErrorFlag(true);
            listener.getErrorInformation().setErrorMsg(e.getMessage());
        }
        listener.getParsedDataStack().pop();
        Parsable tmpNode = listener.getParsedDataStack().peek();
        switch(tmpNode.getParsableDataType()) {
            case MODULE_DATA:
                {
                    YangModule module = (YangModule) tmpNode;
                    module.addIncludedInfo((YangInclude) tmpIncludeNode);
                    break;
                }
            case SUB_MODULE_DATA:
                {
                    YangSubModule subModule = (YangSubModule) tmpNode;
                    subModule.addIncludedInfo((YangInclude) tmpIncludeNode);
                    break;
                }
            default:
                listener.getErrorInformation().setErrorFlag(true);
                listener.getErrorInformation().setErrorMsg("Include associated with incorrect YANG construct");
                break;
        }
    }
}
#method_after
public static void processIncludeExit(TreeWalkListener listener, GeneratedYangParser.IncludeStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.INCLUDE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT);
    Parsable tmpIncludeNode = listener.getParsedDataStack().peek();
    if (tmpIncludeNode instanceof YangInclude) {
        listener.getParsedDataStack().pop();
        // Check for stack to be non empty.
        ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.INCLUDE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT);
        Parsable tmpNode = listener.getParsedDataStack().peek();
        switch(tmpNode.getParsableDataType()) {
            case MODULE_DATA:
                {
                    YangModule module = (YangModule) tmpNode;
                    module.addIncludedInfo((YangInclude) tmpIncludeNode);
                    break;
                }
            case SUB_MODULE_DATA:
                {
                    YangSubModule subModule = (YangSubModule) tmpNode;
                    subModule.addIncludedInfo((YangInclude) tmpIncludeNode);
                    break;
                }
            default:
                throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.INCLUDE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
        }
    } else {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.MISSING_CURRENT_HOLDER, ParsableDataType.INCLUDE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
    }
}
#end_block

#method_before
public static void processSubModuleEntry(TreeWalkListener listener, GeneratedYangParser.SubModuleStatementContext ctx) {
    // Check whether error found while walking YANG file, if yes return.
    if (listener.getErrorInformation().isErrorFlag()) {
        return;
    }
    // If stack is not empty it indicates error condition
    if (!listener.getParsedDataStack().empty()) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg("Sub module statement is not a " + "starting statement");
    }
    YangSubModule yangSubModule = new YangSubModule();
    yangSubModule.setName(ctx.IDENTIFIER().getText());
    try {
        yangSubModule.validateDataOnEntry();
    } catch (DataModelException e) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(e.getMessage());
    }
    listener.getParsedDataStack().push(yangSubModule);
}
#method_after
public static void processSubModuleEntry(TreeWalkListener listener, GeneratedYangParser.SubModuleStatementContext ctx) {
    // Check if stack is empty.
    ListenerValidation.checkStackIsEmpty(listener, ListenerErrorType.INVALID_HOLDER, ParsableDataType.SUB_MODULE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY);
    YangSubModule yangSubModule = new YangSubModule();
    yangSubModule.setName(ctx.IDENTIFIER().getText());
    listener.getParsedDataStack().push(yangSubModule);
}
#end_block

#method_before
public static void processSubModuleExit(TreeWalkListener listener, GeneratedYangParser.SubModuleStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, "belongsto")) {
        return;
    }
    // Check whether error found while walking YANG file, if yes return.
    if (listener.getErrorInformation().isErrorFlag()) {
        return;
    }
    if (listener.getParsedDataStack().peek() instanceof YangSubModule) {
        YangSubModule yangSubModule = (YangSubModule) listener.getParsedDataStack().peek();
        try {
            yangSubModule.validateDataOnExit();
        } catch (DataModelException e) {
            listener.getErrorInformation().setErrorFlag(true);
            listener.getErrorInformation().setErrorMsg(e.getMessage());
        }
    } else {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg("Sub module object expected");
    }
}
#method_after
public static void processSubModuleExit(TreeWalkListener listener, GeneratedYangParser.SubModuleStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.SUB_MODULE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT);
    if (!(listener.getParsedDataStack().peek() instanceof YangSubModule)) {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.MISSING_CURRENT_HOLDER, ParsableDataType.SUB_MODULE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
    }
}
#end_block

#method_before
public static void processVersionEntry(TreeWalkListener listener, GeneratedYangParser.YangVersionStatementContext ctx) {
    // Validate for abnormal conditions.
    if (ListenerValidation.preValidation(listener, "version")) {
        return;
    }
    Integer version = Integer.valueOf(ctx.INTEGER().getText());
    if (!validateVersionValue(version)) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg("Input value of YANG version is not correct");
    }
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                module.setVersion((byte) 1);
                break;
            }
        case SUB_MODULE_DATA:
            {
                YangSubModule subModule = (YangSubModule) tmpNode;
                subModule.setVersion((byte) 1);
                break;
            }
        default:
            listener.getErrorInformation().setErrorFlag(true);
            listener.getErrorInformation().setErrorMsg("Version associated with YANG construct other" + "than module and sub-module");
            break;
    }
}
#method_after
public static void processVersionEntry(TreeWalkListener listener, GeneratedYangParser.YangVersionStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.VERSION_DATA, String.valueOf(ctx.INTEGER().getText()), ListenerErrorLocation.ENTRY);
    Integer version = Integer.valueOf(ctx.INTEGER().getText());
    if (!isVersionValid(version)) {
        ParserException parserException = new ParserException("Input version not supported");
        parserException.setLine(ctx.INTEGER().getSymbol().getLine());
        parserException.setCharPosition(ctx.INTEGER().getSymbol().getCharPositionInLine());
        throw parserException;
    }
    // Obtain the node of the stack.
    Parsable tmpNode = listener.getParsedDataStack().peek();
    switch(tmpNode.getParsableDataType()) {
        case MODULE_DATA:
            {
                YangModule module = (YangModule) tmpNode;
                module.setVersion((byte) 1);
                break;
            }
        case SUB_MODULE_DATA:
            {
                YangSubModule subModule = (YangSubModule) tmpNode;
                subModule.setVersion((byte) 1);
                break;
            }
        default:
            throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.INVALID_HOLDER, ParsableDataType.VERSION_DATA, String.valueOf(ctx.INTEGER().getText()), ListenerErrorLocation.ENTRY));
    }
}
#end_block

#method_before
@Test(expected = ParserException.class)
public void processContactDualEntryTest() throws IOException, ParserException {
    out.write("module Test {\n");
    out.write("yang-version 1;\n");
    out.write("namespace urn:itut:params:xml:ns:yang:ietf-ospf;\n");
    out.write("prefix On;\n");
    out.write("organization \"IETF SPRING Working Group\";\n");
    out.write("contact\n");
    out.write("\"WG List:  <mailto:spring@ietf.org>\n");
    out.write("Editor:    Stephane Litkowski\n");
    out.write("           <mailto:stephane.litkowski@orange.com>\";\n");
    out.write("contact\n");
    out.write("\"WG2 List:  <mailto:spring@ietf.org>\n");
    out.write("Editor:    Stephane Litkowski\n");
    out.write("           <mailto:stephane.litkowski@orange.com>\";\n");
    out.write("}\n");
    out.close();
    YangNode node = manager.getDataModel("demo.yang");
}
#method_after
@Test(expected = ParserException.class)
public void processContactDualEntryTest() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/ContactDualEntryTest.yang");
}
#end_block

#method_before
public static void processModuleEntry(TreeWalkListener listener, GeneratedYangParser.ModuleStatementContext ctx) {
    // Check whether error found while walking YANG file, if yes return.
    if (listener.getErrorInformation().isErrorFlag()) {
        return;
    }
    // If stack is not empty it indicates error condition
    if (!listener.getParsedDataStack().empty()) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg("Module statement is not a " + "starting statement");
    }
    YangModule yangModule = new YangModule();
    yangModule.setName(ctx.IDENTIFIER().getText());
    try {
        yangModule.validateDataOnEntry();
    } catch (DataModelException e) {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg(e.getMessage());
    }
    listener.getParsedDataStack().push(yangModule);
}
#method_after
public static void processModuleEntry(TreeWalkListener listener, GeneratedYangParser.ModuleStatementContext ctx) {
    // Check if stack is empty.
    ListenerValidation.checkStackIsEmpty(listener, ListenerErrorType.INVALID_HOLDER, ParsableDataType.MODULE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.ENTRY);
    YangModule yangModule = new YangModule();
    yangModule.setName(ctx.IDENTIFIER().getText());
    listener.getParsedDataStack().push(yangModule);
}
#end_block

#method_before
public static void processModuleExit(TreeWalkListener listener, GeneratedYangParser.ModuleStatementContext ctx) {
    // Check whether error found while walking YANG file, if yes return.
    if (listener.getErrorInformation().isErrorFlag()) {
        return;
    }
    if (listener.getParsedDataStack().peek() instanceof YangModule) {
        YangModule yangModule = (YangModule) listener.getParsedDataStack().peek();
        try {
            yangModule.validateDataOnExit();
        } catch (DataModelException e) {
            listener.getErrorInformation().setErrorFlag(true);
            listener.getErrorInformation().setErrorMsg(e.getMessage());
        }
    } else {
        listener.getErrorInformation().setErrorFlag(true);
        listener.getErrorInformation().setErrorMsg("Module object expected");
    }
}
#method_after
public static void processModuleExit(TreeWalkListener listener, GeneratedYangParser.ModuleStatementContext ctx) {
    // Check for stack to be non empty.
    ListenerValidation.checkStackIsNotEmpty(listener, ListenerErrorType.MISSING_HOLDER, ParsableDataType.MODULE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT);
    if (!(listener.getParsedDataStack().peek() instanceof YangModule)) {
        throw new ParserException(ListenerErrorMessageConstruction.constructListenerErrorMessage(ListenerErrorType.MISSING_CURRENT_HOLDER, ParsableDataType.MODULE_DATA, String.valueOf(ctx.IDENTIFIER().getText()), ListenerErrorLocation.EXIT));
    }
}
#end_block

#method_before
@Test(expected = ParserException.class)
public void processModuleInvalidEntryTest() throws IOException, ParserException {
    out.write("module Test:test {\n");
    out.write("yang-version 1;\n");
    out.write("namespace urn:ietf:params:xml:ns:yang:ietf-ospf;\n");
    out.write("prefix On;\n");
    out.write("}\n");
    out.close();
    YangNode node = manager.getDataModel("demo.yang");
}
#method_after
@Test(expected = ParserException.class)
public void processModuleInvalidEntryTest() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/ModuleWithInvalidIdentifier.yang");
}
#end_block

#method_before
@Override
protected void execute() {
    init();
    if (!src.matches(DEVRE) || !dst.matches(DEVRE)) {
        print("expected source and destination device ID pair");
        return;
    }
    Set<Path> paths = service.getPaths(topology, deviceId(src), deviceId(dst));
    if (outputJson()) {
        print("%s", json(this, paths));
    } else {
        for (Path path : paths) {
            print(pathString(path));
        }
    }
}
#method_after
@Override
protected void execute() {
    init();
    if (src.split("/").length != 1 || dst.split("/").length != 1) {
        print("Expected device IDs as arguments");
        return;
    }
    Set<Path> paths = service.getPaths(topology, deviceId(src), deviceId(dst));
    if (outputJson()) {
        print("%s", json(this, paths));
    } else {
        for (Path path : paths) {
            print(pathString(path));
        }
    }
}
#end_block

#method_before
@Override
public boolean unregister(List<ResourceId> ids) {
    checkNotNull(ids);
    TransactionContext tx = service.transactionContextBuilder().build();
    tx.begin();
    TransactionalMap<DiscreteResourceId, Set<Resource>> childTxMap = tx.getTransactionalMap(CHILD_MAP, SERIALIZER);
    TransactionalMap<DiscreteResourceId, ResourceConsumer> discreteConsumerTxMap = tx.getTransactionalMap(DISCRETE_CONSUMER_MAP, SERIALIZER);
    TransactionalMap<ContinuousResourceId, ContinuousResourceAllocation> continuousConsumerTxMap = tx.getTransactionalMap(CONTINUOUS_CONSUMER_MAP, SERIALIZER);
    // Look up resources by resource IDs
    List<Resource> resources = ids.stream().filter(x -> x.parent().isPresent()).map(x -> {
        if (x instanceof DiscreteResourceId) {
            return Optional.of(Resources.discrete((DiscreteResourceId) x).resource());
        } else {
            return lookup(childTxMap, x);
        }
    }).flatMap(Tools::stream).collect(Collectors.toList());
    // the order is preserved by LinkedHashMap
    Map<DiscreteResourceId, List<Resource>> resourceMap = resources.stream().collect(Collectors.groupingBy(x -> x.parent().get().id(), LinkedHashMap::new, Collectors.toList()));
    // all unregistrations are regarded as failure
    for (Map.Entry<DiscreteResourceId, List<Resource>> entry : resourceMap.entrySet()) {
        boolean allocated = entry.getValue().stream().anyMatch(x -> {
            if (x instanceof DiscreteResource) {
                return discreteConsumerTxMap.get(((DiscreteResource) x).id()) != null;
            } else if (x instanceof ContinuousResource) {
                ContinuousResourceAllocation allocations = continuousConsumerTxMap.get(((ContinuousResource) x).id());
                return allocations != null && !allocations.allocations().isEmpty();
            } else {
                return false;
            }
        });
        if (allocated) {
            log.warn("Failed to unregister {}: allocation exists", entry.getKey());
            return abortTransaction(tx);
        }
        if (!removeValues(childTxMap, entry.getKey(), entry.getValue())) {
            log.warn("Failed to unregister {}: Failed to remove values: {}", entry.getKey(), entry.getValue());
            return abortTransaction(tx);
        }
    }
    boolean success = tx.commit();
    if (success) {
        List<ResourceEvent> events = resources.stream().filter(x -> x.parent().isPresent()).map(x -> new ResourceEvent(RESOURCE_REMOVED, x)).collect(Collectors.toList());
        notifyDelegate(events);
    } else {
        log.warn("Failed to unregister {}: Commit failed.", ids);
    }
    return success;
}
#method_after
@Override
public boolean unregister(List<ResourceId> ids) {
    checkNotNull(ids);
    TransactionContext tx = service.transactionContextBuilder().build();
    tx.begin();
    TransactionalMap<DiscreteResourceId, Set<Resource>> childTxMap = tx.getTransactionalMap(CHILD_MAP, SERIALIZER);
    TransactionalMap<DiscreteResourceId, ResourceConsumer> discreteConsumerTxMap = tx.getTransactionalMap(DISCRETE_CONSUMER_MAP, SERIALIZER);
    TransactionalMap<ContinuousResourceId, ContinuousResourceAllocation> continuousConsumerTxMap = tx.getTransactionalMap(CONTINUOUS_CONSUMER_MAP, SERIALIZER);
    // Look up resources by resource IDs
    List<Resource> resources = ids.stream().filter(x -> x.parent().isPresent()).map(x -> {
        // avoid access to consistent map in the case of discrete resource
        if (x instanceof DiscreteResourceId) {
            return Optional.of(Resources.discrete((DiscreteResourceId) x).resource());
        } else {
            return lookup(childTxMap, x);
        }
    }).flatMap(Tools::stream).collect(Collectors.toList());
    // the order is preserved by LinkedHashMap
    Map<DiscreteResourceId, List<Resource>> resourceMap = resources.stream().collect(Collectors.groupingBy(x -> x.parent().get().id(), LinkedHashMap::new, Collectors.toList()));
    // all unregistrations are regarded as failure
    for (Map.Entry<DiscreteResourceId, List<Resource>> entry : resourceMap.entrySet()) {
        boolean allocated = entry.getValue().stream().anyMatch(x -> {
            if (x instanceof DiscreteResource) {
                return discreteConsumerTxMap.get(((DiscreteResource) x).id()) != null;
            } else if (x instanceof ContinuousResource) {
                ContinuousResourceAllocation allocations = continuousConsumerTxMap.get(((ContinuousResource) x).id());
                return allocations != null && !allocations.allocations().isEmpty();
            } else {
                return false;
            }
        });
        if (allocated) {
            log.warn("Failed to unregister {}: allocation exists", entry.getKey());
            return abortTransaction(tx);
        }
        if (!removeValues(childTxMap, entry.getKey(), entry.getValue())) {
            log.warn("Failed to unregister {}: Failed to remove values: {}", entry.getKey(), entry.getValue());
            return abortTransaction(tx);
        }
    }
    boolean success = tx.commit();
    if (success) {
        List<ResourceEvent> events = resources.stream().filter(x -> x.parent().isPresent()).map(x -> new ResourceEvent(RESOURCE_REMOVED, x)).collect(Collectors.toList());
        notifyDelegate(events);
    } else {
        log.warn("Failed to unregister {}: Commit failed.", ids);
    }
    return success;
}
#end_block

