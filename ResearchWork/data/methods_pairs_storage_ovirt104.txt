467
#method_before
protected boolean isQuotaDependant() {
    if (getActionType().getQuotaDependency() == VdcActionType.QuotaDependency.NONE) {
        return false;
    } else if (!isInternalExecution()) {
        return true;
    } else if (getActionType().isQuotaDependentAsInternalCommand()) {
        return true;
    } else {
        return false;
    }
}
#method_after
protected boolean isQuotaDependant() {
    if (getActionType().getQuotaDependency() == VdcActionType.QuotaDependency.NONE) {
        return false;
    }
    if (!isInternalExecution()) {
        return true;
    }
    return getActionType().isQuotaDependentAsInternalCommand();
}
#end_block

#method_before
public EntityModel getSourceModel() {
    return sourceModel;
}
#method_after
public IModel getSourceModel() {
    return sourceModel;
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (sender == getMAC()) {
        mAC_PropertyChanged((PropertyChangedEventArgs) args);
    } else if (sender == getPlugged()) {
        PropertyChangedEventArgs propArgs = (PropertyChangedEventArgs) args;
        if (propArgs.propertyName.equals("Entity")) {
            // $NON-NLS-1$
            boolean plugged = getPlugged().getEntity();
            getPlugged_IsSelected().setEntity(plugged);
            getUnplugged_IsSelected().setEntity(!plugged);
        } else if (propArgs.propertyName.equals("IsChangable")) {
            // $NON-NLS-1$
            boolean isPlugChangeable = getPlugged().getIsChangable();
            getPlugged_IsSelected().setChangeProhibitionReason(getLinked().getChangeProhibitionReason());
            getPlugged_IsSelected().setIsChangable(isPlugChangeable);
            getUnplugged_IsSelected().setChangeProhibitionReason(getLinked().getChangeProhibitionReason());
            getUnplugged_IsSelected().setIsChangable(isPlugChangeable);
        } else if (propArgs.propertyName.equals("IsAvailable")) {
            // $NON-NLS-1$
            boolean isPlugAvailable = getPlugged().getIsAvailable();
            getPlugged_IsSelected().setIsAvailable(isPlugAvailable);
            getUnplugged_IsSelected().setIsAvailable(isPlugAvailable);
        }
    } else if (sender == getPlugged_IsSelected()) {
        if (getPlugged_IsSelected().getEntity()) {
            getPlugged().setEntity(true);
        }
    } else if (sender == getUnplugged_IsSelected()) {
        if (getUnplugged_IsSelected().getEntity()) {
            getPlugged().setEntity(false);
        }
    } else if (sender == getLinked()) {
        PropertyChangedEventArgs propArgs = (PropertyChangedEventArgs) args;
        if (propArgs.propertyName.equals("Entity")) {
            // $NON-NLS-1$
            boolean linked = getLinked().getEntity();
            getLinked_IsSelected().setEntity(linked);
            getUnlinked_IsSelected().setEntity(!linked);
        } else if (propArgs.propertyName.equals("IsChangable")) {
            // $NON-NLS-1$
            boolean isLinkedChangeable = getLinked().getIsChangable();
            getLinked_IsSelected().setChangeProhibitionReason(getChangeProhibitionReason());
            getLinked_IsSelected().setIsChangable(isLinkedChangeable);
            getUnlinked_IsSelected().setChangeProhibitionReason(getLinked().getChangeProhibitionReason());
            getUnlinked_IsSelected().setIsChangable(isLinkedChangeable);
        } else if (propArgs.propertyName.equals("IsAvailable")) {
            // $NON-NLS-1$
            boolean isLinkedAvailable = getLinked().getIsAvailable();
            getLinked_IsSelected().setIsAvailable(isLinkedAvailable);
            getUnlinked_IsSelected().setIsAvailable(isLinkedAvailable);
        }
    } else if (sender == getLinked_IsSelected()) {
        if (getLinked_IsSelected().getEntity()) {
            getLinked().setEntity(true);
        }
    } else if (sender == getUnlinked_IsSelected()) {
        if (getUnlinked_IsSelected().getEntity()) {
            getLinked().setEntity(false);
        }
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (sender == getMAC()) {
        mAC_PropertyChanged((PropertyChangedEventArgs) args);
    } else if (sender == getPlugged()) {
        PropertyChangedEventArgs propArgs = (PropertyChangedEventArgs) args;
        if (propArgs.propertyName.equals("Entity")) {
            // $NON-NLS-1$
            boolean plugged = getPlugged().getEntity();
            getPlugged_IsSelected().setEntity(plugged);
            getUnplugged_IsSelected().setEntity(!plugged);
        } else if (propArgs.propertyName.equals("IsChangable")) {
            // $NON-NLS-1$
            boolean isPlugChangeable = getPlugged().getIsChangable();
            getPlugged_IsSelected().setChangeProhibitionReason(getLinked().getChangeProhibitionReason());
            getPlugged_IsSelected().setIsChangeable(isPlugChangeable);
            getUnplugged_IsSelected().setChangeProhibitionReason(getLinked().getChangeProhibitionReason());
            getUnplugged_IsSelected().setIsChangeable(isPlugChangeable);
        } else if (propArgs.propertyName.equals("IsAvailable")) {
            // $NON-NLS-1$
            boolean isPlugAvailable = getPlugged().getIsAvailable();
            getPlugged_IsSelected().setIsAvailable(isPlugAvailable);
            getUnplugged_IsSelected().setIsAvailable(isPlugAvailable);
        }
    } else if (sender == getPlugged_IsSelected()) {
        if (getPlugged_IsSelected().getEntity()) {
            getPlugged().setEntity(true);
        }
    } else if (sender == getUnplugged_IsSelected()) {
        if (getUnplugged_IsSelected().getEntity()) {
            getPlugged().setEntity(false);
        }
    } else if (sender == getLinked()) {
        PropertyChangedEventArgs propArgs = (PropertyChangedEventArgs) args;
        if (propArgs.propertyName.equals("Entity")) {
            // $NON-NLS-1$
            boolean linked = getLinked().getEntity();
            getLinked_IsSelected().setEntity(linked);
            getUnlinked_IsSelected().setEntity(!linked);
        } else if (propArgs.propertyName.equals("IsChangable")) {
            // $NON-NLS-1$
            boolean isLinkedChangeable = getLinked().getIsChangable();
            getLinked_IsSelected().setChangeProhibitionReason(getLinked().getChangeProhibitionReason());
            getLinked_IsSelected().setIsChangeable(isLinkedChangeable);
            getUnlinked_IsSelected().setChangeProhibitionReason(getLinked().getChangeProhibitionReason());
            getUnlinked_IsSelected().setIsChangeable(isLinkedChangeable);
        } else if (propArgs.propertyName.equals("IsAvailable")) {
            // $NON-NLS-1$
            boolean isLinkedAvailable = getLinked().getIsAvailable();
            getLinked_IsSelected().setIsAvailable(isLinkedAvailable);
            getUnlinked_IsSelected().setIsAvailable(isLinkedAvailable);
        }
    } else if (sender == getLinked_IsSelected()) {
        if (getLinked_IsSelected().getEntity()) {
            getLinked().setEntity(true);
        }
    } else if (sender == getUnlinked_IsSelected()) {
        if (getUnlinked_IsSelected().getEntity()) {
            getLinked().setEntity(false);
        }
    }
}
#end_block

#method_before
private void mAC_PropertyChanged(PropertyChangedEventArgs e) {
    if (// $NON-NLS-1$
    e.propertyName.equals("IsChangeAllowed") && !getMAC().getIsChangable()) {
        getMAC().setIsValid(true);
    }
}
#method_after
private void mAC_PropertyChanged(PropertyChangedEventArgs e) {
    if (e.propertyName.equals("IsChangeAllowed") && !getMAC().getIsChangable()) {
        // $NON-NLS-1$
        getMAC().setIsValid(true);
    }
}
#end_block

#method_before
public boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new NoSpecialCharactersWithDotValidation() });
    getNicType().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMAC().setIsValid(true);
    if (getMAC().getIsChangable()) {
        getMAC().validateEntity(new IValidation[] { new NotEmptyValidation(), new UnicastMacAddressValidation() });
    }
    return getName().getIsValid() && getNicType().getIsValid() && getMAC().getIsValid();
}
#method_after
public boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new NoSpecialCharactersWithDotValidation() });
    getNicType().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getProfile().validateSelectedItem(new IValidation[] { new VnicProfileValidation(clusterCompatibilityVersion.toString(), getNicType().getSelectedItem()) });
    getMAC().setIsValid(true);
    if (getMAC().getIsChangable()) {
        getMAC().validateEntity(new IValidation[] { new NotEmptyValidation(), new UnicastMacAddressValidation() });
    }
    return getName().getIsValid() && getNicType().getIsValid() && getMAC().getIsValid() && getProfile().getIsValid();
}
#end_block

#method_before
protected void onSave() {
    VmNetworkInterface nic = createBaseNic();
    if (getProgress() != null) {
        return;
    }
    if (!validate()) {
        return;
    }
    // Save changes.
    nic.setName(getName().getEntity());
    VnicProfileView profile = getProfile().getSelectedItem();
    nic.setVnicProfileId(profile.getId());
    nic.setNetworkName(profile.getNetworkName());
    nic.setLinked(getLinked().getEntity());
    if (getNicType().getSelectedItem() == null) {
        nic.setType(null);
    } else {
        nic.setType(getNicType().getSelectedItem().getValue());
    }
    onSaveMAC(nic);
    nic.setPlugged(getPlugged().getEntity());
    startProgress(null);
    Frontend.getInstance().runAction(getVdcActionType(), createVdcActionParameters(nic), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            stopProgress();
            if (returnValue != null && returnValue.getSucceeded()) {
                cancel();
                postOnSave();
            }
        }
    }, this);
}
#method_after
protected void onSave() {
    VmNetworkInterface nic = createBaseNic();
    if (getProgress() != null) {
        return;
    }
    if (!validate()) {
        return;
    }
    // Save changes.
    nic.setName(getName().getEntity());
    VnicProfileView profile = getProfile().getSelectedItem();
    nic.setVnicProfileId(profile.getId());
    nic.setNetworkName(profile.getNetworkName());
    nic.setLinked(getLinked().getEntity());
    if (getNicType().getSelectedItem() == null) {
        nic.setType(null);
    } else {
        nic.setType(getNicType().getSelectedItem().getValue());
    }
    onSaveMAC(nic);
    nic.setPlugged(getPlugged().getEntity());
    startProgress();
    Frontend.getInstance().runAction(getVdcActionType(), createVdcActionParameters(nic), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            stopProgress();
            if (returnValue != null && returnValue.getSucceeded()) {
                cancel();
                postOnSave();
            }
        }
    }, this);
}
#end_block

#method_before
protected void updateLinkChangability() {
    boolean isNullProfileSelected = getProfile().getSelectedItem() == null;
    if (isNullProfileSelected) {
        getLinked().setIsChangable(false);
        return;
    }
    if (!hotUpdateSupported) {
        getLinked().setIsChangable(false);
        return;
    }
    getLinked().setIsChangable(true);
}
#method_after
protected void updateLinkChangability() {
    boolean isNullProfileSelected = getProfile().getSelectedItem() == null;
    if (isNullProfileSelected) {
        getLinked().setIsChangeable(false);
        return;
    }
    if (!hotUpdateSupported) {
        getLinked().setIsChangeable(false);
        return;
    }
    if ((VmInterfaceType.pciPassthrough.equals(getNicType().getSelectedItem()) || getProfile().getSelectedItem().isPassthrough())) {
        getLinked().setEntity(true);
        getLinked().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().linkStateUpdateNotSupportedForPassthroughVnic());
        getLinked().setIsChangeable(false);
        return;
    }
    getLinked().setIsChangeable(true);
}
#end_block

#method_before
protected void updateProfileChangability() {
    getProfile().setIsChangable(true);
}
#method_after
protected void updateProfileChangability() {
    getProfile().setIsChangeable(true);
}
#end_block

#method_before
@Mapping(from = VmPool.class, to = org.ovirt.engine.core.common.businessentities.VmPool.class)
public static org.ovirt.engine.core.common.businessentities.VmPool map(VmPool model, org.ovirt.engine.core.common.businessentities.VmPool template) {
    org.ovirt.engine.core.common.businessentities.VmPool entity = template != null ? template : new org.ovirt.engine.core.common.businessentities.VmPool();
    if (model.isSetId()) {
        entity.setVmPoolId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setVmPoolDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetSize()) {
        entity.setAssignedVmsCount(model.getSize());
    }
    if (model.isSetCluster()) {
        if (model.getCluster().isSetId()) {
            entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
        } else if (model.getCluster().isSetName()) {
            entity.setVdsGroupName(model.getCluster().getName());
        }
    }
    if (model.isSetPrestartedVms()) {
        entity.setPrestartedVms(model.getPrestartedVms());
    }
    if (model.isSetMaxUserVms()) {
        entity.setMaxAssignedVmsPerUser(model.getMaxUserVms());
    }
    if (model.isSetDisplay() && model.getDisplay().isSetProxy()) {
        entity.setSpiceProxy("".equals(model.getDisplay().getProxy()) ? null : model.getDisplay().getProxy());
    }
    if (model.isSetType()) {
        VmPoolType type = VmPoolType.forName(model.getType());
        entity.setVmPoolType(type != null ? type : VmPoolType.Automatic);
    }
    return entity;
}
#method_after
@Mapping(from = VmPool.class, to = org.ovirt.engine.core.common.businessentities.VmPool.class)
public static org.ovirt.engine.core.common.businessentities.VmPool map(VmPool model, org.ovirt.engine.core.common.businessentities.VmPool template) {
    org.ovirt.engine.core.common.businessentities.VmPool entity = template != null ? template : new org.ovirt.engine.core.common.businessentities.VmPool();
    if (model.isSetId()) {
        entity.setVmPoolId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setVmPoolDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetSize()) {
        entity.setAssignedVmsCount(model.getSize());
    }
    if (model.isSetCluster()) {
        if (model.getCluster().isSetId()) {
            entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
        } else if (model.getCluster().isSetName()) {
            entity.setVdsGroupName(model.getCluster().getName());
        }
    }
    if (model.isSetPrestartedVms()) {
        entity.setPrestartedVms(model.getPrestartedVms());
    }
    if (model.isSetMaxUserVms()) {
        entity.setMaxAssignedVmsPerUser(model.getMaxUserVms());
    }
    if (model.isSetDisplay() && model.getDisplay().isSetProxy()) {
        entity.setSpiceProxy("".equals(model.getDisplay().getProxy()) ? null : model.getDisplay().getProxy());
    }
    if (model.isSetType()) {
        VmPoolType type = VmPoolType.fromValue(model.getType());
        entity.setVmPoolType(type != null ? map(type, null) : org.ovirt.engine.core.common.businessentities.VmPoolType.Automatic);
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VmPool.class, to = VmPool.class)
public static VmPool map(org.ovirt.engine.core.common.businessentities.VmPool entity, VmPool template) {
    VmPool model = template != null ? template : new VmPool();
    model.setId(entity.getVmPoolId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmPoolDescription());
    model.setComment(entity.getComment());
    model.setSize(entity.getAssignedVmsCount());
    model.setPrestartedVms(entity.getPrestartedVms());
    if (entity.getVdsGroupId() != null || entity.getVdsGroupName() != null) {
        model.setCluster(new Cluster());
        model.getCluster().setId(entity.getVdsGroupId().toString());
    }
    model.setMaxUserVms(entity.getMaxAssignedVmsPerUser());
    if (StringUtils.isNotBlank(entity.getSpiceProxy())) {
        Display display = new Display();
        display.setProxy(entity.getSpiceProxy());
        model.setDisplay(display);
    }
    model.setType(entity.getVmPoolType().getName());
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VmPool.class, to = VmPool.class)
public static VmPool map(org.ovirt.engine.core.common.businessentities.VmPool entity, VmPool template) {
    VmPool model = template != null ? template : new VmPool();
    model.setId(entity.getVmPoolId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmPoolDescription());
    model.setComment(entity.getComment());
    model.setSize(entity.getAssignedVmsCount());
    model.setPrestartedVms(entity.getPrestartedVms());
    if (entity.getVdsGroupId() != null || entity.getVdsGroupName() != null) {
        model.setCluster(new Cluster());
        model.getCluster().setId(entity.getVdsGroupId().toString());
    }
    model.setMaxUserVms(entity.getMaxAssignedVmsPerUser());
    if (StringUtils.isNotBlank(entity.getSpiceProxy())) {
        Display display = new Display();
        display.setProxy(entity.getSpiceProxy());
        model.setDisplay(display);
    }
    model.setType(map(entity.getVmPoolType(), null));
    return model;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmPool.class)
public static VmPool map(VM vm, VmPool template) {
    VmPool model = template != null ? template : new VmPool();
    org.ovirt.engine.api.model.VM vmModel = VmMapper.map(vm, (org.ovirt.engine.api.model.VM) null);
    vmModel.setCluster(null);
    vmModel.setTemplate(null);
    vmModel.setVmPool(null);
    model.setVm(vmModel);
    return model;
}
#method_after
@Mapping(from = VmPoolType.class, to = org.ovirt.engine.core.common.businessentities.VmPoolType.class)
public static org.ovirt.engine.core.common.businessentities.VmPoolType map(VmPoolType vmPoolType, org.ovirt.engine.core.common.businessentities.VmPoolType incoming) {
    switch(vmPoolType) {
        case AUTOMATIC:
            return org.ovirt.engine.core.common.businessentities.VmPoolType.Automatic;
        case MANUAL:
            return org.ovirt.engine.core.common.businessentities.VmPoolType.Manual;
        default:
            return null;
    }
}
#end_block

#method_before
@Before
public void setup() {
    vdsGroup1 = createVdsGroup();
    vdsGroup2 = createVdsGroup();
    when(vdsGroupDao.getAll()).thenReturn(Arrays.asList(vdsGroup1, vdsGroup2));
    when(rulesEnforcer.chooseNextVmToMigrate(eq(vdsGroup1))).thenReturn(vm1);
    when(rulesEnforcer.chooseNextVmToMigrate(eq(vdsGroup2))).thenReturn(vm2);
    arem.wakeup();
}
#method_after
@Before
public void setup() {
    vdsGroup1 = createVdsGroup();
    vdsGroup2 = createVdsGroup();
    when(vdsGroupDao.getWithoutMigratingVms()).thenReturn(Arrays.asList(vdsGroup1, vdsGroup2));
    when(rulesEnforcer.chooseNextVmToMigrate(eq(vdsGroup1))).thenReturn(vm1);
    when(rulesEnforcer.chooseNextVmToMigrate(eq(vdsGroup2))).thenReturn(vm2);
    arem.wakeup();
}
#end_block

#method_before
@OnTimerMethodAnnotation("refresh")
public void refresh() {
    log.debug("Affinity Rules Enforcement Manager interval reached.");
    final List<VM> vmCandidates = new ArrayList<>();
    for (VDSGroup cluster : findMigrationFreeClusters()) {
        final VM candidate = rulesEnforcer.chooseNextVmToMigrate(cluster);
        if (candidate != null) {
            vmCandidates.add(candidate);
        }
    }
    // Trigger migrations
    for (VM vm : vmCandidates) {
        migrateVM(vm);
    }
}
#method_after
@OnTimerMethodAnnotation("refresh")
public void refresh() {
    log.debug("Affinity Rules Enforcement Manager interval reached.");
    final List<VM> vmCandidates = new ArrayList<>();
    for (VDSGroup cluster : vdsGroupDao.getWithoutMigratingVms()) {
        final VM candidate = rulesEnforcer.chooseNextVmToMigrate(cluster);
        if (candidate != null) {
            vmCandidates.add(candidate);
        }
    }
    // Trigger migrations
    for (VM vm : vmCandidates) {
        migrateVM(vm);
    }
}
#end_block

#method_before
public Result invoke(List<VDS> sourceHosts, List<VDS> destinationHosts, VmDao vmDao) {
    List<VDS> validDestinationHosts;
    // Iterate over source hosts until you find valid vm to migrate, hosts sorted by cpu usage
    for (VDS sourceHost : sourceHosts) {
        // Get list of all migratable vms on host
        log.debug("Get all migratable vms from host '{}'", sourceHost.getName());
        List<VM> migratableVmsOnHost = getMigratableVmsRunningOnVds(vmDao, sourceHost.getId());
        if (migratableVmsOnHost != null && !migratableVmsOnHost.isEmpty()) {
            // Sort vms by cpu usage
            Collections.sort(migratableVmsOnHost, VmCpuUsageComparator.INSTANCE);
            for (VM vmToMigrate : migratableVmsOnHost) {
                if (vmToMigrate != null) {
                    log.debug("Validate if vm '{}' not over utilized CPU and memory of destination hosts", vmToMigrate.getName());
                    // Check if vm not over utilize memory or CPU of destination hosts
                    validDestinationHosts = getValidHosts(destinationHosts, cluster, vmToMigrate, highCpuUtilization, requiredMemory);
                    if (!validDestinationHosts.isEmpty()) {
                        return new Result(vmToMigrate, validDestinationHosts);
                    }
                }
            }
        }
    }
    return null;
}
#method_after
public Result invoke(List<VDS> sourceHosts, List<VDS> destinationHosts, VmDao vmDao) {
    List<VDS> validDestinationHosts;
    // Iterate over source hosts until you find valid vm to migrate, hosts sorted by cpu usage
    for (VDS sourceHost : sourceHosts) {
        // Get list of all migratable vms on host
        List<VM> migratableVmsOnHost = getMigratableVmsRunningOnVds(vmDao, sourceHost.getId());
        if (migratableVmsOnHost != null && !migratableVmsOnHost.isEmpty()) {
            // Sort vms by cpu usage
            Collections.sort(migratableVmsOnHost, VmCpuUsageComparator.INSTANCE);
            for (VM vmToMigrate : migratableVmsOnHost) {
                if (vmToMigrate != null) {
                    // Check if vm not over utilize memory or CPU of destination hosts
                    validDestinationHosts = getValidHosts(destinationHosts, cluster, vmToMigrate, highCpuUtilization, requiredMemory);
                    if (!validDestinationHosts.isEmpty()) {
                        log.debug("Vm '{}' selected for migration", vmToMigrate.getName());
                        return new Result(vmToMigrate, validDestinationHosts);
                    }
                }
            }
        }
    }
    return null;
}
#end_block

#method_before
private VmStatsRefresher getRefresherForVds(VdsManager vdsManager) {
    Version version = vdsManager.getCompatibilityVersion();
    VDS vds = vdsManager.getCopyVds();
    if (FeatureSupported.jsonProtocol(version) && VdsProtocol.STOMP == vds.getProtocol() && FeatureSupported.events(version)) {
        return new EventVmStatsRefresher(vdsManager);
    }
    return new PollListAndAllVmStatsRefresher(vdsManager);
}
#method_after
private VmStatsRefresher getRefresherForVds(VdsManager vdsManager) {
    Version version = vdsManager.getCompatibilityVersion();
    VDS vds = vdsManager.getCopyVds();
    if (FeatureSupported.jsonProtocol(version) && VdsProtocol.STOMP == vds.getProtocol() && FeatureSupported.vmStatsEvents(version) && FeatureSupported.events(version)) {
        return new EventVmStatsRefresher(vdsManager);
    }
    return new PollListAndAllVmStatsRefresher(vdsManager);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDS host = getVds();
    final ValidationResult hostValidatorResult = new HostValidator(host, isInternalExecution()).validate();
    if (!hostValidatorResult.isValid()) {
        return validate(hostValidatorResult);
    }
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(getExistingNics());
    nicNameNicIdCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments());
    nicNameNicIdCompleter.completeBonds(getParameters().getBonds());
    nicNameNicIdCompleter.completeNetworkAttachments(getExistingAttachments());
    nicNameNicIdCompleter.completeLabels(getParameters().getLabels());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments(), getNetworkBusinessEntityMap());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getExistingAttachments(), getNetworkBusinessEntityMap());
    NicLabelsCompleter labelsCompleter = new NicLabelsCompleter(getParameters(), getExistingAttachments(), getClusterNetworks(), getExistingNicsBusinessEntityMap());
    labelsCompleter.completeNetworkAttachments();
    ValidationResult hostSetupNetworkValidatorResult = validateWithHostSetupNetworksValidator(host);
    if (!hostSetupNetworkValidatorResult.isValid()) {
        return validate(hostSetupNetworkValidatorResult);
    }
    return validate(checkForOutOfSyncNetworks());
}
#method_after
@Override
protected boolean canDoAction() {
    VDS host = getVds();
    fillInUnsetBondingOptions();
    final ValidationResult hostValidatorResult = new HostValidator(host, isInternalExecution()).validate();
    if (!hostValidatorResult.isValid()) {
        return validate(hostValidatorResult);
    }
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(getExistingNics());
    nicNameNicIdCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments());
    nicNameNicIdCompleter.completeBonds(getParameters().getBonds());
    nicNameNicIdCompleter.completeNetworkAttachments(getExistingAttachments());
    nicNameNicIdCompleter.completeLabels(getParameters().getLabels());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments(), getNetworkBusinessEntityMap());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getExistingAttachments(), getNetworkBusinessEntityMap());
    NicLabelsCompleter labelsCompleter = new NicLabelsCompleter(getParameters(), getExistingAttachments(), getClusterNetworks(), getExistingNicsBusinessEntityMap());
    labelsCompleter.completeNetworkAttachments();
    ValidationResult hostSetupNetworkValidatorResult = validateWithHostSetupNetworksValidator(host);
    if (!hostSetupNetworkValidatorResult.isValid()) {
        return validate(hostSetupNetworkValidatorResult);
    }
    return validate(checkForOutOfSyncNetworks());
}
#end_block

#method_before
private ValidationResult validateWithHostSetupNetworksValidator(VDS host) {
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, getParameters(), getExistingNics(), getExistingAttachments(), getNetworkBusinessEntityMap(), managementNetworkUtil, networkClusterDao, networkDao, vdsDao, hostSetupNetworksValidatorHelper, vmDao);
    return validator.validate();
}
#method_after
private ValidationResult validateWithHostSetupNetworksValidator(VDS host) {
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, getParameters(), getExistingNics(), getExistingAttachments(), getNetworkBusinessEntityMap(), managementNetworkUtil, networkClusterDao, networkDao, vdsDao, hostSetupNetworksValidatorHelper, vmDao, networkExclusivenessValidatorResolver);
    return validator.validate();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        log.info("No changes were detected in setup networks for host '{}' (ID: '{}')", getVdsName(), getVdsId());
        setSucceeded(true);
        return;
    }
    fillInUnsetBondingOptions();
    int timeout = getSetupNetworksTimeout();
    FutureVDSCall<VDSReturnValue> setupNetworksTask = invokeSetupNetworksCommand(timeout);
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().rollbackOnFailure()) {
                throw new EngineException(EngineError.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                try (EngineLock monitoringLock = acquireMonitorLock()) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                logMonitorLockReleased("Host setup networks");
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Host Setup networks command timed out for {} seconds", timeout);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        log.info("No changes were detected in setup networks for host '{}' (ID: '{}')", getVdsName(), getVdsId());
        setSucceeded(true);
        return;
    }
    int timeout = getSetupNetworksTimeout();
    FutureVDSCall<VDSReturnValue> setupNetworksTask = invokeSetupNetworksCommand(timeout);
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().rollbackOnFailure()) {
                throw new EngineException(EngineError.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                try (EngineLock monitoringLock = acquireMonitorLock()) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                logMonitorLockReleased("Host setup networks");
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Host Setup networks command timed out for {} seconds", timeout);
    }
}
#end_block

#method_before
private ValidationResult checkForOutOfSyncNetworks() {
    for (NetworkAttachment networkAttachment : getParameters().getNetworkAttachments()) {
        boolean newNetworkAttachment = networkAttachment.getId() == null;
        if (newNetworkAttachment) {
            // attachment to be yet created cannot be out of sync.
            continue;
        }
        boolean doNotCheckForOutOfSync = networkAttachment.isOverrideConfiguration();
        if (doNotCheckForOutOfSync) {
            continue;
        }
        Map<Guid, NetworkAttachment> existingNetworkAttachmentMap = Entities.businessEntitiesById(getExistingAttachments());
        NetworkAttachment existingNetworkAttachment = existingNetworkAttachmentMap.get(networkAttachment.getId());
        VdsNetworkInterface vdsNetworkInterface = Entities.hostInterfacesByNetworkName(getExistingNics()).get(existingNetworkAttachment.getNetworkName());
        Network network = getNetworkBusinessEntityMap().get(existingNetworkAttachment.getNetworkId());
        HostNetworkQos qos = qosDaoCache.get(network.getQosId());
        boolean networkInSync = NetworkUtils.isNetworkInSync(vdsNetworkInterface, network, qos);
        if (!networkInSync) {
            return new ValidationResult(EngineMessage.NETWORKS_NOT_IN_SYNC, ReplacementUtils.createSetVariableString("NETWORK_NOT_IN_SYNC", network.getName()));
        }
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult checkForOutOfSyncNetworks() {
    for (NetworkAttachment networkAttachment : getParameters().getNetworkAttachments()) {
        boolean newNetworkAttachment = networkAttachment.getId() == null;
        if (newNetworkAttachment) {
            // attachment to be yet created cannot be out of sync.
            continue;
        }
        boolean doNotCheckForOutOfSync = networkAttachment.isOverrideConfiguration();
        if (doNotCheckForOutOfSync) {
            continue;
        }
        Map<Guid, NetworkAttachment> existingNetworkAttachmentMap = Entities.businessEntitiesById(getExistingAttachments());
        NetworkAttachment existingNetworkAttachment = existingNetworkAttachmentMap.get(networkAttachment.getId());
        VdsNetworkInterface nic = Entities.hostInterfacesByNetworkName(getExistingNics()).get(existingNetworkAttachment.getNetworkName());
        NetworkImplementationDetails networkImplementationDetails = nic.getNetworkImplementationDetails();
        boolean networkIsNotInSync = networkImplementationDetails != null && !networkImplementationDetails.isInSync();
        if (networkIsNotInSync) {
            return new ValidationResult(EngineMessage.NETWORKS_NOT_IN_SYNC, ReplacementUtils.createSetVariableString("NETWORK_NOT_IN_SYNC", existingNetworkAttachment.getNetworkName()));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private List<VdsNetworkInterface> getExistingNics() {
    if (existingNics == null) {
        existingNics = getDbFacade().getInterfaceDao().getAllInterfacesForVds(getVdsId());
        NetworkCommonUtils.fillBondSlaves(existingNics);
        for (VdsNetworkInterface iface : existingNics) {
            Network network = getNetworkBusinessEntityMap().get(iface.getNetworkName());
            HostNetworkQos hostNetworkQos = network == null ? null : qosDaoCache.get(network.getQosId());
            VdsNetworkInterface.NetworkImplementationDetails networkImplementationDetails = NetworkUtils.calculateNetworkImplementationDetails(network, hostNetworkQos, iface);
            iface.setNetworkImplementationDetails(networkImplementationDetails);
        }
    }
    return existingNics;
}
#method_after
private List<VdsNetworkInterface> getExistingNics() {
    if (existingNics == null) {
        existingNics = getDbFacade().getInterfaceDao().getAllInterfacesForVds(getVdsId());
        NetworkCommonUtils.fillBondSlaves(existingNics);
        for (VdsNetworkInterface iface : existingNics) {
            Network network = getNetworkBusinessEntityMap().get(iface.getNetworkName());
            NetworkImplementationDetails networkImplementationDetails = networkImplementationDetailsUtils.calculateNetworkImplementationDetails(iface, network);
            iface.setNetworkImplementationDetails(networkImplementationDetails);
        }
    }
    return existingNics;
}
#end_block

#method_before
private List<HostNetwork> getNetworksToConfigure() {
    if (networksToConfigure == null) {
        networksToConfigure = new ArrayList<>(getParameters().getNetworkAttachments().size());
        BusinessEntityMap<VdsNetworkInterface> nics = getExistingNicsBusinessEntityMap();
        for (NetworkAttachment attachment : getParameters().getNetworkAttachments()) {
            Network network = existingNetworkRelatedToAttachment(attachment);
            HostNetwork networkToConfigure = new HostNetwork(network, attachment);
            networkToConfigure.setBonding(isBonding(attachment, nics));
            if (defaultRouteSupported() && defaultRouteRequired(network, attachment.getIpConfiguration())) {
                networkToConfigure.setDefaultRoute(true);
            }
            // TODO MM:  if it's newly created interface, it won't be discovered and Qos cannot be evaluated.
            VdsNetworkInterface iface = nics.get(attachment.getNicId(), attachment.getNicName());
            boolean qosConfiguredOnInterface = iface == null ? false : NetworkUtils.qosConfiguredOnInterface(iface, network);
            networkToConfigure.setQosConfiguredOnInterface(qosConfiguredOnInterface);
            if (qosConfiguredOnInterface) {
                networkToConfigure.setQos(iface.isQosOverridden() ? iface.getQos() : qosDaoCache.get(network.getQosId()));
            }
            networksToConfigure.add(networkToConfigure);
        }
    }
    return networksToConfigure;
}
#method_after
private List<HostNetwork> getNetworksToConfigure() {
    if (networksToConfigure == null) {
        networksToConfigure = new ArrayList<>(getParameters().getNetworkAttachments().size());
        BusinessEntityMap<VdsNetworkInterface> nics = getExistingNicsBusinessEntityMap();
        for (NetworkAttachment attachment : getParameters().getNetworkAttachments()) {
            Network network = existingNetworkRelatedToAttachment(attachment);
            HostNetwork networkToConfigure = new HostNetwork(network, attachment);
            networkToConfigure.setBonding(isBonding(attachment, nics));
            if (defaultRouteSupported() && defaultRouteRequired(network, attachment.getIpConfiguration())) {
                networkToConfigure.setDefaultRoute(true);
            }
            if (NetworkUtils.qosConfiguredOnInterface(attachment, network)) {
                networkToConfigure.setQosConfiguredOnInterface(true);
                HostNetworkQos hostNetworkQos = effectiveHostNetworkQos.getQos(attachment, network);
                networkToConfigure.setQos(hostNetworkQos);
            }
            networksToConfigure.add(networkToConfigure);
        }
    }
    return networksToConfigure;
}
#end_block

#method_before
public VM chooseNextVmToMigrate(VDSGroup vdsGroup) {
    List<AffinityGroup> allHardAffinityGroups = getAllHardAffinityGroups(vdsGroup);
    Set<Set<Guid>> unifiedPositiveAffinityGroups = AffinityRulesUtils.getUnifiedPositiveAffinityGroups(allHardAffinityGroups);
    List<AffinityGroup> unifiedAffinityGroups = AffinityRulesUtils.setsToAffinityGroups(unifiedPositiveAffinityGroups);
    // Add negative affinity groups
    for (AffinityGroup ag : allHardAffinityGroups) {
        if (!ag.isPositive()) {
            unifiedAffinityGroups.add(ag);
        }
    }
    // Create a set of all VMs in affinity groups
    Set<Guid> allVms = new HashSet<>();
    for (AffinityGroup group : unifiedAffinityGroups) {
        allVms.addAll(group.getEntityIds());
    }
    Map<Guid, Guid> vmToHost = createMapOfVmToHost(allVms);
    // There is no need to migrate when no collision was detected
    Set<AffinityGroup> violatedAffinityGroups = checkForAffinityGroupViolations(unifiedAffinityGroups, vmToHost, FailMode.GET_ALL);
    if (violatedAffinityGroups.isEmpty()) {
        log.debug("No affinity group collision detected for cluster {}. Standing by.", vdsGroup.getId());
        return null;
    }
    // Find a VM that is breaking the affinityGroup and can be theoretically migrated
    // - start with bigger Affinity Groups
    List<AffinityGroup> affGroupsBySize = new ArrayList<>(violatedAffinityGroups);
    Collections.sort(affGroupsBySize, Collections.reverseOrder(new AffinityGroupComparator()));
    for (AffinityGroup affinityGroup : affGroupsBySize) {
        final List<Guid> candidateVms;
        if (affinityGroup.isPositive()) {
            candidateVms = findVmViolatingPositiveAg(affinityGroup, vmToHost);
            log.info("Positive affinity group violation detected");
        } else {
            candidateVms = findVmViolatingNegativeAg(affinityGroup, vmToHost);
            log.info("Negative affinity group violation detected");
        }
        while (!candidateVms.isEmpty()) {
            final int index = new Random().nextInt(candidateVms.size());
            final Guid candidateVm = candidateVms.get(index);
            // Test whether any migration is possible, this uses current AffinityGroup settings
            // and so won't allow more breakage
            VM vm = vmDao.get(candidateVm);
            boolean canMove = schedulingManager.canSchedule(vdsGroup, vm, new ArrayList<Guid>(), new ArrayList<Guid>(), null, new ArrayList<String>());
            if (canMove) {
                log.debug("VM {} is a viable candidate for solving affinity group violation situation.", candidateVm);
                return vm;
            }
            log.debug("VM {} is NOT a viable candidate for solving affinity group violation situation.", candidateVm);
            candidateVms.remove(index);
        }
    }
    // No possible migration..
    return null;
}
#method_after
public VM chooseNextVmToMigrate(VDSGroup vdsGroup) {
    List<AffinityGroup> allHardAffinityGroups = getAllHardAffinityGroups(vdsGroup);
    Set<Set<Guid>> unifiedPositiveAffinityGroups = AffinityRulesUtils.getUnifiedPositiveAffinityGroups(allHardAffinityGroups);
    List<AffinityGroup> unifiedAffinityGroups = AffinityRulesUtils.setsToAffinityGroups(unifiedPositiveAffinityGroups);
    // Add negative affinity groups
    for (AffinityGroup ag : allHardAffinityGroups) {
        if (!ag.isPositive()) {
            unifiedAffinityGroups.add(ag);
        }
    }
    // Create a set of all VMs in affinity groups
    Set<Guid> allVms = new HashSet<>();
    for (AffinityGroup group : unifiedAffinityGroups) {
        allVms.addAll(group.getEntityIds());
    }
    Map<Guid, Guid> vmToHost = createMapOfVmToHost(allVms);
    // There is no need to migrate when no collision was detected
    Set<AffinityGroup> violatedAffinityGroups = checkForAffinityGroupViolations(unifiedAffinityGroups, vmToHost, FailMode.GET_ALL);
    if (violatedAffinityGroups.isEmpty()) {
        log.debug("No affinity group collision detected for cluster {}. Standing by.", vdsGroup.getId());
        return null;
    }
    // Find a VM that is breaking the affinityGroup and can be theoretically migrated
    // - start with bigger Affinity Groups
    List<AffinityGroup> affGroupsBySize = new ArrayList<>(violatedAffinityGroups);
    Collections.sort(affGroupsBySize, Collections.reverseOrder(new AffinityGroupComparator()));
    for (AffinityGroup affinityGroup : affGroupsBySize) {
        final List<VM> candidateVms;
        if (affinityGroup.isPositive()) {
            candidateVms = vmDao.getVmsByIds(findVmViolatingPositiveAg(affinityGroup, vmToHost));
            log.info("Positive affinity group violation detected");
        } else {
            candidateVms = vmDao.getVmsByIds(findVmViolatingNegativeAg(affinityGroup, vmToHost));
            log.info("Negative affinity group violation detected");
        }
        while (!candidateVms.isEmpty()) {
            final int index = random.nextInt(candidateVms.size());
            final VM candidateVm = candidateVms.get(index);
            // Test whether any migration is possible, this uses current AffinityGroup settings
            // and so won't allow more breakage
            boolean canMove = schedulingManager.canSchedule(vdsGroup, candidateVm, new ArrayList<Guid>(), new ArrayList<Guid>(), null, new ArrayList<String>());
            if (canMove) {
                log.debug("VM {} is a viable candidate for solving affinity group violation situation.", candidateVm.getId());
                return candidateVm;
            }
            log.debug("VM {} is NOT a viable candidate for solving affinity group violation situation.", candidateVm.getId());
            candidateVms.remove(index);
        }
    }
    // No possible migration..
    return null;
}
#end_block

#method_before
@Test
public void shouldSelectFirstSchedulableFromCandidatePool() {
    affinityGroups.add(createAffinityGroup(vdsGroup, true, vm1, vm2, vm3, vm5, vm6));
    when(schedulingManager.canSchedule(eq(vdsGroup), any(VM.class), anyList(), anyList(), anyList(), anyList())).thenReturn(false, true);
    assertTrue(Arrays.asList(vm5, vm6).contains(enforcer.chooseNextVmToMigrate(vdsGroup)));
    verify(schedulingManager).canSchedule(eq(vdsGroup), eq(vm5), anyList(), anyList(), anyList(), anyList());
    verify(schedulingManager).canSchedule(eq(vdsGroup), eq(vm6), anyList(), anyList(), anyList(), anyList());
}
#method_after
@Test
public void shouldSelectFirstSchedulableFromCandidatePool() {
    // Because three VMs are running on host1 and only two Vms (vm5 and vm6) are running on host3
    // the enforcer will detect vm5 and vm6 as possible candidates for migration
    affinityGroups.add(createAffinityGroup(vdsGroup, true, vm1, vm2, vm3, vm5, vm6));
    // Say no to the first scheduling attempt and yes to the second one, to force the enforcer
    // to check every possible candidate
    when(schedulingManager.canSchedule(eq(vdsGroup), any(VM.class), anyList(), anyList(), anyList(), anyList())).thenReturn(false, true);
    // There is no fixed order so we only know that one of those VMs will be selected for migration
    assertTrue(Arrays.asList(vm5, vm6).contains(enforcer.chooseNextVmToMigrate(vdsGroup)));
    // Verify that the enforcer tried to schedule both candidate VMs.
    verify(schedulingManager).canSchedule(eq(vdsGroup), eq(vm5), anyList(), anyList(), anyList(), anyList());
    verify(schedulingManager).canSchedule(eq(vdsGroup), eq(vm6), anyList(), anyList(), anyList(), anyList());
}
#end_block

#method_before
private void prepareVmDao(VM... vmList) {
    List<VM> vms = Arrays.asList(vmList);
    when(vmDao.getVmsByIds(anyList())).thenReturn(vms);
    for (VM vm : vms) {
        when(vmDao.get(eq(vm.getId()))).thenReturn(vm);
    }
}
#method_after
private void prepareVmDao(VM... vmList) {
    final List<VM> vms = Arrays.asList(vmList);
    doAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocation) throws Throwable {
            final List<VM> selectedVms = new ArrayList<>();
            final Set<Guid> vmIds = new HashSet<>((List<Guid>) invocation.getArguments()[0]);
            for (VM vm : vms) {
                if (vmIds.contains(vm.getId())) {
                    selectedVms.add(vm);
                }
            }
            return selectedVms;
        }
    }).when(vmDao).getVmsByIds(anyList());
    for (VM vm : vmList) {
        when(vmDao.get(eq(vm.getId()))).thenReturn(vm);
    }
}
#end_block

#method_before
private void initGraphicsData() {
    ImportUtils.updateGraphicsDevices(getVm().getStaticData(), getVdsGroup() != null ? getVdsGroup().getCompatibilityVersion() : null);
}
#method_after
private void initGraphicsData() {
    ImportUtils.updateGraphicsDevices(getVm().getStaticData(), getVdsGroup().getCompatibilityVersion());
}
#end_block

#method_before
void proceedDownVms() {
    if (vdsmVm != null && vdsmVm.getVmDynamic().getStatus() == VMStatus.Down) {
        VMStatus status = VMStatus.Unassigned;
        if (dbVm != null) {
            status = dbVm.getStatus();
            proceedVmBeforeDeletion();
            // when going to suspend, delete vm from cache later
            if (status == VMStatus.SavingState) {
                vmsMonitoring.getResourceManager().InternalSetVmStatus(dbVm, VMStatus.Suspended);
            }
            clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
        }
        VmStatistics vmStatistics = vmsMonitoring.getDbFacade().getVmStatisticsDao().get(vdsmVm.getVmDynamic().getId());
        if (vmStatistics != null) {
            vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.Destroy, new DestroyVmVDSCommandParameters(getVdsManager().getVdsId(), vdsmVm.getVmDynamic().getId(), false, false, 0));
            if (dbVm != null && status == VMStatus.SavingState) {
                afterSuspendTreatment(vdsmVm.getVmDynamic());
            } else if (status != VMStatus.MigratingFrom) {
                handleVmOnDown(dbVm, vdsmVm.getVmDynamic(), vmStatistics);
            }
        }
    }
}
#method_after
void proceedDownVms() {
    if (vdsmVm != null && vdsmVm.getVmDynamic().getStatus() == VMStatus.Down) {
        VMStatus prevStatus = VMStatus.Unassigned;
        if (dbVm != null) {
            prevStatus = dbVm.getStatus();
            proceedVmBeforeDeletion();
            // when going to suspend, delete vm from cache later
            if (prevStatus == VMStatus.SavingState) {
                vmsMonitoring.getResourceManager().internalSetVmStatus(dbVm, VMStatus.Suspended);
            }
            clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
        } else {
            VmDynamic dynamicFromDb = getDbFacade().getVmDynamicDao().get(vdsmVm.getVmDynamic().getId());
            if (dynamicFromDb != null) {
                prevStatus = dynamicFromDb.getStatus();
            }
        }
        if (prevStatus != VMStatus.Unassigned) {
            vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.Destroy, new DestroyVmVDSCommandParameters(getVdsManager().getVdsId(), vdsmVm.getVmDynamic().getId(), false, false, 0));
            if (dbVm != null && prevStatus == VMStatus.SavingState) {
                afterSuspendTreatment(vdsmVm.getVmDynamic());
            } else if (prevStatus != VMStatus.MigratingFrom) {
                handleVmOnDown(dbVm, vdsmVm.getVmDynamic());
            }
        }
    }
}
#end_block

#method_before
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    // which is different than the one it should be running on (must be in migration process)
    if (cacheVm != null) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
    }
    if (exitStatus != VmExitStatus.Normal) {
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (vmsMonitoring.getResourceManager().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.info("Running on vds during rerun failed vm: '{}'", vmDynamic.getRunOnVds());
                rerun = true;
            } else if (cacheVm.isAutoStartup()) {
                autoVmToRun = true;
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            saveDynamic(vdsmVm.getVmDynamic());
        }
    } else {
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        vmsMonitoring.getResourceManager().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#method_after
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    // which is different than the one it should be running on (must be in migration process)
    if (cacheVm != null) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmDynamic.getId());
    }
    if (exitStatus != VmExitStatus.Normal) {
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (vmsMonitoring.getResourceManager().isVmInAsyncRunningList(vmDynamic.getId())) {
                log.info("Running on vds during rerun failed vm: '{}'", vmDynamic.getRunOnVds());
                rerun = true;
            } else if (cacheVm.isAutoStartup()) {
                autoVmToRun = true;
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().removeAsyncRunningVm(vmDynamic.getId());
            saveDynamic(vdsmVm.getVmDynamic());
        }
    } else {
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        vmsMonitoring.getResourceManager().removeAsyncRunningVm(vmDynamic.getId());
    }
}
#end_block

#method_before
private void afterSuspendTreatment(VmDynamic vm) {
    AuditLogType type = vm.getExitStatus() == VmExitStatus.Normal ? AuditLogType.USER_SUSPEND_VM_OK : AuditLogType.USER_FAILED_SUSPEND_VM;
    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), vm.getId());
    auditLog(logable, type);
    ResourceManager.getInstance().RemoveAsyncRunningVm(vm.getId());
}
#method_after
private void afterSuspendTreatment(VmDynamic vm) {
    AuditLogType type = vm.getExitStatus() == VmExitStatus.Normal ? AuditLogType.USER_SUSPEND_VM_OK : AuditLogType.USER_FAILED_SUSPEND_VM;
    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), vm.getId());
    auditLog(logable, type);
    ResourceManager.getInstance().removeAsyncRunningVm(vm.getId());
}
#end_block

#method_before
private void clearVm(VmExitStatus exitStatus, String exitMessage, VmExitReason vmExistReason) {
    if (dbVm.getStatus() != VMStatus.MigratingFrom) {
        // we will add it to vmDynamicToSave though because it might been removed from it in #updateRepository
        if (dbVm.getStatus() != VMStatus.Suspended && dbVm.getStatus() != VMStatus.Down) {
            vmsMonitoring.getResourceManager().InternalSetVmStatus(dbVm, VMStatus.Down, exitStatus, exitMessage, vmExistReason);
        }
        saveDynamic(dbVm.getDynamicData());
        saveStatistics();
        saveVmInterfaces();
        if (!vmsMonitoring.getResourceManager().IsVmInAsyncRunningList(dbVm.getId())) {
            movedToDown = true;
        }
    }
}
#method_after
private void clearVm(VmExitStatus exitStatus, String exitMessage, VmExitReason vmExistReason) {
    if (dbVm.getStatus() != VMStatus.MigratingFrom) {
        // we will add it to vmDynamicToSave though because it might been removed from it in #updateRepository
        if (dbVm.getStatus() != VMStatus.Suspended && dbVm.getStatus() != VMStatus.Down) {
            vmsMonitoring.getResourceManager().internalSetVmStatus(dbVm, VMStatus.Down, exitStatus, exitMessage, vmExistReason);
        }
        saveDynamic(dbVm.getDynamicData());
        saveStatistics();
        saveVmInterfaces();
        if (!vmsMonitoring.getResourceManager().isVmInAsyncRunningList(dbVm.getId())) {
            movedToDown = true;
        }
    }
}
#end_block

#method_before
// TODO Method with Side-Effect - move to VmsMonitoring
private void proceedVmBeforeDeletion() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
    switch(dbVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vdsmVm.getVmDynamic() != null && vdsmVm.getVmDynamic().getExitStatus() != VmExitStatus.Normal) {
                    if (dbVm.getMigratingToVds() != null) {
                        VDSReturnValue destoryReturnValue = vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(new Guid(dbVm.getMigratingToVds().toString()), dbVm.getId(), true, false, 0));
                        if (destoryReturnValue.getSucceeded()) {
                            log.info("Stopped migrating VM: '{}' on VDS: '{}'", dbVm.getName(), dbVm.getMigratingToVds());
                        } else {
                            log.info("Could not stop migrating VM: '{}' on VDS: '{}', Error: '{}'", dbVm.getName(), dbVm.getMigratingToVds(), destoryReturnValue.getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(dbVm, VMStatus.Down, vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
                    saveDynamic(dbVm.getDynamicData());
                    saveStatistics();
                    saveVmInterfaces();
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vdsmVm.getVmDynamic().getExitMessage());
                    vmsMonitoring.getResourceManager().RemoveAsyncRunningVm(vdsmVm.getVmDynamic().getId());
                }
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#method_after
// TODO Method with Side-Effect - move to VmsMonitoring
private void proceedVmBeforeDeletion() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
    switch(dbVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vdsmVm.getVmDynamic() != null && vdsmVm.getVmDynamic().getExitStatus() != VmExitStatus.Normal) {
                    if (dbVm.getMigratingToVds() != null) {
                        VDSReturnValue destoryReturnValue = vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(new Guid(dbVm.getMigratingToVds().toString()), dbVm.getId(), true, false, 0));
                        if (destoryReturnValue.getSucceeded()) {
                            log.info("Stopped migrating VM: '{}' on VDS: '{}'", dbVm.getName(), dbVm.getMigratingToVds());
                        } else {
                            log.info("Could not stop migrating VM: '{}' on VDS: '{}', Error: '{}'", dbVm.getName(), dbVm.getMigratingToVds(), destoryReturnValue.getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().internalSetVmStatus(dbVm, VMStatus.Down, vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
                    saveDynamic(dbVm.getDynamicData());
                    saveStatistics();
                    saveVmInterfaces();
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vdsmVm.getVmDynamic().getExitMessage());
                    vmsMonitoring.getResourceManager().removeAsyncRunningVm(vdsmVm.getVmDynamic().getId());
                }
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#end_block

#method_before
private void proceedBalloonCheck() {
    if (getVdsManager().getCopyVds().isBalloonEnabled()) {
        VmBalloonInfo balloonInfo = vdsmVm.getVmStatistics().getVmBalloonInfo();
        Guid vmId = vdsmVm.getVmDynamic().getId();
        if (dbVm == null) {
            return;
        }
        /* last memory is null the first time we check it or when
               we're not getting the balloon info from vdsm
            */
        if (balloonInfo.getBalloonLastMemory() == null || balloonInfo.getBalloonLastMemory() == 0) {
            balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
            return;
        }
        if (isBalloonDeviceActiveOnVm(vdsmVm) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !isBalloonWorking(balloonInfo))) {
            vmBalloonDriverIsRequestedAndUnavailable(vmId);
        } else {
            vmBalloonDriverIsNotRequestedOrAvailable(vmId);
        }
        // save the current value for the next time we check it
        balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
        if (vdsmVm.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
        vdsmVm.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
        balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
            guestAgentIsDownAndBalloonInfalted(vmId);
        } else {
            guestAgentIsUpOrBalloonDeflated(vmId);
        }
    }
}
#method_after
private void proceedBalloonCheck() {
    if (getVdsManager().getCopyVds().isBalloonEnabled()) {
        if (dbVm == null || vdsmVm == null) {
            return;
        }
        VmBalloonInfo balloonInfo = vdsmVm.getVmStatistics().getVmBalloonInfo();
        if (balloonInfo == null) {
            return;
        }
        Guid vmId = vdsmVm.getVmDynamic().getId();
        /* last memory is null the first time we check it or when
               we're not getting the balloon info from vdsm
            */
        if (balloonInfo.getBalloonLastMemory() == null || balloonInfo.getBalloonLastMemory() == 0) {
            balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
            return;
        }
        if (isBalloonDeviceActiveOnVm(vdsmVm) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !isBalloonWorking(balloonInfo))) {
            vmBalloonDriverIsRequestedAndUnavailable(vmId);
        } else {
            vmBalloonDriverIsNotRequestedOrAvailable(vmId);
        }
        // save the current value for the next time we check it
        balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
        if (vdsmVm.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
        vdsmVm.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
        balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
            guestAgentIsDownAndBalloonInfalted(vmId);
        } else {
            guestAgentIsUpOrBalloonDeflated(vmId);
        }
    }
}
#end_block

#method_before
private void updateRepository() {
    if (vdsmVm != null) {
        VmDynamic vdsmVmDynamic = vdsmVm.getVmDynamic();
        // if not migrating here and not down
        if (!inMigrationTo(vdsmVmDynamic, dbVm) && vdsmVmDynamic.getStatus() != VMStatus.Down) {
            if (dbVm != null) {
                if (!StringUtils.equals(vdsmVmDynamic.getClientIp(), dbVm.getClientIp())) {
                    clientIpChanged = true;
                }
            }
            if (dbVm != null) {
                logVmStatusTransition();
                if (dbVm.getStatus() != VMStatus.Up && vdsmVmDynamic.getStatus() == VMStatus.Up || dbVm.getStatus() != VMStatus.PoweringUp && vdsmVmDynamic.getStatus() == VMStatus.PoweringUp) {
                    poweringUp = true;
                }
                // "Up" as this means that the power down operation failed:
                if (dbVm.getStatus() == VMStatus.PoweringDown && vdsmVmDynamic.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (dbVm.getStatus() != VMStatus.Up && dbVm.getStatus() != VMStatus.MigratingFrom && vdsmVmDynamic.getStatus() == VMStatus.Up) {
                    // Vm moved to Up status - remove its record from Async
                    // reportedAndUnchangedVms handling
                    log.debug("removing VM '{}' from successful run VMs list", dbVm.getId());
                    succeededToRun = true;
                }
                afterMigrationFrom(vdsmVmDynamic, dbVm);
                if (dbVm.getStatus() != VMStatus.NotResponding && vdsmVmDynamic.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (vdsmVmDynamic.getStatus() == VMStatus.Paused) {
                    removeFromAsync = true;
                    if (dbVm.getStatus() != VMStatus.Paused) {
                        AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                        auditLog(logable, AuditLogType.VM_PAUSED);
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(vdsmVmDynamic.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (dbVm != null || vdsmVmDynamic.getStatus() != VMStatus.MigratingFrom) {
                if (updateVmRunTimeInfo()) {
                    saveDynamic(dbVm.getDynamicData());
                }
            }
            if (dbVm != null) {
                updateVmStatistics();
                stable = true;
                if (!getVdsManager().isInitialized()) {
                    vmsMonitoring.getResourceManager().RemoveVmFromDownVms(getVdsManager().getVdsId(), vdsmVmDynamic.getId());
                }
            }
        } else {
            if (vdsmVmDynamic.getStatus() == VMStatus.MigratingTo) {
                stable = true;
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(vdsmVmDynamic.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                saveDynamic(null);
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache();
}
#method_after
private void updateRepository() {
    if (vdsmVm != null) {
        VmDynamic vdsmVmDynamic = vdsmVm.getVmDynamic();
        // if not migrating here and not down
        if (!inMigrationTo(vdsmVmDynamic, dbVm) && vdsmVmDynamic.getStatus() != VMStatus.Down) {
            if (dbVm != null) {
                if (!StringUtils.equals(vdsmVmDynamic.getClientIp(), dbVm.getClientIp())) {
                    clientIpChanged = true;
                }
            }
            if (dbVm != null) {
                logVmStatusTransition();
                if (dbVm.getStatus() != VMStatus.Up && vdsmVmDynamic.getStatus() == VMStatus.Up || dbVm.getStatus() != VMStatus.PoweringUp && vdsmVmDynamic.getStatus() == VMStatus.PoweringUp) {
                    poweringUp = true;
                }
                // "Up" as this means that the power down operation failed:
                if (dbVm.getStatus() == VMStatus.PoweringDown && vdsmVmDynamic.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                // log vm recovered from error
                if (dbVm.getStatus() == VMStatus.Paused && dbVm.getVmPauseStatus().isError() && vdsmVmDynamic.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                    auditLog(logable, AuditLogType.VM_RECOVERED_FROM_PAUSE_ERROR);
                }
                if (dbVm.getStatus() != VMStatus.Up && dbVm.getStatus() != VMStatus.MigratingFrom && vdsmVmDynamic.getStatus() == VMStatus.Up) {
                    // Vm moved to Up status - remove its record from Async
                    // reportedAndUnchangedVms handling
                    log.debug("removing VM '{}' from successful run VMs list", dbVm.getId());
                    succeededToRun = true;
                }
                afterMigrationFrom(vdsmVmDynamic, dbVm);
                if (dbVm.getStatus() != VMStatus.NotResponding && vdsmVmDynamic.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (vdsmVmDynamic.getStatus() == VMStatus.Paused) {
                    removeFromAsync = true;
                    if (dbVm.getStatus() != VMStatus.Paused) {
                        AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                        auditLog(logable, AuditLogType.VM_PAUSED);
                        // check exit message to determine why the VM is paused
                        if (vdsmVmDynamic.getPauseStatus().isError()) {
                            AuditLogType logType = vmPauseStatusToAuditLogType(vdsmVmDynamic.getPauseStatus());
                            logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (dbVm != null || vdsmVmDynamic.getStatus() != VMStatus.MigratingFrom) {
                if (updateVmRunTimeInfo()) {
                    saveDynamic(dbVm.getDynamicData());
                }
            }
            if (dbVm != null) {
                updateVmStatistics();
                stable = true;
                if (!getVdsManager().isInitialized()) {
                    vmsMonitoring.getResourceManager().removeVmFromDownVms(getVdsManager().getVdsId(), vdsmVmDynamic.getId());
                }
            }
        } else {
            if (vdsmVmDynamic.getStatus() == VMStatus.MigratingTo) {
                stable = true;
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(vdsmVmDynamic.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                saveDynamic(null);
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache();
}
#end_block

#method_before
private void removeVmsFromCache() {
    if (dbVm != null && !stable) {
        proceedVmBeforeDeletion();
        boolean migrating = dbVm.getStatus() == VMStatus.MigratingFrom;
        if (migrating) {
            handOverVM(dbVm);
        } else {
            clearVm(VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", dbVm.getName()), VmExitReason.GenericError);
        }
        log.info("VM '{}({}) is running in db and not running in VDS '{}'", dbVm.getId(), dbVm.getName(), getVdsManager().getVdsName());
        if (!migrating && !rerun && vmsMonitoring.getResourceManager().IsVmInAsyncRunningList(dbVm.getId())) {
            rerun = true;
            log.info("add VM '{}' to rerun treatment", dbVm.getName());
        } else // or reported from vdsm with error code
        if (dbVm.isAutoStartup() && !autoVmToRun && (vdsmVm == null || vdsmVm.getVmDynamic().getExitStatus() != VmExitStatus.Normal)) {
            autoVmToRun = true;
            log.info("add VM '{}' to HA rerun treatment", dbVm.getName());
        }
    }
}
#method_after
private void removeVmsFromCache() {
    if (dbVm != null && !stable) {
        // marks the vm was powered down by user but not reported as Down afterwards by vdsm
        boolean poweredDown = false;
        proceedVmBeforeDeletion();
        boolean migrating = dbVm.getStatus() == VMStatus.MigratingFrom;
        if (migrating) {
            handOverVM(dbVm);
        } else if (dbVm.getStatus() == VMStatus.PoweringDown) {
            poweredDown = true;
            clearVm(VmExitStatus.Normal, String.format("VM %s shutdown complete", dbVm.getName()), VmExitReason.Success);
        } else {
            clearVm(VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", dbVm.getName()), VmExitReason.GenericError);
        }
        log.info("VM '{}({}) is running in db and not running in VDS '{}'", dbVm.getId(), dbVm.getName(), getVdsManager().getVdsName());
        if (!migrating && !rerun && vmsMonitoring.getResourceManager().isVmInAsyncRunningList(dbVm.getId())) {
            rerun = true;
            log.info("add VM '{}' to rerun treatment", dbVm.getName());
        } else // or reported from vdsm with error code
        if (dbVm.isAutoStartup() && !autoVmToRun && (vdsmVm == null || vdsmVm.getVmDynamic().getExitStatus() != VmExitStatus.Normal) && !poweredDown) {
            autoVmToRun = true;
            log.info("add VM '{}' to HA rerun treatment", dbVm.getName());
        }
    }
}
#end_block

#method_before
private void handOverVM(VM vmToRemove) {
    Guid destinationHostId = vmToRemove.getMigratingToVds();
    // when the destination VDS is NonResponsive put the VM to Uknown like the rest of its VMs, else MigratingTo
    VMStatus newVmStatus = (VDSStatus.NonResponsive == getDbFacade().getVdsDao().get(destinationHostId).getStatus()) ? VMStatus.Unknown : VMStatus.MigratingTo;
    // handing over the VM to the DST by marking it running on it. it will now be its SRC host.
    vmToRemove.setRunOnVds(destinationHostId);
    log.info("Handing over VM '{}'({}) to Host '{}'. Setting VM to status '{}'", vmToRemove.getName(), vmToRemove.getId(), destinationHostId, newVmStatus);
    // if the DST host goes unresponsive it will take care all MigratingTo and unknown VMs
    vmsMonitoring.getResourceManager().InternalSetVmStatus(vmToRemove, newVmStatus);
    // save the VM state
    saveDynamic(vmToRemove.getDynamicData());
    saveStatistics();
    saveVmInterfaces();
}
#method_after
private void handOverVM(VM vmToRemove) {
    Guid destinationHostId = vmToRemove.getMigratingToVds();
    // when the destination VDS is NonResponsive put the VM to Uknown like the rest of its VMs, else MigratingTo
    VMStatus newVmStatus = (VDSStatus.NonResponsive == getDbFacade().getVdsDao().get(destinationHostId).getStatus()) ? VMStatus.Unknown : VMStatus.MigratingTo;
    // handing over the VM to the DST by marking it running on it. it will now be its SRC host.
    vmToRemove.setRunOnVds(destinationHostId);
    log.info("Handing over VM '{}'({}) to Host '{}'. Setting VM to status '{}'", vmToRemove.getName(), vmToRemove.getId(), destinationHostId, newVmStatus);
    // if the DST host goes unresponsive it will take care all MigratingTo and unknown VMs
    vmsMonitoring.getResourceManager().internalSetVmStatus(vmToRemove, newVmStatus);
    // save the VM state
    saveDynamic(vmToRemove.getDynamicData());
    saveStatistics();
    saveVmInterfaces();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Disk disk = getDiskDao().get(getParameters().getImageGroupID());
    DiskValidator diskValidator = new DiskValidator(disk);
    return validate(diskValidator.validateDiskIsNotLun()) && validate(diskValidator.validateDiskIsNotCinder());
}
#method_after
@Override
protected boolean canDoAction() {
    Disk disk = getDiskDao().get(getParameters().getImageGroupID());
    if (disk != null) {
        DiskValidator diskValidator = new DiskValidator(disk);
        return validate(diskValidator.validateUnsupportedDiskStorageType(DiskStorageType.LUN, DiskStorageType.CINDER));
    }
    return false;
}
#end_block

#method_before
@Test
public void canDoActionFailureOnMovingLunDisk() {
    MoveDiskParameters moveDiskParameters1 = new MoveDiskParameters(Guid.newGuid(), srcStorageId, dstStorageId);
    command.getParameters().setParametersList(Collections.singletonList(moveDiskParameters1));
    initLunDisk();
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_LUN_DISK);
}
#method_after
@Test
public void canDoActionFailureOnMovingLunDisk() {
    MoveDiskParameters moveDiskParameters1 = new MoveDiskParameters(Guid.newGuid(), srcStorageId, dstStorageId);
    command.getParameters().setParametersList(Collections.singletonList(moveDiskParameters1));
    initLunDisk();
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_NOT_SUPPORTED_DISK_STORAGE_TYPE);
}
#end_block

#method_before
@Test
public void canDoActionFailureOnMovingCinderDisk() {
    MoveDiskParameters moveDiskParameters = new MoveDiskParameters(Guid.newGuid(), srcStorageId, dstStorageId);
    command.getParameters().setParametersList(Collections.singletonList(moveDiskParameters));
    initCinderDisk();
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_CINDER_DISK);
}
#method_after
@Test
public void canDoActionFailureOnMovingCinderDisk() {
    MoveDiskParameters moveDiskParameters = new MoveDiskParameters(Guid.newGuid(), srcStorageId, dstStorageId);
    command.getParameters().setParametersList(Collections.singletonList(moveDiskParameters));
    initCinderDisk();
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_NOT_SUPPORTED_DISK_STORAGE_TYPE);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getParameters().getParametersList().isEmpty()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NO_DISKS_SPECIFIED);
    }
    return verifyNoUnsupportedDisks();
}
#method_after
@Override
protected boolean canDoAction() {
    if (getParameters().getParametersList().isEmpty()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NO_DISKS_SPECIFIED);
    }
    return verifyUnsupportedDisks();
}
#end_block

#method_before
@Test
public void canDoActionFailureOnMovingLunDisk() {
    initializeCommand(ImageOperation.Move, new LunDisk());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_LUN_DISK);
}
#method_after
@Test
public void canDoActionFailureOnMovingLunDisk() {
    initializeCommand(ImageOperation.Move, new LunDisk());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_NOT_SUPPORTED_DISK_STORAGE_TYPE);
}
#end_block

#method_before
@Test
public void canDoActionFailureOnCopyingLunDisk() {
    initializeCommand(ImageOperation.Copy, new LunDisk());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_LUN_DISK);
}
#method_after
@Test
public void canDoActionFailureOnCopyingLunDisk() {
    initializeCommand(ImageOperation.Copy, new LunDisk());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_NOT_SUPPORTED_DISK_STORAGE_TYPE);
}
#end_block

#method_before
@Test
public void canDoActionFailureOnMovingVmLunDisk() {
    initializeCommand(ImageOperation.Move, new LunDisk());
    vmDevice.setSnapshotId(Guid.newGuid());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_LUN_DISK);
}
#method_after
@Test
public void canDoActionFailureOnMovingVmLunDisk() {
    initializeCommand(ImageOperation.Move, new LunDisk());
    vmDevice.setSnapshotId(Guid.newGuid());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_NOT_SUPPORTED_DISK_STORAGE_TYPE);
}
#end_block

#method_before
@Test
public void canDoActionFailureOnMovingCinderDisk() {
    initializeCommand(ImageOperation.Move, new CinderDisk());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_CINDER_DISK);
}
#method_after
@Test
public void canDoActionFailureOnMovingCinderDisk() {
    initializeCommand(ImageOperation.Move, new CinderDisk());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_NOT_SUPPORTED_DISK_STORAGE_TYPE);
}
#end_block

#method_before
@Test
public void canDoActionFailureOnCopyingCinderDisk() {
    initializeCommand(ImageOperation.Copy, new CinderDisk());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_CINDER_DISK);
}
#method_after
@Test
public void canDoActionFailureOnCopyingCinderDisk() {
    initializeCommand(ImageOperation.Copy, new CinderDisk());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_NOT_SUPPORTED_DISK_STORAGE_TYPE);
}
#end_block

#method_before
private void updateClusterList(HostModel hostModel, List<VDSGroup> clusters) {
    VDSGroup oldCluster = hostModel.getCluster().getSelectedItem();
    hostModel.getCluster().setItems(clusters);
    if (oldCluster != null) {
        VDSGroup newSelectedItem = Linq.firstOrDefault(clusters, new Linq.ClusterPredicate(oldCluster.getId()));
        if (newSelectedItem != null) {
            hostModel.getCluster().setSelectedItem(newSelectedItem);
        }
    }
    if (hostModel.getCluster().getSelectedItem() == null) {
        hostModel.getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
}
#method_after
private void updateClusterList(HostModel hostModel, List<VDSGroup> clusters) {
    VDSGroup oldCluster = hostModel.getCluster().getSelectedItem();
    List<VDSGroup> filteredClusters = filterClusters(clusters, hostModel.getDataCenter().getItems());
    hostModel.getCluster().setItems(filteredClusters);
    if (oldCluster != null) {
        VDSGroup newSelectedItem = Linq.firstOrDefault(filteredClusters, new Linq.ClusterPredicate(oldCluster.getId()));
        if (newSelectedItem != null) {
            hostModel.getCluster().setSelectedItem(newSelectedItem);
        }
    }
    if (hostModel.getCluster().getSelectedItem() == null) {
        hostModel.getCluster().setSelectedItem(Linq.firstOrDefault(filteredClusters));
    }
}
#end_block

#method_before
private boolean checkIfModelIsDuplicate(FenceAgentModel model, FenceAgentModel concurrentExistingModel) {
    if (model.getManagementIp().getEntity().equals(concurrentExistingModel.getManagementIp().getEntity())) {
        // Force a change event by setting to true, which will change to false below.
        model.getManagementIp().setIsValid(true);
        model.getManagementIp().getInvalidityReasons().clear();
        // Duplicate.
        model.getManagementIp().getInvalidityReasons().add(constants.duplicateFenceAgentManagementIp());
        model.getManagementIp().setIsValid(false);
    }
    return model.getManagementIp().getIsValid();
}
#method_after
private boolean checkIfModelIsDuplicate(FenceAgentModel model, FenceAgentModel concurrentExistingModel) {
    if (model.getManagementIp().getEntity().equals(concurrentExistingModel.getManagementIp().getEntity())) {
        // Force a change event by setting to true, which will change to false below.
        model.getManagementIp().setIsValid(true);
        // Duplicate, need to set the invalidity reason before switching to false to update the widgets properly.
        model.getManagementIp().getInvalidityReasons().add(constants.duplicateFenceAgentManagementIp());
        model.getManagementIp().setIsValid(false);
    }
    return model.getManagementIp().getIsValid();
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    Guid storageDomainId = getParameters().getStorageDomainId();
    Guid diskId = getParameters().getDiskId();
    StorageDomain storageDomain = getDbFacade().getStorageDomainDao().get(storageDomainId);
    if (storageDomain == null) {
        getQueryReturnValue().setExceptionString(EngineMessage.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    if (storageDomain.getStorageType().isCinderDomain()) {
        VdcQueryReturnValue returnValue = runInternalQuery(VdcQueryType.GetUnregisteredCinderDiskByIdAndStorageDomainId, new GetCinderEntityByStorageDomainIdParameters(diskId, getParameters().getStorageDomainId()));
        setReturnValue(returnValue.getReturnValue());
        return;
    }
    // Now get the list of volumes for each new image.
    StoragePoolDomainAndGroupIdBaseVDSCommandParameters getVolumesParameters = new StoragePoolDomainAndGroupIdBaseVDSCommandParameters(storagePoolId, storageDomainId, diskId);
    VDSReturnValue volumesListReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetVolumesList, getVolumesParameters);
    if (!volumesListReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(volumesListReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    @SuppressWarnings("unchecked")
    List<Guid> volumesList = (List<Guid>) volumesListReturn.getReturnValue();
    // image. If there are multiple volumes, skip the image and move on to the next.
    if (volumesList.size() != 1) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    Guid volumeId = volumesList.get(0);
    // Get the information about the volume from VDSM.
    GetImageInfoVDSCommandParameters imageInfoParameters = new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskId, volumeId);
    VDSReturnValue imageInfoReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetImageInfo, imageInfoParameters);
    if (!imageInfoReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(imageInfoReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    DiskImage newDiskImage = (DiskImage) imageInfoReturn.getReturnValue();
    if (StringUtils.isNotEmpty(newDiskImage.getDescription())) {
        try {
            ImagesHandler.enrichDiskByJsonDescription(newDiskImage.getDescription(), newDiskImage);
        } catch (IOException | DecoderException e) {
            log.warn("Exception while parsing JSON for disk. Exception: '{}'", e);
        }
    }
    // The disk image won't have an interface set on it. Set it to IDE by default. When the
    // disk is attached to a VM, its interface can be changed to the appropriate value for that VM.
    newDiskImage.setDiskInterface(DiskInterface.IDE);
    newDiskImage.setStoragePoolId(storagePoolId);
    getQueryReturnValue().setReturnValue(newDiskImage);
    getQueryReturnValue().setSucceeded(true);
}
#method_after
@Override
protected void executeQueryCommand() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    Guid storageDomainId = getParameters().getStorageDomainId();
    Guid diskId = getParameters().getDiskId();
    StorageDomain storageDomain = getDbFacade().getStorageDomainDao().get(storageDomainId);
    if (storageDomain == null) {
        getQueryReturnValue().setExceptionString(EngineMessage.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    if (storageDomain.getStorageType().isCinderDomain()) {
        VdcQueryReturnValue returnValue = runInternalQuery(VdcQueryType.GetUnregisteredCinderDiskByIdAndStorageDomainId, new GetCinderEntityByStorageDomainIdParameters(diskId, getParameters().getStorageDomainId()));
        setReturnValue(returnValue.getReturnValue());
        return;
    }
    // Now get the list of volumes for each new image.
    StoragePoolDomainAndGroupIdBaseVDSCommandParameters getVolumesParameters = new StoragePoolDomainAndGroupIdBaseVDSCommandParameters(storagePoolId, storageDomainId, diskId);
    VDSReturnValue volumesListReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetVolumesList, getVolumesParameters);
    if (!volumesListReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(volumesListReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    @SuppressWarnings("unchecked")
    List<Guid> volumesList = (List<Guid>) volumesListReturn.getReturnValue();
    // image. If there are multiple volumes, skip the image and move on to the next.
    if (volumesList.size() != 1) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    Guid volumeId = volumesList.get(0);
    // Get the information about the volume from VDSM.
    GetImageInfoVDSCommandParameters imageInfoParameters = new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskId, volumeId);
    VDSReturnValue imageInfoReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetImageInfo, imageInfoParameters);
    if (!imageInfoReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(imageInfoReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    DiskImage newDiskImage = (DiskImage) imageInfoReturn.getReturnValue();
    if (StringUtils.isNotEmpty(newDiskImage.getDescription())) {
        try {
            MetadataDiskDescriptionHandler.getInstance().enrichDiskByJsonDescription(newDiskImage.getDescription(), newDiskImage);
        } catch (IOException | DecoderException e) {
            log.warn("Exception while parsing JSON for disk. Exception: '{}'", e);
        }
    }
    // The disk image won't have an interface set on it. Set it to IDE by default. When the
    // disk is attached to a VM, its interface can be changed to the appropriate value for that VM.
    newDiskImage.setDiskInterface(DiskInterface.IDE);
    newDiskImage.setStoragePoolId(storagePoolId);
    getQueryReturnValue().setReturnValue(newDiskImage);
    getQueryReturnValue().setSucceeded(true);
}
#end_block

#method_before
@Before
public void setUp() {
    disk1 = new DiskImage();
}
#method_after
@Before
public void setUp() {
    disk = new DiskImage();
    metadataDiskDescriptionHandler = spy(MetadataDiskDescriptionHandler.getInstance());
    doReturn(auditLogDirector).when(metadataDiskDescriptionHandler).getAuditLogDirector();
    doNothing().when(auditLogDirector).log(any(AuditLogableBase.class), any(AuditLogType.class));
}
#end_block

#method_before
@Test
public void testJsonDiskDescription() throws IOException {
    disk1.setDiskAlias("DiskAlias");
    disk1.setDiskDescription("DiskDescription");
    assertDiskDescriptionMap(disk1, "DiskAlias", "DiskDescription");
}
#method_after
@Test
public void testJsonDiskDescription() throws IOException {
    disk.setDiskAlias("DiskAlias");
    disk.setDiskDescription("DiskDescription");
    assertDiskDescriptionMap(disk, generateDiskAliasJsonEntry("DiskAlias"), generateDiskDescriptionJsonEntry("DiskDescription"));
}
#end_block

#method_before
@Test
public void testJsonNullDiskDescription() throws IOException {
    disk1.setDiskAlias("DiskAlias");
    disk1.setDiskDescription(null);
    assertDiskDescriptionMap(disk1, "DiskAlias", "");
}
#method_after
@Test
public void testJsonNullDiskDescription() throws IOException {
    disk.setDiskAlias("DiskAlias");
    disk.setDiskDescription(null);
    assertDiskDescriptionMap(disk, generateDiskAliasJsonEntry("DiskAlias"), generateDiskDescriptionJsonEntry(""));
}
#end_block

#method_before
@Test
public void testJsonEmptyDiskDescription() throws IOException {
    disk1.setDiskAlias("DiskAlias");
    disk1.setDiskDescription("");
    assertDiskDescriptionMap(disk1, "DiskAlias", "");
}
#method_after
@Test
public void testJsonEmptyDiskDescription() throws IOException {
    disk.setDiskAlias("DiskAlias");
    disk.setDiskDescription("");
    assertDiskDescriptionMap(disk, generateDiskAliasJsonEntry("DiskAlias"), generateDiskDescriptionJsonEntry(""));
}
#end_block

#method_before
@Test
public void generateDiskDescriptionWhenAliasIsTruncated() throws IOException {
    // Only 173 can be stored.
    disk1.setDiskAlias(DISK_PROPERTY_FOR_TESTING.substring(0, 180));
    disk1.setDiskDescription("DiskDescription");
    // Only first 173 characters were stored from the alias. The description was lost.
    assertDiskDescriptionMap(disk1, DISK_PROPERTY_FOR_TESTING.substring(0, 173), "");
}
#method_after
@Test
public void generateDiskDescriptionWhenAliasIsTruncated() throws IOException {
    String alias = generateRandomString(200);
    // Only 194 can be stored.
    disk.setDiskAlias(alias);
    disk.setDiskDescription("DiskDescription");
    // Only first 194 bytes were stored from the alias. The description was lost.
    assertDiskDescriptionMap(disk, generateDiskAliasJsonEntry(alias.substring(0, DISK_ALIAS_MAX_LENGTH)));
}
#end_block

#method_before
@Test
public void generateDiskDescriptionWhenDescriptionIsCompletelyTruncated() throws IOException {
    String alias = DISK_PROPERTY_FOR_TESTING.substring(0, 173);
    // Exactly the limit.
    disk1.setDiskAlias(alias);
    disk1.setDiskDescription("DiskDescription");
    // Alias was completely stored. The description was lost.
    assertDiskDescriptionMap(disk1, alias, "");
}
#method_after
@Test
public void generateDiskDescriptionWhenDescriptionIsCompletelyTruncated() throws IOException {
    String alias = generateRandomString(DISK_ALIAS_MAX_LENGTH);
    // Exactly the limit.
    disk.setDiskAlias(alias);
    disk.setDiskDescription("DiskDescription");
    // Alias was completely stored. The description was lost.
    assertDiskDescriptionMap(disk, generateDiskAliasJsonEntry(alias));
}
#end_block

#method_before
@Test
public void generateDiskDescriptionWhenDescriptionIsTruncated() throws IOException {
    // Alias.length == 9 characters.
    disk1.setDiskAlias("DiskAlias");
    disk1.setDiskDescription(DISK_PROPERTY_FOR_TESTING.substring(0, 170));
    // Only first 164 characters were stored from the description. The alias was completely stored.
    assertDiskDescriptionMap(disk1, "DiskAlias", DISK_PROPERTY_FOR_TESTING.substring(0, 164));
}
#method_after
@Test
public void generateDiskDescriptionWhenDescriptionIsTruncated() throws IOException {
    // diskAlias.length == 9 characters.
    disk.setDiskAlias("DiskAlias");
    String diskDescription = generateRandomString(170);
    // Only 164 can be stored.
    disk.setDiskDescription(diskDescription);
    // Only first 164 bytes were stored from the description. The alias was completely stored.
    assertDiskDescriptionMap(disk, generateDiskAliasJsonEntry("DiskAlias"), generateDiskDescriptionJsonEntry(diskDescription.substring(0, 164)));
}
#end_block

#method_before
private void assertDiskDescriptionMap(Disk disk, String expectedDiskAlias, String expectedDiskDescription) throws IOException {
    assertEquals("Should be map of disk alias and disk description", String.format("{\"DiskAlias\":\"%s\"," + "\"DiskDescription\":\"%s\"}", expectedDiskAlias, StringUtils.defaultString(expectedDiskDescription)), MetadataDiskDescriptionHandler.generateJsonDiskDescription(disk));
}
#method_after
private void assertDiskDescriptionMap(Disk disk, String... jsonEntries) throws IOException {
    assertEquals(String.format("{%s}", StringUtils.join(jsonEntries, ",", 0, jsonEntries.length)), metadataDiskDescriptionHandler.generateJsonDiskDescription(disk));
}
#end_block

#method_before
private String getJsonDiskDescription() throws IOException {
    return MetadataDiskDescriptionHandler.generateJsonDiskDescription(getParameters().getDiskInfo());
}
#method_after
private String getJsonDiskDescription() throws IOException {
    return MetadataDiskDescriptionHandler.getInstance().generateJsonDiskDescription(getParameters().getDiskInfo());
}
#end_block

#method_before
public static String generateJsonDiskDescription(Disk disk) throws IOException {
    String diskAlias = disk.getDiskAlias();
    String diskDescription = disk.getDiskDescription() != null ? disk.getDiskDescription() : "";
    int diskDescriptionMetadataPotentialLength = METADATA_DESCRIPTION_VALUE_MAX_LENGTH - DESCRIPTION_METADATA_OVERHEAD_LENGTH;
    if (diskAlias.length() <= diskDescriptionMetadataPotentialLength) {
        diskDescriptionMetadataPotentialLength -= diskAlias.length();
        if (diskDescription.length() > diskDescriptionMetadataPotentialLength) {
            diskDescription = diskDescription.substring(0, diskDescriptionMetadataPotentialLength);
            log.warn("Can't store full disk {} description since it's too long. " + "Truncating and storing {}={}.", disk.getId(), DISK_DESCRIPTION, diskDescription);
        }
    } else {
        // Alias is too long and needs to be truncated. The description will be lost.
        diskAlias = diskAlias.substring(0, diskDescriptionMetadataPotentialLength);
        diskDescription = StringUtils.EMPTY;
        log.warn("Can't store full disk {} alias since it's too long. " + "Truncating and storing {}={}.", disk.getId(), DISK_ALIAS, diskAlias);
        log.warn("Can't store disk {} description since the alias is too long. " + "The description will be stored as an empty string.", disk.getId());
    }
    Map<String, Object> description = new TreeMap<>();
    description.put(DISK_ALIAS, diskAlias);
    description.put(DISK_DESCRIPTION, diskDescription);
    return JsonHelper.mapToJson(description, false);
}
#method_after
public String generateJsonDiskDescription(Disk disk) throws IOException {
    Map<String, Object> description = new TreeMap<>();
    description.put(DISK_ALIAS, disk.getDiskAlias());
    description.put(DISK_DESCRIPTION, StringUtils.defaultString(disk.getDiskDescription()));
    return JsonHelper.mapToJson(generateJsonDiskDescription(description, DESCRIPTION_FIELDS_PRIORITY), false);
}
#end_block

#method_before
public static String generateJsonDiskDescription(Disk disk) throws IOException {
    String diskAlias = disk.getDiskAlias();
    String diskDescription = disk.getDiskDescription() != null ? disk.getDiskDescription() : "";
    int diskDescriptionMetadataPotentialLength = METADATA_DESCRIPTION_VALUE_MAX_LENGTH - DESCRIPTION_METADATA_OVERHEAD_LENGTH;
    if (diskAlias.length() <= diskDescriptionMetadataPotentialLength) {
        diskDescriptionMetadataPotentialLength -= diskAlias.length();
        if (diskDescription.length() > diskDescriptionMetadataPotentialLength) {
            diskDescription = diskDescription.substring(0, diskDescriptionMetadataPotentialLength);
            log.warn("Can't store full disk {} description since it's too long. " + "Truncating and storing {}={}.", disk.getId(), DISK_DESCRIPTION, diskDescription);
        }
    } else {
        // Alias is too long and needs to be truncated. The description will be lost.
        diskAlias = diskAlias.substring(0, diskDescriptionMetadataPotentialLength);
        diskDescription = StringUtils.EMPTY;
        log.warn("Can't store full disk {} alias since it's too long. " + "Truncating and storing {}={}.", disk.getId(), DISK_ALIAS, diskAlias);
        log.warn("Can't store disk {} description since the alias is too long. " + "The description will be stored as an empty string.", disk.getId());
    }
    Map<String, Object> description = new TreeMap<>();
    description.put(DISK_ALIAS, diskAlias);
    description.put(DISK_DESCRIPTION, diskDescription);
    return JsonHelper.mapToJson(description, false);
}
#method_after
private Map<String, Object> generateJsonDiskDescription(Map<String, Object> descriptionFields, String... descriptionFieldsPriority) {
    Map<String, Object> descriptionMap = new TreeMap<>();
    int descriptionAvailableLength = METADATA_DESCRIPTION_MAX_LENGTH;
    for (int priority = 0; priority < descriptionFieldsPriority.length; ++priority) {
        String fieldName = descriptionFieldsPriority[priority];
        String fieldValue = descriptionFields.get(fieldName).toString();
        descriptionAvailableLength = addFieldToDescriptionMap(descriptionMap, fieldName, fieldValue, descriptionAvailableLength);
        if (descriptionAvailableLength <= 0) {
            // Storage space limitation reached.
            if (!auditLogIfFieldWasNotAddedSuccessfully(descriptionFields, descriptionMap, fieldName, fieldValue, descriptionFieldsPriority, priority)) {
                break;
            }
        }
    }
    return descriptionMap;
}
#end_block

#method_before
public static void enrichDiskByJsonDescription(String jsonDiskDescription, Disk disk) throws IOException {
    Map<String, Object> diskDescriptionMap = JsonHelper.jsonToMap(jsonDiskDescription);
    disk.setDiskAlias(diskDescriptionMap.get(DISK_ALIAS).toString());
    disk.setDiskDescription(diskDescriptionMap.get(DISK_DESCRIPTION).toString());
}
#method_after
public void enrichDiskByJsonDescription(String jsonDiskDescription, Disk disk) throws IOException {
    Map<String, Object> diskDescriptionMap = JsonHelper.jsonToMap(jsonDiskDescription);
    disk.setDiskAlias((String) diskDescriptionMap.get(DISK_ALIAS));
    disk.setDiskDescription((String) diskDescriptionMap.get(DISK_DESCRIPTION));
}
#end_block

#method_before
protected String getJsonDiskDescription(Disk disk) {
    try {
        return MetadataDiskDescriptionHandler.generateJsonDiskDescription(disk);
    } catch (IOException e) {
        log.error("Exception while generating json for disk. ERROR: '{}'", e);
        return StringUtils.EMPTY;
    }
}
#method_after
protected String getJsonDiskDescription(Disk disk) {
    try {
        return MetadataDiskDescriptionHandler.getInstance().generateJsonDiskDescription(disk);
    } catch (IOException e) {
        log.error("Exception while generating json for disk. ERROR: '{}'", e);
        return StringUtils.EMPTY;
    }
}
#end_block

#method_before
private void assertDiskDescriptionMap(Disk disk) throws IOException {
    assertEquals("Should be map of disk alias and disk description", String.format("{\"DiskAlias\":\"%s\"," + "\"DiskDescription\":\"%s\"}", disk.getDiskAlias(), StringUtils.defaultString(disk.getDiskDescription())), MetadataDiskDescriptionHandler.getJsonDiskDescription(disk));
}
#method_after
private static void assertDiskDescriptionMap(Disk disk) throws IOException {
    assertEquals("Should be map of disk alias and disk description", String.format("{\"DiskAlias\":\"%s\"," + "\"DiskDescription\":\"%s\"}", disk.getDiskAlias(), StringUtils.defaultString(disk.getDiskDescription())), MetadataDiskDescriptionHandler.getJsonDiskDescription(disk));
}
#end_block

#method_before
@Test
public void testJsonDiskDescription() throws IOException {
    disk1.setDiskAlias("DiskAlias");
    disk1.setDiskDescription("DiskDescription");
    assertDiskDescriptionMap();
}
#method_after
@Test
public void testJsonDiskDescription() throws IOException {
    disk1.setDiskAlias("DiskAlias");
    disk1.setDiskDescription("DiskDescription");
    assertDiskDescriptionMap(disk1);
}
#end_block

#method_before
@Test
public void testJsonNullDiskDescription() throws IOException {
    disk1.setDiskAlias("DiskAlias");
    disk1.setDiskDescription(null);
    assertDiskDescriptionMap();
}
#method_after
@Test
public void testJsonNullDiskDescription() throws IOException {
    disk1.setDiskAlias("DiskAlias");
    disk1.setDiskDescription(null);
    assertDiskDescriptionMap(disk1);
}
#end_block

#method_before
@Test
public void testJsonEmptyDiskDescription() throws IOException {
    disk1.setDiskAlias("DiskAlias");
    disk1.setDiskDescription("");
    assertDiskDescriptionMap();
}
#method_after
@Test
public void testJsonEmptyDiskDescription() throws IOException {
    disk1.setDiskAlias("DiskAlias");
    disk1.setDiskDescription("");
    assertDiskDescriptionMap(disk1);
}
#end_block

#method_before
private void assertDiskDescriptionMap() throws IOException {
    assertEquals("Should be map of disk alias and disk description", "{\"" + ImagesHandler.DISK_ALIAS + "\":\"" + disk1.getDiskAlias() + "\"," + "\"" + ImagesHandler.DISK_DESCRIPTION + "\":\"" + StringUtils.defaultString(disk1.getDiskDescription()) + "\"}", ImagesHandler.getJsonDiskDescription(disk1));
}
#method_after
private static void assertDiskDescriptionMap(Disk disk) throws IOException {
    assertEquals("Should be map of disk alias and disk description", String.format("{\"DiskAlias\":\"%s\"," + "\"DiskDescription\":\"%s\"}", disk.getDiskAlias(), StringUtils.defaultString(disk.getDiskDescription())), ImagesHandler.getJsonDiskDescription(disk));
}
#end_block

#method_before
private void assertDiskDescriptionMap(String diskAlias, String diskDescription) throws IOException {
    assertEquals("Should be map of disk alias and disk description", "{\"" + ImagesHandler.DISK_ALIAS + "\":\"" + diskAlias + "\"," + "\"" + ImagesHandler.DISK_DESCRIPTION + "\":\"" + StringUtils.defaultString(diskDescription) + "\"}", ImagesHandler.getJsonDiskDescription(diskAlias, diskDescription));
}
#method_after
private static void assertDiskDescriptionMap(String diskAlias, String diskDescription) throws IOException {
    assertEquals("Should be map of disk alias and disk description", String.format("{\"DiskAlias\":\"%s\"," + "\"DiskDescription\":\"%s\"}", diskAlias, StringUtils.defaultString(diskDescription)), ImagesHandler.getJsonDiskDescription(diskAlias, diskDescription));
}
#end_block

#method_before
public ValidationResult roleNetworkHasIp() {
    if (isRoleNetwork()) {
        final Network network = networkDao.get(networkCluster.getNetworkId());
        final String networkName = network.getName();
        final ValidationResult roleNetworkHasIpOnAttachedNics = roleNetworkHasIpOnAttachedNics(networkName);
        if (!roleNetworkHasIpOnAttachedNics.isValid()) {
            return roleNetworkHasIpOnAttachedNics;
        }
        final ValidationResult roleNetworkHasIpOnLabeledNics = roleNetworkHasIpOnLabeledNics(network);
        if (!roleNetworkHasIpOnLabeledNics.isValid()) {
            return roleNetworkHasIpOnLabeledNics;
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult roleNetworkHasIp() {
    if (NetworkUtils.isRoleNetwork(networkCluster)) {
        final Network network = networkDao.get(networkCluster.getNetworkId());
        final String networkName = network.getName();
        final ValidationResult roleNetworkHasIpOnAttachedNics = roleNetworkHasIpOnAttachedNics(networkName);
        if (!roleNetworkHasIpOnAttachedNics.isValid()) {
            return roleNetworkHasIpOnAttachedNics;
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
protected ValidationResult roleNetworkHasIpOnAttachedNics(String networkName) {
    final VdsNetworkInterface missingIpNic = findMissingIpNic(networkName);
    if (missingIpNic != null) {
        return createMissingIpValidationResult(missingIpNic, networkName);
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult roleNetworkHasIpOnAttachedNics(String networkName) {
    final VdsNetworkInterface missingIpNic = findMissingIpNic(networkName);
    if (missingIpNic != null) {
        return createMissingIpValidationResult(missingIpNic, networkName);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult createMissingIpValidationResult(VdsNetworkInterface missingIpLabeledNic, String networkName) {
    return new ValidationResult(EngineMessage.NETWORK_ADDR_MANDATORY_FOR_ROLE_NETWORK, String.format(NETWORK_NAME_REPLACEMENT, networkName), String.format(NIC_NAME_REPLACEMENT, missingIpLabeledNic.getName()), String.format(HOST_NAME_REPLACEMENT, missingIpLabeledNic.getVdsName()));
}
#method_after
private ValidationResult createMissingIpValidationResult(VdsNetworkInterface missingIpNic, String networkName) {
    return new ValidationResult(EngineMessage.NETWORK_ADDR_MANDATORY_FOR_ROLE_NETWORK, String.format(NETWORK_NAME_REPLACEMENT, networkName), String.format(NIC_NAME_REPLACEMENT, missingIpNic.getName()), String.format(HOST_NAME_REPLACEMENT, missingIpNic.getVdsName()));
}
#end_block

#method_before
private VdsNetworkInterface findMissingIpNic(final String networkName) {
    final List<VdsNetworkInterface> interfacesByClusterId = interfaceDao.getAllInterfacesByClusterId(networkCluster.getClusterId());
    final VdsNetworkInterface missingIpNic = LinqUtils.firstOrNull(interfacesByClusterId, new Predicate<VdsNetworkInterface>() {

        @Override
        public boolean eval(VdsNetworkInterface nic) {
            return networkName.equals(nic.getNetworkName()) && StringUtils.isNotEmpty(nic.getAddress());
        }
    });
    return missingIpNic;
}
#method_after
private VdsNetworkInterface findMissingIpNic(final String networkName) {
    final List<VdsNetworkInterface> interfacesByClusterId = interfaceDao.getAllInterfacesByClusterId(networkCluster.getClusterId());
    final VdsNetworkInterface missingIpNic = LinqUtils.firstOrNull(interfacesByClusterId, new Predicate<VdsNetworkInterface>() {

        @Override
        public boolean eval(VdsNetworkInterface nic) {
            return networkName.equals(nic.getNetworkName()) && StringUtils.isEmpty(nic.getAddress());
        }
    });
    return missingIpNic;
}
#end_block

#method_before
private void validateQosNotPartiallyConfigured() {
    Set<String> someSubInterfacesHaveQos = new HashSet<>();
    Set<String> notAllSubInterfacesHaveQos = new HashSet<>();
    // first map which interfaces have some QoS configured on them, and which interfaces lack some QoS configuration
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String networkName = iface.getNetworkName();
        Network network = getExistingClusterNetworks().get(networkName);
        NetworkAttachment networkAttachment = getNetworkAttachment(iface, network);
        String baseIfaceName = NetworkUtils.stripVlan(iface);
        if (network != null) {
            if (NetworkUtils.qosConfiguredOnInterface(networkAttachment, network)) {
                someSubInterfacesHaveQos.add(baseIfaceName);
            } else {
                notAllSubInterfacesHaveQos.add(baseIfaceName);
            }
        }
    }
    // if any base interface has some sub-interfaces with QoS and some without - this is a partial configuration
    for (String ifaceName : someSubInterfacesHaveQos) {
        if (notAllSubInterfacesHaveQos.contains(ifaceName)) {
            addViolation(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_INTERFACES_WITHOUT_QOS, ifaceName);
        }
    }
}
#method_after
private void validateQosNotPartiallyConfigured() {
    Set<String> someSubInterfacesHaveQos = new HashSet<>();
    Set<String> notAllSubInterfacesHaveQos = new HashSet<>();
    // first map which interfaces have some QoS configured on them, and which interfaces lack some QoS configuration
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String networkName = iface.getNetworkName();
        Network network = getExistingClusterNetworks().get(networkName);
        if (network != null) {
            NetworkAttachment networkAttachment = getNetworkAttachment(iface, network);
            String baseIfaceName = NetworkUtils.stripVlan(iface);
            if (NetworkUtils.qosConfiguredOnInterface(networkAttachment, network)) {
                someSubInterfacesHaveQos.add(baseIfaceName);
            } else {
                notAllSubInterfacesHaveQos.add(baseIfaceName);
            }
        }
    }
    // if any base interface has some sub-interfaces with QoS and some without - this is a partial configuration
    for (String ifaceName : someSubInterfacesHaveQos) {
        if (notAllSubInterfacesHaveQos.contains(ifaceName)) {
            addViolation(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_INTERFACES_WITHOUT_QOS, ifaceName);
        }
    }
}
#end_block

#method_before
@PostConstruct
private void init() {
    // init the singleton. TODO remove once all code is using CDI
    setInstance(this);
    log.info("Start initializing {}", getClass().getSimpleName());
    populateVdsAndVmsList();
    // Populate the VDS dictionary
    final List<VDS> allVdsList = hostDao.getAll();
    for (VDS curVds : allVdsList) {
        AddVds(curVds, true);
    }
    IrsBrokerCommand.init();
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#method_after
@PostConstruct
private void init() {
    // init the singleton. TODO remove once all code is using CDI
    setInstance(this);
    log.info("Start initializing {}", getClass().getSimpleName());
    populateVdsAndVmsList();
    // Populate the VDS dictionary
    final List<VDS> allVdsList = hostDao.getAll();
    for (VDS curVds : allVdsList) {
        addVds(curVds, true);
    }
    IrsBrokerCommand.init();
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#end_block

#method_before
public void succededToRunVm(Guid vmId, Guid vdsId) {
    if (asyncRunningVms.contains(vmId)) {
        getEventListener().runningSucceded(vmId);
    }
    RemoveAsyncRunningVm(vmId);
}
#method_after
public void succededToRunVm(Guid vmId, Guid vdsId) {
    if (asyncRunningVms.contains(vmId)) {
        getEventListener().runningSucceded(vmId);
    }
    removeAsyncRunningVm(vmId);
}
#end_block

#method_before
public void reestablishConnection(Guid vdsId) {
    VDS vds = hostDao.get(vdsId);
    RemoveVds(vds.getId());
    AddVds(vds, false);
}
#method_after
public void reestablishConnection(Guid vdsId) {
    VDS vds = hostDao.get(vdsId);
    removeVds(vds.getId());
    addVds(vds, false);
}
#end_block

#method_before
private <P extends VDSParametersBase> VDSCommandBase<P> CreateCommand(VDSCommandType commandType, P parameters) {
    try {
        @SuppressWarnings("unchecked")
        Class<VDSCommandBase<P>> type = (Class<VDSCommandBase<P>>) Class.forName(GetCommandTypeName(commandType));
        Constructor<VDSCommandBase<P>> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return instantiateInjectedCommand(parameters, constructor);
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateCommand failed: {}", e.getCause().getMessage());
            log.error("Exception", e);
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateCommand failed: {}", e.getMessage());
        log.debug("Exception", e);
    }
    return null;
}
#method_after
private <P extends VDSParametersBase> VDSCommandBase<P> CreateCommand(VDSCommandType commandType, P parameters) {
    try {
        @SuppressWarnings("unchecked")
        Class<VDSCommandBase<P>> type = (Class<VDSCommandBase<P>>) Class.forName(getCommandTypeName(commandType));
        Constructor<VDSCommandBase<P>> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return instantiateInjectedCommand(parameters, constructor);
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateCommand failed: {}", e.getCause().getMessage());
            log.error("Exception", e);
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateCommand failed: {}", e.getMessage());
        log.debug("Exception", e);
    }
    return null;
}
#end_block

#method_before
private static Set<String> getClusterEmulatedMachines(VDSGroup cluster) {
    if (cluster.getEmulatedMachine() != null) {
        return new HashSet<>(Arrays.asList(cluster.getEmulatedMachine().split(",")));
    } else {
        return new HashSet<>();
    }
}
#method_after
private static Set<String> getClusterEmulatedMachines(VDSGroup cluster) {
    if (cluster.getEmulatedMachine() == null) {
        return new HashSet<>();
    } else {
        return new HashSet<>(Arrays.asList(cluster.getEmulatedMachine().split(",")));
    }
}
#end_block

#method_before
private static Set<String> getHostEmulatedMachines(VDS vds) {
    return new HashSet<>(Arrays.asList(vds.getSupportedEmulatedMachines().split(",")));
}
#method_after
private static Set<String> getHostEmulatedMachines(VDS vds) {
    if (vds.getSupportedEmulatedMachines() == null) {
        return new HashSet<>();
    } else {
        return new HashSet<>(Arrays.asList(vds.getSupportedEmulatedMachines().split(",")));
    }
}
#end_block

#method_before
protected List<VDS> getUnderUtilizedCPUHosts(Collection<VDS> relevantHosts, final int lowUtilization, final int minVmCount, final int cpuOverCommitDurationMinutes) {
    List<VDS> underUtilizedHosts = LinqUtils.filter(relevantHosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            return (p.getUsageCpuPercent() + calcSpmCpuConsumption(p)) < lowUtilization && p.getVmCount() >= minVmCount && p.getCpuOverCommitTimestamp() != null && (getTime().getTime() - p.getCpuOverCommitTimestamp().getTime()) >= TimeUnit.MINUTES.toMillis(cpuOverCommitDurationMinutes);
        }
    });
    if (underUtilizedHosts.size() > 1) {
        // Assume all hosts belong to the same cluster
        VDSGroup cluster = getVdsGroupDao().get(underUtilizedHosts.get(0).getVdsGroupId());
        Collections.sort(underUtilizedHosts, new VdsCpuUsageComparator(cluster != null && cluster.getCountThreadsAsCores()));
    }
    return underUtilizedHosts;
}
#method_after
protected List<VDS> getUnderUtilizedCPUHosts(Collection<VDS> relevantHosts, final int lowUtilization, final int minVmCount, final int cpuOverCommitDurationMinutes) {
    List<VDS> underUtilizedHosts = LinqUtils.filter(relevantHosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            return (p.getUsageCpuPercent() + calcSpmCpuConsumption(p)) < lowUtilization && p.getVmCount() >= minVmCount && (p.getCpuOverCommitTimestamp() == null || (getTime().getTime() - p.getCpuOverCommitTimestamp().getTime()) >= TimeUnit.MINUTES.toMillis(cpuOverCommitDurationMinutes));
        }
    });
    if (underUtilizedHosts.size() > 1) {
        // Assume all hosts belong to the same cluster
        VDSGroup cluster = getVdsGroupDao().get(underUtilizedHosts.get(0).getVdsGroupId());
        Collections.sort(underUtilizedHosts, new VdsCpuUsageComparator(cluster != null && cluster.getCountThreadsAsCores()));
    }
    return underUtilizedHosts;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getDiskImage().getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.DISK, getDiskIsBeingExportedMessage()));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    DiskImage diskImage = getDiskImage();
    if (diskImage == null) {
        return null;
    }
    return Collections.singletonMap(diskImage.getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.DISK, getDiskIsBeingExportedMessage()));
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionSubjects = new ArrayList<>();
    permissionSubjects.add(new PermissionSubject(getDiskImage().getId(), VdcObjectType.Disk, ActionGroup.ATTACH_DISK));
    permissionSubjects.add(new PermissionSubject(getParameters().getDestinationDomainId(), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
    return permissionSubjects;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionSubjects = new ArrayList<>();
    DiskImage diskImage = getDiskImage();
    if (diskImage != null) {
        permissionSubjects.add(new PermissionSubject(diskImage.getId(), VdcObjectType.Disk, ActionGroup.ATTACH_DISK));
    }
    permissionSubjects.add(new PermissionSubject(getParameters().getDestinationDomainId(), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
    return permissionSubjects;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getDiskImage() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive())) {
        return false;
    }
    // or that are based on a a template.
    if (!getDiskImage().getParentId().equals(Guid.Empty)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DISK_CONFIGURATION_NOT_SUPPORTED);
    }
    for (VM vm : getVmDao().getVmsListForDisk(getDiskImage().getId(), false)) {
        if (vm.getStatus() != VMStatus.Down) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_IS_RUNNING);
        }
    }
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Arrays.asList(getDiskImage()));
    if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!validateDiskImage()) {
        return false;
    }
    if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive())) {
        return false;
    }
    // or that are based on a a template.
    if (!getDiskImage().getParentId().equals(Guid.Empty)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DISK_CONFIGURATION_NOT_SUPPORTED);
    }
    for (VM vm : getVmDao().getVmsListForDisk(getDiskImage().getId(), false)) {
        if (vm.getStatus() != VMStatus.Down) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_IS_RUNNING);
        }
    }
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Arrays.asList(getDiskImage()));
    if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
        return false;
    }
    return true;
}
#end_block

#method_before
public ValidationResult validateRemoveProvider() {
    if (getAsyncTaskDao().getAsyncTaskIdsByEntity(getStorageDomain().getId()).size() > 0) {
        return new ValidationResult(EngineMessage.ERROR_CANNOT_DEACTIVATE_DOMAIN_WITH_TASKS);
    }
    return ValidationResult.VALID;
}
#method_after
@Override
public ValidationResult validateRemoveProvider() {
    if (getAsyncTaskDao().getAsyncTaskIdsByEntity(getStorageDomain().getId()).size() > 0) {
        return new ValidationResult(EngineMessage.ERROR_CANNOT_DEACTIVATE_DOMAIN_WITH_TASKS);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public boolean canRunVm(List<String> messages, StoragePool storagePool, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, List<Guid> destVdsList, VDSGroup vdsGroup) {
    if (vm.getStatus() == VMStatus.Paused) {
        // as the rest of the checks were already checked before
        return validate(validateVdsStatus(vm), messages);
    } else if (vm.getStatus() == VMStatus.Suspended) {
        return validate(new VmValidator(vm).vmNotLocked(), messages) && validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) && validate(validateVmStatusUsingMatrix(vm), messages) && validate(validateStoragePoolUp(vm, storagePool, getVmImageDisks()), messages) && validate(vmDuringInitialization(vm), messages) && validate(validateStorageDomains(vm, isInternalExecution, getVmImageDisks()), messages) && validate(validateImagesForRunVm(vm, getVmImageDisks()), messages) && getSchedulingManager().canSchedule(vdsGroup, vm, vdsBlackList, vdsWhiteList, destVdsList, messages);
    }
    return validateVmProperties(vm, runVmParam.getCustomProperties(), messages) && validate(validateBootSequence(vm, runVmParam.getBootSequence(), getVmDisks(), activeIsoDomainId), messages) && validate(validateDisplayType(), messages) && validate(new VmValidator(vm).vmNotLocked(), messages) && validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) && validate(validateVmStatusUsingMatrix(vm), messages) && validate(validateStoragePoolUp(vm, storagePool, getVmImageDisks()), messages) && validate(validateIsoPath(vm, runVmParam.getDiskPath(), runVmParam.getFloppyPath(), activeIsoDomainId), messages) && validate(vmDuringInitialization(vm), messages) && validate(validateStatelessVm(vm, runVmParam.getRunAsStateless()), messages) && validate(validateFloppy(), messages) && validate(validateStorageDomains(vm, isInternalExecution, filterReadonlyAndPreallocate(getVmImageDisks())), messages) && validate(validateImagesForRunVm(vm, getVmImageDisks()), messages) && validate(validateMemorySize(vm), messages) && getSchedulingManager().canSchedule(vdsGroup, vm, vdsBlackList, vdsWhiteList, destVdsList, messages);
}
#method_after
public boolean canRunVm(List<String> messages, StoragePool storagePool, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, List<Guid> destVdsList, VDSGroup vdsGroup) {
    if (vm.getStatus() == VMStatus.Paused) {
        // as the rest of the checks were already checked before
        return validate(validateVdsStatus(vm), messages);
    } else if (vm.getStatus() == VMStatus.Suspended) {
        return validate(new VmValidator(vm).vmNotLocked(), messages) && validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) && validate(validateVmStatusUsingMatrix(vm), messages) && validate(validateStoragePoolUp(vm, storagePool, getVmImageDisks()), messages) && validate(vmDuringInitialization(vm), messages) && validate(validateStorageDomains(vm, isInternalExecution, getVmImageDisks()), messages) && validate(validateImagesForRunVm(vm, getVmImageDisks()), messages) && getSchedulingManager().canSchedule(vdsGroup, vm, vdsBlackList, vdsWhiteList, destVdsList, messages);
    }
    return validateVmProperties(vm, runVmParam.getCustomProperties(), messages) && validate(validateBootSequence(vm, runVmParam.getBootSequence(), getVmDisks(), activeIsoDomainId), messages) && validate(validateDisplayType(), messages) && validate(new VmValidator(vm).vmNotLocked(), messages) && validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) && validate(validateVmStatusUsingMatrix(vm), messages) && validate(validateStoragePoolUp(vm, storagePool, getVmImageDisks()), messages) && validate(validateIsoPath(vm, runVmParam.getDiskPath(), runVmParam.getFloppyPath(), activeIsoDomainId), messages) && validate(vmDuringInitialization(vm), messages) && validate(validateStatelessVm(vm, runVmParam.getRunAsStateless()), messages) && validate(validateFloppy(), messages) && validate(validateStorageDomains(vm, isInternalExecution, filterReadOnlyAndPreallocatedDisks(getVmImageDisks())), messages) && validate(validateImagesForRunVm(vm, getVmImageDisks()), messages) && validate(validateMemorySize(vm), messages) && getSchedulingManager().canSchedule(vdsGroup, vm, vdsBlackList, vdsWhiteList, destVdsList, messages);
}
#end_block

#method_before
protected Guid getSourceStorageDomainId(Disk disk) {
    if (disk.getStorageDomains() != null) {
        StorageDomain storageDomain = disk.getStorageDomains().getStorageDomains().get(0);
        if (storageDomain != null) {
            return asGuid(storageDomain.getId());
        }
    }
    return null;
}
#method_after
protected Guid getSourceStorageDomainId(Disk disk) {
    if (disk.isSetStorageDomains()) {
        StorageDomain storageDomain = disk.getStorageDomains().getStorageDomains().get(0);
        if (storageDomain != null) {
            return asGuid(storageDomain.getId());
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getParameters().getParametersList().isEmpty()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NO_DISKS_SPECIFIED);
    }
    for (MoveDiskParameters moveDiskParameters : getParameters().getParametersList()) {
        Disk disk = getDiskDao().get(moveDiskParameters.getImageGroupID());
        if (disk.getDiskStorageType() == DiskStorageType.LUN) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_LUN_DISK);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getParameters().getParametersList().isEmpty()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NO_DISKS_SPECIFIED);
    }
    return verifyNoLunDisks();
}
#end_block

#method_before
protected Guid getSourceStorageDomainId(Disk disk) {
    if (disk.getStorageDomains() != null) {
        StorageDomain storageDomain = disk.getStorageDomains().getStorageDomains().get(0);
        if (storageDomain != null) {
            return asGuid(storageDomain.getId());
        }
    }
    return null;
}
#method_after
protected Guid getSourceStorageDomainId(Disk disk) {
    if (disk.isSetStorageDomains()) {
        StorageDomain storageDomain = disk.getStorageDomains().getStorageDomains().get(0);
        if (storageDomain != null) {
            return asGuid(storageDomain.getId());
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Disk disk = getDiskDao().get(getParameters().getImageGroupID());
    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_LUN_DISK);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    return !isDiskLun();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    DiskImage diskImage = getDiskImage();
    OpenStackImageProviderProxy proxy = getProviderProxy();
    acquireImageDbLock();
    String newImageId = proxy.createImageFromDiskImage(diskImage);
    getParameters().setParentCommand(VdcActionType.ExportRepoImage);
    Guid taskId = getAsyncTaskId();
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getImageGroupID()));
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.UploadImage, new UploadImageVDSCommandParameters(getStorageDomain().getStoragePoolId(), getStorageDomain().getId(), diskImage.getId(), diskImage.getImageId(), new HttpLocationInfo(getProviderProxy().getImageUrl(newImageId), getProviderProxy().getUploadHeaders())));
    if (vdsReturnValue.getSucceeded()) {
        getReturnValue().getVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Disk, getParameters().getImageGroupID()));
    }
    getReturnValue().setActionReturnValue(newImageId);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    DiskImage diskImage = getDiskImage();
    OpenStackImageProviderProxy proxy = getProviderProxy();
    acquireImageDbLock();
    String newImageId = proxy.createImageFromDiskImage(diskImage);
    getParameters().setParentCommand(VdcActionType.ExportRepoImage);
    Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getImageGroupID()));
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.UploadImage, new UploadImageVDSCommandParameters(getStorageDomain().getStoragePoolId(), getStorageDomain().getId(), diskImage.getId(), diskImage.getImageId(), new HttpLocationInfo(getProviderProxy().getImageUrl(newImageId), getProviderProxy().getUploadHeaders())));
    if (vdsReturnValue.getSucceeded()) {
        getReturnValue().getVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Disk, getParameters().getImageGroupID()));
    }
    getReturnValue().setActionReturnValue(newImageId);
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (isDiskLun()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_LUN_DISK);
    }
    if (getDiskImage() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive())) {
        return false;
    }
    // or that are based on a a template.
    if (!getDiskImage().getParentId().equals(Guid.Empty)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DISK_CONFIGURATION_NOT_SUPPORTED);
    }
    for (VM vm : getVmDao().getVmsListForDisk(getDiskImage().getId(), false)) {
        if (vm.getStatus() != VMStatus.Down) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_IS_RUNNING);
        }
    }
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Arrays.asList(getDiskImage()));
    if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!validateDiskImage()) {
        return false;
    }
    if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive())) {
        return false;
    }
    // or that are based on a a template.
    if (!getDiskImage().getParentId().equals(Guid.Empty)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DISK_CONFIGURATION_NOT_SUPPORTED);
    }
    for (VM vm : getVmDao().getVmsListForDisk(getDiskImage().getId(), false)) {
        if (vm.getStatus() != VMStatus.Down) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_IS_RUNNING);
        }
    }
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Arrays.asList(getDiskImage()));
    if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
        return false;
    }
    return true;
}
#end_block

#method_before
public boolean isHostedEngine() {
    return OriginType.HOSTED_ENGINE.equals(getOrigin());
}
#method_after
public boolean isHostedEngine() {
    return OriginType.HOSTED_ENGINE == getOrigin() || OriginType.MANAGED_HOSTED_ENGINE == getOrigin();
}
#end_block

#method_before
public boolean isManagedVm() {
    return !isHostedEngine() && !isExternalVm();
}
#method_after
public boolean isManagedVm() {
    return !(OriginType.HOSTED_ENGINE == getOrigin()) && !isExternalVm();
}
#end_block

#method_before
public String getNetworkNames() {
    return getParameters().getNetworkNames();
}
#method_after
public String getNetworkNames() {
    if (getParameters().getNetworkAttachments().size() == 0) {
        getParameters().setNetworkNames(StringUtils.EMPTY);
    } else if (StringUtils.isEmpty(getParameters().getNetworkNames())) {
        updateModifiedNetworksNames();
    }
    return getParameters().getNetworkNames();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getParameters().getShouldBeLogged()) {
        auditLogDirector.log(this, AuditLogType.PERSIST_HOST_SETUP_NETWORK_ON_HOST);
    }
    VdcReturnValueBase returnValue = runInternalAction(VdcActionType.HostSetupNetworks, getParameters(), cloneContextAndDetachFromParent());
    boolean changesDetected = checkForChanges();
    if (returnValue.getSucceeded() && changesDetected) {
        updateModifiedNetworksNames();
        VdsActionParameters parameters = new VdsActionParameters(getParameters().getVdsId());
        parameters.setShouldBeLogged(false);
        parameters.setCorrelationId(getCorrelationId());
        returnValue = runInternalAction(VdcActionType.CommitNetworkChanges, parameters, cloneContextAndDetachFromParent());
    }
    if (!returnValue.getSucceeded()) {
        propagateFailure(returnValue);
    }
    setSucceeded(returnValue.getSucceeded());
}
#method_after
@Override
protected void executeCommand() {
    if (getParameters().getShouldBeLogged()) {
        auditLogDirector.log(this, AuditLogType.PERSIST_HOST_SETUP_NETWORK_ON_HOST);
    }
    VdcReturnValueBase returnValue = runInternalAction(VdcActionType.HostSetupNetworks, getParameters(), cloneContextAndDetachFromParent());
    boolean changesDetected = checkForChanges();
    if (returnValue.getSucceeded() && changesDetected) {
        VdsActionParameters parameters = new VdsActionParameters(getParameters().getVdsId());
        parameters.setShouldBeLogged(false);
        parameters.setCorrelationId(getCorrelationId());
        returnValue = runInternalAction(VdcActionType.CommitNetworkChanges, parameters, cloneContextAndDetachFromParent());
    }
    if (!returnValue.getSucceeded()) {
        propagateFailure(returnValue);
    }
    setSucceeded(returnValue.getSucceeded());
}
#end_block

#method_before
private PersistentHostSetupNetworksParameters generateSyncAllHostNetworksParameters() {
    PersistentHostSetupNetworksParameters parameters = new PersistentHostSetupNetworksParameters(getVdsId());
    VdcQueryReturnValue returnValue = runInternalQuery(VdcQueryType.GetNetworkAttachmentsByHostId, new IdQueryParameters(getVdsId()));
    List<NetworkAttachment> networkAttachments = returnValue.getReturnValue();
    List<NetworkAttachment> unSyncNetworkAttachments = LinqUtils.filter(networkAttachments, new NetworkNotInSyncPredicate());
    for (NetworkAttachment networkAttachment : unSyncNetworkAttachments) {
        networkAttachment.setOverrideConfiguration(true);
    }
    parameters.setNetworkAttachments(unSyncNetworkAttachments);
    return parameters;
}
#method_after
private PersistentHostSetupNetworksParameters generateSyncAllHostNetworksParameters() {
    PersistentHostSetupNetworksParameters parameters = new PersistentHostSetupNetworksParameters(getVdsId());
    VdcQueryReturnValue returnValue = runInternalQuery(VdcQueryType.GetNetworkAttachmentsByHostId, new IdQueryParameters(getVdsId()));
    List<NetworkAttachment> networkAttachments = returnValue.getReturnValue();
    List<NetworkAttachment> unSyncNetworkAttachments = LinqUtils.filter(networkAttachments, new NetworkNotInSyncPredicate());
    for (NetworkAttachment networkAttachment : unSyncNetworkAttachments) {
        networkAttachment.setOverrideConfiguration(true);
    }
    parameters.setNetworkAttachments(unSyncNetworkAttachments);
    parameters.setSequence(parameters.getSequence() + 1);
    parameters.setTotal(parameters.getTotal() + 1);
    return parameters;
}
#end_block

#method_before
@Override
public String eval(NetworkAttachment networkAttachment) {
    final String networkName = networkAttachment.getNetworkName();
    return StringUtils.isEmpty(networkName) ? networkAttachment.getId().toString() : networkName;
}
#method_after
@Override
public String eval(NetworkAttachment networkAttachment) {
    final String networkName = networkAttachment.getNetworkName();
    if (!StringUtils.isEmpty(networkName)) {
        return networkName;
    }
    final Guid networkId = networkAttachment.getNetworkId();
    return networkId == null ? null : networkId.toString();
}
#end_block

#method_before
private NetworkAttachment createNetworkAttachmentWithMockedId() {
    NetworkAttachment networkAttachment = new NetworkAttachment();
    networkAttachment.setId(mockNetworkAttachmentGuid);
    return networkAttachment;
}
#method_after
private NetworkAttachment createNetworkAttachmentWithMockedId() {
    NetworkAttachment networkAttachment = new NetworkAttachment();
    networkAttachment.setNetworkId(mockNetworkGuid);
    return networkAttachment;
}
#end_block

#method_before
@Override
protected void executeVdsIdCommand() {
    log.info("addVds - entered , starting logic to add VDS '{}'", getVdsId());
    VDS vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
    log.info("addVds - VDS '{}' was added, will try to add it to the resource manager", getVdsId());
    ResourceManager.getInstance().addVds(vds, false);
}
#method_after
@Override
protected void executeVdsIdCommand() {
    log.info("AddVds - entered , starting logic to add VDS '{}'", getVdsId());
    VDS vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
    log.info("AddVds - VDS '{}' was added, will try to add it to the resource manager", getVdsId());
    ResourceManager.getInstance().addVds(vds, false);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (userProfileDao.getByUserId(getUserId()) == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_PROFILE_NOT_EXIST);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getUserProfile() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_PROFILE_NOT_EXIST);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    UserProfile profile = userProfileDao.getByUserId(getUserId());
    profile.setSshPublicKeyId(getParameters().getUserProfile().getSshPublicKeyId());
    profile.setSshPublicKey(getParameters().getUserProfile().getSshPublicKey());
    profile.setUserPortalVmLoginAutomatically(getParameters().getUserProfile().isUserPortalVmLoginAutomatically());
    userProfileDao.update(profile);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    UserProfile profile = getUserProfile();
    profile.setSshPublicKeyId(getParameters().getUserProfile().getSshPublicKeyId());
    profile.setSshPublicKey(getParameters().getUserProfile().getSshPublicKey());
    profile.setUserPortalVmLoginAutomatically(getParameters().getUserProfile().isUserPortalVmLoginAutomatically());
    userProfileDao.update(profile);
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (userProfileDao.getByUserId(getUserId()) != null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_PROFILE_ALREADY_EXISTS);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getUserProfile() != null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_PROFILE_ALREADY_EXISTS);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    UserProfile profile = getParameters().getUserProfile();
    profile.setId(Guid.newGuid());
    profile.setUserId(getUserId());
    /* must be overridden */
    if (!profile.getSshPublicKey().isEmpty() && (profile.getSshPublicKeyId() == null || profile.getSshPublicKeyId().equals(Guid.Empty))) {
        profile.setSshPublicKeyId(Guid.newGuid());
    }
    userProfileDao.save(profile);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    UserProfile profile = getParameters().getUserProfile();
    profile.setId(Guid.newGuid());
    profile.setUserId(getUserId());
    /* must be overridden */
    if (!profile.getSshPublicKey().isEmpty() && Guid.isNullOrEmpty(profile.getSshPublicKeyId())) {
        profile.setSshPublicKeyId(Guid.newGuid());
    }
    userProfileDao.save(profile);
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    UserProfile dbProfile = userProfileDao.getByUserId(getUserId());
    if (dbProfile == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_PROFILE_NOT_EXIST);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getUserProfile() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_PROFILE_NOT_EXIST);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    UserProfile dbProfile = userProfileDao.getByUserId(getUserId());
    userProfileDao.remove(dbProfile.getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    UserProfile profile = getUserProfile();
    userProfileDao.remove(profile.getId());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Guid userId = getParameters().getUserProfile().getUserId();
    if (userId == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_PROFILE_NOT_EXISTS);
    } else {
        if (userId.equals(Guid.Empty)) {
            // Empty GUID == current user
            userId = getUserId();
            getParameters().getUserProfile().setUserId(userId);
        } else if (!userId.equals(getUserId())) {
            return failCanDoAction(EngineMessage.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        }
    }
    String sshPublicKey = getParameters().getUserProfile().getSshPublicKey();
    if (sshPublicKey == null || sshPublicKey.isEmpty()) {
        // the user wants to wipe out its own key, and we're fine with that.
        return true;
    }
    // else it is either a new or replacement key. In both cases, must be a valid key.
    if (!OpenSSHUtils.isPublicKeyValid(sshPublicKey)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_INVALID_PUBLIC_SSH_KEY);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    Guid userId = getParameters().getUserProfile().getUserId();
    if (Guid.isNullOrEmpty(userId)) {
        // null/Empty GUID == current user. Fix parameters for later use (e.g. subclasses).
        userId = getUserId();
        getParameters().getUserProfile().setUserId(userId);
    } else if (!userId.equals(getUserId())) {
        return failCanDoAction(EngineMessage.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
    }
    String sshPublicKey = getParameters().getUserProfile().getSshPublicKey();
    if (sshPublicKey == null || sshPublicKey.isEmpty()) {
        // the user wants to wipe out its own key, and we're fine with that.
        return true;
    }
    // else it is either a new or replacement key. In both cases, must be a valid key.
    if (!OpenSSHUtils.isPublicKeyValid(sshPublicKey)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_INVALID_PUBLIC_SSH_KEY);
    }
    return true;
}
#end_block

#method_before
public UICommand getSyncAllHostNetworksCommand() {
    return privateSyncAllHostNetworksCommand;
}
#method_after
public UICommand getSyncAllHostNetworksCommand() {
    return syncAllHostNetworksCommand;
}
#end_block

#method_before
public void setSyncAllHostNetworksCommand(UICommand privateSyncAllHostNetworkCommand) {
    this.privateSyncAllHostNetworksCommand = privateSyncAllHostNetworkCommand;
}
#method_after
public void setSyncAllHostNetworksCommand(UICommand privateSyncAllHostNetworkCommand) {
    this.syncAllHostNetworksCommand = privateSyncAllHostNetworkCommand;
}
#end_block

#method_before
// protected override void OnSelectedItemChanged()
// {
// base.OnSelectedItemChanged();
// UpdateActionAvailability();
// }
// protected override void SelectedItemsChanged()
// {
// base.SelectedItemsChanged();
// UpdateActionAvailability();
// }
@Override
protected void entityPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.entityPropertyChanged(sender, e);
    if (// $NON-NLS-1$ //$NON-NLS-2$
    e.propertyName.equals("status") || e.propertyName.equals("net_config_dirty")) {
        updateActionAvailability();
    }
}
#method_after
// protected override void OnSelectedItemChanged()
// {
// base.OnSelectedItemChanged();
// UpdateActionAvailability();
// }
// protected override void SelectedItemsChanged()
// {
// base.SelectedItemsChanged();
// UpdateActionAvailability();
// }
@Override
protected void entityPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.entityPropertyChanged(sender, e);
    if (e.propertyName.equals("status") || e.propertyName.equals("net_config_dirty")) {
        // $NON-NLS-1$ //$NON-NLS-2$
        updateActionAvailability();
    }
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ProvidePropertyChangedEvent.definition)) {
        model_PropertyChanged(sender, (PropertyChangedEventArgs) args);
    } else if (// $NON-NLS-1$
    sender instanceof Model && "InterfaceList".equals(((Model) sender).getTitle())) {
        HostManagementNetworkModel managementNetworkModel = ((HostManagementNetworkModel) getWindow());
        VdsNetworkInterface vdsNetworkInterface = managementNetworkModel.getInterface().getSelectedItem();
        if (vdsNetworkInterface.getBonded() != null && vdsNetworkInterface.getBonded().equals(true)) {
            managementNetworkModel.getBondingOptions().setIsChangeable(true);
        } else {
            managementNetworkModel.getBondingOptions().setIsChangeable(false);
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ProvidePropertyChangedEvent.definition)) {
        model_PropertyChanged(sender, (PropertyChangedEventArgs) args);
    } else if (sender instanceof Model && "InterfaceList".equals(((Model) sender).getTitle())) {
        // $NON-NLS-1$
        HostManagementNetworkModel managementNetworkModel = ((HostManagementNetworkModel) getWindow());
        VdsNetworkInterface vdsNetworkInterface = managementNetworkModel.getInterface().getSelectedItem();
        if (vdsNetworkInterface.getBonded() != null && vdsNetworkInterface.getBonded().equals(true)) {
            managementNetworkModel.getBondingOptions().setIsChangeable(true);
        } else {
            managementNetworkModel.getBondingOptions().setIsChangeable(false);
        }
    }
}
#end_block

#method_before
private void model_PropertyChanged(Object sender, PropertyChangedEventArgs args) {
    if (// $NON-NLS-1$
    !args.propertyName.equals("IsSelected")) {
        return;
    }
    if (sender instanceof HostInterfaceLineModel) {
        HostInterfaceLineModel model = (HostInterfaceLineModel) sender;
        for (HostInterface hostInterface : model.getInterfaces()) {
            hostInterface.getPropertyChangedEvent().removeListener(this);
            hostInterface.setIsSelected(model.getIsSelected());
            hostInterface.getPropertyChangedEvent().addListener(this);
        }
        for (HostVLan vLan : model.getVLans()) {
            vLan.getPropertyChangedEvent().removeListener(this);
            vLan.setIsSelected(false);
            vLan.getPropertyChangedEvent().addListener(this);
        }
        if (model.getIsSelected()) {
            if (model.getIsBonded()) {
                setSelectedItem(model.getInterface());
            } else {
                setSelectedItem(model.getInterfaces().get(0).getInterface());
            }
        }
    } else if (sender instanceof HostInterface) {
        HostInterface model = (HostInterface) sender;
        VdsNetworkInterface selectItem = null;
        if (model.getIsSelected()) {
            selectItem = model.getInterface();
        }
        for (Object a : getItems()) {
            HostInterfaceLineModel item = (HostInterfaceLineModel) a;
            boolean found = false;
            for (HostInterface hostInterface : item.getInterfaces()) {
                if (hostInterface == model) {
                    item.getPropertyChangedEvent().removeListener(this);
                    item.setIsSelected(model.getIsSelected());
                    item.getPropertyChangedEvent().addListener(this);
                    if (item.getIsBonded() && item.getIsSelected()) {
                        selectItem = item.getInterface();
                    }
                    for (HostVLan vLan : item.getVLans()) {
                        vLan.getPropertyChangedEvent().removeListener(this);
                        vLan.setIsSelected(false);
                        vLan.getPropertyChangedEvent().addListener(this);
                    }
                    found = true;
                    break;
                }
            }
            if (found) {
                for (HostInterface hostInterface : item.getInterfaces()) {
                    hostInterface.getPropertyChangedEvent().removeListener(this);
                    hostInterface.setIsSelected(model.getIsSelected());
                    hostInterface.getPropertyChangedEvent().addListener(this);
                }
            }
        }
        if (selectItem != null) {
            setSelectedItem(selectItem);
        }
    } else if (sender instanceof HostVLan) {
        HostVLan model = (HostVLan) sender;
        for (Object a : getItems()) {
            HostInterfaceLineModel item = (HostInterfaceLineModel) a;
            for (HostVLan vLan : item.getVLans()) {
                if (vLan == model) {
                    for (HostInterface hostInterface : item.getInterfaces()) {
                        hostInterface.getPropertyChangedEvent().removeListener(this);
                        hostInterface.setIsSelected(false);
                        hostInterface.getPropertyChangedEvent().addListener(this);
                    }
                    item.getPropertyChangedEvent().removeListener(this);
                    item.setIsSelected(false);
                    item.getPropertyChangedEvent().addListener(this);
                    break;
                }
            }
        }
        if (model.getIsSelected()) {
            setSelectedItem(model.getInterface());
        }
    }
    if (getSelectedItems().isEmpty()) {
        setSelectedItem(null);
    } else {
        // Check whether the SelectedItem is still a one from SelectedItems. If not, choose the first one.
        boolean found = false;
        for (VdsNetworkInterface item : getSelectedItems()) {
            if (item == getSelectedItem()) {
                found = true;
                break;
            }
        }
        if (!found) {
            setSelectedItem(Linq.firstOrDefault(getSelectedItems()));
        }
    }
    updateActionAvailability();
}
#method_after
private void model_PropertyChanged(Object sender, PropertyChangedEventArgs args) {
    if (!args.propertyName.equals("IsSelected")) {
        // $NON-NLS-1$
        return;
    }
    if (sender instanceof HostInterfaceLineModel) {
        HostInterfaceLineModel model = (HostInterfaceLineModel) sender;
        for (HostInterface hostInterface : model.getInterfaces()) {
            hostInterface.getPropertyChangedEvent().removeListener(this);
            hostInterface.setIsSelected(model.getIsSelected());
            hostInterface.getPropertyChangedEvent().addListener(this);
        }
        for (HostVLan vLan : model.getVLans()) {
            vLan.getPropertyChangedEvent().removeListener(this);
            vLan.setIsSelected(false);
            vLan.getPropertyChangedEvent().addListener(this);
        }
        if (model.getIsSelected()) {
            if (model.getIsBonded()) {
                setSelectedItem(model.getInterface());
            } else {
                setSelectedItem(model.getInterfaces().get(0).getInterface());
            }
        }
    } else if (sender instanceof HostInterface) {
        HostInterface model = (HostInterface) sender;
        VdsNetworkInterface selectItem = null;
        if (model.getIsSelected()) {
            selectItem = model.getInterface();
        }
        for (Object a : getItems()) {
            HostInterfaceLineModel item = (HostInterfaceLineModel) a;
            boolean found = false;
            for (HostInterface hostInterface : item.getInterfaces()) {
                if (hostInterface == model) {
                    item.getPropertyChangedEvent().removeListener(this);
                    item.setIsSelected(model.getIsSelected());
                    item.getPropertyChangedEvent().addListener(this);
                    if (item.getIsBonded() && item.getIsSelected()) {
                        selectItem = item.getInterface();
                    }
                    for (HostVLan vLan : item.getVLans()) {
                        vLan.getPropertyChangedEvent().removeListener(this);
                        vLan.setIsSelected(false);
                        vLan.getPropertyChangedEvent().addListener(this);
                    }
                    found = true;
                    break;
                }
            }
            if (found) {
                for (HostInterface hostInterface : item.getInterfaces()) {
                    hostInterface.getPropertyChangedEvent().removeListener(this);
                    hostInterface.setIsSelected(model.getIsSelected());
                    hostInterface.getPropertyChangedEvent().addListener(this);
                }
            }
        }
        if (selectItem != null) {
            setSelectedItem(selectItem);
        }
    } else if (sender instanceof HostVLan) {
        HostVLan model = (HostVLan) sender;
        for (Object a : getItems()) {
            HostInterfaceLineModel item = (HostInterfaceLineModel) a;
            for (HostVLan vLan : item.getVLans()) {
                if (vLan == model) {
                    for (HostInterface hostInterface : item.getInterfaces()) {
                        hostInterface.getPropertyChangedEvent().removeListener(this);
                        hostInterface.setIsSelected(false);
                        hostInterface.getPropertyChangedEvent().addListener(this);
                    }
                    item.getPropertyChangedEvent().removeListener(this);
                    item.setIsSelected(false);
                    item.getPropertyChangedEvent().addListener(this);
                    break;
                }
            }
        }
        if (model.getIsSelected()) {
            setSelectedItem(model.getInterface());
        }
    }
    if (getSelectedItems().isEmpty()) {
        setSelectedItem(null);
    } else {
        // Check whether the SelectedItem is still a one from SelectedItems. If not, choose the first one.
        boolean found = false;
        for (VdsNetworkInterface item : getSelectedItems()) {
            if (item == getSelectedItem()) {
                found = true;
                break;
            }
        }
        if (!found) {
            setSelectedItem(Linq.firstOrDefault(getSelectedItems()));
        }
    }
    updateActionAvailability();
}
#end_block

#method_before
public void onEditManagementNetwork() {
    HostManagementNetworkModel model = (HostManagementNetworkModel) getWindow();
    if (getConfirmWindow() != null) {
        ConfirmationModel confirmModel = (ConfirmationModel) getConfirmWindow();
        if (confirmModel.getLatch().getEntity() == true) {
            model.getCheckConnectivity().setEntity(true);
        }
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    VdsNetworkInterface nic = model.getInterface().getSelectedItem();
    Network network = model.getEntity();
    VdcActionType actionType = VdcActionType.UpdateNetworkToVdsInterface;
    UpdateNetworkToVdsParameters parameters = new UpdateNetworkToVdsParameters(getEntity().getId(), network, new ArrayList<VdsNetworkInterface>(Arrays.asList(new VdsNetworkInterface[] { nic })));
    Map.Entry<String, EntityModel<String>> bondingOption;
    if (model.getBondingOptions().getSelectedItem() != null) {
        bondingOption = model.getBondingOptions().getSelectedItem();
        if (// $NON-NLS-1$
        !bondingOption.getKey().equals("custom")) {
            parameters.setBondingOptions((StringHelper.isNullOrEmpty(bondingOption.getKey()) ? null : bondingOption.getKey()));
        } else {
            EntityModel entityModel = bondingOption.getValue();
            if (entityModel.getEntity() != null) {
                parameters.setBondingOptions(entityModel.getEntity().toString());
            }
        }
    }
    if (nic.getBonded() == null || nic.getBonded() == false) {
        parameters.setBondingOptions(null);
    }
    if (network != null) {
        parameters.setOldNetworkName(network.getName());
    }
    parameters.setCheckConnectivity(model.getCheckConnectivity().getEntity());
    parameters.setBootProtocol(model.getBootProtocol());
    if (model.getIsStaticAddress()) {
        parameters.setAddress(model.getAddress().getEntity());
        parameters.setSubnet(model.getSubnet().getEntity());
        parameters.setGateway(model.getGateway().getEntity());
    }
    model.startProgress(null);
    setcurrentModel(model);
    Frontend.getInstance().runAction(actionType, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                EntityModel<Boolean> commitChanges = ((HostManagementNetworkModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                if (commitChanges.getEntity()) {
                    new SaveNetworkConfigAction(HostInterfaceListModel.this, hostInterfaceListModel.getcurrentModel(), getEntity()).execute();
                } else {
                    hostInterfaceListModel.getcurrentModel().stopProgress();
                    hostInterfaceListModel.cancel();
                    hostInterfaceListModel.search();
                }
            } else {
                hostInterfaceListModel.getcurrentModel().stopProgress();
            }
        }
    }, this);
    cancelConfirm();
}
#method_after
public void onEditManagementNetwork() {
    HostManagementNetworkModel model = (HostManagementNetworkModel) getWindow();
    if (getConfirmWindow() != null) {
        ConfirmationModel confirmModel = (ConfirmationModel) getConfirmWindow();
        if (confirmModel.getLatch().getEntity() == true) {
            model.getCheckConnectivity().setEntity(true);
        }
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    VdsNetworkInterface nic = model.getInterface().getSelectedItem();
    Network network = model.getEntity();
    VdcActionType actionType = VdcActionType.UpdateNetworkToVdsInterface;
    UpdateNetworkToVdsParameters parameters = new UpdateNetworkToVdsParameters(getEntity().getId(), network, new ArrayList<VdsNetworkInterface>(Arrays.asList(new VdsNetworkInterface[] { nic })));
    Map.Entry<String, EntityModel<String>> bondingOption;
    if (model.getBondingOptions().getSelectedItem() != null) {
        bondingOption = model.getBondingOptions().getSelectedItem();
        if (!bondingOption.getKey().equals("custom")) {
            // $NON-NLS-1$
            parameters.setBondingOptions((StringHelper.isNullOrEmpty(bondingOption.getKey()) ? null : bondingOption.getKey()));
        } else {
            EntityModel entityModel = bondingOption.getValue();
            if (entityModel.getEntity() != null) {
                parameters.setBondingOptions(entityModel.getEntity().toString());
            }
        }
    }
    if (nic.getBonded() == null || nic.getBonded() == false) {
        parameters.setBondingOptions(null);
    }
    if (network != null) {
        parameters.setOldNetworkName(network.getName());
    }
    parameters.setCheckConnectivity(model.getCheckConnectivity().getEntity());
    parameters.setBootProtocol(model.getBootProtocol());
    if (model.getIsStaticAddress()) {
        parameters.setAddress(model.getAddress().getEntity());
        parameters.setSubnet(model.getSubnet().getEntity());
        parameters.setGateway(model.getGateway().getEntity());
    }
    model.startProgress();
    setcurrentModel(model);
    Frontend.getInstance().runAction(actionType, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                EntityModel<Boolean> commitChanges = ((HostManagementNetworkModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                if (commitChanges.getEntity()) {
                    new SaveNetworkConfigAction(HostInterfaceListModel.this, hostInterfaceListModel.getcurrentModel(), getEntity()).execute();
                } else {
                    hostInterfaceListModel.getcurrentModel().stopProgress();
                    hostInterfaceListModel.cancel();
                    hostInterfaceListModel.search();
                }
            } else {
                hostInterfaceListModel.getcurrentModel().stopProgress();
            }
        }
    }, this);
    cancelConfirm();
}
#end_block

#method_before
public void bond() {
    if (getWindow() != null) {
        return;
    }
    HostBondInterfaceModel bondModel = new HostBondInterfaceModel();
    setWindow(bondModel);
    bondModel.setTitle(ConstantsManager.getInstance().getConstants().bondNetworkInterfacesTitle());
    bondModel.setHelpTag(HelpTag.bond_network_interfaces);
    // $NON-NLS-1$
    bondModel.setHashName("bond_network_interfaces");
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) model;
            ArrayList<Network> networksByCluster = (ArrayList<Network>) ReturnValue;
            HostBondInterfaceModel innerBondModel = (HostBondInterfaceModel) hostInterfaceListModel.getWindow();
            Network selectedNetwork = null;
            VDS host = hostInterfaceListModel.getEntity();
            // Allow change gateway if there one of the selected interfaces connected to engine network.
            boolean isAnyManagement = false;
            for (VdsNetworkInterface innerItem : hostInterfaceListModel.getSelectedItemsWithVlans()) {
                if (innerItem.getIsManagement()) {
                    isAnyManagement = true;
                    break;
                }
            }
            ArrayList<Network> networksToAdd = new ArrayList<Network>();
            // creating dictionary of networks by name
            HashMap<String, Network> networkDictionary = new HashMap<String, Network>();
            for (Network network : networksByCluster) {
                networkDictionary.put(network.getName(), network);
            }
            // creating list of attached networks.
            ArrayList<Network> attachedNetworks = new ArrayList<Network>();
            for (VdsNetworkInterface nic : hostInterfaceListModel.getAllItems()) {
                if (nic.getNetworkName() != null && networkDictionary.containsKey(nic.getNetworkName())) {
                    attachedNetworks.add(networkDictionary.get(nic.getNetworkName()));
                }
            }
            ArrayList<Network> unAttachedNetworks = Linq.except(networksByCluster, attachedNetworks);
            // adding selected network names to list.
            boolean isVlanSelected = false;
            boolean isManagement = false;
            RefObject<Boolean> tempRef_isVlanSelected = new RefObject<Boolean>(isVlanSelected);
            RefObject<Boolean> tempRef_isManagement = new RefObject<Boolean>(isManagement);
            ArrayList<String> selectedNicsNetworks = hostInterfaceListModel.getSelectedNicsNetworks(tempRef_isVlanSelected, tempRef_isManagement);
            isVlanSelected = tempRef_isVlanSelected.argvalue;
            isManagement = tempRef_isManagement.argvalue;
            for (String selectedNetworkName : selectedNicsNetworks) {
                if (networkDictionary.containsKey(selectedNetworkName)) {
                    Network network = networkDictionary.get(selectedNetworkName);
                    networksToAdd.add(network);
                    attachedNetworks.remove(network);
                    if (selectedNetwork == null) {
                        selectedNetwork = network;
                    }
                }
            }
            if (!isManagement) {
                for (Network unAttachedNetwork : unAttachedNetworks) {
                    if (isVlanSelected) {
                        if (unAttachedNetwork.getVlanId() != null) {
                            networksToAdd.add(unAttachedNetwork);
                        }
                    } else {
                        networksToAdd.add(unAttachedNetwork);
                    }
                }
                innerBondModel.getNetwork().setItems(networksToAdd);
            } else {
                innerBondModel.getNetwork().setItems(new ArrayList<Network>(Arrays.asList(selectedNetwork)));
            }
            if (selectedNetwork == null && networksToAdd.size() > 0) {
                selectedNetwork = networksToAdd.get(0);
            }
            innerBondModel.getNetwork().setSelectedItem(selectedNetwork);
            // Interface bond = selectedItems.FirstOrDefault(a => a.is_bond.HasValue && a.is_bond.Value);
            VdsNetworkInterface bond = Linq.findInterfaceByIsBond(getSelectedItems());
            if (bond != null) // one of the bond items is a bond itself -> don't
            // allocate a new bond name, edit the existing one:
            {
                innerBondModel.getBond().setItems(new ArrayList<String>(Arrays.asList(new String[] { bond.getName() })));
                innerBondModel.getBond().setSelectedItem(bond.getName());
                innerBondModel.getBond().setIsChangeable(false);
                hostInterfaceListModel.postBond(hostInterfaceListModel, innerBondModel, networksToAdd, isAnyManagement);
            } else {
                AsyncQuery _asyncQuery1 = new AsyncQuery();
                _asyncQuery1.setModel(hostInterfaceListModel);
                _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object ReturnValue1) {
                        HostInterfaceListModel innerHostInterfaceListModel = (HostInterfaceListModel) model1;
                        HostBondInterfaceModel bModel = (HostBondInterfaceModel) innerHostInterfaceListModel.getWindow();
                        List<VdsNetworkInterface> bonds = ((VdcQueryReturnValue) ReturnValue1).getReturnValue();
                        List<String> bondNames = new ArrayList<String>();
                        for (VdsNetworkInterface bond : bonds) {
                            bondNames.add(bond.getName());
                        }
                        bModel.getBond().setItems(bondNames);
                        // ((List<Interface>)model.Bond.Options).Sort(a => a.name);
                        bModel.getBond().setSelectedItem(Linq.firstOrDefault(bondNames));
                        boolean hasManagement = false;
                        for (VdsNetworkInterface innerItem : innerHostInterfaceListModel.getSelectedItemsWithVlans()) {
                            if (innerItem.getIsManagement()) {
                                hasManagement = true;
                                break;
                            }
                        }
                        innerHostInterfaceListModel.postBond(innerHostInterfaceListModel, bModel, bModel.getNetwork().getItems() != null ? (ArrayList<Network>) bModel.getNetwork().getItems() : new ArrayList<Network>(), hasManagement);
                    }
                };
                Frontend.getInstance().runQuery(VdcQueryType.GetVdsFreeBondsByVdsId, new IdQueryParameters(host.getId()), _asyncQuery1);
            }
        }
    };
    AsyncDataProvider.getInstance().getClusterNetworkList(_asyncQuery, getEntity().getVdsGroupId());
}
#method_after
public void bond() {
    if (getWindow() != null) {
        return;
    }
    HostBondInterfaceModel bondModel = new HostBondInterfaceModel();
    setWindow(bondModel);
    bondModel.setTitle(ConstantsManager.getInstance().getConstants().bondNetworkInterfacesTitle());
    bondModel.setHelpTag(HelpTag.bond_network_interfaces);
    // $NON-NLS-1$
    bondModel.setHashName("bond_network_interfaces");
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) model;
            ArrayList<Network> networksByCluster = (ArrayList<Network>) ReturnValue;
            HostBondInterfaceModel innerBondModel = (HostBondInterfaceModel) hostInterfaceListModel.getWindow();
            Network selectedNetwork = null;
            VDS host = hostInterfaceListModel.getEntity();
            // Allow change gateway if there one of the selected interfaces connected to engine network.
            boolean isAnyManagement = false;
            for (VdsNetworkInterface innerItem : hostInterfaceListModel.getSelectedItemsWithVlans()) {
                if (innerItem.getIsManagement()) {
                    isAnyManagement = true;
                    break;
                }
            }
            ArrayList<Network> networksToAdd = new ArrayList<Network>();
            // creating dictionary of networks by name
            HashMap<String, Network> networkDictionary = new HashMap<String, Network>();
            for (Network network : networksByCluster) {
                networkDictionary.put(network.getName(), network);
            }
            // creating list of attached networks.
            ArrayList<Network> attachedNetworks = new ArrayList<Network>();
            for (VdsNetworkInterface nic : hostInterfaceListModel.getAllItems()) {
                if (nic.getNetworkName() != null && networkDictionary.containsKey(nic.getNetworkName())) {
                    attachedNetworks.add(networkDictionary.get(nic.getNetworkName()));
                }
            }
            ArrayList<Network> unAttachedNetworks = Linq.except(networksByCluster, attachedNetworks);
            // adding selected network names to list.
            boolean isVlanSelected = false;
            boolean isManagement = false;
            RefObject<Boolean> tempRef_isVlanSelected = new RefObject<Boolean>(isVlanSelected);
            RefObject<Boolean> tempRef_isManagement = new RefObject<Boolean>(isManagement);
            ArrayList<String> selectedNicsNetworks = hostInterfaceListModel.getSelectedNicsNetworks(tempRef_isVlanSelected, tempRef_isManagement);
            isVlanSelected = tempRef_isVlanSelected.argvalue;
            isManagement = tempRef_isManagement.argvalue;
            for (String selectedNetworkName : selectedNicsNetworks) {
                if (networkDictionary.containsKey(selectedNetworkName)) {
                    Network network = networkDictionary.get(selectedNetworkName);
                    networksToAdd.add(network);
                    attachedNetworks.remove(network);
                    if (selectedNetwork == null) {
                        selectedNetwork = network;
                    }
                }
            }
            if (!isManagement) {
                for (Network unAttachedNetwork : unAttachedNetworks) {
                    if (isVlanSelected) {
                        if (unAttachedNetwork.getVlanId() != null) {
                            networksToAdd.add(unAttachedNetwork);
                        }
                    } else {
                        networksToAdd.add(unAttachedNetwork);
                    }
                }
                innerBondModel.getNetwork().setItems(networksToAdd);
            } else {
                innerBondModel.getNetwork().setItems(new ArrayList<Network>(Arrays.asList(selectedNetwork)));
            }
            if (selectedNetwork == null && networksToAdd.size() > 0) {
                selectedNetwork = networksToAdd.get(0);
            }
            innerBondModel.getNetwork().setSelectedItem(selectedNetwork);
            // Interface bond = selectedItems.FirstOrDefault(a => a.is_bond.HasValue && a.is_bond.Value);
            VdsNetworkInterface bond = Linq.findInterfaceByIsBond(getSelectedItems());
            if (bond != null) {
                // one of the bond items is a bond itself -> don't
                // allocate a new bond name, edit the existing one:
                innerBondModel.getBond().setItems(new ArrayList<String>(Arrays.asList(new String[] { bond.getName() })));
                innerBondModel.getBond().setSelectedItem(bond.getName());
                innerBondModel.getBond().setIsChangeable(false);
                hostInterfaceListModel.postBond(hostInterfaceListModel, innerBondModel, networksToAdd, isAnyManagement);
            } else {
                AsyncQuery _asyncQuery1 = new AsyncQuery();
                _asyncQuery1.setModel(hostInterfaceListModel);
                _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object ReturnValue1) {
                        HostInterfaceListModel innerHostInterfaceListModel = (HostInterfaceListModel) model1;
                        HostBondInterfaceModel bModel = (HostBondInterfaceModel) innerHostInterfaceListModel.getWindow();
                        List<VdsNetworkInterface> bonds = ((VdcQueryReturnValue) ReturnValue1).getReturnValue();
                        List<String> bondNames = new ArrayList<String>();
                        for (VdsNetworkInterface bond : bonds) {
                            bondNames.add(bond.getName());
                        }
                        bModel.getBond().setItems(bondNames);
                        // ((List<Interface>)model.Bond.Options).Sort(a => a.name);
                        bModel.getBond().setSelectedItem(Linq.firstOrDefault(bondNames));
                        boolean hasManagement = false;
                        for (VdsNetworkInterface innerItem : innerHostInterfaceListModel.getSelectedItemsWithVlans()) {
                            if (innerItem.getIsManagement()) {
                                hasManagement = true;
                                break;
                            }
                        }
                        innerHostInterfaceListModel.postBond(innerHostInterfaceListModel, bModel, bModel.getNetwork().getItems() != null ? (ArrayList<Network>) bModel.getNetwork().getItems() : new ArrayList<Network>(), hasManagement);
                    }
                };
                Frontend.getInstance().runQuery(VdcQueryType.GetVdsFreeBondsByVdsId, new IdQueryParameters(host.getId()), _asyncQuery1);
            }
        }
    };
    AsyncDataProvider.getInstance().getClusterNetworkList(_asyncQuery, getEntity().getVdsGroupId());
}
#end_block

#method_before
public void onBond() {
    HostBondInterfaceModel model = (HostBondInterfaceModel) getWindow();
    if (getConfirmWindow() != null) {
        ConfirmationModel confirmModel = (ConfirmationModel) getConfirmWindow();
        if (confirmModel.getLatch().getEntity() == true) {
            model.getCheckConnectivity().setEntity(true);
        }
        cancelConfirm();
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    VDS host = getEntity();
    ArrayList<VdsNetworkInterface> selectedItems = getSelectedItems();
    Network net = model.getNetwork().getSelectedItem();
    // Interface interfaceWithNetwork = items.FirstOrDefault(a => !string.IsNullOrEmpty(a.network_name));
    VdsNetworkInterface interfaceWithNetwork = Linq.findInterfaceNetworkNameNotEmpty(selectedItems);
    // look for lines with vlans
    ArrayList<HostInterfaceLineModel> itemList = (ArrayList<HostInterfaceLineModel>) getItems();
    for (HostInterfaceLineModel lineModel : itemList) {
        if (lineModel.getIsSelected() && lineModel.getVlanSize() == 1) {
            interfaceWithNetwork = lineModel.getVLans().get(0).getInterface();
            // bond action is only enabled if there is one vlaned interface
            break;
        }
    }
    if (interfaceWithNetwork != null) {
        UpdateNetworkToVdsParameters parameters = new UpdateNetworkToVdsParameters(host.getId(), net, selectedItems);
        parameters.setCheckConnectivity(model.getCheckConnectivity().getEntity());
        parameters.setOldNetworkName(interfaceWithNetwork.getNetworkName());
        Map.Entry<String, EntityModel<String>> bondingOption;
        if (model.getBondingOptions().getSelectedItem() != null) {
            bondingOption = model.getBondingOptions().getSelectedItem();
            if (// $NON-NLS-1$
            !bondingOption.getKey().equals("custom")) {
                parameters.setBondingOptions((StringHelper.isNullOrEmpty(bondingOption.getKey()) ? null : bondingOption.getKey()));
            } else {
                EntityModel entityModel = bondingOption.getValue();
                if (entityModel.getEntity() != null) {
                    parameters.setBondingOptions(entityModel.getEntity().toString());
                }
            }
        }
        parameters.setBootProtocol(model.getBootProtocol());
        parameters.setBondName(model.getBond().getSelectedItem());
        if (model.getIsStaticAddress()) {
            parameters.setAddress(model.getAddress().getEntity());
            parameters.setSubnet(model.getSubnet().getEntity());
            if (interfaceWithNetwork.getIsManagement()) {
                parameters.setGateway(model.getGateway().getEntity());
            }
        }
        model.startProgress(null);
        setcurrentModel(model);
        Frontend.getInstance().runAction(VdcActionType.UpdateNetworkToVdsInterface, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
                VdcReturnValueBase returnValueBase = result.getReturnValue();
                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                    EntityModel<Boolean> commitChanges = ((HostBondInterfaceModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                    if (commitChanges.getEntity()) {
                        new SaveNetworkConfigAction(HostInterfaceListModel.this, hostInterfaceListModel.getcurrentModel(), getEntity()).execute();
                    } else {
                        hostInterfaceListModel.getcurrentModel().stopProgress();
                        hostInterfaceListModel.cancel();
                        hostInterfaceListModel.search();
                    }
                } else {
                    hostInterfaceListModel.getcurrentModel().stopProgress();
                }
            }
        }, this);
    } else {
        String[] nics = new String[selectedItems.size()];
        for (int i = 0; i < selectedItems.size(); i++) {
            nics[i] = selectedItems.get(i).getName();
        }
        AddBondParameters parameters = new AddBondParameters(host.getId(), model.getBond().getSelectedItem(), net, nics);
        Map.Entry<String, EntityModel<String>> bondingOption;
        if (model.getBondingOptions().getSelectedItem() != null) {
            bondingOption = model.getBondingOptions().getSelectedItem();
            if (// $NON-NLS-1$
            !bondingOption.getKey().equals("custom")) {
                parameters.setBondingOptions((StringHelper.isNullOrEmpty(bondingOption.getKey()) ? null : bondingOption.getKey()));
            } else {
                EntityModel entityModel = bondingOption.getValue();
                if (entityModel.getEntity() != null) {
                    parameters.setBondingOptions(entityModel.getEntity().toString());
                }
            }
        }
        parameters.setBootProtocol(model.getBootProtocol());
        if (model.getIsStaticAddress()) {
            parameters.setAddress(model.getAddress().getEntity());
            parameters.setSubnet(model.getSubnet().getEntity());
            parameters.setGateway(model.getGateway().getEntity());
        }
        model.startProgress(null);
        setcurrentModel(model);
        Frontend.getInstance().runAction(VdcActionType.AddBond, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
                VdcReturnValueBase returnValueBase = result.getReturnValue();
                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                    EntityModel<Boolean> commitChanges = ((HostBondInterfaceModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                    if (commitChanges.getEntity()) {
                        new SaveNetworkConfigAction(HostInterfaceListModel.this, hostInterfaceListModel.getcurrentModel(), getEntity()).execute();
                    } else {
                        hostInterfaceListModel.getcurrentModel().stopProgress();
                        hostInterfaceListModel.cancel();
                        hostInterfaceListModel.search();
                    }
                } else {
                    hostInterfaceListModel.getcurrentModel().stopProgress();
                }
            }
        }, this);
    }
}
#method_after
public void onBond() {
    HostBondInterfaceModel model = (HostBondInterfaceModel) getWindow();
    if (getConfirmWindow() != null) {
        ConfirmationModel confirmModel = (ConfirmationModel) getConfirmWindow();
        if (confirmModel.getLatch().getEntity() == true) {
            model.getCheckConnectivity().setEntity(true);
        }
        cancelConfirm();
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    VDS host = getEntity();
    ArrayList<VdsNetworkInterface> selectedItems = getSelectedItems();
    Network net = model.getNetwork().getSelectedItem();
    // Interface interfaceWithNetwork = items.FirstOrDefault(a => !string.IsNullOrEmpty(a.network_name));
    VdsNetworkInterface interfaceWithNetwork = Linq.findInterfaceNetworkNameNotEmpty(selectedItems);
    // look for lines with vlans
    ArrayList<HostInterfaceLineModel> itemList = (ArrayList<HostInterfaceLineModel>) getItems();
    for (HostInterfaceLineModel lineModel : itemList) {
        if (lineModel.getIsSelected() && lineModel.getVlanSize() == 1) {
            interfaceWithNetwork = lineModel.getVLans().get(0).getInterface();
            // bond action is only enabled if there is one vlaned interface
            break;
        }
    }
    if (interfaceWithNetwork != null) {
        UpdateNetworkToVdsParameters parameters = new UpdateNetworkToVdsParameters(host.getId(), net, selectedItems);
        parameters.setCheckConnectivity(model.getCheckConnectivity().getEntity());
        parameters.setOldNetworkName(interfaceWithNetwork.getNetworkName());
        Map.Entry<String, EntityModel<String>> bondingOption;
        if (model.getBondingOptions().getSelectedItem() != null) {
            bondingOption = model.getBondingOptions().getSelectedItem();
            if (!bondingOption.getKey().equals("custom")) {
                // $NON-NLS-1$
                parameters.setBondingOptions((StringHelper.isNullOrEmpty(bondingOption.getKey()) ? null : bondingOption.getKey()));
            } else {
                EntityModel entityModel = bondingOption.getValue();
                if (entityModel.getEntity() != null) {
                    parameters.setBondingOptions(entityModel.getEntity().toString());
                }
            }
        }
        parameters.setBootProtocol(model.getBootProtocol());
        parameters.setBondName(model.getBond().getSelectedItem());
        if (model.getIsStaticAddress()) {
            parameters.setAddress(model.getAddress().getEntity());
            parameters.setSubnet(model.getSubnet().getEntity());
            if (interfaceWithNetwork.getIsManagement()) {
                parameters.setGateway(model.getGateway().getEntity());
            }
        }
        model.startProgress();
        setcurrentModel(model);
        Frontend.getInstance().runAction(VdcActionType.UpdateNetworkToVdsInterface, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
                VdcReturnValueBase returnValueBase = result.getReturnValue();
                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                    EntityModel<Boolean> commitChanges = ((HostBondInterfaceModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                    if (commitChanges.getEntity()) {
                        new SaveNetworkConfigAction(HostInterfaceListModel.this, hostInterfaceListModel.getcurrentModel(), getEntity()).execute();
                    } else {
                        hostInterfaceListModel.getcurrentModel().stopProgress();
                        hostInterfaceListModel.cancel();
                        hostInterfaceListModel.search();
                    }
                } else {
                    hostInterfaceListModel.getcurrentModel().stopProgress();
                }
            }
        }, this);
    } else {
        String[] nics = new String[selectedItems.size()];
        for (int i = 0; i < selectedItems.size(); i++) {
            nics[i] = selectedItems.get(i).getName();
        }
        AddBondParameters parameters = new AddBondParameters(host.getId(), model.getBond().getSelectedItem(), net, nics);
        Map.Entry<String, EntityModel<String>> bondingOption;
        if (model.getBondingOptions().getSelectedItem() != null) {
            bondingOption = model.getBondingOptions().getSelectedItem();
            if (!bondingOption.getKey().equals("custom")) {
                // $NON-NLS-1$
                parameters.setBondingOptions((StringHelper.isNullOrEmpty(bondingOption.getKey()) ? null : bondingOption.getKey()));
            } else {
                EntityModel entityModel = bondingOption.getValue();
                if (entityModel.getEntity() != null) {
                    parameters.setBondingOptions(entityModel.getEntity().toString());
                }
            }
        }
        parameters.setBootProtocol(model.getBootProtocol());
        if (model.getIsStaticAddress()) {
            parameters.setAddress(model.getAddress().getEntity());
            parameters.setSubnet(model.getSubnet().getEntity());
            parameters.setGateway(model.getGateway().getEntity());
        }
        model.startProgress();
        setcurrentModel(model);
        Frontend.getInstance().runAction(VdcActionType.AddBond, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
                VdcReturnValueBase returnValueBase = result.getReturnValue();
                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                    EntityModel<Boolean> commitChanges = ((HostBondInterfaceModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                    if (commitChanges.getEntity()) {
                        new SaveNetworkConfigAction(HostInterfaceListModel.this, hostInterfaceListModel.getcurrentModel(), getEntity()).execute();
                    } else {
                        hostInterfaceListModel.getcurrentModel().stopProgress();
                        hostInterfaceListModel.cancel();
                        hostInterfaceListModel.search();
                    }
                } else {
                    hostInterfaceListModel.getcurrentModel().stopProgress();
                }
            }
        }, this);
    }
}
#end_block

#method_before
public void onDetach() {
    HostInterfaceModel model = (HostInterfaceModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    setcurrentModel(model);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) model;
            ArrayList<Network> networks = (ArrayList<Network>) ReturnValue;
            Network defaultNetwork = new Network();
            VdsNetworkInterface nic = (VdsNetworkInterface) getSelectedItem();
            defaultNetwork.setName(nic.getNetworkName());
            Network tempVar = Linq.findNetworkByName(networks, nic.getNetworkName());
            Network net = (tempVar != null) ? tempVar : defaultNetwork;
            hostInterfaceListModel.startProgress(null);
            Frontend.getInstance().runAction(VdcActionType.DetachNetworkFromVdsInterface, new AttachNetworkToVdsParameters(getEntity().getId(), net, nic), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        EntityModel<Boolean> commitChanges = ((HostInterfaceModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                        if (commitChanges.getEntity()) {
                            new SaveNetworkConfigAction(HostInterfaceListModel.this, getcurrentModel(), getEntity()).execute();
                        } else {
                            hostInterfaceListModel.getcurrentModel().stopProgress();
                            hostInterfaceListModel.cancel();
                            hostInterfaceListModel.search();
                        }
                    } else {
                        hostInterfaceListModel.getcurrentModel().stopProgress();
                        hostInterfaceListModel.cancel();
                    }
                }
            }, hostInterfaceListModel);
        }
    };
    AsyncDataProvider.getInstance().getClusterNetworkList(_asyncQuery, getEntity().getVdsGroupId());
}
#method_after
public void onDetach() {
    HostInterfaceModel model = (HostInterfaceModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    setcurrentModel(model);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) model;
            ArrayList<Network> networks = (ArrayList<Network>) ReturnValue;
            Network defaultNetwork = new Network();
            VdsNetworkInterface nic = (VdsNetworkInterface) getSelectedItem();
            defaultNetwork.setName(nic.getNetworkName());
            Network tempVar = Linq.findNetworkByName(networks, nic.getNetworkName());
            Network net = (tempVar != null) ? tempVar : defaultNetwork;
            hostInterfaceListModel.startProgress();
            Frontend.getInstance().runAction(VdcActionType.DetachNetworkFromVdsInterface, new AttachNetworkToVdsParameters(getEntity().getId(), net, nic), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        EntityModel<Boolean> commitChanges = ((HostInterfaceModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                        if (commitChanges.getEntity()) {
                            new SaveNetworkConfigAction(HostInterfaceListModel.this, getcurrentModel(), getEntity()).execute();
                        } else {
                            hostInterfaceListModel.getcurrentModel().stopProgress();
                            hostInterfaceListModel.cancel();
                            hostInterfaceListModel.search();
                        }
                    } else {
                        hostInterfaceListModel.getcurrentModel().stopProgress();
                        hostInterfaceListModel.cancel();
                    }
                }
            }, hostInterfaceListModel);
        }
    };
    AsyncDataProvider.getInstance().getClusterNetworkList(_asyncQuery, getEntity().getVdsGroupId());
}
#end_block

#method_before
public void onSave() {
    HostInterfaceModel model = (HostInterfaceModel) getWindow();
    if (!model.validate()) {
        return;
    }
    String nicName = (String) model.getEntity();
    final VdsNetworkInterface nic = (VdsNetworkInterface) Linq.findInterfaceByName(getAllItems(), nicName);
    if (nic == null) {
        cancel();
        return;
    }
    Network network = model.getNetwork().getSelectedItem();
    // Save changes.
    if (network.getId().equals(Guid.Empty)) {
        if (nic.getIsManagement()) {
            // We are trying to disconnect the management interface from its
            // network -> ask for the user's confirmation before doing that.
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkInterfaceTitle());
            confirmModel.setHelpTag(HelpTag.edit_management_network_interface);
            // $NON-NLS-1$
            confirmModel.setHashName("edit_management_network_interface");
            confirmModel.setMessage(ConstantsManager.getInstance().getMessages().youAreAboutToDisconnectHostInterfaceMsg(nic.getName()));
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnConfirmManagementDetach", this);
            confirmModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
            confirmModel.getCommands().add(tempVar2);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            AsyncQuery _asyncQuery = new AsyncQuery();
            _asyncQuery.setModel(this);
            _asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object ReturnValue) {
                    final HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) model;
                    HostInterfaceModel hostInterfaceModel = (HostInterfaceModel) hostInterfaceListModel.getWindow();
                    ArrayList<Network> networks = (ArrayList<Network>) ReturnValue;
                    Network defaultNetwork = new Network();
                    defaultNetwork.setName(nic.getNetworkName());
                    Network tempVar3 = Linq.findNetworkByName(networks, nic.getNetworkName());
                    Network net = (tempVar3 != null) ? tempVar3 : defaultNetwork;
                    hostInterfaceModel.startProgress(null);
                    setcurrentModel(hostInterfaceModel);
                    Frontend.getInstance().runAction(VdcActionType.DetachNetworkFromVdsInterface, new AttachNetworkToVdsParameters(getEntity().getId(), net, nic), new IFrontendActionAsyncCallback() {

                        @Override
                        public void executed(FrontendActionAsyncResult result) {
                            HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
                            VdcReturnValueBase returnValueBase = result.getReturnValue();
                            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                                EntityModel<Boolean> commitChanges = ((HostInterfaceModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                                if (commitChanges.getEntity()) {
                                    new SaveNetworkConfigAction(HostInterfaceListModel.this, getcurrentModel(), getEntity()).execute();
                                } else {
                                    hostInterfaceListModel.getcurrentModel().stopProgress();
                                    hostInterfaceListModel.cancel();
                                    hostInterfaceListModel.search();
                                }
                            } else {
                                hostInterfaceListModel.getcurrentModel().stopProgress();
                            }
                        }
                    }, hostInterfaceListModel);
                }
            };
            AsyncDataProvider.getInstance().getClusterNetworkList(_asyncQuery, getEntity().getVdsGroupId());
        }
    } else {
        if (model.getProgress() != null) {
            return;
        }
        AttachNetworkToVdsParameters parameters;
        VdcActionType actionType;
        boolean vLanAttached = false;
        boolean bondWithVlans = false;
        boolean isUpdateVlan = false;
        if (nic.getBonded() != null && nic.getBonded()) {
            for (HostInterfaceLineModel item : (ArrayList<HostInterfaceLineModel>) getItems()) {
                if (item.getInterface() != null && item.getInterface().getId().equals(nic.getId())) {
                    if (item.getVLans() != null && item.getVLans().size() > 0) {
                        bondWithVlans = true;
                        for (HostVLan vLan : item.getVLans()) {
                            if (ObjectUtils.objectsEqual(network.getName(), vLan.getNetworkName())) {
                                vLanAttached = true;
                                break;
                            }
                        }
                    }
                    break;
                }
            }
        } else {
            for (VdsNetworkInterface item : getSelectedItemsWithVlans()) {
                if (item.getVlanId() != null && ObjectUtils.objectsEqual(item.getNetworkName(), network.getName())) {
                    isUpdateVlan = true;
                    break;
                }
            }
        }
        // and the selected network in the dialog is a new vlan, attach selected network.
        if ((StringHelper.isNullOrEmpty(nic.getNetworkName()) && (nic.getBonded() == null || !nic.getBonded()) && !isUpdateVlan) || (bondWithVlans && (!vLanAttached && network.getVlanId() != null))) {
            parameters = new AttachNetworkToVdsParameters(getEntity().getId(), network, nic);
            actionType = VdcActionType.AttachNetworkToVdsInterface;
        } else {
            parameters = new UpdateNetworkToVdsParameters(getEntity().getId(), network, new ArrayList<VdsNetworkInterface>(Arrays.asList(new VdsNetworkInterface[] { nic })));
            parameters.setOldNetworkName((nic.getNetworkName() != null ? nic.getNetworkName() : network.getName()));
            parameters.setCheckConnectivity(model.getCheckConnectivity().getEntity());
            actionType = VdcActionType.UpdateNetworkToVdsInterface;
        }
        Map.Entry<String, EntityModel<String>> bondingOption;
        if (model.getBondingOptions().getSelectedItem() != null) {
            bondingOption = model.getBondingOptions().getSelectedItem();
            if (// $NON-NLS-1$
            !bondingOption.getKey().equals("custom")) {
                parameters.setBondingOptions((StringHelper.isNullOrEmpty(bondingOption.getKey()) ? null : bondingOption.getKey()));
            } else {
                EntityModel entityModel = bondingOption.getValue();
                if (entityModel.getEntity() != null) {
                    parameters.setBondingOptions(entityModel.getEntity().toString());
                }
            }
        }
        parameters.setBootProtocol(model.getBootProtocol());
        if (model.getIsStaticAddress()) {
            parameters.setAddress(model.getAddress().getEntity());
            parameters.setSubnet(model.getSubnet().getEntity());
        }
        model.startProgress(null);
        setcurrentModel(model);
        Frontend.getInstance().runAction(actionType, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
                VdcReturnValueBase returnValueBase = result.getReturnValue();
                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                    EntityModel<Boolean> commitChanges = ((HostInterfaceModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                    if (commitChanges.getEntity()) {
                        new SaveNetworkConfigAction(HostInterfaceListModel.this, hostInterfaceListModel.getcurrentModel(), getEntity()).execute();
                    } else {
                        hostInterfaceListModel.getcurrentModel().stopProgress();
                        hostInterfaceListModel.cancel();
                        hostInterfaceListModel.search();
                    }
                } else {
                    hostInterfaceListModel.getcurrentModel().stopProgress();
                }
            }
        }, this);
    }
}
#method_after
public void onSave() {
    HostInterfaceModel model = (HostInterfaceModel) getWindow();
    if (!model.validate()) {
        return;
    }
    String nicName = (String) model.getEntity();
    final VdsNetworkInterface nic = (VdsNetworkInterface) Linq.findInterfaceByName(getAllItems(), nicName);
    if (nic == null) {
        cancel();
        return;
    }
    Network network = model.getNetwork().getSelectedItem();
    // Save changes.
    if (network.getId().equals(Guid.Empty)) {
        if (nic.getIsManagement()) {
            // We are trying to disconnect the management interface from its
            // network -> ask for the user's confirmation before doing that.
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkInterfaceTitle());
            confirmModel.setHelpTag(HelpTag.edit_management_network_interface);
            // $NON-NLS-1$
            confirmModel.setHashName("edit_management_network_interface");
            confirmModel.setMessage(ConstantsManager.getInstance().getMessages().youAreAboutToDisconnectHostInterfaceMsg(nic.getName()));
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnConfirmManagementDetach", this);
            confirmModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
            confirmModel.getCommands().add(tempVar2);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            AsyncQuery _asyncQuery = new AsyncQuery();
            _asyncQuery.setModel(this);
            _asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object ReturnValue) {
                    final HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) model;
                    HostInterfaceModel hostInterfaceModel = (HostInterfaceModel) hostInterfaceListModel.getWindow();
                    ArrayList<Network> networks = (ArrayList<Network>) ReturnValue;
                    Network defaultNetwork = new Network();
                    defaultNetwork.setName(nic.getNetworkName());
                    Network tempVar3 = Linq.findNetworkByName(networks, nic.getNetworkName());
                    Network net = (tempVar3 != null) ? tempVar3 : defaultNetwork;
                    hostInterfaceModel.startProgress();
                    setcurrentModel(hostInterfaceModel);
                    Frontend.getInstance().runAction(VdcActionType.DetachNetworkFromVdsInterface, new AttachNetworkToVdsParameters(getEntity().getId(), net, nic), new IFrontendActionAsyncCallback() {

                        @Override
                        public void executed(FrontendActionAsyncResult result) {
                            HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
                            VdcReturnValueBase returnValueBase = result.getReturnValue();
                            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                                EntityModel<Boolean> commitChanges = ((HostInterfaceModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                                if (commitChanges.getEntity()) {
                                    new SaveNetworkConfigAction(HostInterfaceListModel.this, getcurrentModel(), getEntity()).execute();
                                } else {
                                    hostInterfaceListModel.getcurrentModel().stopProgress();
                                    hostInterfaceListModel.cancel();
                                    hostInterfaceListModel.search();
                                }
                            } else {
                                hostInterfaceListModel.getcurrentModel().stopProgress();
                            }
                        }
                    }, hostInterfaceListModel);
                }
            };
            AsyncDataProvider.getInstance().getClusterNetworkList(_asyncQuery, getEntity().getVdsGroupId());
        }
    } else {
        if (model.getProgress() != null) {
            return;
        }
        AttachNetworkToVdsParameters parameters;
        VdcActionType actionType;
        boolean vLanAttached = false;
        boolean bondWithVlans = false;
        boolean isUpdateVlan = false;
        if (nic.getBonded() != null && nic.getBonded()) {
            for (HostInterfaceLineModel item : (ArrayList<HostInterfaceLineModel>) getItems()) {
                if (item.getInterface() != null && item.getInterface().getId().equals(nic.getId())) {
                    if (item.getVLans() != null && item.getVLans().size() > 0) {
                        bondWithVlans = true;
                        for (HostVLan vLan : item.getVLans()) {
                            if (ObjectUtils.objectsEqual(network.getName(), vLan.getNetworkName())) {
                                vLanAttached = true;
                                break;
                            }
                        }
                    }
                    break;
                }
            }
        } else {
            for (VdsNetworkInterface item : getSelectedItemsWithVlans()) {
                if (item.getVlanId() != null && ObjectUtils.objectsEqual(item.getNetworkName(), network.getName())) {
                    isUpdateVlan = true;
                    break;
                }
            }
        }
        // and the selected network in the dialog is a new vlan, attach selected network.
        if ((StringHelper.isNullOrEmpty(nic.getNetworkName()) && (nic.getBonded() == null || !nic.getBonded()) && !isUpdateVlan) || (bondWithVlans && (!vLanAttached && network.getVlanId() != null))) {
            parameters = new AttachNetworkToVdsParameters(getEntity().getId(), network, nic);
            actionType = VdcActionType.AttachNetworkToVdsInterface;
        } else {
            parameters = new UpdateNetworkToVdsParameters(getEntity().getId(), network, new ArrayList<VdsNetworkInterface>(Arrays.asList(new VdsNetworkInterface[] { nic })));
            parameters.setOldNetworkName((nic.getNetworkName() != null ? nic.getNetworkName() : network.getName()));
            parameters.setCheckConnectivity(model.getCheckConnectivity().getEntity());
            actionType = VdcActionType.UpdateNetworkToVdsInterface;
        }
        Map.Entry<String, EntityModel<String>> bondingOption;
        if (model.getBondingOptions().getSelectedItem() != null) {
            bondingOption = model.getBondingOptions().getSelectedItem();
            if (!bondingOption.getKey().equals("custom")) {
                // $NON-NLS-1$
                parameters.setBondingOptions((StringHelper.isNullOrEmpty(bondingOption.getKey()) ? null : bondingOption.getKey()));
            } else {
                EntityModel entityModel = bondingOption.getValue();
                if (entityModel.getEntity() != null) {
                    parameters.setBondingOptions(entityModel.getEntity().toString());
                }
            }
        }
        parameters.setBootProtocol(model.getBootProtocol());
        if (model.getIsStaticAddress()) {
            parameters.setAddress(model.getAddress().getEntity());
            parameters.setSubnet(model.getSubnet().getEntity());
        }
        model.startProgress();
        setcurrentModel(model);
        Frontend.getInstance().runAction(actionType, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
                VdcReturnValueBase returnValueBase = result.getReturnValue();
                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                    EntityModel<Boolean> commitChanges = ((HostInterfaceModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                    if (commitChanges.getEntity()) {
                        new SaveNetworkConfigAction(HostInterfaceListModel.this, hostInterfaceListModel.getcurrentModel(), getEntity()).execute();
                    } else {
                        hostInterfaceListModel.getcurrentModel().stopProgress();
                        hostInterfaceListModel.cancel();
                        hostInterfaceListModel.search();
                    }
                } else {
                    hostInterfaceListModel.getcurrentModel().stopProgress();
                }
            }
        }, this);
    }
}
#end_block

#method_before
public void onSaveNetworkConfig() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    model.startProgress(null);
    setcurrentModel(model);
    new SaveNetworkConfigAction(this, model, getEntity()).execute();
}
#method_after
public void onSaveNetworkConfig() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    model.startProgress();
    setcurrentModel(model);
    new SaveNetworkConfigAction(this, model, getEntity()).execute();
}
#end_block

#method_before
public void onConfirmManagementDetach() {
    HostInterfaceModel model = (HostInterfaceModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    String nicName = (String) model.getEntity();
    final VdsNetworkInterface nic = (VdsNetworkInterface) Linq.findInterfaceByName(getInterfaceItems(), nicName);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) model;
            ArrayList<Network> networks = (ArrayList<Network>) ReturnValue;
            Network defaultNetwork = new Network();
            defaultNetwork.setName(nic.getNetworkName());
            Network tempVar = Linq.findNetworkByName(networks, nic.getNetworkName());
            Network net = (tempVar != null) ? tempVar : defaultNetwork;
            hostInterfaceListModel.startProgress(null);
            setcurrentModel(hostInterfaceListModel);
            Frontend.getInstance().runAction(VdcActionType.DetachNetworkFromVdsInterface, new AttachNetworkToVdsParameters(getEntity().getId(), net, nic), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        EntityModel<Boolean> commitChanges = ((HostInterfaceModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                        if (commitChanges.getEntity()) {
                            new SaveNetworkConfigAction(HostInterfaceListModel.this, hostInterfaceListModel.getcurrentModel(), getEntity()).execute();
                        } else {
                            hostInterfaceListModel.getcurrentModel().stopProgress();
                            hostInterfaceListModel.cancel();
                            hostInterfaceListModel.search();
                        }
                    } else {
                        hostInterfaceListModel.getcurrentModel().stopProgress();
                    }
                }
            }, hostInterfaceListModel);
        }
    };
    AsyncDataProvider.getInstance().getClusterNetworkList(_asyncQuery, getEntity().getVdsGroupId());
}
#method_after
public void onConfirmManagementDetach() {
    HostInterfaceModel model = (HostInterfaceModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    String nicName = (String) model.getEntity();
    final VdsNetworkInterface nic = (VdsNetworkInterface) Linq.findInterfaceByName(getInterfaceItems(), nicName);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) model;
            ArrayList<Network> networks = (ArrayList<Network>) ReturnValue;
            Network defaultNetwork = new Network();
            defaultNetwork.setName(nic.getNetworkName());
            Network tempVar = Linq.findNetworkByName(networks, nic.getNetworkName());
            Network net = (tempVar != null) ? tempVar : defaultNetwork;
            hostInterfaceListModel.startProgress();
            setcurrentModel(hostInterfaceListModel);
            Frontend.getInstance().runAction(VdcActionType.DetachNetworkFromVdsInterface, new AttachNetworkToVdsParameters(getEntity().getId(), net, nic), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        EntityModel<Boolean> commitChanges = ((HostInterfaceModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                        if (commitChanges.getEntity()) {
                            new SaveNetworkConfigAction(HostInterfaceListModel.this, hostInterfaceListModel.getcurrentModel(), getEntity()).execute();
                        } else {
                            hostInterfaceListModel.getcurrentModel().stopProgress();
                            hostInterfaceListModel.cancel();
                            hostInterfaceListModel.search();
                        }
                    } else {
                        hostInterfaceListModel.getcurrentModel().stopProgress();
                    }
                }
            }, hostInterfaceListModel);
        }
    };
    AsyncDataProvider.getInstance().getClusterNetworkList(_asyncQuery, getEntity().getVdsGroupId());
}
#end_block

#method_before
public void syncAllHostNetworks() {
    Frontend.getInstance().runAction(VdcActionType.SyncAllHostNetworks, new VdsActionParameters(getEntity().getId()), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
        }
    }, null);
}
#method_after
public void syncAllHostNetworks() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().syncAllHostNetworkConfirmationDialogTitle());
    model.setHelpTag(HelpTag.sync_all_host_networks);
    // $NON-NLS-1$
    model.setHashName("sync_all_host_networks");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToSyncAllHostNetworksMsg());
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSyncAllHostNetworkConfirm", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getEditCommand()) {
        edit();
    } else if (command == getEditManagementNetworkCommand()) {
        editManagementNetwork();
    } else if (command == getSetupNetworksCommand()) {
        setupNetworks();
    } else if (command == getBondCommand()) {
        bond();
    } else if (command == getDetachCommand()) {
        detach();
    } else if (command == getSaveNetworkConfigCommand()) {
        saveNetworkConfig();
    } else if (command == getSyncAllHostNetworksCommand()) {
        syncAllHostNetworks();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "OnEditManagementNetwork".equals(command.getName())) {
        onEditManagementNetwork();
    } else if (// $NON-NLS-1$
    "OnEditManagementNetworkConfirmation".equals(command.getName())) {
        onEditManagementNetworkConfirmation(false);
    } else if (// $NON-NLS-1$
    "OnEditManagementNetworkConfirmation_Bond".equals(command.getName())) {
        onEditManagementNetworkConfirmation(true);
    } else if (// $NON-NLS-1$
    "OnBond".equals(command.getName())) {
        onBond();
    } else if (// $NON-NLS-1$
    "OnDetach".equals(command.getName())) {
        onDetach();
    } else if (// $NON-NLS-1$
    "OnConfirmManagementDetach".equals(command.getName())) {
        onConfirmManagementDetach();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "CancelConfirm".equals(command.getName())) {
        cancelConfirm();
    } else if (// $NON-NLS-1$
    "OnSaveNetworkConfig".equals(command.getName())) {
        onSaveNetworkConfig();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getEditCommand()) {
        edit();
    } else if (command == getEditManagementNetworkCommand()) {
        editManagementNetwork();
    } else if (command == getSetupNetworksCommand()) {
        setupNetworks();
    } else if (command == getBondCommand()) {
        bond();
    } else if (command == getDetachCommand()) {
        detach();
    } else if (command == getSaveNetworkConfigCommand()) {
        saveNetworkConfig();
    } else if (command == getSyncAllHostNetworksCommand()) {
        syncAllHostNetworks();
    } else if ("OnSave".equals(command.getName())) {
        // $NON-NLS-1$
        onSave();
    } else if ("OnEditManagementNetwork".equals(command.getName())) {
        // $NON-NLS-1$
        onEditManagementNetwork();
    } else if ("OnEditManagementNetworkConfirmation".equals(command.getName())) {
        // $NON-NLS-1$
        onEditManagementNetworkConfirmation(false);
    } else if ("OnEditManagementNetworkConfirmation_Bond".equals(command.getName())) {
        // $NON-NLS-1$
        onEditManagementNetworkConfirmation(true);
    } else if ("OnBond".equals(command.getName())) {
        // $NON-NLS-1$
        onBond();
    } else if ("OnDetach".equals(command.getName())) {
        // $NON-NLS-1$
        onDetach();
    } else if ("OnConfirmManagementDetach".equals(command.getName())) {
        // $NON-NLS-1$
        onConfirmManagementDetach();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("CancelConfirm".equals(command.getName())) {
        // $NON-NLS-1$
        cancelConfirm();
    } else if ("OnSaveNetworkConfig".equals(command.getName())) {
        // $NON-NLS-1$
        onSaveNetworkConfig();
    } else if ("OnSyncAllHostNetworkConfirm".equals(command.getName())) {
        // $NON-NLS-1$
        onSyncAllHostNetworkConfirm();
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    HostSetupNetworksParameters parameters = generateSyncAllHostNetworksParameters();
    VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.PersistentHostSetupNetworks, parameters, cloneContextAndDetachFromParent());
    if (!retVal.getSucceeded()) {
        auditLogDirector.log(new AuditLogableBase(super.getVdsId()), AuditLogType.HOST_SYNC_ALL_NETWORKS_FAILED);
        propagateFailure(retVal);
    } else {
        auditLogDirector.log(new AuditLogableBase(super.getVdsId()), AuditLogType.HOST_SYNC_ALL_NETWORKS_FINISHED);
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    HostSetupNetworksParameters parameters = generateSyncAllHostNetworksParameters();
    VdcReturnValueBase retVal = runInternalAction(VdcActionType.PersistentHostSetupNetworks, parameters, cloneContextAndDetachFromParent());
    if (!retVal.getSucceeded()) {
        propagateFailure(retVal);
    } else {
        setSucceeded(true);
    }
}
#end_block

#method_before
private HostSetupNetworksParameters generateSyncAllHostNetworksParameters() {
    HostSetupNetworksParameters parameters = new HostSetupNetworksParameters(getVdsId());
    VdcQueryReturnValue returnValue = getBackend().runInternalQuery(VdcQueryType.GetNetworkAttachmentsByHostId, new IdQueryParameters(getVdsId()));
    List<NetworkAttachment> networkAttachments = returnValue.getReturnValue();
    List<NetworkAttachment> unSyncNetworkAttachments = LinqUtils.filter(networkAttachments, new NetworkNotInSyncPredicate());
    for (NetworkAttachment networkAttachment : unSyncNetworkAttachments) {
        networkAttachment.setOverrideConfiguration(true);
    }
    parameters.setNetworkAttachments(unSyncNetworkAttachments);
    return parameters;
}
#method_after
private HostSetupNetworksParameters generateSyncAllHostNetworksParameters() {
    HostSetupNetworksParameters parameters = new HostSetupNetworksParameters(getVdsId());
    VdcQueryReturnValue returnValue = runInternalQuery(VdcQueryType.GetNetworkAttachmentsByHostId, new IdQueryParameters(getVdsId()));
    List<NetworkAttachment> networkAttachments = returnValue.getReturnValue();
    List<NetworkAttachment> unSyncNetworkAttachments = LinqUtils.filter(networkAttachments, new NetworkNotInSyncPredicate());
    for (NetworkAttachment networkAttachment : unSyncNetworkAttachments) {
        networkAttachment.setOverrideConfiguration(true);
    }
    parameters.setNetworkAttachments(unSyncNetworkAttachments);
    return parameters;
}
#end_block

#method_before
@Mapping(from = Template.class, to = VmTemplate.class)
public static VmTemplate map(Template model, VmTemplate incoming) {
    VmTemplate entity = incoming != null ? incoming : new VmTemplate();
    mapVmBaseModelToEntity(entity, model);
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setClusterArch(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        if (entity.getVmInit() == null) {
            entity.setVmInit(new VmInit());
        }
        entity.getVmInit().setDomain(model.getDomain().getName());
    }
    if (model.getVersion() != null) {
        if (model.getVersion().getBaseTemplate() != null && StringUtils.isNotEmpty(model.getVersion().getBaseTemplate().getId())) {
            entity.setBaseTemplateId(Guid.createGuidFromString(model.getVersion().getBaseTemplate().getId()));
        }
        if (model.getVersion().isSetVersionName()) {
            entity.setTemplateVersionName(model.getVersion().getVersionName());
        }
    // numbering is generated in the backend, hence even if user specified version number, we ignore it.
    }
    return entity;
}
#method_after
@Mapping(from = Template.class, to = VmTemplate.class)
public static VmTemplate map(Template model, VmTemplate incoming) {
    VmTemplate entity = incoming != null ? incoming : new VmTemplate();
    mapVmBaseModelToEntity(entity, model);
    if (model.isSetInitialization()) {
        entity.setVmInit(InitializationMapper.map(model.getInitialization(), new VmInit()));
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setClusterArch(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        if (entity.getVmInit() == null) {
            entity.setVmInit(new VmInit());
        }
        entity.getVmInit().setDomain(model.getDomain().getName());
    }
    if (model.getVersion() != null) {
        if (model.getVersion().getBaseTemplate() != null && StringUtils.isNotEmpty(model.getVersion().getBaseTemplate().getId())) {
            entity.setBaseTemplateId(Guid.createGuidFromString(model.getVersion().getBaseTemplate().getId()));
        }
        if (model.getVersion().isSetVersionName()) {
            entity.setTemplateVersionName(model.getVersion().getVersionName());
        }
    // numbering is generated in the backend, hence even if user specified version number, we ignore it.
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = Template.class, to = VmStatic.class)
public static VmStatic map(Template model, VmStatic incoming) {
    VmStatic staticVm = incoming != null ? incoming : new VmStatic();
    mapVmBaseModelToEntity(staticVm, model);
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        staticVm.getVmInit().setDomain(model.getDomain().getName());
    }
    return staticVm;
}
#method_after
@Mapping(from = Template.class, to = VmStatic.class)
public static VmStatic map(Template model, VmStatic incoming) {
    VmStatic staticVm = incoming != null ? incoming : new VmStatic();
    mapVmBaseModelToEntity(staticVm, model);
    if (model.isSetInitialization()) {
        staticVm.setVmInit(InitializationMapper.map(model.getInitialization(), new VmInit()));
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        staticVm.getVmInit().setDomain(model.getDomain().getName());
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = Template.class)
public static Template map(VmTemplate entity, Template incoming) {
    Template model = incoming != null ? incoming : new Template();
    mapVmBaseEntityToModel(model, entity);
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
    }
    if (entity.getDefaultBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getOsId()));
        if (entity.getDefaultBootSequence() != null) {
            for (Boot boot : VmMapper.map(entity.getDefaultBootSequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getClusterArch() != null) {
        model.getCpu().setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    }
    model.setDisplay(DisplayMapper.map(entity, null));
    model.getDisplay().setDisconnectAction(map(entity.getConsoleDisconnectAction(), null).toString());
    // so need to populate template version properties
    if (!entity.isBaseTemplate()) {
        TemplateVersion version = new TemplateVersion();
        version.setVersionName(entity.getTemplateVersionName());
        version.setVersionNumber(entity.getTemplateVersionNumber());
        Template baseTemplate = new Template();
        baseTemplate.setId(entity.getBaseTemplateId().toString());
        version.setBaseTemplate(baseTemplate);
        model.setVersion(version);
    }
    return model;
}
#method_after
@Mapping(from = VmTemplate.class, to = Template.class)
public static Template map(VmTemplate entity, Template incoming) {
    Template model = incoming != null ? incoming : new Template();
    mapVmBaseEntityToModel(model, entity);
    if (entity.getVmInit() != null) {
        model.setInitialization(InitializationMapper.map(entity.getVmInit(), null));
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
    }
    if (entity.getDefaultBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getOsId()));
        if (entity.getDefaultBootSequence() != null) {
            for (Boot boot : VmMapper.map(entity.getDefaultBootSequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getClusterArch() != null) {
        model.getCpu().setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    }
    model.setDisplay(DisplayMapper.map(entity, null));
    model.getDisplay().setDisconnectAction(map(entity.getConsoleDisconnectAction(), null).toString());
    // so need to populate template version properties
    if (!entity.isBaseTemplate()) {
        TemplateVersion version = new TemplateVersion();
        version.setVersionName(entity.getTemplateVersionName());
        version.setVersionNumber(entity.getTemplateVersionNumber());
        Template baseTemplate = new Template();
        baseTemplate.setId(entity.getBaseTemplateId().toString());
        version.setBaseTemplate(baseTemplate);
        model.setVersion(version);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    mapVmBaseModelToEntity(staticVm, vm);
    if (!vm.isSetMemory() && staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetPlacementPolicy()) {
        if (vm.getPlacementPolicy().isSetAffinity()) {
            // read migration policy
            VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
            if (vmAffinity != null) {
                staticVm.setMigrationSupport(map(vmAffinity, null));
            }
        }
        // reset previous dedicated host or hosts
        Set<Guid> hostGuidsSet = new HashSet<>();
        // read single host if exist
        if (vm.getPlacementPolicy().isSetHost()) {
            hostGuidsSet.add(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
        }
        // read multiple hosts if there are few
        if (vm.getPlacementPolicy().isSetHosts() && vm.getPlacementPolicy().getHosts().getHosts().size() > 0) {
            hostGuidsSet.addAll(staticVm.getDedicatedVmForVdsList());
            for (Host currHost : vm.getPlacementPolicy().getHosts().getHosts()) {
                Guid hostGuid;
                if (currHost.isSetId()) {
                    hostGuid = Guid.createGuidFromString(currHost.getId());
                } else {
                    continue;
                }
                hostGuidsSet.add(hostGuid);
            }
        }
        staticVm.setDedicatedVmForVdsList(new LinkedList<Guid>(hostGuidsSet));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(TemplateMapper.map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        // We don't want to override the domain if it set via the Initialization object
        if (!vm.isSetInitialization() || !vm.getInitialization().isSetDomain()) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    if (vm.isSetNumaTuneMode()) {
        NumaTuneMode mode = NumaTuneMode.fromValue(vm.getNumaTuneMode());
        if (mode != null) {
            staticVm.setNumaTuneMode(map(mode, null));
        }
    }
    if (vm.isSetExternalHostProvider()) {
        String providerId = vm.getExternalHostProvider().getId();
        staticVm.setProviderId(providerId == null ? null : GuidUtils.asGuid(providerId));
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    mapVmBaseModelToEntity(staticVm, vm);
    if (!vm.isSetMemory() && staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetPlacementPolicy()) {
        if (vm.getPlacementPolicy().isSetAffinity()) {
            // read migration policy
            VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
            if (vmAffinity != null) {
                staticVm.setMigrationSupport(map(vmAffinity, null));
            }
        }
        // reset previous dedicated host or hosts
        Set<Guid> hostGuidsSet = new HashSet<>();
        // read single host if exist
        if (vm.getPlacementPolicy().isSetHost()) {
            hostGuidsSet.add(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
        }
        // read multiple hosts if there are few
        if (vm.getPlacementPolicy().isSetHosts() && vm.getPlacementPolicy().getHosts().getHosts().size() > 0) {
            for (Host currHost : vm.getPlacementPolicy().getHosts().getHosts()) {
                Guid hostGuid;
                if (currHost.isSetId()) {
                    hostGuid = Guid.createGuidFromString(currHost.getId());
                } else {
                    continue;
                }
                hostGuidsSet.add(hostGuid);
            }
        }
        staticVm.setDedicatedVmForVdsList(new LinkedList<Guid>(hostGuidsSet));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(InitializationMapper.map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        // We don't want to override the domain if it set via the Initialization object
        if (!vm.isSetInitialization() || !vm.getInitialization().isSetDomain()) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    if (vm.isSetNumaTuneMode()) {
        NumaTuneMode mode = NumaTuneMode.fromValue(vm.getNumaTuneMode());
        if (mode != null) {
            staticVm.setNumaTuneMode(map(mode, null));
        }
    }
    if (vm.isSetExternalHostProvider()) {
        String providerId = vm.getExternalHostProvider().getId();
        staticVm.setProviderId(providerId == null ? null : GuidUtils.asGuid(providerId));
    }
    return staticVm;
}
#end_block

#method_before
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template, boolean showDynamicInfo) {
    VM model = template != null ? template : new VM();
    mapVmBaseEntityToModel(model, entity.getStaticData());
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getInstanceTypeId() != null) {
        model.setInstanceType(new InstanceType());
        model.getInstanceType().setId(entity.getInstanceTypeId().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getStopReason() != null) {
        model.setStopReason(entity.getStopReason());
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.isUseHostCpuFlags()) {
        model.getCpu().setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    model.getCpu().setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    model.getCpu().setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    model.setDisplay(new Display());
    // and dynamic value (current/last run value, that can be different in case of run-once or edit while running)
    if (showDynamicInfo && entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
    }
    // fill dynamic data
    if (entity.getDynamicData() != null && !entity.getStatus().isNotRunning()) {
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        final boolean hasGuestOsVersion = entity.getGuestOsVersion() != null && !entity.getGuestOsVersion().isEmpty();
        if (hasGuestOsVersion) {
            GuestOperatingSystem os = model.getGuestOperatingSystem();
            if (os == null) {
                os = new GuestOperatingSystem();
                model.setGuestOperatingSystem(os);
            }
            os.setArchitecture(entity.getGuestOsArch().name());
            os.setCodename(entity.getGuestOsCodename());
            os.setDistribution(entity.getGuestOsDistribution());
            String kernelVersionString = entity.getGuestOsKernelVersion();
            if (StringUtils.isNotEmpty(kernelVersionString)) {
                org.ovirt.engine.api.model.Version kernelVersion = VersionMapper.fromKernelVersionString(kernelVersionString);
                if (kernelVersion != null) {
                    if (os.getKernel() == null) {
                        os.setKernel(new Kernel());
                    }
                    os.getKernel().setVersion(kernelVersion);
                    os.getKernel().getVersion().setFullVersion(entity.getGuestOsKernelVersion());
                }
            }
            String osVersionString = entity.getGuestOsVersion();
            if (StringUtils.isNotEmpty(osVersionString)) {
                os.setVersion(VersionMapper.fromVersionString(osVersionString));
                if (os.getVersion() != null) {
                    os.getVersion().setFullVersion(entity.getGuestOsVersion());
                }
            }
            os.setFamily(entity.getGuestOsType().name());
        }
        final boolean hasTimezoneName = entity.getGuestOsTimezoneName() != null && !entity.getGuestOsTimezoneName().isEmpty();
        if (hasTimezoneName) {
            TimeZone guestTz = model.getGuestTimeZone();
            if (guestTz == null) {
                guestTz = new TimeZone();
                model.setGuestTimeZone(guestTz);
            }
            guestTz.setName(entity.getGuestOsTimezoneName());
            guestTz.setUtcOffset(TimeZoneMapper.mapUtcOffsetToDisplayString(entity.getGuestOsTimezoneOffset()));
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setRunOnce(entity.isRunOnce());
        org.ovirt.engine.core.common.businessentities.GraphicsType graphicsType = deriveGraphicsType(entity.getGraphicsInfos());
        if (graphicsType != null) {
            model.getDisplay().setType(DisplayMapper.map(graphicsType, null).value());
            GraphicsInfo graphicsInfo = entity.getGraphicsInfos().get(graphicsType);
            model.getDisplay().setAddress(graphicsInfo == null ? null : graphicsInfo.getIp());
            Integer displayPort = graphicsInfo == null ? null : graphicsInfo.getPort();
            model.getDisplay().setPort(displayPort == null || displayPort.equals(-1) ? null : displayPort);
            Integer displaySecurePort = graphicsInfo == null ? null : graphicsInfo.getTlsPort();
            model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort.equals(-1) ? null : displaySecurePort);
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    model.getDisplay().setMonitors(entity.getNumOfMonitors());
    model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
    model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    model.getDisplay().setFileTransferEnabled(entity.isSpiceFileTransferEnabled());
    model.getDisplay().setCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
    model.getDisplay().setProxy(getEffectiveSpiceProxy(entity));
    model.getDisplay().setDisconnectAction(map(entity.getConsoleDisconnectAction(), null).toString());
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVdsList().size() == 1) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVdsList().get(0).toString());
    } else if (entity.getDedicatedVmForVdsList().size() > 1) {
        Hosts hostsList = new Hosts();
        for (Guid hostGuid : entity.getDedicatedVmForVdsList()) {
            Host newHost = new Host();
            newHost.setId(hostGuid.toString());
            hostsList.getHosts().add(newHost);
        }
        model.getPlacementPolicy().setHosts(hostsList);
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    if (entity.getVmInit() != null) {
        model.setInitialization(TemplateMapper.map(entity.getVmInit(), null));
    }
    model.setNextRunConfigurationExists(entity.isNextRunConfigurationExists());
    model.setNumaTuneMode(map(entity.getNumaTuneMode(), null));
    if (entity.getProviderId() != null) {
        model.setExternalHostProvider(new ExternalHostProvider());
        model.getExternalHostProvider().setId(entity.getProviderId().toString());
    }
    return model;
}
#method_after
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template, boolean showDynamicInfo) {
    VM model = template != null ? template : new VM();
    mapVmBaseEntityToModel(model, entity.getStaticData());
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getInstanceTypeId() != null) {
        model.setInstanceType(new InstanceType());
        model.getInstanceType().setId(entity.getInstanceTypeId().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getStopReason() != null) {
        model.setStopReason(entity.getStopReason());
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.isUseHostCpuFlags()) {
        model.getCpu().setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    model.getCpu().setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    model.getCpu().setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    model.setDisplay(new Display());
    // and dynamic value (current/last run value, that can be different in case of run-once or edit while running)
    if (showDynamicInfo && entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
    }
    // fill dynamic data
    if (entity.getDynamicData() != null && !entity.getStatus().isNotRunning()) {
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        final boolean hasGuestOsVersion = entity.getGuestOsVersion() != null && !entity.getGuestOsVersion().isEmpty();
        if (hasGuestOsVersion) {
            GuestOperatingSystem os = model.getGuestOperatingSystem();
            if (os == null) {
                os = new GuestOperatingSystem();
                model.setGuestOperatingSystem(os);
            }
            os.setArchitecture(entity.getGuestOsArch().name());
            os.setCodename(entity.getGuestOsCodename());
            os.setDistribution(entity.getGuestOsDistribution());
            String kernelVersionString = entity.getGuestOsKernelVersion();
            if (StringUtils.isNotEmpty(kernelVersionString)) {
                org.ovirt.engine.api.model.Version kernelVersion = VersionMapper.fromKernelVersionString(kernelVersionString);
                if (kernelVersion != null) {
                    if (os.getKernel() == null) {
                        os.setKernel(new Kernel());
                    }
                    os.getKernel().setVersion(kernelVersion);
                    os.getKernel().getVersion().setFullVersion(entity.getGuestOsKernelVersion());
                }
            }
            String osVersionString = entity.getGuestOsVersion();
            if (StringUtils.isNotEmpty(osVersionString)) {
                os.setVersion(VersionMapper.fromVersionString(osVersionString));
                if (os.getVersion() != null) {
                    os.getVersion().setFullVersion(entity.getGuestOsVersion());
                }
            }
            os.setFamily(entity.getGuestOsType().name());
        }
        final boolean hasTimezoneName = entity.getGuestOsTimezoneName() != null && !entity.getGuestOsTimezoneName().isEmpty();
        if (hasTimezoneName) {
            TimeZone guestTz = model.getGuestTimeZone();
            if (guestTz == null) {
                guestTz = new TimeZone();
                model.setGuestTimeZone(guestTz);
            }
            guestTz.setName(entity.getGuestOsTimezoneName());
            guestTz.setUtcOffset(TimeZoneMapper.mapUtcOffsetToDisplayString(entity.getGuestOsTimezoneOffset()));
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setRunOnce(entity.isRunOnce());
        org.ovirt.engine.core.common.businessentities.GraphicsType graphicsType = deriveGraphicsType(entity.getGraphicsInfos());
        if (graphicsType != null) {
            model.getDisplay().setType(DisplayMapper.map(graphicsType, null).value());
            GraphicsInfo graphicsInfo = entity.getGraphicsInfos().get(graphicsType);
            model.getDisplay().setAddress(graphicsInfo == null ? null : graphicsInfo.getIp());
            Integer displayPort = graphicsInfo == null ? null : graphicsInfo.getPort();
            model.getDisplay().setPort(displayPort == null || displayPort.equals(-1) ? null : displayPort);
            Integer displaySecurePort = graphicsInfo == null ? null : graphicsInfo.getTlsPort();
            model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort.equals(-1) ? null : displaySecurePort);
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    model.getDisplay().setMonitors(entity.getNumOfMonitors());
    model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
    model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    model.getDisplay().setFileTransferEnabled(entity.isSpiceFileTransferEnabled());
    model.getDisplay().setCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
    model.getDisplay().setProxy(getEffectiveSpiceProxy(entity));
    model.getDisplay().setDisconnectAction(map(entity.getConsoleDisconnectAction(), null).toString());
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVdsList().size() == 1) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVdsList().get(0).toString());
    } else if (entity.getDedicatedVmForVdsList().size() > 1) {
        Hosts hostsList = new Hosts();
        for (Guid hostGuid : entity.getDedicatedVmForVdsList()) {
            Host newHost = new Host();
            newHost.setId(hostGuid.toString());
            hostsList.getHosts().add(newHost);
        }
        model.getPlacementPolicy().setHosts(hostsList);
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    if (entity.getVmInit() != null) {
        model.setInitialization(InitializationMapper.map(entity.getVmInit(), null));
    }
    model.setNextRunConfigurationExists(entity.isNextRunConfigurationExists());
    model.setNumaTuneMode(map(entity.getNumaTuneMode(), null));
    if (entity.getProviderId() != null) {
        model.setExternalHostProvider(new ExternalHostProvider());
        model.getExternalHostProvider().setId(entity.getProviderId().toString());
    }
    return model;
}
#end_block

#method_before
@Override
public void setListValue(List<T> value) {
    // Reset the current selected values, we will locate the right selected values below.
    selectedList.clear();
    selectedList.addAll(value);
    ListBox listBox = asListBox();
    // Unselect anything set by the 'normal' setValue
    if (listBox.getSelectedIndex() > -1) {
        listBox.setItemSelected(listBox.getSelectedIndex(), false);
    }
    for (T item : selectedList) {
        if (typedItemList.indexOf(item) > -1 && typedItemList.indexOf(item) < listBox.getItemCount()) {
            listBox.setItemSelected(typedItemList.indexOf(item), true);
        }
    }
}
#method_after
@Override
public void setListValue(List<T> value) {
    // Reset the current selected values, we will locate the right selected values below.
    selectedList.clear();
    selectedList.addAll(value);
    ListBox listBox = asListBox();
    // Unselect anything set by the 'normal' setValue
    if (listBox.getSelectedIndex() > -1) {
        listBox.setItemSelected(listBox.getSelectedIndex(), false);
    }
    for (T item : selectedList) {
        int itemIndex = typedItemList.indexOf(item);
        if (itemIndex > -1 && itemIndex < listBox.getItemCount()) {
            listBox.setItemSelected(itemIndex, true);
        }
    }
}
#end_block

#method_before
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setProtocol(getProtocol());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setExternalStatus(getExternalStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setOnlineCpus(getOnlineCpus());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setVersion(getVersion());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setPmEnabled(isPmEnabled());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterfsCliVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setLibrbdVersion(getLibrbdVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    vds.setBalloonEnabled(isBalloonEnabled());
    vds.setNumaNodeList(getNumaNodeList());
    vds.setAutoNumaBalancing(getAutoNumaBalancing());
    vds.setFenceAgents(getFenceAgents());
    vds.setVdsGroupCompatibilityVersion(getVdsGroupCompatibilityVersion());
    vds.setUpdateAvailable(isUpdateAvailable());
    vds.setHostDevicePassthroughEnabled(isHostDevicePassthroughEnabled());
    return vds;
}
#method_after
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setProtocol(getProtocol());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setExternalStatus(getExternalStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setOnlineCpus(getOnlineCpus());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setVersion(getVersion());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setPmEnabled(isPmEnabled());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterfsCliVersion(getGlusterfsCliVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setLibrbdVersion(getLibrbdVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    vds.setBalloonEnabled(isBalloonEnabled());
    vds.setNumaNodeList(getNumaNodeList());
    vds.setAutoNumaBalancing(getAutoNumaBalancing());
    vds.setFenceAgents(getFenceAgents());
    vds.setVdsGroupCompatibilityVersion(getVdsGroupCompatibilityVersion());
    vds.setUpdateAvailable(isUpdateAvailable());
    vds.setHostDevicePassthroughEnabled(isHostDevicePassthroughEnabled());
    return vds;
}
#end_block

#method_before
private static VmStatic buildVmStaticDataFromExternalProvider(Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.vm_guid) || !xmlRpcStruct.containsKey(VdsProperties.vm_name) || !xmlRpcStruct.containsKey(VdsProperties.mem_size_mb) || !xmlRpcStruct.containsKey(VdsProperties.num_of_cpus)) {
        return null;
    }
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(Guid.createGuidFromString((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    vmStatic.setName((String) xmlRpcStruct.get(VdsProperties.vm_name));
    vmStatic.setMemSizeMb(parseIntVdsProperty(xmlRpcStruct.get(VdsProperties.mem_size_mb)));
    vmStatic.setNumOfSockets(parseIntVdsProperty(xmlRpcStruct.get(VdsProperties.num_of_cpus)));
    vmStatic.setCustomCpuName((String) xmlRpcStruct.get(VdsProperties.cpu_model));
    vmStatic.setCustomEmulatedMachine((String) xmlRpcStruct.get(VdsProperties.emulatedMachine));
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        for (Object disk : (Object[]) xmlRpcStruct.get(VdsProperties.vm_disks)) {
            Map<String, Object> diskMap = (Map<String, Object>) disk;
            if (VdsProperties.Disk.equals(diskMap.get(VdsProperties.type))) {
                DiskImage image = buildDiskImageFromExternalProvider(diskMap);
                vmStatic.getImages().add(image);
            }
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NETWORKS)) {
        for (Object networkMap : (Object[]) xmlRpcStruct.get(VdsProperties.NETWORKS)) {
            vmStatic.getInterfaces().add(buildNetworkInterfaceFromExternalProvider((Map<String, Object>) networkMap));
        }
    }
    return vmStatic;
}
#method_after
private static VmStatic buildVmStaticDataFromExternalProvider(Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.vm_guid) || !xmlRpcStruct.containsKey(VdsProperties.vm_name) || !xmlRpcStruct.containsKey(VdsProperties.mem_size_mb) || !xmlRpcStruct.containsKey(VdsProperties.num_of_cpus)) {
        return null;
    }
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(Guid.createGuidFromString((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    vmStatic.setName((String) xmlRpcStruct.get(VdsProperties.vm_name));
    vmStatic.setMemSizeMb(parseIntVdsProperty(xmlRpcStruct.get(VdsProperties.mem_size_mb)));
    vmStatic.setNumOfSockets(parseIntVdsProperty(xmlRpcStruct.get(VdsProperties.num_of_cpus)));
    vmStatic.setCustomCpuName((String) xmlRpcStruct.get(VdsProperties.cpu_model));
    vmStatic.setCustomEmulatedMachine((String) xmlRpcStruct.get(VdsProperties.emulatedMachine));
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        for (Object disk : (Object[]) xmlRpcStruct.get(VdsProperties.vm_disks)) {
            Map<String, Object> diskMap = (Map<String, Object>) disk;
            if (VdsProperties.Disk.equals(diskMap.get(VdsProperties.type))) {
                DiskImage image = buildDiskImageFromExternalProvider(diskMap);
                vmStatic.getImages().add(image);
            }
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NETWORKS)) {
        int idx = 0;
        for (Object networkMap : (Object[]) xmlRpcStruct.get(VdsProperties.NETWORKS)) {
            VmNetworkInterface nic = buildNetworkInterfaceFromExternalProvider((Map<String, Object>) networkMap);
            nic.setName(String.format("nic%d", ++idx));
            nic.setVmName(vmStatic.getName());
            nic.setVmId(vmStatic.getId());
            vmStatic.getInterfaces().add(nic);
        }
    }
    return vmStatic;
}
#end_block

#method_before
private static DiskImage buildDiskImageFromExternalProvider(Map<String, Object> map) {
    DiskImage image = new DiskImage();
    image.setDiskAlias((String) map.get(VdsProperties.Alias));
    image.setSize(Long.parseLong((String) map.get(VdsProperties.DISK_VIRTUAL_SIZE)));
    image.setActualSize(Long.parseLong((String) map.get(VdsProperties.DISK_ALLOCATION)));
    image.setId(Guid.newGuid());
    return image;
}
#method_after
private static DiskImage buildDiskImageFromExternalProvider(Map<String, Object> map) {
    DiskImage image = new DiskImage();
    image.setDiskAlias((String) map.get(VdsProperties.Alias));
    image.setSize(Long.parseLong((String) map.get(VdsProperties.DISK_VIRTUAL_SIZE)));
    image.setActualSizeInBytes(Long.parseLong((String) map.get(VdsProperties.DISK_ALLOCATION)));
    image.setId(Guid.newGuid());
    return image;
}
#end_block

#method_before
private static VmNetworkInterface buildNetworkInterfaceFromExternalProvider(Map<String, Object> map) {
    VmNetworkInterface nic = new VmNetworkInterface();
    nic.setMacAddress((String) map.get(VdsProperties.MAC_ADDR));
    nic.setName((String) map.get(VdsProperties.BRIDGE));
    nic.setType(VmInterfaceType.pv.getValue());
    if (map.containsKey(VdsProperties.Model)) {
        String model = (String) map.get(VdsProperties.Model);
        for (VmInterfaceType type : VmInterfaceType.values()) {
            if (model.equals(type.getInternalName())) {
                nic.setType(type.getValue());
                break;
            }
        }
    }
    return nic;
}
#method_after
private static VmNetworkInterface buildNetworkInterfaceFromExternalProvider(Map<String, Object> map) {
    VmNetworkInterface nic = new VmNetworkInterface();
    nic.setMacAddress((String) map.get(VdsProperties.MAC_ADDR));
    nic.setRemoteNetworkName((String) map.get(VdsProperties.BRIDGE));
    nic.setType(VmInterfaceType.pv.getValue());
    if (map.containsKey(VdsProperties.Model)) {
        String model = (String) map.get(VdsProperties.Model);
        for (VmInterfaceType type : VmInterfaceType.values()) {
            if (model.equals(type.getInternalName())) {
                nic.setType(type.getValue());
                break;
            }
        }
    }
    return nic;
}
#end_block

#method_before
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        boolean cfgEntriesDeprecated = FeatureSupported.cfgEntriesDeprecated(vds.getVdsGroupCompatibilityVersion());
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            VdsNetworkInterface bond = new Bond();
            updateCommonInterfaceData(bond, vds, entry);
            bond.setBonded(true);
            Map<String, Object> bondProperties = entry.getValue();
            if (bondProperties != null) {
                bond.setMacAddress((String) bondProperties.get("hwaddr"));
                if (bondProperties.get("slaves") != null) {
                    addBondDeviceToHost(vds, bond, (Object[]) bondProperties.get("slaves"));
                }
                Object bondOptions = null;
                if (cfgEntriesDeprecated) {
                    Map<String, Object> bondOptionsMap = new HashMap<>();
                    bondOptionsMap.putAll((Map<String, Object>) bondProperties.get("opts"));
                    String bondOptionsString = "";
                    String mode = (String) bondOptionsMap.get("mode");
                    String miimon = (String) bondOptionsMap.get("miimon");
                    if (mode != null && miimon != null) {
                        bondOptionsString = String.format("mode=%s miimon=%s", mode, miimon);
                        bondOptionsMap.remove("mode");
                        bondOptionsMap.remove("miimon");
                    }
                    for (Map.Entry<String, Object> optionEntry : bondOptionsMap.entrySet()) {
                        bondOptionsString = String.format("%s %s=%s", bondOptionsString, optionEntry.getKey(), optionEntry.getValue());
                    }
                    bondOptions = bondOptionsString.isEmpty() ? null : bondOptionsString;
                } else {
                    Map<String, Object> config = (Map<String, Object>) bondProperties.get("cfg");
                    bondOptions = (config == null) ? null : config.get("BONDING_OPTS");
                }
                if (bondOptions != null) {
                    bond.setBondOptions(bondOptions.toString());
                }
            }
        }
    }
}
#method_after
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        boolean cfgEntriesDeprecated = FeatureSupported.cfgEntriesDeprecated(vds.getVdsGroupCompatibilityVersion());
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            VdsNetworkInterface bond = new Bond();
            updateCommonInterfaceData(bond, vds, entry);
            bond.setBonded(true);
            Map<String, Object> bondProperties = entry.getValue();
            if (bondProperties != null) {
                bond.setMacAddress((String) bondProperties.get("hwaddr"));
                if (bondProperties.get("slaves") != null) {
                    addBondDeviceToHost(vds, bond, (Object[]) bondProperties.get("slaves"));
                }
                Object bondOptions = null;
                if (cfgEntriesDeprecated) {
                    Map<String, Object> bondOptionsMap = new HashMap<>();
                    Map<String, Object> bondOpts = (Map<String, Object>) bondProperties.get("opts");
                    if (bondOpts != null) {
                        bondOptionsMap.putAll(bondOpts);
                    }
                    String bondOptionsString = "";
                    String mode = (String) bondOptionsMap.get("mode");
                    String miimon = (String) bondOptionsMap.get("miimon");
                    if (mode != null && miimon != null) {
                        bondOptionsString = String.format("mode=%s miimon=%s", mode, miimon);
                        bondOptionsMap.remove("mode");
                        bondOptionsMap.remove("miimon");
                    }
                    for (Map.Entry<String, Object> optionEntry : bondOptionsMap.entrySet()) {
                        bondOptionsString = String.format("%s %s=%s", bondOptionsString, optionEntry.getKey(), optionEntry.getValue());
                    }
                    bondOptions = bondOptionsString.isEmpty() ? null : bondOptionsString;
                } else {
                    Map<String, Object> config = (Map<String, Object>) bondProperties.get("cfg");
                    bondOptions = (config == null) ? null : config.get("BONDING_OPTS");
                }
                if (bondOptions != null) {
                    bond.setBondOptions(bondOptions.toString());
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public boolean prepareConnectHostToStoragePoolServers(ConnectHostToStoragePoolServersParameters parameters, List<StorageServerConnections> connections) {
    List<StorageServerConnections> res = updateIfaces(connections, parameters.getVds().getId());
    connections.clear();
    connections.addAll(res);
    return true;
}
#method_after
@Override
public void prepareConnectHostToStoragePoolServers(ConnectHostToStoragePoolServersParameters parameters, List<StorageServerConnections> connections) {
    List<StorageServerConnections> res = updateIfaces(connections, parameters.getVds().getId());
    connections.clear();
    connections.addAll(res);
}
#end_block

#method_before
@Override
public boolean prepareConnectHostToStoragePoolServers(ConnectHostToStoragePoolServersParameters parameters, List<StorageServerConnections> connections) {
    return true;
}
#method_after
@Override
public void prepareConnectHostToStoragePoolServers(ConnectHostToStoragePoolServersParameters parameters, List<StorageServerConnections> connections) {
// default implementation
}
#end_block

#method_before
private boolean connectStorageServersByType(StorageType storageType, List<StorageServerConnections> connections) {
    if (!StorageHelperDirector.getInstance().getItem(storageType).prepareConnectHostToStoragePoolServers(getParameters(), connections)) {
        return false;
    }
    Map<String, String> retValues = (Map<String, String>) runVdsCommand(VDSCommandType.ConnectStorageServer, new StorageServerConnectionManagementVDSParameters(getVds().getId(), getStoragePool().getId(), storageType, connections)).getReturnValue();
    return StorageHelperDirector.getInstance().getItem(storageType).isConnectSucceeded(retValues, connections);
}
#method_after
private boolean connectStorageServersByType(StorageType storageType, List<StorageServerConnections> connections) {
    StorageHelperDirector.getInstance().getItem(storageType).prepareConnectHostToStoragePoolServers(getParameters(), connections);
    Map<String, String> retValues = (Map<String, String>) runVdsCommand(VDSCommandType.ConnectStorageServer, new StorageServerConnectionManagementVDSParameters(getVds().getId(), getStoragePool().getId(), storageType, connections)).getReturnValue();
    return StorageHelperDirector.getInstance().getItem(storageType).isConnectSucceeded(retValues, connections);
}
#end_block

#method_before
@Override
protected Pair<Boolean, EngineFault> runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type) {
    Provider provider = getProviderDao().get(Guid.createGuidFromString(storageDomain.getStorage()));
    List<LibvirtSecret> libvirtSecrets = getLibvirtSecretDao().getAllByProviderId(provider.getId());
    VDS vds = getVdsDao().get(vdsId);
    if (!isLibrbdAvailable(vds)) {
        log.error("Couldn't found librbd1 package on vds {} (needed for storage domain {}).", vds.getName(), storageDomain.getName());
        StorageHelperBase.addMessageToAuditLog(AuditLogType.NO_LIBRBD_PACKAGE_AVAILABLE_ON_VDS, null, vds.getName());
        return new Pair<>(false, null);
    }
    return registerLibvirtSecrets(storageDomain, vds, libvirtSecrets);
}
#method_after
@Override
protected Pair<Boolean, EngineFault> runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type) {
    Provider provider = getProviderDao().get(Guid.createGuidFromString(storageDomain.getStorage()));
    List<LibvirtSecret> libvirtSecrets = getLibvirtSecretDao().getAllByProviderId(provider.getId());
    VDS vds = getVdsDao().get(vdsId);
    if (!isLibrbdAvailable(vds)) {
        log.error("Couldn't found librbd1 package on vds {} (needed for storage domain {}).", vds.getName(), storageDomain.getName());
        addMessageToAuditLog(AuditLogType.NO_LIBRBD_PACKAGE_AVAILABLE_ON_VDS, null, vds.getName());
        return new Pair<>(false, null);
    }
    return registerLibvirtSecrets(storageDomain, vds, libvirtSecrets);
}
#end_block

#method_before
public static Pair<Boolean, EngineFault> registerLibvirtSecrets(StorageDomain storageDomain, VDS vds, List<LibvirtSecret> libvirtSecrets) {
    VDSReturnValue returnValue;
    if (!libvirtSecrets.isEmpty()) {
        try {
            returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RegisterLibvirtSecrets, new RegisterLibvirtSecretsVDSParameters(vds.getId(), libvirtSecrets));
        } catch (RuntimeException e) {
            log.error("Failed to register libvirt secret for storage domain {} on vds {}. Error: {}", storageDomain.getName(), vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return new Pair<>(false, null);
        }
        if (!returnValue.getSucceeded()) {
            StorageHelperBase.addMessageToAuditLog(AuditLogType.FAILED_TO_REGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to register libvirt secret for storage domain {} on vds {}.", storageDomain.getName(), vds.getName());
            EngineFault engineFault = new EngineFault();
            engineFault.setError(returnValue.getVdsError().getCode());
            return new Pair<>(false, engineFault);
        }
    }
    return new Pair<>(true, null);
}
#method_after
public static Pair<Boolean, EngineFault> registerLibvirtSecrets(StorageDomain storageDomain, VDS vds, List<LibvirtSecret> libvirtSecrets) {
    VDSReturnValue returnValue;
    if (!libvirtSecrets.isEmpty()) {
        try {
            returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RegisterLibvirtSecrets, new RegisterLibvirtSecretsVDSParameters(vds.getId(), libvirtSecrets));
        } catch (RuntimeException e) {
            log.error("Failed to register libvirt secret for storage domain {} on vds {}. Error: {}", storageDomain.getName(), vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return new Pair<>(false, null);
        }
        if (!returnValue.getSucceeded()) {
            addMessageToAuditLog(AuditLogType.FAILED_TO_REGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to register libvirt secret for storage domain {} on vds {}.", storageDomain.getName(), vds.getName());
            EngineFault engineFault = new EngineFault();
            engineFault.setError(returnValue.getVdsError().getCode());
            return new Pair<>(false, engineFault);
        }
    }
    return new Pair<>(true, null);
}
#end_block

#method_before
public static boolean unregisterLibvirtSecrets(StorageDomain storageDomain, VDS vds, List<LibvirtSecret> libvirtSecrets) {
    List<Guid> libvirtSecretsUuids = Entities.getIds(libvirtSecrets);
    if (!libvirtSecrets.isEmpty()) {
        VDSReturnValue returnValue;
        try {
            returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UnregisterLibvirtSecrets, new UnregisterLibvirtSecretsVDSParameters(vds.getId(), libvirtSecretsUuids));
        } catch (RuntimeException e) {
            StorageHelperBase.addMessageToAuditLog(AuditLogType.FAILED_TO_UNREGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}. Error: {}", storageDomain.getName(), vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return false;
        }
        if (!returnValue.getSucceeded()) {
            StorageHelperBase.addMessageToAuditLog(AuditLogType.FAILED_TO_UNREGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}.", storageDomain.getName(), vds.getName());
            return false;
        }
    }
    return true;
}
#method_after
public static boolean unregisterLibvirtSecrets(StorageDomain storageDomain, VDS vds, List<LibvirtSecret> libvirtSecrets) {
    List<Guid> libvirtSecretsUuids = Entities.getIds(libvirtSecrets);
    if (!libvirtSecrets.isEmpty()) {
        VDSReturnValue returnValue;
        try {
            returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UnregisterLibvirtSecrets, new UnregisterLibvirtSecretsVDSParameters(vds.getId(), libvirtSecretsUuids));
        } catch (RuntimeException e) {
            addMessageToAuditLog(AuditLogType.FAILED_TO_UNREGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}. Error: {}", storageDomain.getName(), vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return false;
        }
        if (!returnValue.getSucceeded()) {
            addMessageToAuditLog(AuditLogType.FAILED_TO_UNREGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}.", storageDomain.getName(), vds.getName());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public boolean prepareDisconnectHostFromStoragePoolServers(HostStoragePoolParametersBase parameters, List<StorageServerConnections> connections) {
    return prepareStorageServer(parameters, connections);
}
#method_after
@Override
public void prepareDisconnectHostFromStoragePoolServers(HostStoragePoolParametersBase parameters, List<StorageServerConnections> connections) {
    prepareStorageServer(parameters, connections);
}
#end_block

#method_before
private boolean prepareStorageServer(HostStoragePoolParametersBase parameters, List<StorageServerConnections> connections) {
    List<StorageServerConnections> res = updateIfaces(connections, parameters.getVds().getId());
    connections.clear();
    connections.addAll(res);
    return true;
}
#method_after
private void prepareStorageServer(HostStoragePoolParametersBase parameters, List<StorageServerConnections> connections) {
    List<StorageServerConnections> res = updateIfaces(connections, parameters.getVds().getId());
    connections.clear();
    connections.addAll(res);
}
#end_block

#method_before
@Override
public boolean prepareDisconnectHostFromStoragePoolServers(HostStoragePoolParametersBase parameters, List<StorageServerConnections> connections) {
    return true;
}
#method_after
@Override
public void prepareDisconnectHostFromStoragePoolServers(HostStoragePoolParametersBase parameters, List<StorageServerConnections> connections) {
// default implementation
}
#end_block

#method_before
@Override
protected void executeCommand() {
    initConnectionList(true);
    Set<StorageType> storageTypes = Collections.emptySet();
    for (Map.Entry<StorageType, List<StorageServerConnections>> connectionToType : getConnectionsTypeMap().entrySet()) {
        disconnectStorageByType(connectionToType.getKey(), connectionToType.getValue());
        storageTypes.add(connectionToType.getKey());
    }
    for (StorageType storageType : storageTypes) {
        if (!StorageHelperDirector.getInstance().getItem(storageType).disconnectHostFromStoragePoolServersCommandCompleted(getParameters())) {
            auditLogDirector.log(new AuditLogableBase(getParameters().getVdsId()), AuditLogType.FAILED_TO_REGISTER_LIBVIRT_SECRET_ON_VDS);
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    initConnectionList(true);
    for (Map.Entry<StorageType, List<StorageServerConnections>> connectionToType : getConnectionsTypeMap().entrySet()) {
        disconnectStorageByType(connectionToType.getKey(), connectionToType.getValue());
        Pair<Boolean, AuditLogType> result = StorageHelperDirector.getInstance().getItem(connectionToType.getKey()).disconnectHostFromStoragePoolServersCommandCompleted(getParameters());
        if (!result.getFirst()) {
            auditLogDirector.log(new AuditLogableBase(getParameters().getVdsId()), result.getSecond());
        }
    }
}
#end_block

#method_before
protected void initConnectionList(boolean includeInactiveDomains) {
    Set<StorageDomainStatus> statuses;
    statuses = includeInactiveDomains ? EnumSet.of(StorageDomainStatus.Active, StorageDomainStatus.Unknown, StorageDomainStatus.Inactive) : EnumSet.of(StorageDomainStatus.Active, StorageDomainStatus.Unknown);
    _connections = DbFacade.getInstance().getStorageServerConnectionDao().getStorageConnectionsByStorageTypeAndStatus(getStoragePool().getId(), null, statuses);
    updateConnectionsTypeMap();
}
#method_after
protected void initConnectionList(boolean includeInactiveDomains) {
    Set<StorageDomainStatus> statuses;
    statuses = includeInactiveDomains ? EnumSet.of(StorageDomainStatus.Active, StorageDomainStatus.Unknown, StorageDomainStatus.Inactive) : EnumSet.of(StorageDomainStatus.Active, StorageDomainStatus.Unknown);
    _connections = DbFacade.getInstance().getStorageServerConnectionDao().getStorageConnectionsByStorageTypeAndStatus(getStoragePool().getId(), null, statuses);
    updateConnectionsTypeMap();
    updateConnectionMapForFiberChannel(statuses);
}
#end_block

#method_before
@Override
protected Pair<Boolean, EngineFault> runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type) {
    Provider provider = getProviderDao().get(Guid.createGuidFromString(storageDomain.getStorage()));
    List<LibvirtSecret> libvirtSecrets = getLibvirtSecretDao().getAllByProviderId(provider.getId());
    VDS vds = getVdsDao().get(vdsId);
    if (!isLibrbdAvailable(vds)) {
        log.error("Couldn't found librbd1 package on vds {} (needed for storage domain {}).", vds.getName(), storageDomain.getName());
        StorageHelperBase.addMessageToAuditLog(AuditLogType.NO_LIBRBD_PACKAGE_AVAILABLE_ON_VDS, null, vds.getName());
        return new Pair<>(false, null);
    }
    return registerLibvirtSecrets(storageDomain, vds, libvirtSecrets);
}
#method_after
@Override
protected Pair<Boolean, EngineFault> runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type) {
    Provider provider = getProviderDao().get(Guid.createGuidFromString(storageDomain.getStorage()));
    List<LibvirtSecret> libvirtSecrets = getLibvirtSecretDao().getAllByProviderId(provider.getId());
    VDS vds = getVdsDao().get(vdsId);
    if (!isLibrbdAvailable(vds)) {
        log.error("Couldn't found librbd1 package on vds {} (needed for storage domain {}).", vds.getName(), storageDomain.getName());
        addMessageToAuditLog(AuditLogType.NO_LIBRBD_PACKAGE_AVAILABLE_ON_VDS, null, vds.getName());
        return new Pair<>(false, null);
    }
    return registerLibvirtSecrets(storageDomain, vds, libvirtSecrets);
}
#end_block

#method_before
public static Pair<Boolean, EngineFault> registerLibvirtSecrets(StorageDomain storageDomain, VDS vds, List<LibvirtSecret> libvirtSecrets) {
    VDSReturnValue returnValue;
    if (!libvirtSecrets.isEmpty()) {
        try {
            returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RegisterLibvirtSecrets, new RegisterLibvirtSecretsVDSParameters(vds.getId(), libvirtSecrets));
        } catch (RuntimeException e) {
            log.error("Failed to register libvirt secret for storage domain {} on vds {}. Error: {}", storageDomain.getName(), vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return new Pair<>(false, null);
        }
        if (!returnValue.getSucceeded()) {
            StorageHelperBase.addMessageToAuditLog(AuditLogType.FAILED_TO_REGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to register libvirt secret for storage domain {} on vds {}.", storageDomain.getName(), vds.getName());
            EngineFault engineFault = new EngineFault();
            engineFault.setError(returnValue.getVdsError().getCode());
            return new Pair<>(false, engineFault);
        }
    }
    return new Pair<>(true, null);
}
#method_after
public static Pair<Boolean, EngineFault> registerLibvirtSecrets(StorageDomain storageDomain, VDS vds, List<LibvirtSecret> libvirtSecrets) {
    VDSReturnValue returnValue;
    if (!libvirtSecrets.isEmpty()) {
        try {
            returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RegisterLibvirtSecrets, new RegisterLibvirtSecretsVDSParameters(vds.getId(), libvirtSecrets));
        } catch (RuntimeException e) {
            log.error("Failed to register libvirt secret for storage domain {} on vds {}. Error: {}", storageDomain.getName(), vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return new Pair<>(false, null);
        }
        if (!returnValue.getSucceeded()) {
            addMessageToAuditLog(AuditLogType.FAILED_TO_REGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to register libvirt secret for storage domain {} on vds {}.", storageDomain.getName(), vds.getName());
            EngineFault engineFault = new EngineFault();
            engineFault.setError(returnValue.getVdsError().getCode());
            return new Pair<>(false, engineFault);
        }
    }
    return new Pair<>(true, null);
}
#end_block

#method_before
public static boolean unregisterLibvirtSecrets(StorageDomain storageDomain, VDS vds, List<LibvirtSecret> libvirtSecrets) {
    List<Guid> libvirtSecretsUuids = Entities.getIds(libvirtSecrets);
    if (!libvirtSecrets.isEmpty()) {
        VDSReturnValue returnValue;
        try {
            returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UnregisterLibvirtSecrets, new UnregisterLibvirtSecretsVDSParameters(vds.getId(), libvirtSecretsUuids));
        } catch (RuntimeException e) {
            StorageHelperBase.addMessageToAuditLog(AuditLogType.FAILED_TO_UNREGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}. Error: {}", storageDomain.getName(), vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return false;
        }
        if (!returnValue.getSucceeded()) {
            StorageHelperBase.addMessageToAuditLog(AuditLogType.FAILED_TO_UNREGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}.", storageDomain.getName(), vds.getName());
            return false;
        }
    }
    return true;
}
#method_after
public static boolean unregisterLibvirtSecrets(StorageDomain storageDomain, VDS vds, List<LibvirtSecret> libvirtSecrets) {
    List<Guid> libvirtSecretsUuids = Entities.getIds(libvirtSecrets);
    if (!libvirtSecrets.isEmpty()) {
        VDSReturnValue returnValue;
        try {
            returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UnregisterLibvirtSecrets, new UnregisterLibvirtSecretsVDSParameters(vds.getId(), libvirtSecretsUuids));
        } catch (RuntimeException e) {
            addMessageToAuditLog(AuditLogType.FAILED_TO_UNREGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}. Error: {}", storageDomain.getName(), vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return false;
        }
        if (!returnValue.getSucceeded()) {
            addMessageToAuditLog(AuditLogType.FAILED_TO_UNREGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}.", storageDomain.getName(), vds.getName());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public boolean disconnectHostFromStoragePoolServersCommandCompleted(HostStoragePoolParametersBase parameters) {
    return unregisterLibvirtSecrets(parameters.getVds(), parameters.getStoragePool());
}
#method_after
@Override
public Pair<Boolean, AuditLogType> disconnectHostFromStoragePoolServersCommandCompleted(HostStoragePoolParametersBase parameters) {
    if (FeatureSupported.cinderProviderSupported(parameters.getStoragePool().getCompatibilityVersion())) {
        // unregister all libvirt secrets if needed
        VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RegisterLibvirtSecrets, new RegisterLibvirtSecretsVDSParameters(parameters.getVds().getId(), Collections.<LibvirtSecret>emptyList(), true));
        if (!returnValue.getSucceeded()) {
            log.error("Failed to unregister libvirt secret on vds {}.", parameters.getVds().getName());
            return new Pair<Boolean, AuditLogType>(false, AuditLogType.FAILED_TO_REGISTER_LIBVIRT_SECRET_ON_VDS);
        }
    }
    return new Pair<Boolean, AuditLogType>(true, null);
}
#end_block

#method_before
@Override
public boolean prepareConnectHostToStoragePoolServers(ConnectHostToStoragePoolServersParameters parameters, List<StorageServerConnections> connections) {
    return true;
}
#method_after
@Override
public void prepareConnectHostToStoragePoolServers(ConnectHostToStoragePoolServersParameters parameters, List<StorageServerConnections> connections) {
// default implementation
}
#end_block

#method_before
@Override
public boolean prepareDisconnectHostFromStoragePoolServers(HostStoragePoolParametersBase parameters, List<StorageServerConnections> connections) {
    return true;
}
#method_after
@Override
public void prepareDisconnectHostFromStoragePoolServers(HostStoragePoolParametersBase parameters, List<StorageServerConnections> connections) {
// default implementation
}
#end_block

#method_before
@Override
public boolean disconnectHostFromStoragePoolServersCommandCompleted(HostStoragePoolParametersBase parameters) {
    return true;
}
#method_after
@Override
public Pair<Boolean, AuditLogType> disconnectHostFromStoragePoolServersCommandCompleted(HostStoragePoolParametersBase parameters) {
    return new Pair<Boolean, AuditLogType>(true, null);
}
#end_block

#method_before
@Override
protected Pair<Boolean, EngineFault> runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type) {
    List<VDS> vdss = getVdsDao().getAllForStoragePoolAndStatus(getVdsDao().get(vdsId).getStoragePoolId(), VDSStatus.Up);
    for (VDS vds : vdss) {
        if (vds.getGlusterVersion() == null) {
            log.error("Couldn't found glusterfs-server package on vds {} (needed for creating gluster storage domain).", vds.getName());
            StorageHelperBase.addMessageToAuditLog(AuditLogType.GLUSTER_PACKAGES_NOT_INSTALLED, null, vds.getName());
            return new Pair<>(false, null);
        }
    }
    return super.runConnectionStorageToDomain(storageDomain, vdsId, type);
}
#method_after
@Override
protected Pair<Boolean, EngineFault> runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type) {
    VDS vds = getVdsDao().get(vdsId);
    if (!canVDSConnectToGlusterfs(vds)) {
        log.error("Couldn't find glusterfs-cli package on vds {} (needed for connecting storage domain {}).", vds.getName(), storageDomain.getName());
        StorageHelperBase.addMessageToAuditLog(AuditLogType.VDS_CANNOT_CONNECT_TO_GLUSTERFS, null, vds.getName());
        return new Pair<>(false, null);
    }
    return super.runConnectionStorageToDomain(storageDomain, vdsId, type);
}
#end_block

#method_before
private VdsDao getVdsDao() {
    return getDbFacade().getVdsDao();
}
#method_after
private static VdsDao getVdsDao() {
    return getDbFacade().getVdsDao();
}
#end_block

#method_before
@Override
public Pair<Boolean, AuditLogType> disconnectHostFromStoragePoolServersCommandCompleted(HostStoragePoolParametersBase parameters) {
    if (FeatureSupported.cinderProviderSupported(parameters.getStoragePool().getCompatibilityVersion())) {
        // unregister all libvirt secrets if needed
        boolean returnValue = registerLibvirtSecretsImpl(parameters.getVds(), Collections.<LibvirtSecret>emptyList(), true);
        if (!returnValue) {
            log.error("Failed to register libvirt secret on vds {}.", parameters.getVds().getName());
            return new Pair<Boolean, AuditLogType>(false, AuditLogType.FAILED_TO_REGISTER_LIBVIRT_SECRET_ON_VDS);
        }
    }
    return new Pair<Boolean, AuditLogType>(true, null);
}
#method_after
@Override
public Pair<Boolean, AuditLogType> disconnectHostFromStoragePoolServersCommandCompleted(HostStoragePoolParametersBase parameters) {
    if (FeatureSupported.cinderProviderSupported(parameters.getStoragePool().getCompatibilityVersion())) {
        // unregister all libvirt secrets if needed
        VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RegisterLibvirtSecrets, new RegisterLibvirtSecretsVDSParameters(parameters.getVds().getId(), Collections.<LibvirtSecret>emptyList(), true));
        if (!returnValue.getSucceeded()) {
            log.error("Failed to unregister libvirt secret on vds {}.", parameters.getVds().getName());
            return new Pair<Boolean, AuditLogType>(false, AuditLogType.FAILED_TO_REGISTER_LIBVIRT_SECRET_ON_VDS);
        }
    }
    return new Pair<Boolean, AuditLogType>(true, null);
}
#end_block

#method_before
private boolean handleLibvirtSecrets(CommandContext cmdContext, VDS vds, Guid poolId) {
    List<LibvirtSecret> libvirtSecrets = DbFacade.getInstance().getLibvirtSecretDao().getAllByStoragePoolIdFilteredByActiveStorageDomains(poolId);
    if (!libvirtSecrets.isEmpty() && !registerLibvirtSecretsImpl(vds, libvirtSecrets, false)) {
        setNonOperational(cmdContext, vds.getId(), NonOperationalReason.LIBVIRT_SECRETS_REGISTRATION_FAILURE);
        return false;
    }
    return true;
}
#method_after
private boolean handleLibvirtSecrets(CommandContext cmdContext, VDS vds, Guid poolId) {
    List<LibvirtSecret> libvirtSecrets = DbFacade.getInstance().getLibvirtSecretDao().getAllByStoragePoolIdFilteredByActiveStorageDomains(poolId);
    if (!libvirtSecrets.isEmpty() && !registerLibvirtSecretsImpl(vds, libvirtSecrets, false)) {
        log.error("Failed to register libvirt secret on vds {}.", vds.getName());
        setNonOperational(cmdContext, vds.getId(), NonOperationalReason.LIBVIRT_SECRETS_REGISTRATION_FAILURE);
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean registerLibvirtSecretsImpl(VDS vds, List<LibvirtSecret> libvirtSecrets, boolean clearUnusedSecrets) {
    VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RegisterLibvirtSecrets, new RegisterLibvirtSecretsVDSParameters(vds.getId(), libvirtSecrets, clearUnusedSecrets));
    if (!returnValue.getSucceeded()) {
        log.error("Failed to register libvirt secret on vds {}.", vds.getName());
        return false;
    }
    return true;
}
#method_after
private boolean registerLibvirtSecretsImpl(VDS vds, List<LibvirtSecret> libvirtSecrets, boolean clearUnusedSecrets) {
    VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RegisterLibvirtSecrets, new RegisterLibvirtSecretsVDSParameters(vds.getId(), libvirtSecrets, clearUnusedSecrets));
    return returnValue.getSucceeded();
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    for (Entry<String, String> e : getParameters().getCustomLogValues().entrySet()) {
        addCustomValue(e.getKey(), e.getValue());
    }
    switch(getParameters().getNonOperationalReason()) {
        case NETWORK_UNREACHABLE:
            return (getSucceeded()) ? AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK : AuditLogType.VDS_SET_NONOPERATIONAL_FAILED;
        case STORAGE_DOMAIN_UNREACHABLE:
            return (getSucceeded()) ? AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN : AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED;
        case TIMEOUT_RECOVERING_FROM_CRASH:
            return AuditLogType.VDS_RECOVER_FAILED;
        case KVM_NOT_RUNNING:
            return AuditLogType.VDS_RUN_IN_NO_KVM_MODE;
        case VERSION_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER;
        case CLUSTER_VERSION_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED;
        case VM_NETWORK_IS_BRIDGELESS:
            return AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS;
        case GLUSTER_COMMAND_FAILED:
            return AuditLogType.GLUSTER_COMMAND_FAILED;
        case GLUSTER_HOST_UUID_NOT_FOUND:
            return AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND;
        case GLUSTER_HOST_UUID_ALREADY_EXISTS:
            return AuditLogType.GLUSTER_HOST_UUID_ALREADY_EXISTS;
        case EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER;
        case EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER_LEVEL:
            return AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER_LEVEL;
        case RNG_SOURCES_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.RNG_SOURCES_INCOMPATIBLE_WITH_CLUSTER;
        case MIXING_RHEL_VERSIONS_IN_CLUSTER:
            return AuditLogType.MIXING_RHEL_VERSIONS_IN_CLUSTER;
        case UNTRUSTED:
            return AuditLogType.VDS_UNTRUSTED;
        case HOST_FEATURES_INCOMPATIBILE_WITH_CLUSTER:
            return AuditLogType.HOST_FEATURES_INCOMPATIBILE_WITH_CLUSTER;
        case LIBRBD_PACKAGE_NOT_AVAILABLE:
            return AuditLogType.NO_LIBRBD_PACKAGE_AVAILABLE_ON_VDS;
        case GLUSTERFS_CLI_PACKAGE_NOT_INSTALLED:
            return AuditLogType.GLUSTERFS_CLI_PACKAGE_NOT_INSTALLED;
        default:
            return (getSucceeded()) ? AuditLogType.VDS_SET_NONOPERATIONAL : AuditLogType.VDS_SET_NONOPERATIONAL_FAILED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    for (Entry<String, String> e : getParameters().getCustomLogValues().entrySet()) {
        addCustomValue(e.getKey(), e.getValue());
    }
    switch(getParameters().getNonOperationalReason()) {
        case NETWORK_UNREACHABLE:
            return (getSucceeded()) ? AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK : AuditLogType.VDS_SET_NONOPERATIONAL_FAILED;
        case STORAGE_DOMAIN_UNREACHABLE:
            return (getSucceeded()) ? AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN : AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED;
        case TIMEOUT_RECOVERING_FROM_CRASH:
            return AuditLogType.VDS_RECOVER_FAILED;
        case KVM_NOT_RUNNING:
            return AuditLogType.VDS_RUN_IN_NO_KVM_MODE;
        case VERSION_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER;
        case CLUSTER_VERSION_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED;
        case VM_NETWORK_IS_BRIDGELESS:
            return AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS;
        case GLUSTER_COMMAND_FAILED:
            return AuditLogType.GLUSTER_COMMAND_FAILED;
        case GLUSTER_HOST_UUID_NOT_FOUND:
            return AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND;
        case GLUSTER_HOST_UUID_ALREADY_EXISTS:
            return AuditLogType.GLUSTER_HOST_UUID_ALREADY_EXISTS;
        case EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER;
        case EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER_LEVEL:
            return AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER_LEVEL;
        case RNG_SOURCES_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.RNG_SOURCES_INCOMPATIBLE_WITH_CLUSTER;
        case MIXING_RHEL_VERSIONS_IN_CLUSTER:
            return AuditLogType.MIXING_RHEL_VERSIONS_IN_CLUSTER;
        case UNTRUSTED:
            return AuditLogType.VDS_UNTRUSTED;
        case HOST_FEATURES_INCOMPATIBILE_WITH_CLUSTER:
            return AuditLogType.HOST_FEATURES_INCOMPATIBILE_WITH_CLUSTER;
        case LIBRBD_PACKAGE_NOT_AVAILABLE:
            return AuditLogType.NO_LIBRBD_PACKAGE_AVAILABLE_ON_VDS;
        case VDS_CANNOT_CONNECT_TO_GLUSTERFS:
            return AuditLogType.VDS_CANNOT_CONNECT_TO_GLUSTERFS;
        default:
            return (getSucceeded()) ? AuditLogType.VDS_SET_NONOPERATIONAL : AuditLogType.VDS_SET_NONOPERATIONAL_FAILED;
    }
}
#end_block

#method_before
public void addReason(Guid id, String hostName, EngineMessage filterType, String filterName) {
    filteredOutReasons.put(id, new Pair<>(filterType, filterName));
    hostNames.put(id, hostName);
}
#method_after
public void addReason(Guid id, String hostName, VdcBllMessages filterType, String filterName) {
    filteredOutReasons.put(id, new Pair<>(filterType, filterName));
    hostNames.put(id, hostName);
}
#end_block

#method_before
public Set<Entry<Guid, Pair<EngineMessage, String>>> getReasons() {
    return filteredOutReasons.entrySet();
}
#method_after
public Set<Entry<Guid, Pair<VdcBllMessages, String>>> getReasons() {
    return filteredOutReasons.entrySet();
}
#end_block

#method_before
public Collection<String> getReasonMessages() {
    List<String> lines = new ArrayList<>();
    for (Entry<Guid, Pair<EngineMessage, String>> line : filteredOutReasons.entrySet()) {
        lines.add(line.getValue().getFirst().name());
        lines.add(String.format("$%1$s %2$s", "hostName", hostNames.get(line.getKey())));
        lines.add(String.format("$%1$s %2$s", "filterName", line.getValue().getSecond()));
        final List<String> detailMessages = details.getMessages(line.getKey());
        if (detailMessages == null || detailMessages.isEmpty()) {
            lines.add(EngineMessage.SCHEDULING_HOST_FILTERED_REASON.name());
        } else {
            lines.addAll(detailMessages);
            lines.add(EngineMessage.SCHEDULING_HOST_FILTERED_REASON_WITH_DETAIL.name());
        }
    }
    return lines;
}
#method_after
public Collection<String> getReasonMessages() {
    List<String> lines = new ArrayList<>();
    for (Entry<Guid, Pair<VdcBllMessages, String>> line : filteredOutReasons.entrySet()) {
        lines.add(line.getValue().getFirst().name());
        lines.add(String.format("$%1$s %2$s", "hostName", hostNames.get(line.getKey())));
        lines.add(String.format("$%1$s %2$s", "filterName", line.getValue().getSecond()));
        final List<String> detailMessages = details.getMessages(line.getKey());
        if (detailMessages == null || detailMessages.isEmpty()) {
            lines.add(VdcBllMessages.SCHEDULING_HOST_FILTERED_REASON.name());
        } else {
            lines.addAll(detailMessages);
            lines.add(VdcBllMessages.SCHEDULING_HOST_FILTERED_REASON_WITH_DETAIL.name());
        }
    }
    return lines;
}
#end_block

#method_before
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, List<Guid> destHostIdList, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    prepareClusterLock(cluster.getId());
    try {
        log.debug("Scheduling started, correlation Id: {}", correlationId);
        checkAllowOverbooking(cluster);
        lockCluster(cluster.getId());
        List<VDS> vdsList = getVdsDao().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        refreshCachedPendingValues(vdsList);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList == null || vdsList.isEmpty()) {
            return null;
        }
        Guid bestHost = selectBestHost(cluster, vm, destHostIdList, vdsList, policy, parameters);
        if (bestHost != null) {
            getPendingResourceManager().addPending(new PendingCpuCores(bestHost, vm, vm.getNumOfCpus()));
            getPendingResourceManager().addPending(new PendingMemory(bestHost, vm, vm.getMinAllocatedMem()));
            getPendingResourceManager().addPending(new PendingVM(bestHost, vm));
            getPendingResourceManager().notifyHostManagers(bestHost);
            VfScheduler vfScheduler = Injector.get(VfScheduler.class);
            Map<Guid, String> passthroughVnicToVfMap = vfScheduler.getVnicToVfMap(vm.getId(), bestHost);
            if (passthroughVnicToVfMap != null && !passthroughVnicToVfMap.isEmpty()) {
                markVfsAsUsedByVm(bestHost, vm.getId(), passthroughVnicToVfMap);
            }
        }
        return bestHost;
    } catch (InterruptedException e) {
        log.error("interrupted", e);
        return null;
    } finally {
        releaseCluster(cluster.getId());
        log.debug("Scheduling ended, correlation Id: {}", correlationId);
    }
}
#method_after
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    prepareClusterLock(cluster.getId());
    try {
        log.debug("Scheduling started, correlation Id: {}", correlationId);
        checkAllowOverbooking(cluster);
        lockCluster(cluster.getId());
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        refreshCachedPendingValues(vdsList);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList == null || vdsList.isEmpty()) {
            return null;
        }
        Guid bestHost = selectBestHost(cluster, vm, destHostId, vdsList, policy, parameters);
        if (bestHost != null) {
            getPendingResourceManager().addPending(new PendingCpuCores(bestHost, vm, vm.getNumOfCpus()));
            getPendingResourceManager().addPending(new PendingMemory(bestHost, vm, vm.getMinAllocatedMem()));
            getPendingResourceManager().addPending(new PendingVM(bestHost, vm));
            getPendingResourceManager().notifyHostManagers(bestHost);
            VfScheduler vfScheduler = Injector.get(VfScheduler.class);
            Map<Guid, String> passthroughVnicToVfMap = vfScheduler.getVnicToVfMap(vm.getId(), bestHost);
            if (passthroughVnicToVfMap != null && !passthroughVnicToVfMap.isEmpty()) {
                markVfsAsUsedByVm(bestHost, vm.getId(), passthroughVnicToVfMap);
            }
        }
        return bestHost;
    } catch (InterruptedException e) {
        log.error("interrupted", e);
        return null;
    } finally {
        releaseCluster(cluster.getId());
        log.debug("Scheduling ended, correlation Id: {}", correlationId);
    }
}
#end_block

#method_before
private Guid selectBestHost(VDSGroup cluster, VM vm, List<Guid> destHostIdList, List<VDS> availableVdsList, ClusterPolicy policy, Map<String, String> parameters) {
    // in case a default destination host was specified and
    // it passed filters, return the first found
    List<VDS> runnableHosts = new LinkedList<>();
    if (destHostIdList.size() > 0) {
        // intersect dedicated hosts list with available list
        for (VDS vds : availableVdsList) {
            for (Guid destHostId : destHostIdList) {
                if (destHostId.equals(vds.getId())) {
                    runnableHosts.add(vds);
                }
            }
        }
    } else {
        // no dedicated hosts
        runnableHosts = availableVdsList;
    }
    switch(runnableHosts.size()) {
        case 0:
            // no runnable hosts found, nothing found
            return null;
        case 1:
            // found single available host, in available list return it
            return runnableHosts.get(0).getId();
        default:
            // select best runnable host with scoring functions (from policy)
            List<Pair<Guid, Integer>> functions = policy.getFunctions();
            if (functions != null && !functions.isEmpty() && shouldWeighClusterHosts(cluster, runnableHosts)) {
                Guid bestHostByFunctions = runFunctions(functions, runnableHosts, vm, parameters);
                if (bestHostByFunctions != null) {
                    return bestHostByFunctions;
                }
            }
    }
    // failed select best runnable host using scoring functions, return the first
    return runnableHosts.get(0).getId();
}
#method_after
private Guid selectBestHost(VDSGroup cluster, VM vm, Guid destHostId, List<VDS> vdsList, ClusterPolicy policy, Map<String, String> parameters) {
    // it passed filters, return it
    if (destHostId != null) {
        for (VDS vds : vdsList) {
            if (destHostId.equals(vds.getId())) {
                return destHostId;
            }
        }
    }
    List<Pair<Guid, Integer>> functions = policy.getFunctions();
    if (functions != null && !functions.isEmpty() && shouldWeighClusterHosts(cluster, vdsList)) {
        Guid bestHostByFunctions = runFunctions(functions, vdsList, vm, parameters);
        if (bestHostByFunctions != null) {
            return bestHostByFunctions;
        }
    }
    return vdsList.get(0).getId();
}
#end_block

#method_before
public boolean canSchedule(VDSGroup cluster, VM vm, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, List<Guid> destVdsIdList, List<String> messages) {
    List<VDS> vdsList = getVdsDao().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
    updateInitialHostList(vdsList, vdsBlackList, true);
    updateInitialHostList(vdsList, vdsWhiteList, false);
    refreshCachedPendingValues(vdsList);
    ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
    Map<String, String> parameters = createClusterPolicyParameters(cluster);
    vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, noWaitingMemoryChecker, false, null);
    return vdsList != null && !vdsList.isEmpty();
}
#method_after
public boolean canSchedule(VDSGroup cluster, VM vm, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, Guid destVdsId, List<String> messages) {
    List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
    updateInitialHostList(vdsList, vdsBlackList, true);
    updateInitialHostList(vdsList, vdsWhiteList, false);
    refreshCachedPendingValues(vdsList);
    ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
    Map<String, String> parameters = createClusterPolicyParameters(cluster);
    vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, noWaitingMemoryChecker, false, null);
    return vdsList != null && !vdsList.isEmpty();
}
#end_block

#method_before
private List<VDS> runFilters(ArrayList<Guid> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, boolean shouldRunExternalFilters, String correlationId) {
    SchedulingResult result = new SchedulingResult();
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<>();
    sortFilters(filters, filterPositionMap);
    if (filters != null) {
        for (Guid filter : filters) {
            PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
            if (filterPolicyUnit.getPolicyUnit().isInternal()) {
                internalFilters.add(filterPolicyUnit);
            } else {
                if (filterPolicyUnit.getPolicyUnit().isEnabled()) {
                    externalFilters.add(filterPolicyUnit);
                }
            }
        }
    }
    /* Short circuit filters if there are no hosts at all */
    if (hostList == null || hostList.isEmpty()) {
        messages.add(EngineMessage.SCHEDULING_NO_HOSTS.name());
        messages.addAll(result.getReasonMessages());
        return hostList;
    }
    hostList = runInternalFilters(internalFilters, hostList, vm, parameters, filterPositionMap, memoryChecker, correlationId, result);
    if (shouldRunExternalFilters && Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && !externalFilters.isEmpty() && hostList != null && !hostList.isEmpty()) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, messages, correlationId, result);
    }
    if (hostList == null || hostList.isEmpty()) {
        messages.add(EngineMessage.SCHEDULING_ALL_HOSTS_FILTERED_OUT.name());
        messages.addAll(result.getReasonMessages());
    }
    return hostList;
}
#method_after
private List<VDS> runFilters(ArrayList<Guid> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, boolean shouldRunExternalFilters, String correlationId) {
    SchedulingResult result = new SchedulingResult();
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<>();
    sortFilters(filters, filterPositionMap);
    if (filters != null) {
        for (Guid filter : filters) {
            PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
            if (filterPolicyUnit.getPolicyUnit().isInternal()) {
                internalFilters.add(filterPolicyUnit);
            } else {
                if (filterPolicyUnit.getPolicyUnit().isEnabled()) {
                    externalFilters.add(filterPolicyUnit);
                }
            }
        }
    }
    /* Short circuit filters if there are no hosts at all */
    if (hostList == null || hostList.isEmpty()) {
        messages.add(VdcBllMessages.SCHEDULING_NO_HOSTS.name());
        messages.addAll(result.getReasonMessages());
        return hostList;
    }
    hostList = runInternalFilters(internalFilters, hostList, vm, parameters, filterPositionMap, memoryChecker, correlationId, result);
    if (shouldRunExternalFilters && Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && !externalFilters.isEmpty() && hostList != null && !hostList.isEmpty()) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, messages, correlationId, result);
    }
    if (hostList == null || hostList.isEmpty()) {
        messages.add(VdcBllMessages.SCHEDULING_ALL_HOSTS_FILTERED_OUT.name());
        messages.addAll(result.getReasonMessages());
    }
    return hostList;
}
#end_block

#method_before
private List<VDS> runInternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, VdsFreeMemoryChecker memoryChecker, String correlationId, SchedulingResult result) {
    if (filters != null) {
        for (PolicyUnitImpl filterPolicyUnit : filters) {
            if (hostList == null || hostList.isEmpty()) {
                break;
            }
            filterPolicyUnit.setMemoryChecker(memoryChecker);
            List<VDS> currentHostList = new ArrayList<>(hostList);
            hostList = filterPolicyUnit.filter(hostList, vm, parameters, result.getDetails());
            logFilterActions(currentHostList, toIdSet(hostList), EngineMessage.VAR__FILTERTYPE__INTERNAL, filterPolicyUnit.getPolicyUnit().getName(), result, correlationId);
        }
    }
    return hostList;
}
#method_after
private List<VDS> runInternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, VdsFreeMemoryChecker memoryChecker, String correlationId, SchedulingResult result) {
    if (filters != null) {
        for (PolicyUnitImpl filterPolicyUnit : filters) {
            if (hostList == null || hostList.isEmpty()) {
                break;
            }
            filterPolicyUnit.setMemoryChecker(memoryChecker);
            List<VDS> currentHostList = new ArrayList<>(hostList);
            hostList = filterPolicyUnit.filter(hostList, vm, parameters, result.getDetails());
            logFilterActions(currentHostList, toIdSet(hostList), VdcBllMessages.VAR__FILTERTYPE__INTERNAL, filterPolicyUnit.getPolicyUnit().getName(), result, correlationId);
        }
    }
    return hostList;
}
#end_block

#method_before
private void logFilterActions(List<VDS> oldList, Set<Guid> newSet, EngineMessage actionName, String filterName, SchedulingResult result, String correlationId) {
    for (VDS host : oldList) {
        if (!newSet.contains(host.getId())) {
            result.addReason(host.getId(), host.getName(), actionName, filterName);
            log.info("Candidate host '{}' ('{}') was filtered out by '{}' filter '{}' (correlation id: {})", host.getName(), host.getId(), actionName.name(), filterName, correlationId);
        }
    }
}
#method_after
private void logFilterActions(List<VDS> oldList, Set<Guid> newSet, VdcBllMessages actionName, String filterName, SchedulingResult result, String correlationId) {
    for (VDS host : oldList) {
        if (!newSet.contains(host.getId())) {
            result.addReason(host.getId(), host.getName(), actionName, filterName);
            log.info("Candidate host '{}' ('{}') was filtered out by '{}' filter '{}' (correlation id: {})", host.getName(), host.getId(), actionName.name(), filterName, correlationId);
        }
    }
}
#end_block

#method_before
private List<VDS> runExternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, List<String> messages, String correlationId, SchedulingResult result) {
    List<Guid> filteredIDs = null;
    if (filters != null) {
        List<String> filterNames = new ArrayList<>();
        for (PolicyUnitImpl filter : filters) {
            filterNames.add(filter.getPolicyUnit().getName());
        }
        List<Guid> hostIDs = new ArrayList<>();
        for (VDS host : hostList) {
            hostIDs.add(host.getId());
        }
        filteredIDs = ExternalSchedulerFactory.getInstance().runFilters(filterNames, hostIDs, vm.getId(), parameters);
        if (filteredIDs != null) {
            logFilterActions(hostList, new HashSet<>(filteredIDs), EngineMessage.VAR__FILTERTYPE__EXTERNAL, Arrays.toString(filterNames.toArray()), result, correlationId);
        }
    }
    return intersectHosts(hostList, filteredIDs);
}
#method_after
private List<VDS> runExternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, List<String> messages, String correlationId, SchedulingResult result) {
    List<Guid> filteredIDs = null;
    if (filters != null) {
        List<String> filterNames = new ArrayList<>();
        for (PolicyUnitImpl filter : filters) {
            filterNames.add(filter.getPolicyUnit().getName());
        }
        List<Guid> hostIDs = new ArrayList<>();
        for (VDS host : hostList) {
            hostIDs.add(host.getId());
        }
        filteredIDs = ExternalSchedulerFactory.getInstance().runFilters(filterNames, hostIDs, vm.getId(), parameters);
        if (filteredIDs != null) {
            logFilterActions(hostList, new HashSet<>(filteredIDs), VdcBllMessages.VAR__FILTERTYPE__EXTERNAL, Arrays.toString(filterNames.toArray()), result, correlationId);
        }
    }
    return intersectHosts(hostList, filteredIDs);
}
#end_block

#method_before
protected VdsGroupDao getVdsGroupDao() {
    return DbFacade.getInstance().getVdsGroupDao();
}
#method_after
protected VdsGroupDAO getVdsGroupDao() {
    return DbFacade.getInstance().getVdsGroupDao();
}
#end_block

#method_before
protected VdsDynamicDao getVdsDynamicDao() {
    return DbFacade.getInstance().getVdsDynamicDao();
}
#method_after
protected VdsDynamicDAO getVdsDynamicDao() {
    return DbFacade.getInstance().getVdsDynamicDao();
}
#end_block

#method_before
@OnTimerMethodAnnotation("performLoadBalancing")
public void performLoadBalancing() {
    log.debug("Load Balancer timer entered.");
    List<VDSGroup> clusters = DbFacade.getInstance().getVdsGroupDao().getAll();
    for (VDSGroup cluster : clusters) {
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        PolicyUnitImpl policyUnit = policyUnits.get(policy.getBalance());
        Pair<List<Guid>, Guid> balanceResult = null;
        if (policyUnit.getPolicyUnit().isEnabled()) {
            List<VDS> hosts = getVdsDao().getAllForVdsGroupWithoutMigrating(cluster.getId());
            if (policyUnit.getPolicyUnit().isInternal()) {
                balanceResult = internalRunBalance(policyUnit, cluster, hosts);
            } else if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled)) {
                balanceResult = externalRunBalance(policyUnit, cluster, hosts);
            }
        }
        if (balanceResult != null && balanceResult.getSecond() != null) {
            migrationHandler.migrateVM(balanceResult.getFirst(), balanceResult.getSecond());
        }
    }
}
#method_after
@OnTimerMethodAnnotation("performLoadBalancing")
public void performLoadBalancing() {
    log.debug("Load Balancer timer entered.");
    List<VDSGroup> clusters = DbFacade.getInstance().getVdsGroupDao().getAll();
    for (VDSGroup cluster : clusters) {
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        PolicyUnitImpl policyUnit = policyUnits.get(policy.getBalance());
        Pair<List<Guid>, Guid> balanceResult = null;
        if (policyUnit.getPolicyUnit().isEnabled()) {
            List<VDS> hosts = getVdsDAO().getAllForVdsGroupWithoutMigrating(cluster.getId());
            if (policyUnit.getPolicyUnit().isInternal()) {
                balanceResult = internalRunBalance(policyUnit, cluster, hosts);
            } else if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled)) {
                balanceResult = externalRunBalance(policyUnit, cluster, hosts);
            }
        }
        if (balanceResult != null && balanceResult.getSecond() != null) {
            migrationHandler.migrateVM(balanceResult.getFirst(), balanceResult.getSecond());
        }
    }
}
#end_block

#method_before
@Test
public void sriovFeatureNotSupported() {
    sriovFeatureSupportTest(failsWith(EngineMessage.ACTION_TYPE_FAILED_SRIOV_FEATURE_NOT_SUPPORTED), false);
}
#method_after
@Test
public void sriovFeatureNotSupported() {
    sriovFeatureSupportTest(failsWith(VdcBllMessages.ACTION_TYPE_FAILED_SRIOV_FEATURE_NOT_SUPPORTED), false);
}
#end_block

#method_before
@Test
public void nicSriovNotEnabled() {
    simulateNicExists();
    validator.setOldVfsConfig(null);
    assertThat(validator.nicSriovEnabled(), failsWith(EngineMessage.ACTION_TYPE_FAILED_NIC_IS_NOT_SRIOV_ENABLED, String.format(VfsConfigValidator.NIC_NAME_REPLACEMENT, nic.getName())));
}
#method_after
@Test
public void nicSriovNotEnabled() {
    simulateNicExists();
    validator.setOldVfsConfig(null);
    assertThat(validator.nicSriovEnabled(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NIC_IS_NOT_SRIOV_ENABLED, String.format(VfsConfigValidator.NIC_NAME_REPLACEMENT, nic.getName())));
}
#end_block

#method_before
private void assertNumOfVfsInValidRange(int numOfVfs) {
    assertThat(validator.numOfVfsInValidRange(numOfVfs), failsWith(EngineMessage.ACTION_TYPE_FAILED_NUM_OF_VFS_NOT_IN_VALID_RANGE, String.format(VfsConfigValidator.NIC_NAME_REPLACEMENT, nic.getName()), String.format(VfsConfigValidator.NUM_OF_VFS_REPLACEMENT, numOfVfs), String.format(VfsConfigValidator.MAX_NUM_OF_VFS_REPLACEMENT, oldVfsConfig.getMaxNumOfVfs())));
}
#method_after
private void assertNumOfVfsInValidRange(int numOfVfs) {
    assertThat(validator.numOfVfsInValidRange(numOfVfs), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NUM_OF_VFS_NOT_IN_VALID_RANGE, String.format(VfsConfigValidator.NIC_NAME_REPLACEMENT, nic.getName()), String.format(VfsConfigValidator.NUM_OF_VFS_REPLACEMENT, numOfVfs), String.format(VfsConfigValidator.MAX_NUM_OF_VFS_REPLACEMENT, oldVfsConfig.getMaxNumOfVfs())));
}
#end_block

#method_before
@Test
public void notAllVfsAreFree() {
    allVfsAreFreeTest(false);
    assertThat(validator.allVfsAreFree(networkDeviceHelper), failsWith(EngineMessage.ACTION_TYPE_FAILED_NUM_OF_VFS_CANNOT_BE_CHANGED, String.format(VfsConfigValidator.NIC_NAME_REPLACEMENT, nic.getName())));
}
#method_after
@Test
public void notAllVfsAreFree() {
    allVfsAreFreeTest(false);
    assertThat(validator.allVfsAreFree(networkDeviceHelper), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NUM_OF_VFS_CANNOT_BE_CHANGED, String.format(VfsConfigValidator.NIC_NAME_REPLACEMENT, nic.getName())));
}
#end_block

#method_before
@Test
public void settingSpecificNetworksAllowed() {
    settingSpecificNetworksAllowedTest(true);
    assertThat(validator.settingSpecificNetworksAllowed(), failsWith(EngineMessage.ACTION_TYPE_FAILED_CANNOT_SET_SPECIFIC_NETWORKS, String.format(VfsConfigValidator.NIC_NAME_REPLACEMENT, nic.getName())));
}
#method_after
@Test
public void settingSpecificNetworksAllowed() {
    settingSpecificNetworksAllowedTest(true);
    assertThat(validator.settingSpecificNetworksAllowed(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_SET_SPECIFIC_NETWORKS, String.format(VfsConfigValidator.NIC_NAME_REPLACEMENT, nic.getName())));
}
#end_block

#method_before
@Test
public void networNotExist() {
    simulateNicExists();
    assertThat(validator.networkExists(NETWORK_ID), failsWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_NOT_EXIST, String.format(VfsConfigValidator.NIC_NAME_REPLACEMENT, nic.getName()), String.format(VfsConfigValidator.NETWORK_ID_REPLACEMENT, NETWORK_ID)));
}
#method_after
@Test
public void networNotExist() {
    simulateNicExists();
    assertThat(validator.networkExists(NETWORK_ID), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_NOT_EXIST, String.format(VfsConfigValidator.NIC_NAME_REPLACEMENT, nic.getName()), String.format(VfsConfigValidator.NETWORK_ID_REPLACEMENT, NETWORK_ID)));
}
#end_block

#method_before
@Test
public void networkNotInVfsConfigNotValid() {
    networkInVfsConfigCommonTest(true);
    assertThat(validator.networkNotInVfsConfig(NETWORK_ID), failsWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_ALREADY_IN_VFS_CONFIG, String.format(VfsConfigValidator.NIC_NAME_REPLACEMENT, nic.getName()), String.format(VfsConfigValidator.NETWORK_NAME_REPLACEMENT, network.getName())));
}
#method_after
@Test
public void networkNotInVfsConfigNotValid() {
    networkInVfsConfigCommonTest(true);
    assertThat(validator.networkNotInVfsConfig(NETWORK_ID), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ALREADY_IN_VFS_CONFIG, String.format(VfsConfigValidator.NIC_NAME_REPLACEMENT, nic.getName()), String.format(VfsConfigValidator.NETWORK_NAME_REPLACEMENT, network.getName())));
}
#end_block

#method_before
@Test
public void networkInVfsConfigNotValid() {
    networkInVfsConfigCommonTest(false);
    assertThat(validator.networkInVfsConfig(NETWORK_ID), failsWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_NOT_IN_VFS_CONFIG, String.format(VfsConfigValidator.NIC_NAME_REPLACEMENT, nic.getName()), String.format(VfsConfigValidator.NETWORK_NAME_REPLACEMENT, network.getName())));
}
#method_after
@Test
public void networkInVfsConfigNotValid() {
    networkInVfsConfigCommonTest(false);
    assertThat(validator.networkInVfsConfig(NETWORK_ID), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_NOT_IN_VFS_CONFIG, String.format(VfsConfigValidator.NIC_NAME_REPLACEMENT, nic.getName()), String.format(VfsConfigValidator.NETWORK_NAME_REPLACEMENT, network.getName())));
}
#end_block

#method_before
@Test
public void labelNotInVfsConfigNotValid() {
    labelInVfsConfigCommonTest(true);
    assertThat(validator.labelNotInVfsConfig(LABEL), failsWith(EngineMessage.ACTION_TYPE_FAILED_LABEL_ALREADY_IN_VFS_CONFIG, String.format(VfsConfigValidator.NIC_NAME_REPLACEMENT, nic.getName()), String.format(VfsConfigValidator.LABEL_REPLACEMENT, LABEL)));
}
#method_after
@Test
public void labelNotInVfsConfigNotValid() {
    labelInVfsConfigCommonTest(true);
    assertThat(validator.labelNotInVfsConfig(LABEL), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_LABEL_ALREADY_IN_VFS_CONFIG, String.format(VfsConfigValidator.NIC_NAME_REPLACEMENT, nic.getName()), String.format(VfsConfigValidator.LABEL_REPLACEMENT, LABEL)));
}
#end_block

#method_before
@Test
public void labelInVfsConfigNotValid() {
    labelInVfsConfigCommonTest(false);
    assertThat(validator.labelInVfsConfig(LABEL), failsWith(EngineMessage.ACTION_TYPE_FAILED_LABEL_NOT_IN_VFS_CONFIG, String.format(VfsConfigValidator.NIC_NAME_REPLACEMENT, nic.getName()), String.format(VfsConfigValidator.LABEL_REPLACEMENT, LABEL)));
}
#method_after
@Test
public void labelInVfsConfigNotValid() {
    labelInVfsConfigCommonTest(false);
    assertThat(validator.labelInVfsConfig(LABEL), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_LABEL_NOT_IN_VFS_CONFIG, String.format(VfsConfigValidator.NIC_NAME_REPLACEMENT, nic.getName()), String.format(VfsConfigValidator.LABEL_REPLACEMENT, LABEL)));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean result = true;
    HostNicVfsConfig oldVfsConfig = getVfsConfig();
    boolean allNetworksAllowedChanged = isAllNetworksAllowed() != oldVfsConfig.isAllNetworksAllowed();
    super.executeCommand();
    // Check if 'allNetworksAllowed' has changed
    if (allNetworksAllowedChanged) {
        oldVfsConfig.setAllNetworksAllowed(isAllNetworksAllowed());
        if (isAllNetworksAllowed()) {
            oldVfsConfig.setNetworks(Collections.<Guid>emptySet());
            oldVfsConfig.setNetworkLabels(Collections.<String>emptySet());
        }
    }
    boolean shouldRefreshHost = false;
    if (wasNumOfVfsChanged()) {
        shouldRefreshHost = true;
        String deviceName = networkDeviceHelper.getPciDeviceNameByNic(getNic());
        VDSReturnValue returnValue = null;
        try {
            returnValue = runVdsCommand(VDSCommandType.HostDevChangeNumVfs, new HostDevChangeNumVfsVDSParameters(getVdsId(), deviceName, getNumOfVfs()));
            result = returnValue.getSucceeded();
        } catch (EngineException e) {
            throw new EngineException(EngineError.UPDATE_NUM_VFS_FAILURE);
        }
    }
    if (result) {
        setSucceeded(saveChangesToDb(shouldRefreshHost, oldVfsConfig, allNetworksAllowedChanged));
    }
}
#method_after
@Override
protected void executeCommand() {
    boolean result = true;
    HostNicVfsConfig oldVfsConfig = getVfsConfig();
    boolean allNetworksAllowedChanged = isAllNetworksAllowed() != oldVfsConfig.isAllNetworksAllowed();
    super.executeCommand();
    // Check if 'allNetworksAllowed' has changed
    if (allNetworksAllowedChanged) {
        oldVfsConfig.setAllNetworksAllowed(isAllNetworksAllowed());
        if (isAllNetworksAllowed()) {
            oldVfsConfig.setNetworks(Collections.<Guid>emptySet());
            oldVfsConfig.setNetworkLabels(Collections.<String>emptySet());
        }
    }
    boolean shouldRefreshHost = false;
    if (wasNumOfVfsChanged()) {
        shouldRefreshHost = true;
        String deviceName = networkDeviceHelper.getPciDeviceNameByNic(getNic());
        VDSReturnValue returnValue = null;
        try {
            returnValue = runVdsCommand(VDSCommandType.HostDevChangeNumVfs, new HostDevChangeNumVfsVDSParameters(getVdsId(), deviceName, getNumOfVfs()));
            result = returnValue.getSucceeded();
        } catch (VdcBLLException e) {
            throw new VdcBLLException(VdcBllErrors.UPDATE_NUM_VFS_FAILURE);
        }
    }
    if (result) {
        setSucceeded(saveChangesToDb(shouldRefreshHost, oldVfsConfig, allNetworksAllowedChanged));
    }
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__UPDATE);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__HOST_NIC_VFS_CONFIG);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST_NIC_VFS_CONFIG);
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__REFRESH);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__HOST_DEVICES);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REFRESH);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST_DEVICES);
}
#end_block

#method_before
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            if (connectLunDisks(getVdsId()) && updateCinderDisksConnections()) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
                markHostDevicesAsUsed();
            }
        } catch (EngineException e) {
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(e.getErrorCode()) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                    cleanupPassthroughVnics();
                    reportCompleted();
                    throw e;
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                    runningFailed();
                    throw e;
                default:
                    log.warn("Failed to run VM '{}': {}", getVmName(), e.getMessage());
            }
        } finally {
            freeLock();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.info("Trying to rerun VM '{}'", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        runningFailed();
    }
}
#method_after
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            if (connectLunDisks(getVdsId()) && updateCinderDisksConnections()) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
                markHostDevicesAsUsed();
            }
        } catch (VdcBLLException e) {
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(e.getErrorCode()) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                    cleanupPassthroughVnics();
                    reportCompleted();
                    throw e;
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                    runningFailed();
                    throw e;
                default:
                    log.warn("Failed to run VM '{}': {}", getVmName(), e.getMessage());
            }
        } finally {
            freeLock();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.info("Trying to rerun VM '{}'", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        runningFailed();
    }
}
#end_block

#method_before
private void acquireHostDevicesLock() {
    if (needsHostDevices) {
        // Only single dedicated host allowed for host devices, verified on canDoActions
        hostDeviceManager.acquireHostDevicesLock(getVm().getDedicatedVmForVdsList().get(0));
    }
}
#method_after
private void acquireHostDevicesLock() {
    if (needsHostDevices) {
        hostDeviceManager.acquireHostDevicesLock(getVm().getDedicatedVmForVds());
    }
}
#end_block

#method_before
private void releaseHostDevicesLock() {
    if (needsHostDevices) {
        // Only single dedicated host allowed for host devices, verified on canDoActions
        hostDeviceManager.releaseHostDevicesLock(getVm().getDedicatedVmForVdsList().get(0));
    }
}
#method_after
private void releaseHostDevicesLock() {
    if (needsHostDevices) {
        hostDeviceManager.releaseHostDevicesLock(getVm().getDedicatedVmForVds());
    }
}
#end_block

#method_before
protected boolean isStatelessSnapshotExistsForVm() {
    if (cachedStatelessSnapshotExistsForVm == null) {
        cachedStatelessSnapshotExistsForVm = getSnapshotDao().exists(getVm().getId(), SnapshotType.STATELESS);
    }
    return cachedStatelessSnapshotExistsForVm;
}
#method_after
protected boolean isStatelessSnapshotExistsForVm() {
    if (cachedStatelessSnapshotExistsForVm == null) {
        cachedStatelessSnapshotExistsForVm = getSnapshotDAO().exists(getVm().getId(), SnapshotType.STATELESS);
    }
    return cachedStatelessSnapshotExistsForVm;
}
#end_block

#method_before
private void statelessVmTreatment() {
    warnIfNotAllDisksPermitSnapshots();
    if (isStatelessSnapshotExistsForVm()) {
        log.error("VM '{}' ({}) already contains stateless snapshot, removing it", getVm().getName(), getVm().getId());
        removeVmStatlessImages();
    } else {
        log.info("Creating stateless snapshot for VM '{}' ({})", getVm().getName(), getVm().getId());
        CreateAllSnapshotsFromVmParameters createAllSnapshotsFromVmParameters = buildCreateSnapshotParameters();
        VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, createAllSnapshotsFromVmParameters, createContextForStatelessSnapshotCreation());
        // setting lock to null in order not to release lock twice
        setLock(null);
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        } else {
            if (areDisksLocked(vdcReturnValue)) {
                throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
            }
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.error("Failed to create stateless snapshot for VM '{}' ({})", getVm().getName(), getVm().getId());
        }
    }
}
#method_after
private void statelessVmTreatment() {
    warnIfNotAllDisksPermitSnapshots();
    if (isStatelessSnapshotExistsForVm()) {
        log.error("VM '{}' ({}) already contains stateless snapshot, removing it", getVm().getName(), getVm().getId());
        removeVmStatlessImages();
    } else {
        log.info("Creating stateless snapshot for VM '{}' ({})", getVm().getName(), getVm().getId());
        CreateAllSnapshotsFromVmParameters createAllSnapshotsFromVmParameters = buildCreateSnapshotParameters();
        VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, createAllSnapshotsFromVmParameters, createContextForStatelessSnapshotCreation());
        // setting lock to null in order not to release lock twice
        setLock(null);
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        } else {
            if (areDisksLocked(vdcReturnValue)) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            }
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.error("Failed to create stateless snapshot for VM '{}' ({})", getVm().getName(), getVm().getId());
        }
    }
}
#end_block

#method_before
private boolean areDisksLocked(VdcReturnValueBase vdcReturnValue) {
    return vdcReturnValue.getCanDoActionMessages().contains(EngineMessage.ACTION_TYPE_FAILED_DISKS_LOCKED.name());
}
#method_after
private boolean areDisksLocked(VdcReturnValueBase vdcReturnValue) {
    return vdcReturnValue.getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISKS_LOCKED.name());
}
#end_block

#method_before
protected boolean isVmRunningOnNonDefaultVds() {
    return getVm().getDedicatedVmForVdsList().isEmpty() == false && getVm().getDedicatedVmForVdsList().contains(getVm().getRunOnVds()) == false;
}
#method_after
protected boolean isVmRunningOnNonDefaultVds() {
    return getVm().getDedicatedVmForVds() != null && !getVm().getRunOnVds().equals(getVm().getDedicatedVmForVds());
}
#end_block

#method_before
protected boolean getVdsToRunOn() {
    Guid vdsToRunOn = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdListToRunOn(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.error("Can't find VDS to run the VM '{}' on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        EngineException outEx = new EngineException(EngineError.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error("VmHandler::{}: {}", getClass().getName(), outEx.getMessage());
        return false;
    }
    return true;
}
#method_after
protected boolean getVdsToRunOn() {
    Guid vdsToRunOn = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.error("Can't find VDS to run the VM '{}' on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        VdcBLLException outEx = new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error("VmHandler::{}: {}", getClass().getName(), outEx.getMessage());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getCanDoActionMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdListToRunOn(), getVdsGroup())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(EngineMessage.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    if (!checkRngDeviceClusterCompatibility()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    // Currently we cannot use two payloads in the same media (cdrom/floppy)
    if (getParameters().getInitializationType() != null) {
        if (getParameters().getInitializationType() == InitializationType.Sysprep && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(EngineMessage.VMPAYLOAD_FLOPPY_WITH_SYSPREP);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.CDROM) {
            return failCanDoAction(EngineMessage.VMPAYLOAD_CDROM_WITH_CLOUD_INIT);
        }
    }
    if (needsHostDevices && // Only single dedicated host allowed for host devices, verified on canDoActions
    !hostDeviceManager.checkVmHostDeviceAvailability(getVm(), getVm().getDedicatedVmForVdsList().get(0))) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_HOST_DEVICE_NOT_AVAILABLE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getCanDoActionMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), getVdsGroup())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    if (!checkRngDeviceClusterCompatibility()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    // Currently we cannot use two payloads in the same media (cdrom/floppy)
    if (getParameters().getInitializationType() != null) {
        if (getParameters().getInitializationType() == InitializationType.Sysprep && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_WITH_SYSPREP);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.CDROM) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_CDROM_WITH_CLOUD_INIT);
        }
    }
    if (needsHostDevices && !hostDeviceManager.checkVmHostDeviceAvailability(getVm(), getVm().getDedicatedVmForVds())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_DEVICE_NOT_AVAILABLE);
    }
    return true;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__RUN);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__VM);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__RUN);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
}
#end_block

#method_before
private CommandContext createContextForRunStatelessVm() {
    Step step = getExecutionContext().getStep();
    // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
    // at this is a new instance of the command is used
    // (comparing with the execution state) so all information on the job and steps should be retrieved.
    Job job = JobRepositoryFactory.getJobRepository().getJob(step.getJobId());
    Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
    // We would like to to set the run stateless step as substep of executing step
    setInternalExecution(true);
    ExecutionContext runStatelessVmCtx = new ExecutionContext();
    // The internal command should be monitored for tasks
    runStatelessVmCtx.setMonitored(true);
    Step runStatelessStep = ExecutionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
    // This is needed in order to end the job upon execution of the steps of the child command
    runStatelessVmCtx.setShouldEndJob(true);
    runStatelessVmCtx.setJob(job);
    // Since run stateless step involves invocation of command, we should set the run stateless vm step as
    // the "beginning step" of the child command.
    runStatelessVmCtx.setStep(runStatelessStep);
    return cloneContextAndDetachFromParent().withExecutionContext(runStatelessVmCtx);
}
#method_after
private CommandContext createContextForRunStatelessVm() {
    Step step = getExecutionContext().getStep();
    // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
    // at this is a new instance of the command is used
    // (comparing with the execution state) so all information on the job and steps should be retrieved.
    Job job = JobRepositoryFactory.getJobRepository().getJobWithSteps(step.getJobId());
    Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
    // We would like to to set the run stateless step as substep of executing step
    setInternalExecution(true);
    ExecutionContext runStatelessVmCtx = new ExecutionContext();
    // The internal command should be monitored for tasks
    runStatelessVmCtx.setMonitored(true);
    Step runStatelessStep = ExecutionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
    // This is needed in order to end the job upon execution of the steps of the child command
    runStatelessVmCtx.setShouldEndJob(true);
    runStatelessVmCtx.setJob(job);
    // Since run stateless step involves invocation of command, we should set the run stateless vm step as
    // the "beginning step" of the child command.
    runStatelessVmCtx.setStep(runStatelessStep);
    return cloneContextAndDetachFromParent().withExecutionContext(runStatelessVmCtx);
}
#end_block

#method_before
private void removeMemoryFromActiveSnapshot() {
    String memory = getActiveSnapshot().getMemoryVolume();
    if (StringUtils.isEmpty(memory)) {
        return;
    }
    getSnapshotDao().removeMemoryFromActiveSnapshot(getVmId());
    // If the memory volumes are not used by any other snapshot, we can remove them
    if (getSnapshotDao().getNumOfSnapshotsByMemory(memory) == 0) {
        removeMemoryVolumes(memory, getActionType(), true);
    }
}
#method_after
private void removeMemoryFromActiveSnapshot() {
    String memory = getActiveSnapshot().getMemoryVolume();
    if (StringUtils.isEmpty(memory)) {
        return;
    }
    getSnapshotDAO().removeMemoryFromActiveSnapshot(getVmId());
    // If the memory volumes are not used by any other snapshot, we can remove them
    if (getSnapshotDAO().getNumOfSnapshotsByMemory(memory) == 0) {
        removeMemoryVolumes(memory, getActionType(), true);
    }
}
#end_block

#method_before
@Override
public void onPowerringUp() {
    decreasePendingVm(getVmStaticDao().get(getVmId()));
}
#method_after
@Override
public void onPowerringUp() {
    decreasePendingVm(getVmStaticDAO().get(getVmId()));
}
#end_block

#method_before
@Test
public void nicNotExist() {
    nicExists(false);
    assertCanDoActionFailure(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST.toString());
}
#method_after
@Test
public void nicNotExist() {
    nicExists(false);
    assertCanDoActionFailure(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST.toString());
}
#end_block

#method_before
@Test
public void sriovFeatureIsNotSupported() {
    sriovFeatureSupported(false);
    assertCanDoActionFailure(EngineMessage.ACTION_TYPE_FAILED_SRIOV_FEATURE_NOT_SUPPORTED.toString());
}
#method_after
@Test
public void sriovFeatureIsNotSupported() {
    sriovFeatureSupported(false);
    assertCanDoActionFailure(VdcBllMessages.ACTION_TYPE_FAILED_SRIOV_FEATURE_NOT_SUPPORTED.toString());
}
#end_block

#method_before
@Test
public void nicNotSriovEnabled() {
    nicSriovEnabled(false);
    assertCanDoActionFailure(EngineMessage.ACTION_TYPE_FAILED_NIC_IS_NOT_SRIOV_ENABLED.toString());
}
#method_after
@Test
public void nicNotSriovEnabled() {
    nicSriovEnabled(false);
    assertCanDoActionFailure(VdcBllMessages.ACTION_TYPE_FAILED_NIC_IS_NOT_SRIOV_ENABLED.toString());
}
#end_block

#method_before
@Test
public void notAllVfsAreFree() {
    allVfsAreFree(false);
    assertCanDoActionFailure(EngineMessage.ACTION_TYPE_FAILED_NUM_OF_VFS_CANNOT_BE_CHANGED.toString());
}
#method_after
@Test
public void notAllVfsAreFree() {
    allVfsAreFree(false);
    assertCanDoActionFailure(VdcBllMessages.ACTION_TYPE_FAILED_NUM_OF_VFS_CANNOT_BE_CHANGED.toString());
}
#end_block

#method_before
@Test
public void numOfVfsIsNotInRange() {
    numOfVfsInValidRange(false);
    assertCanDoActionFailure(EngineMessage.ACTION_TYPE_FAILED_NUM_OF_VFS_NOT_IN_VALID_RANGE.toString());
}
#method_after
@Test
public void numOfVfsIsNotInRange() {
    numOfVfsInValidRange(false);
    assertCanDoActionFailure(VdcBllMessages.ACTION_TYPE_FAILED_NUM_OF_VFS_NOT_IN_VALID_RANGE.toString());
}
#end_block

#method_before
private void nicExists(boolean isValid) {
    when(validator.nicExists()).thenReturn(isValid ? ValidationResult.VALID : new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST));
}
#method_after
private void nicExists(boolean isValid) {
    when(validator.nicExists()).thenReturn(isValid ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST));
}
#end_block

#method_before
private void sriovFeatureSupported(boolean isValid) {
    when(validator.sriovFeatureSupported()).thenReturn(isValid ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_SRIOV_FEATURE_NOT_SUPPORTED));
}
#method_after
private void sriovFeatureSupported(boolean isValid) {
    when(validator.sriovFeatureSupported()).thenReturn(isValid ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_SRIOV_FEATURE_NOT_SUPPORTED));
}
#end_block

#method_before
private void nicSriovEnabled(boolean isValid) {
    when(validator.nicSriovEnabled()).thenReturn(isValid ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NIC_IS_NOT_SRIOV_ENABLED));
}
#method_after
private void nicSriovEnabled(boolean isValid) {
    when(validator.nicSriovEnabled()).thenReturn(isValid ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NIC_IS_NOT_SRIOV_ENABLED));
}
#end_block

#method_before
private void allVfsAreFree(boolean isValid) {
    when(validator.allVfsAreFree(any(NetworkDeviceHelper.class))).thenReturn(isValid ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NUM_OF_VFS_CANNOT_BE_CHANGED));
}
#method_after
private void allVfsAreFree(boolean isValid) {
    when(validator.allVfsAreFree(any(NetworkDeviceHelper.class))).thenReturn(isValid ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NUM_OF_VFS_CANNOT_BE_CHANGED));
}
#end_block

#method_before
private void numOfVfsInValidRange(boolean isValid) {
    when(validator.numOfVfsInValidRange(param.getNumOfVfs())).thenReturn(isValid ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NUM_OF_VFS_NOT_IN_VALID_RANGE));
}
#method_after
private void numOfVfsInValidRange(boolean isValid) {
    when(validator.numOfVfsInValidRange(param.getNumOfVfs())).thenReturn(isValid ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NUM_OF_VFS_NOT_IN_VALID_RANGE));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean removingVmPool = isRemovingVmPool();
    if (!removingVmPool) {
        applyNextRunConfiguration();
        boolean removedStatelessSnapshot = detachUsers();
        if (!removedStatelessSnapshot && !templateVersionChanged) {
            // If template version didn't change, and we are dealing with a prestarted Vm
            // or a regular Vm - clean stateless images
            // Otherwise this was already done in DetachUserFromVmFromPoolCommand \ updateVmVersionCommand->RemoveVmCommand
            removeVmStatelessImages();
        }
    }
    getQuotaManager().rollbackQuotaByVmId(getVmId());
    if (!removingVmPool) {
        removeStatelessVmUnmanagedDevices();
        boolean vmHasDirectPassthroughDevices = releaseUsedHostDevices();
        Guid hostId = cleanupVfs();
        // Only single dedicated host allowed for host devices, verified on canDoActions
        Guid alternativeHostsList = vmHasDirectPassthroughDevices ? getVm().getDedicatedVmForVdsList().get(0) : null;
        refreshHostIfNeeded(hostId == null ? alternativeHostsList : hostId);
    }
}
#method_after
@Override
protected void executeCommand() {
    applyNextRunConfiguration();
    boolean removedStatelessSnapshot = detachUsers();
    if (!removedStatelessSnapshot && !templateVersionChanged) {
        // If template version didn't change, and we are dealing with a prestarted Vm
        // or a regular Vm - clean stateless images
        // Otherwise this was already done in DetachUserFromVmFromPoolCommand \ updateVmVersionCommand->RemoveVmCommand
        removeVmStatelessImages();
    }
    getQuotaManager().rollbackQuotaByVmId(getVmId());
    removeStatelessVmUnmanagedDevices();
    boolean vmHasDirectPassthroughDevices = releaseUsedHostDevices();
    Guid hostId = cleanupVfs();
    refreshHostIfNeeded(hostId == null ? (vmHasDirectPassthroughDevices ? getVm().getDedicatedVmForVds() : null) : hostId);
}
#end_block

#method_before
private boolean releaseUsedHostDevices() {
    if (hostDeviceManager.checkVmNeedsDirectPassthrough(getVm())) {
        try {
            // Only single dedicated host allowed for host devices, verified on canDoActions
            hostDeviceManager.acquireHostDevicesLock(getVm().getDedicatedVmForVdsList().get(0));
            hostDeviceManager.freeVmHostDevices(getVmId());
        } finally {
            // Only single dedicated host allowed for host devices, verified on canDoActions
            hostDeviceManager.releaseHostDevicesLock(getVm().getDedicatedVmForVdsList().get(0));
        }
        return true;
    }
    return false;
}
#method_after
private boolean releaseUsedHostDevices() {
    if (hostDeviceManager.checkVmNeedsDirectPassthrough(getVm())) {
        try {
            hostDeviceManager.acquireHostDevicesLock(getVm().getDedicatedVmForVds());
            hostDeviceManager.freeVmHostDevices(getVmId());
        } finally {
            hostDeviceManager.releaseHostDevicesLock(getVm().getDedicatedVmForVds());
        }
        return true;
    }
    return false;
}
#end_block

#method_before
private boolean detachUsers() {
    // check if this is a VM from a VM pool
    if (getVm().getVmPoolId() == null) {
        return false;
    }
    List<DbUser> users = getDbUserDao().getAllForVm(getVmId());
    // check if this VM is attached to a user
    if (users == null || users.isEmpty()) {
        // if not, check if new version or need to restore stateless
        if (!templateVersionChanged) {
            // if template version was changed, no need to restore
            runInternalActionWithTasksContext(VdcActionType.RestoreStatelessVm, new VmOperationParameterBase(getVmId()), getLock());
        }
        return true;
    }
    VmPool pool = getVmPoolDao().get(getVm().getVmPoolId());
    if (pool != null && pool.getVmPoolType() == VmPoolType.Automatic) {
        // should be only one user in the collection
        for (DbUser dbUser : users) {
            runInternalActionWithTasksContext(VdcActionType.DetachUserFromVmFromPool, new DetachUserFromVmFromPoolParameters(getVm().getVmPoolId(), dbUser.getId(), getVmId(), !templateVersionChanged), getLock());
        }
        return true;
    }
    return false;
}
#method_after
private boolean detachUsers() {
    // check if this is a VM from a VM pool
    if (getVm().getVmPoolId() == null) {
        return false;
    }
    List<DbUser> users = getDbUserDAO().getAllForVm(getVmId());
    // check if this VM is attached to a user
    if (users == null || users.isEmpty()) {
        // if not, check if new version or need to restore stateless
        if (!templateVersionChanged) {
            // if template version was changed, no need to restore
            runInternalActionWithTasksContext(VdcActionType.RestoreStatelessVm, new VmOperationParameterBase(getVmId()), getLock());
        }
        return true;
    }
    VmPool pool = getVmPoolDAO().get(getVm().getVmPoolId());
    if (pool != null && pool.getVmPoolType() == VmPoolType.Automatic) {
        // should be only one user in the collection
        for (DbUser dbUser : users) {
            runInternalActionWithTasksContext(VdcActionType.DetachUserFromVmFromPool, new DetachUserFromVmFromPoolParameters(getVm().getVmPoolId(), dbUser.getId(), getVmId(), !templateVersionChanged), getLock());
        }
        return true;
    }
    return false;
}
#end_block

#method_before
private void applyNextRunConfiguration() {
    // Remove snpashot first, in case other update is in progress, it will block this one with exclusive lock
    // and any newer update should be preffered to this one.
    Snapshot runSnap = getSnapshotDao().get(getVmId(), SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDao().remove(runSnap.getId());
        Date originalCreationDate = getVm().getVmCreationDate();
        new SnapshotsManager().updateVmFromConfiguration(getVm(), runSnap.getVmConfiguration());
        // override creation date because the value in the config is the creation date of the config, not the vm
        getVm().setVmCreationDate(originalCreationDate);
        VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, createUpdateVmParameters());
        if (result.getActionReturnValue() != null && result.getActionReturnValue().equals(VdcActionType.UpdateVmVersion)) {
            // Template-version changed
            templateVersionChanged = true;
        }
    }
}
#method_after
private void applyNextRunConfiguration() {
    // Remove snpashot first, in case other update is in progress, it will block this one with exclusive lock
    // and any newer update should be preffered to this one.
    Snapshot runSnap = getSnapshotDAO().get(getVmId(), SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDAO().remove(runSnap.getId());
        Date originalCreationDate = getVm().getVmCreationDate();
        new SnapshotsManager().updateVmFromConfiguration(getVm(), runSnap.getVmConfiguration());
        // override creation date because the value in the config is the creation date of the config, not the vm
        getVm().setVmCreationDate(originalCreationDate);
        VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, createUpdateVmParameters());
        if (result.getActionReturnValue() != null && result.getActionReturnValue().equals(VdcActionType.UpdateVmVersion)) {
            // Template-version changed
            templateVersionChanged = true;
        }
    }
}
#end_block

#method_before
private void removeVmStatelessImages() {
    if (getSnapshotDao().exists(getVmId(), SnapshotType.STATELESS)) {
        log.info("Deleting snapshot for stateless vm '{}'", getVmId());
        runInternalAction(VdcActionType.RestoreStatelessVm, new VmOperationParameterBase(getVmId()), ExecutionHandler.createDefaultContextForTasks(getContext(), getLock()));
    }
}
#method_after
private void removeVmStatelessImages() {
    if (getSnapshotDAO().exists(getVmId(), SnapshotType.STATELESS)) {
        log.info("Deleting snapshot for stateless vm '{}'", getVmId());
        runInternalAction(VdcActionType.RestoreStatelessVm, new VmOperationParameterBase(getVmId()), ExecutionHandler.createDefaultContextForTasks(getContext(), getLock()));
    }
}
#end_block

#method_before
public ValidationResult nicExists() {
    return ValidationResult.failWith(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST).when(getNic() == null);
}
#method_after
public ValidationResult nicExists() {
    return ValidationResult.failWith(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST).when(getNic() == null);
}
#end_block

#method_before
public ValidationResult nicSriovEnabled() {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_NIC_IS_NOT_SRIOV_ENABLED, getNicNameReplacement()).when(oldVfsConfig == null);
}
#method_after
public ValidationResult nicSriovEnabled() {
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_NIC_IS_NOT_SRIOV_ENABLED, getNicNameReplacement()).when(oldVfsConfig == null);
}
#end_block

#method_before
public ValidationResult sriovFeatureSupported() {
    VDS host = getDbFacade().getVdsDao().get(getNic().getVdsId());
    Version clusterCompVer = host.getVdsGroupCompatibilityVersion();
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_SRIOV_FEATURE_NOT_SUPPORTED).unless(FeatureSupported.sriov(clusterCompVer));
}
#method_after
public ValidationResult sriovFeatureSupported() {
    VDS host = getDbFacade().getVdsDao().get(getNic().getVdsId());
    Version clusterCompVer = host.getVdsGroupCompatibilityVersion();
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_SRIOV_FEATURE_NOT_SUPPORTED).unless(FeatureSupported.sriov(clusterCompVer));
}
#end_block

#method_before
public ValidationResult allVfsAreFree(NetworkDeviceHelper networkDeviceHelper) {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_NUM_OF_VFS_CANNOT_BE_CHANGED, getNicNameReplacement()).unless(networkDeviceHelper.areAllVfsFree(getNic()));
}
#method_after
public ValidationResult allVfsAreFree(NetworkDeviceHelper networkDeviceHelper) {
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_NUM_OF_VFS_CANNOT_BE_CHANGED, getNicNameReplacement()).unless(networkDeviceHelper.areAllVfsFree(getNic()));
}
#end_block

#method_before
public ValidationResult numOfVfsInValidRange(int numOfVfs) {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_NUM_OF_VFS_NOT_IN_VALID_RANGE, getNicNameReplacement(), String.format(NUM_OF_VFS_REPLACEMENT, numOfVfs), String.format(MAX_NUM_OF_VFS_REPLACEMENT, oldVfsConfig.getMaxNumOfVfs())).when(numOfVfs > oldVfsConfig.getMaxNumOfVfs() || numOfVfs < 0);
}
#method_after
public ValidationResult numOfVfsInValidRange(int numOfVfs) {
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_NUM_OF_VFS_NOT_IN_VALID_RANGE, getNicNameReplacement(), String.format(NUM_OF_VFS_REPLACEMENT, numOfVfs), String.format(MAX_NUM_OF_VFS_REPLACEMENT, oldVfsConfig.getMaxNumOfVfs())).when(numOfVfs > oldVfsConfig.getMaxNumOfVfs() || numOfVfs < 0);
}
#end_block

#method_before
public ValidationResult settingSpecificNetworksAllowed() {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_CANNOT_SET_SPECIFIC_NETWORKS, getNicNameReplacement()).when(oldVfsConfig.isAllNetworksAllowed());
}
#method_after
public ValidationResult settingSpecificNetworksAllowed() {
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_SET_SPECIFIC_NETWORKS, getNicNameReplacement()).when(oldVfsConfig.isAllNetworksAllowed());
}
#end_block

#method_before
public ValidationResult networkExists(Guid networkId) {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_NOT_EXIST, getNicNameReplacement(), String.format(NETWORK_ID_REPLACEMENT, networkId)).when(getNetwork(networkId) == null);
}
#method_after
public ValidationResult networkExists(Guid networkId) {
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_NOT_EXIST, getNicNameReplacement(), String.format(NETWORK_ID_REPLACEMENT, networkId)).when(getNetwork(networkId) == null);
}
#end_block

#method_before
public ValidationResult networkNotInVfsConfig(Guid networkId) {
    String networkName = getNetwork(networkId).getName();
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_ALREADY_IN_VFS_CONFIG, getNicNameReplacement(), String.format(NETWORK_NAME_REPLACEMENT, networkName)).when(oldVfsConfig.getNetworks().contains(networkId));
}
#method_after
public ValidationResult networkNotInVfsConfig(Guid networkId) {
    String networkName = getNetwork(networkId).getName();
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ALREADY_IN_VFS_CONFIG, getNicNameReplacement(), String.format(NETWORK_NAME_REPLACEMENT, networkName)).when(oldVfsConfig.getNetworks().contains(networkId));
}
#end_block

#method_before
public ValidationResult networkInVfsConfig(Guid networkId) {
    String networkName = getNetwork(networkId).getName();
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_NOT_IN_VFS_CONFIG, getNicNameReplacement(), String.format(NETWORK_NAME_REPLACEMENT, networkName)).when(!oldVfsConfig.getNetworks().contains(networkId));
}
#method_after
public ValidationResult networkInVfsConfig(Guid networkId) {
    String networkName = getNetwork(networkId).getName();
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_NOT_IN_VFS_CONFIG, getNicNameReplacement(), String.format(NETWORK_NAME_REPLACEMENT, networkName)).when(!oldVfsConfig.getNetworks().contains(networkId));
}
#end_block

#method_before
public ValidationResult labelNotInVfsConfig(String label) {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_LABEL_ALREADY_IN_VFS_CONFIG, getNicNameReplacement(), String.format(LABEL_REPLACEMENT, label)).when(oldVfsConfig.getNetworkLabels().contains(label));
}
#method_after
public ValidationResult labelNotInVfsConfig(String label) {
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_LABEL_ALREADY_IN_VFS_CONFIG, getNicNameReplacement(), String.format(LABEL_REPLACEMENT, label)).when(oldVfsConfig.getNetworkLabels().contains(label));
}
#end_block

#method_before
public ValidationResult labelInVfsConfig(String label) {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_LABEL_NOT_IN_VFS_CONFIG, getNicNameReplacement(), String.format(LABEL_REPLACEMENT, label)).unless(oldVfsConfig.getNetworkLabels().contains(label));
}
#method_after
public ValidationResult labelInVfsConfig(String label) {
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_LABEL_NOT_IN_VFS_CONFIG, getNicNameReplacement(), String.format(LABEL_REPLACEMENT, label)).unless(oldVfsConfig.getNetworkLabels().contains(label));
}
#end_block

#method_before
@Test
public void testHostDeviceNetworkFree() {
    List<HostDevice> freeVfs = freeVfCommon(1, 0, 0, 0, 0);
    assertEquals(1, freeVfs.size());
    assertTrue(networkDeviceHelper.isNetworkDeviceFree(freeVfs.get(0)));
}
#method_after
@Test
@Ignore
public void testHostDeviceNetworkFree() {
    List<HostDevice> freeVfs = freeVfCommon(1, 0, 0, 0, 0);
    assertEquals(1, freeVfs.size());
    assertTrue(networkDeviceHelper.isNetworkDeviceFree(freeVfs.get(0)));
}
#end_block

#method_before
@Test
public void testHostDeviceOccupiedByNetwork() {
    freeVfCommon(0, 0, 0, 1, 0);
    HostDevice device = getSingleMockedNonFreeDevice();
    assertFalse(networkDeviceHelper.isNetworkDeviceFree(device));
}
#method_after
@Test
@Ignore
public void testHostDeviceOccupiedByNetwork() {
    List<HostDevice> freeVfs = freeVfCommon(0, 0, 0, 1, 0);
    assertEquals(1, freeVfs.size());
    assertFalse(networkDeviceHelper.isNetworkDeviceFree(freeVfs.get(0)));
}
#end_block

#method_before
@Test
public void testHostDeviceOccupiedByVlan() {
    freeVfCommon(0, 0, 0, 0, 1);
    HostDevice device = getSingleMockedNonFreeDevice();
    assertFalse(networkDeviceHelper.isNetworkDeviceFree(device));
}
#method_after
@Test
@Ignore
public void testHostDeviceOccupiedByVlan() {
    List<HostDevice> freeVfs = freeVfCommon(0, 0, 0, 0, 1);
    assertEquals(1, freeVfs.size());
    assertFalse(networkDeviceHelper.isNetworkDeviceFree(freeVfs.get(0)));
}
#end_block

#method_before
private static NetworkOperation binaryOperationWithNetworkInterfaceModelAsSecondOperand(NetworkItemModel<?> op1, NetworkInterfaceModel dst) {
    // first collect the networks into one set
    Set<LogicalNetworkModel> networks = new HashSet<>();
    networks.addAll(dst.getItems());
    // op1 is a NIC, verify that it isn't already part of a bond or dragged unto itself
    if (op1 instanceof NetworkInterfaceModel) {
        NetworkInterfaceModel src = (NetworkInterfaceModel) op1;
        if (src.isBonded() || src.equals(dst)) {
            return NetworkOperation.NULL_OPERATION;
        }
        networks.addAll(src.getItems());
    } else if (op1 instanceof LogicalNetworkModel) {
        // op1 is a network, verify that it isn't dragged unto the NIC already containing it
        if (!networks.add((LogicalNetworkModel) op1)) {
            return NetworkOperation.NULL_OPERATION;
        }
    } else if (op1 instanceof NetworkLabelModel) {
        // op1 is a label, verify that it's not applied to the interface already labelled by it
        NetworkLabelModel src = (NetworkLabelModel) op1;
        if (dst.equals(src.getInterface())) {
            return NetworkOperation.NULL_OPERATION;
        }
        networks.addAll(src.getNetworks());
    }
    final String hostMaxSupportedClusterVersion = gethostMaxSupportedClusterVersion(op1);
    final boolean permissiveValidation = AsyncDataProvider.getInstance().isNetworkExclusivenessPermissiveValidation(hostMaxSupportedClusterVersion);
    // go over the networks and check whether they comply, if not - the reason is important
    boolean vlanFound = false;
    String nonVlanVmNetwork = null;
    int nonVlanCounter = 0;
    for (LogicalNetworkModel network : networks) {
        if (!network.isManaged()) {
            if (op1 instanceof LogicalNetworkModel) {
                return NetworkOperation.NULL_OPERATION_UNMANAGED;
            }
            if (op1.aggregatesNetworks()) {
                dst.setCulpritNetwork(network.getName());
                return NetworkOperation.NULL_OPERATION_BATCH_UNMANAGED;
            }
        } else {
            if (!network.isInSync()) {
                if (op1 instanceof LogicalNetworkModel) {
                    return NetworkOperation.NULL_OPERATION_OUT_OF_SYNC;
                }
                if (op1.aggregatesNetworks()) {
                    dst.setCulpritNetwork(network.getName());
                    return NetworkOperation.NULL_OPERATION_BATCH_OUT_OF_SYNC;
                }
            }
        }
        if (network.hasVlan()) {
            vlanFound = true;
        } else {
            ++nonVlanCounter;
            if (network.getNetwork().isVmNetwork()) {
                nonVlanVmNetwork = network.getName();
            }
        }
        if (nonVlanCounter > 1) {
            if (op1 instanceof LogicalNetworkModel) {
                return NetworkOperation.NULL_OPERATION_TOO_MANY_NON_VLANS;
            }
            if (op1.aggregatesNetworks()) {
                dst.setCulpritNetwork(network.getName());
                return NetworkOperation.NULL_OPERATION_BATCH_TOO_MANY_NON_VLANS;
            }
        } else {
            if (!permissiveValidation && nonVlanVmNetwork != null && vlanFound) {
                if (op1 instanceof LogicalNetworkModel) {
                    return NetworkOperation.NULL_OPERATION_VM_WITH_VLANS;
                }
                if (op1.aggregatesNetworks()) {
                    dst.setCulpritNetwork(nonVlanVmNetwork);
                    return NetworkOperation.NULL_OPERATION_BATCH_VM_WITH_VLANS;
                }
            }
        }
    }
    // networks comply, all that's left is to return the correct operation
    if (op1 instanceof LogicalNetworkModel) {
        return NetworkOperation.ATTACH_NETWORK;
    }
    if (op1 instanceof BondNetworkInterfaceModel) {
        if (dst instanceof BondNetworkInterfaceModel) {
            return NetworkOperation.JOIN_BONDS;
        } else {
            return NetworkOperation.EXTEND_BOND_WITH;
        }
    }
    if (op1 instanceof NetworkInterfaceModel) {
        if (dst instanceof BondNetworkInterfaceModel) {
            return NetworkOperation.ADD_TO_BOND;
        } else {
            return NetworkOperation.BOND_WITH;
        }
    }
    if (op1 instanceof NetworkLabelModel) {
        return NetworkOperation.LABEL;
    }
    return NetworkOperation.NULL_OPERATION;
}
#method_after
private static NetworkOperation binaryOperationWithNetworkInterfaceModelAsSecondOperand(NetworkItemModel<?> op1, NetworkInterfaceModel dst) {
    // first collect the networks into one set
    Set<LogicalNetworkModel> networks = new HashSet<>();
    networks.addAll(dst.getItems());
    // op1 is a NIC, verify that it isn't already part of a bond or dragged unto itself
    if (op1 instanceof NetworkInterfaceModel) {
        NetworkInterfaceModel src = (NetworkInterfaceModel) op1;
        if (src.isBonded() || src.equals(dst)) {
            return NetworkOperation.NULL_OPERATION;
        }
        networks.addAll(src.getItems());
    } else if (op1 instanceof LogicalNetworkModel) {
        // op1 is a network, verify that it isn't dragged unto the NIC already containing it
        if (!networks.add((LogicalNetworkModel) op1)) {
            return NetworkOperation.NULL_OPERATION;
        }
    } else if (op1 instanceof NetworkLabelModel) {
        // op1 is a label, verify that it's not applied to the interface already labelled by it
        NetworkLabelModel src = (NetworkLabelModel) op1;
        if (dst.equals(src.getInterface())) {
            return NetworkOperation.NULL_OPERATION;
        }
        networks.addAll(src.getNetworks());
    }
    final String hostMaxSupportedClusterVersion = getHostMaxSupportedClusterVersion(op1);
    final boolean permissiveValidation = AsyncDataProvider.getInstance().isNetworkExclusivenessPermissiveValidation(hostMaxSupportedClusterVersion);
    // go over the networks and check whether they comply, if not - the reason is important
    boolean vlanFound = false;
    String nonVlanVmNetwork = null;
    int nonVlanCounter = 0;
    for (LogicalNetworkModel network : networks) {
        if (!network.isManaged()) {
            if (op1 instanceof LogicalNetworkModel) {
                return NetworkOperation.NULL_OPERATION_UNMANAGED;
            }
            if (op1.aggregatesNetworks()) {
                dst.setCulpritNetwork(network.getName());
                return NetworkOperation.NULL_OPERATION_BATCH_UNMANAGED;
            }
        } else {
            if (!network.isInSync()) {
                if (op1 instanceof LogicalNetworkModel) {
                    return NetworkOperation.NULL_OPERATION_OUT_OF_SYNC;
                }
                if (op1.aggregatesNetworks()) {
                    dst.setCulpritNetwork(network.getName());
                    return NetworkOperation.NULL_OPERATION_BATCH_OUT_OF_SYNC;
                }
            }
        }
        if (network.hasVlan()) {
            vlanFound = true;
        } else {
            ++nonVlanCounter;
            if (network.getNetwork().isVmNetwork()) {
                nonVlanVmNetwork = network.getName();
            }
        }
        if (nonVlanCounter > 1) {
            if (op1 instanceof LogicalNetworkModel) {
                return NetworkOperation.NULL_OPERATION_TOO_MANY_NON_VLANS;
            }
            if (op1.aggregatesNetworks()) {
                dst.setCulpritNetwork(network.getName());
                return NetworkOperation.NULL_OPERATION_BATCH_TOO_MANY_NON_VLANS;
            }
        } else {
            if (!permissiveValidation && nonVlanVmNetwork != null && vlanFound) {
                if (op1 instanceof LogicalNetworkModel) {
                    return NetworkOperation.NULL_OPERATION_VM_WITH_VLANS;
                }
                if (op1.aggregatesNetworks()) {
                    dst.setCulpritNetwork(nonVlanVmNetwork);
                    return NetworkOperation.NULL_OPERATION_BATCH_VM_WITH_VLANS;
                }
            }
        }
    }
    // networks comply, all that's left is to return the correct operation
    if (op1 instanceof LogicalNetworkModel) {
        return NetworkOperation.ATTACH_NETWORK;
    }
    if (op1 instanceof BondNetworkInterfaceModel) {
        if (dst instanceof BondNetworkInterfaceModel) {
            return NetworkOperation.JOIN_BONDS;
        } else {
            return NetworkOperation.EXTEND_BOND_WITH;
        }
    }
    if (op1 instanceof NetworkInterfaceModel) {
        if (dst instanceof BondNetworkInterfaceModel) {
            return NetworkOperation.ADD_TO_BOND;
        } else {
            return NetworkOperation.BOND_WITH;
        }
    }
    if (op1 instanceof NetworkLabelModel) {
        return NetworkOperation.LABEL;
    }
    return NetworkOperation.NULL_OPERATION;
}
#end_block

#method_before
@Override
public VdcBllMessages getViolationMessage() {
    return VdcBllMessages.NETWORK_INTERFACES_NOT_EXCLUSIVELY_USED_BY_NETWORK;
}
#method_after
@Override
public EngineMessage getViolationMessage() {
    return EngineMessage.NETWORK_INTERFACES_NOT_EXCLUSIVELY_USED_BY_NETWORK;
}
#end_block

#method_before
@Test
public void testResolveNetworkExclusivenessValidatorNullInput() {
    final NetworkExclusivenessValidator actual = underTest.resolveNetworkExclusivenessValidator(null);
    Assert.assertThat(actual, sameInstance(legacyNetworkExclusivenessValidator));
}
#method_after
@Test
public void testResolveNetworkExclusivenessValidatorNullInput() {
    final NetworkExclusivenessValidator actual = underTest.resolveNetworkExclusivenessValidator(null);
    assertThat(actual, sameInstance(legacyNetworkExclusivenessValidator));
}
#end_block

#method_before
@Test
public void testResolveNetworkExclusivenessValidatorEmptyInput() {
    final NetworkExclusivenessValidator actual = underTest.resolveNetworkExclusivenessValidator(Collections.<Version>emptySet());
    Assert.assertThat(actual, sameInstance(legacyNetworkExclusivenessValidator));
}
#method_after
@Test
public void testResolveNetworkExclusivenessValidatorEmptyInput() {
    final NetworkExclusivenessValidator actual = underTest.resolveNetworkExclusivenessValidator(Collections.<Version>emptySet());
    assertThat(actual, sameInstance(legacyNetworkExclusivenessValidator));
}
#end_block

#method_before
@Test
public void testResolveNetworkExclusivenessValidatorNew() {
    final HashSet<Version> supportedVersions = new HashSet<>(Arrays.asList(Version.v3_5, Version.v3_6));
    final NetworkExclusivenessValidator actual = underTest.resolveNetworkExclusivenessValidator(supportedVersions);
    Assert.assertThat(actual, sameInstance(vlanUntaggedNetworkExclusivenessValidator));
}
#method_after
@Test
public void testResolveNetworkExclusivenessValidatorNew() {
    final HashSet<Version> supportedVersions = new HashSet<>(Arrays.asList(Version.v3_5, Version.v3_6));
    final NetworkExclusivenessValidator actual = underTest.resolveNetworkExclusivenessValidator(supportedVersions);
    assertThat(actual, sameInstance(vlanUntaggedNetworkExclusivenessValidator));
}
#end_block

#method_before
@Test
public void testResolveNetworkExclusivenessValidatorAllLegacy() {
    final Set<Version> supportedVersions = new HashSet<>();
    for (int i = 0; i < 6; i++) {
        supportedVersions.add(new Version(3, i));
    }
    final NetworkExclusivenessValidator actual = underTest.resolveNetworkExclusivenessValidator(supportedVersions);
    Assert.assertThat(actual, sameInstance(legacyNetworkExclusivenessValidator));
}
#method_after
@Test
public void testResolveNetworkExclusivenessValidatorAllLegacy() {
    final Set<Version> supportedVersions = new HashSet<>();
    for (int i = 0; i < 6; i++) {
        supportedVersions.add(new Version(3, i));
    }
    final NetworkExclusivenessValidator actual = underTest.resolveNetworkExclusivenessValidator(supportedVersions);
    assertThat(actual, sameInstance(legacyNetworkExclusivenessValidator));
}
#end_block

#method_before
@Test
public void testResolveNetworkExclusivenessValidatorEveryLegacyVersion() {
    for (int i = 0; i < 6; i++) {
        final Version version = new Version(3, i);
        final NetworkExclusivenessValidator actual = underTest.resolveNetworkExclusivenessValidator(Collections.singleton(version));
        Assert.assertThat(version.getValue() + " supposed to return the legacy validator", actual, sameInstance(legacyNetworkExclusivenessValidator));
    }
}
#method_after
@Test
public void testResolveNetworkExclusivenessValidatorEveryLegacyVersion() {
    for (int i = 0; i < 6; i++) {
        final Version version = new Version(3, i);
        final NetworkExclusivenessValidator actual = underTest.resolveNetworkExclusivenessValidator(Collections.singleton(version));
        assertThat(version.getValue() + " supposed to return the legacy validator", actual, sameInstance(legacyNetworkExclusivenessValidator));
    }
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__SETUP);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__NETWORKS);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__SETUP);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__NETWORKS);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDS host = getVds();
    if (host == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
        return false;
    }
    if (!hostStatusLegalForSetupNetworks(host)) {
        addCanDoActionMessage(VdcBllMessages.VAR__HOST_STATUS__UP_MAINTENANCE_OR_NON_OPERATIONAL);
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL);
        return false;
    }
    NicNameNicIdCompleter completer = new NicNameNicIdCompleter(getExistingNics());
    completer.completeNetworkAttachments(getParameters().getNetworkAttachments());
    completer.completeBonds(getParameters().getBonds());
    completer.completeNetworkAttachments(getExistingAttachments());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments(), getNetworkBusinessEntityMap());
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, getParameters(), getExistingNics(), getExistingAttachments(), getNetworkBusinessEntityMap(), managementNetworkUtil, networkExclusivenessValidatorResolver);
    FailingValidationResults<String> validationResults = validator.validate();
    if (!validationResults.isValid()) {
        List<String> validationMessages = validationResults.translateToListOfViolationMessagesWithCausesString();
        for (String msg : validationMessages) {
            addCanDoActionMessage(msg);
        }
        return false;
    }
    if (!checkForOutOfSyncNetworks()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VDS host = getVds();
    final ValidationResult hostValidatorResult = new HostValidator(host, isInternalExecution()).validate();
    if (!hostValidatorResult.isValid()) {
        return validate(hostValidatorResult);
    }
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(getExistingNics());
    nicNameNicIdCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments());
    nicNameNicIdCompleter.completeBonds(getParameters().getBonds());
    nicNameNicIdCompleter.completeNetworkAttachments(getExistingAttachments());
    nicNameNicIdCompleter.completeLabels(getParameters().getLabels());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments(), getNetworkBusinessEntityMap());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getExistingAttachments(), getNetworkBusinessEntityMap());
    NicLabelsCompleter labelsCompleter = new NicLabelsCompleter(getParameters(), getExistingAttachments(), getClusterNetworks(), getExistingNicsBusinessEntityMap());
    labelsCompleter.completeNetworkAttachments();
    ValidationResult hostSetupNetworkValidatorResult = validateWithHostSetupNetworksValidator(host);
    if (!hostSetupNetworkValidatorResult.isValid()) {
        return validate(hostSetupNetworkValidatorResult);
    }
    return validate(checkForOutOfSyncNetworks());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        log.info("No changes were detected in setup networks for host '{}' (ID: '{}')", getVdsName(), getVdsId());
        setSucceeded(true);
        return;
    }
    int timeout = getSetupNetworksTimeout();
    FutureVDSCall<VDSReturnValue> setupNetworksTask = invokeSetupNetworksCommand(timeout);
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().rollbackOnFailure()) {
                throw new VdcBLLException(VdcBllErrors.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                try (EngineLock monitoringLock = acquireMonitorLock()) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Host Setup networks command timed out for {} seconds", timeout);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        log.info("No changes were detected in setup networks for host '{}' (ID: '{}')", getVdsName(), getVdsId());
        setSucceeded(true);
        return;
    }
    int timeout = getSetupNetworksTimeout();
    FutureVDSCall<VDSReturnValue> setupNetworksTask = invokeSetupNetworksCommand(timeout);
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().rollbackOnFailure()) {
                throw new EngineException(EngineError.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                try (EngineLock monitoringLock = acquireMonitorLock()) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                logMonitorLockReleased("Host setup networks");
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Host Setup networks command timed out for {} seconds", timeout);
    }
}
#end_block

#method_before
private boolean checkForOutOfSyncNetworks() {
    BusinessEntityMap<VdsNetworkInterface> existingNicsBusinessEntityMap = getExistingNicsBusinessEntityMap();
    boolean success = true;
    for (NetworkAttachment networkAttachment : getParameters().getNetworkAttachments()) {
        boolean newNetworkAttachment = networkAttachment.getId() == null;
        if (newNetworkAttachment) {
            // attachment to be yet created cannot be out of sync.
            continue;
        }
        boolean doNotCheckForOutOfSync = networkAttachment.isOverrideConfiguration();
        if (doNotCheckForOutOfSync) {
            continue;
        }
        Map<Guid, NetworkAttachment> existingNetworkAttachmentMap = Entities.businessEntitiesById(getExistingAttachments());
        NetworkAttachment existingNetworkAttachment = existingNetworkAttachmentMap.get(networkAttachment.getId());
        VdsNetworkInterface vdsNetworkInterface = existingNicsBusinessEntityMap.get(existingNetworkAttachment.getNicId());
        Network network = getNetworkBusinessEntityMap().get(existingNetworkAttachment.getNetworkId());
        HostNetworkQos qos = qosDaoCache.get(network.getQosId());
        boolean networkInSync = NetworkUtils.isNetworkInSync(vdsNetworkInterface, network, qos);
        if (!networkInSync) {
            boolean networkMoved = networkMoved(networkAttachment, existingNetworkAttachment);
            addCanDoActionMessage(networkMoved ? VdcBllMessages.MOVING_NETWORKS_MAKES_IT_OUT_OF_SYNC : VdcBllMessages.NETWORKS_NOT_IN_SYNC);
            addCanDoActionMessageVariable("NETWORK_NOT_IN_SYNC", network.getName());
            success = false;
        }
    }
    return success;
}
#method_after
private ValidationResult checkForOutOfSyncNetworks() {
    for (NetworkAttachment networkAttachment : getParameters().getNetworkAttachments()) {
        boolean newNetworkAttachment = networkAttachment.getId() == null;
        if (newNetworkAttachment) {
            // attachment to be yet created cannot be out of sync.
            continue;
        }
        boolean doNotCheckForOutOfSync = networkAttachment.isOverrideConfiguration();
        if (doNotCheckForOutOfSync) {
            continue;
        }
        Map<Guid, NetworkAttachment> existingNetworkAttachmentMap = Entities.businessEntitiesById(getExistingAttachments());
        NetworkAttachment existingNetworkAttachment = existingNetworkAttachmentMap.get(networkAttachment.getId());
        VdsNetworkInterface nic = Entities.hostInterfacesByNetworkName(getExistingNics()).get(existingNetworkAttachment.getNetworkName());
        NetworkImplementationDetails networkImplementationDetails = nic.getNetworkImplementationDetails();
        boolean networkIsNotInSync = networkImplementationDetails != null && !networkImplementationDetails.isInSync();
        if (networkIsNotInSync) {
            return new ValidationResult(EngineMessage.NETWORKS_NOT_IN_SYNC, ReplacementUtils.createSetVariableString("NETWORK_NOT_IN_SYNC", existingNetworkAttachment.getNetworkName()));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private HostSetupNetworksVdsCommandParameters createSetupNetworksParameters(int timeout) {
    final HostSetupNetworksVdsCommandParameters hostCmdParams = new HostSetupNetworksVdsCommandParameters(getVds(), getNetworks(), getAllNetworksToRemove(), getParameters().getBonds(), getRemovedBondNames());
    hostCmdParams.setRollbackOnFailure(getParameters().rollbackOnFailure());
    hostCmdParams.setConectivityTimeout(timeout);
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(getVds().getVdsGroupCompatibilityVersion());
    hostCmdParams.setHostNetworkQosSupported(hostNetworkQosSupported);
    return hostCmdParams;
}
#method_after
private HostSetupNetworksVdsCommandParameters createSetupNetworksParameters(int timeout) {
    final HostSetupNetworksVdsCommandParameters hostCmdParams = new HostSetupNetworksVdsCommandParameters(getVds(), getNetworksToConfigure(), getAllNetworksToRemove(), getParameters().getBonds(), getRemovedBondNames());
    hostCmdParams.setRollbackOnFailure(getParameters().rollbackOnFailure());
    hostCmdParams.setConectivityTimeout(timeout);
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(getVds().getVdsGroupCompatibilityVersion());
    hostCmdParams.setHostNetworkQosSupported(hostNetworkQosSupported);
    return hostCmdParams;
}
#end_block

#method_before
private boolean defaultRouteRequired(Network network, IpConfiguration ipConfiguration) {
    return managementNetworkUtil.isManagementNetwork(network.getId()) && ipConfiguration != null && (ipConfiguration.getBootProtocol() == NetworkBootProtocol.DHCP || ipConfiguration.getBootProtocol() == NetworkBootProtocol.STATIC_IP && ipConfiguration.hasPrimaryAddressSet() && StringUtils.isNotEmpty(ipConfiguration.getPrimaryAddress().getGateway()));
}
#method_after
private boolean defaultRouteRequired(Network network, IpConfiguration ipConfiguration) {
    return managementNetworkUtil.isManagementNetwork(network.getId(), getVds().getVdsGroupId()) && ipConfiguration != null && ipConfiguration.hasPrimaryAddressSet() && (ipConfiguration.getPrimaryAddress().getBootProtocol() == NetworkBootProtocol.DHCP || ipConfiguration.getPrimaryAddress().getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(ipConfiguration.getPrimaryAddress().getGateway()));
}
#end_block

#method_before
private boolean noChangesDetected() {
    return getNetworks().isEmpty() && getRemovedNetworks().isEmpty() && getParameters().getBonds().isEmpty() && getRemovedBondNames().isEmpty();
}
#method_after
private boolean noChangesDetected() {
    return getNetworksToConfigure().isEmpty() && getRemovedNetworks().isEmpty() && getParameters().getBonds().isEmpty() && getRemovedBondNames().isEmpty() && getRemovedUnmanagedNetworks().isEmpty() && getParameters().getLabels().isEmpty() && getParameters().getRemovedLabels().isEmpty();
}
#end_block

#method_before
private Set<String> getRemovedBondNames() {
    if (removedBondNames == null) {
        List<VdsNetworkInterface> existingVdsInterfaceToBeRemoved = getExistingBondVdsInterfaceToBeRemoved();
        Set<String> removedBondNames = new HashSet<>(existingVdsInterfaceToBeRemoved.size());
        for (VdsNetworkInterface removedBondInterface : existingVdsInterfaceToBeRemoved) {
            removedBondNames.add(removedBondInterface.getName());
        }
        this.removedBondNames = removedBondNames;
    }
    return removedBondNames;
}
#method_after
private Set<String> getRemovedBondNames() {
    if (removedBondNames == null) {
        List<VdsNetworkInterface> existingVdsInterfaceToBeRemoved = getRemovedBonds();
        Set<String> removedBondNames = new HashSet<>(existingVdsInterfaceToBeRemoved.size());
        for (VdsNetworkInterface removedBondInterface : existingVdsInterfaceToBeRemoved) {
            removedBondNames.add(removedBondInterface.getName());
        }
        this.removedBondNames = removedBondNames;
    }
    return removedBondNames;
}
#end_block

#method_before
private List<VdsNetworkInterface> getExistingNics() {
    if (existingNics == null) {
        existingNics = getDbFacade().getInterfaceDao().getAllInterfacesForVds(getVdsId());
        for (VdsNetworkInterface iface : existingNics) {
            Network network = getNetworkBusinessEntityMap().get(iface.getNetworkName());
            HostNetworkQos hostNetworkQos = network == null ? null : qosDaoCache.get(network.getQosId());
            VdsNetworkInterface.NetworkImplementationDetails networkImplementationDetails = NetworkUtils.calculateNetworkImplementationDetails(network, hostNetworkQos, iface);
            iface.setNetworkImplementationDetails(networkImplementationDetails);
        }
    }
    return existingNics;
}
#method_after
private List<VdsNetworkInterface> getExistingNics() {
    if (existingNics == null) {
        existingNics = getDbFacade().getInterfaceDao().getAllInterfacesForVds(getVdsId());
        NetworkCommonUtils.fillBondSlaves(existingNics);
        for (VdsNetworkInterface iface : existingNics) {
            Network network = getNetworkBusinessEntityMap().get(iface.getNetworkName());
            NetworkImplementationDetails networkImplementationDetails = networkImplementationDetailsUtils.calculateNetworkImplementationDetails(iface, network);
            iface.setNetworkImplementationDetails(networkImplementationDetails);
        }
    }
    return existingNics;
}
#end_block

#method_before
private Set<String> getRemovedNetworks() {
    if (removedNetworks == null) {
        Set<Guid> removedNetworkAttachmentIds = getParameters().getRemovedNetworkAttachments();
        int removedNetworkAttachmentIdsSize = removedNetworkAttachmentIds.size();
        removedNetworks = new HashSet<>(removedNetworkAttachmentIdsSize);
        List<NetworkAttachment> removedNetworkAttachments = new ArrayList<>(removedNetworkAttachmentIdsSize);
        if (!Entities.entitiesById(removedNetworkAttachmentIds, existingAttachments, removedNetworkAttachments)) {
            throw new IllegalArgumentException("Unable to find requested network attachment");
        } else {
            for (NetworkAttachment attachment : removedNetworkAttachments) {
                removedNetworks.add(getNetworkBusinessEntityMap().get(attachment.getNetworkId()).getName());
            }
        }
    }
    return removedNetworks;
}
#method_after
private Set<String> getRemovedNetworks() {
    if (removedNetworks == null) {
        List<NetworkAttachment> removedNetworkAttachments = Entities.filterEntitiesByRequiredIds(getParameters().getRemovedNetworkAttachments(), existingAttachments);
        removedNetworks = new HashSet<>(removedNetworkAttachments.size());
        Map<Guid, NetworkAttachment> networkIdToAttachment = new MapNetworkAttachments(getParameters().getNetworkAttachments()).byNetworkId();
        for (NetworkAttachment removedAttachment : removedNetworkAttachments) {
            if (!networkIdToAttachment.containsKey(removedAttachment.getNetworkId())) {
                removedNetworks.add(existingNetworkRelatedToAttachment(removedAttachment).getName());
            }
        }
    }
    return removedNetworks;
}
#end_block

#method_before
private List<VdsNetworkInterface> applyUserConfiguredNics() {
    List<VdsNetworkInterface> userConfiguredNics = new ArrayList<>();
    userConfiguredNics.addAll(getParameters().getBonds());
    for (VdsNetworkInterface existingBondToRemove : getExistingBondVdsInterfaceToBeRemoved()) {
        existingBondToRemove.setLabels(null);
        userConfiguredNics.add(existingBondToRemove);
    }
    return userConfiguredNics;
}
#method_after
private List<VdsNetworkInterface> applyUserConfiguredNics() {
    List<VdsNetworkInterface> nicsToConfigure = getNicsToConfigureWithoutLabelsUpdates();
    updateLabelsOnNicsToConfigure(nicsToConfigure);
    return nicsToConfigure;
}
#end_block

#method_before
private List<Network> getModifiedNetworks() {
    List<Network> modifiedNetworks = new ArrayList<>(getParameters().getNetworkAttachments().size());
    for (NetworkAttachment attachment : getParameters().getNetworkAttachments()) {
        modifiedNetworks.add(getNetworkBusinessEntityMap().get(attachment.getNetworkId()));
    }
    return modifiedNetworks;
}
#method_after
private List<Network> getModifiedNetworks() {
    if (modifiedNetworks == null) {
        List<NetworkAttachment> networkAttachments = getParameters().getNetworkAttachments();
        modifiedNetworks = new ArrayList<>(networkAttachments.size());
        for (NetworkAttachment attachment : networkAttachments) {
            modifiedNetworks.add(existingNetworkRelatedToAttachment(attachment));
        }
    }
    return modifiedNetworks;
}
#end_block

#method_before
private BusinessEntityMap<Network> getNetworkBusinessEntityMap() {
    if (networkBusinessEntityMap == null) {
        List<Network> networks = getNetworkDAO().getAllForCluster(getVdsGroupId());
        networkBusinessEntityMap = new BusinessEntityMap<>(networks);
    }
    return networkBusinessEntityMap;
}
#method_after
private BusinessEntityMap<Network> getNetworkBusinessEntityMap() {
    if (networkBusinessEntityMap == null) {
        networkBusinessEntityMap = new BusinessEntityMap<>(getClusterNetworks());
    }
    return networkBusinessEntityMap;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    vlanNetwork = createNetworkWithId();
    vlanNetwork.setVlanId(1);
    vmNetwork1 = createNetworkWithId();
    vmNetwork1.setVmNetwork(true);
    vmNetwork2 = createNetworkWithId();
    vmNetwork2.setVmNetwork(true);
    nonVmNetwork1 = createNetworkWithId();
    nonVmNetwork1.setVmNetwork(false);
    nonVmNetwork2 = createNetworkWithId();
    nonVmNetwork2.setVmNetwork(false);
    networkMap = new BusinessEntityMap<>(Arrays.asList(vlanNetwork, vmNetwork1, vmNetwork2, nonVmNetwork1, nonVmNetwork2));
    Mockito.when(networkExclusivenessValidator.getViolationMessage()).thenReturn(NETWORK_INTERFACES_NOT_EXCLUSIVELY_USED_BY_NETWORK);
}
#method_after
@Before
public void setUp() throws Exception {
    nic = new VdsNetworkInterface();
    nic.setId(Guid.newGuid());
    nic.setName("nicName");
    vlanNetwork = createNetworkWithIdAndName("vlanNetwork");
    vlanNetwork.setVlanId(1);
    vmNetwork1 = createNetworkWithIdAndName("Network1");
    vmNetwork1.setVmNetwork(true);
    vmNetwork2 = createNetworkWithIdAndName("Network2");
    vmNetwork2.setVmNetwork(true);
    nonVmNetwork1 = createNetworkWithIdAndName("nonVmNetwork1");
    nonVmNetwork1.setVmNetwork(false);
    nonVmNetwork2 = createNetworkWithIdAndName("nonVmNetwork2");
    nonVmNetwork2.setVmNetwork(false);
    networkMap = new BusinessEntityMap<>(Arrays.asList(vlanNetwork, vmNetwork1, vmNetwork2, nonVmNetwork1, nonVmNetwork2));
    when(networkExclusivenessValidator.getViolationMessage()).thenReturn(NETWORK_INTERFACES_NOT_EXCLUSIVELY_USED_BY_NETWORK);
}
#end_block

#method_before
private void checkVmNetworkIsSoleAssignedInterface(boolean valid, List<NetworkType> expectedNetworksTypes, Network... networks) {
    List<NetworkAttachment> attachmentsToConfigure = new ArrayList<>(networks.length);
    for (Network network : networks) {
        attachmentsToConfigure.add(createNetworkAttachment("a", network));
    }
    when(networkExclusivenessValidator.isNetworkExclusive(expectedNetworksTypes)).thenReturn(valid);
    NetworkAttachmentsValidator validator = new NetworkAttachmentsValidator(attachmentsToConfigure, networkMap, networkExclusivenessValidator);
    final ValidationResult actual = validator.validateNetworkExclusiveOnNics();
    verify(networkExclusivenessValidator).isNetworkExclusive(networkTypeCaptor.capture());
    assertThat(networkTypeCaptor.getValue(), is(expectedNetworksTypes));
    final Matcher<? super ValidationResult> matcher = valid ? isValid() : failsWith(NETWORK_INTERFACES_NOT_EXCLUSIVELY_USED_BY_NETWORK);
    assertThat(actual, matcher);
}
#method_after
private void checkVmNetworkIsSoleAssignedInterface(boolean valid, List<NetworkType> expectedNetworksTypes, Network... networks) {
    List<NetworkAttachment> attachmentsToConfigure = new ArrayList<>(networks.length);
    for (Network network : networks) {
        attachmentsToConfigure.add(createNetworkAttachment(nic.getName(), network));
    }
    when(networkExclusivenessValidator.isNetworkExclusive(expectedNetworksTypes)).thenReturn(valid);
    NetworkAttachmentsValidator validator = new NetworkAttachmentsValidator(attachmentsToConfigure, networkMap, networkExclusivenessValidator);
    final ValidationResult actual = validator.validateNetworkExclusiveOnNics();
    verify(networkExclusivenessValidator).isNetworkExclusive(networkTypeCaptor.capture());
    assertThat(networkTypeCaptor.getValue(), is(expectedNetworksTypes));
    final Matcher<? super ValidationResult> matcher = valid ? isValid() : failsWith(NETWORK_INTERFACES_NOT_EXCLUSIVELY_USED_BY_NETWORK);
    assertThat(actual, matcher);
}
#end_block

#method_before
private NetworkAttachment createNetworkAttachment(String nicName, Network network) {
    NetworkAttachment result = new NetworkAttachment();
    result.setNicName(nicName);
    result.setNetworkId(network.getId());
    return result;
}
#method_after
private NetworkAttachment createNetworkAttachment(String nicName, Network network) {
    NetworkAttachment result = createNetworkAttachment(network);
    result.setNicName(nicName);
    return result;
}
#end_block

#method_before
private NetworkAttachment createNetworkAttachment(String nicName, Network network) {
    NetworkAttachment result = new NetworkAttachment();
    result.setNicName(nicName);
    result.setNetworkId(network.getId());
    return result;
}
#method_after
private NetworkAttachment createNetworkAttachment(Network network) {
    NetworkAttachment result = new NetworkAttachment();
    result.setNetworkId(network.getId());
    return result;
}
#end_block

#method_before
@Test(expected = IllegalArgumentException.class)
public void testValidateNetworkExclusiveOnNicsAllAttachmentsMustHaveNicNameSet() throws Exception {
    BusinessEntityMap<Network> networkMap = new BusinessEntityMap<>(Arrays.asList(vlanNetwork, vmNetwork1, nonVmNetwork1));
    NetworkAttachment networkAttachment = new NetworkAttachment();
    networkAttachment.setNetworkId(vmNetwork1.getId());
    List<NetworkAttachment> attachmentsToConfigure = Collections.singletonList(networkAttachment);
    new NetworkAttachmentsValidator(attachmentsToConfigure, networkMap, networkExclusivenessValidator).validateNetworkExclusiveOnNics();
}
#method_after
@Test(expected = IllegalArgumentException.class)
public void testValidateNetworkExclusiveOnNicsAllAttachmentsMustHaveNicNameSet() throws Exception {
    NetworkAttachment networkAttachment = new NetworkAttachment();
    networkAttachment.setNetworkId(vmNetwork1.getId());
    List<NetworkAttachment> attachmentsToConfigure = Collections.singletonList(networkAttachment);
    new NetworkAttachmentsValidator(attachmentsToConfigure, networkMap, networkExclusivenessValidator).validateNetworkExclusiveOnNics();
}
#end_block

#method_before
@Override
public VdcBllMessages getViolationMessage() {
    return VdcBllMessages.NETWORK_INTERFACES_NOT_EXCLUSIVELY_USED_BY_UNTAGGED_NETWORK;
}
#method_after
@Override
public EngineMessage getViolationMessage() {
    return EngineMessage.NETWORK_INTERFACES_NOT_EXCLUSIVELY_USED_BY_UNTAGGED_NETWORK;
}
#end_block

#method_before
@Test
public void testNotRemovingLabeledNetworksReferencingUnlabeledNetworkRemovalIsOk() throws Exception {
    Network unlabeledNetwork = new Network();
    unlabeledNetwork.setId(Guid.newGuid());
    NetworkAttachment networkAttachment = createNetworkAttachment(unlabeledNetwork);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Collections.singletonList(unlabeledNetwork), Collections.<VdsNetworkInterface>emptyList());
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), is(true));
}
#method_after
public void testNotRemovingLabeledNetworksReferencingUnlabeledNetworkRemovalIsOk() throws Exception {
    Network unlabeledNetwork = new Network();
    unlabeledNetwork.setId(Guid.newGuid());
    NetworkAttachment networkAttachment = createNetworkAttachment(unlabeledNetwork);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Collections.singletonList(unlabeledNetwork));
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), isValid());
}
#end_block

#method_before
@Test
public void testNotRemovingLabeledNetworksWhenNicNameDoesNotReferenceExistingNicItsOkToRemove() throws Exception {
    Network labeledNetwork = new Network();
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel("label");
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName("noLongerExistingNicName");
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setName("existingNicName");
    List<VdsNetworkInterface> existingNics = Collections.singletonList(existingNic);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Collections.singletonList(labeledNetwork), existingNics);
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), is(true));
}
#method_after
@Test
public void testNotRemovingLabeledNetworksWhenNicNameDoesNotReferenceExistingNicItsOkToRemove() throws Exception {
    Network labeledNetwork = new Network();
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel("label");
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName("noLongerExistingNicName");
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setName("existingNicName");
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Collections.singletonList(labeledNetwork));
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), isValid());
}
#end_block

#method_before
@Test
public void testNotRemovingLabeledNetworksWhenRemovingLabeledNetworkUnrelatedToRemovedBond() throws Exception {
    String nicName = "nicName";
    String label = "label";
    Network labeledNetwork = new Network();
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName(nicName);
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setLabels(Collections.singleton(label));
    existingNic.setName(nicName);
    List<VdsNetworkInterface> existingNics = Collections.singletonList(existingNic);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Collections.singletonList(labeledNetwork), existingNics);
    assertThat(validator.validateAndInitRemovedBondInterfaces(), is(true));
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), is(false));
}
#method_after
@Test
public void testNotRemovingLabeledNetworksWhenRemovingLabeledNetworkUnrelatedToRemovedBond() throws Exception {
    String nicName = "nicName";
    String label = "label";
    Network labeledNetwork = new Network();
    labeledNetwork.setName("networkName");
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName(nicName);
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setLabels(Collections.singleton(label));
    existingNic.setName(nicName);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(new HostSetupNetworksParameters(host.getId()), Collections.singletonList(existingNic), Collections.<NetworkAttachment>emptyList(), Collections.singletonList(labeledNetwork));
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), failsWith(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC_LIST, labeledNetwork.getName())));
}
#end_block

#method_before
@Test
public void testNotRemovingLabeledNetworksWhenLabelRelatedToRemovedBond() throws Exception {
    String label = "label";
    String nicName = "nicName";
    Network labeledNetwork = new Network();
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName(nicName);
    bond.setLabels(Collections.singleton(label));
    bond.setName(nicName);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(bond.getId()));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>singletonList(bond), null, new BusinessEntityMap<>(Collections.singletonList(labeledNetwork)), managementNetworkUtil, mockNetworkExclusivenessValidatorResolver);
    assertThat(validator.validateAndInitRemovedBondInterfaces(), is(true));
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), is(true));
}
#method_after
@Test
public void testNotRemovingLabeledNetworksWhenLabelRelatedToRemovedBond() throws Exception {
    String label = "label";
    String nicName = "nicName";
    Network labeledNetwork = new Network();
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName(nicName);
    bond.setLabels(Collections.singleton(label));
    bond.setName(nicName);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(bond.getId()));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.<VdsNetworkInterface>singletonList(bond), null, Collections.singletonList(labeledNetwork));
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), isValid());
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenNotRemovingAnyBond() throws Exception {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.<Guid>emptySet());
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), null, null, managementNetworkUtil, mockNetworkExclusivenessValidatorResolver);
    assertThat(validator.validateAndInitRemovedBondInterfaces(), is(true));
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), is(true));
}
#method_after
@Test
public void testValidRemovedBondsWhenNotRemovingAnyBond() throws Exception {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.<Guid>emptySet());
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, null);
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), isValid());
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenReferencedInterfaceIsNotBond() throws Exception {
    VdsNetworkInterface notABond = createNic("nicName");
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(notABond.getId()));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Collections.singletonList(notABond), null, null, managementNetworkUtil, mockNetworkExclusivenessValidatorResolver);
    assertThat(validator.validateAndInitRemovedBondInterfaces(), is(true));
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), is(false));
    assertThat(validator.containsViolation(VdcBllMessages.NETWORK_INTERFACE_IS_NOT_BOND), is(true));
}
#method_after
@Test
public void testValidRemovedBondsWhenReferencedInterfaceIsNotBond() throws Exception {
    VdsNetworkInterface notABond = createNic("nicName");
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(notABond.getId()));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.singletonList(notABond));
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), failsWith(EngineMessage.NETWORK_INTERFACE_IS_NOT_BOND, ReplacementUtils.createSetVariableString(HostInterfaceValidator.VAR_NETWORK_INTERFACE_IS_NOT_BOND_ENTITY, notABond.getName())));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenBondIsRequired() throws Exception {
    String nicName = "nicName";
    bond.setName(nicName);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(bond.getId()));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>singletonList(bond), null, null, managementNetworkUtil, mockNetworkExclusivenessValidatorResolver);
    NetworkAttachment requiredNetworkAttachment = new NetworkAttachment();
    requiredNetworkAttachment.setNicName(nicName);
    assertThat(validator.validateAndInitRemovedBondInterfaces(), is(true));
    assertThat(validator.validRemovedBonds(Collections.singletonList(requiredNetworkAttachment)), is(false));
    assertThat(validator.containsViolation(VdcBllMessages.BOND_USED_BY_NETWORK_ATTACHMENTS), is(true));
}
#method_after
@Test
public void testValidRemovedBondsWhenBondIsRequired() throws Exception {
    String nicName = "nicName";
    bond.setName(nicName);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(bond.getId()));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.<VdsNetworkInterface>singletonList(bond));
    NetworkAttachment requiredNetworkAttachment = new NetworkAttachment();
    requiredNetworkAttachment.setNicName(nicName);
    List<String> replacements = new ArrayList<>();
    replacements.add(ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_BOND_NAME, nicName));
    // null -- new network attachment with null id.
    replacements.addAll(replaceWith(HostSetupNetworksValidator.VAR_ATTACHMENT_IDS, Collections.<Guid>singletonList(null)));
    assertThat(validator.validRemovedBonds(Collections.singletonList(requiredNetworkAttachment)), failsWith(EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS, replacements));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenBondIsNotRequired() throws Exception {
    String nicName = "nicName";
    bond.setName(nicName);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(bond.getId()));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>singletonList(bond), null, null, managementNetworkUtil, mockNetworkExclusivenessValidatorResolver);
    assertThat(validator.validateAndInitRemovedBondInterfaces(), is(true));
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), is(true));
}
#method_after
@Test
public void testValidRemovedBondsWhenBondIsNotRequired() throws Exception {
    String nicName = "nicName";
    bond.setName(nicName);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(bond.getId()));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.<VdsNetworkInterface>singletonList(bond));
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), isValid());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testGetAttachmentsToConfigureWhenNoChangesWereSent() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, new HostSetupNetworksParameters(host.getId()), Collections.<VdsNetworkInterface>emptyList(), Arrays.asList(networkAttachmentA, networkAttachmentB), null, managementNetworkUtil, mockNetworkExclusivenessValidatorResolver);
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(2));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(true));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testGetAttachmentsToConfigureWhenNoChangesWereSent() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setHost(host).setParams(new HostSetupNetworksParameters(host.getId())).setExistingAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB)).build();
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(2));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(true));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#end_block

#method_before
@Test
public void testGetAttachmentsToConfigureWhenUpdatingNetworkAttachments() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), Arrays.asList(networkAttachmentA, networkAttachmentB), null, managementNetworkUtil, mockNetworkExclusivenessValidatorResolver);
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(2));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(true));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#method_after
@Test
public void testGetAttachmentsToConfigureWhenUpdatingNetworkAttachments() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).setExistingAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB)).build();
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(2));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(true));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#end_block

#method_before
@Test
public void testGetAttachmentsToConfigureWhenRemovingNetworkAttachments() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachmentB));
    params.setRemovedNetworkAttachments(Collections.singleton(networkAttachmentA.getId()));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), Arrays.asList(networkAttachmentA, networkAttachmentB), null, managementNetworkUtil, mockNetworkExclusivenessValidatorResolver);
    assertThat(validator.validateAndInitRemovedNetworkAttachments(), is(true));
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(1));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(false));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#method_after
@Test
public void testGetAttachmentsToConfigureWhenRemovingNetworkAttachments() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachmentB));
    params.setRemovedNetworkAttachments(Collections.singleton(networkAttachmentA.getId()));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.<VdsNetworkInterface>emptyList(), Arrays.asList(networkAttachmentA, networkAttachmentB), null);
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(1));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(false));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#end_block

#method_before
@Test
public void testGetAttachmentsToConfigureWhenAddingNewNetworkAttachments() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA, null);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB, null);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), Collections.<NetworkAttachment>emptyList(), null, managementNetworkUtil, mockNetworkExclusivenessValidatorResolver);
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(2));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(true));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#method_after
@Test
public void testGetAttachmentsToConfigureWhenAddingNewNetworkAttachments() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA, (Guid) null);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB, (Guid) null);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.<VdsNetworkInterface>emptyList(), Collections.<NetworkAttachment>emptyList(), null);
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(2));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(true));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#end_block

#method_before
private NetworkAttachment createNetworkAttachment(Network networkA, Guid id) {
    NetworkAttachment networkAttachmentA = new NetworkAttachment();
    networkAttachmentA.setId(id);
    networkAttachmentA.setNetworkId(networkA.getId());
    return networkAttachmentA;
}
#method_after
private NetworkAttachment createNetworkAttachment(Network networkA, VdsNetworkInterface nic) {
    NetworkAttachment attachment = createNetworkAttachment(networkA, Guid.newGuid());
    attachment.setNicId(nic.getId());
    attachment.setNicName(nic.getName());
    return attachment;
}
#end_block

#method_before
private NetworkAttachment createNetworkAttachment(Network networkA) {
    return createNetworkAttachment(networkA, Guid.newGuid());
}
#method_after
private NetworkAttachment createNetworkAttachment(Network network) {
    return createNetworkAttachment(network, Guid.newGuid());
}
#end_block

#method_before
private NetworkAttachment createNetworkAttachment(Network networkA, Guid id) {
    NetworkAttachment networkAttachmentA = new NetworkAttachment();
    networkAttachmentA.setId(id);
    networkAttachmentA.setNetworkId(networkA.getId());
    return networkAttachmentA;
}
#method_after
private NetworkAttachment createNetworkAttachment(Network network, Guid id) {
    NetworkAttachment networkAttachment = new NetworkAttachment();
    networkAttachment.setId(id);
    networkAttachment.setNetworkId(network.getId());
    networkAttachment.setNetworkName(network.getName());
    return networkAttachment;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenUsedByVms() throws Exception {
    String nameOfNetworkA = "networkA";
    String nameOfNetworkB = "networkB";
    Network networkA = createNetworkWithName(nameOfNetworkA);
    Network networkB = createNetworkWithName(nameOfNetworkB);
    VdsNetworkInterface nicA = createNic("nicA");
    VdsNetworkInterface nicB = createNic("nicB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    networkAttachmentA.setNicId(nicA.getId());
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    networkAttachmentB.setNicId(nicB.getId());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedNetworkAttachments(new HashSet<>(Arrays.asList(networkAttachmentA.getId(), networkAttachmentB.getId())));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidator(host, params, Arrays.asList(nicA, nicB), Arrays.asList(networkAttachmentA, networkAttachmentB), new BusinessEntityMap<>(Arrays.asList(networkA, networkB)), managementNetworkUtil, mockNetworkExclusivenessValidatorResolver));
    VmInterfaceManager vmInterfaceManagerMock = mock(VmInterfaceManager.class);
    doReturn(vmInterfaceManagerMock).when(validator).getVmInterfaceManager();
    when(vmInterfaceManagerMock.findActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(Arrays.asList(nameOfNetworkA, nameOfNetworkB));
    assertThat(validator.validateAndInitRemovedNetworkAttachments(), is(true));
    assertThat(validator.validateNotRemovingUsedNetworkByVms(), is(false));
    assertThat(validator.containsViolation(VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS), is(true));
    ArgumentCaptor<Collection> collectionArgumentCaptor = ArgumentCaptor.forClass(Collection.class);
    verify(vmInterfaceManagerMock).findActiveVmsUsingNetworks(eq(host.getId()), collectionArgumentCaptor.capture());
    assertThat(collectionArgumentCaptor.getValue().size(), is(2));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkA), is(true));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkB), is(true));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenUsedByVms() throws Exception {
    String nameOfNetworkA = "networkA";
    String nameOfNetworkB = "networkB";
    Network networkA = createNetworkWithName(nameOfNetworkA);
    Network networkB = createNetworkWithName(nameOfNetworkB);
    VdsNetworkInterface nicA = createNic("nicA");
    VdsNetworkInterface nicB = createNic("nicB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    networkAttachmentA.setNicId(nicA.getId());
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    networkAttachmentB.setNicId(nicB.getId());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedNetworkAttachments(new HashSet<>(Arrays.asList(networkAttachmentA.getId(), networkAttachmentB.getId())));
    HostSetupNetworksValidator validator = spy(createHostSetupNetworksValidator(params, Arrays.asList(nicA, nicB), Arrays.asList(networkAttachmentA, networkAttachmentB), Arrays.asList(networkA, networkB)));
    VmInterfaceManager vmInterfaceManagerMock = mock(VmInterfaceManager.class);
    doReturn(vmInterfaceManagerMock).when(validator).getVmInterfaceManager();
    List<String> vmNames = Arrays.asList("vmName1", "vmName2");
    when(vmInterfaceManagerMock.findActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(vmNames);
    final List<String> errorNetworkNames = Arrays.asList(nameOfNetworkA, nameOfNetworkB);
    assertThat(validator.validateNotRemovingUsedNetworkByVms(), failsWith(EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, concat(replaceWith(VAR_NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS_LIST, vmNames), replaceWith(VAR_NETWORK_NAMES, errorNetworkNames))));
    ArgumentCaptor<Collection> collectionArgumentCaptor = ArgumentCaptor.forClass(Collection.class);
    verify(vmInterfaceManagerMock).findActiveVmsUsingNetworks(eq(host.getId()), collectionArgumentCaptor.capture());
    assertThat(collectionArgumentCaptor.getValue().size(), is(2));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkA), is(true));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkB), is(true));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenNotUsedByVms() throws Exception {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), null, new BusinessEntityMap<>(Collections.<Network>emptyList()), managementNetworkUtil, mockNetworkExclusivenessValidatorResolver));
    VmInterfaceManager vmInterfaceManagerMock = mock(VmInterfaceManager.class);
    doReturn(vmInterfaceManagerMock).when(validator).getVmInterfaceManager();
    when(vmInterfaceManagerMock.findActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(Collections.<String>emptyList());
    assertThat(validator.validateAndInitRemovedNetworkAttachments(), is(true));
    assertThat(validator.validateNotRemovingUsedNetworkByVms(), is(true));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenNotUsedByVms() throws Exception {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    HostSetupNetworksValidator validator = spy(createHostSetupNetworksValidator(params, Collections.<VdsNetworkInterface>emptyList(), null, Collections.<Network>emptyList()));
    VmInterfaceManager vmInterfaceManagerMock = mock(VmInterfaceManager.class);
    doReturn(vmInterfaceManagerMock).when(validator).getVmInterfaceManager();
    when(vmInterfaceManagerMock.findActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(Collections.<String>emptyList());
    assertThat(validator.validateNotRemovingUsedNetworkByVms(), isValid());
}
#end_block

#method_before
@Test
public void testNetworksUniquelyConfiguredOnHostWhenUniquelyConfigured() throws Exception {
    Network networkA = new Network();
    networkA.setId(Guid.newGuid());
    Network networkB = new Network();
    networkB.setId(Guid.newGuid());
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), null, new BusinessEntityMap<>(Arrays.asList(networkA, networkB)), managementNetworkUtil, mockNetworkExclusivenessValidatorResolver);
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachmentA, networkAttachmentB)), is(true));
}
#method_after
@Test
public void testNetworksUniquelyConfiguredOnHostWhenUniquelyConfigured() throws Exception {
    Network networkA = new Network();
    networkA.setId(Guid.newGuid());
    Network networkB = new Network();
    networkB.setId(Guid.newGuid());
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Arrays.asList(networkA, networkB));
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachmentA, networkAttachmentB)), isValid());
}
#end_block

#method_before
@Test
public void testNetworksUniquelyConfiguredOnHostWhenNotUniquelyConfigured() throws Exception {
    Guid id = Guid.newGuid();
    Network networkA = new Network();
    networkA.setId(id);
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentReferencingSameNetwork = createNetworkAttachment(networkA);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), null, new BusinessEntityMap<>(Collections.singletonList(networkA)), managementNetworkUtil, mockNetworkExclusivenessValidatorResolver);
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachment, networkAttachmentReferencingSameNetwork)), is(false));
    assertThat(validator.containsViolation(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES), is(true));
}
#method_after
@Test
public void testNetworksUniquelyConfiguredOnHostWhenNotUniquelyConfigured() throws Exception {
    Guid id = Guid.newGuid();
    String networkName = "networkName";
    Network networkA = new Network();
    networkA.setName(networkName);
    networkA.setId(id);
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentReferencingSameNetwork = createNetworkAttachment(networkA);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Collections.singletonList(networkA));
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachment, networkAttachmentReferencingSameNetwork)), failsWith(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORKS_ALREADY_ATTACHED_TO_IFACES_LIST, networkName)));
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenReferencingExistingNonBondInterface() throws Exception {
    Bond bond = new Bond();
    bond.setName("bond0");
    doTestValidModifiedBonds(bond, ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_IS_NOT_BOND), VdcBllMessages.NETWORK_INTERFACE_IS_NOT_BOND, false, false);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenReferencingExistingNonBondInterface() throws Exception {
    Bond bond = createBond();
    ValidationResult notABondValidationResult = new ValidationResult(EngineMessage.NETWORK_INTERFACE_IS_NOT_BOND, HostInterfaceValidator.VAR_NETWORK_INTERFACE_IS_NOT_BOND_ENTITY, bond.getName());
    doTestValidModifiedBonds(bond, ValidationResult.VALID, notABondValidationResult, notABondValidationResult, ValidationResult.VALID);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenInsufficientNumberOfSlaves() throws Exception {
    Bond bond = new Bond();
    bond.setName("bond0");
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, VdcBllMessages.NETWORK_BONDS_INVALID_SLAVE_COUNT, false, false);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenInsufficientNumberOfSlaves() throws Exception {
    Bond bond = createBond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_BONDS_INVALID_SLAVE_COUNT_LIST, bond.getName())), ValidationResult.VALID);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenSlavesValidationFails() throws Exception {
    Bond bond = new Bond();
    bond.setName("bond0");
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, null, false, false);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenSlavesValidationFails() throws Exception {
    ValidationResult slavesValidationResult = new ValidationResult(EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE, ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE_ENTITY, "slaveA"), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, "networkName"));
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, /*this mocks validateModifiedBondSlaves to just verify, that caller method will behave ok, when
            validateModifiedBondSlaves return invalid result*/
    slavesValidationResult, slavesValidationResult);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsWhenAllOk() throws Exception {
    Bond bond = new Bond();
    bond.setName("bond0");
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, null, true, true);
}
#method_after
@Test
public void testValidModifiedBondsWhenAllOk() throws Exception {
    Bond bond = new Bond("bond1");
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID);
}
#end_block

#method_before
private void doTestValidModifiedBonds(Bond bond, ValidationResult interfaceByNameExistValidationResult, ValidationResult interfaceIsBondValidationResult, VdcBllMessages expectedViolation, boolean expectedValidationResult, boolean slavesValidationOk) {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), null, new BusinessEntityMap<>(Collections.<Network>emptyList()), managementNetworkUtil, mockNetworkExclusivenessValidatorResolver));
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceByNameExists()).thenReturn(interfaceByNameExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceIsBond()).thenReturn(interfaceIsBondValidationResult);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    doReturn(slavesValidationOk).when(validator).validateModifiedBondSlaves(any(Bond.class));
    assertThat(validator.validNewOrModifiedBonds(), is(expectedValidationResult));
    if (expectedViolation != null) {
        assertThat(validator.containsViolation(expectedViolation), is(true));
    }
    verify(hostInterfaceValidatorMock).interfaceByNameExists();
    // assert only if previous call was successful, otherwise this method was not called.
    if (interfaceByNameExistValidationResult.isValid()) {
        verify(hostInterfaceValidatorMock).interfaceIsBond();
    }
}
#method_after
private void doTestValidModifiedBonds(Bond bond, ValidationResult interfaceByNameExistValidationResult, ValidationResult interfaceIsBondValidationResult, ValidationResult expectedValidationResult, ValidationResult slavesValidationValidationResult) {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    HostSetupNetworksValidator validator = spy(createHostSetupNetworksValidator(params, null, null, null));
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceByNameExists()).thenReturn(interfaceByNameExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(interfaceIsBondValidationResult);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    doReturn(slavesValidationValidationResult).when(validator).validateModifiedBondSlaves(any(Bond.class));
    if (expectedValidationResult.isValid()) {
        assertThat(validator.validNewOrModifiedBonds(), isValid());
    } else {
        assertThat(validator.validNewOrModifiedBonds(), failsWith(expectedValidationResult.getMessage(), expectedValidationResult.getVariableReplacements()));
    }
    verify(hostInterfaceValidatorMock).interfaceByNameExists();
    // assert only if previous call was successful, otherwise this method was not called.
    if (interfaceByNameExistValidationResult.isValid()) {
        verify(hostInterfaceValidatorMock).interfaceIsBondOrNull();
    }
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveInterfaceDoesNotExist() throws Exception {
    Bond bond = new Bond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidateModifiedBondSlaves(bond, Collections.<VdsNetworkInterface>emptyList(), new BusinessEntityMap<>(Collections.<Network>emptyList()), new ValidationResult(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST), ValidationResult.VALID, false, VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST);
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveInterfaceDoesNotExist() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, null, Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST), ValidationResult.VALID, new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST));
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveIsNotValid() throws Exception {
    Bond bond = new Bond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidateModifiedBondSlaves(bond, Collections.<VdsNetworkInterface>emptyList(), new BusinessEntityMap<>(Collections.<Network>emptyList()), ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE), false, VdcBllMessages.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE);
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveIsNotValid() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    ValidationResult cannotBeSlaveValidationResult = new ValidationResult(EngineMessage.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE, HostInterfaceValidator.VAR_INTERFACE_NAME, bond.getName());
    doTestValidateModifiedBondSlaves(params, null, Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), ValidationResult.VALID, cannotBeSlaveValidationResult, cannotBeSlaveValidationResult);
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBond() throws Exception {
    Bond bond = createBond("bondName");
    Bond differentBond = createBond("differentBond");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    doTestValidateModifiedBondSlaves(bond, Arrays.asList(bond, differentBond, slaveA, slaveB), new BusinessEntityMap<>(Collections.<Network>emptyList()), ValidationResult.VALID, ValidationResult.VALID, false, VdcBllMessages.NETWORK_INTERFACE_ALREADY_IN_BOND);
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBond() throws Exception {
    Bond bond = createBond("bond1");
    Bond differentBond = createBond("bond2");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, Arrays.asList(bond, differentBond, slaveA, slaveB), Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_INTERFACE_ALREADY_IN_BOND, ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_INTERFACE_ALREADY_IN_BOND_ENTITY, slaveB.getName())));
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBondWhichGetsRemoved() throws Exception {
    Bond bond = createBond("bondName");
    Bond differentBond = createBond("differentBond");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(differentBond.getId()));
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    doTestValidateModifiedBondSlaves(bond, params, new BusinessEntityMap<>(Collections.<Network>emptyList()), Arrays.asList(bond, differentBond, slaveA, slaveB), Collections.<NetworkAttachment>emptyList(), ValidationResult.VALID, ValidationResult.VALID, true, null);
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBondWhichGetsRemoved() throws Exception {
    Bond bond = createBond("bondName");
    Bond differentBond = createBond("differentBond");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(differentBond.getId()));
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    doTestValidateModifiedBondSlaves(params, Arrays.asList(bond, differentBond, slaveA, slaveB), Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID);
}
#end_block

#method_before
public Bond createBond(String bondName) {
    Bond bond = new Bond();
    bond.setName(bondName);
    bond.setId(Guid.newGuid());
    return bond;
}
#method_after
private Bond createBond() {
    return createBond("bond1");
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsNotRemovedAsAPartOfRequest() throws Exception {
    Bond bond = createBond("bondName");
    Network assignedNetwork = new Network();
    assignedNetwork.setName("assignedNetwork");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName(assignedNetwork.getName());
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    doTestValidateModifiedBondSlaves(bond, Arrays.asList(bond, slaveA, slaveB), new BusinessEntityMap<>(Collections.singletonList(assignedNetwork)), ValidationResult.VALID, ValidationResult.VALID, false, VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE);
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsNotRemovedAsAPartOfRequest() throws Exception {
    Bond bond = createBond();
    Network networkBeingRemoved = new Network();
    networkBeingRemoved.setName("assignedNetwork");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName("assignedNetwork");
    NetworkAttachment attachmentOfNetworkToSlaveA = createNetworkAttachment(networkBeingRemoved, slaveA);
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, Arrays.asList(bond, slaveA, slaveB), Collections.singletonList(attachmentOfNetworkToSlaveA), Collections.singletonList(networkBeingRemoved), ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE, ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE_ENTITY, slaveA.getName()), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, networkBeingRemoved.getName())));
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsRemovedAsAPartOfRequest() throws Exception {
    Bond bond = createBond("bondName");
    Network networkBeingRemoved = new Network();
    networkBeingRemoved.setName("assignedNetwork");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName(networkBeingRemoved.getName());
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    NetworkAttachment removedNetworkAttachment = new NetworkAttachment();
    removedNetworkAttachment.setId(Guid.newGuid());
    removedNetworkAttachment.setNicName(slaveA.getName());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedNetworkAttachments(Collections.singleton(removedNetworkAttachment.getId()));
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    doTestValidateModifiedBondSlaves(bond, params, new BusinessEntityMap<>(Collections.singletonList(networkBeingRemoved)), Arrays.asList(bond, slaveA, slaveB), Collections.singletonList(removedNetworkAttachment), ValidationResult.VALID, ValidationResult.VALID, true, null);
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsRemovedAsAPartOfRequest() throws Exception {
    Bond bond = createBond();
    Network networkBeingRemoved = new Network();
    networkBeingRemoved.setName("assignedNetwork");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName(networkBeingRemoved.getName());
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    NetworkAttachment removedNetworkAttachment = new NetworkAttachment();
    removedNetworkAttachment.setId(Guid.newGuid());
    removedNetworkAttachment.setNicName(slaveA.getName());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedNetworkAttachments(Collections.singleton(removedNetworkAttachment.getId()));
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    doTestValidateModifiedBondSlaves(params, Arrays.asList(bond, slaveA, slaveB), Collections.singletonList(removedNetworkAttachment), Collections.singletonList(networkBeingRemoved), ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID);
}
#end_block

#method_before
private void doTestValidateModifiedBondSlaves(Bond bond, HostSetupNetworksParameters params, BusinessEntityMap<Network> networkBusinessEntityMap, List<VdsNetworkInterface> existingInterfaces, List<NetworkAttachment> existingAttachments, ValidationResult interfaceExistValidationResult, ValidationResult interfaceIsValidSlaveValidationResult, boolean expectedValidationResult, VdcBllMessages expectedViolation) {
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidator(host, params, existingInterfaces, existingAttachments, networkBusinessEntityMap, managementNetworkUtil, mockNetworkExclusivenessValidatorResolver));
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceExists()).thenReturn(interfaceExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceIsValidSlave()).thenReturn(interfaceIsValidSlaveValidationResult);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    assertThat(validator.validateAndInitRemovedBondInterfaces(), is(true));
    assertThat(validator.validateAndInitRemovedNetworkAttachments(), is(true));
    assertThat(validator.validateModifiedBondSlaves(bond), is(expectedValidationResult));
    if (expectedViolation != null) {
        assertThat(validator.containsViolation(expectedViolation), is(true));
    }
}
#method_after
private void doTestValidateModifiedBondSlaves(HostSetupNetworksParameters params, List<VdsNetworkInterface> existingInterfaces, List<NetworkAttachment> existingAttachments, Collection<Network> networks, ValidationResult interfaceExistValidationResult, ValidationResult interfaceIsValidSlaveValidationResult, ValidationResult expectedValidationResult) {
    HostSetupNetworksValidator validator = spy(createHostSetupNetworksValidator(params, existingInterfaces, existingAttachments, networks));
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceExists()).thenReturn(interfaceExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceByNameExists()).thenReturn(interfaceExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceIsValidSlave()).thenReturn(interfaceIsValidSlaveValidationResult);
    // TODO MM: test for this.
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(ValidationResult.VALID);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    if (expectedValidationResult.isValid()) {
        assertThat(validator.validNewOrModifiedBonds(), isValid());
    } else {
        assertThat(validator.validNewOrModifiedBonds(), failsWith(expectedValidationResult.getMessage(), expectedValidationResult.getVariableReplacements()));
    }
}
#end_block

#method_before
@Test
public void testValidateCustomPropertiesWhenAttachmentDoesNotHaveCustomProperties() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    networkAttachmentA.setProperties(null);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    networkAttachmentB.setProperties(new HashMap<String, String>());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachmentA));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), null, new BusinessEntityMap<>(Arrays.asList(networkA, networkB)), managementNetworkUtil, mockNetworkExclusivenessValidatorResolver);
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), is(true));
}
#method_after
@Test
public void testValidateCustomPropertiesWhenAttachmentDoesNotHaveCustomProperties() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    networkAttachmentA.setProperties(null);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    networkAttachmentB.setProperties(new HashMap<String, String>());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Arrays.asList(networkA, networkB), params);
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), isValid());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateCustomPropertiesWhenCustomPropertiesFeatureIsNotSupported() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    VDS host = new VDS();
    host.setVdsGroupCompatibilityVersion(Version.v3_4);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), null, new BusinessEntityMap<>(Collections.singletonList(networkA)), managementNetworkUtil, mockNetworkExclusivenessValidatorResolver));
    doReturn(Collections.emptyList()).when(validator).translateErrorMessages(any(List.class));
    SimpleCustomPropertiesUtil simpleCustomPropertiesUtil = spy(SimpleCustomPropertiesUtil.getInstance());
    doReturn(Collections.emptyList()).when(simpleCustomPropertiesUtil).validateProperties(any(Map.class), any(Map.class));
    assertThat(validator.validateCustomProperties(simpleCustomPropertiesUtil, Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), is(false));
    assertThat(validator.containsViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED), is(true));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testValidateCustomPropertiesWhenCustomPropertiesFeatureIsNotSupported() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    VDS host = new VDS();
    host.setVdsGroupCompatibilityVersion(Version.v3_4);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).addNetworks(networkA).build());
    assertThat(validator.validateCustomProperties(null, Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), failsWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED_LIST, networkA.getName())));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateCustomPropertiesWhenCustomPropertyValidationFailed() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), null, new BusinessEntityMap<>(Collections.singletonList(networkA)), managementNetworkUtil, mockNetworkExclusivenessValidatorResolver));
    doReturn(Collections.emptyList()).when(validator).translateErrorMessages(any(List.class));
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), is(false));
    assertThat(validator.containsViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT), is(true));
}
#method_after
@Test
public void testValidateCustomPropertiesWhenCustomPropertyValidationFailed() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).addNetworks(networkA).build());
    // this was added just because of DI issues with 'Backend.getInstance().getErrorsTranslator()' is 'spyed' method
    // noinspection unchecked
    doReturn(Collections.emptyList()).when(validator).translateErrorMessages(any(List.class));
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), failsWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT_LIST, networkA.getName())));
}
#end_block

#method_before
private VdsNetworkInterface createBondSlave(Bond bond, String slaveName) {
    VdsNetworkInterface slave = new VdsNetworkInterface();
    slave.setId(Guid.newGuid());
    slave.setName(slaveName);
    slave.setBondName(bond.getName());
    slave.setBonded(true);
    return slave;
}
#method_after
private VdsNetworkInterface createBondSlave(Bond bond, String slaveName) {
    VdsNetworkInterface slave = new VdsNetworkInterface();
    slave.setId(Guid.newGuid());
    slave.setName(slaveName);
    slave.setBondName(bond.getName());
    slave.setBonded(false);
    return slave;
}
#end_block

#method_before
private HostSetupNetworksValidator createHostSetupNetworksValidator(List<Network> networks, List<VdsNetworkInterface> existingInterfaces) {
    return new HostSetupNetworksValidator(host, new HostSetupNetworksParameters(host.getId()), existingInterfaces, null, new BusinessEntityMap<>(networks), managementNetworkUtil, mockNetworkExclusivenessValidatorResolver);
}
#method_after
private HostSetupNetworksValidator createHostSetupNetworksValidator(List<Network> networks) {
    return createHostSetupNetworksValidator(networks, new HostSetupNetworksParameters(host.getId()));
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__SETUP);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__NETWORKS);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__SETUP);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__NETWORKS);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDS vds = getVds();
    if (vds == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
        return false;
    }
    if (!(SUPPORTED_HOST_STATUSES.contains(vds.getStatus()) || (vds.getStatus() == VDSStatus.Installing && isInternalExecution()))) {
        addCanDoActionMessage(VdcBllMessages.VAR__HOST_STATUS__UP_MAINTENANCE_OR_NON_OPERATIONAL);
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL);
        return false;
    }
    helper = new SetupNetworksHelper(getParameters(), vds, managementNetworkUtil, networkExclusivenessValidatorResolver);
    List<String> validationMessages = helper.validate();
    if (!validationMessages.isEmpty()) {
        for (String msg : validationMessages) {
            addCanDoActionMessage(msg);
        }
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VDS vds = getVds();
    if (vds == null) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
        return false;
    }
    if (!(SUPPORTED_HOST_STATUSES.contains(vds.getStatus()) || (vds.getStatus() == VDSStatus.Installing && isInternalExecution()))) {
        addCanDoActionMessage(EngineMessage.VAR__HOST_STATUS__UP_MAINTENANCE_OR_NON_OPERATIONAL);
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL);
        return false;
    }
    helper = new SetupNetworksHelper(getParameters(), vds, managementNetworkUtil, networkExclusivenessValidatorResolver);
    List<String> validationMessages = helper.validate();
    if (!validationMessages.isEmpty()) {
        for (String msg : validationMessages) {
            addCanDoActionMessage(msg);
        }
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        if (!getModifiedInterfaces().isEmpty()) {
            updateModifiedInterfaces();
        }
        log.info("No changes were detected in setup networks for host '{}' (ID '{}')", getVdsName(), getVdsId());
        if (isInternalExecution()) {
            setActionReturnValue(SETUP_NETWORKS_RESOLUTION.NO_CHANGES_DETECTED);
        }
        setSucceeded(true);
        return;
    }
    T bckndCmdParams = getParameters();
    final SetupNetworksVdsCommandParameters vdsCmdParams = new SetupNetworksVdsCommandParameters(getVds(), getNetworks(), getRemovedNetworks(), getBonds(), getRemovedBonds().keySet(), getInterfaces());
    vdsCmdParams.setForce(bckndCmdParams.isForce());
    vdsCmdParams.setCheckConnectivity(bckndCmdParams.isCheckConnectivity());
    int timeout = bckndCmdParams.getConectivityTimeout() != null ? bckndCmdParams.getConectivityTimeout() : Config.<Integer>getValue(ConfigValues.NetworkConnectivityCheckTimeoutInSeconds);
    vdsCmdParams.setConectivityTimeout(timeout);
    FutureVDSCall<VDSReturnValue> setupNetworksTask = createFutureTask(vdsCmdParams);
    if (bckndCmdParams.isCheckConnectivity()) {
        pollInterruptively(setupNetworksTask);
    }
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().isCheckConnectivity()) {
                throw new VdcBLLException(VdcBllErrors.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                try (EngineLock monitoringLock = acquireMonitorLock()) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Setup networks command timed out for {} seconds", timeout);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        if (!getModifiedInterfaces().isEmpty()) {
            updateModifiedInterfaces();
        }
        log.info("No changes were detected in setup networks for host '{}' (ID '{}')", getVdsName(), getVdsId());
        if (isInternalExecution()) {
            setActionReturnValue(SETUP_NETWORKS_RESOLUTION.NO_CHANGES_DETECTED);
        }
        setSucceeded(true);
        return;
    }
    T bckndCmdParams = getParameters();
    final SetupNetworksVdsCommandParameters vdsCmdParams = new SetupNetworksVdsCommandParameters(getVds(), getNetworks(), getRemovedNetworks(), getBonds(), getRemovedBonds().keySet(), getInterfaces());
    vdsCmdParams.setForce(bckndCmdParams.isForce());
    vdsCmdParams.setCheckConnectivity(bckndCmdParams.isCheckConnectivity());
    int timeout = bckndCmdParams.getConectivityTimeout() != null ? bckndCmdParams.getConectivityTimeout() : Config.<Integer>getValue(ConfigValues.NetworkConnectivityCheckTimeoutInSeconds);
    vdsCmdParams.setConectivityTimeout(timeout);
    FutureVDSCall<VDSReturnValue> setupNetworksTask = createFutureTask(vdsCmdParams);
    if (bckndCmdParams.isCheckConnectivity()) {
        pollInterruptively(setupNetworksTask);
    }
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().isCheckConnectivity()) {
                throw new EngineException(EngineError.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                try (EngineLock monitoringLock = acquireMonitorLock()) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Setup networks command timed out for {} seconds", timeout);
    }
}
#end_block

#method_before
private void setSupportedFeatures() {
    networkCustomPropertiesSupported = FeatureSupported.networkCustomProperties(host.getVdsGroupCompatibilityVersion());
}
#method_after
private void setSupportedFeatures() {
    Version clusterCompatibilityVersion = host.getVdsGroupCompatibilityVersion();
    networkCustomPropertiesSupported = FeatureSupported.networkCustomProperties(clusterCompatibilityVersion);
    hostNetworkQosSupported = FeatureSupported.hostNetworkQos(clusterCompatibilityVersion);
}
#end_block

#method_before
public FailingValidationResults<String> validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    if (validateAndInitRemovedBondInterfaces() && validateAndInitRemovedNetworkAttachments() && validNewOrModifiedNetworkAttachments() && validRemovedNetworkAttachments() && validNewOrModifiedBonds() && validRemovedBonds(attachmentsToConfigure) && validateNotRemovingUsedNetworkByVms()) {
        boolean valid = networksUniquelyConfiguredOnHost(attachmentsToConfigure) && !violations.addViolation(validateNetworkExclusiveOnNics(attachmentsToConfigure)) && !violations.addViolations(new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure)) && validateCustomProperties();
    // TODO: Cover qos change not supported and network sync. see SetupNetworkHelper.validateNetworkQos()
    // Violation - VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED
    // Violation - VdcBllMessages.NETWORKS_NOT_IN_SYNC
    }
    return violations;
}
#method_after
public ValidationResult validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    ValidationResult vr = ValidationResult.VALID;
    vr = skipValidation(vr) ? vr : new NicLabelValidator(params, existingInterfacesMap, bondsMap, hostSetupNetworksValidatorHelper).validate();
    vr = skipValidation(vr) ? vr : validNewOrModifiedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validRemovedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validNewOrModifiedBonds();
    vr = skipValidation(vr) ? vr : validRemovedBonds(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : attachmentsDontReferenceSameNetworkDuplicately(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : networksUniquelyConfiguredOnHost(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateNetworkExclusiveOnNics(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateCustomProperties();
    vr = skipValidation(vr) ? vr : validateQos(attachmentsToConfigure);
    return vr;
}
#end_block

#method_before
private ValidationResult validateNetworkExclusiveOnNics(Collection<NetworkAttachment> attachmentsToConfigure) {
    return new NetworkAttachmentsValidator(attachmentsToConfigure, networkBusinessEntityMap, networkExclusivenessValidator).validateNetworkExclusiveOnNics();
}
#method_after
private ValidationResult validateNetworkExclusiveOnNics(Collection<NetworkAttachment> attachmentsToConfigure) {
    NetworkAttachmentsValidator validator = new NetworkAttachmentsValidator(attachmentsToConfigure, networkBusinessEntityMap, networkExclusivenessValidator);
    return validator.validateNetworkExclusiveOnNics();
}
#end_block

#method_before
boolean networksUniquelyConfiguredOnHost(Collection<NetworkAttachment> attachmentsToConfigure) {
    boolean passed = true;
    Set<Guid> usedNetworkIds = new HashSet<>(attachmentsToConfigure.size());
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        boolean alreadyUsedNetworkId = usedNetworkIds.contains(attachment.getNetworkId());
        if (alreadyUsedNetworkId) {
            Network network = networkBusinessEntityMap.get(attachment.getNetworkId());
            violations.addViolation(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES, network.getName());
            passed = false;
        } else {
            usedNetworkIds.add(attachment.getNetworkId());
        }
    }
    return passed;
}
#method_after
ValidationResult networksUniquelyConfiguredOnHost(Collection<NetworkAttachment> attachmentsToConfigure) {
    Set<Guid> usedNetworkIds = new HashSet<>(attachmentsToConfigure.size());
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        boolean alreadyUsedNetworkId = usedNetworkIds.contains(attachment.getNetworkId());
        if (alreadyUsedNetworkId) {
            Network network = existingNetworkRelatedToAttachment(attachment);
            return new ValidationResult(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, ReplacementUtils.createSetVariableString(VAR_NETWORKS_ALREADY_ATTACHED_TO_IFACES_LIST, network.getName()));
        } else {
            usedNetworkIds.add(attachment.getNetworkId());
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
boolean validateNotRemovingUsedNetworkByVms() {
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : removedNetworkAttachments) {
        removedNetworks.add(networkBusinessEntityMap.get(removedAttachment.getNetworkId()).getName());
    }
    List<String> vmNames = getVmInterfaceManager().findActiveVmsUsingNetworks(host.getId(), removedNetworks);
    for (String vmName : vmNames) {
        violations.addViolation(VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, vmName);
    }
    return vmNames.isEmpty();
}
#method_after
ValidationResult validateNotRemovingUsedNetworkByVms() {
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : removedNetworkAttachments) {
        removedNetworks.add(existingNetworkRelatedToAttachment(removedAttachment).getName());
    }
    final List<String> vmNames = getVmInterfaceManager().findActiveVmsUsingNetworks(host.getId(), removedNetworks);
    if (vmNames.isEmpty()) {
        return ValidationResult.VALID;
    } else {
        final List<String> sortedRemovedNetsworks = new ArrayList<>(removedNetworks);
        Collections.sort(sortedRemovedNetsworks);
        return new ValidationResult(EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, LinqUtils.concat(ReplacementUtils.replaceWith(VAR_NETWORK_NAMES, sortedRemovedNetsworks), ReplacementUtils.replaceWith(VAR_NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS_LIST, vmNames)));
    }
}
#end_block

#method_before
boolean validRemovedBonds(Collection<NetworkAttachment> attachmentsToConfigure) {
    Set<String> requiredInterfaceNames = getNetworkAttachmentInterfaceNames(attachmentsToConfigure);
    boolean passed = true;
    for (VdsNetworkInterface removedBond : removedBondVdsNetworkInterface) {
        String bondName = removedBond.getName();
        if (bondName == null) {
            violations.addViolation(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST, null);
            passed = false;
            continue;
        }
        VdsNetworkInterface existingBond = existingInterfacesMap.get(bondName);
        if (violations.addViolation(createHostInterfaceValidator(existingBond).interfaceIsBond(), bondName)) {
            passed = false;
            continue;
        }
        boolean cantRemoveRequiredInterface = requiredInterfaceNames.contains(bondName);
        if (cantRemoveRequiredInterface) {
            violations.addViolation(VdcBllMessages.BOND_USED_BY_NETWORK_ATTACHMENTS, bondName);
            passed = false;
            continue;
        }
    }
    return passed;
}
#method_after
ValidationResult validRemovedBonds(Collection<NetworkAttachment> attachmentsToConfigure) {
    List<Guid> invalidBondIds = Entities.idsNotReferencingExistingRecords(params.getRemovedBonds(), existingInterfacesMap.unmodifiableEntitiesByIdMap());
    if (!invalidBondIds.isEmpty()) {
        return new ValidationResult(EngineMessage.NETWORK_BOND_RECORD_DOES_NOT_EXISTS, ReplacementUtils.replaceWith(VAR_NETWORK_BOND_RECORD_DOES_NOT_EXISTS_LIST, invalidBondIds));
    }
    Map<String, List<Guid>> nicNameToAttachedNetworkAttachmentIds = getIdsOfNetworkAttachmentsRelatedToInterfaceNames(attachmentsToConfigure);
    for (VdsNetworkInterface removedBond : removedBondVdsNetworkInterface) {
        String bondName = removedBond.getName();
        VdsNetworkInterface existingBond = existingInterfacesMap.get(bondName);
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingBond).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        boolean cantRemoveRequiredInterface = nicNameToAttachedNetworkAttachmentIds.containsKey(bondName);
        if (cantRemoveRequiredInterface) {
            List<Guid> networkAttachmentsForNic = nicNameToAttachedNetworkAttachmentIds.get(bondName);
            List<String> replacements = new ArrayList<>();
            replacements.add(ReplacementUtils.createSetVariableString(VAR_BOND_NAME, bondName));
            replacements.addAll(ReplacementUtils.replaceWith(VAR_ATTACHMENT_IDS, networkAttachmentsForNic));
            return new ValidationResult(EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS, replacements);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
Collection<NetworkAttachment> getAttachmentsToConfigure() {
    Map<Guid, NetworkAttachment> networkAttachmentsMap = new HashMap<>(existingAttachments.size() + params.getNetworkAttachments().size());
    List<NetworkAttachment> newAttachments = new ArrayList<>();
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        if (attachment.getId() == null) {
            newAttachments.add(attachment);
            continue;
        } else {
            networkAttachmentsMap.put(attachment.getId(), attachment);
        }
    }
    Map<Guid, NetworkAttachment> removedNetworkAttachments = Entities.businessEntitiesById(this.removedNetworkAttachments);
    for (NetworkAttachment existingAttachment : existingAttachments) {
        Guid existingAttachmentId = existingAttachment.getId();
        if (!networkAttachmentsMap.containsKey(existingAttachmentId) && !removedNetworkAttachments.containsKey(existingAttachmentId)) {
            networkAttachmentsMap.put(existingAttachmentId, existingAttachment);
        }
    }
    List<NetworkAttachment> result = new ArrayList<>(networkAttachmentsMap.values());
    result.addAll(newAttachments);
    return result;
}
#method_after
Collection<NetworkAttachment> getAttachmentsToConfigure() {
    Map<Guid, NetworkAttachment> networkAttachmentsMap = new HashMap<>(existingAttachments.size() + params.getNetworkAttachments().size());
    List<NetworkAttachment> newAttachments = new ArrayList<>();
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        if (attachment.getId() == null) {
            newAttachments.add(attachment);
        } else {
            networkAttachmentsMap.put(attachment.getId(), attachment);
        }
    }
    Map<Guid, NetworkAttachment> removedNetworkAttachments = Entities.businessEntitiesById(this.removedNetworkAttachments);
    for (NetworkAttachment existingAttachment : existingAttachments) {
        Guid existingAttachmentId = existingAttachment.getId();
        if (!networkAttachmentsMap.containsKey(existingAttachmentId) && !removedNetworkAttachments.containsKey(existingAttachmentId)) {
            networkAttachmentsMap.put(existingAttachmentId, existingAttachment);
        }
    }
    List<NetworkAttachment> result = new ArrayList<>(networkAttachmentsMap.values());
    result.addAll(newAttachments);
    return result;
}
#end_block

#method_before
boolean validNewOrModifiedBonds() {
    boolean passed = true;
    for (Bond modifiedOrNewBond : params.getBonds()) {
        // does not test, whether interface exists, but only if the instance is non-null and its name is set.
        if (violations.addViolation(createHostInterfaceValidator(modifiedOrNewBond).interfaceByNameExists())) {
            passed = false;
            continue;
        }
        String bondName = modifiedOrNewBond.getName();
        boolean validBondName = bondName.matches(BusinessEntitiesDefinitions.BOND_NAME_PATTERN);
        if (!validBondName) {
            violations.addViolation(VdcBllMessages.NETWORK_BOND_NAME_BAD_FORMAT, bondName);
            passed = false;
        }
        HostInterfaceValidator validator = createHostInterfaceValidator(existingInterfacesMap.get(bondName));
        // either it's newly create bond, thus non existing, or given name must reference existing bond.
        if (violations.addViolation(validator.interfaceIsBond(), bondName)) {
            passed = false;
            continue;
        }
        // count of bond slaves must be at least two.
        if (modifiedOrNewBond.getSlaves().size() < 2) {
            violations.addViolation(VdcBllMessages.NETWORK_BONDS_INVALID_SLAVE_COUNT, bondName);
            passed = false;
            continue;
        }
        passed &= validateModifiedBondSlaves(modifiedOrNewBond);
    }
    return passed;
}
#method_after
ValidationResult validNewOrModifiedBonds() {
    for (Bond modifiedOrNewBond : params.getBonds()) {
        String bondName = modifiedOrNewBond.getName();
        ValidationResult validateCoherentNicIdentification = validateCoherentNicIdentification(modifiedOrNewBond);
        if (!validateCoherentNicIdentification.isValid()) {
            return validateCoherentNicIdentification;
        }
        // does not test, whether interface exists, but only if the instance is non-null and its name is set.
        ValidationResult interfaceByNameExists = createHostInterfaceValidator(modifiedOrNewBond).interfaceByNameExists();
        if (!interfaceByNameExists.isValid()) {
            return interfaceByNameExists;
        }
        boolean validBondName = bondName != null && bondName.matches(BusinessEntitiesDefinitions.BOND_NAME_PATTERN);
        if (!validBondName) {
            return new ValidationResult(EngineMessage.NETWORK_BOND_NAME_BAD_FORMAT, ReplacementUtils.createSetVariableString(VAR_NETWORK_BOND_NAME_BAD_FORMAT_ENTITY, bondName));
        }
        // either it's newly create bond, thus non existing, or given name must reference existing bond.
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingInterfacesMap.get(bondName)).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        // count of bond slaves must be at least two.
        if (modifiedOrNewBond.getSlaves().size() < 2) {
            return new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.createSetVariableString(VAR_NETWORK_BONDS_INVALID_SLAVE_COUNT_LIST, bondName));
        }
        ValidationResult validateModifiedBondSlaves = validateModifiedBondSlaves(modifiedOrNewBond);
        if (!validateModifiedBondSlaves.isValid()) {
            return validateModifiedBondSlaves;
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
boolean validateModifiedBondSlaves(Bond modifiedOrNewBond) {
    boolean passed = true;
    Map<String, NetworkAttachment> removedNetworkAttachmentsByNicName = new MapNetworkAttachments(removedNetworkAttachments).byNicName();
    for (String slaveName : modifiedOrNewBond.getSlaves()) {
        VdsNetworkInterface slave = existingInterfacesMap.get(slaveName);
        HostInterfaceValidator slaveHostInterfaceValidator = createHostInterfaceValidator(slave);
        if (violations.addViolation(slaveHostInterfaceValidator.interfaceExists(), slaveName)) {
            passed = false;
            continue;
        }
        if (violations.addViolation(slaveHostInterfaceValidator.interfaceIsValidSlave(), slaveName)) {
            passed = false;
            continue;
        }
        /* definition of currently processed bond references this slave, but this slave already 'slaves' for
            another bond. This is ok only when this bond will be removed as a part of this request. */
        String slaveBondName = slave.getBondName();
        if (slave.isBondSlave() && !slaveBondName.equals(modifiedOrNewBond.getName()) && // …but this bond is also removed in this request, so it's ok.
        !bondIsBeingRemoved(slaveBondName)) {
            violations.addViolation(VdcBllMessages.NETWORK_INTERFACE_ALREADY_IN_BOND, slaveName);
            passed = false;
            continue;
        }
        String slaveNetworkName = slave.getNetworkName();
        boolean slaveHadNetworkAttached = slaveNetworkName != null;
        if (slaveHadNetworkAttached) {
            boolean attachmentBoundToNicBecomingSlaveRemoved = removedNetworkAttachmentsByNicName.containsKey(slave.getName());
            Guid slaveNetworkId = networkBusinessEntityMap.get(slaveNetworkName).getId();
            NetworkAttachment attachmentRelevantToSlaveNetwork = networkAttachmentsByNetworkId.get(slaveNetworkId);
            boolean networkBoundToNicBecomingSlaveMovedToAnotherNic = attachmentRelevantToSlaveNetwork != null && (!Objects.equals(attachmentRelevantToSlaveNetwork.getNicId(), slave.getId()) && !Objects.equals(attachmentRelevantToSlaveNetwork.getNicName(), slave.getName()));
            boolean slaveStillHasNetworkAttached = !(attachmentBoundToNicBecomingSlaveRemoved || networkBoundToNicBecomingSlaveMovedToAnotherNic);
            if (slaveStillHasNetworkAttached) {
                violations.addViolation(VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE, slave.getName());
                passed = false;
                continue;
            }
        }
    }
    return passed;
}
#method_after
ValidationResult validateModifiedBondSlaves(Bond modifiedOrNewBond) {
    for (String slaveName : modifiedOrNewBond.getSlaves()) {
        VdsNetworkInterface potentialSlave = existingInterfacesMap.get(slaveName);
        HostInterfaceValidator slaveHostInterfaceValidator = createHostInterfaceValidator(potentialSlave);
        ValidationResult interfaceExists = slaveHostInterfaceValidator.interfaceExists();
        if (!interfaceExists.isValid()) {
            return interfaceExists;
        }
        ValidationResult interfaceIsValidSlave = slaveHostInterfaceValidator.interfaceIsValidSlave();
        if (!interfaceIsValidSlave.isValid()) {
            return interfaceIsValidSlave;
        }
        /* definition of currently processed bond references this slave, but this slave already 'slaves' for
                another bond. This is ok only when this bond will be removed as a part of this request
                or the slave will be removed from its former bond, as a part of this request. */
        String currentSlavesBondName = potentialSlave.getBondName();
        if (potentialSlave.isPartOfBond() && /* we're creating new bond, and it's definition contains reference to slave already assigned
                        to a different bond. */
        (!potentialSlave.isPartOfBond(modifiedOrNewBond.getName()) && // …but this bond is also removed in this request, so it's ok.
        !isBondRemoved(currentSlavesBondName) && // … or slave was removed from its former bond
        !bondIsUpdatedAndDoesNotContainCertainSlave(slaveName, currentSlavesBondName))) {
            return new ValidationResult(EngineMessage.NETWORK_INTERFACE_ALREADY_IN_BOND, ReplacementUtils.createSetVariableString(VAR_NETWORK_INTERFACE_ALREADY_IN_BOND_ENTITY, slaveName));
        }
        ValidationResult slaveHasAttachedNetworksValidationResult = validateSlaveHasNoNetworks(potentialSlave.getName());
        if (!slaveHasAttachedNetworksValidationResult.isValid()) {
            return slaveHasAttachedNetworksValidationResult;
        }
        if (slaveUsedMultipleTimesInDifferentBonds(slaveName)) {
            return new ValidationResult(EngineMessage.NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES, ReplacementUtils.createSetVariableString("NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES_ENTITY", slaveName));
        }
        ValidationResult slaveHasNoLabelsValidationResult = validateSlaveHasNoLabels(slaveName);
        if (!slaveHasNoLabelsValidationResult.isValid()) {
            return slaveHasNoLabelsValidationResult;
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private boolean validNewOrModifiedNetworkAttachments() {
    boolean passed = true;
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachment, host, managementNetworkUtil);
        String networkId = attachment.getNetworkId() == null ? "" : attachment.getNetworkId().toString();
        if (violations.addViolation(validator.networkAttachmentIsSet()) || violations.addViolation(referencedNetworkAttachmentActuallyExists(attachment.getId()), networkId) || // this is not network exist, but only network is set.
        violations.addViolation(validator.networkExists(), networkId) || violations.addViolation(networkActuallyExists(attachment.getNetworkId()), networkId) || violations.addViolation(validator.notExternalNetwork(), networkId) || violations.addViolation(validator.networkAttachedToCluster(), networkId) || violations.addViolation(validator.ipConfiguredForStaticBootProtocol(), networkId) || violations.addViolation(validator.bootProtocolSetForDisplayNetwork(), networkId) || // this is not nic exist, but only nic is set.
        violations.addViolation(validator.nicExists(), networkId) || violations.addViolation(nicActuallyExistsOrReferencesNewBond(attachment), networkId) || violations.addViolation(validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfacesMap)) || violations.addViolation(validator.networkNotChanged(attachmentsById.get(attachment.getId()))) || violations.addViolation(validator.validateGateway())) {
            passed = false;
        }
    }
    return passed;
}
#method_after
private ValidationResult validNewOrModifiedNetworkAttachments() {
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = params.getNetworkAttachments().iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : referencedNetworkAttachmentActuallyExists(attachment.getId());
        // TODO MM: complain about unset network id.
        vr = skipValidation(vr) ? vr : validator.networkExists();
        vr = skipValidation(vr) ? vr : validateCoherentNicIdentification(attachment);
        vr = skipValidation(vr) ? vr : validateCoherentNetworkIdentification(attachment);
        vr = skipValidation(vr) ? vr : modifiedAttachmentExists(attachment.getId());
        vr = skipValidation(vr) ? vr : modifiedAttachmentNotRemoved(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentNotReferenceVlanDevice(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentAndNicReferenceSameLabelNotConflict(attachment);
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.networkAttachedToCluster();
        vr = skipValidation(vr) ? vr : validator.ipConfiguredForStaticBootProtocol();
        vr = skipValidation(vr) ? vr : validator.bootProtocolSetForDisplayNetwork();
        // this is not nic exist, but only nic is set.
        vr = skipValidation(vr) ? vr : validator.nicExists();
        vr = skipValidation(vr) ? vr : nicActuallyExistsOrReferencesNewBond(attachment);
        vr = skipValidation(vr) ? vr : validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfacesMap);
        vr = skipValidation(vr) ? vr : validator.networkNotChanged(attachmentsById.get(attachment.getId()));
        vr = skipValidation(vr) ? vr : validator.validateGateway();
        boolean attachmentUpdated = !isNewAttachment(attachment.getId());
        if (attachmentUpdated) {
            vr = skipValidation(vr) ? vr : validator.networkNotUsedByVms();
            vr = skipValidation(vr) ? vr : notMovingLabeledNetworkToDifferentNic(attachment);
        }
    }
    return vr;
}
#end_block

#method_before
private ValidationResult referencedNetworkAttachmentActuallyExists(Guid networkAttachmentId) {
    boolean doesNotReferenceExistingNetworkAttachment = networkAttachmentId == null;
    if (doesNotReferenceExistingNetworkAttachment) {
        return ValidationResult.VALID;
    }
    for (NetworkAttachment existingAttachment : existingAttachments) {
        if (existingAttachment.getId().equals(networkAttachmentId)) {
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(VdcBllMessages.NETWORK_ATTACHMENT_NOT_EXISTS);
}
#method_after
private ValidationResult referencedNetworkAttachmentActuallyExists(Guid networkAttachmentId) {
    boolean doesNotReferenceExistingNetworkAttachment = networkAttachmentId == null;
    if (doesNotReferenceExistingNetworkAttachment) {
        return ValidationResult.VALID;
    }
    for (NetworkAttachment existingAttachment : existingAttachments) {
        if (existingAttachment.getId().equals(networkAttachmentId)) {
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS);
}
#end_block

#method_before
private ValidationResult nicActuallyExistsOrReferencesNewBond(NetworkAttachment attachment) {
    String targetNicName = attachment.getNicName();
    boolean attachmentReferencesExistingNic = existingInterfacesMap.get(attachment.getNicId(), targetNicName) != null;
    if (attachmentReferencesExistingNic) {
        return ValidationResult.VALID;
    }
    boolean attachmentReferencesNewlyCreatedBond = targetNicName != null && bondsMap.get(targetNicName) != null;
    if (attachmentReferencesNewlyCreatedBond) {
        return ValidationResult.VALID;
    }
    return new ValidationResult(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST);
}
#method_after
private ValidationResult nicActuallyExistsOrReferencesNewBond(NetworkAttachment attachment) {
    boolean nicActuallyExistsOrReferencesNewBond = isNicActuallyExistsOrReferencesNewBond(attachment.getNicName(), attachment.getNicId());
    if (nicActuallyExistsOrReferencesNewBond) {
        return ValidationResult.VALID;
    }
    // Duplicate message / fix other code as well?
    return new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST);
}
#end_block

#method_before
private boolean validRemovedNetworkAttachments() {
    boolean passed = true;
    for (NetworkAttachment attachment : removedNetworkAttachments) {
        NetworkAttachment attachmentToValidate = attachmentsById.get(attachment.getId());
        NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachmentToValidate, host, managementNetworkUtil);
        if (violations.addViolation(validator.networkAttachmentIsSet()) || violations.addViolation(validator.notExternalNetwork()) || violations.addViolation(validator.notRemovingManagementNetwork()) || !notRemovingLabeledNetworks(attachment)) {
            passed = false;
        }
    }
    return passed;
}
#method_after
private ValidationResult validRemovedNetworkAttachments() {
    List<Guid> invalidIds = Entities.idsNotReferencingExistingRecords(params.getRemovedNetworkAttachments(), existingAttachments);
    if (!invalidIds.isEmpty()) {
        return new ValidationResult(EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS, ReplacementUtils.replaceWith(VAR_NETWORK_ATTACHMENTS_NOT_EXISTS_LIST, invalidIds));
    }
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = removedNetworkAttachments.iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachment attachmentToValidate = attachmentsById.get(attachment.getId());
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachmentToValidate);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.notRemovingManagementNetwork();
        vr = skipValidation(vr) ? vr : notRemovingLabeledNetworks(attachment);
        vr = skipValidation(vr) ? vr : validateNotRemovingUsedNetworkByVms();
    }
    return vr;
}
#end_block

#method_before
boolean notRemovingLabeledNetworks(NetworkAttachment attachment) {
    Network removedNetwork = networkBusinessEntityMap.get(attachment.getNetworkId());
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return true;
    }
    VdsNetworkInterface nic = existingInterfacesMap.get(attachment.getNicName());
    if (nic != null && !removedBondVdsNetworkInterfaceMap.containsKey(nic.getName())) {
        // TODO MM: why is this correct?? Why when it's related to removed bond I can remove labeled network?
        if (NetworkUtils.isLabeled(nic) && nic.getLabels().contains(removedNetwork.getLabel())) {
            violations.addViolation(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, removedNetwork.getName());
            return false;
        }
    }
    return true;
}
#method_after
ValidationResult notRemovingLabeledNetworks(NetworkAttachment attachment) {
    Network removedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return ValidationResult.VALID;
    }
    boolean networkAttachedToNicByAnotherAttachment = networkAttachmentsByNetworkId.get(removedNetwork.getId()) != null;
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, ReplacementUtils.createSetVariableString(VAR_ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC_LIST, removedNetwork.getName())).when(!networkAttachedToNicByAnotherAttachment && isNicToConfigureContainTheLabel(attachment.getNicName(), removedNetwork.getLabel()));
}
#end_block

#method_before
private boolean validateCustomProperties() {
    String version = host.getVdsGroupCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validPropertiesForVmNetwork = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validPropertiesForVmNetwork.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    Map<String, String> validPropertiesForNonVm = new HashMap<>(validPropertiesForVmNetwork);
    validPropertiesForNonVm.remove("bridge_opts");
    return validateCustomProperties(util, validPropertiesForVmNetwork, validPropertiesForNonVm);
}
#method_after
private ValidationResult validateCustomProperties() {
    String version = host.getVdsGroupCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validPropertiesForVmNetwork = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validPropertiesForVmNetwork.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    Map<String, String> validPropertiesForNonVm = new HashMap<>(validPropertiesForVmNetwork);
    validPropertiesForNonVm.remove("bridge_opts");
    return validateCustomProperties(util, validPropertiesForVmNetwork, validPropertiesForNonVm);
}
#end_block

#method_before
boolean validateCustomProperties(SimpleCustomPropertiesUtil util, Map<String, String> validPropertiesForVm, Map<String, String> validPropertiesForNonVm) {
    boolean passed = true;
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        Network network = networkBusinessEntityMap.get(attachment.getNetworkId());
        if (attachment.hasProperties()) {
            if (!networkCustomPropertiesSupported) {
                violations.addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, network.getName());
                passed = false;
            }
            List<ValidationError> errors = util.validateProperties(network.isVmNetwork() ? validPropertiesForVm : validPropertiesForNonVm, attachment.getProperties());
            if (!errors.isEmpty()) {
                violations.addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, network.getName());
                List<String> messages = new ArrayList<>();
                util.handleCustomPropertiesError(errors, messages);
                log.error(StringUtils.join(translateErrorMessages(messages), ','));
                passed = false;
            }
        }
    }
    return passed;
}
#method_after
ValidationResult validateCustomProperties(SimpleCustomPropertiesUtil util, Map<String, String> validPropertiesForVm, Map<String, String> validPropertiesForNonVm) {
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        Network network = existingNetworkRelatedToAttachment(attachment);
        if (attachment.hasProperties()) {
            if (!networkCustomPropertiesSupported) {
                return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, ReplacementUtils.createSetVariableString(VAR_ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED_LIST, network.getName()));
            }
            List<ValidationError> errors = util.validateProperties(network.isVmNetwork() ? validPropertiesForVm : validPropertiesForNonVm, attachment.getProperties());
            if (!errors.isEmpty()) {
                handleCustomPropertiesError(util, errors);
                return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, ReplacementUtils.createSetVariableString(VAR_ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT_LIST, network.getName()));
            }
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public List<String> validate() {
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String name = iface.getName();
        if (addInterfaceToProcessedList(iface)) {
            if (isBond(iface)) {
                extractBondIfModified(iface, name);
            } else if (StringUtils.isNotBlank(iface.getBondName())) {
                extractBondSlave(iface);
            }
            // validate and extract to network map
            if (violations.isEmpty() && StringUtils.isNotBlank(iface.getNetworkName())) {
                extractNetwork(iface);
                validateGateway(iface);
            }
        }
    }
    validateInterfacesExist();
    validateBondSlavesCount();
    extractRemovedNetworks();
    extractRemovedBonds();
    extractModifiedInterfaces();
    detectSlaveChanges();
    validateMTU();
    validateNetworkQos();
    validateNotRemovingLabeledNetworks();
    validateCustomProperties();
    return translateViolations();
}
#method_after
public List<String> validate() {
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String name = iface.getName();
        if (addInterfaceToProcessedList(iface)) {
            if (iface.isBond()) {
                extractBondIfModified(iface, name);
            } else if (StringUtils.isNotBlank(iface.getBondName())) {
                extractBondSlave(iface);
            }
            // validate and extract to network map
            if (violations.isEmpty() && StringUtils.isNotBlank(iface.getNetworkName())) {
                extractNetwork(iface);
                validateGateway(iface);
            }
        }
    }
    validateInterfacesExist();
    validateBondSlavesCount();
    extractRemovedNetworks();
    extractRemovedBonds();
    extractModifiedInterfaces();
    detectSlaveChanges();
    validateMTU();
    validateNetworkQos();
    validateNotRemovingLabeledNetworks();
    validateCustomProperties();
    validateNotRemovingGlusterBrickNetworks();
    return translateViolations();
}
#end_block

#method_before
private void validateNicForNotRemovingLabeledNetworks(String network, VdsNetworkInterface nic) {
    Network removedNetwork = getExistingClusterNetworks().get(network);
    if (NetworkUtils.isLabeled(nic) && removedNetwork != null && nic.getLabels().contains(removedNetwork.getLabel())) {
        addViolation(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, network);
    }
}
#method_after
private void validateNicForNotRemovingLabeledNetworks(String network, VdsNetworkInterface nic) {
    Network removedNetwork = getExistingClusterNetworks().get(network);
    if (NetworkUtils.isLabeled(nic) && removedNetwork != null && nic.getLabels().contains(removedNetwork.getLabel())) {
        addViolation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, network);
    }
}
#end_block

#method_before
private void extractModifiedInterfaces() {
    for (VdsNetworkInterface nic : params.getInterfaces()) {
        VdsNetworkInterface existingNic = getExistingIfaces().get(nic.getName());
        if (existingNic != null) {
            Set<String> newLabels = NetworkUtils.isLabeled(nic) ? nic.getLabels() : Collections.<String>emptySet();
            Set<String> existingLabels = NetworkUtils.isLabeled(existingNic) ? existingNic.getLabels() : Collections.<String>emptySet();
            if (!CollectionUtils.isEqualCollection(newLabels, existingLabels) || (StringUtils.isNotEmpty(nic.getNetworkName()) && qosOrCustomPropertiesChanged(nic, existingNic))) {
                existingNic.setLabels(newLabels);
                existingNic.setQosOverridden(nic.isQosOverridden());
                existingNic.setCustomProperties(nic.getCustomProperties());
                modifiedInterfaces.add(existingNic);
            }
        }
    }
}
#method_after
private void extractModifiedInterfaces() {
    for (VdsNetworkInterface nic : params.getInterfaces()) {
        VdsNetworkInterface existingNic = getExistingIfaces().get(nic.getName());
        if (existingNic != null) {
            Set<String> newLabels = NetworkUtils.isLabeled(nic) ? nic.getLabels() : Collections.<String>emptySet();
            Set<String> existingLabels = NetworkUtils.isLabeled(existingNic) ? existingNic.getLabels() : Collections.<String>emptySet();
            if (!CollectionUtils.isEqualCollection(newLabels, existingLabels) || (StringUtils.isNotEmpty(nic.getNetworkName()) && customPropertiesChanged(nic, existingNic))) {
                existingNic.setLabels(newLabels);
                existingNic.setCustomProperties(nic.getCustomProperties());
                modifiedInterfaces.add(existingNic);
            }
        }
    }
}
#end_block

#method_before
private void validateInterfacesExist() {
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        updateBaseInterface(iface);
        String nameWithoutVlanId = NetworkUtils.stripVlan(iface);
        if (!getExistingIfaces().containsKey(nameWithoutVlanId) && !bonds.containsKey(nameWithoutVlanId)) {
            addViolation(VdcBllMessages.NETWORK_INTERFACES_DONT_EXIST, nameWithoutVlanId);
        }
    }
}
#method_after
private void validateInterfacesExist() {
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        updateBaseInterface(iface);
        String nameWithoutVlanId = NetworkUtils.stripVlan(iface);
        if (!getExistingIfaces().containsKey(nameWithoutVlanId) && !bonds.containsKey(nameWithoutVlanId)) {
            addViolation(EngineMessage.NETWORK_INTERFACES_DONT_EXIST, nameWithoutVlanId);
        }
    }
}
#end_block

#method_before
private void reportMTUDifferences(List<Network> ifaceNetworks) {
    List<String> mtuDiffNetworks = new ArrayList<>();
    for (Network net : ifaceNetworks) {
        mtuDiffNetworks.add(String.format("%s(%s)", net.getName(), net.getMtu() == 0 ? "default" : String.valueOf(net.getMtu())));
    }
    addViolation(VdcBllMessages.NETWORK_MTU_DIFFERENCES, String.format("[%s]", StringUtils.join(mtuDiffNetworks, ", ")));
}
#method_after
private void reportMTUDifferences(List<Network> ifaceNetworks) {
    List<String> mtuDiffNetworks = new ArrayList<>();
    for (Network net : ifaceNetworks) {
        mtuDiffNetworks.add(String.format("%s(%s)", net.getName(), net.getMtu() == 0 ? "default" : String.valueOf(net.getMtu())));
    }
    addViolation(EngineMessage.NETWORK_MTU_DIFFERENCES, String.format("[%s]", StringUtils.join(mtuDiffNetworks, ", ")));
}
#end_block

#method_before
private void validateNetworkQos() {
    validateQosOverriddenInterfaces();
    validateQosNotPartiallyConfigured();
    validateQosCommitment();
}
#method_after
private void validateNetworkQos() {
    validateQosNotPartiallyConfigured();
}
#end_block

#method_before
private void validateQosNotPartiallyConfigured() {
    Set<String> someSubInterfacesHaveQos = new HashSet<>();
    Set<String> notAllSubInterfacesHaveQos = new HashSet<>();
    // first map which interfaces have some QoS configured on them, and which interfaces lack some QoS configuration
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        Network network = getExistingClusterNetworks().get(iface.getNetworkName());
        String baseIfaceName = NetworkUtils.stripVlan(iface);
        if (NetworkUtils.qosConfiguredOnInterface(iface, network)) {
            someSubInterfacesHaveQos.add(baseIfaceName);
        } else {
            notAllSubInterfacesHaveQos.add(baseIfaceName);
        }
    }
    // if any base interface has some sub-interfaces with QoS and some without - this is a partial configuration
    for (String ifaceName : someSubInterfacesHaveQos) {
        if (notAllSubInterfacesHaveQos.contains(ifaceName)) {
            addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_INTERFACES_WITHOUT_QOS, ifaceName);
        }
    }
}
#method_after
private void validateQosNotPartiallyConfigured() {
    Set<String> someSubInterfacesHaveQos = new HashSet<>();
    Set<String> notAllSubInterfacesHaveQos = new HashSet<>();
    // first map which interfaces have some QoS configured on them, and which interfaces lack some QoS configuration
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String networkName = iface.getNetworkName();
        Network network = getExistingClusterNetworks().get(networkName);
        VdsNetworkInterface baseNic = calculateBaseNic.getBaseNic(iface, existingIfaces);
        NetworkAttachment networkAttachment = baseNic == null || network == null ? null : networkAttachmentDao.getNetworkAttachmentByNicIdAndNetworkId(baseNic.getId(), network.getId());
        String baseIfaceName = baseNic == null ? null : baseNic.getName();
        if (NetworkUtils.qosConfiguredOnInterface(networkAttachment, network)) {
            someSubInterfacesHaveQos.add(baseIfaceName);
        } else {
            notAllSubInterfacesHaveQos.add(baseIfaceName);
        }
    }
    // if any base interface has some sub-interfaces with QoS and some without - this is a partial configuration
    for (String ifaceName : someSubInterfacesHaveQos) {
        if (notAllSubInterfacesHaveQos.contains(ifaceName)) {
            addViolation(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_INTERFACES_WITHOUT_QOS, ifaceName);
        }
    }
}
#end_block

#method_before
private void validateCustomProperties() {
    String version = vds.getVdsGroupCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validProperties = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validProperties.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    Map<String, String> validPropertiesNonVm = new HashMap<>(validProperties);
    validPropertiesNonVm.remove("bridge_opts");
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String networkName = iface.getNetworkName();
        if (iface.hasCustomProperties() && StringUtils.isNotEmpty(networkName)) {
            if (!networkCustomPropertiesSupported) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, networkName);
            }
            Network network = existingClusterNetworks.get(networkName);
            List<ValidationError> errors = util.validateProperties(network == null || network.isVmNetwork() ? validProperties : validPropertiesNonVm, iface.getCustomProperties());
            if (!errors.isEmpty()) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, networkName);
                List<String> messages = new ArrayList<>();
                util.handleCustomPropertiesError(errors, messages);
                log.error(StringUtils.join(translateErrorMessages(messages), ','));
            }
        }
    }
}
#method_after
private void validateCustomProperties() {
    String version = vds.getVdsGroupCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validProperties = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validProperties.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    Map<String, String> validPropertiesNonVm = new HashMap<>(validProperties);
    validPropertiesNonVm.remove("bridge_opts");
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String networkName = iface.getNetworkName();
        if (iface.hasCustomProperties() && StringUtils.isNotEmpty(networkName)) {
            if (!networkCustomPropertiesSupported) {
                addViolation(EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, networkName);
            }
            Network network = existingClusterNetworks.get(networkName);
            List<ValidationError> errors = util.validateProperties(network == null || network.isVmNetwork() ? validProperties : validPropertiesNonVm, iface.getCustomProperties());
            if (!errors.isEmpty()) {
                addViolation(EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, networkName);
                List<String> messages = new ArrayList<>();
                util.handleCustomPropertiesError(errors, messages);
                log.error(StringUtils.join(translateErrorMessages(messages), ','));
            }
        }
    }
}
#end_block

#method_before
private void addViolation(VdcBllMessages violation, String violatingEntity) {
    List<String> violatingEntities = violations.get(violation);
    if (violatingEntities == null) {
        violatingEntities = new ArrayList<>();
        violations.put(violation, violatingEntities);
    }
    violatingEntities.add(violatingEntity);
}
#method_after
private void addViolation(EngineMessage violationMsg, String violatingEntity) {
    final Violation violation = (Violation) violations.get(violationMsg);
    if (violation == null) {
        violations.put(violationMsg, new Violation(violationMsg.name(), violatingEntity));
    } else {
        violation.add(violatingEntity);
    }
}
#end_block

#method_before
private List<String> translateViolations() {
    List<String> violationMessages = new ArrayList<>(violations.size() * 2);
    for (Map.Entry<VdcBllMessages, List<String>> v : violations.entrySet()) {
        String violationName = v.getKey().name();
        violationMessages.add(violationName);
        violationMessages.add(MessageFormat.format(VIOLATING_ENTITIES_LIST_FORMAT, violationName, StringUtils.join(v.getValue(), ", ")));
        if (v.getKey() == VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_OVERCOMMITMENT) {
            violationMessages.add("$commitmentThreshold " + (int) (100 * QOS_OVERCOMMITMENT_THRESHOLD));
        }
    }
    return violationMessages;
}
#method_after
private List<String> translateViolations() {
    List<String> violationMessages = new ArrayList<>(violations.size() * 2);
    for (Entry<EngineMessage, ViolationRenderer> violationEntry : violations.entrySet()) {
        final List<String> renderedViolationMessages = violationEntry.getValue().render();
        violationMessages.addAll(renderedViolationMessages);
    }
    return violationMessages;
}
#end_block

#method_before
private boolean addInterfaceToProcessedList(VdsNetworkInterface iface) {
    if (ifaceByNames.containsKey(iface.getName())) {
        addViolation(VdcBllMessages.NETWORK_INTERFACES_ALREADY_SPECIFIED, iface.getName());
        return false;
    }
    ifaceByNames.put(iface.getName(), iface);
    return true;
}
#method_after
private boolean addInterfaceToProcessedList(VdsNetworkInterface iface) {
    if (ifaceByNames.containsKey(iface.getName())) {
        addViolation(EngineMessage.NETWORK_INTERFACES_ALREADY_SPECIFIED, iface.getName());
        return false;
    }
    ifaceByNames.put(iface.getName(), iface);
    return true;
}
#end_block

#method_before
private void detectSlaveChanges() {
    for (VdsNetworkInterface newIface : params.getInterfaces()) {
        VdsNetworkInterface existingIface = getExistingIfaces().get(newIface.getName());
        if (existingIface != null && !isBond(existingIface) && existingIface.getVlanId() == null) {
            String bondNameInNewIface = newIface.getBondName();
            String bondNameInOldIface = existingIface.getBondName();
            if (!StringUtils.equals(bondNameInNewIface, bondNameInOldIface)) {
                if (bondNameInNewIface != null && !modifiedBonds.containsKey(bondNameInNewIface)) {
                    modifiedBonds.put(bondNameInNewIface, getExistingIfaces().get(bondNameInNewIface));
                }
                if (bondNameInOldIface != null && !modifiedBonds.containsKey(bondNameInNewIface) && !removedBonds.containsKey(bondNameInOldIface)) {
                    modifiedBonds.put(bondNameInOldIface, getExistingIfaces().get(bondNameInOldIface));
                }
            }
        }
    }
}
#method_after
private void detectSlaveChanges() {
    for (VdsNetworkInterface newIface : params.getInterfaces()) {
        VdsNetworkInterface existingIface = getExistingIfaces().get(newIface.getName());
        if (existingIface != null && !existingIface.isBond() && existingIface.getVlanId() == null) {
            String bondNameInNewIface = newIface.getBondName();
            String bondNameInOldIface = existingIface.getBondName();
            if (!StringUtils.equals(bondNameInNewIface, bondNameInOldIface)) {
                if (bondNameInNewIface != null && !modifiedBonds.containsKey(bondNameInNewIface)) {
                    modifiedBonds.put(bondNameInNewIface, getExistingIfaces().get(bondNameInNewIface));
                }
                if (bondNameInOldIface != null && !modifiedBonds.containsKey(bondNameInNewIface) && !removedBonds.containsKey(bondNameInOldIface)) {
                    modifiedBonds.put(bondNameInOldIface, getExistingIfaces().get(bondNameInOldIface));
                }
            }
        }
    }
}
#end_block

#method_before
private Map<String, Network> getExistingClusterNetworks() {
    if (existingClusterNetworks == null) {
        existingClusterNetworks = Entities.entitiesByName(getDbFacade().getNetworkDao().getAllForCluster(vds.getVdsGroupId()));
    }
    return existingClusterNetworks;
}
#method_after
private Map<String, Network> getExistingClusterNetworks() {
    if (existingClusterNetworks == null) {
        existingClusterNetworks = Entities.entitiesByName(networkDao.getAllForCluster(vds.getVdsGroupId()));
    }
    return existingClusterNetworks;
}
#end_block

#method_before
private Map<String, VdsNetworkInterface> getExistingIfaces() {
    if (existingIfaces == null) {
        List<VdsNetworkInterface> ifaces = getDbFacade().getInterfaceDao().getAllInterfacesForVds(params.getVdsId());
        HostNetworkQosDao qosDao = getDbFacade().getHostNetworkQosDao();
        for (VdsNetworkInterface iface : ifaces) {
            Network network = getExistingClusterNetworks().get(iface.getNetworkName());
            iface.setNetworkImplementationDetails(NetworkUtils.calculateNetworkImplementationDetails(network, network == null ? null : qosDao.get(network.getQosId()), iface));
        }
        existingIfaces = Entities.entitiesByName(ifaces);
    }
    return existingIfaces;
}
#method_after
private Map<String, VdsNetworkInterface> getExistingIfaces() {
    if (existingIfaces == null) {
        List<VdsNetworkInterface> ifaces = interfaceDao.getAllInterfacesForVds(params.getVdsId());
        for (VdsNetworkInterface iface : ifaces) {
            Network network = getExistingClusterNetworks().get(iface.getNetworkName());
            NetworkImplementationDetails networkImplementationDetails = networkImplementationDetailsUtils.calculateNetworkImplementationDetails(iface, network);
            iface.setNetworkImplementationDetails(networkImplementationDetails);
        }
        existingIfaces = Entities.entitiesByName(ifaces);
    }
    return existingIfaces;
}
#end_block

#method_before
private void extractNetwork(VdsNetworkInterface iface) {
    String networkName = iface.getNetworkName();
    // prevent attaching 2 interfaces to 1 network
    if (attachedNetworksNames.contains(networkName)) {
        addViolation(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES, networkName);
    } else {
        attachedNetworksNames.add(networkName);
        // check if network exists on cluster
        if (getExistingClusterNetworks().containsKey(networkName)) {
            Network network = getExistingClusterNetworks().get(networkName);
            iface.setVlanId(network.getVlanId());
            validateNetworkInternal(network);
            validateNetworkExclusiveOnIface(iface, determineNetworkType(network.getVlanId(), network.isVmNetwork()));
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            if (existingIface != null && !networkName.equals(existingIface.getNetworkName())) {
                existingIface = getExistingIfaceByNetwork(networkName);
            }
            if (existingIface != null && existingIface.getNetworkImplementationDetails() != null && !existingIface.getNetworkImplementationDetails().isInSync()) {
                iface.setVlanId(existingIface.getVlanId());
                if (networkShouldBeSynced(networkName)) {
                    modifiedNetworks.add(network);
                    if (network.getQosId() != null && !hostNetworkQosSupported) {
                        addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, networkName);
                    }
                } else if (networkWasModified(iface)) {
                    addViolation(VdcBllMessages.NETWORKS_NOT_IN_SYNC, networkName);
                }
            } else if (networkWasModified(iface)) {
                if (networkIpAddressWasSameAsHostnameAndChanged(iface)) {
                    addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED, networkName);
                }
                modifiedNetworks.add(network);
            }
        } else {
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            existingIface = (existingIface == null ? iface : existingIface);
            iface.setVlanId(existingIface.getVlanId());
            validateNetworkExclusiveOnIface(iface, determineNetworkType(existingIface.getVlanId(), existingIface.isBridged()));
            if (unmanagedNetworkChanged(iface)) {
                addViolation(VdcBllMessages.NETWORKS_DONT_EXIST_IN_CLUSTER, networkName);
            }
        }
    }
}
#method_after
private void extractNetwork(VdsNetworkInterface iface) {
    String networkName = iface.getNetworkName();
    // prevent attaching 2 interfaces to 1 network
    if (attachedNetworksNames.contains(networkName)) {
        addViolation(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, networkName);
    } else {
        attachedNetworksNames.add(networkName);
        // check if network exists on cluster
        if (getExistingClusterNetworks().containsKey(networkName)) {
            Network network = getExistingClusterNetworks().get(networkName);
            iface.setVlanId(network.getVlanId());
            validateNetworkInternal(network);
            validateNetworkExclusiveOnIface(iface, determineNetworkType(network.getVlanId(), network.isVmNetwork()));
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            if (existingIface != null && !networkName.equals(existingIface.getNetworkName())) {
                existingIface = getExistingIfaceByNetwork(networkName);
            }
            if (existingIface != null && existingIface.getNetworkImplementationDetails() != null && !existingIface.getNetworkImplementationDetails().isInSync()) {
                iface.setVlanId(existingIface.getVlanId());
                if (networkShouldBeSynced(networkName)) {
                    modifiedNetworks.add(network);
                    if (unableToApplyQos(iface, network)) {
                        addViolation(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, networkName);
                    }
                } else if (networkWasModified(iface)) {
                    addViolation(EngineMessage.NETWORKS_NOT_IN_SYNC, networkName);
                }
            } else if (networkWasModified(iface)) {
                if (networkIpAddressWasSameAsHostnameAndChanged(iface)) {
                    addViolation(EngineMessage.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED, networkName);
                }
                if (networkIpAddressUsedByBrickChanged(iface, network)) {
                    addViolation(EngineMessage.ACTION_TYPE_FAILED_NETWORK_ADDRESS_BRICK_IN_USE, networkName);
                }
                modifiedNetworks.add(network);
            }
        } else {
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            existingIface = (existingIface == null ? iface : existingIface);
            iface.setVlanId(existingIface.getVlanId());
            validateNetworkExclusiveOnIface(iface, determineNetworkType(existingIface.getVlanId(), existingIface.isBridged()));
            if (unmanagedNetworkChanged(iface)) {
                addViolation(EngineMessage.NETWORKS_DONT_EXIST_IN_CLUSTER, networkName);
            }
        }
    }
}
#end_block

#method_before
private void validateNetworkExclusiveOnIface(VdsNetworkInterface iface, NetworkType networkType) {
    String ifaceName = NetworkUtils.stripVlan(iface);
    List<NetworkType> networksOnIface = ifacesWithExclusiveNetwork.get(ifaceName);
    if (networksOnIface == null) {
        networksOnIface = new ArrayList<>();
        ifacesWithExclusiveNetwork.put(ifaceName, networksOnIface);
    }
    if ((networkType == NetworkType.VLAN && networksOnIface.contains(NetworkType.VM)) || (networkType == NetworkType.VM && !networksOnIface.isEmpty())) {
        addViolation(VdcBllMessages.NETWORK_INTERFACES_NOT_EXCLUSIVELY_USED_BY_NETWORK, ifaceName);
    }
    networksOnIface.add(networkType);
}
#method_after
private void validateNetworkExclusiveOnIface(VdsNetworkInterface iface, NetworkType networkType) {
    String ifaceName = NetworkUtils.stripVlan(iface);
    List<NetworkType> networksOnIface = ifacesWithExclusiveNetwork.get(ifaceName);
    if (networksOnIface == null) {
        networksOnIface = new ArrayList<>();
        ifacesWithExclusiveNetwork.put(ifaceName, networksOnIface);
    }
    networksOnIface.add(networkType);
    if (!networkExclusivenessValidator.isNetworkExclusive(networksOnIface)) {
        addViolation(networkExclusivenessValidator.getViolationMessage(), ifaceName);
    }
}
#end_block

#method_before
private void validateNetworkInternal(Network network) {
    if (network.getProvidedBy() != null) {
        addViolation(VdcBllMessages.ACTION_TYPE_FAILED_EXTERNAL_NETWORKS_CANNOT_BE_PROVISIONED, network.getName());
    }
}
#method_after
private void validateNetworkInternal(Network network) {
    if (network.getProvidedBy() != null) {
        addViolation(EngineMessage.ACTION_TYPE_FAILED_EXTERNAL_NETWORKS_CANNOT_BE_PROVISIONED, network.getName());
    }
}
#end_block

#method_before
private boolean validateBondSlavesCount() {
    boolean returnValue = true;
    for (Map.Entry<String, List<VdsNetworkInterface>> bondEntry : bonds.entrySet()) {
        if (bondEntry.getValue().size() < 2) {
            returnValue = false;
            addViolation(VdcBllMessages.NETWORK_BONDS_INVALID_SLAVE_COUNT, bondEntry.getKey());
        }
    }
    return returnValue;
}
#method_after
private boolean validateBondSlavesCount() {
    boolean returnValue = true;
    for (Map.Entry<String, List<VdsNetworkInterface>> bondEntry : bonds.entrySet()) {
        if (bondEntry.getValue().size() < 2) {
            returnValue = false;
            addViolation(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bondEntry.getKey());
        }
    }
    return returnValue;
}
#end_block

#method_before
private void extractRemovedNetworks() {
    for (VdsNetworkInterface iface : getExistingIfaces().values()) {
        String net = iface.getNetworkName();
        if (StringUtils.isNotBlank(net) && !attachedNetworksNames.contains(net)) {
            removedNetworks.add(net);
        }
    }
    List<String> vmNames = getVmInterfaceManager().findActiveVmsUsingNetworks(params.getVdsId(), removedNetworks);
    for (String vmName : vmNames) {
        addViolation(VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, vmName);
    }
}
#method_after
private void extractRemovedNetworks() {
    for (VdsNetworkInterface iface : getExistingIfaces().values()) {
        String networkName = iface.getNetworkName();
        if (StringUtils.isNotBlank(networkName) && !attachedNetworksNames.contains(networkName)) {
            removedNetworks.add(networkName);
            final List<String> vmNames = getVmInterfaceManager().findActiveVmsUsingNetworks(params.getVdsId(), Collections.singleton(networkName));
            for (String vmName : vmNames) {
                addDetailedViolation(EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, vmName, Collections.singletonMap("networkNames", networkName));
            }
        }
    }
}
#end_block

#method_before
private void validateGateway(VdsNetworkInterface iface) {
    if (StringUtils.isNotEmpty(iface.getGateway()) && !managementNetworkUtil.isManagementNetwork(iface.getNetworkName(), vds.getVdsGroupId()) && !FeatureSupported.multipleGatewaysSupported(vds.getVdsGroupCompatibilityVersion())) {
        addViolation(VdcBllMessages.NETWORK_ATTACH_ILLEGAL_GATEWAY, iface.getNetworkName());
    }
}
#method_after
private void validateGateway(VdsNetworkInterface iface) {
    if (StringUtils.isNotEmpty(iface.getGateway()) && !managementNetworkUtil.isManagementNetwork(iface.getNetworkName(), vds.getVdsGroupId()) && !FeatureSupported.multipleGatewaysSupported(vds.getVdsGroupCompatibilityVersion())) {
        addViolation(EngineMessage.NETWORK_ATTACH_ILLEGAL_GATEWAY, iface.getNetworkName());
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    underTest = new VlanUntaggedNetworkExclusivenessValidator(mockUntaggedNetworkPredicate);
    Mockito.when(mockUntaggedNetworkPredicate.evaluate(VLAN)).thenReturn(false);
    Mockito.when(mockUntaggedNetworkPredicate.evaluate(VM)).thenReturn(true);
}
#method_after
@Before
public void setUp() throws Exception {
    underTest = new VlanUntaggedNetworkExclusivenessValidator(mockUntaggedNetworkPredicate);
    when(mockUntaggedNetworkPredicate.evaluate(VLAN)).thenReturn(false);
    when(mockUntaggedNetworkPredicate.evaluate(VM)).thenReturn(true);
}
#end_block

#method_before
/* --- Tests for networks functionality --- */
@Test
public void networkDidntChange() {
    VdsNetworkInterface nic = createNic("nic0", "net");
    mockExistingIfaces(nic);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic));
    validateAndAssertNoChanges(helper);
}
#method_after
@Test
public void networkDidntChange() {
    Network network = createNetwork("network");
    VdsNetworkInterface nic = createNic("nic0", "network");
    mockExistingIfaces(nic);
    mockExistingNetworks(network);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic));
    validateAndAssertNoChanges(helper);
}
#end_block

#method_before
@Test
public void unmanagedNetworkAddedToNic() {
    VdsNetworkInterface nic = createNic("nic0", null);
    mockExistingIfaces(nic);
    nic.setNetworkName("net");
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic));
    validateAndExpectViolation(helper, VdcBllMessages.NETWORKS_DONT_EXIST_IN_CLUSTER, nic.getNetworkName());
}
#method_after
@Test
public void unmanagedNetworkAddedToNic() {
    VdsNetworkInterface nic = createNic("nic0", null);
    mockExistingIfaces(nic);
    nic.setNetworkName("net");
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic));
    validateAndExpectViolation(helper, EngineMessage.NETWORKS_DONT_EXIST_IN_CLUSTER, nic.getNetworkName());
}
#end_block

#method_before
@Test
public void unsupportedGatewayChanged() {
    Network net = createNetwork("otherThenMgmtNetwork");
    mockExistingNetworks(net);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net);
    nic.setBootProtocol(NetworkBootProtocol.STATIC_IP);
    nic.setGateway(RandomUtils.instance().nextString(10));
    mockExistingIfaces(nic);
    nic.setGateway(RandomUtils.instance().nextString(10));
    VDS vds = mock(VDS.class);
    when(vds.getId()).thenReturn(Guid.Empty);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic), vds);
    when(vds.getVdsGroupCompatibilityVersion()).thenReturn(Version.v3_2);
    validateAndExpectViolation(helper, VdcBllMessages.NETWORK_ATTACH_ILLEGAL_GATEWAY, nic.getNetworkName());
}
#method_after
@Test
public void unsupportedGatewayChanged() {
    Network net = createNetwork("otherThenMgmtNetwork");
    mockExistingNetworks(net);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net);
    nic.setBootProtocol(NetworkBootProtocol.STATIC_IP);
    nic.setGateway(RandomUtils.instance().nextString(10));
    mockExistingIfaces(nic);
    nic.setGateway(RandomUtils.instance().nextString(10));
    VDS vds = mock(VDS.class);
    when(vds.getId()).thenReturn(Guid.Empty);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic), vds);
    when(vds.getVdsGroupCompatibilityVersion()).thenReturn(Version.v3_2);
    validateAndExpectViolation(helper, EngineMessage.NETWORK_ATTACH_ILLEGAL_GATEWAY, nic.getNetworkName());
}
#end_block

#method_before
@Test
public void ipChangedWhenEqualToHostname() {
    String hostName = "1.1.1.1";
    Network net = createNetwork("net");
    mockExistingNetworks(net);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net);
    nic.setBootProtocol(NetworkBootProtocol.STATIC_IP);
    nic.setAddress(hostName);
    mockExistingIfaces(nic);
    nic.setAddress(RandomUtils.instance().nextString(10));
    VDS vds = mock(VDS.class);
    when(vds.getHostName()).thenReturn(hostName);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic), vds);
    validateAndExpectViolation(helper, VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED);
}
#method_after
@Test
public void ipChangedWhenEqualToHostname() {
    String hostName = "1.1.1.1";
    Network net = createNetwork("net");
    mockExistingNetworks(net);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net);
    nic.setBootProtocol(NetworkBootProtocol.STATIC_IP);
    nic.setAddress(hostName);
    mockExistingIfaces(nic);
    nic.setAddress(RandomUtils.instance().nextString(10));
    VDS vds = mock(VDS.class);
    when(vds.getHostName()).thenReturn(hostName);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic), vds);
    validateAndExpectViolation(helper, EngineMessage.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED);
}
#end_block

#method_before
@Test
public void managementNetworkChangedCorrectlyWhenDhcpSet() {
    Network net = createManagementNetwork();
    mockExistingNetworks(net);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net);
    nic.setBootProtocol(NetworkBootProtocol.DHCP);
    nic.setAddress(RandomUtils.instance().nextString(10));
    mockExistingIfaces(nic);
    nic.setAddress(RandomUtils.instance().nextString(10));
    VDS vds = mock(VDS.class);
    when(vds.getId()).thenReturn(Guid.Empty);
    when(vds.getHostName()).thenReturn(RandomUtils.instance().nextString(10));
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic), vds);
    validateAndAssertNetworkModified(helper, net);
}
#method_after
@Test
public void managementNetworkChangedCorrectlyWhenDhcpSet() {
    Network net = createManagementNetwork();
    mockExistingNetworks(net);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net);
    nic.setBootProtocol(NetworkBootProtocol.STATIC_IP);
    nic.setAddress(RandomUtils.instance().nextString(10));
    mockExistingIfaces(nic);
    nic.setBootProtocol(NetworkBootProtocol.DHCP);
    nic.setAddress(RandomUtils.instance().nextString(10));
    VDS vds = mock(VDS.class);
    when(vds.getId()).thenReturn(Guid.Empty);
    when(vds.getHostName()).thenReturn(RandomUtils.instance().nextString(10));
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic), vds);
    validateAndAssertNetworkModified(helper, net);
}
#end_block

#method_before
public void managementNetworkChangedCorrectlyWithIpHostname() {
    Network net = createManagementNetwork();
    mockExistingNetworks(net);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net);
    nic.setBootProtocol(NetworkBootProtocol.STATIC_IP);
    nic.setAddress(RandomUtils.instance().nextString(10));
    mockExistingIfaces(nic);
    nic.setAddress(RandomUtils.instance().nextString(10));
    VDS vds = mock(VDS.class);
    when(vds.getId()).thenReturn(Guid.Empty);
    when(vds.getHostName()).thenReturn("1.1.1.1");
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic), vds);
    validateAndAssertNetworkModified(helper, net);
}
#method_after
@Test
public void managementNetworkChangedCorrectlyWithIpHostname() {
    Network net = createManagementNetwork();
    mockExistingNetworks(net);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net);
    nic.setBootProtocol(NetworkBootProtocol.STATIC_IP);
    nic.setAddress(RandomUtils.instance().nextString(10));
    mockExistingIfaces(nic);
    nic.setAddress(RandomUtils.instance().nextString(10));
    VDS vds = mock(VDS.class);
    when(vds.getId()).thenReturn(Guid.Empty);
    when(vds.getHostName()).thenReturn("1.1.1.1");
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic), vds);
    validateAndAssertNetworkModified(helper, net);
}
#end_block

#method_before
@Test
public void managementNetworkChangedIncorrectly() {
    String hostName = "1.1.1.1";
    Network net = createManagementNetwork();
    mockExistingNetworks(net);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net);
    nic.setBootProtocol(NetworkBootProtocol.STATIC_IP);
    nic.setAddress(hostName);
    mockExistingIfaces(nic);
    nic.setAddress(RandomUtils.instance().nextString(10));
    VDS vds = mock(VDS.class);
    when(vds.getId()).thenReturn(Guid.Empty);
    when(vds.getHostName()).thenReturn(hostName);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic), vds);
    validateAndExpectViolation(helper, VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED);
}
#method_after
@Test
public void managementNetworkChangedIncorrectly() {
    String hostName = "1.1.1.1";
    Network net = createManagementNetwork();
    mockExistingNetworks(net);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net);
    nic.setBootProtocol(NetworkBootProtocol.STATIC_IP);
    nic.setAddress(hostName);
    mockExistingIfaces(nic);
    nic.setAddress(RandomUtils.instance().nextString(10));
    VDS vds = mock(VDS.class);
    when(vds.getId()).thenReturn(Guid.Empty);
    when(vds.getHostName()).thenReturn(hostName);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic), vds);
    validateAndExpectViolation(helper, EngineMessage.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED);
}
#end_block

#method_before
private SetupNetworksHelper qosValuesTest(Network network, HostNetworkQos qos) {
    mockExistingNetworks(network);
    VdsNetworkInterface iface = createNicSyncedWithNetwork("eth0", network);
    iface.setQosOverridden(true);
    mockExistingIfaces(iface);
    iface.setQos(qos);
    return createHelper(createParametersForNics(iface), Version.v3_4);
}
#method_after
private SetupNetworksHelper qosValuesTest(Network network, HostNetworkQos qos) {
    mockExistingNetworks(network);
    VdsNetworkInterface iface = createNicSyncedWithNetwork("eth0", network);
    mockExistingIfaces(iface);
    iface.setQos(qos);
    return createHelper(createParametersForNics(iface), Version.v3_4);
}
#end_block

#method_before
private SetupNetworksHelper setupCompositeQosConfiguration(boolean constructBond, boolean qosOnAll, HostNetworkQos qos, Integer slaveSpeed, Integer masterSpeed, String bondOptions) {
    Network net1 = createNetwork("net1");
    net1.setVlanId(100);
    Network net2 = createNetwork("net2");
    net2.setVlanId(200);
    Network net3 = createNetwork("net3");
    net3.setVmNetwork(false);
    VdsNetworkInterface master = createNic(BOND_NAME, net3.getName());
    master.setSpeed(masterSpeed);
    VdsNetworkInterface vlan1 = createVlan(master.getName(), net1.getVlanId(), net1.getName());
    VdsNetworkInterface vlan2 = createVlan(master.getName(), net2.getVlanId(), net2.getName());
    vlan1.setQosOverridden(true);
    vlan1.setQos(qos);
    Guid qosId = Guid.newGuid();
    when(qosDao.get(qosId)).thenReturn(qos);
    net2.setQosId(qosId);
    net3.setQosId(qosOnAll ? qosId : null);
    mockExistingNetworks(net1, net2, net3);
    if (constructBond) {
        master.setBonded(true);
        VdsNetworkInterface slave1 = createNic("nic1", null);
        VdsNetworkInterface slave2 = createNic("nic2", null);
        slave2.setSpeed(slaveSpeed);
        master.setBondOptions(bondOptions);
        mockExistingIfaces(master, slave1, slave2);
        slave1.setBondName(master.getName());
        slave2.setBondName(master.getName());
        return createHelper(createParametersForNics(master, slave1, slave2, vlan1, vlan2), Version.v3_4);
    } else {
        mockExistingIfaces(master);
        return createHelper(createParametersForNics(master, vlan1, vlan2), Version.v3_4);
    }
}
#method_after
private SetupNetworksHelper setupCompositeQosConfiguration(boolean constructBond, boolean qosOnAll, HostNetworkQos qos, Integer slaveSpeed, Integer masterSpeed, String bondOptions) {
    Network net1 = createNetwork("net1");
    net1.setVlanId(100);
    Network net2 = createNetwork("net2");
    net2.setVlanId(200);
    Network net3 = createNetwork("net3");
    net3.setVmNetwork(false);
    VdsNetworkInterface master = createNic(BOND_NAME, net3.getName());
    master.setSpeed(masterSpeed);
    VdsNetworkInterface vlan1 = createVlan(master, net1.getVlanId(), net1.getName());
    VdsNetworkInterface vlan2 = createVlan(master, net2.getVlanId(), net2.getName());
    vlan1.setQos(qos);
    Guid qosId = Guid.newGuid();
    when(qosDao.get(qosId)).thenReturn(qos);
    NetworkAttachment networkAttachment = new NetworkAttachment();
    networkAttachment.setHostNetworkQos(qos);
    when(networkAttachmentDao.getNetworkAttachmentByNicIdAndNetworkId(master.getId(), net1.getId())).thenReturn(networkAttachment);
    net2.setQosId(qosId);
    net3.setQosId(qosOnAll ? qosId : null);
    mockExistingNetworks(net1, net2, net3);
    if (constructBond) {
        master.setBonded(true);
        VdsNetworkInterface slave1 = createNic("nic1", null);
        VdsNetworkInterface slave2 = createNic("nic2", null);
        slave2.setSpeed(slaveSpeed);
        master.setBondOptions(bondOptions);
        mockExistingIfaces(master, slave1, slave2);
        slave1.setBondName(master.getName());
        slave2.setBondName(master.getName());
        return createHelper(createParametersForNics(master, slave1, slave2, vlan1, vlan2), Version.v3_4);
    } else {
        mockExistingIfaces(master);
        return createHelper(createParametersForNics(master, vlan1, vlan2), Version.v3_4);
    }
}
#end_block

#method_before
@Test
public void qosNotConfiguredOnAllNetworks() {
    SetupNetworksHelper helper = setupCompositeQosConfiguration(false);
    validateAndExpectViolation(helper, VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_INTERFACES_WITHOUT_QOS, BOND_NAME);
}
#method_after
@Test
public void qosNotConfiguredOnAllNetworks() {
    SetupNetworksHelper helper = setupCompositeQosConfiguration(false);
    validateAndExpectViolation(helper, EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_INTERFACES_WITHOUT_QOS, BOND_NAME);
}
#end_block

#method_before
@Test
public void customPropertiesNotSupported() {
    Network network = createManagementNetwork();
    mockExistingNetworks(network);
    VdsNetworkInterface iface = createNicSyncedWithNetwork("eth0", network);
    mockExistingIfaces(iface);
    iface.setCustomProperties(createCustomProperties());
    SetupNetworksHelper helper = createHelper(createParametersForNics(iface));
    validateAndExpectViolation(helper, VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, network.getName());
}
#method_after
@Test
public void customPropertiesNotSupported() {
    Network network = createManagementNetwork();
    mockExistingNetworks(network);
    VdsNetworkInterface iface = createNicSyncedWithNetwork("eth0", network);
    mockExistingIfaces(iface);
    iface.setCustomProperties(createCustomProperties());
    SetupNetworksHelper helper = createHelper(createParametersForNics(iface));
    validateAndExpectViolation(helper, EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, network.getName());
}
#end_block

#method_before
@Test
public void customPropertiesBadInput() {
    Network network = createManagementNetwork();
    mockExistingNetworks(network);
    VdsNetworkInterface iface = createNicSyncedWithNetwork("eth0", network);
    mockExistingIfaces(iface);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("foo", "b@r");
    iface.setCustomProperties(customProperties);
    SetupNetworksHelper helper = createHelper(createParametersForNics(iface), Version.v3_5);
    validateAndExpectViolation(helper, VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, network.getName());
}
#method_after
@Test
public void customPropertiesBadInput() {
    Network network = createManagementNetwork();
    mockExistingNetworks(network);
    VdsNetworkInterface iface = createNicSyncedWithNetwork("eth0", network);
    mockExistingIfaces(iface);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("foo", "b@r");
    iface.setCustomProperties(customProperties);
    SetupNetworksHelper helper = createHelper(createParametersForNics(iface), Version.v3_5);
    validateAndExpectViolation(helper, EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, network.getName());
}
#end_block

#method_before
@Test
public void bridgePropertiesNonVm() {
    Network network = createManagementNetwork();
    network.setVmNetwork(false);
    mockExistingNetworks(network);
    VdsNetworkInterface iface = createNicSyncedWithNetwork("eth0", network);
    mockExistingIfaces(iface);
    iface.setCustomProperties(createCustomProperties());
    SetupNetworksHelper helper = createHelper(createParametersForNics(iface), Version.v3_5);
    validateAndExpectViolation(helper, VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, MANAGEMENT_NETWORK_NAME);
}
#method_after
@Test
public void bridgePropertiesNonVm() {
    Network network = createManagementNetwork();
    network.setVmNetwork(false);
    mockExistingNetworks(network);
    VdsNetworkInterface iface = createNicSyncedWithNetwork("eth0", network);
    mockExistingIfaces(iface);
    iface.setCustomProperties(createCustomProperties());
    SetupNetworksHelper helper = createHelper(createParametersForNics(iface), Version.v3_5);
    validateAndExpectViolation(helper, EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, MANAGEMENT_NETWORK_NAME);
}
#end_block

#method_before
/* --- Tests for external networks --- */
@Test
public void externalNetworkAttached() {
    Network net = createNetwork("net");
    net.setProvidedBy(new ProviderNetwork());
    mockExistingNetworks(net);
    VdsNetworkInterface nic = createNic("nic0", null);
    mockExistingIfaces(nic);
    nic.setNetworkName(net.getName());
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic));
    validateAndExpectViolation(helper, VdcBllMessages.ACTION_TYPE_FAILED_EXTERNAL_NETWORKS_CANNOT_BE_PROVISIONED);
}
#method_after
/* --- Tests for external networks --- */
@Test
public void externalNetworkAttached() {
    Network net = createNetwork("net");
    net.setProvidedBy(new ProviderNetwork());
    mockExistingNetworks(net);
    VdsNetworkInterface nic = createNic("nic0", null);
    mockExistingIfaces(nic);
    nic.setNetworkName(net.getName());
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic));
    validateAndExpectViolation(helper, EngineMessage.ACTION_TYPE_FAILED_EXTERNAL_NETWORKS_CANNOT_BE_PROVISIONED);
}
#end_block

#method_before
@Test
public void unsyncedNetworkModified() {
    Network net = createNetwork("net");
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net);
    nic.setBridged(!net.isVmNetwork());
    nic.setBootProtocol(NetworkBootProtocol.NONE);
    mockExistingNetworks(net);
    mockExistingIfaces(nic);
    nic.setBootProtocol(NetworkBootProtocol.DHCP);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic));
    validateAndExpectViolation(helper, VdcBllMessages.NETWORKS_NOT_IN_SYNC, net.getName());
}
#method_after
@Test
public void unsyncedNetworkModified() {
    Network net = createNetwork("net");
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net);
    nic.setBridged(!net.isVmNetwork());
    nic.setBootProtocol(NetworkBootProtocol.NONE);
    mockExistingNetworks(net);
    mockExistingIfaces(nic);
    nic.setBootProtocol(NetworkBootProtocol.DHCP);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic));
    validateAndExpectViolation(helper, EngineMessage.NETWORKS_NOT_IN_SYNC, net.getName());
}
#end_block

#method_before
@Test
public void unsyncedNetworkMovedToAnotherNic() {
    Network net = createNetwork("net");
    VdsNetworkInterface nic1 = createNicSyncedWithNetwork("nic0", net);
    nic1.setBridged(!net.isVmNetwork());
    VdsNetworkInterface nic2 = createNic("nic1", null);
    mockExistingNetworks(net);
    mockExistingIfaces(nic1, nic2);
    nic2.setNetworkName(nic1.getNetworkName());
    nic1.setNetworkName(null);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic1, nic2));
    validateAndExpectViolation(helper, VdcBllMessages.NETWORKS_NOT_IN_SYNC, net.getName());
}
#method_after
@Test
public void unsyncedNetworkMovedToAnotherNic() {
    Network net = createNetwork("net");
    VdsNetworkInterface nic1 = createNicSyncedWithNetwork("nic0", net);
    nic1.setBridged(!net.isVmNetwork());
    VdsNetworkInterface nic2 = createNic("nic1", null);
    mockExistingNetworks(net);
    mockExistingIfaces(nic1, nic2);
    nic2.setNetworkName(nic1.getNetworkName());
    nic1.setNetworkName(null);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic1, nic2));
    validateAndExpectViolation(helper, EngineMessage.NETWORKS_NOT_IN_SYNC, net.getName());
}
#end_block

#method_before
@Test
public void syncNetworkQosNotSupported() {
    Network network = createManagementNetwork();
    mockExistingNetworks(network);
    VdsNetworkInterface iface = createNicSyncedWithNetwork("eth0", network);
    mockExistingIfaces(iface);
    Guid qosId = Guid.newGuid();
    when(qosDao.get(qosId)).thenReturn(createQos());
    network.setQosId(qosId);
    SetupNetworksHelper helper = createHelper(createParametersForSync(iface));
    validateAndExpectViolation(helper, VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, MANAGEMENT_NETWORK_NAME);
}
#method_after
@Test
public void syncNetworkQosNotSupported() {
    Network network = createManagementNetwork();
    mockExistingNetworks(network);
    VdsNetworkInterface iface = createNicSyncedWithNetwork("eth0", network);
    mockExistingIfaces(iface);
    Guid qosId = Guid.newGuid();
    HostNetworkQos qos = createQos();
    when(qosDao.get(qosId)).thenReturn(qos);
    network.setQosId(qosId);
    SetupNetworksHelper helper = createHelper(createParametersForSync(iface));
    validateAndExpectViolation(helper, EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, MANAGEMENT_NETWORK_NAME);
}
#end_block

#method_before
@Test
public void vlanNetworkWithVmNetworkDenied() {
    Network net1 = createNetwork("net1");
    Network net2 = createNetwork("net2");
    net2.setVlanId(100);
    mockExistingNetworks(net1, net2);
    VdsNetworkInterface nic = createNic("nic0", null);
    VdsNetworkInterface vlanNic = createVlan(nic.getName(), net2.getVlanId(), net2.getName());
    mockExistingIfaces(nic, vlanNic);
    nic.setNetworkName(net1.getName());
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, vlanNic));
    final List<NetworkType> networksOnIface = Arrays.asList(NetworkType.VM, NetworkType.VLAN);
    when(networkExclusivenessValidator.isNetworkExclusive(networksOnIface)).thenReturn(false);
    validateAndExpectViolation(helper, NETWORK_INTERFACES_NOT_EXCLUSIVELY_USED_BY_NETWORK_MSG, nic.getName());
}
#method_after
@Test
public void vlanNetworkWithVmNetworkDenied() {
    Network net1 = createNetwork("net1");
    Network net2 = createNetwork("net2");
    net2.setVlanId(100);
    mockExistingNetworks(net1, net2);
    VdsNetworkInterface nic = createNic("nic0", null);
    VdsNetworkInterface vlanNic = createVlan(nic, net2.getVlanId(), net2.getName());
    mockExistingIfaces(nic, vlanNic);
    nic.setNetworkName(net1.getName());
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, vlanNic));
    final List<NetworkType> networksOnIface = Arrays.asList(NetworkType.VM, NetworkType.VLAN);
    when(networkExclusivenessValidator.isNetworkExclusive(networksOnIface)).thenReturn(false);
    validateAndExpectViolation(helper, EngineMessage.NETWORK_INTERFACES_NOT_EXCLUSIVELY_USED_BY_NETWORK, nic.getName());
}
#end_block

#method_before
@Test
public void vmNetworkWithVlanNetworkDenied() {
    Network net1 = createNetwork("net1");
    Network net2 = createNetwork("net2");
    net2.setVlanId(100);
    mockExistingNetworks(net1, net2);
    VdsNetworkInterface nic = createNic("nic0", null);
    VdsNetworkInterface vlanNic = createVlan(nic.getName(), net2.getVlanId(), net2.getName());
    mockExistingIfaces(nic, vlanNic);
    nic.setNetworkName(net1.getName());
    SetupNetworksHelper helper = createHelper(createParametersForNics(vlanNic, nic));
    final List<NetworkType> networksOnIface = Arrays.asList(NetworkType.VLAN, NetworkType.VM);
    when(networkExclusivenessValidator.isNetworkExclusive(networksOnIface)).thenReturn(false);
    validateAndExpectViolation(helper, NETWORK_INTERFACES_NOT_EXCLUSIVELY_USED_BY_NETWORK_MSG, nic.getName());
}
#method_after
@Test
public void vmNetworkWithVlanNetworkDenied() {
    Network net1 = createNetwork("net1");
    Network net2 = createNetwork("net2");
    net2.setVlanId(100);
    mockExistingNetworks(net1, net2);
    VdsNetworkInterface nic = createNic("nic0", null);
    VdsNetworkInterface vlanNic = createVlan(nic, net2.getVlanId(), net2.getName());
    mockExistingIfaces(nic, vlanNic);
    nic.setNetworkName(net1.getName());
    SetupNetworksHelper helper = createHelper(createParametersForNics(vlanNic, nic));
    final List<NetworkType> networksOnIface = Arrays.asList(NetworkType.VLAN, NetworkType.VM);
    when(networkExclusivenessValidator.isNetworkExclusive(networksOnIface)).thenReturn(false);
    validateAndExpectViolation(helper, EngineMessage.NETWORK_INTERFACES_NOT_EXCLUSIVELY_USED_BY_NETWORK, nic.getName());
}
#end_block

#method_before
@Test
public void unmanagedVlanNetworkWithVmNetworkDenied() {
    Network net1 = createNetwork("net1");
    Network net2 = createNetwork("net2");
    net2.setVlanId(100);
    mockExistingNetworks(net1);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net1);
    mockExistingIfaces(nic);
    VdsNetworkInterface vlanNic = createVlan(nic.getName(), net2.getVlanId(), net2.getName());
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, vlanNic));
    final List<NetworkType> networksOnIface = Arrays.asList(NetworkType.VM, NetworkType.VLAN);
    when(networkExclusivenessValidator.isNetworkExclusive(networksOnIface)).thenReturn(false);
    validateAndExpectViolation(helper, NETWORK_INTERFACES_NOT_EXCLUSIVELY_USED_BY_NETWORK_MSG, nic.getName());
}
#method_after
@Test
public void unmanagedVlanNetworkWithVmNetworkDenied() {
    Network net1 = createNetwork("net1");
    Network net2 = createNetwork("net2");
    net2.setVlanId(100);
    mockExistingNetworks(net1);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net1);
    mockExistingIfaces(nic);
    VdsNetworkInterface vlanNic = createVlan(nic, net2.getVlanId(), net2.getName());
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, vlanNic));
    final List<NetworkType> networksOnIface = Arrays.asList(NetworkType.VM, NetworkType.VLAN);
    when(networkExclusivenessValidator.isNetworkExclusive(networksOnIface)).thenReturn(false);
    validateAndExpectViolation(helper, EngineMessage.NETWORK_INTERFACES_NOT_EXCLUSIVELY_USED_BY_NETWORK, nic.getName());
}
#end_block

#method_before
@Test
public void fakeVlanNicWithVmNetworkDenied() {
    Network net1 = createNetwork("net1");
    Network net2 = createNetwork("net2");
    net2.setVlanId(100);
    mockExistingNetworks(net1, net2);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net1);
    mockExistingIfaces(nic);
    VdsNetworkInterface fakeVlanNic = createVlan(nic.getName(), 100, net2.getName());
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, fakeVlanNic));
    final List<NetworkType> networksOnIface = Arrays.asList(NetworkType.VM, NetworkType.VLAN);
    when(networkExclusivenessValidator.isNetworkExclusive(networksOnIface)).thenReturn(false);
    validateAndExpectViolation(helper, NETWORK_INTERFACES_NOT_EXCLUSIVELY_USED_BY_NETWORK_MSG, nic.getName());
}
#method_after
@Test
public void fakeVlanNicWithVmNetworkDenied() {
    Network net1 = createNetwork("net1");
    Network net2 = createNetwork("net2");
    net2.setVlanId(100);
    mockExistingNetworks(net1, net2);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net1);
    mockExistingIfaces(nic);
    VdsNetworkInterface fakeVlanNic = createVlan(nic, 100, net2.getName());
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, fakeVlanNic));
    final List<NetworkType> networksOnIface = Arrays.asList(NetworkType.VM, NetworkType.VLAN);
    when(networkExclusivenessValidator.isNetworkExclusive(networksOnIface)).thenReturn(false);
    validateAndExpectViolation(helper, EngineMessage.NETWORK_INTERFACES_NOT_EXCLUSIVELY_USED_BY_NETWORK, nic.getName());
}
#end_block

#method_before
@Test
public void nonVmNetworkWithVlanVmNetwork() {
    Network net1 = createNetwork("net1");
    net1.setVmNetwork(false);
    Network net2 = createNetwork("net2");
    net2.setVlanId(200);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net1);
    VdsNetworkInterface vlan = createVlan(nic.getName(), net2.getVlanId(), net2.getName());
    mockExistingNetworks(net1, net2);
    mockExistingIfaces(nic);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, vlan));
    validateAndExpectNoViolations(helper);
}
#method_after
@Test
public void nonVmNetworkWithVlanVmNetwork() {
    Network net1 = createNetwork("net1");
    net1.setVmNetwork(false);
    Network net2 = createNetwork("net2");
    net2.setVlanId(200);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net1);
    VdsNetworkInterface vlan = createVlan(nic, net2.getVlanId(), net2.getName());
    mockExistingNetworks(net1, net2);
    mockExistingIfaces(nic);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, vlan));
    validateAndExpectNoViolations(helper);
}
#end_block

#method_before
@Test
public void twoVlanVmNetworks() {
    Network net1 = createNetwork("net1");
    net1.setVlanId(100);
    Network net2 = createNetwork("net2");
    net2.setVlanId(200);
    VdsNetworkInterface nic = createNic("nic0", null);
    VdsNetworkInterface vlan1 = createVlan(nic.getName(), net1.getVlanId(), net1.getName());
    VdsNetworkInterface vlan2 = createVlan(nic.getName(), net2.getVlanId(), net2.getName());
    mockExistingNetworks(net1, net2);
    mockExistingIfaces(nic);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, vlan1, vlan2));
    validateAndExpectNoViolations(helper);
}
#method_after
@Test
public void twoVlanVmNetworks() {
    Network net1 = createNetwork("net1");
    net1.setVlanId(100);
    Network net2 = createNetwork("net2");
    net2.setVlanId(200);
    VdsNetworkInterface nic = createNic("nic0", null);
    VdsNetworkInterface vlan1 = createVlan(nic, net1.getVlanId(), net1.getName());
    VdsNetworkInterface vlan2 = createVlan(nic, net2.getVlanId(), net2.getName());
    mockExistingNetworks(net1, net2);
    mockExistingIfaces(nic);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, vlan1, vlan2));
    validateAndExpectNoViolations(helper);
}
#end_block

#method_before
/* --- Tests for bonds functionality --- */
@Test
public void bondWithNoSlaves() {
    VdsNetworkInterface bond = createBond(BOND_NAME, null);
    mockExistingIfaces(bond);
    SetupNetworksHelper helper = createHelper(createParametersForNics(bond));
    validateAndExpectViolation(helper, VdcBllMessages.NETWORK_BONDS_INVALID_SLAVE_COUNT, bond.getName());
}
#method_after
/* --- Tests for bonds functionality --- */
@Test
public void bondWithNoSlaves() {
    VdsNetworkInterface bond = createBond(BOND_NAME, null);
    mockExistingIfaces(bond);
    SetupNetworksHelper helper = createHelper(createParametersForNics(bond));
    validateAndExpectViolation(helper, EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bond.getName());
}
#end_block

#method_before
@Test
public void onlyOneSlaveForBonding() {
    VdsNetworkInterface bond = createBond(BOND_NAME, null);
    List<VdsNetworkInterface> slaves = Arrays.asList(createNic("nic0", null));
    mockExistingIfacesWithBond(bond, slaves);
    SetupNetworksHelper helper = createHelper(createParametersForBond(bond, slaves));
    validateAndExpectViolation(helper, VdcBllMessages.NETWORK_BONDS_INVALID_SLAVE_COUNT, bond.getName());
}
#method_after
@Test
public void onlyOneSlaveForBonding() {
    VdsNetworkInterface bond = createBond(BOND_NAME, null);
    List<VdsNetworkInterface> slaves = Collections.singletonList(createNic("nic0", null));
    mockExistingIfacesWithBond(bond, slaves);
    SetupNetworksHelper helper = createHelper(createParametersForBond(bond, slaves));
    validateAndExpectViolation(helper, EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bond.getName());
}
#end_block

#method_before
@Test
public void sameBondNameSentTwice() {
    VdsNetworkInterface bond = createBond(BOND_NAME, null);
    mockExistingIfaces(bond);
    SetupNetworksHelper helper = createHelper(createParametersForNics(bond, bond));
    validateAndExpectViolation(helper, VdcBllMessages.NETWORK_INTERFACES_ALREADY_SPECIFIED, bond.getName());
}
#method_after
@Test
public void sameBondNameSentTwice() {
    VdsNetworkInterface bond = createBond(BOND_NAME, null);
    mockExistingIfaces(bond);
    SetupNetworksHelper helper = createHelper(createParametersForNics(bond, bond));
    validateAndExpectViolation(helper, EngineMessage.NETWORK_INTERFACES_ALREADY_SPECIFIED, bond.getName());
}
#end_block

#method_before
@Test
public void bondGrew() {
    VdsNetworkInterface bond = createBond(BOND_NAME, "net");
    List<VdsNetworkInterface> slaves = createNics(bond.getName(), RandomUtils.instance().nextInt(3, 100));
    slaves.get(0).setBondName(null);
    mockExistingIfacesWithBond(bond, slaves);
    slaves.get(0).setBondName(bond.getName());
    SetupNetworksParameters parameters = createParametersForBond(bond, slaves);
    SetupNetworksHelper helper = createHelper(parameters);
    validateAndExpectNoViolations(helper);
    assertBondModified(helper, bond);
    assertNoNetworksModified(helper);
    assertNoNetworksRemoved(helper);
    assertNoBondsRemoved(helper);
}
#method_after
@Test
public void bondGrew() {
    Network network = createNetwork("network");
    VdsNetworkInterface bond = createBond(BOND_NAME, "network");
    List<VdsNetworkInterface> slaves = createNics(bond.getName(), RandomUtils.instance().nextInt(3, 100));
    slaves.get(0).setBondName(null);
    mockExistingIfacesWithBond(bond, slaves);
    mockExistingNetworks(network);
    slaves.get(0).setBondName(bond.getName());
    @SuppressWarnings("deprecation")
    SetupNetworksParameters parameters = createParametersForBond(bond, slaves);
    SetupNetworksHelper helper = createHelper(parameters);
    validateAndExpectNoViolations(helper);
    assertBondModified(helper, bond);
    assertNoNetworksModified(helper);
    assertNoNetworksRemoved(helper);
    assertNoBondsRemoved(helper);
}
#end_block

#method_before
@Test
public void bondShrank() {
    VdsNetworkInterface bond = createBond(BOND_NAME, "net");
    List<VdsNetworkInterface> slaves = createNics(bond.getName(), RandomUtils.instance().nextInt(3, 100));
    mockExistingIfacesWithBond(bond, slaves);
    slaves.get(0).setBondName(null);
    SetupNetworksParameters parameters = new SetupNetworksParameters();
    parameters.setInterfaces(slaves);
    parameters.getInterfaces().add(bond);
    SetupNetworksHelper helper = createHelper(parameters);
    validateAndExpectNoViolations(helper);
    assertBondModified(helper, bond);
    assertNoNetworksModified(helper);
    assertNoNetworksRemoved(helper);
    assertNoBondsRemoved(helper);
}
#method_after
@Test
public void bondShrank() {
    VdsNetworkInterface bond = createBond(BOND_NAME, "net");
    List<VdsNetworkInterface> slaves = createNics(bond.getName(), RandomUtils.instance().nextInt(3, 100));
    mockExistingIfacesWithBond(bond, slaves);
    slaves.get(0).setBondName(null);
    // noinspection deprecation
    SetupNetworksParameters parameters = new SetupNetworksParameters();
    parameters.setInterfaces(slaves);
    parameters.getInterfaces().add(bond);
    SetupNetworksHelper helper = createHelper(parameters);
    validateAndExpectNoViolations(helper);
    assertBondModified(helper, bond);
    assertNoNetworksModified(helper);
    assertNoNetworksRemoved(helper);
    assertNoBondsRemoved(helper);
}
#end_block

#method_before
@Test
public void bondWithNetworkDidntChange() {
    VdsNetworkInterface bond = createBond(BOND_NAME, "net");
    List<VdsNetworkInterface> ifaces = createNics(bond.getName());
    mockExistingIfacesWithBond(bond, ifaces);
    SetupNetworksParameters parameters = new SetupNetworksParameters();
    ifaces.add(bond);
    parameters.setInterfaces(ifaces);
    SetupNetworksHelper helper = createHelper(parameters);
    validateAndExpectNoViolations(helper);
    assertNoBondsModified(helper);
    assertNoNetworksModified(helper);
    assertNoBondsRemoved(helper);
    assertNoNetworksRemoved(helper);
}
#method_after
@Test
public void bondWithNetworkDidntChange() {
    Network network = createNetwork("network");
    VdsNetworkInterface bond = createBond(BOND_NAME, network.getName());
    List<VdsNetworkInterface> ifaces = createNics(bond.getName());
    mockExistingIfacesWithBond(bond, ifaces);
    mockExistingNetworks(network);
    // noinspection deprecation
    @SuppressWarnings("deprecation")
    SetupNetworksParameters parameters = new SetupNetworksParameters();
    ifaces.add(bond);
    parameters.setInterfaces(ifaces);
    SetupNetworksHelper helper = createHelper(parameters);
    validateAndExpectNoViolations(helper);
    assertNoBondsModified(helper);
    assertNoNetworksModified(helper);
    assertNoBondsRemoved(helper);
    assertNoNetworksRemoved(helper);
}
#end_block

#method_before
@Test
public void bondWithNoNetworkDidntChange() {
    VdsNetworkInterface bond = createBond(BOND_NAME, null);
    List<VdsNetworkInterface> ifaces = createNics(bond.getName());
    mockExistingIfacesWithBond(bond, ifaces);
    SetupNetworksParameters parameters = new SetupNetworksParameters();
    ifaces.add(bond);
    parameters.setInterfaces(ifaces);
    SetupNetworksHelper helper = createHelper(parameters);
    validateAndExpectNoViolations(helper);
    assertNoBondsModified(helper);
    assertNoNetworksModified(helper);
    assertNoBondsRemoved(helper);
    assertNoNetworksRemoved(helper);
}
#method_after
@Test
public void bondWithNoNetworkDidntChange() {
    VdsNetworkInterface bond = createBond(BOND_NAME, null);
    List<VdsNetworkInterface> ifaces = createNics(bond.getName());
    mockExistingIfacesWithBond(bond, ifaces);
    // noinspection deprecation
    SetupNetworksParameters parameters = new SetupNetworksParameters();
    ifaces.add(bond);
    parameters.setInterfaces(ifaces);
    SetupNetworksHelper helper = createHelper(parameters);
    validateAndExpectNoViolations(helper);
    assertNoBondsModified(helper);
    assertNoNetworksModified(helper);
    assertNoBondsRemoved(helper);
    assertNoNetworksRemoved(helper);
}
#end_block

#method_before
@Test
public void bondWithNetworkAttached() {
    Network network = createNetwork("net");
    VdsNetworkInterface bond = createBond(BOND_NAME, null);
    List<VdsNetworkInterface> ifaces = createNics(null);
    mockExistingNetworks(network);
    mockExistingIfacesWithBond(bond, ifaces);
    bond.setNetworkName(network.getName());
    SetupNetworksParameters parameters = createParametersForBond(bond, ifaces);
    SetupNetworksHelper helper = createHelper(parameters);
    validateAndExpectNoViolations(helper);
    // The expected network name is null, since the bond didn't change from the one in the DB.
    bond.setNetworkName(null);
    assertBondModified(helper, bond);
    assertNetworkModified(helper, network);
    assertNoBondsRemoved(helper);
    assertNoNetworksRemoved(helper);
}
#method_after
@Test
public void bondWithNetworkAttached() {
    Network network = createNetwork("net");
    VdsNetworkInterface bond = createBond(BOND_NAME, null);
    List<VdsNetworkInterface> ifaces = createNics(null);
    mockExistingNetworks(network);
    mockExistingIfacesWithBond(bond, ifaces);
    bond.setNetworkName(network.getName());
    // noinspection deprecation
    SetupNetworksParameters parameters = createParametersForBond(bond, ifaces);
    SetupNetworksHelper helper = createHelper(parameters);
    validateAndExpectNoViolations(helper);
    // The expected network name is null, since the bond didn't change from the one in the DB.
    bond.setNetworkName(null);
    assertBondModified(helper, bond);
    assertNetworkModified(helper, network);
    assertNoBondsRemoved(helper);
    assertNoNetworksRemoved(helper);
}
#end_block

#method_before
@Test
public void bondWithNoNetowrkAttached() {
    VdsNetworkInterface bond = createBond(BOND_NAME, null);
    List<VdsNetworkInterface> ifacesToBond = createNics(null);
    SetupNetworksParameters parameters = createParametersForBond(bond, ifacesToBond);
    SetupNetworksHelper helper = createHelper(parameters);
    mockExistingIfacesWithBond(bond, ifacesToBond);
    validateAndExpectNoViolations(helper);
    assertBondModified(helper, bond);
    assertNoNetworksModified(helper);
    assertNoBondsRemoved(helper);
    assertNoNetworksRemoved(helper);
}
#method_after
@Test
public void bondWithNoNetowrkAttached() {
    VdsNetworkInterface bond = createBond(BOND_NAME, null);
    List<VdsNetworkInterface> ifacesToBond = createNics(null);
    // noinspection deprecation
    SetupNetworksParameters parameters = createParametersForBond(bond, ifacesToBond);
    SetupNetworksHelper helper = createHelper(parameters);
    mockExistingIfacesWithBond(bond, ifacesToBond);
    validateAndExpectNoViolations(helper);
    assertBondModified(helper, bond);
    assertNoNetworksModified(helper);
    assertNoBondsRemoved(helper);
    assertNoNetworksRemoved(helper);
}
#end_block

#method_before
@Test
public void bondWithNetworkRemoved() {
    VdsNetworkInterface bond = createBond(BOND_NAME, "net");
    List<VdsNetworkInterface> slaves = createNics(bond.getName());
    mockExistingIfacesWithBond(bond, slaves);
    SetupNetworksParameters parameters = new SetupNetworksParameters();
    for (VdsNetworkInterface slave : slaves) {
        parameters.getInterfaces().add(enslaveOrReleaseNIC(slave, null));
    }
    SetupNetworksHelper helper = createHelper(parameters);
    validateAndExpectNoViolations(helper);
    assertNoBondsModified(helper);
    assertNoNetworksModified(helper);
    assertNetworkRemoved(helper, bond.getNetworkName());
    assertBondRemoved(helper, bond.getName());
}
#method_after
@Test
public void bondWithNetworkRemoved() {
    VdsNetworkInterface bond = createBond(BOND_NAME, "net");
    List<VdsNetworkInterface> slaves = createNics(bond.getName());
    mockExistingIfacesWithBond(bond, slaves);
    // noinspection deprecation
    SetupNetworksParameters parameters = new SetupNetworksParameters();
    for (VdsNetworkInterface slave : slaves) {
        parameters.getInterfaces().add(enslaveOrReleaseNIC(slave, null));
    }
    SetupNetworksHelper helper = createHelper(parameters);
    validateAndExpectNoViolations(helper);
    assertNoBondsModified(helper);
    assertNoNetworksModified(helper);
    assertNetworkRemoved(helper, bond.getNetworkName());
    assertBondRemoved(helper, bond.getName());
}
#end_block

#method_before
@Test
public void networkRemovedFromBond() {
    String networkName = "net";
    VdsNetworkInterface bond = createBond(BOND_NAME, networkName);
    List<VdsNetworkInterface> slaves = createNics(bond.getName());
    mockExistingIfacesWithBond(bond, slaves);
    bond.setNetworkName(null);
    SetupNetworksParameters parameters = createParametersForBond(bond, slaves);
    SetupNetworksHelper helper = createHelper(parameters);
    validateAndExpectNoViolations(helper);
    assertNoBondsModified(helper);
    assertNoNetworksModified(helper);
    assertNetworkRemoved(helper, networkName);
    assertNoBondsRemoved(helper);
}
#method_after
@Test
public void networkRemovedFromBond() {
    String networkName = "net";
    VdsNetworkInterface bond = createBond(BOND_NAME, networkName);
    List<VdsNetworkInterface> slaves = createNics(bond.getName());
    mockExistingIfacesWithBond(bond, slaves);
    bond.setNetworkName(null);
    // noinspection deprecation
    SetupNetworksParameters parameters = createParametersForBond(bond, slaves);
    SetupNetworksHelper helper = createHelper(parameters);
    validateAndExpectNoViolations(helper);
    assertNoBondsModified(helper);
    assertNoNetworksModified(helper);
    assertNetworkRemoved(helper, networkName);
    assertNoBondsRemoved(helper);
}
#end_block

#method_before
/* --- Tests for VLANs functionality --- */
@Test
public void vlanOverBond() {
    Network network = createNetwork("net");
    network.setVlanId(100);
    VdsNetworkInterface bond = createBond(BOND_NAME, null);
    List<VdsNetworkInterface> ifacesToBond = createNics(null);
    mockExistingNetworks(network);
    mockExistingIfacesWithBond(bond, ifacesToBond);
    SetupNetworksParameters parameters = createParametersForBond(bond, ifacesToBond);
    parameters.getInterfaces().add(createVlan(bond.getName(), 100, network.getName()));
    SetupNetworksHelper helper = createHelper(parameters);
    validateAndExpectNoViolations(helper);
    assertBondModified(helper, bond);
    assertNetworkModified(helper, network);
    assertNoBondsRemoved(helper);
    assertNoNetworksRemoved(helper);
}
#method_after
/* --- Tests for VLANs functionality --- */
@Test
public void vlanOverBond() {
    Network network = createNetwork("net");
    network.setVlanId(100);
    VdsNetworkInterface bond = createBond(BOND_NAME, null);
    List<VdsNetworkInterface> ifacesToBond = createNics(null);
    mockExistingNetworks(network);
    mockExistingIfacesWithBond(bond, ifacesToBond);
    // noinspection deprecation
    SetupNetworksParameters parameters = createParametersForBond(bond, ifacesToBond);
    parameters.getInterfaces().add(createVlan(bond, 100, network.getName()));
    SetupNetworksHelper helper = createHelper(parameters);
    validateAndExpectNoViolations(helper);
    assertBondModified(helper, bond);
    assertNetworkModified(helper, network);
    assertNoBondsRemoved(helper);
    assertNoNetworksRemoved(helper);
}
#end_block

#method_before
@Test
public void vlanBondNameMismatch() {
    VdsNetworkInterface bond = createBond(BOND_NAME, null);
    List<VdsNetworkInterface> ifacesToBond = createNics(null);
    SetupNetworksParameters parameters = createParametersForBond(bond, ifacesToBond);
    String ifaceName = bond.getName() + "1";
    parameters.getInterfaces().add(createVlan(ifaceName, 100, "net"));
    mockExistingIfacesWithBond(bond, ifacesToBond);
    SetupNetworksHelper helper = createHelper(parameters);
    validateAndExpectViolation(helper, VdcBllMessages.NETWORK_INTERFACES_DONT_EXIST, ifaceName);
}
#method_after
@Test
public void vlanBondNameMismatch() {
    VdsNetworkInterface bond = createBond(BOND_NAME, null);
    VdsNetworkInterface anotherBond = createBond(BOND_NAME + "1", null);
    List<VdsNetworkInterface> ifacesToBond = createNics(null);
    // noinspection deprecation
    SetupNetworksParameters parameters = createParametersForBond(bond, ifacesToBond);
    parameters.getInterfaces().add(createVlan(anotherBond, 100, "net"));
    mockExistingIfacesWithBond(bond, ifacesToBond);
    SetupNetworksHelper helper = createHelper(parameters);
    validateAndExpectViolation(helper, EngineMessage.NETWORK_INTERFACES_DONT_EXIST, anotherBond.getName());
}
#end_block

#method_before
@Test
public void unmanagedVlanAddedToNic() {
    VdsNetworkInterface nic = createNic("nic0", null);
    mockExistingIfaces(nic);
    String networkName = "net";
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, createVlan(nic.getName(), 100, networkName)));
    validateAndExpectViolation(helper, VdcBllMessages.NETWORKS_DONT_EXIST_IN_CLUSTER, networkName);
}
#method_after
@Test
public void unmanagedVlanAddedToNic() {
    VdsNetworkInterface nic = createNic("nic0", null);
    mockExistingIfaces(nic);
    String networkName = "net";
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, createVlan(nic, 100, networkName)));
    validateAndExpectViolation(helper, EngineMessage.NETWORKS_DONT_EXIST_IN_CLUSTER, networkName);
}
#end_block

#method_before
@Test
public void networkWithTheSameMTUAddedToNic() {
    Network net = createNetwork("nonVmMtu9000");
    net.setVmNetwork(false);
    net.setMtu(9000);
    Network newNet = createNetwork("vlanVmMtu9000");
    newNet.setMtu(9000);
    newNet.setVlanId(100);
    mockExistingNetworks(net, newNet);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net);
    mockExistingIfaces(nic);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, createVlan(nic.getName(), newNet.getVlanId(), newNet.getName())));
    validateAndExpectNoViolations(helper);
}
#method_after
@Test
public void networkWithTheSameMTUAddedToNic() {
    Network net = createNetwork("nonVmMtu9000");
    net.setVmNetwork(false);
    net.setMtu(9000);
    Network newNet = createNetwork("vlanVmMtu9000");
    newNet.setMtu(9000);
    newNet.setVlanId(100);
    mockExistingNetworks(net, newNet);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net);
    mockExistingIfaces(nic);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, createVlan(nic, newNet.getVlanId(), newNet.getName())));
    validateAndExpectNoViolations(helper);
}
#end_block

#method_before
@Test
public void nonVmWithSameMTUAddedToNic() {
    Network net = createNetwork("vlanVmMtu9000");
    net.setVlanId(100);
    net.setMtu(9000);
    Network newNet = createNetwork("nonVmMtu9000");
    newNet.setVmNetwork(false);
    newNet.setMtu(9000);
    mockExistingNetworks(net, newNet);
    VdsNetworkInterface nic = createNic("nic0", null);
    VdsNetworkInterface nicWithVlan = createVlanSyncedWithNetwork(nic.getName(), net);
    mockExistingIfaces(nic, nicWithVlan);
    nic.setNetworkName(newNet.getName());
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, nicWithVlan));
    validateAndExpectNoViolations(helper);
}
#method_after
@Test
public void nonVmWithSameMTUAddedToNic() {
    Network net = createNetwork("vlanVmMtu9000");
    net.setVlanId(100);
    net.setMtu(9000);
    Network newNet = createNetwork("nonVmMtu9000");
    newNet.setVmNetwork(false);
    newNet.setMtu(9000);
    mockExistingNetworks(net, newNet);
    VdsNetworkInterface nic = createNic("nic0", null);
    VdsNetworkInterface nicWithVlan = createVlanSyncedWithNetwork(nic, net);
    mockExistingIfaces(nic, nicWithVlan);
    nic.setNetworkName(newNet.getName());
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, nicWithVlan));
    validateAndExpectNoViolations(helper);
}
#end_block

#method_before
@Test
public void networkWithTheSameDefaultMTUAddedToNic() {
    Network net = createNetwork("nonVm");
    net.setVmNetwork(false);
    Network newNet = createNetwork("vlanVm");
    newNet.setVlanId(100);
    mockExistingNetworks(net, newNet);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net);
    mockExistingIfaces(nic);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, createVlan(nic.getName(), newNet.getVlanId(), newNet.getName())));
    validateAndExpectNoViolations(helper);
}
#method_after
@Test
public void networkWithTheSameDefaultMTUAddedToNic() {
    Network net = createNetwork("nonVm");
    net.setVmNetwork(false);
    Network newNet = createNetwork("vlanVm");
    newNet.setVlanId(100);
    mockExistingNetworks(net, newNet);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net);
    mockExistingIfaces(nic);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, createVlan(nic, newNet.getVlanId(), newNet.getName())));
    validateAndExpectNoViolations(helper);
}
#end_block

#method_before
@Test
public void vlanWithDifferentMTUAddedToNic() {
    Network net = createNetwork("nonVmMtu5000");
    net.setVmNetwork(false);
    net.setMtu(5000);
    Network newNet = createNetwork("vlanVmMtu9000");
    newNet.setVlanId(100);
    newNet.setMtu(9000);
    mockExistingNetworks(net, newNet);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net);
    mockExistingIfaces(nic);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, createVlan(nic.getName(), newNet.getVlanId(), newNet.getName())));
    validateAndExpectMtuValidation(helper, net, newNet);
}
#method_after
@Test
public void vlanWithDifferentMTUAddedToNic() {
    Network net = createNetwork("nonVmMtu5000");
    net.setVmNetwork(false);
    net.setMtu(5000);
    Network newNet = createNetwork("vlanVmMtu9000");
    newNet.setVlanId(100);
    newNet.setMtu(9000);
    mockExistingNetworks(net, newNet);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net);
    mockExistingIfaces(nic);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, createVlan(nic, newNet.getVlanId(), newNet.getName())));
    validateAndExpectMtuValidation(helper, net, newNet);
}
#end_block

#method_before
@Test
public void nonVmWithDifferentMTUAddedToNic() {
    Network net = createNetwork("vlanVmMtu9000");
    net.setVlanId(100);
    net.setMtu(9000);
    Network newNet = createNetwork("nonVmMtu5000");
    newNet.setVmNetwork(false);
    newNet.setMtu(5000);
    mockExistingNetworks(net, newNet);
    VdsNetworkInterface nic = createNic("nic0", null);
    VdsNetworkInterface nicWithVlan = createVlanSyncedWithNetwork(nic.getName(), net);
    mockExistingIfaces(nic, nicWithVlan);
    nic.setNetworkName(newNet.getName());
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, nicWithVlan));
    validateAndExpectMtuValidation(helper, newNet, net);
}
#method_after
@Test
public void nonVmWithDifferentMTUAddedToNic() {
    Network net = createNetwork("vlanVmMtu9000");
    net.setVlanId(100);
    net.setMtu(9000);
    Network newNet = createNetwork("nonVmMtu5000");
    newNet.setVmNetwork(false);
    newNet.setMtu(5000);
    mockExistingNetworks(net, newNet);
    VdsNetworkInterface nic = createNic("nic0", null);
    VdsNetworkInterface nicWithVlan = createVlanSyncedWithNetwork(nic, net);
    mockExistingIfaces(nic, nicWithVlan);
    nic.setNetworkName(newNet.getName());
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, nicWithVlan));
    validateAndExpectMtuValidation(helper, newNet, net);
}
#end_block

#method_before
@Test
public void nonVmWithDefaultMTUAddedToNic() {
    Network net = createNetwork("vlanVmMtu9000");
    net.setVlanId(100);
    net.setMtu(9000);
    Network newNet = createNetwork("nonVm");
    newNet.setVmNetwork(false);
    mockExistingNetworks(net, newNet);
    VdsNetworkInterface nic = createNic("nic0", null);
    VdsNetworkInterface nicWithVlan = createVlanSyncedWithNetwork(nic.getName(), net);
    mockExistingIfaces(nic, nicWithVlan);
    nic.setNetworkName(newNet.getName());
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, nicWithVlan));
    validateAndExpectMtuValidation(helper, newNet, net);
}
#method_after
@Test
public void nonVmWithDefaultMTUAddedToNic() {
    Network net = createNetwork("vlanVmMtu9000");
    net.setVlanId(100);
    net.setMtu(9000);
    Network newNet = createNetwork("nonVm");
    newNet.setVmNetwork(false);
    mockExistingNetworks(net, newNet);
    VdsNetworkInterface nic = createNic("nic0", null);
    VdsNetworkInterface nicWithVlan = createVlanSyncedWithNetwork(nic, net);
    mockExistingIfaces(nic, nicWithVlan);
    nic.setNetworkName(newNet.getName());
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, nicWithVlan));
    validateAndExpectMtuValidation(helper, newNet, net);
}
#end_block

#method_before
@Test
public void nonVmVlanWithDifferentMTUAddedToNic() {
    Network net = createNetwork("vlanVmMtu9000");
    net.setVlanId(100);
    net.setMtu(9000);
    Network newNet = createNetwork("vlanNonVmMtu5000");
    newNet.setVlanId(200);
    newNet.setMtu(5000);
    newNet.setVmNetwork(false);
    mockExistingNetworks(net, newNet);
    VdsNetworkInterface nic = createNic("nic0", null);
    VdsNetworkInterface nicWithVlan = createVlanSyncedWithNetwork(nic.getName(), net);
    mockExistingIfaces(nic, nicWithVlan);
    VdsNetworkInterface nicWithNonVmVlan = createVlan(nic.getName(), newNet.getVlanId(), newNet.getName());
    nicWithNonVmVlan.setMtu(newNet.getMtu());
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, nicWithVlan, nicWithNonVmVlan));
    validateAndExpectNoViolations(helper);
}
#method_after
@Test
public void nonVmVlanWithDifferentMTUAddedToNic() {
    Network net = createNetwork("vlanVmMtu9000");
    net.setVlanId(100);
    net.setMtu(9000);
    Network newNet = createNetwork("vlanNonVmMtu5000");
    newNet.setVlanId(200);
    newNet.setMtu(5000);
    newNet.setVmNetwork(false);
    mockExistingNetworks(net, newNet);
    VdsNetworkInterface nic = createNic("nic0", null);
    VdsNetworkInterface nicWithVlan = createVlanSyncedWithNetwork(nic, net);
    mockExistingIfaces(nic, nicWithVlan);
    VdsNetworkInterface nicWithNonVmVlan = createVlan(nic, newNet.getVlanId(), newNet.getName());
    nicWithNonVmVlan.setMtu(newNet.getMtu());
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, nicWithVlan, nicWithNonVmVlan));
    validateAndExpectNoViolations(helper);
}
#end_block

#method_before
@Test
public void networksWithDifferentMTUAddedToNic() {
    Network net = createNetwork("nonVmMtu5000");
    net.setVmNetwork(false);
    net.setMtu(5000);
    Network newNet = createNetwork("vlanVmMtu9000");
    newNet.setVlanId(100);
    newNet.setMtu(9000);
    mockExistingNetworks(net, newNet);
    VdsNetworkInterface nic = createNic("nic0", null);
    mockExistingIfaces(nic);
    nic.setNetworkName(net.getName());
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, createVlan(nic.getName(), newNet.getVlanId(), newNet.getName())));
    validateAndExpectMtuValidation(helper, net, newNet);
}
#method_after
@Test
public void networksWithDifferentMTUAddedToNic() {
    Network net = createNetwork("nonVmMtu5000");
    net.setVmNetwork(false);
    net.setMtu(5000);
    Network newNet = createNetwork("vlanVmMtu9000");
    newNet.setVlanId(100);
    newNet.setMtu(9000);
    mockExistingNetworks(net, newNet);
    VdsNetworkInterface nic = createNic("nic0", null);
    mockExistingIfaces(nic);
    nic.setNetworkName(net.getName());
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, createVlan(nic, newNet.getVlanId(), newNet.getName())));
    validateAndExpectMtuValidation(helper, net, newNet);
}
#end_block

#method_before
private void validateAndExpectMtuValidation(SetupNetworksHelper helper, Network net1, Network net2) {
    validateAndExpectViolation(helper, VdcBllMessages.NETWORK_MTU_DIFFERENCES, String.format("[%s(%s), %s(%d)]", net1.getName(), net1.getMtu() == 0 ? "default" : net1.getMtu(), net2.getName(), net2.getMtu()));
}
#method_after
private void validateAndExpectMtuValidation(SetupNetworksHelper helper, Network net1, Network net2) {
    validateAndExpectViolation(helper, EngineMessage.NETWORK_MTU_DIFFERENCES, String.format("[%s(%s), %s(%d)]", net1.getName(), net1.getMtu() == 0 ? "default" : net1.getMtu(), net2.getName(), net2.getMtu()));
}
#end_block

#method_before
/* --- Tests for General Violations --- */
@Test
public void violationAppearsTwice() {
    VdsNetworkInterface nic1 = createNic("nic0", null);
    VdsNetworkInterface nic2 = createNic("nic1", null);
    mockExistingIfaces(nic1, nic2);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic1, nic1, nic2, nic2));
    validateAndExpectViolation(helper, VdcBllMessages.NETWORK_INTERFACES_ALREADY_SPECIFIED, nic1.getName(), nic2.getName());
}
#method_after
/* --- Tests for General Violations --- */
@Test
public void violationAppearsTwice() {
    VdsNetworkInterface nic1 = createNic("nic0", null);
    VdsNetworkInterface nic2 = createNic("nic1", null);
    mockExistingIfaces(nic1, nic2);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic1, nic1, nic2, nic2));
    validateAndExpectViolation(helper, EngineMessage.NETWORK_INTERFACES_ALREADY_SPECIFIED, nic1.getName(), nic2.getName());
}
#end_block

#method_before
@Test
public void nicDoesntExist() {
    VdsNetworkInterface nic = createNic("eth0", null);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic));
    validateAndExpectViolation(helper, VdcBllMessages.NETWORK_INTERFACES_DONT_EXIST, nic.getName());
}
#method_after
@Test
public void nicDoesntExist() {
    VdsNetworkInterface nic = createNic("eth0", null);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic));
    validateAndExpectViolation(helper, EngineMessage.NETWORK_INTERFACES_DONT_EXIST, nic.getName());
}
#end_block

#method_before
@Test
public void labeledNetworkRemovedFromNic() {
    String networkName = "net";
    String label = "lbl1";
    VdsNetworkInterface nic = createLabeledNic("nic0", networkName, label);
    mockExistingIfaces(nic);
    nic.setNetworkName(null);
    mockExistingNetworks(createLabeledNetwork(networkName, label));
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic));
    validateAndExpectViolation(helper, VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, networkName);
}
#method_after
@Test
public void labeledNetworkRemovedFromNic() {
    String networkName = "net";
    String label = "lbl1";
    VdsNetworkInterface nic = createLabeledNic("nic0", networkName, label);
    mockExistingIfaces(nic);
    nic.setNetworkName(null);
    mockExistingNetworks(createLabeledNetwork(networkName, label));
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic));
    validateAndExpectViolation(helper, EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, networkName);
}
#end_block

#method_before
private void validateAndExpectViolation(SetupNetworksHelper helper, VdcBllMessages violation) {
    List<String> violations = helper.validate();
    assertTrue(MessageFormat.format("Expected violation {0} but only got {1}.", violation, violations), violations.contains(violation.name()));
}
#method_after
private void validateAndExpectViolation(SetupNetworksHelper helper, EngineMessage violation, String... violatingEntities) {
    List<String> violations = helper.validate();
    assertTrue(MessageFormat.format("Expected violation {0} but only got {1}.", violation, violations), violations.contains(violation.name()));
    for (String violationDetail : ReplacementUtils.replaceWith(violation + LIST_SUFFIX, Arrays.asList(violatingEntities))) {
        assertThat("Missing violation entity", violations, hasItems(violationDetail));
    }
}
#end_block

#method_before
private void assertInterfaceModified(SetupNetworksHelper helper, VdsNetworkInterface iface) {
    Set<String> modifiedNames = new HashSet<String>();
    for (VdsNetworkInterface modifiedIface : helper.getModifiedInterfaces()) {
        modifiedNames.add(modifiedIface.getName());
    }
    assertTrue(MessageFormat.format("Expected interface ''{0}'' to be modified but it wasn''t. Modified interfaces: {1}", iface, helper.getModifiedInterfaces()), modifiedNames.contains(iface.getName()));
}
#method_after
private void assertInterfaceModified(SetupNetworksHelper helper, VdsNetworkInterface iface) {
    Set<String> modifiedNames = new HashSet<>();
    for (VdsNetworkInterface modifiedIface : helper.getModifiedInterfaces()) {
        modifiedNames.add(modifiedIface.getName());
    }
    assertTrue(MessageFormat.format("Expected interface ''{0}'' to be modified but it wasn''t. Modified interfaces: {1}", iface, helper.getModifiedInterfaces()), modifiedNames.contains(iface.getName()));
}
#end_block

#method_before
private Network createNetwork(String networkName) {
    return new Network("", "", Guid.newGuid(), networkName, "", "", 0, null, false, 0, true);
}
#method_after
private Network createNetwork(String networkName) {
    Network net = new Network("", "", Guid.newGuid(), networkName, "", "", 0, null, false, 0, true);
    net.setCluster(new NetworkCluster());
    return net;
}
#end_block

#method_before
private VdsNetworkInterface createVdsInterface(Guid id, String name, Boolean bonded, String bondName, String baseInterfaceName, Integer vlanId, String networkName, boolean bridged, String address, boolean qosOverridden, Set<String> labels, Integer speed) {
    VdsNetworkInterface iface = new VdsNetworkInterface();
    iface.setId(id);
    iface.setName(name);
    iface.setBonded(bonded);
    iface.setBondName(bondName);
    iface.setBaseInterface(baseInterfaceName);
    iface.setVlanId(vlanId);
    iface.setNetworkName(networkName);
    iface.setBridged(bridged);
    iface.setAddress(address);
    iface.setQosOverridden(qosOverridden);
    iface.setLabels(labels);
    iface.setSpeed(speed);
    return iface;
}
#method_after
private VdsNetworkInterface createVdsInterface(Guid id, String name, Boolean bonded, String bondName, String baseInterfaceName, Integer vlanId, String networkName, boolean bridged, String address, Set<String> labels, Integer speed) {
    VdsNetworkInterface iface = new VdsNetworkInterface();
    iface.setId(id);
    iface.setName(name);
    iface.setBonded(bonded);
    iface.setBondName(bondName);
    iface.setBaseInterface(baseInterfaceName);
    iface.setVlanId(vlanId);
    iface.setNetworkName(networkName);
    iface.setBridged(bridged);
    iface.setAddress(address);
    iface.setLabels(labels);
    iface.setSpeed(speed);
    return iface;
}
#end_block

#method_before
private VdsNetworkInterface createNic(String nicName, String networkName) {
    return createVdsInterface(Guid.newGuid(), nicName, false, null, null, null, networkName, true, null, false, null, DEFAULT_SPEED);
}
#method_after
private VdsNetworkInterface createNic(String nicName, String networkName) {
    VdsNetworkInterface nic = createVdsInterface(Guid.newGuid(), nicName, false, null, null, null, networkName, true, null, null, DEFAULT_SPEED);
    mockCalculateBaseNicWhenBaseNicIsPassed(nic);
    return nic;
}
#end_block

#method_before
private VdsNetworkInterface createNicSyncedWithNetwork(String nicName, Network network) {
    VdsNetworkInterface nic = createVdsInterface(Guid.newGuid(), nicName, false, null, null, network.getVlanId(), network.getName(), network.isVmNetwork(), network.getAddr(), false, null, DEFAULT_SPEED);
    return nic;
}
#method_after
private VdsNetworkInterface createNicSyncedWithNetwork(String nicName, Network network) {
    VdsNetworkInterface nic = createVdsInterface(Guid.newGuid(), nicName, false, null, null, network.getVlanId(), network.getName(), network.isVmNetwork(), network.getAddr(), null, DEFAULT_SPEED);
    mockCalculateBaseNicWhenBaseNicIsPassed(nic);
    return nic;
}
#end_block

#method_before
private VdsNetworkInterface createVlanSyncedWithNetwork(String nicName, Network network) {
    VdsNetworkInterface nic = createVlan(nicName, network.getVlanId(), network.getName());
    nic.setBridged(network.isVmNetwork());
    nic.setMtu(network.getMtu());
    return nic;
}
#method_after
private VdsNetworkInterface createVlanSyncedWithNetwork(VdsNetworkInterface baseNic, Network network) {
    VdsNetworkInterface nic = createVlan(baseNic, network.getVlanId(), network.getName());
    nic.setBridged(network.isVmNetwork());
    nic.setMtu(network.getMtu());
    return nic;
}
#end_block

#method_before
private VdsNetworkInterface createBond(String name, String networkName) {
    return createVdsInterface(Guid.newGuid(), name, true, null, null, null, networkName, true, null, false, null, DEFAULT_SPEED);
}
#method_after
private VdsNetworkInterface createBond(String name, String networkName) {
    VdsNetworkInterface bond = createVdsInterface(Guid.newGuid(), name, true, null, null, null, networkName, true, null, null, DEFAULT_SPEED);
    mockCalculateBaseNicWhenBaseNicIsPassed(bond);
    return bond;
}
#end_block

#method_before
private VdsNetworkInterface createVlan(String baseIfaceName, int vlanId, String networkName) {
    return createVdsInterface(Guid.newGuid(), baseIfaceName + "." + vlanId, false, null, baseIfaceName, vlanId, networkName, true, null, false, null, DEFAULT_SPEED);
}
#method_after
private VdsNetworkInterface createVlan(VdsNetworkInterface baseNic, int vlanId, String networkName) {
    String baseIfaceName = baseNic.getName();
    VdsNetworkInterface nic = createVdsInterface(Guid.newGuid(), baseIfaceName + "." + vlanId, false, null, baseIfaceName, vlanId, networkName, true, null, null, DEFAULT_SPEED);
    mockCalculateBaseNicWhenVlanNicIsPassed(baseNic, nic);
    return nic;
}
#end_block

#method_before
private VdsNetworkInterface enslaveOrReleaseNIC(VdsNetworkInterface iface, String bondName) {
    return createVdsInterface(iface.getId(), iface.getName(), false, bondName, null, null, null, true, null, false, null, DEFAULT_SPEED);
}
#method_after
private VdsNetworkInterface enslaveOrReleaseNIC(VdsNetworkInterface iface, String bondName) {
    return createVdsInterface(iface.getId(), iface.getName(), false, bondName, null, null, null, true, null, null, DEFAULT_SPEED);
}
#end_block

#method_before
private List<VdsNetworkInterface> createNics(String bondName, int count) {
    List<VdsNetworkInterface> ifaces = new ArrayList<VdsNetworkInterface>(count);
    for (int i = 0; i < count; i++) {
        VdsNetworkInterface nic = createNic("eth" + i, null);
        if (bondName != null) {
            nic = enslaveOrReleaseNIC(nic, bondName);
        }
        ifaces.add(nic);
    }
    return ifaces;
}
#method_after
private List<VdsNetworkInterface> createNics(String bondName, int count) {
    List<VdsNetworkInterface> ifaces = new ArrayList<>(count);
    for (int i = 0; i < count; i++) {
        VdsNetworkInterface nic = createNic("eth" + i, null);
        if (bondName != null) {
            nic = enslaveOrReleaseNIC(nic, bondName);
        }
        ifaces.add(nic);
    }
    return ifaces;
}
#end_block

#method_before
private SetupNetworksParameters createParametersForNics(VdsNetworkInterface... nics) {
    SetupNetworksParameters parameters = new SetupNetworksParameters();
    parameters.setInterfaces(Arrays.asList(nics));
    return parameters;
}
#method_after
@SuppressWarnings("deprecation")
private SetupNetworksParameters createParametersForNics(VdsNetworkInterface... nics) {
    SetupNetworksParameters parameters = new SetupNetworksParameters();
    parameters.setInterfaces(Arrays.asList(nics));
    return parameters;
}
#end_block

#method_before
private SetupNetworksParameters createParametersForBond(VdsNetworkInterface bond, List<VdsNetworkInterface> bondedIfaces) {
    SetupNetworksParameters parameters = new SetupNetworksParameters();
    parameters.getInterfaces().add(bond);
    for (VdsNetworkInterface iface : bondedIfaces) {
        parameters.getInterfaces().add(enslaveOrReleaseNIC(iface, bond.getName()));
    }
    return parameters;
}
#method_after
@SuppressWarnings("deprecation")
private SetupNetworksParameters createParametersForBond(VdsNetworkInterface bond, List<VdsNetworkInterface> bondedIfaces) {
    SetupNetworksParameters parameters = new SetupNetworksParameters();
    parameters.getInterfaces().add(bond);
    for (VdsNetworkInterface iface : bondedIfaces) {
        parameters.getInterfaces().add(enslaveOrReleaseNIC(iface, bond.getName()));
    }
    return parameters;
}
#end_block

#method_before
private SetupNetworksParameters createParametersForSync(VdsNetworkInterface nic) {
    return createParametersForSync(nic.getNetworkName(), nic);
}
#method_after
@SuppressWarnings("deprecation")
private SetupNetworksParameters createParametersForSync(VdsNetworkInterface nic) {
    return createParametersForSync(nic.getNetworkName(), nic);
}
#end_block

#method_before
private SetupNetworksParameters createParametersForSync(String network, VdsNetworkInterface... nics) {
    SetupNetworksParameters params = createParametersForNics(nics);
    params.setNetworksToSync(Collections.singletonList(network));
    return params;
}
#method_after
@SuppressWarnings("deprecation")
private SetupNetworksParameters createParametersForSync(String network, VdsNetworkInterface... nics) {
    // noinspection deprecation
    SetupNetworksParameters params = createParametersForNics(nics);
    params.setNetworksToSync(Collections.singletonList(network));
    return params;
}
#end_block

#method_before
private Map<String, String> createCustomProperties() {
    Map<String, String> customProperties = new HashMap<String, String>();
    customProperties.put("bridge_opts", "forward_delay=1500");
    return customProperties;
}
#method_after
private Map<String, String> createCustomProperties() {
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("bridge_opts", "forward_delay=1500");
    return customProperties;
}
#end_block

#method_before
private void mockExistingNetworks(Network... networks) {
    when(networkDAO.getAllForCluster(any(Guid.class))).thenReturn(Arrays.asList(networks));
}
#method_after
private void mockExistingNetworks(Network... networks) {
    when(networkDao.getAllForCluster(any(Guid.class))).thenReturn(Arrays.asList(networks));
}
#end_block

#method_before
private void mockExistingIfaces(VdsNetworkInterface... nics) {
    List<VdsNetworkInterface> existingIfaces = new ArrayList<VdsNetworkInterface>();
    for (int i = 0; i < nics.length; i++) {
        existingIfaces.add(createVdsInterface(nics[i].getId(), nics[i].getName(), nics[i].getBonded(), nics[i].getBondName(), nics[i].getBaseInterface(), nics[i].getVlanId(), nics[i].getNetworkName(), nics[i].isBridged(), nics[i].getAddress(), nics[i].isQosOverridden(), nics[i].getLabels(), nics[i].getSpeed()));
    }
    when(interfaceDAO.getAllInterfacesForVds(any(Guid.class))).thenReturn(existingIfaces);
}
#method_after
private void mockExistingIfaces(VdsNetworkInterface... nics) {
    List<VdsNetworkInterface> existingIfaces = new ArrayList<>();
    for (VdsNetworkInterface original : nics) {
        VdsNetworkInterface vdsInterface = createVdsInterface(original.getId(), original.getName(), original.getBonded(), original.getBondName(), original.getBaseInterface(), original.getVlanId(), original.getNetworkName(), original.isBridged(), original.getAddress(), original.getLabels(), original.getSpeed());
        vdsInterface.setBootProtocol(original.getBootProtocol());
        existingIfaces.add(vdsInterface);
    }
    mockCalculateBaseNic(existingIfaces);
    when(interfaceDao.getAllInterfacesForVds(any(Guid.class))).thenReturn(existingIfaces);
}
#end_block

#method_before
private SetupNetworksHelper createHelper(SetupNetworksParameters params) {
    return createHelper(params, Version.v3_3);
}
#method_after
@SuppressWarnings("deprecation")
private SetupNetworksHelper createHelper(SetupNetworksParameters params) {
    return createHelper(params, Version.v3_3);
}
#end_block

#method_before
private SetupNetworksHelper createHelper(SetupNetworksParameters params, Version compatibilityVersion) {
    VDS vds = mock(VDS.class);
    when(vds.getId()).thenReturn(Guid.Empty);
    return createHelper(params, vds, compatibilityVersion);
}
#method_after
@SuppressWarnings("deprecation")
private SetupNetworksHelper createHelper(SetupNetworksParameters params, Version compatibilityVersion) {
    VDS vds = mock(VDS.class);
    when(vds.getId()).thenReturn(Guid.Empty);
    return createHelper(params, vds, compatibilityVersion);
}
#end_block

#method_before
private SetupNetworksHelper createHelper(SetupNetworksParameters params, VDS vds) {
    return createHelper(params, vds, Version.v3_3);
}
#method_after
@SuppressWarnings("deprecation")
private SetupNetworksHelper createHelper(SetupNetworksParameters params, VDS vds) {
    return createHelper(params, vds, Version.v3_3);
}
#end_block

#method_before
private SetupNetworksHelper createHelper(SetupNetworksParameters params, VDS vds, Version compatibilityVersion) {
    when(vds.getVdsGroupCompatibilityVersion()).thenReturn(compatibilityVersion);
    final HashSet<Version> supportedClusterVersions = new HashSet<>();
    when(vds.getSupportedClusterVersionsSet()).thenReturn(supportedClusterVersions);
    when(networkExclusivenessValidatorResolver.resolveNetworkExclusivenessValidator(same(supportedClusterVersions))).thenReturn(networkExclusivenessValidator);
    when(networkExclusivenessValidator.isNetworkExclusive(Mockito.anyListOf(NetworkType.class))).thenReturn(true);
    when(networkExclusivenessValidator.getViolationMessage()).thenReturn(NETWORK_INTERFACES_NOT_EXCLUSIVELY_USED_BY_NETWORK_MSG);
    SetupNetworksHelper helper = spy(new SetupNetworksHelper(params, vds, managementNetworkUtil, networkExclusivenessValidatorResolver));
    when(helper.getVmInterfaceManager()).thenReturn(vmInterfaceManager);
    doReturn(null).when(helper).translateErrorMessages(Matchers.<List<String>>any());
    DbFacade dbFacade = mock(DbFacade.class);
    doReturn(dbFacade).when(helper).getDbFacade();
    doReturn(interfaceDAO).when(dbFacade).getInterfaceDao();
    doReturn(mock(VdsDAO.class)).when(dbFacade).getVdsDao();
    doReturn(networkDAO).when(dbFacade).getNetworkDao();
    doReturn(qosDao).when(dbFacade).getHostNetworkQosDao();
    return helper;
}
#method_after
@SuppressWarnings("deprecation")
private SetupNetworksHelper createHelper(SetupNetworksParameters params, VDS vds, Version compatibilityVersion) {
    when(vds.getVdsGroupCompatibilityVersion()).thenReturn(compatibilityVersion);
    final HashSet<Version> supportedClusterVersions = new HashSet<>();
    when(vds.getSupportedClusterVersionsSet()).thenReturn(supportedClusterVersions);
    when(networkExclusivenessValidatorResolver.resolveNetworkExclusivenessValidator(same(supportedClusterVersions))).thenReturn(networkExclusivenessValidator);
    when(networkExclusivenessValidator.isNetworkExclusive(Mockito.anyListOf(NetworkType.class))).thenReturn(true);
    when(networkExclusivenessValidator.getViolationMessage()).thenReturn(NETWORK_INTERFACES_NOT_EXCLUSIVELY_USED_BY_NETWORK_MSG);
    SetupNetworksHelper helper = spy(new SetupNetworksHelper(params, vds, managementNetworkUtil, networkExclusivenessValidatorResolver));
    when(helper.getVmInterfaceManager()).thenReturn(vmInterfaceManager);
    doReturn(null).when(helper).translateErrorMessages(Matchers.<List<String>>any());
    return helper;
}
#end_block

#method_before
public ValidationResult validateNetworkExclusiveOnNics() {
    Map<String, List<NetworkType>> nicNameToNetworkTypesMap = createNicNameToNetworkTypesMap();
    List<String> violatedNics = findViolatedNics(nicNameToNetworkTypesMap);
    if (violatedNics.isEmpty()) {
        return ValidationResult.VALID;
    } else {
        return new ValidationResult(networkExclusivenessValidator.getViolationMessage(), violatedNics);
    }
}
#method_after
public ValidationResult validateNetworkExclusiveOnNics() {
    Map<String, List<NetworkType>> nicNameToNetworkTypesMap = createNicNameToNetworkTypesMap();
    List<String> violatedNics = findViolatedNics(nicNameToNetworkTypesMap);
    if (violatedNics.isEmpty()) {
        return ValidationResult.VALID;
    } else {
        final EngineMessage violationMessage = networkExclusivenessValidator.getViolationMessage();
        return new ValidationResult(violationMessage, ReplacementUtils.replaceWith(violationMessage + LIST_SUFFIX, violatedNics));
    }
}
#end_block

#method_before
private Map<String, List<NetworkType>> createNicNameToNetworkTypesMap() {
    Map<String, List<NetworkType>> nicNameToNetworkTypes = new HashMap<>();
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        Network networkToConfigure = networkBusinessEntityMap.get(attachment.getNetworkId());
        NetworkType networkType = determineNetworkType(networkToConfigure);
        getNetworkTypesList(nicNameToNetworkTypes, attachment.getNicName()).add(networkType);
    }
    return nicNameToNetworkTypes;
}
#method_after
private Map<String, List<NetworkType>> createNicNameToNetworkTypesMap() {
    Map<String, List<NetworkType>> nicNameToNetworkTypes = new HashMap<>();
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        String nicName = attachment.getNicName();
        // have to check since if null, multiple results would be merged producing invalid results.
        if (nicName == null) {
            throw new IllegalArgumentException("nic name cannot be null");
        }
        Network networkToConfigure = networkBusinessEntityMap.get(attachment.getNetworkId());
        NetworkType networkTypeToAdd = determineNetworkType(networkToConfigure);
        MultiValueMapUtils.ListCreator<NetworkType> listCreator = new MultiValueMapUtils.ListCreator<>();
        MultiValueMapUtils.addToMap(nicName, networkTypeToAdd, nicNameToNetworkTypes, listCreator);
    }
    return nicNameToNetworkTypes;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (Guid.isNullOrEmpty(getVdsId())) {
        return failCanDoAction(VdcBllMessages.VDS_INVALID_SERVER_ID);
    }
    if (getVds() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (Guid.isNullOrEmpty(getVdsId())) {
        return failCanDoAction(EngineMessage.VDS_INVALID_SERVER_ID);
    }
    if (getVds() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
    }
    return true;
}
#end_block

#method_before
private void installHost() {
    try (final VdsDeploy installer = new VdsDeploy(getVds())) {
        log.info("Before Installation host {}, {}", getVds().getId(), getVds().getName());
        T parameters = getParameters();
        installer.setCorrelationId(getCorrelationId());
        boolean configureNetworkUsingHostDeploy = !FeatureSupported.setupManagementNetwork(getVds().getVdsGroupCompatibilityVersion());
        installer.setReboot(parameters.isRebootAfterInstallation() && configureNetworkUsingHostDeploy);
        if (configureNetworkUsingHostDeploy) {
            final Network managementNetwork = managementNetworkUtil.getManagementNetwork(getVdsGroupId());
            installer.setManagementNetwork(managementNetwork.getName());
        }
        if (parameters.getNetworkProviderId() != null) {
            Provider<?> provider = getDbFacade().getProviderDao().get(parameters.getNetworkProviderId());
            if (provider.getType() == ProviderType.OPENSTACK_NETWORK) {
                OpenstackNetworkProviderProperties agentProperties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
                if (StringUtils.isNotBlank(parameters.getNetworkMappings())) {
                    agentProperties.getAgentConfiguration().setNetworkMappings(parameters.getNetworkMappings());
                }
                installer.setOpenStackAgentProperties(agentProperties);
            }
        }
        switch(getVds().getVdsType()) {
            case VDS:
                installer.setFirewall(parameters.getOverrideFirewall());
                break;
            case oVirtNode:
                if (parameters.getOverrideFirewall()) {
                    log.warn("Installation of Host {} will ignore Firewall Override option, since it is not supported for Host type {}", getVds().getName(), getVds().getVdsType().name());
                }
                break;
            default:
                throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getVdsType()));
        }
        if (parameters.getEnableSerialConsole()) {
            if (FeatureSupported.isVirtioSerialConsoleSupported(getVds().getVdsGroupCompatibilityVersion())) {
                installer.setVMConsole(true);
            } else {
                log.warn("Installation of Host {} will ignore Virtio Serial console option, since it is not support for clusterLevel {}", getVds().getName(), getVds().getVdsGroupCompatibilityVersion());
            }
        }
        switch(getParameters().getAuthMethod()) {
            case Password:
                installer.setPassword(parameters.getPassword());
                break;
            case PublicKey:
                installer.useDefaultKeyPair();
                break;
            default:
                throw new Exception("Invalid authentication method value was sent to InstallVdsInternalCommand");
        }
        setVdsStatus(VDSStatus.Installing);
        installer.execute();
        switch(installer.getDeployStatus()) {
            case Failed:
                throw new VdsInstallException(VDSStatus.InstallFailed, StringUtils.EMPTY);
            case Incomplete:
                throw new VdsInstallException(VDSStatus.InstallFailed, "Partial installation");
            case Reboot:
                setVdsStatus(VDSStatus.Reboot);
                runSleepOnReboot(getStatusOnReboot());
                break;
            case Complete:
                if (checkProtocolTofallback(getVds())) {
                    // we need to check whether we are connecting to vdsm which supports xmlrpc only
                    ProtocolDetector detector = new ProtocolDetector(getVds(), resourceManager);
                    if (!detector.attemptConnection()) {
                        detector.stopConnection();
                        if (detector.attemptFallbackProtocol()) {
                            detector.setFallbackProtocol();
                        } else {
                            throw new VdsInstallException(VDSStatus.InstallFailed, "Host not reachable");
                        }
                    }
                }
                if (!configureNetworkUsingHostDeploy) {
                    configureManagementNetwork();
                }
                if (!getParameters().getActivateHost() && VDSStatus.Maintenance.equals(vdsInitialStatus)) {
                    setVdsStatus(VDSStatus.Maintenance);
                } else {
                    setVdsStatus(VDSStatus.Initializing);
                }
                break;
        }
        log.info("After Installation host {}, {}", getVds().getName(), getVds().getVdsType().name());
        setSucceeded(true);
    } catch (VdsInstallException e) {
        handleError(e, e.getStatus());
    } catch (Exception e) {
        handleError(e, VDSStatus.InstallFailed);
    }
}
#method_after
private void installHost() {
    try (final VdsDeploy deploy = new VdsDeploy("ovirt-host-deploy", getVds(), true)) {
        log.info("Before Installation host {}, {}", getVds().getId(), getVds().getName());
        T parameters = getParameters();
        deploy.setCorrelationId(getCorrelationId());
        deploy.addUnit(new VdsDeployMiscUnit(), new VdsDeployVdsmUnit(), new VdsDeployPKIUnit(), new VdsDeployKdumpUnit());
        if (parameters.getNetworkProviderId() != null) {
            Provider<?> provider = getDbFacade().getProviderDao().get(parameters.getNetworkProviderId());
            if (provider.getType() == ProviderType.OPENSTACK_NETWORK) {
                OpenstackNetworkProviderProperties agentProperties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
                if (StringUtils.isNotBlank(parameters.getNetworkMappings())) {
                    agentProperties.getAgentConfiguration().setNetworkMappings(parameters.getNetworkMappings());
                }
                deploy.addUnit(new VdsDeployOpenStackUnit(agentProperties));
            }
        }
        if (parameters.getOverrideFirewall()) {
            switch(getVds().getVdsType()) {
                case VDS:
                    deploy.addUnit(new VdsDeployIptablesUnit());
                    break;
                case oVirtNode:
                    log.warn("Installation of Host {} will ignore Firewall Override option, since it is not supported for Host type {}", getVds().getName(), getVds().getVdsType().name());
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getVdsType()));
            }
        }
        if (parameters.getEnableSerialConsole()) {
            /* in 3.6.0 we always enable serial console without user intervention. */
            if (FeatureSupported.virtioSerialConsole(getVds().getVdsGroupCompatibilityVersion())) {
                deploy.addUnit(new VdsDeployVmconsoleUnit());
            } else {
                log.warn("Installation of Host {} will skip Virtio Serial Console, because it is not supported for clusterLevel {}", getVds().getName(), getVds().getVdsGroupCompatibilityVersion());
            }
        }
        switch(getParameters().getAuthMethod()) {
            case Password:
                deploy.setPassword(parameters.getPassword());
                break;
            case PublicKey:
                deploy.useDefaultKeyPair();
                break;
            default:
                throw new Exception("Invalid authentication method value was sent to InstallVdsInternalCommand");
        }
        setVdsStatus(VDSStatus.Installing);
        deploy.execute();
        switch(deploy.getDeployStatus()) {
            case Failed:
                throw new VdsInstallException(VDSStatus.InstallFailed, StringUtils.EMPTY);
            case Incomplete:
                throw new VdsInstallException(VDSStatus.InstallFailed, "Partial installation");
            case Reboot:
                setVdsStatus(VDSStatus.Reboot);
                runSleepOnReboot(getStatusOnReboot());
                break;
            case Complete:
                if (checkProtocolTofallback(getVds())) {
                    // we need to check whether we are connecting to vdsm which supports xmlrpc only
                    ProtocolDetector detector = new ProtocolDetector(getVds(), resourceManager);
                    if (!detector.attemptConnection()) {
                        detector.stopConnection();
                        if (detector.attemptFallbackProtocol()) {
                            detector.setFallbackProtocol();
                        } else {
                            throw new VdsInstallException(VDSStatus.InstallFailed, "Host not reachable");
                        }
                    }
                }
                configureManagementNetwork();
                if (!getParameters().getActivateHost() && VDSStatus.Maintenance.equals(vdsInitialStatus)) {
                    setVdsStatus(VDSStatus.Maintenance);
                } else {
                    setVdsStatus(VDSStatus.Initializing);
                }
                break;
        }
        log.info("After Installation host {}, {}", getVds().getName(), getVds().getVdsType().name());
        setSucceeded(true);
    } catch (VdsInstallException e) {
        handleError(e, e.getStatus());
    } catch (Exception e) {
        handleError(e, VDSStatus.InstallFailed);
    }
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getParameters().getVdsId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VDS, VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getParameters().getVdsId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VDS, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
}
#end_block

#method_before
@Override
public Result getCurrentResult(String cluster) {
    ClusterOptimizer clusterOptimizer;
    Result r;
    synchronized (clusterOptimizers) {
        clusterOptimizer = clusterOptimizers.get(cluster);
    }
    if (clusterOptimizer == null) {
        log.error(String.format("Cluster %s does not exist", cluster));
        r = Result.createEmpty(cluster);
    } else {
        ClusterOptimizer.Result best = clusterOptimizer.getBestSolution();
        OptimalDistributionStepsSolution solution = best.getSolution();
        r = new Result(cluster);
        r.setStatus(Result.ResultStatus.OK);
        r.setHardScore(solution.getScore().getHardScore());
        r.setSoftScore(solution.getScore().getSoftScore());
        r.setHosts(new HashSet<String>());
        for (Host h : solution.getHosts()) {
            r.getHosts().add(h.getId());
        }
        r.setVms(new HashSet<String>());
        for (VM vm : solution.getVms()) {
            r.getVms().add(vm.getId());
        }
        r.setRequestedVms(new HashSet<String>());
        for (Object fact : solution.getFixedFacts()) {
            if (fact instanceof RunningVm) {
                r.getRequestedVms().add(((RunningVm) fact).getId());
            }
        }
        r.setHostToVms(solution.getFinalSituation().getHostToVmAssignments());
        r.setVmToHost(solution.getFinalSituation().getVmToHostAssignments());
        r.setCurrentVmToHost(solution.getVmToHostAssignments());
        List<Map<String, String>> migrations = new ArrayList<>();
        for (Migration step : solution.getSteps()) {
            if (!step.isValid()) {
                continue;
            }
            Map<String, String> migration = new HashMap<>();
            migration.put(step.getVm().getId(), step.getDestination().getId());
            migrations.add(migration);
        }
        r.setMigrations(migrations);
        long time = System.currentTimeMillis();
        r.setResultAge(time - best.getTimestamp());
    }
    return r;
}
#method_after
@Override
public Result getCurrentResult(String cluster) {
    ClusterOptimizer clusterOptimizer;
    Result r;
    synchronized (clusterOptimizers) {
        clusterOptimizer = clusterOptimizers.get(cluster);
    }
    if (clusterOptimizer == null) {
        log.error(String.format("Cluster %s does not exist", cluster));
        r = Result.createEmpty(cluster);
    } else {
        OptimalDistributionStepsSolution best = clusterOptimizer.getBestSolution();
        r = new Result(cluster);
        r.setStatus(Result.ResultStatus.OK);
        r.setHardScore(best.getScore().getHardScore());
        r.setSoftScore(best.getScore().getSoftScore());
        r.setHosts(new HashSet<String>());
        for (Host h : best.getHosts()) {
            r.getHosts().add(h.getId());
        }
        r.setVms(new HashSet<String>());
        for (VM vm : best.getVms()) {
            r.getVms().add(vm.getId());
        }
        r.setRequestedVms(new HashSet<String>());
        for (Object fact : best.getFixedFacts()) {
            if (fact instanceof RunningVm) {
                r.getRequestedVms().add(((RunningVm) fact).getId());
            }
        }
        r.setHostToVms(best.getFinalSituation().getHostToVmAssignments());
        r.setVmToHost(best.getFinalSituation().getVmToHostAssignments());
        r.setCurrentVmToHost(best.getVmToHostAssignments());
        List<Map<String, String>> migrations = new ArrayList<>();
        for (Migration step : best.getSteps()) {
            if (!step.isValid()) {
                continue;
            }
            Map<String, String> migration = new HashMap<>();
            migration.put(step.getVm().getId(), step.getDestination().getId());
            migrations.add(migration);
        }
        r.setMigrations(migrations);
        long time = System.currentTimeMillis();
        r.setAge(time - best.getTimestamp());
    }
    return r;
}
#end_block

#method_before
HardSoftScore computeScore(List<Map<String, String>> migrationIds) {
    OptimalDistributionStepsSolution sourceSolution = null;
    synchronized (ClusterOptimizer.this) {
        sourceSolution = bestSolution.getSolution();
    }
    log.debug("Reevaluating solution {}", migrationIds);
    SolverFactory solverFactory = SolverFactory.createFromXmlResource("org/ovirt/optimizer/service/rules/scoreonly.xml");
    addCustomDrlFiles(solverFactory.getSolverConfig().getScoreDirectorFactoryConfig(), customDrlFiles);
    Solver solver = solverFactory.buildSolver();
    /* Reconstruct the Solution object with current facts */
    OptimalDistributionStepsSolution solution = new OptimalDistributionStepsSolution();
    solution.setHosts(sourceSolution.getHosts());
    solution.setVms(sourceSolution.getVms());
    solution.setOtherFacts(sourceSolution.getOtherFacts());
    solution.setFixedFacts(sourceSolution.getFixedFacts());
    /* Get id to object mappings for hosts and VMs */
    Map<String, Host> hosts = new HashMap<>();
    for (Host h : solution.getHosts()) {
        hosts.put(h.getId(), h);
        log.debug("Found host {}", h.getId());
    }
    Map<String, VM> vms = new HashMap<>();
    for (VM vm : solution.getVms()) {
        vms.put(vm.getId(), vm);
        log.debug("Found VM {}", vm.getId());
    }
    /* Recreate the migration objects */
    List<Migration> migrations = new ArrayList<>();
    for (Map<String, String> migrationStep : migrationIds) {
        for (Map.Entry<String, String> singleMigration : migrationStep.entrySet()) {
            // Create new migration step
            Migration migration = new Migration();
            String hostId = singleMigration.getValue();
            // Inject current host data
            if (hosts.containsKey(hostId)) {
                migration.setDestination(hosts.get(hostId));
                log.debug("Setting destination for {} to {}", migration, hostId);
            } else {
                log.debug("Host {} is no longer valid", hostId);
            }
            // Inject current VM data
            String vmId = singleMigration.getKey();
            if (vms.containsKey(vmId)) {
                migration.setVm(vms.get(vmId));
                log.debug("Setting VM for {} to {}", migration, vmId);
            } else {
                log.debug("VM {} is no longer valid", vmId);
            }
            // Add the step to the list of steps
            migrations.add(migration);
        }
    }
    /* Compute the migration ordering cache */
    solution.setSteps(migrations);
    solution.establishStepOrdering();
    /* Prepare shadow variables */
    ClusterSituation previous = solution;
    for (Migration m : migrations) {
        m.recomputeSituationAfter(previous);
        previous = m;
    }
    /* Recompute score */
    solver.solve(solution);
    if (log.isDebugEnabled()) {
        recomputeScoreUsingScoreDirector(solver, solution);
    }
    return solution.getScore();
}
#method_after
HardSoftScore computeScore(List<Map<String, String>> migrationIds) {
    OptimalDistributionStepsSolution sourceSolution = null;
    synchronized (ClusterOptimizer.this) {
        sourceSolution = bestSolution;
    }
    log.debug("Reevaluating solution {}", migrationIds);
    SolverFactory solverFactory = SolverFactory.createFromXmlResource("org/ovirt/optimizer/service/rules/scoreonly.xml");
    addCustomDrlFiles(solverFactory.getSolverConfig().getScoreDirectorFactoryConfig(), customDrlFiles);
    Solver solver = solverFactory.buildSolver();
    /* Reconstruct the Solution object with current facts */
    OptimalDistributionStepsSolution solution = new OptimalDistributionStepsSolution();
    solution.setHosts(sourceSolution.getHosts());
    solution.setVms(sourceSolution.getVms());
    solution.setOtherFacts(sourceSolution.getOtherFacts());
    solution.setFixedFacts(sourceSolution.getFixedFacts());
    /* Get id to object mappings for hosts and VMs */
    Map<String, Host> hosts = new HashMap<>();
    for (Host h : solution.getHosts()) {
        hosts.put(h.getId(), h);
        log.debug("Found host {}", h.getId());
    }
    Map<String, VM> vms = new HashMap<>();
    for (VM vm : solution.getVms()) {
        vms.put(vm.getId(), vm);
        log.debug("Found VM {}", vm.getId());
    }
    /* Recreate the migration objects */
    List<Migration> migrations = new ArrayList<>();
    for (Map<String, String> migrationStep : migrationIds) {
        for (Map.Entry<String, String> singleMigration : migrationStep.entrySet()) {
            // Create new migration step
            Migration migration = new Migration();
            String hostId = singleMigration.getValue();
            // Inject current host data
            if (hosts.containsKey(hostId)) {
                migration.setDestination(hosts.get(hostId));
                log.debug("Setting destination for {} to {}", migration, hostId);
            } else {
                log.debug("Host {} is no longer valid", hostId);
            }
            // Inject current VM data
            String vmId = singleMigration.getKey();
            if (vms.containsKey(vmId)) {
                migration.setVm(vms.get(vmId));
                log.debug("Setting VM for {} to {}", migration, vmId);
            } else {
                log.debug("VM {} is no longer valid", vmId);
            }
            // Add the step to the list of steps
            migrations.add(migration);
        }
    }
    /* Compute the migration ordering cache */
    solution.setSteps(migrations);
    solution.establishStepOrdering();
    /* Prepare shadow variables */
    ClusterSituation previous = solution;
    for (Migration m : migrations) {
        m.recomputeSituationAfter(previous);
        previous = m;
    }
    /* Recompute score */
    solver.solve(solution);
    if (log.isDebugEnabled()) {
        recomputeScoreUsingScoreDirector(solver, solution);
    }
    return solution.getScore();
}
#end_block

#method_before
private void recomputeScoreUsingScoreDirector(Solver solver, OptimalDistributionStepsSolution solution) {
    ScoreDirector director = solver.getScoreDirectorFactory().buildScoreDirector();
    director.setWorkingSolution(solution);
    director.calculateScore();
    for (ConstraintMatchTotal constraintMatchTotal : director.getConstraintMatchTotals()) {
        String constraintName = constraintMatchTotal.getConstraintName();
        Number weightTotal = constraintMatchTotal.getWeightTotalAsNumber();
        for (ConstraintMatch constraintMatch : constraintMatchTotal.getConstraintMatchSet()) {
            List<Object> justificationList = constraintMatch.getJustificationList();
            Number weight = constraintMatch.getWeightAsNumber();
            log.debug("Constraint match {} with weight {}", constraintMatch, weight);
            for (Object item : justificationList) {
                log.debug("Justified by {}", item);
            }
        }
    }
    log.debug("Final score {}", bestSolution.getSolution().getScore().toString());
}
#method_after
private void recomputeScoreUsingScoreDirector(Solver solver, OptimalDistributionStepsSolution solution) {
    ScoreDirector director = solver.getScoreDirectorFactory().buildScoreDirector();
    director.setWorkingSolution(solution);
    director.calculateScore();
    for (ConstraintMatchTotal constraintMatchTotal : director.getConstraintMatchTotals()) {
        String constraintName = constraintMatchTotal.getConstraintName();
        Number weightTotal = constraintMatchTotal.getWeightTotalAsNumber();
        for (ConstraintMatch constraintMatch : constraintMatchTotal.getConstraintMatchSet()) {
            List<Object> justificationList = constraintMatch.getJustificationList();
            Number weight = constraintMatch.getWeightAsNumber();
            log.debug("Constraint match {} with weight {}", constraintMatch, weight);
            for (Object item : justificationList) {
                log.debug("Justified by {}", item);
            }
        }
    }
    log.debug("Final score {}", bestSolution.getScore().toString());
}
#end_block

#method_before
void solve() {
    log.info(String.format("Solver for %s starting", clusterId));
    solver.solve(bestSolution.getSolution());
    log.info(String.format("Solver for %s finished", clusterId));
    synchronized (this) {
        bestSolution = new Result((OptimalDistributionStepsSolution) solver.getBestSolution());
    }
}
#method_after
void solve() {
    log.info(String.format("Solver for %s starting", clusterId));
    solver.solve(bestSolution);
    log.info(String.format("Solver for %s finished", clusterId));
    synchronized (this) {
        bestSolution = (OptimalDistributionStepsSolution) solver.getBestSolution();
    }
}
#end_block

#method_before
public Result getBestSolution() {
    synchronized (this) {
        return bestSolution;
    }
}
#method_after
public OptimalDistributionStepsSolution getBestSolution() {
    synchronized (this) {
        return bestSolution;
    }
}
#end_block

#method_before
protected void initConnectionList(boolean includeInactiveDomains) {
    Set<StorageDomainStatus> statuses;
    statuses = includeInactiveDomains ? EnumSet.of(StorageDomainStatus.Active, StorageDomainStatus.Unknown, StorageDomainStatus.Inactive) : EnumSet.of(StorageDomainStatus.Active, StorageDomainStatus.Unknown);
    _connections = DbFacade.getInstance().getStorageServerConnectionDao().getStorageConnectionsByStorageTypeAndStatus(getStoragePool().getId(), null, statuses);
    updateConnectionsTypeMap();
    updateConnectionMapForFiberChannel();
}
#method_after
protected void initConnectionList(boolean includeInactiveDomains) {
    Set<StorageDomainStatus> statuses;
    statuses = includeInactiveDomains ? EnumSet.of(StorageDomainStatus.Active, StorageDomainStatus.Unknown, StorageDomainStatus.Inactive) : EnumSet.of(StorageDomainStatus.Active, StorageDomainStatus.Unknown);
    _connections = DbFacade.getInstance().getStorageServerConnectionDao().getStorageConnectionsByStorageTypeAndStatus(getStoragePool().getId(), null, statuses);
    updateConnectionsTypeMap();
    updateConnectionMapForFiberChannel(statuses);
}
#end_block

#method_before
private void updateConnectionMapForFiberChannel() {
    if (FeatureSupported.refreshLunSupported(getStoragePool().getCompatibilityVersion())) {
        List<StorageDomain> storageDomainList = getStorageDomainDao().getAllForStoragePool(getStoragePool().getId());
        for (StorageDomain sd : storageDomainList) {
            if (sd.getStorageType().equals(StorageType.FCP)) {
                MultiValueMapUtils.addToMap(StorageType.FCP, FCPStorageHelper.getFCPConnection(), getConnectionsTypeMap());
                break;
            }
        }
    }
}
#method_after
private void updateConnectionMapForFiberChannel(Set<StorageDomainStatus> statuses) {
    if (FeatureSupported.refreshLunSupported(getStoragePool().getCompatibilityVersion())) {
        List<StorageDomain> storageDomainList = getStorageDomainDao().getAllForStoragePool(getStoragePool().getId());
        for (StorageDomain sd : storageDomainList) {
            if (sd.getStorageType() == StorageType.FCP && statuses.contains(sd.getStatus())) {
                MultiValueMapUtils.addToMap(StorageType.FCP, FCPStorageHelper.getFCPConnection(), getConnectionsTypeMap());
                break;
            }
        }
    }
}
#end_block

#method_before
@Override
protected Pair<Boolean, EngineFault> runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type) {
    return runConnectionStorageToDomain(storageDomain, vdsId, type, null, Guid.Empty);
}
#method_after
@Override
protected Pair<Boolean, EngineFault> runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type) {
    return runConnectionStorageToDomain(storageDomain, vdsId, type, null, storageDomain.getStoragePoolId());
}
#end_block

#method_before
@Override
protected Pair<Boolean, EngineFault> runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type, LUNs lun, Guid storagePoolId) {
    Guid poolId = storagePoolId;
    if (storageDomain != null && storageDomain.getStoragePoolId() != null) {
        poolId = storageDomain.getStoragePoolId();
    }
    if (FeatureSupported.refreshLunSupported(DbFacade.getInstance().getStoragePoolDao().get(poolId).getCompatibilityVersion())) {
        boolean isSuccess = true;
        VDSReturnValue returnValue = null;
        List<StorageServerConnections> list = new ArrayList<>();
        list.add(getFCPConnection());
        returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.forValue(type), new StorageServerConnectionManagementVDSParameters(vdsId, poolId, StorageType.FCP, list));
        isSuccess = returnValue.getSucceeded();
        EngineFault engineFault = null;
        if (!isSuccess && returnValue.getVdsError() != null) {
            engineFault = new EngineFault();
            engineFault.setError(returnValue.getVdsError().getCode());
        }
        return new Pair<>(isSuccess, engineFault);
    } else {
        return new Pair<>(true, null);
    }
}
#method_after
@Override
protected Pair<Boolean, EngineFault> runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type, LUNs lun, Guid storagePoolId) {
    if (Guid.isNullOrEmpty(storagePoolId) || !FeatureSupported.refreshLunSupported(DbFacade.getInstance().getStoragePoolDao().get(storagePoolId).getCompatibilityVersion())) {
        return new Pair<>(true, null);
    }
    VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.forValue(type), new StorageServerConnectionManagementVDSParameters(vdsId, storagePoolId, StorageType.FCP, Arrays.asList(getFCPConnection())));
    boolean isSuccess = returnValue.getSucceeded();
    EngineFault engineFault = null;
    if (!isSuccess && returnValue.getVdsError() != null) {
        engineFault = new EngineFault();
        engineFault.setError(returnValue.getVdsError().getCode());
    }
    return new Pair<>(isSuccess, engineFault);
}
#end_block

#method_before
private void onNewTemplate() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null) {
        cancel();
        return;
    }
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck(this);
    } else {
        model.startProgress(null);
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel vmModel = (UnitVmModel) userPortalListModel.getWindow();
                    vmModel.getName().getInvalidityReasons().clear();
                    vmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    vmModel.getName().setIsValid(false);
                    vmModel.setIsValid(false);
                    stopProgress(target);
                } else {
                    userPortalListModel.postNameUniqueCheck(userPortalListModel);
                }
            }
        }), name, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
    }
}
#method_after
private void onNewTemplate() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null) {
        cancel();
        return;
    }
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck(this);
    } else {
        model.startProgress();
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel vmModel = (UnitVmModel) userPortalListModel.getWindow();
                    vmModel.getName().getInvalidityReasons().clear();
                    vmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    vmModel.getName().setIsValid(false);
                    vmModel.setIsValid(false);
                    stopProgress(target);
                } else {
                    userPortalListModel.postNameUniqueCheck(userPortalListModel);
                }
            }
        }), name, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
    }
}
#end_block

#method_before
private void onRemove() {
    getConfirmWindow().startProgress(null);
    List<VdcActionParametersBase> paramsList = new ArrayList<VdcActionParametersBase>();
    for (VM vm : getSelectedVms()) {
        paramsList.add(new RemoveVmParameters(vm.getId(), false));
    }
    Frontend.getInstance().runMultipleActions(VdcActionType.RemoveVm, paramsList, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel model = (ConfirmationModel) ((UserPortalListModel) result.getState()).getConfirmWindow();
            model.stopProgress();
            cancel();
        }
    }, this);
}
#method_after
private void onRemove() {
    getConfirmWindow().startProgress();
    List<VdcActionParametersBase> paramsList = new ArrayList<VdcActionParametersBase>();
    for (VM vm : getSelectedVms()) {
        paramsList.add(new RemoveVmParameters(vm.getId(), false));
    }
    Frontend.getInstance().runMultipleActions(VdcActionType.RemoveVm, paramsList, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel model = (ConfirmationModel) ((UserPortalListModel) result.getState()).getConfirmWindow();
            model.stopProgress();
            cancel();
        }
    }, this);
}
#end_block

#method_before
private void onChangeCD() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        cancel();
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    AttachCdModel model = (AttachCdModel) getWindow();
    model.startProgress(null);
    String isoName = // $NON-NLS-1$
    (model.getIsoImage().getSelectedItem().equals(ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem();
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            stopProgress(result.getState());
            cancel();
        }
    }, this);
}
#method_after
private void onChangeCD() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        cancel();
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    AttachCdModel model = (AttachCdModel) getWindow();
    model.startProgress();
    String isoName = // $NON-NLS-1$
    (model.getIsoImage().getSelectedItem().equals(ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem();
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            stopProgress(result.getState());
            cancel();
        }
    }, this);
}
#end_block

#method_before
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (!model.getIsNew() && selectedItem.getEntity() == null) {
        cancel();
        return;
    }
    settempVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem.getEntity()));
    if (!model.validate()) {
        return;
    }
    model.startProgress(null);
    // Check name uniqueness.
    AsyncDataProvider.getInstance().isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) target;
            boolean isNameUnique = (Boolean) returnValue;
            String newName = model.getName().getEntity();
            String currentName = userPortalListModel.gettempVm().getName();
            if (!isNameUnique && newName.compareToIgnoreCase(currentName) != 0) {
                UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                unitModel.getName().getInvalidityReasons().clear();
                unitModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                unitModel.getName().setIsValid(false);
                unitModel.setIsValid(false);
                unitModel.setValidTab(TabName.GENERAL_TAB, false);
                stopProgress(target);
            } else {
                String selectedCpu = model.getCustomCpu().getSelectedItem();
                if (selectedCpu != null && !selectedCpu.isEmpty() && !model.getCustomCpu().getItems().contains(selectedCpu)) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuTitle());
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuMessage());
                    confirmModel.setHelpTag(HelpTag.edit_unsupported_cpu);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_unsupported_cpu");
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("postVmNameUniqueCheck", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    userPortalListModel.postVmNameUniqueCheck();
                }
            }
        }
    }), model.getName().getEntity(), model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
}
#method_after
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (!model.getIsNew() && selectedItem.getEntity() == null) {
        cancel();
        return;
    }
    settempVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem.getEntity()));
    if (!model.validate()) {
        return;
    }
    model.startProgress();
    // Check name uniqueness.
    AsyncDataProvider.getInstance().isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) target;
            boolean isNameUnique = (Boolean) returnValue;
            String newName = model.getName().getEntity();
            String currentName = userPortalListModel.gettempVm().getName();
            if (!isNameUnique && newName.compareToIgnoreCase(currentName) != 0) {
                UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                unitModel.getName().getInvalidityReasons().clear();
                unitModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                unitModel.getName().setIsValid(false);
                unitModel.setIsValid(false);
                unitModel.setValidTab(TabName.GENERAL_TAB, false);
                stopProgress(target);
            } else {
                String selectedCpu = model.getCustomCpu().getSelectedItem();
                if (selectedCpu != null && !selectedCpu.isEmpty() && !model.getCustomCpu().getItems().contains(selectedCpu)) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuTitle());
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuMessage());
                    confirmModel.setHelpTag(HelpTag.edit_unsupported_cpu);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_unsupported_cpu");
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("postVmNameUniqueCheck", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    userPortalListModel.postVmNameUniqueCheck();
                }
            }
        }
    }), model.getName().getEntity(), model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
}
#end_block

#method_before
private void updateExistingVm(UserPortalListModel userPortalListModel, final boolean applyCpuChangesLater) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) userPortalListModel.getSelectedItem();
    Guid oldClusterID = ((VM) selectedItem.getEntity()).getVdsGroupId();
    Guid newClusterID = model.getSelectedCluster().getId();
    if (oldClusterID.equals(newClusterID) == false) {
        Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(newClusterID, gettempVm().getId()), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                VdcReturnValueBase returnValueBase = result.getReturnValue();
                final UserPortalListModel userPortalListModel = (UserPortalListModel) result.getState();
                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                    VmManagementParametersBase param = getUpdateVmParameters(applyCpuChangesLater);
                    Frontend.getInstance().runAction(VdcActionType.UpdateVm, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, gettempVm().getId()), this);
                } else {
                    userPortalListModel.getWindow().stopProgress();
                }
            }
        }, this);
    } else {
        VmManagementParametersBase param = getUpdateVmParameters(applyCpuChangesLater);
        Frontend.getInstance().runAction(VdcActionType.UpdateVm, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, gettempVm().getId()), this);
    }
}
#method_after
private void updateExistingVm(UserPortalListModel userPortalListModel, final boolean applyCpuChangesLater) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) userPortalListModel.getSelectedItem();
    Guid oldClusterID = ((VM) selectedItem.getEntity()).getVdsGroupId();
    Guid newClusterID = model.getSelectedCluster().getId();
    if (oldClusterID.equals(newClusterID) == false) {
        Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(newClusterID, gettempVm().getId()), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                VdcReturnValueBase returnValueBase = result.getReturnValue();
                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                    VmManagementParametersBase param = getUpdateVmParameters(applyCpuChangesLater);
                    Frontend.getInstance().runAction(VdcActionType.UpdateVm, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, gettempVm().getId()), this);
                } else {
                    getWindow().stopProgress();
                }
            }
        }, this);
    } else {
        VmManagementParametersBase param = getUpdateVmParameters(applyCpuChangesLater);
        Frontend.getInstance().runAction(VdcActionType.UpdateVm, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, gettempVm().getId()), this);
    }
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!super.equals(obj)) {
        return false;
    }
    if (!(obj instanceof NetworkView)) {
        return false;
    }
    NetworkView other = (NetworkView) obj;
    if (getCompatibilityVersion() == null) {
        if (other.getCompatibilityVersion() != null) {
            return false;
        }
    } else if (!getCompatibilityVersion().equals(other.getCompatibilityVersion())) {
        return false;
    }
    if (getDataCenterName() == null) {
        if (other.getDataCenterName() != null) {
            return false;
        }
    } else if (!getDataCenterName().equals(other.getDataCenterName())) {
        return false;
    }
    if (Objects.equals(getProviderName(), other.getProviderName())) {
        return false;
    }
    if (Objects.equals(getQosName(), other.getQosName())) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!super.equals(obj)) {
        return false;
    }
    if (!(obj instanceof NetworkView)) {
        return false;
    }
    NetworkView other = (NetworkView) obj;
    if (getCompatibilityVersion() == null) {
        if (other.getCompatibilityVersion() != null) {
            return false;
        }
    } else if (!getCompatibilityVersion().equals(other.getCompatibilityVersion())) {
        return false;
    }
    if (getDataCenterName() == null) {
        if (other.getDataCenterName() != null) {
            return false;
        }
    } else if (!getDataCenterName().equals(other.getDataCenterName())) {
        return false;
    }
    if (!Objects.equals(getProviderName(), other.getProviderName())) {
        return false;
    }
    if (!Objects.equals(getQosName(), other.getQosName())) {
        return false;
    }
    return true;
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<NetworkView> nameColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(NetworkConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameNetwork(), "200px");
    CommentColumn<NetworkView> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    boolean virtMode = ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly);
    AbstractTextColumn<NetworkView> dcColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getDataCenterName();
        }
    };
    dcColumn.makeSortable(NetworkConditionFieldAutoCompleter.DATA_CENTER);
    // $NON-NLS-1$
    getTable().ensureColumnPresent(dcColumn, constants.dcNetwork(), virtMode, "200px");
    AbstractTextColumn<NetworkView> descriptionColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable(NetworkConditionFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.descriptionNetwork(), "300px");
    AbstractSafeHtmlColumn<NetworkView> roleColumn = new AbstractSafeHtmlColumn<NetworkView>() {

        @Override
        public SafeHtml getValue(NetworkView networkView) {
            List<SafeHtml> images = new LinkedList<>();
            if (networkView.isVmNetwork()) {
                images.add(vmImage);
            } else {
                images.add(emptyImage);
            }
            return MultiImageColumnHelper.getValue(images);
        }

        @Override
        public SafeHtml getTooltip(NetworkView networkView) {
            Map<SafeHtml, String> imagesToText = new LinkedHashMap<>();
            if (networkView.isVmNetwork()) {
                imagesToText.put(vmImage, constants.vmItemInfo());
            }
            return MultiImageColumnHelper.getTooltip(imagesToText);
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(roleColumn, constants.roleNetwork(), "60px");
    AbstractTextColumn<NetworkView> vlanColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getVlanId() == null ? "-" : object.getVlanId().toString();
        }
    };
    vlanColumn.makeSortable(NetworkConditionFieldAutoCompleter.VLAN_ID);
    // $NON-NLS-1$
    getTable().ensureColumnPresent(vlanColumn, constants.vlanNetwork(), virtMode, "60px");
    AbstractTextColumn<NetworkView> qosColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getQosName() == null ? "-" : object.getQosName().toString();
        }
    };
    vlanColumn.makeSortable(NetworkConditionFieldAutoCompleter.VLAN_ID);
    // $NON-NLS-1$
    getTable().ensureColumnPresent(qosColumn, constants.qosName(), virtMode, "60px");
    AbstractTextColumn<NetworkView> labelColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getLabel() == null ? "-" : object.getLabel();
        }
    };
    labelColumn.makeSortable(NetworkConditionFieldAutoCompleter.LABEL);
    // $NON-NLS-1$
    getTable().addColumn(labelColumn, constants.networkLabelNetworksTab(), "200px");
    providerColumn = new AbstractLinkColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getProvidedBy() == null ? "" : object.getProviderName();
        }
    };
    providerColumn.makeSortable(NetworkConditionFieldAutoCompleter.PROVIDER_NAME);
    // $NON-NLS-1$
    getTable().ensureColumnPresent(providerColumn, constants.providerNetwork(), virtMode, "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.newNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.importNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getImportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.editNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.removeNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<NetworkView> nameColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(NetworkConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameNetwork(), "200px");
    CommentColumn<NetworkView> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    boolean virtMode = ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly);
    AbstractTextColumn<NetworkView> dcColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getDataCenterName();
        }
    };
    dcColumn.makeSortable(NetworkConditionFieldAutoCompleter.DATA_CENTER);
    // $NON-NLS-1$
    getTable().ensureColumnPresent(dcColumn, constants.dcNetwork(), virtMode, "200px");
    AbstractTextColumn<NetworkView> descriptionColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable(NetworkConditionFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.descriptionNetwork(), "300px");
    AbstractSafeHtmlColumn<NetworkView> roleColumn = new AbstractSafeHtmlColumn<NetworkView>() {

        @Override
        public SafeHtml getValue(NetworkView networkView) {
            List<SafeHtml> images = new LinkedList<>();
            if (networkView.isVmNetwork()) {
                images.add(vmImage);
            } else {
                images.add(emptyImage);
            }
            return MultiImageColumnHelper.getValue(images);
        }

        @Override
        public SafeHtml getTooltip(NetworkView networkView) {
            Map<SafeHtml, String> imagesToText = new LinkedHashMap<>();
            if (networkView.isVmNetwork()) {
                imagesToText.put(vmImage, constants.vmItemInfo());
            }
            return MultiImageColumnHelper.getTooltip(imagesToText);
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(roleColumn, constants.roleNetwork(), "60px");
    AbstractTextColumn<NetworkView> vlanColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getVlanId() == null ? "-" : object.getVlanId().toString();
        }
    };
    vlanColumn.makeSortable(NetworkConditionFieldAutoCompleter.VLAN_ID);
    // $NON-NLS-1$
    getTable().ensureColumnPresent(vlanColumn, constants.vlanNetwork(), virtMode, "60px");
    AbstractTextColumn<NetworkView> qosColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getQosName() == null ? "-" : object.getQosName().toString();
        }
    };
    qosColumn.makeSortable(NetworkConditionFieldAutoCompleter.QOS);
    // $NON-NLS-1$
    getTable().ensureColumnPresent(qosColumn, constants.qosName(), virtMode, "60px");
    AbstractTextColumn<NetworkView> labelColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getLabel() == null ? "-" : object.getLabel();
        }
    };
    labelColumn.makeSortable(NetworkConditionFieldAutoCompleter.LABEL);
    // $NON-NLS-1$
    getTable().addColumn(labelColumn, constants.networkLabelNetworksTab(), "200px");
    providerColumn = new AbstractLinkColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getProvidedBy() == null ? "" : object.getProviderName();
        }
    };
    providerColumn.makeSortable(NetworkConditionFieldAutoCompleter.PROVIDER_NAME);
    // $NON-NLS-1$
    getTable().ensureColumnPresent(providerColumn, constants.providerNetwork(), virtMode, "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.newNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.importNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getImportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.editNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.removeNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
}
#end_block

#method_before
@Test
public void testStartPinnedVmWithMigration() {
    TestOptimizer optimizer = new TestOptimizer(EnumSet.noneOf(ClusterFeatures.class));
    Host host = optimizer.createHost("H1", 1000000000L);
    Host host2 = optimizer.createHost("H2", 1000000000L);
    // Create new instance of host to mimic the SDK's behaviour better
    Host dummyhost = new Host();
    dummyhost.setId("H1");
    VM vm = optimizer.createVm("VM-A", 10000000L);
    vm.getPlacementPolicy().setHost(dummyhost);
    vm.getPlacementPolicy().setAffinity("pinned");
    VM vm2 = optimizer.createVm("VM-A", 10000000L);
    vm2.setHost(host);
    HardSoftScore result = optimizer.startVm(vm).addMigration(vm2, host2).addMigration(vm, host).enablePolicyUnit(PolicyUnit.EVEN_GUEST_DIST_WEIGHT).enablePolicyUnit(PolicyUnit.PIN_TO_HOST_FILTER).score();
    assertNotEquals(0, result.getHardScore());
}
#method_after
@Test
public void testStartPinnedVmWithMigration() {
    TestOptimizer optimizer = new TestOptimizer(EnumSet.noneOf(ClusterFeatures.class));
    Host host = optimizer.createHost("H1", 1000000000L);
    Host host2 = optimizer.createHost("H2", 1000000000L);
    // Create new instance of host to mimic the SDK's behaviour better
    Host dummyhost = new Host();
    dummyhost.setId("H1");
    VM vm = optimizer.createVm("VM-A", 10000000L);
    vm.getPlacementPolicy().setHost(dummyhost);
    vm.getPlacementPolicy().setAffinity("pinned");
    VM vm2 = optimizer.createVm("VM-B", 10000000L);
    vm2.setHost(host);
    HardSoftScore result = optimizer.startVm(vm).addMigration(vm2, host2).addMigration(vm, host).enablePolicyUnit(PolicyUnit.EVEN_GUEST_DIST_WEIGHT).enablePolicyUnit(PolicyUnit.PIN_TO_HOST_FILTER).score();
    assertEquals(0, result.getHardScore());
}
#end_block

#method_before
@Test
public void testCpuEvenDistribution() {
    TestOptimizer optimizer = new TestOptimizer();
    optimizer.enablePolicyUnit(PolicyUnit.EVEN_DIST_WEIGHT, 1);
    Host h1 = optimizer.createHost("h1", 1000L * MB);
    Host h2 = optimizer.createHost("h2", 1000L * MB);
    HostInfo info1 = new HostInfo("h1");
    info1.setTotalThreads(1);
    HostInfo info2 = new HostInfo("h2");
    info2.setTotalThreads(1);
    optimizer.addFact(info1).addFact(info2);
    List<VmStats> statList = new ArrayList<>();
    final int vmCount = 4;
    // create VMs and add them to facts
    for (int i = 0; i < vmCount; ++i) {
        VM vm = optimizer.createVm("vm" + i, 1L * MB);
        vm.setHost(((i % 2) == 0) ? h1 : h2);
        VmStats stats = new VmStats("vm" + i);
        stats.setMemUsed(1L * MB);
        stats.setMemInstalled(1L * MB);
        stats.setCpuCurrentHypervisor(0.0f);
        statList.add(stats);
        VmInfo info = new VmInfo("vm" + i);
        info.setRunning(true);
        info.setTotalThreads(1);
        optimizer.addFact(stats).addFact(info).addMigration(vm, vm.getHost()).startVm(vm);
    }
    fillVmCpuUtil(statList, new float[] { 20.0f, 40.0f, 30.0f, 40.0f });
    HardSoftScore r1 = optimizer.score();
    fillVmCpuUtil(statList, new float[] { 20.0f, 30.0f, 40.0f, 40.0f });
    HardSoftScore r2 = optimizer.score();
    assertTrue(r1.getSoftScore() < r2.getSoftScore());
}
#method_after
@Test
public void testCpuEvenDistribution() {
    TestOptimizer optimizer = new TestOptimizer();
    optimizer.enablePolicyUnit(PolicyUnit.EVEN_DIST_WEIGHT, 1);
    // Create 2 hosts for distribution testing
    Host h1 = optimizer.createHost("h1", 1000L * MB);
    Host h2 = optimizer.createHost("h2", 1000L * MB);
    List<VmStats> statList = new ArrayList<>();
    final int vmCount = 4;
    // Create VMs and add them to facts
    for (int i = 0; i < vmCount; ++i) {
        VM vm = optimizer.createVm("vm" + i, 1L * MB);
        // set VMs to hosts uniformly
        vm.setHost(((i % 2) == 0) ? h1 : h2);
        VmStats stats = new VmStats("vm" + i);
        stats.setMemUsed(1L * MB);
        stats.setMemInstalled(1L * MB);
        stats.setCpuCurrentHypervisor(0.0f);
        statList.add(stats);
        optimizer.addFact(stats).addMigration(vm, vm.getHost()).startVm(vm);
    }
    // Change cpu load inside vm statistics and measure score
    fillVmCpuUtil(statList, new float[] { 20.0f, 40.0f, 30.0f, 40.0f });
    HardSoftScore r1 = optimizer.score();
    fillVmCpuUtil(statList, new float[] { 20.0f, 30.0f, 40.0f, 40.0f });
    HardSoftScore r2 = optimizer.score();
    assertTrue(r1.getSoftScore() < r2.getSoftScore());
}
#end_block

#method_before
@Test
public void testMemoryEvenDistribution() {
    TestOptimizer optimizer = new TestOptimizer();
    optimizer.enablePolicyUnit(PolicyUnit.EVEN_DIST_WEIGHT, 1);
    Host h1 = optimizer.createHost("h1", 1000L * MB);
    Host h2 = optimizer.createHost("h2", 1000L * MB);
    List<VM> vmList = new ArrayList<>();
    final int vmCount = 4;
    for (int i = 0; i < vmCount; ++i) {
        VM vm = optimizer.createVm("vm" + i, 1L * MB);
        vm.setHost(((i % 2) == 0) ? h1 : h2);
        optimizer.addMigration(vm, vm.getHost()).startVm(vm);
        vmList.add(vm);
    }
    fillVmMemoryUtil(vmList, new long[] { 200L * MB, 400L * MB, 300L * MB, 400L * MB });
    HardSoftScore r1 = optimizer.score();
    fillVmMemoryUtil(vmList, new long[] { 200L * MB, 300L * MB, 400L * MB, 400L * MB });
    HardSoftScore r2 = optimizer.score();
    assertTrue(r1.getSoftScore() < r2.getSoftScore());
}
#method_after
@Test
public void testMemoryEvenDistribution() {
    TestOptimizer optimizer = new TestOptimizer();
    optimizer.enablePolicyUnit(PolicyUnit.EVEN_DIST_WEIGHT, 1);
    Host h1 = optimizer.createHost("h1", 1000L * MB);
    Host h2 = optimizer.createHost("h2", 1000L * MB);
    List<VM> vmList = new ArrayList<>();
    final int vmCount = 4;
    for (int i = 0; i < vmCount; ++i) {
        VM vm = optimizer.createVm("vm" + i, 1L * MB);
        // set VMs to hosts uniformly
        vm.setHost(((i % 2) == 0) ? h1 : h2);
        optimizer.addMigration(vm, vm.getHost()).startVm(vm);
        vmList.add(vm);
    }
    // Change memory requirements of VMs and measure score
    fillVmMemoryUtil(vmList, new long[] { 200L * MB, 400L * MB, 300L * MB, 400L * MB });
    HardSoftScore r1 = optimizer.score();
    fillVmMemoryUtil(vmList, new long[] { 200L * MB, 300L * MB, 400L * MB, 400L * MB });
    HardSoftScore r2 = optimizer.score();
    assertTrue(r1.getSoftScore() < r2.getSoftScore());
}
#end_block

#method_before
@Test
public void testCpuHighUtilization() {
    TestOptimizer optimizer = new TestOptimizer();
    optimizer.enablePolicyUnit(PolicyUnit.EVEN_DIST_WEIGHT, 1);
    Property threshold = new Property();
    threshold.setName(PolicyProperty.HIGH_UTIL.getName());
    threshold.setValue("50");
    Host host = optimizer.createHost("h1", 1000000000L);
    HostInfo hostInfo = new HostInfo("h1");
    hostInfo.setTotalThreads(4);
    VM vm = optimizer.createVm("vm", 1000000L);
    vm.setHost(host);
    VmInfo vmInfo = new VmInfo("vm");
    vmInfo.setRunning(true);
    vmInfo.setTotalThreads(4);
    VmStats stats = new VmStats("vm");
    stats.setMemUsed(1000000L);
    stats.setMemInstalled(1000000L);
    stats.setCpuCurrentHypervisor(0.0f);
    stats.setCpuCurrentGuest(30.0f);
    stats.setCpuCurrentTotal(30.0f);
    optimizer.addMigration(vm, host).startVm(vm).addFact(threshold).addFact(hostInfo).addFact(vmInfo).addFact(stats);
    HardSoftScore r1 = optimizer.score();
    stats.setCpuCurrentGuest(40.0f);
    stats.setCpuCurrentTotal(40.0f);
    HardSoftScore r2 = optimizer.score();
    stats.setCpuCurrentGuest(60.0f);
    stats.setCpuCurrentTotal(60.0f);
    HardSoftScore r3 = optimizer.score();
    // assert big difference between r2 and r3
    assertTrue(r1.getSoftScore() >= r2.getSoftScore() && (r2.getSoftScore() - r3.getSoftScore()) > 10000);
}
#method_after
@Test
public void testCpuHighUtilization() {
    TestOptimizer optimizer = new TestOptimizer();
    optimizer.enablePolicyUnit(PolicyUnit.EVEN_DIST_WEIGHT, 1);
    // Set 50% cpu as overutilized
    Property threshold = new Property();
    threshold.setName(PolicyProperty.HIGH_UTIL.getName());
    threshold.setValue("50");
    Host host = optimizer.createHost("h1", 1000000000L);
    host.getCpu().getTopology().setCores(4);
    VM vm = optimizer.createVm("vm", 1000000L);
    vm.setHost(host);
    vm.getCpu().getTopology().setCores(4);
    VmStats stats = new VmStats("vm");
    stats.setMemUsed(1000000L);
    stats.setMemInstalled(1000000L);
    stats.setCpuCurrentHypervisor(0.0f);
    optimizer.addMigration(vm, host).startVm(vm).addFact(threshold).addFact(stats);
    // Test score with vm running at different cpu loads
    stats.setCpuCurrentGuest(30.0f);
    stats.setCpuCurrentTotal(30.0f);
    HardSoftScore r1 = optimizer.score();
    stats.setCpuCurrentGuest(40.0f);
    stats.setCpuCurrentTotal(40.0f);
    HardSoftScore r2 = optimizer.score();
    stats.setCpuCurrentGuest(60.0f);
    stats.setCpuCurrentTotal(60.0f);
    HardSoftScore r3 = optimizer.score();
    // assert big difference between r2 and r3
    assertTrue(r1.getSoftScore() >= r2.getSoftScore() && (r2.getSoftScore() - r3.getSoftScore()) > 10000);
}
#end_block

#method_before
@Test
public void testMemHighUtilization() {
    TestOptimizer optimizer = new TestOptimizer();
    optimizer.enablePolicyUnit(PolicyUnit.EVEN_DIST_WEIGHT, 1);
    Property threshold = new Property();
    threshold.setName(PolicyProperty.MAX_FREE_MEM_OVER_UTIL.getName());
    threshold.setValue(Long.toString(100L * MB));
    Host host = optimizer.createHost("h1", 1000L * MB);
    VM vm = optimizer.createVm("vm", 10L * MB);
    vm.setHost(host);
    VmInfo vmInfo = new VmInfo("vm");
    vmInfo.setRunning(true);
    vmInfo.setTotalThreads(4);
    optimizer.addMigration(vm, host).startVm(vm).addFact(threshold).addFact(vmInfo);
    HardSoftScore r1 = optimizer.score();
    vm.setMemory(100L * MB);
    vm.getMemoryPolicy().setGuaranteed(100L * MB);
    HardSoftScore r2 = optimizer.score();
    vm.setMemory(950L * MB);
    vm.getMemoryPolicy().setGuaranteed(950L * MB);
    HardSoftScore r3 = optimizer.score();
    // assert big difference between r2 and r3
    assertTrue(r1.getSoftScore() >= r2.getSoftScore() && (r2.getSoftScore() - r3.getSoftScore()) > 10000);
}
#method_after
@Test
public void testMemHighUtilization() {
    TestOptimizer optimizer = new TestOptimizer();
    optimizer.enablePolicyUnit(PolicyUnit.EVEN_DIST_WEIGHT, 1);
    // Set less than 100 MB free memory as overutilized
    Property threshold = new Property();
    threshold.setName(PolicyProperty.MAX_FREE_MEM_OVER_UTIL.getName());
    threshold.setValue(Long.toString(100L * MB));
    Host host = optimizer.createHost("h1", 1000L * MB);
    // Create vm with 10 MB memory
    VM vm = optimizer.createVm("vm", 10L * MB);
    vm.setHost(host);
    optimizer.addMigration(vm, host).startVm(vm).addFact(threshold);
    // Test score of vm with different memory requirements
    HardSoftScore r1 = optimizer.score();
    vm.setMemory(100L * MB);
    vm.getMemoryPolicy().setGuaranteed(100L * MB);
    HardSoftScore r2 = optimizer.score();
    vm.setMemory(950L * MB);
    vm.getMemoryPolicy().setGuaranteed(950L * MB);
    HardSoftScore r3 = optimizer.score();
    // assert big difference between r2 and r3
    assertTrue(r1.getSoftScore() >= r2.getSoftScore() && (r2.getSoftScore() - r3.getSoftScore()) > 10000);
}
#end_block

#method_before
@Test
public void testRunningHostPenalization() {
    TestOptimizer optimizer = new TestOptimizer();
    optimizer.enablePolicyUnit(PolicyUnit.POWER_SAVING_WEIGHT, 1);
    Host host1 = optimizer.createHost("h1", 1000000000L);
    Host host2 = optimizer.createHost("h2", 1000000000L);
    VM vm1 = optimizer.createVm("vm1", 1000000L);
    vm1.setHost(host1);
    VmInfo vmInfo1 = new VmInfo("vm1");
    vmInfo1.setRunning(true);
    VM vm2 = optimizer.createVm("vm2", 1000000L);
    vm2.setHost(host1);
    VmInfo vmInfo2 = new VmInfo("vm2");
    vmInfo2.setRunning(true);
    optimizer.addMigration(vm1, host1).startVm(vm1).startVm(vm2).addFact(vmInfo1).addFact(vmInfo2);
    HardSoftScore r1 = optimizer.score();
    vm2.setHost(host2);
    HardSoftScore r2 = optimizer.score();
    assertTrue(r1.getSoftScore() > r2.getSoftScore());
}
#method_after
@Test
public void testRunningHostPenalization() {
    TestOptimizer optimizer = new TestOptimizer();
    optimizer.enablePolicyUnit(PolicyUnit.POWER_SAVING_WEIGHT, 1);
    Host host1 = optimizer.createHost("h1", 1000000000L);
    Host host2 = optimizer.createHost("h2", 1000000000L);
    VM vm1 = optimizer.createVm("vm1", 1000000L);
    vm1.setHost(host1);
    VM vm2 = optimizer.createVm("vm2", 1000000L);
    vm2.setHost(host1);
    optimizer.addMigration(vm1, host1).startVm(vm1).startVm(vm2);
    HardSoftScore r1 = optimizer.score();
    vm2.setHost(host2);
    HardSoftScore r2 = optimizer.score();
    // Both VMs on the same host should have better score than one VM on each
    assertTrue(r1.getSoftScore() > r2.getSoftScore());
}
#end_block

#method_before
private void prepare() {
    while (bestSolution.getSteps().size() < numberOfSteps) {
        bestSolution.getSteps().add(new Migration());
    }
    ClusterSituation situation = bestSolution;
    for (Migration m : bestSolution.getSteps()) {
        m.recomputeSituationAfter(situation);
        situation = m;
    }
    for (VM vm : bestSolution.getVms()) {
        if (vm.getHost() != null) {
            bestSolution.getOtherFacts().add(new RunningVm(vm.getId()));
        }
    }
    bestSolution.establishStepOrdering();
}
#method_after
private void prepare() {
    while (bestSolution.getSteps().size() < numberOfSteps) {
        bestSolution.getSteps().add(new Migration());
    }
    ClusterSituation situation = bestSolution;
    for (Migration m : bestSolution.getSteps()) {
        m.recomputeSituationAfter(situation);
        situation = m;
    }
    for (VM vm : bestSolution.getVms()) {
        if (vm.getHost() != null) {
            bestSolution.getOtherFacts().add(new RunningVm(vm.getId()));
        }
    }
    bestSolution.establishStepOrdering();
    for (Host h : bestSolution.getHosts()) {
        HostInfo info = HostInfo.createFromHost(h, true);
        hostInfos.add(info);
        bestSolution.getFixedFacts().add(info);
    }
    for (VM vm : bestSolution.getVms()) {
        VmInfo info = VmInfo.createFromVm(vm, true);
        vmInfos.add(info);
        bestSolution.getFixedFacts().add(info);
    }
}
#end_block

#method_before
public OptimalDistributionStepsSolution run() {
    prepare();
    solver.solve(bestSolution);
    return (OptimalDistributionStepsSolution) solver.getBestSolution();
}
#method_after
public OptimalDistributionStepsSolution run() {
    prepare();
    solver.solve(bestSolution);
    OptimalDistributionStepsSolution solution = (OptimalDistributionStepsSolution) solver.getBestSolution();
    cleanup();
    return solution;
}
#end_block

#method_before
public HardSoftScore score() {
    prepare();
    ScoreDirector director = solver.getScoreDirectorFactory().buildScoreDirector();
    director.setWorkingSolution(bestSolution);
    return (HardSoftScore) director.calculateScore();
}
#method_after
public HardSoftScore score() {
    prepare();
    ScoreDirector director = solver.getScoreDirectorFactory().buildScoreDirector();
    director.setWorkingSolution(bestSolution);
    HardSoftScore score = (HardSoftScore) director.calculateScore();
    cleanup();
    return score;
}
#end_block

#method_before
public VM createVm(String name, Long memory) {
    VM vm = new VM();
    vm.setCluster(cluster);
    vm.setName(name);
    vm.setId(name);
    vm.setPlacementPolicy(new VmPlacementPolicy());
    vm.getPlacementPolicy().setAffinity("migratable");
    vm.setMemory(memory);
    vm.setMemoryPolicy(new MemoryPolicy());
    vm.getMemoryPolicy().setBallooning(false);
    vm.getMemoryPolicy().setGuaranteed(memory);
    vm.setCpu(new CPU());
    vm.getCpu().setArchitecture("Westmere");
    bestSolution.getVms().add(vm);
    return vm;
}
#method_after
public VM createVm(String name, Long memory) {
    VM vm = new VM();
    vm.setCluster(cluster);
    vm.setName(name);
    vm.setId(name);
    vm.setPlacementPolicy(new VmPlacementPolicy());
    vm.getPlacementPolicy().setAffinity("migratable");
    vm.setMemory(memory);
    vm.setMemoryPolicy(new MemoryPolicy());
    vm.getMemoryPolicy().setBallooning(false);
    vm.getMemoryPolicy().setGuaranteed(memory);
    vm.setCpu(new CPU());
    vm.getCpu().setArchitecture("Westmere");
    vm.getCpu().setTopology(new CpuTopology());
    bestSolution.getVms().add(vm);
    return vm;
}
#end_block

#method_before
public Host createHost(String name, Long memory) {
    Host host = new Host();
    host.setName(name);
    host.setId(name);
    host.setMemory(memory);
    host.setCluster(cluster);
    host.setCpu(new CPU());
    host.getCpu().setArchitecture("Westmere");
    bestSolution.getHosts().add(host);
    return host;
}
#method_after
public Host createHost(String name, Long memory) {
    Host host = new Host();
    host.setName(name);
    host.setId(name);
    host.setMemory(memory);
    host.setCluster(cluster);
    host.setCpu(new CPU());
    host.getCpu().setArchitecture("Westmere");
    host.getCpu().setTopology(new CpuTopology());
    bestSolution.getHosts().add(host);
    return host;
}
#end_block

#method_before
@Override
public void run() {
    log.info(String.format("Updater thread for %s starting", clusterId));
    while (running) {
        int refresh = Integer.valueOf(configProvider.load().getConfig().getProperty(ConfigProvider.SOLVER_DATA_REFRESH));
        Set<Host> hosts = new HashSet<>();
        Set<String> hostIds = new HashSet<>();
        Set<VM> vms = new HashSet<>();
        Set<Object> facts = new HashSet<>();
        try {
            Api engine = ovirtClient.getConnection();
            Cluster clusterInstance = engine.getClusters().getById(clusterId);
            DataCenter dataCenter = clusterInstance.getDataCenter();
            boolean threadsAsCores = clusterInstance.getThreadsAsCores();
            // Ask for all content (needed to get hosted engine info)
            for (Host host : engine.getHosts().list(null, null, null, "true")) {
                if (host.getCluster().getId().equals(clusterId)) {
                    log.debug(String.format("Discovered host %s (%s) on cluster %s with state %s", host.getName(), host.getId(), clusterId, host.getStatus().getState()));
                    if (host.getStatus().getState().equals("up")) {
                        /* Reconstruct references to other structures */
                        host.setCluster(clusterInstance);
                        /* Add the host to fact database */
                        hosts.add(host);
                        hostIds.add(host.getId());
                        HostStatistics stats = (HostStatistics) host.getStatistics();
                        HostStats hostStats = new HostStats(host.getId());
                        for (Statistic stat : stats.list()) {
                            hostStats.loadValue(stat);
                        }
                        facts.add(hostStats);
                        HostInfo info = new HostInfo(host.getId());
                        info.setTotalThreads(threadsFromTopology(host.getCpu().getTopology(), threadsAsCores));
                        facts.add(info);
                    }
                }
            }
            for (VM vm : engine.getVMs().list()) {
                final Host runningAt = vm.getHost();
                if (runningAt == null || hostIds.contains(runningAt.getId())) {
                    log.debug(String.format("Discovered VM %s (%s) on cluster %s", vm.getName(), vm.getId(), clusterId));
                    vms.add(vm);
                    if (runningAt != null) {
                        facts.add(new RunningVm(vm.getId()));
                    }
                    VMStatistics stats = (VMStatistics) vm.getStatistics();
                    VmStats vmStats = new VmStats(vm.getId());
                    for (Statistic stat : stats.list()) {
                        vmStats.loadValue(stat);
                    }
                    facts.add(vmStats);
                    VmInfo info = new VmInfo(vm.getId());
                    info.setRunning(runningAt != null);
                    info.setTotalThreads(threadsFromTopology(vm.getCpu().getTopology(), threadsAsCores));
                    facts.add(info);
                }
            }
            for (Network network : clusterInstance.getNetworks().list()) {
                if (network.getDataCenter() != null && network.getDataCenter().getId().equals(clusterInstance.getDataCenter().getId())) {
                    log.debug(String.format("Discovered Network %s (%s) on cluster %s [datacenter %s]", network.getName(), network.getId(), clusterInstance.getId(), dataCenter.getId()));
                    facts.add(network);
                }
            }
            String schedulingPolicyId = clusterInstance.getSchedulingPolicy().getId();
            SchedulingPolicy schedulingPolicy = engine.getSchedulingPolicies().getById(schedulingPolicyId);
            for (SchedulingPolicyWeight weight : schedulingPolicy.getWeights().list()) {
                log.debug("Found policy unit weight {} with factor {}", weight.getId(), weight.getFactor());
                PolicyUnitEnabled policyUnitEnabled = new PolicyUnitEnabled(weight.getId(), weight.getFactor());
                facts.add(policyUnitEnabled);
            }
            for (SchedulingPolicyFilter filter : schedulingPolicy.getFilters().list()) {
                log.debug("Found policy unit filter {}", filter.getId());
                PolicyUnitEnabled policyUnitEnabled = new PolicyUnitEnabled(filter.getId(), 1);
                facts.add(policyUnitEnabled);
            }
            for (SchedulingPolicyBalance balance : schedulingPolicy.getBalances().list()) {
                log.debug("Found policy unit balancer {}", balance.getId());
                PolicyUnitEnabled policyUnitEnabled = new PolicyUnitEnabled(balance.getId(), 1);
                facts.add(policyUnitEnabled);
            }
            /* Find scheduling policy properties - try cluster configuration first
                   and policy defaults as backup
                 */
            Collection<Property> schedulingPolicyProperties = null;
            if (clusterInstance.getSchedulingPolicy().getProperties() != null && clusterInstance.getSchedulingPolicy().getProperties().getProperties() != null) {
                schedulingPolicyProperties = clusterInstance.getSchedulingPolicy().getProperties().getProperties();
            } else if (schedulingPolicy.getProperties() != null && schedulingPolicy.getProperties().getProperties() != null) {
                schedulingPolicyProperties = schedulingPolicy.getProperties().getProperties();
            } else {
                log.debug("No cluster policy properties found");
            }
            if (schedulingPolicyProperties != null) {
                if (log.isDebugEnabled()) {
                    for (Property p : schedulingPolicyProperties) {
                        log.debug("Found policy property {} with value '{}'", p.getName(), p.getValue());
                    }
                }
                facts.addAll(schedulingPolicyProperties);
            }
        } catch (ConnectException ex) {
            log.error("Cluster update failed", ex);
            continue;
        } catch (IOException ex) {
            log.error("Cluster update failed", ex);
            continue;
        } catch (ServerException ex) {
            log.error("Cluster update failed", ex);
            continue;
        } catch (UnsecuredConnectionAttemptError ex) {
            log.error("Cluster update failed", ex);
            continue;
        }
        Set<ClusterUpdateAvailable> currentHandlers = new HashSet<>();
        synchronized (handlers) {
            currentHandlers.addAll(handlers);
        }
        for (ClusterUpdateAvailable handler : currentHandlers) {
            handler.checkUpdate(vms, hosts, facts);
        }
        // Wait, but watch for terminate command
        try {
            synchronized (this) {
                if (running) {
                    this.wait(refresh * 1000);
                }
            }
        } catch (InterruptedException ex) {
            Thread.currentThread().interrupt();
        }
    }
    log.info(String.format("Updater thread for %s finished", clusterId));
}
#method_after
@Override
public void run() {
    log.info(String.format("Updater thread for %s starting", clusterId));
    while (running) {
        int refresh = Integer.valueOf(configProvider.load().getConfig().getProperty(ConfigProvider.SOLVER_DATA_REFRESH));
        Set<Host> hosts = new HashSet<>();
        Set<String> hostIds = new HashSet<>();
        Set<VM> vms = new HashSet<>();
        Set<Object> facts = new HashSet<>();
        try {
            Api engine = ovirtClient.getConnection();
            Cluster clusterInstance = engine.getClusters().getById(clusterId);
            DataCenter dataCenter = clusterInstance.getDataCenter();
            boolean threadsAsCores = clusterInstance.getThreadsAsCores();
            // Ask for all content (needed to get hosted engine info)
            for (Host host : engine.getHosts().list(null, null, null, "true")) {
                if (host.getCluster().getId().equals(clusterId)) {
                    log.debug(String.format("Discovered host %s (%s) on cluster %s with state %s", host.getName(), host.getId(), clusterId, host.getStatus().getState()));
                    if (host.getStatus().getState().equals("up")) {
                        /* Reconstruct references to other structures */
                        host.setCluster(clusterInstance);
                        /* Add the host to fact database */
                        hosts.add(host);
                        hostIds.add(host.getId());
                        // Compile host statistics and add them to fact database
                        // Interestingly the typecast has to be to different object than
                        // the parameter of Host.setStatistics()
                        HostStatistics stats = (HostStatistics) host.getStatistics();
                        HostStats hostStats = new HostStats(host.getId());
                        for (Statistic stat : stats.list()) {
                            hostStats.loadValue(stat);
                        }
                        facts.add(hostStats);
                        // Add additional host info
                        facts.add(HostInfo.createFromHost(host, threadsAsCores));
                    }
                }
            }
            for (VM vm : engine.getVMs().list()) {
                final Host runningAt = vm.getHost();
                if (runningAt == null || hostIds.contains(runningAt.getId())) {
                    log.debug(String.format("Discovered VM %s (%s) on cluster %s", vm.getName(), vm.getId(), clusterId));
                    // Add VM to fact database
                    vms.add(vm);
                    if (runningAt != null) {
                        facts.add(new RunningVm(vm.getId()));
                    }
                    // Compile VM statistics and add them to fact database
                    // Typecast is needed; like for host statistics
                    VMStatistics stats = (VMStatistics) vm.getStatistics();
                    VmStats vmStats = new VmStats(vm.getId());
                    for (Statistic stat : stats.list()) {
                        vmStats.loadValue(stat);
                    }
                    facts.add(vmStats);
                    // Add additional VM info
                    facts.add(VmInfo.createFromVm(vm, threadsAsCores));
                }
            }
            for (Network network : clusterInstance.getNetworks().list()) {
                if (network.getDataCenter() != null && network.getDataCenter().getId().equals(clusterInstance.getDataCenter().getId())) {
                    log.debug(String.format("Discovered Network %s (%s) on cluster %s [datacenter %s]", network.getName(), network.getId(), clusterInstance.getId(), dataCenter.getId()));
                    facts.add(network);
                }
            }
            String schedulingPolicyId = clusterInstance.getSchedulingPolicy().getId();
            SchedulingPolicy schedulingPolicy = engine.getSchedulingPolicies().getById(schedulingPolicyId);
            for (SchedulingPolicyWeight weight : schedulingPolicy.getWeights().list()) {
                log.debug("Found policy unit weight {} with factor {}", weight.getId(), weight.getFactor());
                PolicyUnitEnabled policyUnitEnabled = new PolicyUnitEnabled(weight.getId(), weight.getFactor());
                facts.add(policyUnitEnabled);
            }
            for (SchedulingPolicyFilter filter : schedulingPolicy.getFilters().list()) {
                log.debug("Found policy unit filter {}", filter.getId());
                PolicyUnitEnabled policyUnitEnabled = new PolicyUnitEnabled(filter.getId(), 1);
                facts.add(policyUnitEnabled);
            }
            for (SchedulingPolicyBalance balance : schedulingPolicy.getBalances().list()) {
                log.debug("Found policy unit balancer {}", balance.getId());
                PolicyUnitEnabled policyUnitEnabled = new PolicyUnitEnabled(balance.getId(), 1);
                facts.add(policyUnitEnabled);
            }
            /* Find scheduling policy properties - try cluster configuration first
                   and policy defaults as backup
                 */
            Collection<Property> schedulingPolicyProperties = null;
            if (clusterInstance.getSchedulingPolicy().getProperties() != null && clusterInstance.getSchedulingPolicy().getProperties().getProperties() != null) {
                schedulingPolicyProperties = clusterInstance.getSchedulingPolicy().getProperties().getProperties();
            } else if (schedulingPolicy.getProperties() != null && schedulingPolicy.getProperties().getProperties() != null) {
                schedulingPolicyProperties = schedulingPolicy.getProperties().getProperties();
            } else {
                log.debug("No cluster policy properties found");
            }
            if (schedulingPolicyProperties != null) {
                if (log.isDebugEnabled()) {
                    for (Property p : schedulingPolicyProperties) {
                        log.debug("Found policy property {} with value '{}'", p.getName(), p.getValue());
                    }
                }
                facts.addAll(schedulingPolicyProperties);
            }
        } catch (ConnectException ex) {
            log.error("Cluster update failed", ex);
            continue;
        } catch (IOException ex) {
            log.error("Cluster update failed", ex);
            continue;
        } catch (ServerException ex) {
            log.error("Cluster update failed", ex);
            continue;
        } catch (UnsecuredConnectionAttemptError ex) {
            log.error("Cluster update failed", ex);
            continue;
        }
        Set<ClusterUpdateAvailable> currentHandlers = new HashSet<>();
        synchronized (handlers) {
            currentHandlers.addAll(handlers);
        }
        for (ClusterUpdateAvailable handler : currentHandlers) {
            handler.checkUpdate(vms, hosts, facts);
        }
        // Wait, but watch for terminate command
        try {
            synchronized (this) {
                if (running) {
                    this.wait(refresh * 1000);
                }
            }
        } catch (InterruptedException ex) {
            Thread.currentThread().interrupt();
        }
    }
    log.info(String.format("Updater thread for %s finished", clusterId));
}
#end_block

#method_before
void bindModels() {
    bind(AdElementListModel.class).to(UserPortalAdElementListModel.class);
    // Basic tab
    bind(UserPortalBasicListModel.class).in(Singleton.class);
    bind(VmBasicDiskListModel.class).in(Singleton.class);
    // Extended tab: Virtual Machine
    bind(UserPortalListModel.class).in(Singleton.class);
    bind(VmGeneralModel.class).in(Singleton.class);
    bind(PoolGeneralModel.class).in(Singleton.class);
    bind(VmInterfaceListModel.class).in(Singleton.class);
    bind(VmDiskListModel.class).in(Singleton.class);
    bind(PoolDiskListModel.class).in(Singleton.class);
    bind(UserPortalVmSnapshotListModel.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalPermissionListModel<UserPortalListModel>>() {
    }).in(Singleton.class);
    bind(UserPortalVmEventListModel.class).in(Singleton.class);
    bind(new TypeLiteral<VmAppListModel<VM>>() {
    }).in(Singleton.class);
    bind(VmMonitorModel.class).in(Singleton.class);
    bind(PoolInterfaceListModel.class).in(Singleton.class);
    bind(VmGuestInfoModel.class).in(Singleton.class);
    // Extended tab: Template
    bind(UserPortalTemplateListModel.class).in(Singleton.class);
    bind(TemplateGeneralModel.class).in(Singleton.class);
    bind(TemplateInterfaceListModel.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalPermissionListModel<VmTemplate>>() {
    }).in(Singleton.class);
    bind(UserPortalTemplateDiskListModel.class).in(Singleton.class);
    bind(UserPortalTemplateEventListModel.class).in(Singleton.class);
    // Extended tab: Resources
    bind(ResourcesModel.class).in(Singleton.class);
    // User Options
    bind(EditOptionsModel.class).in(Singleton.class);
}
#method_after
void bindModels() {
    bind(AdElementListModel.class).to(UserPortalAdElementListModel.class);
    // Basic tab
    bind(UserPortalBasicListModel.class).in(Singleton.class);
    bind(VmBasicDiskListModel.class).in(Singleton.class);
    // Extended tab: Virtual Machine
    bind(UserPortalListModel.class).in(Singleton.class);
    bind(VmGeneralModel.class).in(Singleton.class);
    bind(PoolGeneralModel.class).in(Singleton.class);
    bind(VmInterfaceListModel.class).in(Singleton.class);
    bind(VmDiskListModel.class).in(Singleton.class);
    bind(PoolDiskListModel.class).in(Singleton.class);
    bind(UserPortalVmSnapshotListModel.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalPermissionListModel<UserPortalListModel>>() {
    }).in(Singleton.class);
    bind(UserPortalVmEventListModel.class).in(Singleton.class);
    bind(new TypeLiteral<VmAppListModel<VM>>() {
    }).in(Singleton.class);
    bind(VmMonitorModel.class).in(Singleton.class);
    bind(PoolInterfaceListModel.class).in(Singleton.class);
    bind(VmGuestInfoModel.class).in(Singleton.class);
    // Extended tab: Template
    bind(UserPortalTemplateListModel.class).in(Singleton.class);
    bind(TemplateGeneralModel.class).in(Singleton.class);
    bind(TemplateInterfaceListModel.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalPermissionListModel<VmTemplate>>() {
    }).in(Singleton.class);
    bind(UserPortalTemplateDiskListModel.class).in(Singleton.class);
    bind(UserPortalTemplateEventListModel.class).in(Singleton.class);
    // Extended tab: Resources
    bind(ResourcesModel.class).in(Singleton.class);
    // User Options
    bind(OptionsModel.class).in(Singleton.class);
}
#end_block

#method_before
void bindModelProviders() {
    // Basic tab
    bind(UserPortalBasicListProvider.class).in(Singleton.class);
    // Extended tab: Virtual Machine
    bind(UserPortalListProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalListModel, VmGeneralModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalListModel, PoolGeneralModel>>() {
    }).in(Singleton.class);
    bind(VmInterfaceListModelProvider.class).in(Singleton.class);
    bind(VmDiskListModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<Disk, UserPortalListModel, PoolDiskListModel>>() {
    }).in(Singleton.class);
    bind(VmSnapshotListModelProvider.class).in(Singleton.class);
    bind(VmPermissionListModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<AuditLog, UserPortalListModel, UserPortalVmEventListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<String, UserPortalListModel, VmAppListModel<VM>>>() {
    }).in(Singleton.class);
    bind(VmMonitorModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<VmNetworkInterface, UserPortalListModel, PoolInterfaceListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalListModel, VmGuestInfoModel>>() {
    }).in(Singleton.class);
    // Extended tab: Template
    bind(UserPortalTemplateListProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalTemplateListModel, TemplateGeneralModel>>() {
    }).in(Singleton.class);
    bind(TemplateInterfaceListModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<DiskImage, UserPortalTemplateListModel, UserPortalTemplateDiskListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<AuditLog, UserPortalTemplateListModel, UserPortalTemplateEventListModel>>() {
    }).in(Singleton.class);
    bind(TemplatePermissionListModelProvider.class).in(Singleton.class);
    // Extended tab: Resources
    bind(new TypeLiteral<UserPortalDataBoundModelProvider<VM, ResourcesModel>>() {
    }).in(Singleton.class);
}
#method_after
void bindModelProviders() {
    // Basic tab
    bind(UserPortalBasicListProvider.class).in(Singleton.class);
    // Options
    bind(OptionsProvider.class).in(Singleton.class);
    // Extended tab: Virtual Machine
    bind(UserPortalListProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalListModel, VmGeneralModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalListModel, PoolGeneralModel>>() {
    }).in(Singleton.class);
    bind(VmInterfaceListModelProvider.class).in(Singleton.class);
    bind(VmDiskListModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<Disk, UserPortalListModel, PoolDiskListModel>>() {
    }).in(Singleton.class);
    bind(VmSnapshotListModelProvider.class).in(Singleton.class);
    bind(VmPermissionListModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<AuditLog, UserPortalListModel, UserPortalVmEventListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<String, UserPortalListModel, VmAppListModel<VM>>>() {
    }).in(Singleton.class);
    bind(VmMonitorModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<VmNetworkInterface, UserPortalListModel, PoolInterfaceListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalListModel, VmGuestInfoModel>>() {
    }).in(Singleton.class);
    // Extended tab: Template
    bind(UserPortalTemplateListProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalTemplateListModel, TemplateGeneralModel>>() {
    }).in(Singleton.class);
    bind(TemplateInterfaceListModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<DiskImage, UserPortalTemplateListModel, UserPortalTemplateDiskListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<AuditLog, UserPortalTemplateListModel, UserPortalTemplateEventListModel>>() {
    }).in(Singleton.class);
    bind(TemplatePermissionListModelProvider.class).in(Singleton.class);
    // Extended tab: Resources
    bind(new TypeLiteral<UserPortalDataBoundModelProvider<VM, ResourcesModel>>() {
    }).in(Singleton.class);
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabBasicPresenter.class, MainTabBasicPresenter.ViewDef.class, MainTabBasicView.class, MainTabBasicPresenter.ProxyDef.class);
    bindPresenter(MainTabExtendedPresenter.class, MainTabExtendedPresenter.ViewDef.class, MainTabExtendedView.class, MainTabExtendedPresenter.ProxyDef.class);
    // Main section: side tabs
    bindPresenter(SideTabExtendedVirtualMachinePresenter.class, SideTabExtendedVirtualMachinePresenter.ViewDef.class, SideTabExtendedVirtualMachineView.class, SideTabExtendedVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(SideTabExtendedTemplatePresenter.class, SideTabExtendedTemplatePresenter.ViewDef.class, SideTabExtendedTemplateView.class, SideTabExtendedTemplatePresenter.ProxyDef.class);
    bindPresenter(SideTabExtendedResourcePresenter.class, SideTabExtendedResourcePresenter.ViewDef.class, SideTabExtendedResourceView.class, SideTabExtendedResourcePresenter.ProxyDef.class);
    // Main section: sub tabs
    // Virtual Machine
    bindPresenter(ExtendedVmSubTabPanelPresenter.class, ExtendedVmSubTabPanelPresenter.ViewDef.class, ExtendedVmSubTabPanelView.class, ExtendedVmSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmGeneralPresenter.class, SubTabExtendedVmGeneralPresenter.ViewDef.class, SubTabExtendedVmGeneralView.class, SubTabExtendedVmGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolGeneralPresenter.class, SubTabExtendedPoolGeneralPresenter.ViewDef.class, SubTabExtendedPoolGeneralView.class, SubTabExtendedPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmNetworkInterfacePresenter.class, SubTabExtendedVmNetworkInterfacePresenter.ViewDef.class, SubTabExtendedVmNetworkInterfaceView.class, SubTabExtendedVmNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolNetworkInterfacePresenter.class, SubTabExtendedPoolNetworkInterfacePresenter.ViewDef.class, SubTabExtendedPoolNetworkInterfaceView.class, SubTabExtendedPoolNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmVirtualDiskPresenter.class, SubTabExtendedVmVirtualDiskPresenter.ViewDef.class, SubTabExtendedVmVirtualDiskView.class, SubTabExtendedVmVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolVirtualDiskPresenter.class, SubTabExtendedPoolVirtualDiskPresenter.ViewDef.class, SubTabExtendedPoolVirtualDiskView.class, SubTabExtendedPoolVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmSnapshotPresenter.class, SubTabExtendedVmSnapshotPresenter.ViewDef.class, SubTabExtendedVmSnapshotView.class, SubTabExtendedVmSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmPermissionPresenter.class, SubTabExtendedVmPermissionPresenter.ViewDef.class, SubTabExtendedVmPermissionView.class, SubTabExtendedVmPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmEventPresenter.class, SubTabExtendedVmEventPresenter.ViewDef.class, SubTabExtendedVmEventView.class, SubTabExtendedVmEventPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmApplicationPresenter.class, SubTabExtendedVmApplicationPresenter.ViewDef.class, SubTabExtendedVmApplicationView.class, SubTabExtendedVmApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmMonitorPresenter.class, SubTabExtendedVmMonitorPresenter.ViewDef.class, SubTabExtendedVmMonitorView.class, SubTabExtendedVmMonitorPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmGuestInfoPresenter.class, SubTabExtendedVmGuestInfoPresenter.ViewDef.class, SubTabExtendedVmGuestInfoView.class, SubTabExtendedVmGuestInfoPresenter.ProxyDef.class);
    // Template
    bindPresenter(ExtendedTemplateSubTabPanelPresenter.class, ExtendedTemplateSubTabPanelPresenter.ViewDef.class, ExtendedTemplateSubTabPanelView.class, ExtendedTemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateGeneralPresenter.class, SubTabExtendedTemplateGeneralPresenter.ViewDef.class, SubTabExtendedTemplateGeneralView.class, SubTabExtendedTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateNetworkInterfacesPresenter.class, SubTabExtendedTemplateNetworkInterfacesPresenter.ViewDef.class, SubTabExtendedTemplateNetworkInterfacesView.class, SubTabExtendedTemplateNetworkInterfacesPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateVirtualDisksPresenter.class, SubTabExtendedTemplateVirtualDisksPresenter.ViewDef.class, SubTabExtendedTemplateVirtualDisksView.class, SubTabExtendedTemplateVirtualDisksPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateEventsPresenter.class, SubTabExtendedTemplateEventsPresenter.ViewDef.class, SubTabExtendedTemplateEventsView.class, SubTabExtendedTemplateEventsPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplatePermissionsPresenter.class, SubTabExtendedTemplatePermissionsPresenter.ViewDef.class, SubTabExtendedTemplatePermissionsView.class, SubTabExtendedTemplatePermissionsPresenter.ProxyDef.class);
    // Main section: basic view
    bindSingletonPresenterWidget(MainTabBasicDetailsPresenterWidget.class, MainTabBasicDetailsPresenterWidget.ViewDef.class, MainTabBasicDetailsView.class);
    bindSingletonPresenterWidget(MainTabBasicListPresenterWidget.class, MainTabBasicListPresenterWidget.ViewDef.class, MainTabBasicListView.class);
    bindPresenterWidget(MainTabBasicListItemPresenterWidget.class, MainTabBasicListItemPresenterWidget.ViewDef.class, MainTabBasicListItemView.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // VM popups
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    bindPresenterWidget(PublicKeyPopupPresenterWidget.class, PublicKeyPopupPresenterWidget.ViewDef.class, PublicKeyPopupView.class);
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Template popups
    bindPresenterWidget(TemplateEditPopupPresenterWidget.class, TemplateEditPopupPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Options popups
    bindPresenterWidget(OptionsPopupPresenterWidget.class, OptionsPopupPresenterWidget.ViewDef.class, OptionsPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabBasicPresenter.class, MainTabBasicPresenter.ViewDef.class, MainTabBasicView.class, MainTabBasicPresenter.ProxyDef.class);
    bindPresenter(MainTabExtendedPresenter.class, MainTabExtendedPresenter.ViewDef.class, MainTabExtendedView.class, MainTabExtendedPresenter.ProxyDef.class);
    // Main section: side tabs
    bindPresenter(SideTabExtendedVirtualMachinePresenter.class, SideTabExtendedVirtualMachinePresenter.ViewDef.class, SideTabExtendedVirtualMachineView.class, SideTabExtendedVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(SideTabExtendedTemplatePresenter.class, SideTabExtendedTemplatePresenter.ViewDef.class, SideTabExtendedTemplateView.class, SideTabExtendedTemplatePresenter.ProxyDef.class);
    bindPresenter(SideTabExtendedResourcePresenter.class, SideTabExtendedResourcePresenter.ViewDef.class, SideTabExtendedResourceView.class, SideTabExtendedResourcePresenter.ProxyDef.class);
    // Main section: sub tabs
    // Virtual Machine
    bindPresenter(ExtendedVmSubTabPanelPresenter.class, ExtendedVmSubTabPanelPresenter.ViewDef.class, ExtendedVmSubTabPanelView.class, ExtendedVmSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmGeneralPresenter.class, SubTabExtendedVmGeneralPresenter.ViewDef.class, SubTabExtendedVmGeneralView.class, SubTabExtendedVmGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolGeneralPresenter.class, SubTabExtendedPoolGeneralPresenter.ViewDef.class, SubTabExtendedPoolGeneralView.class, SubTabExtendedPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmNetworkInterfacePresenter.class, SubTabExtendedVmNetworkInterfacePresenter.ViewDef.class, SubTabExtendedVmNetworkInterfaceView.class, SubTabExtendedVmNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolNetworkInterfacePresenter.class, SubTabExtendedPoolNetworkInterfacePresenter.ViewDef.class, SubTabExtendedPoolNetworkInterfaceView.class, SubTabExtendedPoolNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmVirtualDiskPresenter.class, SubTabExtendedVmVirtualDiskPresenter.ViewDef.class, SubTabExtendedVmVirtualDiskView.class, SubTabExtendedVmVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolVirtualDiskPresenter.class, SubTabExtendedPoolVirtualDiskPresenter.ViewDef.class, SubTabExtendedPoolVirtualDiskView.class, SubTabExtendedPoolVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmSnapshotPresenter.class, SubTabExtendedVmSnapshotPresenter.ViewDef.class, SubTabExtendedVmSnapshotView.class, SubTabExtendedVmSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmPermissionPresenter.class, SubTabExtendedVmPermissionPresenter.ViewDef.class, SubTabExtendedVmPermissionView.class, SubTabExtendedVmPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmEventPresenter.class, SubTabExtendedVmEventPresenter.ViewDef.class, SubTabExtendedVmEventView.class, SubTabExtendedVmEventPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmApplicationPresenter.class, SubTabExtendedVmApplicationPresenter.ViewDef.class, SubTabExtendedVmApplicationView.class, SubTabExtendedVmApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmMonitorPresenter.class, SubTabExtendedVmMonitorPresenter.ViewDef.class, SubTabExtendedVmMonitorView.class, SubTabExtendedVmMonitorPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmGuestInfoPresenter.class, SubTabExtendedVmGuestInfoPresenter.ViewDef.class, SubTabExtendedVmGuestInfoView.class, SubTabExtendedVmGuestInfoPresenter.ProxyDef.class);
    // Template
    bindPresenter(ExtendedTemplateSubTabPanelPresenter.class, ExtendedTemplateSubTabPanelPresenter.ViewDef.class, ExtendedTemplateSubTabPanelView.class, ExtendedTemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateGeneralPresenter.class, SubTabExtendedTemplateGeneralPresenter.ViewDef.class, SubTabExtendedTemplateGeneralView.class, SubTabExtendedTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateNetworkInterfacesPresenter.class, SubTabExtendedTemplateNetworkInterfacesPresenter.ViewDef.class, SubTabExtendedTemplateNetworkInterfacesView.class, SubTabExtendedTemplateNetworkInterfacesPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateVirtualDisksPresenter.class, SubTabExtendedTemplateVirtualDisksPresenter.ViewDef.class, SubTabExtendedTemplateVirtualDisksView.class, SubTabExtendedTemplateVirtualDisksPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateEventsPresenter.class, SubTabExtendedTemplateEventsPresenter.ViewDef.class, SubTabExtendedTemplateEventsView.class, SubTabExtendedTemplateEventsPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplatePermissionsPresenter.class, SubTabExtendedTemplatePermissionsPresenter.ViewDef.class, SubTabExtendedTemplatePermissionsView.class, SubTabExtendedTemplatePermissionsPresenter.ProxyDef.class);
    // Main section: basic view
    bindSingletonPresenterWidget(MainTabBasicDetailsPresenterWidget.class, MainTabBasicDetailsPresenterWidget.ViewDef.class, MainTabBasicDetailsView.class);
    bindSingletonPresenterWidget(MainTabBasicListPresenterWidget.class, MainTabBasicListPresenterWidget.ViewDef.class, MainTabBasicListView.class);
    bindPresenterWidget(MainTabBasicListItemPresenterWidget.class, MainTabBasicListItemPresenterWidget.ViewDef.class, MainTabBasicListItemView.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // VM popups
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    bindPresenterWidget(PublicKeyPopupPresenterWidget.class, PublicKeyPopupPresenterWidget.ViewDef.class, PublicKeyPopupView.class);
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Template popups
    bindPresenterWidget(TemplateEditPopupPresenterWidget.class, TemplateEditPopupPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Options popups
    bindPresenterWidget(OptionsPopupPresenterWidget.class, OptionsPopupPresenterWidget.ViewDef.class, OptionsPopupView.class);
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    registerHandler(getView().getAboutLink().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            RevealRootPopupContentEvent.fire(HeaderPresenterWidget.this, aboutPopup);
        }
    }));
    registerHandler(getView().getOptionsLink().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            UserPortalBasicListModel model = basicListProvider.getModel();
            model.executeCommand(model.getEditCommand());
        }
    }));
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    registerHandler(getView().getAboutLink().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            RevealRootPopupContentEvent.fire(HeaderPresenterWidget.this, aboutPopup);
        }
    }));
    registerHandler(getView().getOptionsLink().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            OptionsModel model = optionsProvider.getModel();
            model.executeCommand(model.getEditCommand());
        }
    }));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    StoragePoolIsoMap map = loadStoragePoolIsoMap();
    changeDomainStatusWithCompensation(map, StorageDomainStatus.Unknown, StorageDomainStatus.Locked, getCompensationContext());
    if (shouldPerformOvfUpdate()) {
        runInternalAction(VdcActionType.ProcessOvfUpdateForStoragePool, new StoragePoolParametersBase(getStoragePoolId()), null);
        if (ovfOnAnyDomainSupported()) {
            VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.ProcessOvfUpdateForStorageDomain, createProcessOvfUpdateForDomainParams(), null);
            getReturnValue().getVdsmTaskIdList().addAll(tmpRetValue.getInternalVdsmTaskIdList());
        }
    }
    if (getReturnValue().getVdsmTaskIdList().isEmpty()) {
        setSucceeded(executeDeactivateCommand(true));
    } else {
        setCommandShouldBeLogged(false);
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    StoragePoolIsoMap map = loadStoragePoolIsoMap();
    changeDomainStatusWithCompensation(map, StorageDomainStatus.Unknown, StorageDomainStatus.Locked, getCompensationContext());
    if (shouldPerformOvfUpdate()) {
        ProcessOvfUpdateForStoragePoolParameters parameters = new ProcessOvfUpdateForStoragePoolParameters(getStoragePoolId());
        parameters.setUpdateStorage(false);
        runInternalAction(VdcActionType.ProcessOvfUpdateForStoragePool, parameters, null);
        if (ovfOnAnyDomainSupported()) {
            VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.ProcessOvfUpdateForStorageDomain, createProcessOvfUpdateForDomainParams(), null);
            getReturnValue().getVdsmTaskIdList().addAll(tmpRetValue.getInternalVdsmTaskIdList());
        }
    }
    if (getReturnValue().getVdsmTaskIdList().isEmpty()) {
        setSucceeded(executeDeactivateCommand(true));
    } else {
        setCommandShouldBeLogged(false);
        setSucceeded(true);
    }
}
#end_block

#method_before
protected boolean shouldPerformOvfUpdate() {
    return !getParameters().isInactive() && isOvfDataShouldBeUpdatedInDB() && getStorageDomain().getStatus() == StorageDomainStatus.Active && getStorageDomain().getStorageDomainType().isDataDomain();
}
#method_after
protected boolean shouldPerformOvfUpdate() {
    return !getParameters().isInactive() && getStorageDomain().getStatus() == StorageDomainStatus.Active && getStorageDomain().getStorageDomainType().isDataDomain();
}
#end_block

#method_before
protected Set<Guid> validateAndUpdateHostsInPlacementPolicy(VmPlacementPolicy placementPolicy) {
    Set<Guid> hostsGuidsSet = new HashSet<Guid>();
    // if there is single host element, with host name
    if (placementPolicy.isSetHost()) {
        Host host = placementPolicy.getHost();
        if (host.isSetId() || host.isSetName()) {
            validateParameters(placementPolicy, "host.id|name");
            updateIdForSingleHost(host, hostsGuidsSet);
        }
    }
    // or there is Hosts element containing any hosts
    if (placementPolicy.isSetHosts() && placementPolicy.getHosts().getHosts().size() > 0) {
        for (Host host : placementPolicy.getHosts().getHosts()) {
            validateParameters(host, "id|name");
            // for each host that is specified by name or id
            updateIdForSingleHost(host, hostsGuidsSet);
        }
    }
    return hostsGuidsSet;
}
#method_after
protected Set<Guid> validateAndUpdateHostsInPlacementPolicy(VmPlacementPolicy placementPolicy) {
    Set<Guid> hostsGuidsSet = new HashSet<Guid>();
    // if there is single host element, with host name
    if (placementPolicy.isSetHost()) {
        Host host = placementPolicy.getHost();
        if (host.isSetId() || host.isSetName()) {
            updateIdForSingleHost(host, hostsGuidsSet);
        }
    }
    // or there is Hosts element containing any hosts
    if (placementPolicy.isSetHosts() && placementPolicy.getHosts().getHosts().size() > 0) {
        for (Host host : placementPolicy.getHosts().getHosts()) {
            validateParameters(host, "id|name");
            // for each host that is specified by name or id
            updateIdForSingleHost(host, hostsGuidsSet);
        }
    }
    return hostsGuidsSet;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    RemoveProviderValidator validator = new RemoveProviderValidator(vmDao, getDeletedProvider());
    return validate(validator.providerIsSet()) && validate(validator.providerNetworksNotUsed()) && validateCinderStorageDomain();
}
#method_after
@Override
protected boolean canDoAction() {
    RemoveProviderValidator validator = new RemoveProviderValidator(vmDao, getDeletedProvider());
    return validate(validator.providerIsSet()) && validate(validator.providerNetworksNotUsed()) && validateRemoveProvider();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final Guid providerId = getParameters().getProvider().getId();
    ProviderProxy providerProxy = ProviderProxyFactory.getInstance().create(getParameters().getProvider());
    if (providerProxy != null) {
        providerProxy.onRemoval();
    }
    getProviderDao().remove(providerId);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final Guid providerId = getParameters().getProvider().getId();
    if (getProviderProxy() != null) {
        getProviderProxy().onRemoval();
    }
    getProviderDao().remove(providerId);
    setSucceeded(true);
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc changeFloppy(String vmId, String imageLocation) {
    // TODO DriveSpec should be used instead of imageLocation
    JsonRpcRequest request = new RequestBuilder("VM.changeFloppy").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("status");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturnForXmlRpc changeFloppy(String vmId, String imageLocation) {
    // TODO DriveSpec should be used instead of imageLocation
    JsonRpcRequest request = new RequestBuilder("VM.changeFloppy").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#end_block

#method_before
public StatusOnlyReturnForXmlRpc convertVmFromExternalSystem(String url, String user, String password, Map<String, Object> vm, String jobUUID) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.convertExternalVm(url, user, password, vm, jobUUID);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc convertVmFromExternalSystem(String url, String user, String password, Map<String, Object> vm, String jobUUID) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.convertExternalVm(url, user, password, vm, jobUUID);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
public OvfReturnForXmlRpc getConvertedVm(String jobUUID) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.getConvertedVm(jobUUID);
        return new OvfReturnForXmlRpc(xmlRpcReturnValue);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public OvfReturnForXmlRpc getConvertedVm(String jobUUID) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.getConvertedVm(jobUUID);
        return new OvfReturnForXmlRpc(xmlRpcReturnValue);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
private boolean restoreVolumeToSnapshot(Guid upServerId, GlusterVolumeEntity volume, String snapshotName) {
    if (volume != null) {
        try (EngineLock lock = acquireEngineLock(volume.getClusterId(), LockingGroup.GLUSTER)) {
            VDSReturnValue retVal = runVdsCommand(VDSCommandType.RestoreGlusterVolumeSnapshot, new GlusterVolumeSnapshotActionVDSParameters(upServerId, volume.getName(), snapshotName));
            if (!retVal.getSucceeded()) {
                handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_RESTORE_FAILED, retVal.getVdsError().getMessage());
                setSucceeded(false);
                return false;
            } else {
                getGlusterVolumeSnapshotDao().removeByName(volume.getId(), snapshotName);
                // Sync the new bricks of the volume immediately
                List<GlusterBrickEntity> oldBricks = volume.getBricks();
                getGlusterBrickDao().removeAllInBatch(oldBricks);
                VDS upServer = getClusterUtils().getRandomUpServer(volume.getClusterId());
                VDSReturnValue volDetailsRetVal = runVdsCommand(VDSCommandType.GetGlusterVolumeInfo, new GlusterVolumeInfoVDSParameters(upServer.getId(), volume.getClusterId(), volume.getName()));
                GlusterVolumeEntity fetchedVolume = ((Map<Guid, GlusterVolumeEntity>) volDetailsRetVal.getReturnValue()).get(volume.getId());
                List<GlusterBrickEntity> fetchedBricks = fetchedVolume.getBricks();
                if (fetchedBricks != null) {
                    for (GlusterBrickEntity fetchdBrick : fetchedVolume.getBricks()) {
                        if (fetchdBrick.getServerId() != null) {
                            fetchdBrick.setStatus(GlusterStatus.UP);
                            getGlusterBrickDao().save(fetchdBrick);
                        }
                    }
                }
            }
        }
    }
    return true;
}
#method_after
private boolean restoreVolumeToSnapshot(Guid upServerId, GlusterVolumeEntity volume, String snapshotName) {
    if (volume != null) {
        VDSReturnValue retVal = runVdsCommand(VDSCommandType.RestoreGlusterVolumeSnapshot, new GlusterVolumeSnapshotActionVDSParameters(upServerId, volume.getName(), snapshotName));
        if (!retVal.getSucceeded()) {
            handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_RESTORE_FAILED, retVal.getVdsError().getMessage());
            setSucceeded(false);
            return false;
        } else {
            getGlusterVolumeSnapshotDao().removeByName(volume.getId(), snapshotName);
            // Sync the new bricks of the volume immediately
            VDS upServer = getClusterUtils().getRandomUpServer(volume.getClusterId());
            VDSReturnValue volDetailsRetVal = runVdsCommand(VDSCommandType.GetGlusterVolumeInfo, new GlusterVolumeInfoVDSParameters(upServer.getId(), volume.getClusterId(), volume.getName()));
            GlusterVolumeEntity fetchedVolume = ((Map<Guid, GlusterVolumeEntity>) volDetailsRetVal.getReturnValue()).get(volume.getId());
            List<GlusterBrickEntity> fetchedBricks = fetchedVolume.getBricks();
            if (fetchedBricks != null) {
                getGlusterBrickDao().removeAllInBatch(volume.getBricks());
                for (GlusterBrickEntity fetchdBrick : fetchedVolume.getBricks()) {
                    if (fetchdBrick.getServerId() != null) {
                        fetchdBrick.setStatus(GlusterStatus.UP);
                        getGlusterBrickDao().save(fetchdBrick);
                    } else {
                        log.warn("Invalid server details for brick " + fetchdBrick.getName() + ". Not adding now.");
                    }
                }
            }
        }
    }
    return true;
}
#end_block

#method_before
private boolean restoreSlaveVolumesToSnapshot(List<GlusterGeoRepSession> geoRepSessions, String snapshotName) {
    for (GlusterGeoRepSession session : geoRepSessions) {
        GlusterVolumeEntity slaveVolume = getDbFacade().getGlusterVolumeDao().getById(session.getSlaveVolumeId());
        if (slaveVolume == null) {
            // continue with other sessions and try to pause
            continue;
        }
        VDS slaveUpServer = ClusterUtils.getInstance().getRandomUpServer(slaveVolume.getClusterId());
        if (slaveUpServer == null) {
            handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_RESTORE_FAILED, EngineError.NoUpServerFoundInRemoteCluster.name());
            setSucceeded(false);
            return false;
        }
        try (EngineLock lock = acquireEngineLock(session.getSlaveVolumeId(), LockingGroup.GLUSTER_SNAPSHOT)) {
            if (!restoreVolumeToSnapshot(slaveUpServer.getId(), slaveVolume, getSnapshot().getSnapshotName())) {
                return false;
            }
        }
    }
    return true;
}
#method_after
private boolean restoreSlaveVolumesToSnapshot(List<GlusterGeoRepSession> geoRepSessions, String snapshotName) {
    for (GlusterGeoRepSession session : geoRepSessions) {
        GlusterVolumeEntity slaveVolume = getDbFacade().getGlusterVolumeDao().getById(session.getSlaveVolumeId());
        if (slaveVolume == null) {
            // continue with other sessions and try to pause
            continue;
        }
        VDS slaveUpServer = ClusterUtils.getInstance().getRandomUpServer(slaveVolume.getClusterId());
        if (slaveUpServer == null) {
            handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_RESTORE_FAILED, EngineError.NoUpServerFoundInRemoteCluster.name());
            setSucceeded(false);
            return false;
        }
        try (EngineLock lock = acquireEngineLock(slaveVolume.getClusterId(), LockingGroup.GLUSTER_SNAPSHOT)) {
            if (!restoreVolumeToSnapshot(slaveUpServer.getId(), slaveVolume, getSnapshot().getSnapshotName())) {
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
public void executeCommand() {
    Boolean tranRetVal = TransactionSupport.executeInNewTransaction(new TransactionMethod<Boolean>() {

        @Override
        public Boolean runInTransaction() {
            if (georepSessions != null) {
                // Stop the geo-replication session
                if (!stopGeoReplicationSessions(georepSessions)) {
                    return false;
                }
                // Stop the slave volumes
                if (!stopSlaveVolumes(georepSessions)) {
                    return false;
                }
                // Restore the slave volumes to said the snapshot
                if (!restoreSlaveVolumesToSnapshot(georepSessions, getParameters().getSnapshotName())) {
                    return false;
                }
            }
            return true;
        }
    });
    if (!tranRetVal) {
        return;
    }
    // Stop the master volume
    if (!stopVolume(getGlusterVolume())) {
        if (!georepSessions.isEmpty()) {
            handleVdsError(AuditLogType.GLUSTER_MASTER_VOLUME_STOP_FAILED_DURING_SNAPSHOT_RESTORE, EngineError.FailedToStopMasterVolumeDuringVolumeSnapshotRestore.name());
        }
        return;
    }
    // Restore the master volume to the said snapshot
    if (!restoreVolumeToSnapshot(upServer.getId(), getGlusterVolume(), getParameters().getSnapshotName())) {
        if (!georepSessions.isEmpty()) {
            handleVdsError(AuditLogType.GLUSTER_MASTER_VOLUME_SNAPSHOT_RESTORE_FAILED, EngineError.FailedToRestoreMasterVolumeDuringVolumeSnapshotRestore.name());
        }
        return;
    }
    // Start the slave volumes
    if (engineStoppedSessions != null && !startSlaveVolumes(engineStoppedSessions)) {
        return;
    }
    // Start the master volume
    if (!startVolume(getGlusterVolume().getClusterId(), getGlusterVolumeId())) {
        return;
    }
    if (engineStoppedSessions != null) {
        // Start the geo-replication sessions
        if (!startGeoRepSessions(engineStoppedSessions)) {
            return;
        }
        // Resume the geo-replication sessions
        if (!resumeGeoRepSessions(engineStoppedSessions)) {
            return;
        }
    }
    setSucceeded(true);
}
#method_after
@Override
public void executeCommand() {
    Boolean tranRetVal = TransactionSupport.executeInNewTransaction(new TransactionMethod<Boolean>() {

        @Override
        public Boolean runInTransaction() {
            if (georepSessions != null) {
                // Stop the geo-replication session
                if (!stopGeoReplicationSessions(georepSessions)) {
                    return false;
                }
                // Stop the slave volumes
                if (!stopSlaveVolumes(georepSessions)) {
                    return false;
                }
                // Restore the slave volumes to said the snapshot
                if (!restoreSlaveVolumesToSnapshot(georepSessions, getParameters().getSnapshotName())) {
                    return false;
                }
            }
            return true;
        }
    });
    if (!tranRetVal) {
        return;
    }
    // Stop the master volume
    if (!stopVolume(getGlusterVolume())) {
        if (!georepSessions.isEmpty()) {
            handleVdsError(AuditLogType.GLUSTER_MASTER_VOLUME_STOP_FAILED_DURING_SNAPSHOT_RESTORE, EngineError.FailedToStopMasterVolumeDuringVolumeSnapshotRestore.name());
        }
        return;
    }
    // Restore the master volume to the said snapshot
    try (EngineLock lock = acquireEngineLock(getGlusterVolume().getClusterId(), LockingGroup.GLUSTER_SNAPSHOT)) {
        if (!restoreVolumeToSnapshot(upServer.getId(), getGlusterVolume(), getParameters().getSnapshotName())) {
            if (!georepSessions.isEmpty()) {
                handleVdsError(AuditLogType.GLUSTER_MASTER_VOLUME_SNAPSHOT_RESTORE_FAILED, EngineError.FailedToRestoreMasterVolumeDuringVolumeSnapshotRestore.name());
            }
            return;
        }
    }
    // Start the slave volumes
    if (engineStoppedSessions != null && !startSlaveVolumes(engineStoppedSessions)) {
        return;
    }
    // Start the master volume
    if (!startVolume(getGlusterVolume().getClusterId(), getGlusterVolumeId())) {
        return;
    }
    if (engineStoppedSessions != null) {
        // Start the geo-replication sessions
        if (!startGeoRepSessions(engineStoppedSessions)) {
            return;
        }
        // Resume the geo-replication sessions
        if (!resumeGeoRepSessions(engineStoppedSessions)) {
            return;
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
public static void initErrataGrid(HasColumns grid) {
    grid.enableColumnResizing();
    grid.addColumn(new AbstractImageResourceColumn<Erratum>() {

        @Override
        public ImageResource getValue(Erratum erratum) {
            if (erratum.getType() == ErrataType.BUGFIX) {
                return resources.bug();
            } else if (erratum.getType() == ErrataType.ENHANCEMENT) {
                return resources.enhancement();
            } else if (erratum.getType() == ErrataType.SECURITY) {
                return resources.security();
            }
            return null;
        }
    }, "", // $NON-NLS-1$ //$NON-NLS-2$
    "30px");
    grid.addColumn(new AbstractTextColumn<Erratum>() {

        @Override
        public String getValue(Erratum erratum) {
            if (erratum.getType() == ErrataType.BUGFIX) {
                return constants.bug();
            } else if (erratum.getType() == ErrataType.ENHANCEMENT) {
                return constants.enhancement();
            } else if (erratum.getType() == ErrataType.SECURITY) {
                return constants.security();
            }
            return constants.unknown();
        }
    }, constants.errataType(), // $NON-NLS-1$
    "150px");
    grid.addColumn(new AbstractTextColumn<Erratum>() {

        @Override
        public String getValue(Erratum erratum) {
            if (erratum.getSeverity() == ErrataSeverity.CRITICAL) {
                return constants.critical();
            } else if (erratum.getSeverity() == ErrataSeverity.IMPORTANT) {
                return constants.important();
            } else if (erratum.getSeverity() == ErrataSeverity.MODERATE) {
                return constants.moderate();
            }
            return constants.unknown();
        }
    }, constants.errataSeverity(), // $NON-NLS-1$
    "150px");
    grid.addColumn(new AbstractFullDateTimeColumn<Erratum>(false) {

        @Override
        protected Date getRawValue(Erratum erratum) {
            return erratum.getIssued();
        }
    }, constants.errataDateIssued(), // $NON-NLS-1$
    "100px");
    grid.addColumn(new AbstractTextColumn<Erratum>() {

        @Override
        public String getValue(Erratum erratum) {
            return erratum.getId();
        }
    }, constants.errataId(), // $NON-NLS-1$
    "115px");
    grid.addColumn(new AbstractTextColumn<Erratum>() {

        @Override
        public String getValue(Erratum erratum) {
            return erratum.getTitle();
        }
    }, constants.errataTitle(), // $NON-NLS-1$
    "305px");
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
public static void initErrataGrid(HasColumns grid) {
    grid.enableColumnResizing();
    grid.addColumn(new AbstractImageResourceColumn<Erratum>() {

        @Override
        public ImageResource getValue(Erratum erratum) {
            if (erratum.getType() == ErrataType.BUGFIX) {
                return resources.bug();
            } else if (erratum.getType() == ErrataType.ENHANCEMENT) {
                return resources.enhancement();
            } else if (erratum.getType() == ErrataType.SECURITY) {
                return resources.security();
            }
            return null;
        }
    }, "", // $NON-NLS-1$ //$NON-NLS-2$
    "30px");
    grid.addColumn(new AbstractTextColumn<Erratum>() {

        @Override
        public String getValue(Erratum erratum) {
            if (erratum.getType() == ErrataType.BUGFIX) {
                return constants.bug();
            } else if (erratum.getType() == ErrataType.ENHANCEMENT) {
                return constants.enhancement();
            } else if (erratum.getType() == ErrataType.SECURITY) {
                return constants.security();
            }
            return constants.unknown();
        }
    }, constants.errataType(), // $NON-NLS-1$
    "150px");
    grid.addColumn(new AbstractTextColumn<Erratum>() {

        @Override
        public String getValue(Erratum erratum) {
            if (erratum.getSeverity() == ErrataSeverity.CRITICAL) {
                return constants.critical();
            } else if (erratum.getSeverity() == ErrataSeverity.IMPORTANT) {
                return constants.important();
            } else if (erratum.getSeverity() == ErrataSeverity.MODERATE) {
                return constants.moderate();
            }
            return constants.unknown();
        }
    }, constants.errataSeverity(), // $NON-NLS-1$
    "150px");
    grid.addColumn(new AbstractFullDateTimeColumn<Erratum>(false) {

        @Override
        protected Date getRawValue(Erratum erratum) {
            return erratum.getIssued();
        }
    }, constants.errataDateIssued(), // $NON-NLS-1$
    "100px");
    grid.addColumn(new AbstractTextColumn<Erratum>() {

        @Override
        public String getValue(Erratum erratum) {
            return erratum.getId();
        }
    }, constants.errataId(), // $NON-NLS-1$
    "115px");
    grid.addColumn(new AbstractTextColumn<Erratum>() {

        @Override
        public String getValue(Erratum erratum) {
            return erratum.getTitle();
        }
    }, constants.errataTitle(), // $NON-NLS-1$
    "290px");
}
#end_block

#method_before
public void runQuery(Guid guid) {
    // $NON-NLS-1$
    startProgress("getCount");
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            stopProgress();
            AbstractErrataCountModel errataCountModel = (AbstractErrataCountModel) model;
            VdcQueryReturnValue returnValueObject = (VdcQueryReturnValue) returnValue;
            ErrataCounts resultEntity = returnValueObject.getReturnValue();
            if (resultEntity != null && returnValueObject.getSucceeded()) {
                errataCountModel.setMessage(null);
                errataCountModel.setErrataCounts(resultEntity);
            } else {
                // Set message to null to make sure the actual setMessage creates an event.
                errataCountModel.setMessage(null);
                errataCountModel.setMessage(// $NON-NLS-1$
                constants.katelloProblemRetrievingErrata() + " " + returnValueObject.getExceptionMessage());
            }
        }
    };
    Frontend.getInstance().runQuery(getQueryType(), new IdQueryParameters(guid), _asyncQuery);
}
#method_after
public void runQuery(Guid guid) {
    // $NON-NLS-1$
    startProgress("getCount");
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            stopProgress();
            AbstractErrataCountModel errataCountModel = (AbstractErrataCountModel) model;
            VdcQueryReturnValue returnValueObject = (VdcQueryReturnValue) returnValue;
            ErrataCounts resultEntity = returnValueObject.getReturnValue();
            // Set message to null to make sure the actual setMessage creates an event.
            errataCountModel.setMessage(null);
            if (resultEntity != null && returnValueObject.getSucceeded()) {
                errataCountModel.setErrataCounts(resultEntity);
            } else {
                errataCountModel.setMessage(// $NON-NLS-1$
                constants.katelloProblemRetrievingErrata() + " " + returnValueObject.getExceptionMessage());
            }
        }
    };
    Frontend.getInstance().runQuery(getQueryType(), new IdQueryParameters(guid), _asyncQuery);
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    AbstractErrataListModel model = modelProvider.getModel();
    // 
    // Handle the query returning a new list of errata -> simple view update.
    // 
    changeListener = new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            getView().showErrataList();
        }
    };
    model.addItemsChangeListener(changeListener);
    // Handle the errata selection changing -> simple view update.
    // 
    getView().getErrataTable().addSelectionChangeHandler(new SelectionChangeEvent.Handler() {

        @Override
        public void onSelectionChange(SelectionChangeEvent event) {
            Erratum erratum = getView().getSelectedErratum();
            if (erratum == null) {
                getView().setErrataDetailPanelVisibilty(false);
            } else {
                getView().updateErrataDetailFormPanel(erratum);
                getView().setErrataDetailPanelVisibilty(true);
            }
        }
    });
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    // 
    // Handle the query returning a new list of errata -> simple view update.
    // 
    changeListener = new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            getView().showErrataList();
        }
    };
    modelProvider.getModel().addItemsChangeListener(changeListener);
    // Handle the errata selection changing -> simple view update.
    // 
    getView().getErrataTable().addSelectionChangeHandler(new SelectionChangeEvent.Handler() {

        @Override
        public void onSelectionChange(SelectionChangeEvent event) {
            Erratum erratum = getView().getSelectedErratum();
            if (erratum == null) {
                getView().setErrataDetailPanelVisibilty(false);
            } else {
                getView().updateErrataDetailFormPanel(erratum);
                getView().setErrataDetailPanelVisibilty(true);
            }
        }
    });
}
#end_block

#method_before
@Override
public Response add(VM vm) {
    validateParameters(vm, "cluster.id|name");
    validateEnums(VM.class, vm);
    validateIconParameters(vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            validateSnapshots(vm);
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            VDSGroup cluster = getCluster(vm);
            VmTemplate template = lookupTemplate(vm.getTemplate(), cluster.getStoragePoolId());
            VmStatic builtFromTemplate = VmMapper.map(template, null, cluster.getCompatibilityVersion());
            // since the template cpu_profile doesn't match cluster.
            if (!vm.isSetCpuProfile() && vm.isSetCluster() && !ObjectUtils.equals(template.getVdsGroupId(), vm.getCluster().getId())) {
                builtFromTemplate.setCpuProfileId(null);
            }
            VmStatic builtFromInstanceType = null;
            InstanceType instanceTypeEntity = null;
            if (vm.isSetInstanceType() && (vm.getInstanceType().isSetId() || vm.getInstanceType().isSetName())) {
                instanceTypeEntity = lookupInstance(vm.getInstanceType());
                builtFromInstanceType = VmMapper.map(instanceTypeEntity, builtFromTemplate, cluster.getCompatibilityVersion());
                builtFromInstanceType.setInstanceTypeId(instanceTypeEntity.getId());
            }
            VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, builtFromInstanceType != null ? builtFromInstanceType : builtFromTemplate);
            if (namedCluster(vm)) {
                staticVm.setVdsGroupId(cluster.getId());
            }
            if (Guid.Empty.equals(template.getId()) && !vm.isSetOs()) {
                staticVm.setOsId(OsRepository.AUTO_SELECT_OS);
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb(), cluster.getCompatibilityVersion()));
            if (!isFiltered() && vm.isSetPlacementPolicy()) {
                Set<Guid> hostGuidsSet = validateAndUpdateHostsInPlacementPolicy(vm.getPlacementPolicy());
                staticVm.setDedicatedVmForVdsList(new LinkedList<Guid>(hostGuidsSet));
            } else {
                vm.setPlacementPolicy(null);
            }
            // migration support (disabling it in architectures that do not support this feature)
            if (!vm.isSetPlacementPolicy() && template.getId().equals(Guid.Empty)) {
                staticVm.setMigrationSupport(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
                response = cloneVmFromTemplate(staticVm, vm, template, instanceTypeEntity, cluster);
            } else if (Guid.Empty.equals(template.getId())) {
                response = addVmFromScratch(staticVm, vm, instanceTypeEntity, cluster);
            } else {
                response = addVm(staticVm, vm, storageDomainId, template, instanceTypeEntity, cluster);
            }
        }
    }
    VM result = (VM) response.getEntity();
    if (result != null) {
        DisplayHelper.adjustDisplayData(this, result);
        removeRestrictedInfo(result);
    }
    return response;
}
#method_after
@Override
public Response add(VM vm) {
    validateParameters(vm, "cluster.id|name");
    validateEnums(VM.class, vm);
    validateIconParameters(vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            validateSnapshotExistence(vm);
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            VDSGroup cluster = getCluster(vm);
            VmTemplate template = lookupTemplate(vm.getTemplate(), cluster.getStoragePoolId());
            VmStatic builtFromTemplate = VmMapper.map(template, null, cluster.getCompatibilityVersion());
            // since the template cpu_profile doesn't match cluster.
            if (!vm.isSetCpuProfile() && vm.isSetCluster() && !ObjectUtils.equals(template.getVdsGroupId(), vm.getCluster().getId())) {
                builtFromTemplate.setCpuProfileId(null);
            }
            VmStatic builtFromInstanceType = null;
            InstanceType instanceTypeEntity = null;
            if (vm.isSetInstanceType() && (vm.getInstanceType().isSetId() || vm.getInstanceType().isSetName())) {
                instanceTypeEntity = lookupInstance(vm.getInstanceType());
                builtFromInstanceType = VmMapper.map(instanceTypeEntity, builtFromTemplate, cluster.getCompatibilityVersion());
                builtFromInstanceType.setInstanceTypeId(instanceTypeEntity.getId());
            }
            VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, builtFromInstanceType != null ? builtFromInstanceType : builtFromTemplate);
            if (namedCluster(vm)) {
                staticVm.setVdsGroupId(cluster.getId());
            }
            if (Guid.Empty.equals(template.getId()) && !vm.isSetOs()) {
                staticVm.setOsId(OsRepository.AUTO_SELECT_OS);
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb(), cluster.getCompatibilityVersion()));
            if (!isFiltered() && vm.isSetPlacementPolicy()) {
                Set<Guid> hostGuidsSet = validateAndUpdateHostsInPlacementPolicy(vm.getPlacementPolicy());
                staticVm.setDedicatedVmForVdsList(new LinkedList<Guid>(hostGuidsSet));
            } else {
                vm.setPlacementPolicy(null);
            }
            // migration support (disabling it in architectures that do not support this feature)
            if (!vm.isSetPlacementPolicy() && template.getId().equals(Guid.Empty)) {
                staticVm.setMigrationSupport(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
                response = cloneVmFromTemplate(staticVm, vm, template, instanceTypeEntity, cluster);
            } else if (Guid.Empty.equals(template.getId())) {
                response = addVmFromScratch(staticVm, vm, instanceTypeEntity, cluster);
            } else {
                response = addVm(staticVm, vm, storageDomainId, template, instanceTypeEntity, cluster);
            }
        }
    }
    VM result = (VM) response.getEntity();
    if (result != null) {
        DisplayHelper.adjustDisplayData(this, result);
        removeRestrictedInfo(result);
    }
    return response;
}
#end_block

#method_before
private boolean canRemoveDiskBasedOnImageStorageCheck() {
    boolean retValue = true;
    DiskImage diskImage = getDiskImage();
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Collections.singletonList(diskImage));
    if (diskImage.isOvfStore() && !validate(diskImagesValidator.disksInStatus(ImageStatus.ILLEGAL, EngineMessage.ACTION_TYPE_FAILED_OVF_DISK_NOT_IN_APPLICABLE_STATUS))) {
        return false;
    }
    boolean noStorageDomainInParams = (getParameters().getStorageDomainId() == null) || (Guid.Empty.equals(getParameters().getStorageDomainId()));
    if (diskImage.getVmEntityType() != null && diskImage.getVmEntityType().isTemplateType()) {
        if (noStorageDomainInParams) {
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CANT_DELETE_TEMPLATE_DISK_WITHOUT_SPECIFYING_DOMAIN);
            return false;
        }
        // Temporary fix until re factoring vm_images_view and image_storage_domain_view
        diskImage.setStorageIds(getDiskImageDao().get(diskImage.getImageId()).getStorageIds());
    } else if (noStorageDomainInParams) {
        getParameters().setStorageDomainId(diskImage.getStorageIds().get(0));
        setStorageDomainId(diskImage.getStorageIds().get(0));
    }
    if (!diskImage.getStorageIds().contains(getParameters().getStorageDomainId())) {
        retValue = false;
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_IS_WRONG);
    }
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    retValue = retValue && validate(validator.isDomainExistAndActive()) && validate(validator.domainIsValidDestination());
    if (retValue && diskImage.getImageStatus() == ImageStatus.LOCKED) {
        retValue = false;
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED);
    }
    if (retValue && getDisk().getVmEntityType() != null) {
        if (getDisk().getVmEntityType().isVmType()) {
            retValue = canRemoveVmImageDisk();
        } else if (getDisk().getVmEntityType().isTemplateType()) {
            retValue = canRemoveTemplateDisk();
        }
    }
    return retValue;
}
#method_after
private boolean canRemoveDiskBasedOnImageStorageCheck() {
    boolean retValue = true;
    DiskImage diskImage = getDiskImage();
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Collections.singletonList(diskImage));
    if (diskImage.isOvfStore() && !validate(diskImagesValidator.disksInStatus(ImageStatus.ILLEGAL, EngineMessage.ACTION_TYPE_FAILED_OVF_DISK_NOT_IN_APPLICABLE_STATUS))) {
        return false;
    }
    boolean isVmTemplateType = diskImage.getVmEntityType() != null && diskImage.getVmEntityType().isTemplateType();
    if (Guid.isNullOrEmpty(getParameters().getStorageDomainId())) {
        if (isVmTemplateType) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CANT_DELETE_TEMPLATE_DISK_WITHOUT_SPECIFYING_DOMAIN);
        }
        getParameters().setStorageDomainId(diskImage.getStorageIds().get(0));
        setStorageDomainId(diskImage.getStorageIds().get(0));
    }
    if (isVmTemplateType) {
        diskImage.setStorageIds(getDiskImageDao().get(diskImage.getImageId()).getStorageIds());
    }
    if (!diskImage.getStorageIds().contains(getParameters().getStorageDomainId())) {
        retValue = false;
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_IS_WRONG);
    }
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    retValue = retValue && validate(validator.isDomainExistAndActive()) && validate(validator.domainIsValidDestination());
    if (retValue && diskImage.getImageStatus() == ImageStatus.LOCKED) {
        retValue = false;
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED);
    }
    if (retValue && getDisk().getVmEntityType() != null) {
        if (getDisk().getVmEntityType().isVmType()) {
            retValue = canRemoveVmImageDisk();
        } else if (getDisk().getVmEntityType().isTemplateType()) {
            retValue = canRemoveTemplateDisk();
        }
    }
    return retValue;
}
#end_block

#method_before
private boolean checkDerivedDisksFromDiskNotExist(DiskImage diskImage) {
    return validate(createDiskImagesValidator(diskImage).diskImagesHaveNoDerivedDisks(getParameters().getStorageDomainId()));
}
#method_after
protected boolean checkDerivedDisksFromDiskNotExist(DiskImage diskImage) {
    return validate(createDiskImagesValidator(diskImage).diskImagesHaveNoDerivedDisks(getParameters().getStorageDomainId()));
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getParameters().getTargetVdsGroupId() != null) {
        // additional permissions needed since changing the cluster
        permissionList.addAll(VmHandler.getPermissionsNeededToChangeCluster(getParameters().getVmId(), getParameters().getTargetVdsGroupId()));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    // this runs before canDoAction so the getVm() can be null - instead of failing on NPE here we pass the parent permissions and let the canDoAction to return proper error
    if (getVm() == null) {
        return permissionList;
    }
    if (getParameters().getTargetVdsGroupId() != null && !getParameters().getTargetVdsGroupId().equals(getVm().getVdsGroupId())) {
        // additional permissions needed since changing the cluster
        permissionList.addAll(VmHandler.getPermissionsNeededToChangeCluster(getParameters().getVmId(), getParameters().getTargetVdsGroupId()));
    }
    return permissionList;
}
#end_block

#method_before
private boolean validateStorage() {
    List<DiskImage> vmDisksList = getDisksListForChecks();
    if (vmDisksList.size() > 0) {
        // TODO: Add a validator factory for Cinder and image disks (after disks will be refacored)
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(vmDisksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()))) {
            return false;
        }
    }
    vmDisksList = ImagesHandler.getDisksDummiesForStorageAllocations(vmDisksList);
    List<DiskImage> allDisks = new ArrayList<>(vmDisksList);
    List<DiskImage> memoryDisksList = null;
    if (getParameters().isSaveMemory()) {
        memoryDisksList = MemoryUtils.createDiskDummies(getVm().getTotalMemorySizeInBytes(), MemoryUtils.META_DATA_SIZE_IN_BYTES);
        if (Guid.Empty.equals(getStorageDomainIdForVmMemory(memoryDisksList))) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        allDisks.addAll(memoryDisksList);
    }
    MultipleStorageDomainsValidator sdValidator = createMultipleStorageDomainsValidator(allDisks);
    if (!validate(sdValidator.allDomainsExistAndActive()) || !validate(sdValidator.allDomainsWithinThresholds()) || !validateCinder()) {
        return false;
    }
    if (memoryDisksList == null) {
        // no memory volumes
        return validate(sdValidator.allDomainsHaveSpaceForNewDisks(vmDisksList));
    }
    return validate(sdValidator.allDomainsHaveSpaceForAllDisks(vmDisksList, memoryDisksList));
}
#method_after
private boolean validateStorage() {
    List<DiskImage> vmDisksList = getSnappableVmDisks();
    vmDisksList = ImagesHandler.getDisksDummiesForStorageAllocations(vmDisksList);
    List<DiskImage> allDisks = new ArrayList<>(vmDisksList);
    List<DiskImage> memoryDisksList = null;
    if (getParameters().isSaveMemory()) {
        memoryDisksList = MemoryUtils.createDiskDummies(getVm().getTotalMemorySizeInBytes(), MemoryUtils.META_DATA_SIZE_IN_BYTES);
        if (Guid.Empty.equals(getStorageDomainIdForVmMemory(memoryDisksList))) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        allDisks.addAll(memoryDisksList);
    }
    MultipleStorageDomainsValidator sdValidator = createMultipleStorageDomainsValidator(allDisks);
    if (!validate(sdValidator.allDomainsExistAndActive()) || !validate(sdValidator.allDomainsWithinThresholds()) || !validateCinder()) {
        return false;
    }
    if (memoryDisksList == null) {
        // no memory volumes
        return validate(sdValidator.allDomainsHaveSpaceForNewDisks(vmDisksList));
    }
    return validate(sdValidator.allDomainsHaveSpaceForAllDisks(vmDisksList, memoryDisksList));
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    createdSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    getParameters().setSnapshotType(determineSnapshotType());
    getSnapshotDao().updateId(createdSnapshotId, newActiveSnapshotId);
    setActionReturnValue(createdSnapshotId);
    MemoryImageBuilder memoryImageBuilder = getMemoryImageBuilder();
    freezeVm();
    createSnapshotsForDisks();
    addSnapshotToDB(createdSnapshotId, memoryImageBuilder);
    fastForwardDisksToActiveSnapshot();
    memoryImageBuilder.build();
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        getParameters().setTaskGroupSuccess(true);
        incrementVmGeneration();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    getParameters().setSnapshotType(determineSnapshotType());
    Guid createdSnapshotId = updateActiveSnapshotId();
    setActionReturnValue(createdSnapshotId);
    MemoryImageBuilder memoryImageBuilder = getMemoryImageBuilder();
    freezeVm();
    createSnapshotsForDisks();
    addSnapshotToDB(createdSnapshotId, memoryImageBuilder);
    fastForwardDisksToActiveSnapshot();
    memoryImageBuilder.build();
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        getParameters().setTaskGroupSuccess(true);
        incrementVmGeneration();
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isSpecifiedDisksExist(getParameters().getDisks())) {
        return false;
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()))) {
        return false;
    }
    return validateStorage();
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isSpecifiedDisksExist(getParameters().getDisks())) {
        return false;
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()))) {
        return false;
    }
    List<DiskImage> disksList = getDisksListForChecks();
    if (disksList.size() > 0) {
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(disksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()))) {
            return false;
        }
    }
    return validateStorage();
}
#end_block

#method_before
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity().trim());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setProtocol(VdsProtocol.fromValue(model.getProtocol().getEntity() ? VdsProtocol.STOMP.toString() : VdsProtocol.XML.toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(model.getPmProxyPreferences()));
    // Save other PM parameters.
    host.setPmEnabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = model.getCluster().getSelectedItem().supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider<?> networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setNetworkProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (Boolean.TRUE.equals(model.getIsDiscoveredHosts().getEntity())) {
            Provider<?> provider = model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            ExternalComputeResource computeResource = (ExternalComputeResource) model.getExternalComputeResource().getSelectedItem();
            ExternalDiscoveredHost discoveredHost = (ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem();
            parameters.initVdsActionParametersForProvision(provider.getId(), hostGroup, computeResource, discoveredHost.getMac(), discoveredHost.getName(), discoveredHost.getIp());
        }
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else {
        // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallHost(false);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getExternalHostProviderEnabled().getEntity() && model.getProviders().getSelectedItem() != null) {
            host.setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity().trim());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setProtocol(VdsProtocol.fromValue(model.getProtocol().getEntity() ? VdsProtocol.STOMP.toString() : VdsProtocol.XML.toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(model.getPmProxyPreferences()));
    // Save other PM parameters.
    host.setPmEnabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    cancelConfirm();
    model.startProgress(null);
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider<?> networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setNetworkProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (Boolean.TRUE.equals(model.getIsDiscoveredHosts().getEntity())) {
            Provider<?> provider = model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            ExternalComputeResource computeResource = (ExternalComputeResource) model.getExternalComputeResource().getSelectedItem();
            ExternalDiscoveredHost discoveredHost = (ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem();
            parameters.initVdsActionParametersForProvision(provider.getId(), hostGroup, computeResource, discoveredHost.getMac(), discoveredHost.getName(), discoveredHost.getIp());
        }
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else {
        // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallHost(false);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getExternalHostProviderEnabled().getEntity() && model.getProviders().getSelectedItem() != null) {
            host.setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
public void onInstall() {
    final VDS host = getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    if (!model.validate(host.isOvirtNode())) {
        model.setValidationFailed(new EntityModel<Boolean>(true));
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword(model.getUserPassword().getEntity());
    param.setReinstallOrUpgrade(true);
    param.setInstallHost(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    param.setActivateHost(model.getActivateHostAfterInstall().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    param.setFenceAgents(host.getFenceAgents());
    Provider<?> networkProvider = (Provider<?>) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.setNetworkProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VDSGroup cluster = (VDSGroup) returnValue;
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            Frontend.getInstance().runAction(VdcActionType.InstallVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getVdsGroupId());
}
#method_after
public void onInstall() {
    final VDS host = getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    if (!model.validate(host.isOvirtNode())) {
        model.setValidationFailed(new EntityModel<Boolean>(true));
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword(model.getUserPassword().getEntity());
    param.setReinstallOrUpgrade(true);
    param.setInstallHost(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    param.setActivateHost(model.getActivateHostAfterInstall().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    param.setFenceAgents(host.getFenceAgents());
    Provider<?> networkProvider = (Provider<?>) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.setNetworkProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            Frontend.getInstance().runAction(VdcActionType.InstallVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getVdsGroupId());
}
#end_block

#method_before
private String getPoolVmTooltip(VmType vmType) {
    switch(vmType) {
        case Server:
            return constants.pooledServer();
        case Desktop:
            return constants.pooledDesktop();
        default:
            // $NON-NLS-1$
            return "";
    }
}
#method_after
private String getPoolVmTooltip(VmType vmType) {
    switch(vmType) {
        case Server:
            return constants.pooledServer();
        case Desktop:
            return constants.pooledDesktop();
        default:
            return constants.pooledDesktop();
    }
}
#end_block

#method_before
private void scheduleJobs(long regularInterval, long longInterval) {
    /* start the interval refreshing */
    jobId = Injector.get(SchedulerUtilQuartzImpl.class).scheduleAFixedDelayJob(this, "refresh", new Class[] {}, new Object[] {}, regularInterval, longInterval, TimeUnit.MINUTES);
}
#method_after
private void scheduleJobs(long regularInterval, long longInterval) {
    /* start the interval refreshing */
    Injector.get(SchedulerUtilQuartzImpl.class).scheduleAFixedDelayJob(this, "refresh", new Class[] {}, new Object[] {}, regularInterval, longInterval, TimeUnit.MINUTES);
}
#end_block

#method_before
private void refreshGlusterStorageDevices() {
    if (getGlusterUtil().isGlusterBrickProvisioningSupported(getVdsGroup().getCompatibilityVersion(), getVdsGroup().getId())) {
        try {
            runInternalAction(VdcActionType.SyncStorageDevices, new VdsActionParameters(getVds().getId()));
        } catch (EngineException e) {
            log.error("Could not refresh storage devices from gluster host '{}'", getVds().getName());
        }
    }
}
#method_after
private void refreshGlusterStorageDevices() {
    if (getGlusterUtil().isGlusterBrickProvisioningSupported(getVdsGroup().getCompatibilityVersion(), getVdsGroup().getId())) {
        try {
            runInternalAction(VdcActionType.SyncStorageDevices, new SyncGlusterStorageDevicesParameter(getVds().getId(), true));
        } catch (EngineException e) {
            log.error("Could not refresh storage devices from gluster host '{}'", getVds().getName());
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDSGroup cluster = getVdsGroup();
    if (!cluster.supportsGlusterService() || (!getGlusterUtil().isGlusterBrickProvisioningSupported(cluster.getCompatibilityVersion(), getVdsGroup().getId()))) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_PROVISIONING_NOT_SUPPORTED_BY_CLUSTER);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VDSGroup cluster = getVdsGroup();
    if (!cluster.supportsGlusterService() || (!getGlusterUtil().isGlusterBrickProvisioningSupported(cluster.getCompatibilityVersion(), getVdsGroup().getId()))) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_PROVISIONING_NOT_SUPPORTED_BY_CLUSTER);
    }
    // and host status will not be up during host activation. So BLL will be called with force in this case.
    if (!getParameters().isForceAction()) {
        HostValidator validator = new HostValidator(getVds());
        return validate(validator.isUp());
    }
    return true;
}
#end_block

#method_before
public void engineInitialize() {
    try {
        createKerberosLdapAAAConfigurations();
    } catch (Exception ex) {
        log.error("Could not load built in configuration. Exception message is: {}", ex.getMessage());
        log.debug("", ex);
    }
    for (File directory : EngineLocalConfig.getInstance().getExtensionsDirectories()) {
        if (!directory.exists()) {
            log.warn("The directory '{}' cotaning configuration files does not exist.", directory.getAbsolutePath());
        } else {
            // The order of the files inside the directory is relevant, as the objects are created in
            // the same order
            // that
            // the files are processed, so it is better to sort them so that objects will always be
            // created in the
            // same
            // order regardless of how the filesystem decides to store the entries of the directory:
            File[] files = directory.listFiles();
            if (files != null) {
                sort(files);
                for (File file : files) {
                    if (file.getName().endsWith(".properties")) {
                        try {
                            load(file);
                        } catch (Exception ex) {
                            log.error("Could not load extension based on configuration file '{}'. Please check the configuration file is valid. Exception message is: {}", file.getAbsolutePath(), ex.getMessage());
                            log.debug("", ex);
                        }
                    }
                }
            }
        }
    }
    for (ExtensionProxy extension : getLoadedExtensions()) {
        if (EngineLocalConfig.getInstance().getBoolean(ENGINE_EXTENSION_ENABLED + normalizeName(extension.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME)), Boolean.parseBoolean(extension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(Base.ConfigKeys.ENABLED, "true")))) {
            try {
                initialize(extension.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME));
            } catch (Exception ex) {
                log.error("Could not initialize extension '{}'. Exception message is: {}", extension.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME), ex.getMessage());
                log.debug("", ex);
            }
        }
    }
    dump();
}
#method_after
public void engineInitialize() {
    for (File directory : EngineLocalConfig.getInstance().getExtensionsDirectories()) {
        if (!directory.exists()) {
            log.warn("The directory '{}' cotaning configuration files does not exist.", directory.getAbsolutePath());
        } else {
            // The order of the files inside the directory is relevant, as the objects are created in
            // the same order
            // that
            // the files are processed, so it is better to sort them so that objects will always be
            // created in the
            // same
            // order regardless of how the filesystem decides to store the entries of the directory:
            File[] files = directory.listFiles();
            if (files != null) {
                sort(files);
                for (File file : files) {
                    if (file.getName().endsWith(".properties")) {
                        try {
                            load(file);
                        } catch (Exception ex) {
                            log.error("Could not load extension based on configuration file '{}'. Please check the configuration file is valid. Exception message is: {}", file.getAbsolutePath(), ex.getMessage());
                            log.debug("", ex);
                        }
                    }
                }
            }
        }
    }
    for (ExtensionProxy extension : getLoadedExtensions()) {
        if (EngineLocalConfig.getInstance().getBoolean(ENGINE_EXTENSION_ENABLED + normalizeName(extension.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME)), Boolean.parseBoolean(extension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(Base.ConfigKeys.ENABLED, "true")))) {
            try {
                initialize(extension.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME));
            } catch (Exception ex) {
                log.error("Could not initialize extension '{}'. Exception message is: {}", extension.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME), ex.getMessage());
                log.debug("", ex);
            }
        }
    }
    dump();
}
#end_block

#method_before
protected void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    if (FeatureSupported.hotPlugMemory(vm.getVdsGroupCompatibilityVersion(), vm.getClusterArch())) {
        if (osRepository.get64bitOss().contains(vm.getOs())) {
            createInfo.put(VdsProperties.maxMemSize, Config.getValue(ConfigValues.VM64BitMaxMemorySizeInMB, vm.getVdsGroupCompatibilityVersion().getValue()));
        } else {
            createInfo.put(VdsProperties.maxMemSize, Config.getValue(ConfigValues.VM32BitMaxMemorySizeInMB));
        }
        createInfo.put(VdsProperties.maxMemSlots, Config.getValue(ConfigValues.MaxMemorySlots));
    }
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (vm.getNumOfIoThreads() != 0) {
        createInfo.put(VdsProperties.numOfIoThreads, vm.getNumOfIoThreads());
    }
    if (Config.<Boolean>getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, (Integer.toString(vm.getCpuPerSocket())));
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getVdsGroupCompatibilityVersion(), vm.getClusterArch())) {
            createInfo.put(VdsProperties.max_number_of_cpus, calcMaxVCpu().toString());
        }
    }
    final String compatibilityVersion = vm.getVdsGroupCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    if (vm.getEmulatedMachine() != null) {
        createInfo.put(VdsProperties.emulatedMachine, vm.getEmulatedMachine());
    }
    // enabled.
    if (Config.<Boolean>getValue(ConfigValues.SSLEnabled)) {
        createInfo.put(VdsProperties.spiceSslCipherSuite, Config.<String>getValue(ConfigValues.CipherSuite));
        createInfo.put(VdsProperties.SpiceSecureChannels, Config.<String>getValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.put(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getCpuName() != null) {
        // uses dynamic vm data which was already updated by runVmCommand
        createInfo.put(VdsProperties.cpuType, vm.getCpuName());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
    if (keyboardLayout == null) {
        keyboardLayout = vm.getDefaultVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = Config.<String>getValue(ConfigValues.VncKeyboardLayout);
        }
    }
    createInfo.put(VdsProperties.KeyboardLayout, keyboardLayout);
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getGraphicsInfos().size() == 1 && vm.getGraphicsInfos().containsKey(GraphicsType.VNC)) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    if (osRepository.isHypervEnabled(vm.getVmOsId(), vm.getVdsGroupCompatibilityVersion())) {
        createInfo.put(VdsProperties.hypervEnable, "true");
    }
}
#method_after
protected void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    if (FeatureSupported.hotPlugMemory(vm.getVdsGroupCompatibilityVersion(), vm.getClusterArch())) {
        if (osRepository.get64bitOss().contains(vm.getOs())) {
            createInfo.put(VdsProperties.maxMemSize, Config.getValue(ConfigValues.VM64BitMaxMemorySizeInMB, vm.getVdsGroupCompatibilityVersion().getValue()));
        } else {
            createInfo.put(VdsProperties.maxMemSize, Config.getValue(ConfigValues.VM32BitMaxMemorySizeInMB));
        }
        createInfo.put(VdsProperties.maxMemSlots, Config.getValue(ConfigValues.MaxMemorySlots));
    }
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (vm.getNumOfIoThreads() != 0) {
        createInfo.put(VdsProperties.numOfIoThreads, vm.getNumOfIoThreads());
    }
    if (Config.<Boolean>getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, (Integer.toString(vm.getCpuPerSocket())));
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getVdsGroupCompatibilityVersion(), vm.getClusterArch())) {
            createInfo.put(VdsProperties.max_number_of_cpus, calcMaxVCpu().toString());
        }
    }
    final String compatibilityVersion = vm.getVdsGroupCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    if (vm.getEmulatedMachine() != null) {
        createInfo.put(VdsProperties.emulatedMachine, vm.getEmulatedMachine());
    }
    // enabled.
    if (Config.<Boolean>getValue(ConfigValues.SSLEnabled)) {
        createInfo.put(VdsProperties.spiceSslCipherSuite, Config.<String>getValue(ConfigValues.CipherSuite));
        createInfo.put(VdsProperties.SpiceSecureChannels, Config.<String>getValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.put(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getCpuName() != null) {
        // uses dynamic vm data which was already updated by runVmCommand
        createInfo.put(VdsProperties.cpuType, vm.getCpuName());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
    if (keyboardLayout == null) {
        keyboardLayout = vm.getDefaultVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = Config.<String>getValue(ConfigValues.VncKeyboardLayout);
        }
    }
    createInfo.put(VdsProperties.KeyboardLayout, keyboardLayout);
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getGraphicsInfos().size() == 1 && vm.getGraphicsInfos().containsKey(GraphicsType.VNC)) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    // ensure compatibility with VDSM <= 4.16
    addVmSpiceOptions(vm.getGraphicsInfos(), createInfo);
    if (osRepository.isHypervEnabled(vm.getVmOsId(), vm.getVdsGroupCompatibilityVersion())) {
        createInfo.put(VdsProperties.hypervEnable, "true");
    }
}
#end_block

#method_before
private Map<String, Object> buildVmGraphicsSpecParamsFromVm(Map<GraphicsType, GraphicsInfo> infos) {
    Map<String, Object> specParamsFromVm = null;
    if (infos.containsKey(GraphicsType.SPICE)) {
        // harmless if added to VNC devices. Just noise.
        specParamsFromVm = new HashMap();
        specParamsFromVm.put(VdsProperties.spiceFileTransferEnable, Boolean.toString(vm.isSpiceFileTransferEnabled()));
        specParamsFromVm.put(VdsProperties.spiceCopyPasteEnable, Boolean.toString(vm.isSpiceCopyPasteEnabled()));
    }
    return specParamsFromVm;
}
#method_after
private Map<String, Object> buildVmGraphicsSpecParamsFromVm(Map<GraphicsType, GraphicsInfo> infos) {
    Map<String, Object> specParamsFromVm = null;
    if (infos != null && infos.containsKey(GraphicsType.SPICE)) {
        // harmless if added to VNC devices. Just noise.
        specParamsFromVm = new HashMap();
        addVmSpiceOptions(infos, specParamsFromVm);
    }
    return specParamsFromVm;
}
#end_block

#method_before
private void buildVmGraphicsDevicesOverriden(Map<GraphicsType, GraphicsInfo> graphicsInfos, boolean usesGraphicsAsDevice, Map<String, Object> extraSpecParams) {
    if (usesGraphicsAsDevice) {
        for (Entry<GraphicsType, GraphicsInfo> graphicsInfo : graphicsInfos.entrySet()) {
            Map struct = new HashMap();
            struct.put(VdsProperties.Type, VmDeviceGeneralType.GRAPHICS.getValue());
            struct.put(VdsProperties.Device, graphicsInfo.getKey().name().toLowerCase());
            struct.put(VdsProperties.DeviceId, String.valueOf(Guid.newGuid()));
            struct.put(VdsProperties.SpecParams, extraSpecParams);
            devices.add(struct);
        }
    }
    if (!graphicsInfos.isEmpty()) {
        String legacyGraphicsType = (graphicsInfos.size() == 2) ? VdsProperties.QXL : graphicsTypeToLegacyDisplayType(graphicsInfos.keySet().iterator().next());
        createInfo.put(VdsProperties.display, legacyGraphicsType);
    }
}
#method_after
private void buildVmGraphicsDevicesOverriden(Map<GraphicsType, GraphicsInfo> graphicsInfos, boolean usesGraphicsAsDevice, Map<String, Object> extraSpecParams) {
    if (usesGraphicsAsDevice) {
        for (Entry<GraphicsType, GraphicsInfo> graphicsInfo : graphicsInfos.entrySet()) {
            Map struct = new HashMap();
            struct.put(VdsProperties.Type, VmDeviceGeneralType.GRAPHICS.getValue());
            struct.put(VdsProperties.Device, graphicsInfo.getKey().name().toLowerCase());
            struct.put(VdsProperties.DeviceId, String.valueOf(Guid.newGuid()));
            if (extraSpecParams != null) {
                struct.put(VdsProperties.SpecParams, extraSpecParams);
            }
            devices.add(struct);
        }
    }
    if (!graphicsInfos.isEmpty()) {
        String legacyGraphicsType = (graphicsInfos.size() == 2) ? VdsProperties.QXL : graphicsTypeToLegacyDisplayType(graphicsInfos.keySet().iterator().next());
        createInfo.put(VdsProperties.display, legacyGraphicsType);
    }
}
#end_block

#method_before
private void buildVmDevicesFromDb(VmDeviceGeneralType generalType, boolean addAddress, Map<String, Object> extraSpecParams) {
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vm.getId(), generalType);
    for (VmDevice vmDevice : vmDevices) {
        Map struct = new HashMap();
        struct.put(VdsProperties.Type, vmDevice.getType().getValue());
        struct.put(VdsProperties.Device, vmDevice.getDevice());
        Map<String, Object> specParams = vmDevice.getSpecParams();
        if (extraSpecParams != null) {
            for (Map.Entry<String, Object> entry : extraSpecParams.entrySet()) {
                specParams.put(entry.getKey(), entry.getValue());
            }
        }
        struct.put(VdsProperties.SpecParams, specParams);
        struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
        if (addAddress) {
            addAddress(vmDevice, struct);
        }
        devices.add(struct);
    }
}
#method_after
private void buildVmDevicesFromDb(VmDeviceGeneralType generalType, boolean addAddress, Map<String, Object> extraSpecParams) {
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vm.getId(), generalType);
    for (VmDevice vmDevice : vmDevices) {
        Map struct = new HashMap();
        struct.put(VdsProperties.Type, vmDevice.getType().getValue());
        struct.put(VdsProperties.Device, vmDevice.getDevice());
        Map<String, Object> specParams = vmDevice.getSpecParams();
        if (extraSpecParams != null) {
            specParams.putAll(extraSpecParams);
        }
        struct.put(VdsProperties.SpecParams, specParams);
        struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
        if (addAddress) {
            addAddress(vmDevice, struct);
        }
        devices.add(struct);
    }
}
#end_block

#method_before
private static VmStatic buildVmStaticDataFromExternalProvider(Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.vm_guid) || !xmlRpcStruct.containsKey(VdsProperties.vm_name) || !xmlRpcStruct.containsKey(VdsProperties.mem_size_mb) || !xmlRpcStruct.containsKey(VdsProperties.num_of_cpus)) {
        return null;
    }
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(Guid.createGuidFromString((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    vmStatic.setName((String) xmlRpcStruct.get(VdsProperties.vm_name));
    vmStatic.setMemSizeMb(parseIntVdsProperty(xmlRpcStruct.get(VdsProperties.mem_size_mb)));
    vmStatic.setNumOfSockets(parseIntVdsProperty(xmlRpcStruct.get(VdsProperties.num_of_cpus)));
    vmStatic.setCustomCpuName((String) xmlRpcStruct.get(VdsProperties.cpu_model));
    vmStatic.setCustomEmulatedMachine((String) xmlRpcStruct.get(VdsProperties.emulatedMachine));
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        for (Object disk : (Object[]) xmlRpcStruct.get(VdsProperties.vm_disks)) {
            Map<String, Object> diskMap = (Map<String, Object>) disk;
            if (VdsProperties.Disk.equals(diskMap.get(VdsProperties.type))) {
                DiskImage image = buildDiskImageFromExternalProvider(diskMap);
                vmStatic.getImages().add(image);
            }
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NETWORKS)) {
        int idx = 0;
        for (Object networkMap : (Object[]) xmlRpcStruct.get(VdsProperties.NETWORKS)) {
            VmNetworkInterface nic = buildNetworkInterfaceFromExternalProvider((Map<String, Object>) networkMap);
            nic.setName(String.format("nic%d", ++idx));
            nic.setVmName(vmStatic.getName());
            vmStatic.getInterfaces().add(nic);
        }
    }
    return vmStatic;
}
#method_after
private static VmStatic buildVmStaticDataFromExternalProvider(Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.vm_guid) || !xmlRpcStruct.containsKey(VdsProperties.vm_name) || !xmlRpcStruct.containsKey(VdsProperties.mem_size_mb) || !xmlRpcStruct.containsKey(VdsProperties.num_of_cpus)) {
        return null;
    }
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(Guid.createGuidFromString((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    vmStatic.setName((String) xmlRpcStruct.get(VdsProperties.vm_name));
    vmStatic.setMemSizeMb(parseIntVdsProperty(xmlRpcStruct.get(VdsProperties.mem_size_mb)));
    vmStatic.setNumOfSockets(parseIntVdsProperty(xmlRpcStruct.get(VdsProperties.num_of_cpus)));
    vmStatic.setCustomCpuName((String) xmlRpcStruct.get(VdsProperties.cpu_model));
    vmStatic.setCustomEmulatedMachine((String) xmlRpcStruct.get(VdsProperties.emulatedMachine));
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        for (Object disk : (Object[]) xmlRpcStruct.get(VdsProperties.vm_disks)) {
            Map<String, Object> diskMap = (Map<String, Object>) disk;
            if (VdsProperties.Disk.equals(diskMap.get(VdsProperties.type))) {
                DiskImage image = buildDiskImageFromExternalProvider(diskMap);
                vmStatic.getImages().add(image);
            }
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NETWORKS)) {
        int idx = 0;
        for (Object networkMap : (Object[]) xmlRpcStruct.get(VdsProperties.NETWORKS)) {
            VmNetworkInterface nic = buildNetworkInterfaceFromExternalProvider((Map<String, Object>) networkMap);
            nic.setName(String.format("nic%d", ++idx));
            nic.setVmName(vmStatic.getName());
            nic.setVmId(vmStatic.getId());
            vmStatic.getInterfaces().add(nic);
        }
    }
    return vmStatic;
}
#end_block

