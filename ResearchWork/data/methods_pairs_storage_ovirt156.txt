169
#method_before
private OsRepository getOsRepository() {
    return SimpleDependecyInjector.getInstance().get(OsRepository.class);
}
#method_after
private static OsRepository getOsRepository() {
    return SimpleDependecyInjector.getInstance().get(OsRepository.class);
}
#end_block

#method_before
@Override
protected void buildVmCD() {
    Map<String, Object> struct;
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.CDROM) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct);
        addDevice(struct, vmDevice, "");
    }
    // check first if CD was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            struct = new HashMap<String, Object>();
            String cdPath = vm.getCdPath();
            addCdDetails(vmDevice, struct);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
}
#method_after
@Override
protected void buildVmCD() {
    Map<String, Object> struct;
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.CDROM) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, "");
    }
    // check first if CD was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            struct = new HashMap<String, Object>();
            String cdPath = vm.getCdPath();
            addCdDetails(vmDevice, struct, vm);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmFloppy() {
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.FLOPPY) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        Map<String, Object> struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct);
        addDevice(struct, vmDevice, "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        Map<String, Object> struct = new HashMap<String, Object>();
        addFloppyDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            Map<String, Object> struct = new HashMap<String, Object>();
            String file = vm.getFloppyPath();
            addFloppyDetails(vmDevice, struct);
            addDevice(struct, vmDevice, file);
        }
    }
}
#method_after
@Override
protected void buildVmFloppy() {
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.FLOPPY) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        Map<String, Object> struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        Map<String, Object> struct = new HashMap<String, Object>();
        addFloppyDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            Map<String, Object> struct = new HashMap<String, Object>();
            String file = vm.getFloppyPath();
            addFloppyDetails(vmDevice, struct);
            addDevice(struct, vmDevice, file);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<String, Object>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForVirtioScsiDisk(unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(vm.getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#method_after
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<String, Object>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(vm.getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#end_block

#method_before
@Override
protected void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Map.Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), Base64.encodeBase64String(entry.getValue()));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addCdDetails(vmDevice, struct);
    addDevice(struct, vmDevice, "");
}
#method_after
@Override
protected void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Map.Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), Base64.encodeBase64String(entry.getValue()));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addCdDetails(vmDevice, struct, vm);
    addDevice(struct, vmDevice, "");
}
#end_block

#method_before
private static void addCdDetails(VmDevice vmDevice, Map<String, Object> struct) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    // IDE slot 2 is reserved by VDSM to CDROM
    struct.put(VdsProperties.Index, "2");
    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
    struct.put(VdsProperties.ReadOnly, Boolean.TRUE.toString());
    struct.put(VdsProperties.Shareable, Boolean.FALSE.toString());
}
#method_after
private static void addCdDetails(VmDevice vmDevice, Map<String, Object> struct, VM vm) {
    OsRepository osRepository = getOsRepository();
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getVdsGroupCompatibilityVersion());
    if ("scsi".equals(cdInterface)) {
        // SCSI unit 0 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "0");
        struct.put(VdsProperties.Address, createAddressForScsiDisk(0, 0));
    } else if ("ide".equals(cdInterface)) {
        // IDE slot 2 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "2");
    }
    struct.put(VdsProperties.INTERFACE, cdInterface);
    struct.put(VdsProperties.ReadOnly, Boolean.TRUE.toString());
    struct.put(VdsProperties.Shareable, Boolean.FALSE.toString());
}
#end_block

#method_before
@Override
protected void buildVmVirtioScsi() {
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName());
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.CONTROLLER.getValue());
        struct.put(VdsProperties.Device, VdsProperties.Scsi);
        struct.put(VdsProperties.Model, VdsProperties.VirtioScsi);
        addAddress(vmDevice, struct);
        addDevice(struct, vmDevice, null);
    }
}
#method_after
@Override
protected void buildVmVirtioScsi() {
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName());
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.CONTROLLER.getValue());
        struct.put(VdsProperties.Device, VdsProperties.Scsi);
        struct.put(VdsProperties.Model, VdsProperties.VirtioScsi);
        struct.put(VdsProperties.Index, Integer.toString(virtioScsiIndex));
        addAddress(vmDevice, struct);
        virtioScsiIndex++;
        addDevice(struct, vmDevice, null);
    }
}
#end_block

#method_before
public static Map<VmDevice, Integer> getVmDeviceUnitMapForVirtioScsiDisks(VM vm) {
    List<Disk> disks = new ArrayList<Disk>(vm.getDiskMap().values());
    Map<VmDevice, Integer> vmDeviceUnitMap = new HashMap<>();
    Map<VmDevice, Disk> vmDeviceDiskMap = new HashMap<>();
    for (Disk disk : disks) {
        if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
            VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
            Map<String, String> address = XmlRpcStringUtils.string2Map(vmDevice.getAddress());
            String unitStr = address.get(VdsProperties.Unit);
            // Otherwise, adding to 'vmDeviceDiskMap' for setting the unit property later.
            if (StringUtils.isNotEmpty(unitStr)) {
                vmDeviceUnitMap.put(vmDevice, Integer.valueOf(unitStr));
            } else {
                vmDeviceDiskMap.put(vmDevice, disk);
            }
        }
    }
    // Find available unit (disk's index in VirtIO-SCSI controller) for disks with empty address
    for (Entry<VmDevice, Disk> entry : vmDeviceDiskMap.entrySet()) {
        int unit = getAvailableUnitForVirtioScsiDisk(vmDeviceUnitMap);
        vmDeviceUnitMap.put(entry.getKey(), unit);
    }
    return vmDeviceUnitMap;
}
#method_after
public static Map<VmDevice, Integer> getVmDeviceUnitMapForVirtioScsiDisks(VM vm) {
    return getVmDeviceUnitMapForScsiDisks(vm, DiskInterface.VirtIO_SCSI, false);
}
#end_block

#method_before
private void applyNetworkChangesToHosts() {
    SyncNetworkParametersBuilder builder = new SyncNetworkParametersBuilder();
    ArrayList<VdcActionParametersBase> parameters = builder.buildParameters(getNetwork());
    if (!parameters.isEmpty()) {
        getBackend().runInternalMultipleActions(VdcActionType.PersistentSetupNetworks, parameters);
    }
}
#method_after
private void applyNetworkChangesToHosts() {
    SyncNetworkParametersBuilder builder = new SyncNetworkParametersBuilder();
    ArrayList<VdcActionParametersBase> parameters = builder.buildParameters(getNetwork(), getOldNetwork());
    if (!parameters.isEmpty()) {
        getBackend().runInternalMultipleActions(VdcActionType.PersistentSetupNetworks, parameters);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (onlyPermittedFieldsChanged()) {
        return true;
    }
    NetworkValidator validatorNew = new NetworkValidator(getNetwork());
    UpdateNetworkValidator validatorOld = new UpdateNetworkValidator(getOldNetwork());
    return validate(validatorNew.dataCenterExists()) && validate(validatorNew.vmNetworkSetCorrectly()) && validate(validatorNew.stpForVmNetworkOnly()) && validate(validatorNew.mtuValid()) && validate(validatorNew.networkPrefixValid()) && validate(validatorNew.vlanIdNotUsed()) && validate(validatorNew.qosExistsInDc()) && validate(validatorOld.networkIsSet()) && validate(validatorOld.notRenamingManagementNetwork(getNetwork())) && validate(validatorNew.networkNameNotUsed()) && validate(validatorOld.networkNotUsedByRunningVms()) && validate(validatorOld.nonVmNetworkNotUsedByVms(getNetwork())) && validate(validatorOld.nonVmNetworkNotUsedByTemplates(getNetwork())) && validate(validatorOld.notRenamingUsedNetwork(getNetworkName())) && (oldAndNewNetworkIsNotExternal() || validate(validatorOld.externalNetworkDetailsUnchanged(getNetwork())));
}
#method_after
@Override
protected boolean canDoAction() {
    if (onlyPermittedFieldsChanged()) {
        return true;
    }
    NetworkValidator validatorNew = new NetworkValidator(getNetwork());
    UpdateNetworkValidator validatorOld = new UpdateNetworkValidator(getOldNetwork());
    return validate(validatorNew.dataCenterExists()) && validate(validatorNew.vmNetworkSetCorrectly()) && validate(validatorNew.stpForVmNetworkOnly()) && validate(validatorNew.mtuValid()) && validate(validatorNew.networkPrefixValid()) && validate(validatorNew.vlanIdNotUsed()) && validate(validatorNew.qosExistsInDc()) && validate(validatorOld.networkIsSet()) && validate(validatorOld.notRenamingManagementNetwork(getNetwork())) && validate(validatorNew.networkNameNotUsed()) && validate(validatorOld.networkNotUsedByRunningVms()) && validate(validatorOld.nonVmNetworkNotUsedByVms(getNetwork())) && validate(validatorOld.nonVmNetworkNotUsedByTemplates(getNetwork())) && validate(validatorOld.notRenamingUsedNetwork(getNetworkName())) && validate(validatorOld.notRenamingLabel(getNetwork().getLabel())) && (oldAndNewNetworkIsNotExternal() || validate(validatorOld.externalNetworkDetailsUnchanged(getNetwork())));
}
#end_block

#method_before
private ArrayList<VdcActionParametersBase> buildParameters(Network network) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getVdsInterfacesByNetworkId(getNetwork().getId());
    Set<Guid> hostIdsToSync = new HashSet<>();
    for (VdsNetworkInterface nic : nics) {
        if (!NetworkUtils.isNetworkInSync(nic, getNetwork())) {
            hostIdsToSync.add(nic.getVdsId());
        }
    }
    for (Guid hostId : hostIdsToSync) {
        SetupNetworksParameters setupNetworkParams = createSetupNetworksParameters(hostId);
        setupNetworkParams.setNetworksToSync(Collections.singletonList(getNetworkName()));
        parameters.add(setupNetworkParams);
    }
    return parameters;
}
#method_after
private ArrayList<VdcActionParametersBase> buildParameters(Network network, Network oldNetwork) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getVdsInterfacesByNetworkId(network.getId());
    // sync network on nics if the label wasn't changed
    if (!labelChanged()) {
        createSyncNetworkParameters(parameters, nics);
        return parameters;
    }
    // add network to labeled interfaces and sync network on the rest
    if (labelAdded()) {
        List<VdsNetworkInterface> labeledNics = getLabeledNics(network);
        Map<Guid, VdsNetworkInterface> hostToNic = mapHostToNic(nics);
        List<VdsNetworkInterface> nicsForAdd = new ArrayList<>();
        Set<VdsNetworkInterface> nicsForSync = new HashSet<>();
        // nics to add network
        for (VdsNetworkInterface labeledNic : labeledNics) {
            VdsNetworkInterface nic = hostToNic.get(labeledNic.getVdsId());
            // add network to labeled nic if network not configured on host
            if (nic == null) {
                nicsForAdd.add(labeledNic);
            } else {
                // sync the network
                nicsForSync.add(nic);
            }
        }
        // add the unlabeled nics to be synced
        for (VdsNetworkInterface nic : nics) {
            if (!nicsForSync.contains(nic)) {
                nicsForSync.add(nic);
            }
        }
        parameters.addAll(createAddNetworkParameters(nicsForAdd));
        createSyncNetworkParameters(parameters, nicsForSync);
        return parameters;
    }
    // remove network from labeled interfaces
    if (labelRemoved()) {
        List<VdsNetworkInterface> labeledNics = getLabeledNics(oldNetwork);
        Map<Guid, VdsNetworkInterface> hostToNic = mapHostToNic(nics);
        List<VdsNetworkInterface> nicsForRemove = new ArrayList<>();
        Set<VdsNetworkInterface> nicsForSync = new HashSet<>();
        // nics to remove the network from
        for (VdsNetworkInterface labeledNic : labeledNics) {
            VdsNetworkInterface nic = hostToNic.get(labeledNic.getVdsId());
            // remove the network from labeled nic
            if (nic != null) {
                nicsForRemove.add(labeledNic);
            }
        }
        // add the unlabeled nics to be synced
        for (VdsNetworkInterface nic : nics) {
            if (!nicsForSync.contains(nic)) {
                nicsForSync.add(nic);
            }
        }
        parameters.addAll(createRemoveNetworkParameters(nicsForRemove));
        createSyncNetworkParameters(parameters, nicsForSync);
        return parameters;
    }
    return parameters;
}
#end_block

#method_before
public ValidationResult vlanIdNotUsed() {
    if (network.getVlanId() != null) {
        for (Network otherNetwork : getNetworks()) {
            if (otherNetwork.getVlanId() != null && otherNetwork.getVlanId().equals(network.getVlanId()) && !otherNetwork.getId().equals(network.getId())) {
                return new ValidationResult(VdcBllMessages.NETWORK_VLAN_IN_USE, String.format("$vlanId %d", network.getVlanId()));
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult vlanIdNotUsed() {
    if (NetworkUtils.isVlan(network)) {
        for (Network otherNetwork : getNetworks()) {
            if (NetworkUtils.isVlan(otherNetwork) && otherNetwork.getVlanId().equals(network.getVlanId()) && !otherNetwork.getId().equals(network.getId())) {
                return new ValidationResult(VdcBllMessages.NETWORK_VLAN_IN_USE, String.format("$vlanId %d", network.getVlanId()));
            }
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private void validateNotRemovingLabeledNetworks() {
    Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(params.getInterfaces());
    Map<String, VdsNetworkInterface> hostInterfacesByNetworkName = Entities.hostInterfacesByNetworkName(getExistingIfaces().values());
    for (String network : removedNetworks) {
        VdsNetworkInterface nic = hostInterfacesByNetworkName.get(network);
        if (nic != null) {
            if (NetworkUtils.isVlan(nic)) {
                nic = nicsByName.get(NetworkUtils.stripVlan(nic.getName()));
            }
            if (nic.getLabels() != null && nic.getLabels().contains(getExistingClusterNetworks().get(network).getLabel())) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, network);
            }
        }
    }
}
#method_after
private void validateNotRemovingLabeledNetworks() {
    Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(params.getInterfaces());
    Map<String, VdsNetworkInterface> hostInterfacesByNetworkName = Entities.hostInterfacesByNetworkName(getExistingIfaces().values());
    for (String network : removedNetworks) {
        VdsNetworkInterface nic = hostInterfacesByNetworkName.get(network);
        if (nic != null) {
            if (NetworkUtils.isVlan(nic)) {
                nic = nicsByName.get(NetworkUtils.stripVlan(nic.getName()));
            }
            Network removedNetwork = getExistingClusterNetworks().get(network);
            if (nic.getLabels() != null && removedNetwork != null && nic.getLabels().contains(removedNetwork.getLabel())) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, network);
            }
        }
    }
}
#end_block

#method_before
@Override
public List<Network> getAllByLabelForCluster(String label, Guid clusterId) {
    List<Network> networksInCluster = getAllForCluster(clusterId, null, false);
    List<Network> labeledNetworks = new ArrayList<>();
    for (Network network : networksInCluster) {
        if (StringUtils.equals(network.getLabel(), label)) {
            labeledNetworks.add(network);
        }
    }
    return labeledNetworks;
}
#method_after
@Override
public List<Network> getAllByLabelForCluster(String label, Guid clusterId) {
    List<Network> networksInCluster = getAllForCluster(clusterId);
    List<Network> labeledNetworks = new ArrayList<>();
    for (Network network : networksInCluster) {
        if (StringUtils.equals(network.getLabel(), label)) {
            labeledNetworks.add(network);
        }
    }
    return labeledNetworks;
}
#end_block

#method_before
@Override
public boolean isValid(VdsNetworkInterface iface, ConstraintValidatorContext context) {
    NetworkBootProtocol bootProtocol = iface.getBootProtocol();
    String address = iface.getAddress();
    if (bootProtocol != null && bootProtocol == STATIC_IP) {
        if (isNullOrEmpty(address)) {
            context.disableDefaultConstraintViolation();
            context.buildConstraintViolationWithTemplate("NETWORK_ADDR_MANDATORY_IN_STATIC_IP").addNode("address").addConstraintViolation();
            return false;
        }
    }
    if (!isEmpty(iface.getBondName()) && !validateSlave(iface)) {
        context.disableDefaultConstraintViolation();
        context.buildConstraintViolationWithTemplate("SLAVE_INTERFACE_IS_MISCONFIGURED").addConstraintViolation();
        return false;
    }
    if (validateLabel(iface)) {
        context.disableDefaultConstraintViolation();
        context.buildConstraintViolationWithTemplate("IMPROPER_INTERFACE_IS_LABELED").addConstraintViolation();
    }
    return true;
}
#method_after
@Override
public boolean isValid(VdsNetworkInterface iface, ConstraintValidatorContext context) {
    NetworkBootProtocol bootProtocol = iface.getBootProtocol();
    String address = iface.getAddress();
    if (bootProtocol != null && bootProtocol == STATIC_IP) {
        if (isNullOrEmpty(address)) {
            context.disableDefaultConstraintViolation();
            context.buildConstraintViolationWithTemplate("NETWORK_ADDR_MANDATORY_IN_STATIC_IP").addNode("address").addConstraintViolation();
            return false;
        }
    }
    if (!isEmpty(iface.getBondName()) && !validateSlave(iface)) {
        context.disableDefaultConstraintViolation();
        context.buildConstraintViolationWithTemplate("SLAVE_INTERFACE_IS_MISCONFIGURED").addConstraintViolation();
        return false;
    }
    if (!validateLabel(iface)) {
        context.disableDefaultConstraintViolation();
        context.buildConstraintViolationWithTemplate("IMPROPER_INTERFACE_IS_LABELED").addConstraintViolation();
    }
    return true;
}
#end_block

#method_before
public static String getVlanDeviceName(String underlyingNic, Network network) {
    return underlyingNic + "." + network.getVlanId();
}
#method_after
public static String getVlanDeviceName(VdsNetworkInterface underlyingNic, Network network) {
    return underlyingNic.getName() + "." + network.getVlanId();
}
#end_block

#method_before
public ArrayList<VdcActionParametersBase> buildParameters(List<VdsNetworkInterface> nics) {
    Set<Guid> nonUpdateableHosts = new HashSet<>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    boolean vlanNetwork = NetworkUtils.isVlan(network);
    for (VdsNetworkInterface nic : nics) {
        SetupNetworksParameters setupNetworkParams = createSetupNetworksParameters(nic.getVdsId());
        VdsNetworkInterface nicToConfigure = getNicToConfigure(setupNetworkParams.getInterfaces(), nic.getId());
        if (nicToConfigure == null) {
            continue;
        }
        if (vlanNetwork) {
            VdsNetworkInterface vlan = createVlanDevice(nic.getName(), nicToConfigure.getVdsId(), network);
            setupNetworkParams.getInterfaces().add(vlan);
        } else if (nicToConfigure.getNetworkName() == null) {
            nicToConfigure.setNetworkName(network.getName());
        } else {
            // if a network is already assigned to that nic, it cannot be configured
            nonUpdateableHosts.add(nic.getVdsId());
            continue;
        }
        parameters.add(setupNetworkParams);
    }
    reportNonUpdateableHosts(nonUpdateableHosts);
    return parameters;
}
#method_after
public ArrayList<VdcActionParametersBase> buildParameters(List<VdsNetworkInterface> nics) {
    Set<Guid> nonUpdateableHosts = new HashSet<>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    boolean vlanNetwork = NetworkUtils.isVlan(network);
    for (VdsNetworkInterface nic : nics) {
        SetupNetworksParameters setupNetworkParams = createSetupNetworksParameters(nic.getVdsId());
        VdsNetworkInterface nicToConfigure = getNicToConfigure(setupNetworkParams.getInterfaces(), nic.getId());
        if (vlanNetwork) {
            VdsNetworkInterface vlan = createVlanDevice(nic, nicToConfigure.getVdsId(), network);
            setupNetworkParams.getInterfaces().add(vlan);
        } else if (nicToConfigure.getNetworkName() == null) {
            nicToConfigure.setNetworkName(network.getName());
        } else {
            // if a network is already assigned to that nic, it cannot be configured
            nonUpdateableHosts.add(nic.getVdsId());
            continue;
        }
        parameters.add(setupNetworkParams);
    }
    reportNonUpdateableHosts(nonUpdateableHosts);
    return parameters;
}
#end_block

#method_before
private void reportNonUpdateableHosts(Set<Guid> nonUpdateableHosts) {
    if (nonUpdateableHosts.isEmpty()) {
        return;
    }
    List<String> hostNames = new ArrayList<>(nonUpdateableHosts.size());
    for (Guid hostId : nonUpdateableHosts) {
        hostNames.add(getDbFacade().getVdsStaticDao().get(hostId).getName());
    }
    AuditLogableBase logable = new AuditLogableBase();
    logable.setStoragePoolId(network.getDataCenterId());
    logable.addCustomValue("Network", network.getName());
    logable.addCustomValue("HostNames", StringUtils.join(hostNames, ", "));
    AuditLogDirector.log(logable, AuditLogType.ADD_NETWORK_BY_LABEL_FAILED);
}
#method_after
private void reportNonUpdateableHosts(Set<Guid> nonUpdateableHosts) {
    if (nonUpdateableHosts.isEmpty()) {
        return;
    }
    List<String> hostNames = new ArrayList<>(nonUpdateableHosts.size());
    for (Guid hostId : nonUpdateableHosts) {
        hostNames.add(getDbFacade().getVdsStaticDao().get(hostId).getName());
    }
    AuditLogableBase logable = new AuditLogableBase();
    logable.setStoragePoolId(network.getDataCenterId());
    logable.addCustomValue("Network", network.getName());
    logable.addCustomValue("HostNames", StringUtils.join(hostNames, ", "));
    logable.addCustomValue("Label", network.getLabel());
    AuditLogDirector.log(logable, AuditLogType.ADD_NETWORK_BY_LABEL_FAILED);
}
#end_block

#method_before
private VdsNetworkInterface createVlanDevice(String underlyingNic, Guid hostId, Network network) {
    VdsNetworkInterface vlan = new Vlan();
    vlan.setNetworkName(network.getName());
    vlan.setVdsId(hostId);
    vlan.setName(NetworkUtils.getVlanDeviceName(underlyingNic, network));
    vlan.setBootProtocol(NetworkBootProtocol.NONE);
    return vlan;
}
#method_after
private VdsNetworkInterface createVlanDevice(VdsNetworkInterface nic, Guid hostId, Network network) {
    VdsNetworkInterface vlan = new Vlan();
    vlan.setNetworkName(network.getName());
    vlan.setVdsId(hostId);
    vlan.setName(NetworkUtils.getVlanDeviceName(nic, network));
    vlan.setBootProtocol(NetworkBootProtocol.NONE);
    return vlan;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setStoragePoolId(getNetwork().getDataCenterId());
    if (Boolean.TRUE.equals(getParameters().getRemoveFromNetworkProvider()) && getNetwork().isExternal()) {
        removeExternalNetwork();
    }
    removeVnicProfiles();
    getNetworkDAO().remove(getNetwork().getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    setStoragePoolId(getNetwork().getDataCenterId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            removeVnicProfiles();
            getCompensationContext().snapshotEntity(getNetwork());
            getNetworkDAO().remove(getNetwork().getId());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getParameters().isRemoveFromNetworkProvider() && getNetwork().isExternal()) {
        removeExternalNetwork();
    }
    setSucceeded(true);
}
#end_block

#method_before
protected void removeVnicProfiles() {
    List<VnicProfile> profiles = getVnicProfileDao().getAllForNetwork(getNetwork().getId());
    for (VnicProfile vnicProfile : profiles) {
        getVnicProfileDao().remove(vnicProfile.getId());
    }
}
#method_after
protected void removeVnicProfiles() {
    List<VnicProfile> profiles = getVnicProfileDao().getAllForNetwork(getNetwork().getId());
    for (VnicProfile vnicProfile : profiles) {
        getCompensationContext().snapshotEntity(vnicProfile);
        getVnicProfileDao().remove(vnicProfile.getId());
    }
}
#end_block

#method_before
private boolean applyChangesToHostsRequired() {
    return !getNetwork().isExternal() && setupNetworkSupported();
}
#method_after
private boolean applyChangesToHostsRequired() {
    return !getNetwork().isExternal() && NetworkHelper.setupNetworkSupported(getStoragePool().getcompatibility_version());
}
#end_block

#method_before
protected ArrayList<VdcActionParametersBase> buildParameters(Network network) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getVdsInterfacesByNetworkId(getNetwork().getId());
    Set<Guid> hostIdsToSync = new HashSet<>();
    for (VdsNetworkInterface nic : nics) {
        if (!NetworkUtils.isNetworkInSync(nic, getNetwork())) {
            hostIdsToSync.add(nic.getVdsId());
        }
    }
    for (Guid hostId : hostIdsToSync) {
        SetupNetworksParameters setupNetworkParams = createSetupNetworksParameters(hostId);
        setupNetworkParams.setNetworksToSync(Collections.singletonList(getNetworkName()));
        parameters.add(setupNetworkParams);
    }
    return parameters;
}
#method_after
private ArrayList<VdcActionParametersBase> buildParameters(Network network) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getVdsInterfacesByNetworkId(getNetwork().getId());
    Set<Guid> hostIdsToSync = new HashSet<>();
    for (VdsNetworkInterface nic : nics) {
        if (!NetworkUtils.isNetworkInSync(nic, getNetwork())) {
            hostIdsToSync.add(nic.getVdsId());
        }
    }
    for (Guid hostId : hostIdsToSync) {
        SetupNetworksParameters setupNetworkParams = createSetupNetworksParameters(hostId);
        setupNetworkParams.setNetworksToSync(Collections.singletonList(getNetworkName()));
        parameters.add(setupNetworkParams);
    }
    return parameters;
}
#end_block

#method_before
@Override
public String add(Network network) {
    NetworkForCreate networkForCreate = new NetworkForCreate();
    networkForCreate.setAdminStateUp(true);
    networkForCreate.setName(network.getName());
    if (network.getLabel() != null) {
        networkForCreate.setProviderPhysicalNetwork(network.getLabel());
        if (network.getVlanId() == null) {
            networkForCreate.setProviderNetworkType(FLAT_NETWORK);
        } else {
            networkForCreate.setProviderNetworkType(VLAN_NETWORK);
            networkForCreate.setProviderSegmentationId(network.getVlanId());
        }
    }
    if (!provider.isRequiringAuthentication()) {
        networkForCreate.setTenantId(DEVICE_OWNER);
    }
    try {
        com.woorea.openstack.quantum.model.Network createdNetwork = getClient().networks().create(networkForCreate).execute();
        return createdNetwork.getId();
    } catch (RuntimeException e) {
        throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE, e);
    }
}
#method_after
@Override
public String add(Network network) {
    NetworkForCreate networkForCreate = new NetworkForCreate();
    networkForCreate.setAdminStateUp(true);
    networkForCreate.setName(network.getName());
    if (network.getLabel() != null) {
        networkForCreate.setProviderPhysicalNetwork(network.getLabel());
        if (NetworkUtils.isVlan(network)) {
            networkForCreate.setProviderNetworkType(VLAN_NETWORK);
            networkForCreate.setProviderSegmentationId(network.getVlanId());
        } else {
            networkForCreate.setProviderNetworkType(FLAT_NETWORK);
        }
    }
    if (!provider.isRequiringAuthentication()) {
        networkForCreate.setTenantId(DEVICE_OWNER);
    }
    try {
        com.woorea.openstack.quantum.model.Network createdNetwork = getClient().networks().create(networkForCreate).execute();
        return createdNetwork.getId();
    } catch (RuntimeException e) {
        throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE, e);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getNetwork().setId(Guid.newGuid());
    getNetworkDAO().save(getNetwork());
    if (getNetwork().isVmNetwork() && getParameters().isVnicProfileRequired()) {
        getVnicProfileDao().save(NetworkHelper.createVnicProfile(getNetwork()));
    }
    NetworkHelper.addPermissionsOnNetwork(getCurrentUser().getId(), getNetwork().getId());
    getReturnValue().setActionReturnValue(getNetwork().getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getNetwork().setId(Guid.newGuid());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getNetworkDAO().save(getNetwork());
            if (getNetwork().isVmNetwork() && getParameters().isVnicProfileRequired()) {
                getVnicProfileDao().save(NetworkHelper.createVnicProfile(getNetwork()));
            }
            NetworkHelper.addPermissionsOnNetwork(getCurrentUser().getId(), getNetwork().getId());
            return null;
        }
    });
    getReturnValue().setActionReturnValue(getNetwork().getId());
    setSucceeded(true);
}
#end_block

#method_before
public void setRemoveFromNetworkProvider(Boolean removeFromNetworkProvider) {
    this.removeFromNetworkProvider = removeFromNetworkProvider;
}
#method_after
public void setRemoveFromNetworkProvider(boolean removeFromNetworkProvider) {
    this.removeFromNetworkProvider = removeFromNetworkProvider;
}
#end_block

#method_before
protected boolean reconstructMaster() {
    proceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive unless the selected domain is the current master
    if (getParameters().isInactive() && (_isLastMaster || !getNewMaster(true).getId().equals(getStorageDomain().getId()))) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getVdsSpmId())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<StoragePoolIsoMap> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    setActionReturnValue(true);
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getVdsSpmId(), getStoragePool().getId(), getStoragePool().getName(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#method_after
protected boolean reconstructMaster() {
    proceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive unless the selected domain is the current master
    if (getParameters().isInactive() && !getStorageDomain().getId().equals(_newMasterStorageDomainId)) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>getValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getVdsSpmId())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<StoragePoolIsoMap> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    setActionReturnValue(true);
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getVdsSpmId(), getStoragePool().getId(), getStoragePool().getName(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    final boolean isPerformConnectOps = !_isLastMaster && commandSucceeded;
    final boolean isPerformDisconnect = !getParameters().isInactive();
    if (isPerformConnectOps || isPerformDisconnect) {
        List<Callable<Void>> tasks = new ArrayList<Callable<Void>>();
        for (final VDS vds : getAllRunningVdssInPool()) {
            tasks.add(new Callable<Void>() {

                @Override
                public Void call() {
                    try {
                        if (isPerformConnectOps && connectVdsToNewMaster(vds)) {
                            try {
                                runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                            } catch (VdcBLLException ex) {
                                if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                                    VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getVdsSpmId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                                    if (!returnVal.getSucceeded()) {
                                        log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                                    }
                                } else {
                                    log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                                }
                            }
                        }
                        // only if we deactivate the storage domain we want to disconnect from it.
                        if (isPerformDisconnect) {
                            StorageHelperDirector.getInstance().getItem(getStorageDomain().getStorageType()).disconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
                        }
                    } catch (Exception e) {
                        log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
                    }
                    return null;
                }
            });
        }
        ThreadPoolUtil.invokeAll(tasks);
    }
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    final boolean isPerformConnectOps = !_isLastMaster && commandSucceeded;
    if (isPerformConnectOps) {
        List<Callable<Void>> tasks = new ArrayList<Callable<Void>>();
        for (final VDS vds : getAllRunningVdssInPool()) {
            tasks.add(new Callable<Void>() {

                @Override
                public Void call() {
                    try {
                        if (isPerformConnectOps && connectVdsToNewMaster(vds)) {
                            try {
                                runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                            } catch (VdcBLLException ex) {
                                if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                                    VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getVdsSpmId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                                    if (!returnVal.getSucceeded()) {
                                        log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                                    }
                                } else {
                                    log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                                }
                            }
                        }
                    } catch (Exception e) {
                        log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
                    }
                    return null;
                }
            });
        }
        ThreadPoolUtil.invokeAll(tasks);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    spm = null;
    if (getStoragePool().getspm_vds_id() != null) {
        spm = getVdsDAO().get(getStoragePool().getspm_vds_id());
    }
    final StoragePoolIsoMap map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    map.setStatus(StorageDomainStatus.Unknown);
    changeStorageDomainStatusInTransaction(map, StorageDomainStatus.Locked);
    proceedStorageDomainTreatmentByDomainType(false);
    if (_isLastMaster) {
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getCompensationContext().snapshotEntityStatus(getStoragePool());
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
        runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
        getStorageDomain().getStorageDynamicData().setAvailableDiskSize(null);
        getStorageDomain().getStorageDynamicData().setUsedDiskSize(null);
    }
    if (!getParameters().isInactive()) {
        runVdsCommand(VDSCommandType.DeactivateStorageDomain, new DeactivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
    }
    freeLock();
    if (!getParameters().isInactive()) {
        runSynchronizeOperation(new AfterDeactivateSingleAsyncOperationFactory(), _isLastMaster, _newMasterStorageDomainId);
    }
    if (_isLastMaster && spm != null) {
        final VDSReturnValue stopSpmReturnValue = runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
        if (!stopSpmReturnValue.getSucceeded()) {
            // no need to continue because DisconnectStoragePool will
            // fail if host is SPM
            log.error("Aborting execution due to failure stopping SPM." + " Stop SPM failed due to " + stopSpmReturnValue.getExceptionString());
            setSucceeded(false);
            return;
        }
        runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(spm.getId(), getStoragePool().getId(), spm.getVdsSpmId()));
    }
    if (!getParameters().isInactive() && spm != null) {
        getStorageHelper(getStorageDomain()).disconnectStorageFromDomainByVdsId(getStorageDomain(), spm.getId());
    }
    executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            if (getParameters().isInactive()) {
                map.setStatus(StorageDomainStatus.InActive);
            } else {
                map.setStatus(StorageDomainStatus.Maintenance);
            }
            getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
            if (!Guid.Empty.equals(_newMasterStorageDomainId)) {
                StoragePoolIsoMap mapOfNewMaster = getNewMaster(false).getStoragePoolIsoMapData();
                mapOfNewMaster.setStatus(StorageDomainStatus.Active);
                getStoragePoolIsoMapDAO().updateStatus(mapOfNewMaster.getId(), mapOfNewMaster.getStatus());
            }
            return null;
        }
    });
    notifyAsyncTasks();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    spm = null;
    if (getStoragePool().getspm_vds_id() != null) {
        spm = getVdsDAO().get(getStoragePool().getspm_vds_id());
    }
    final StoragePoolIsoMap map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    map.setStatus(StorageDomainStatus.Unknown);
    changeStorageDomainStatusInTransaction(map, StorageDomainStatus.Locked);
    proceedStorageDomainTreatmentByDomainType(false);
    if (_isLastMaster) {
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getCompensationContext().snapshotEntityStatus(getStoragePool());
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
        getStorageDomain().getStorageDynamicData().setAvailableDiskSize(null);
        getStorageDomain().getStorageDynamicData().setUsedDiskSize(null);
    }
    if (!getParameters().isInactive()) {
        runVdsCommand(VDSCommandType.DeactivateStorageDomain, new DeactivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
    }
    freeLock();
    if (_isLastMaster) {
        if (spm != null) {
            final VDSReturnValue stopSpmReturnValue = runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
            if (!stopSpmReturnValue.getSucceeded()) {
                // no need to continue because DisconnectStoragePool will
                // fail if host is SPM
                log.error("Aborting execution due to failure stopping SPM." + " Stop SPM failed due to " + stopSpmReturnValue.getExceptionString());
                setSucceeded(false);
                return;
            }
            runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(spm.getId(), getStoragePool().getId(), spm.getVdsSpmId()));
        }
        runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    }
    if (!getParameters().isInactive()) {
        runSynchronizeOperation(new AfterDeactivateSingleAsyncOperationFactory(), _isLastMaster, _newMasterStorageDomainId);
    }
    if (!getParameters().isInactive() && spm != null) {
        getStorageHelper(getStorageDomain()).disconnectStorageFromDomainByVdsId(getStorageDomain(), spm.getId());
    }
    executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            if (getParameters().isInactive()) {
                map.setStatus(StorageDomainStatus.InActive);
            } else {
                map.setStatus(StorageDomainStatus.Maintenance);
            }
            getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
            if (!Guid.Empty.equals(_newMasterStorageDomainId)) {
                StoragePoolIsoMap mapOfNewMaster = getNewMaster(false).getStoragePoolIsoMapData();
                mapOfNewMaster.setStatus(StorageDomainStatus.Active);
                getStoragePoolIsoMapDAO().updateStatus(mapOfNewMaster.getId(), mapOfNewMaster.getStatus());
            }
            return null;
        }
    });
    notifyAsyncTasks();
    setSucceeded(true);
}
#end_block

#method_before
@Override
public void vdsNotResponding(final VDS vds, final boolean executeSshSoftFencing) {
    ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, false);
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            log.infoFormat("ResourceManager::vdsNotResponding entered for Host {0}, {1}", vds.getId(), vds.getHostName());
            boolean shouldExecRealFencing = true;
            if (executeSshSoftFencing) {
                VdcReturnValueBase retVal = Backend.getInstance().runInternalAction(VdcActionType.SshSoftFencing, new VdsActionParameters(vds.getId()), ExecutionHandler.createInternalJobContext());
                // if SSH Soft Fencing command execution was successful, do not execute
                // standard fencing immediately, but wait to see if it helped
                shouldExecRealFencing = !retVal.getSucceeded();
            }
            if (MonitoringStrategyFactory.getMonitoringStrategyForVds(vds).isPowerManagementSupported() && shouldExecRealFencing) {
                Backend.getInstance().runInternalAction(VdcActionType.VdsNotRespondingTreatment, new FenceVdsActionParameters(vds.getId(), FenceActionType.Restart), ExecutionHandler.createInternalJobContext());
            }
        }
    });
}
#method_after
@Override
public void vdsNotResponding(final VDS vds, final boolean executeSshSoftFencing) {
    ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, false);
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            log.infoFormat("ResourceManager::vdsNotResponding entered for Host {0}, {1}", vds.getId(), vds.getHostName());
            boolean shouldExecRealFencing = true;
            if (executeSshSoftFencing) {
                VdcReturnValueBase retVal = Backend.getInstance().runInternalAction(VdcActionType.SshSoftFencing, new VdsActionParameters(vds.getId()), ExecutionHandler.createInternalJobContext());
                // if SSH Soft Fencing command execution was successful, do not execute
                // standard fencing immediately, but wait to see if it helped
                shouldExecRealFencing = !retVal.getSucceeded();
            }
            if (MonitoringStrategyFactory.getMonitoringStrategyForVds(vds).isPowerManagementSupported() && shouldExecRealFencing) {
                Backend.getInstance().runInternalAction(VdcActionType.VdsNotRespondingTreatment, new FenceVdsActionParameters(vds.getId(), FenceActionType.Restart), ExecutionHandler.createInternalJobContext());
            }
            moveBricksToUnknown(vds);
        }
    });
}
#end_block

#method_before
@Override
public void processOnClientIpChange(final VDS vds, final Guid vmId) {
    final VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(vmId);
    // (this happened when user close the console to spice/vnc)
    if (StringUtils.isEmpty(vmDynamic.getClientIp())) {
        vmDynamic.setConsoleCurrentUserName(null);
        DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
    }
}
#method_after
@Override
public void processOnClientIpChange(final VDS vds, final Guid vmId) {
    final VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(vmId);
    final AuditLogableBase event = new AuditLogableBase();
    event.setVmId(vmId);
    event.setUserName(vmDynamic.getConsoleCurrentUserName());
    // (this happened when user close the console to spice/vnc)
    if (StringUtils.isEmpty(vmDynamic.getClientIp())) {
        vmDynamic.setConsoleCurrentUserName(null);
        DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
        AuditLogDirector.log(event, AuditLogType.VM_CONSOLE_DISCONNECTED);
    } else {
        AuditLogDirector.log(event, AuditLogType.VM_CONSOLE_CONNECTED);
    }
}
#end_block

#method_before
@Override
public void processOnVmPoweringUp(Guid vds_id, Guid vmid, String display_ip, int display_port) {
    IVdsAsyncCommand command = Backend.getInstance().getResourceManager().GetAsyncCommandForVm(vmid);
    if (command != null) {
        command.onPowerringUp();
        if (command.getAutoStart() && command.getAutoStartVdsId() != null) {
            try {
                String otp64 = Ticketing.GenerateOTP();
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmTicket, new SetVmTicketVDSCommandParameters(vds_id, vmid, otp64, 60, "", Guid.Empty));
                log.infoFormat("VdsEventListener.ProcessOnVmPoweringUp - Auto start logic, starting spice to vm - {0} ", vmid);
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.StartSpice, new StartSpiceVDSCommandParameters(command.getAutoStartVdsId(), display_ip, display_port, otp64));
            } catch (RuntimeException ex) {
                log.errorFormat("VdsEventListener.ProcessOnVmPoweringUp - failed to start spice on VM - {0} - {1} - {2}", vmid, ex.getMessage(), ex.getStackTrace());
            }
        }
    }
}
#method_after
@Override
public void processOnVmPoweringUp(Guid vds_id, Guid vmid, String display_ip, int display_port) {
    IVdsAsyncCommand command = Backend.getInstance().getResourceManager().GetAsyncCommandForVm(vmid);
    /*
         * XXX: command is null after successful migration, because runningSucceeded removes the
         *      MigrateVmCommand instance from the async cache too early.
         *      See the order of succeededToRunVm and processOnVmPoweringUp
         *      in VdsUpdateRunTimeInfo.afterRefreshTreatment
         */
    if (command != null) {
        command.onPowerringUp();
        if (command.getAutoStart() && command.getAutoStartVdsId() != null) {
            try {
                String otp64 = Ticketing.generateOTP();
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmTicket, new SetVmTicketVDSCommandParameters(vds_id, vmid, otp64, 60, "", Guid.Empty));
                log.infoFormat("VdsEventListener.ProcessOnVmPoweringUp - Auto start logic, starting spice to vm - {0} ", vmid);
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.StartSpice, new StartSpiceVDSCommandParameters(command.getAutoStartVdsId(), display_ip, display_port, otp64));
            } catch (RuntimeException ex) {
                log.errorFormat("VdsEventListener.ProcessOnVmPoweringUp - failed to start spice on VM - {0} - {1} - {2}", vmid, ex.getMessage(), ex.getStackTrace());
            }
        }
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void proceedStoragePoolStats(StoragePool storagePool) {
    // ugly patch because vdsm doesnt check if host is spm on spm
    // operations
    VDSReturnValue result = null;
    Guid curVdsId = mCurrentVdsId;
    if (curVdsId != null) {
        result = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(curVdsId, _storagePoolId));
    }
    if (result == null || !result.getSucceeded() || (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() != SpmStatus.SPM)) {
        // update pool status to problematic until fence will happen
        if (storagePool.getStatus() != StoragePoolStatus.NonResponsive && storagePool.getStatus() != StoragePoolStatus.NotOperational) {
            if (result != null && result.getVdsError() != null) {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, result.getVdsError().getCode());
            } else {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE);
            }
        }
        // then cause failover with attempts
        if (result != null && !(result.getExceptionObject() instanceof VDSNetworkException)) {
            HashMap<Guid, AsyncTaskStatus> tasksList = (HashMap<Guid, AsyncTaskStatus>) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(curVdsId)).getReturnValue();
            boolean allTasksFinished = true;
            if (tasksList != null) {
                for (AsyncTaskStatus taskStatus : tasksList.values()) {
                    if (AsyncTaskStatusEnum.finished != taskStatus.getStatus()) {
                        allTasksFinished = false;
                        break;
                    }
                }
            }
            if ((tasksList == null) || allTasksFinished) {
                nullifyInternalProxies();
            } else {
                if (_errorAttempts < Config.<Integer>GetValue(ConfigValues.SPMFailOverAttempts)) {
                    _errorAttempts++;
                    log.warnFormat("failed getting spm status for pool {0}:{1}, attempt number {2}", _storagePoolId, storagePool.getName(), _errorAttempts);
                } else {
                    nullifyInternalProxies();
                    _errorAttempts = 0;
                }
            }
        }
    } else if (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() == SpmStatus.SPM && (storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend)) {
        // if recovered from network exception set back to up
        DbFacade.getInstance().getStoragePoolDao().updateStatus(storagePool.getId(), StoragePoolStatus.Up);
        storagePool.setStatus(StoragePoolStatus.Up);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getStatus());
    }
    GetStoragePoolInfoVDSCommandParameters tempVar = new GetStoragePoolInfoVDSCommandParameters(_storagePoolId);
    tempVar.setIgnoreFailoverLimit(true);
    VDSReturnValue storagePoolInfoResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetStoragePoolInfo, tempVar);
    if (storagePoolInfoResult.getSucceeded()) {
        KeyValuePairCompat<StoragePool, java.util.List<StorageDomain>> data = (KeyValuePairCompat<StoragePool, java.util.List<StorageDomain>>) storagePoolInfoResult.getReturnValue();
        int masterVersion = data.getKey().getmaster_domain_version();
        java.util.HashSet<Guid> domainsInVds = new java.util.HashSet<Guid>();
        for (StorageDomain domainData : data.getValue()) {
            domainsInVds.add(domainData.getId());
            proceedStorageDomain(domainData, masterVersion, storagePool);
        }
        List<StorageDomain> domainsInDb = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(_storagePoolId);
        for (final StorageDomain domainInDb : domainsInDb) {
            if (domainInDb.getStorageDomainType() != StorageDomainType.Master && domainInDb.getStatus() != StorageDomainStatus.Locked && !domainsInVds.contains(domainInDb.getId())) {
                // domain not attached to pool anymore
                DbFacade.getInstance().getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(domainInDb.getId(), _storagePoolId));
            }
        }
    }
}
#method_after
@SuppressWarnings("unchecked")
private void proceedStoragePoolStats(StoragePool storagePool) {
    // ugly patch because vdsm doesnt check if host is spm on spm
    // operations
    VDSReturnValue result = null;
    Guid curVdsId = mCurrentVdsId;
    if (curVdsId != null) {
        result = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(curVdsId, _storagePoolId));
    }
    if (result == null || !result.getSucceeded() || (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() != SpmStatus.SPM)) {
        // update pool status to problematic until fence will happen
        if (storagePool.getStatus() != StoragePoolStatus.NonResponsive && storagePool.getStatus() != StoragePoolStatus.NotOperational) {
            if (result != null && result.getVdsError() != null) {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, result.getVdsError().getCode());
            } else {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE);
            }
        }
        // then cause failover with attempts
        if (result != null && !(result.getExceptionObject() instanceof VDSNetworkException)) {
            HashMap<Guid, AsyncTaskStatus> tasksList = (HashMap<Guid, AsyncTaskStatus>) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(curVdsId)).getReturnValue();
            boolean allTasksFinished = true;
            if (tasksList != null) {
                for (AsyncTaskStatus taskStatus : tasksList.values()) {
                    if (AsyncTaskStatusEnum.finished != taskStatus.getStatus()) {
                        allTasksFinished = false;
                        break;
                    }
                }
            }
            if ((tasksList == null) || allTasksFinished) {
                nullifyInternalProxies();
            } else {
                if (_errorAttempts < Config.<Integer>getValue(ConfigValues.SPMFailOverAttempts)) {
                    _errorAttempts++;
                    log.warnFormat("failed getting spm status for pool {0}:{1}, attempt number {2}", _storagePoolId, storagePool.getName(), _errorAttempts);
                } else {
                    nullifyInternalProxies();
                    _errorAttempts = 0;
                }
            }
        }
    } else if (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() == SpmStatus.SPM && (storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend)) {
        // if recovered from network exception set back to up
        DbFacade.getInstance().getStoragePoolDao().updateStatus(storagePool.getId(), StoragePoolStatus.Up);
        storagePool.setStatus(StoragePoolStatus.Up);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getStatus());
    }
    GetStoragePoolInfoVDSCommandParameters tempVar = new GetStoragePoolInfoVDSCommandParameters(_storagePoolId);
    tempVar.setIgnoreFailoverLimit(true);
    VDSReturnValue storagePoolInfoResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetStoragePoolInfo, tempVar);
    if (storagePoolInfoResult.getSucceeded()) {
        KeyValuePairCompat<StoragePool, java.util.List<StorageDomain>> data = (KeyValuePairCompat<StoragePool, java.util.List<StorageDomain>>) storagePoolInfoResult.getReturnValue();
        int masterVersion = data.getKey().getmaster_domain_version();
        java.util.HashSet<Guid> domainsInVds = new java.util.HashSet<Guid>();
        for (StorageDomain domainData : data.getValue()) {
            domainsInVds.add(domainData.getId());
            proceedStorageDomain(domainData, masterVersion, storagePool);
        }
        List<StorageDomain> domainsInDb = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(_storagePoolId);
        for (final StorageDomain domainInDb : domainsInDb) {
            if (domainInDb.getStorageDomainType() != StorageDomainType.Master && domainInDb.getStatus() != StorageDomainStatus.Locked && !domainsInVds.contains(domainInDb.getId())) {
                // domain not attached to pool anymore
                DbFacade.getInstance().getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(domainInDb.getId(), _storagePoolId));
            }
        }
    }
}
#end_block

#method_before
private void proceedStorageDomain(StorageDomain data, int dataMasterVersion, StoragePool storagePool) {
    StorageDomain storage_domain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(data.getId(), _storagePoolId);
    StorageDomainStatic domainFromDb = null;
    StoragePoolIsoMap domainPoolMap = null;
    if (storage_domain != null) {
        domainFromDb = storage_domain.getStorageStaticData();
        domainPoolMap = storage_domain.getStoragePoolIsoMapData();
        // If the domain is master in the DB
        if (domainFromDb.getStorageDomainType() == StorageDomainType.Master && domainPoolMap != null && domainPoolMap.getStatus() != StorageDomainStatus.Locked) {
            // and the domain is not master in the VDSM
            if (!((data.getStorageDomainType() == StorageDomainType.Master) || (data.getStorageDomainType() == StorageDomainType.Unknown))) {
                reconstructMasterDomainNotInSync(data.getStoragePoolId(), domainFromDb.getId(), "Mismatch between master in DB and VDSM", MessageFormat.format("Master domain is not in sync between DB and VDSM. " + "Domain {0} marked as master in DB and not in the storage", domainFromDb.getStorageName()));
            } else // mismatch
            if (dataMasterVersion != storagePool.getmaster_domain_version()) {
                reconstructMasterDomainNotInSync(data.getStoragePoolId(), domainFromDb.getId(), "Mismatch between master version in DB and VDSM", MessageFormat.format("Master domain version is not in sync between DB and VDSM. " + "Domain {0} marked as master, but the version in DB: {1} and in VDSM: {2}", domainFromDb.getStorageName(), storagePool.getmaster_domain_version(), dataMasterVersion));
            }
        }
        boolean statusChanged = false;
        if (domainPoolMap == null) {
            data.setStoragePoolId(_storagePoolId);
            DbFacade.getInstance().getStoragePoolIsoMapDao().save(data.getStoragePoolIsoMapData());
            statusChanged = true;
        } else if (domainPoolMap.getStatus() != StorageDomainStatus.Locked && domainPoolMap.getStatus() != data.getStatus()) {
            if (domainPoolMap.getStatus() != StorageDomainStatus.InActive && data.getStatus() != StorageDomainStatus.InActive) {
                DbFacade.getInstance().getStoragePoolIsoMapDao().update(data.getStoragePoolIsoMapData());
                statusChanged = true;
            }
            if (data.getStatus() != null && data.getStatus() == StorageDomainStatus.InActive && domainFromDb.getStorageDomainType() == StorageDomainType.Master) {
                StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(domainPoolMap.getstorage_pool_id());
                if (pool != null) {
                    DbFacade.getInstance().getStoragePoolDao().updateStatus(pool.getId(), StoragePoolStatus.Maintenance);
                    pool.setStatus(StoragePoolStatus.Maintenance);
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(pool.getId(), StoragePoolStatus.Maintenance);
                }
            }
        }
        // update dynamic data
        if (statusChanged || (domainPoolMap.getStatus() != StorageDomainStatus.InActive && data.getStatus() == StorageDomainStatus.Active)) {
            DbFacade.getInstance().getStorageDomainDynamicDao().update(data.getStorageDynamicData());
            if (data.getAvailableDiskSize() != null && data.getUsedDiskSize() != null) {
                double freePercent = data.getStorageDynamicData().getfreeDiskPercent();
                int freeDiskInGB = data.getStorageDynamicData().getfreeDiskInGB();
                AuditLogType type = AuditLogType.UNASSIGNED;
                boolean spaceThresholdMet = freeDiskInGB <= Config.<Integer>GetValue(ConfigValues.FreeSpaceCriticalLowInGB);
                boolean percentThresholdMet = freePercent <= Config.<Integer>GetValue(ConfigValues.FreeSpaceLow);
                if (spaceThresholdMet && percentThresholdMet) {
                    type = AuditLogType.IRS_DISK_SPACE_LOW_ERROR;
                } else {
                    if (spaceThresholdMet || percentThresholdMet) {
                        type = AuditLogType.IRS_DISK_SPACE_LOW;
                    }
                }
                if (type != AuditLogType.UNASSIGNED) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setStorageDomain(data);
                    logable.setStoragePoolId(_storagePoolId);
                    logable.addCustomValue("DiskSpace", (data.getAvailableDiskSize()).toString());
                    data.setStorageName(domainFromDb.getStorageName());
                    AuditLogDirector.log(logable, type);
                }
            }
            Set<VdcBllErrors> alerts = data.getAlerts();
            if (alerts != null && !alerts.isEmpty()) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.setStorageDomain(data);
                data.setStorageName(domainFromDb.getStorageName());
                logable.setStoragePoolId(_storagePoolId);
                for (VdcBllErrors alert : alerts) {
                    switch(alert) {
                        case VG_METADATA_CRITICALLY_FULL:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL);
                            break;
                        case SMALL_VG_METADATA:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA);
                            break;
                        default:
                            log.errorFormat("Unrecognized alert for domain {0}(id = {1}): {2}", data.getStorageName(), data.getId(), alert);
                            break;
                    }
                }
            }
        }
    } else {
        log.debugFormat("The domain with id {0} was not found in DB", data.getId());
    }
}
#method_after
private void proceedStorageDomain(StorageDomain data, int dataMasterVersion, StoragePool storagePool) {
    StorageDomain storage_domain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(data.getId(), _storagePoolId);
    StorageDomainStatic domainFromDb = null;
    StoragePoolIsoMap domainPoolMap = null;
    if (storage_domain != null) {
        domainFromDb = storage_domain.getStorageStaticData();
        domainPoolMap = storage_domain.getStoragePoolIsoMapData();
        // If the domain is master in the DB
        if (domainFromDb.getStorageDomainType() == StorageDomainType.Master && domainPoolMap != null && domainPoolMap.getStatus() != StorageDomainStatus.Locked) {
            // and the domain is not master in the VDSM
            if (!((data.getStorageDomainType() == StorageDomainType.Master) || (data.getStorageDomainType() == StorageDomainType.Unknown))) {
                reconstructMasterDomainNotInSync(data.getStoragePoolId(), domainFromDb.getId(), "Mismatch between master in DB and VDSM", MessageFormat.format("Master domain is not in sync between DB and VDSM. " + "Domain {0} marked as master in DB and not in the storage", domainFromDb.getStorageName()));
            } else // mismatch
            if (dataMasterVersion != storagePool.getmaster_domain_version()) {
                reconstructMasterDomainNotInSync(data.getStoragePoolId(), domainFromDb.getId(), "Mismatch between master version in DB and VDSM", MessageFormat.format("Master domain version is not in sync between DB and VDSM. " + "Domain {0} marked as master, but the version in DB: {1} and in VDSM: {2}", domainFromDb.getStorageName(), storagePool.getmaster_domain_version(), dataMasterVersion));
            }
        }
        boolean statusChanged = false;
        if (domainPoolMap == null) {
            data.setStoragePoolId(_storagePoolId);
            DbFacade.getInstance().getStoragePoolIsoMapDao().save(data.getStoragePoolIsoMapData());
            statusChanged = true;
        } else if (domainPoolMap.getStatus() != StorageDomainStatus.Locked && domainPoolMap.getStatus() != data.getStatus()) {
            if (domainPoolMap.getStatus() != StorageDomainStatus.InActive && data.getStatus() != StorageDomainStatus.InActive) {
                DbFacade.getInstance().getStoragePoolIsoMapDao().update(data.getStoragePoolIsoMapData());
                statusChanged = true;
            }
            if (data.getStatus() != null && data.getStatus() == StorageDomainStatus.InActive && domainFromDb.getStorageDomainType() == StorageDomainType.Master) {
                StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(domainPoolMap.getstorage_pool_id());
                if (pool != null) {
                    DbFacade.getInstance().getStoragePoolDao().updateStatus(pool.getId(), StoragePoolStatus.Maintenance);
                    pool.setStatus(StoragePoolStatus.Maintenance);
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(pool.getId(), StoragePoolStatus.Maintenance);
                }
            }
        }
        // update dynamic data
        if (statusChanged || (domainPoolMap.getStatus() != StorageDomainStatus.InActive && data.getStatus() == StorageDomainStatus.Active)) {
            DbFacade.getInstance().getStorageDomainDynamicDao().update(data.getStorageDynamicData());
            if (data.getAvailableDiskSize() != null && data.getUsedDiskSize() != null) {
                double freePercent = data.getStorageDynamicData().getfreeDiskPercent();
                int freeDiskInGB = data.getStorageDynamicData().getfreeDiskInGB();
                AuditLogType type = AuditLogType.UNASSIGNED;
                boolean spaceThresholdMet = freeDiskInGB <= Config.<Integer>getValue(ConfigValues.FreeSpaceCriticalLowInGB);
                boolean percentThresholdMet = freePercent <= Config.<Integer>getValue(ConfigValues.FreeSpaceLow);
                if (spaceThresholdMet && percentThresholdMet) {
                    type = AuditLogType.IRS_DISK_SPACE_LOW_ERROR;
                } else {
                    if (spaceThresholdMet || percentThresholdMet) {
                        type = AuditLogType.IRS_DISK_SPACE_LOW;
                    }
                }
                if (type != AuditLogType.UNASSIGNED) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setStorageDomain(data);
                    logable.setStoragePoolId(_storagePoolId);
                    logable.addCustomValue("DiskSpace", (data.getAvailableDiskSize()).toString());
                    data.setStorageName(domainFromDb.getStorageName());
                    AuditLogDirector.log(logable, type);
                }
            }
            Set<VdcBllErrors> alerts = data.getAlerts();
            if (alerts != null && !alerts.isEmpty()) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.setStorageDomain(data);
                data.setStorageName(domainFromDb.getStorageName());
                logable.setStoragePoolId(_storagePoolId);
                for (VdcBllErrors alert : alerts) {
                    switch(alert) {
                        case VG_METADATA_CRITICALLY_FULL:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL);
                            break;
                        case SMALL_VG_METADATA:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA);
                            break;
                        default:
                            log.errorFormat("Unrecognized alert for domain {0}(id = {1}): {2}", data.getStorageName(), data.getId(), alert);
                            break;
                    }
                }
            }
        }
    } else {
        log.debugFormat("The domain with id {0} was not found in DB", data.getId());
    }
}
#end_block

#method_before
public IIrsServer getIrsProxy() {
    if (getmIrsProxy() == null) {
        final StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
        // don't try to start spm on uninitialized pool
        if (storagePool.getStatus() != StoragePoolStatus.Uninitialized) {
            String host = TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<String>() {

                @Override
                public String runInTransaction() {
                    return gethostFromVds();
                }
            });
            if (host != null) {
                // Get the values of the timeouts:
                int clientTimeOut = Config.<Integer>GetValue(ConfigValues.vdsTimeout) * 1000;
                int connectionTimeOut = Config.<Integer>GetValue(ConfigValues.vdsConnectionTimeout) * 1000;
                int clientRetries = Config.<Integer>GetValue(ConfigValues.vdsRetries);
                Pair<IrsServerConnector, HttpClient> returnValue = XmlRpcUtils.getConnection(host, getmIrsPort(), clientTimeOut, connectionTimeOut, clientRetries, IrsServerConnector.class, Config.<Boolean>GetValue(ConfigValues.EncryptHostCommunication));
                privatemIrsProxy = new IrsServerWrapper(returnValue.getFirst(), returnValue.getSecond());
                runStoragePoolUpEvent(storagePool);
            }
        }
    }
    return getmIrsProxy();
}
#method_after
public IIrsServer getIrsProxy() {
    if (getmIrsProxy() == null) {
        final StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
        // don't try to start spm on uninitialized pool
        if (storagePool.getStatus() != StoragePoolStatus.Uninitialized) {
            String host = TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<String>() {

                @Override
                public String runInTransaction() {
                    return gethostFromVds();
                }
            });
            if (host != null) {
                // Get the values of the timeouts:
                int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
                int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
                int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
                Pair<IrsServerConnector, HttpClient> returnValue = XmlRpcUtils.getConnection(host, getmIrsPort(), clientTimeOut, connectionTimeOut, clientRetries, IrsServerConnector.class, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication));
                privatemIrsProxy = new IrsServerWrapper(returnValue.getFirst(), returnValue.getSecond());
                runStoragePoolUpEvent(storagePool);
            }
        }
    }
    return getmIrsProxy();
}
#end_block

#method_before
private String handleSelectedVdsForSPM(StoragePool storagePool, RefObject<VDS> selectedVds, RefObject<SpmStatusResult> spmStatus, StoragePoolStatus prevStatus) {
    String returnValue = null;
    if (spmStatus.argvalue == null || spmStatus.argvalue.getSpmStatus() != SpmStatus.SPM) {
        movePoolToProblematicInDB(storagePool);
        selectedVds.argvalue = null;
        log.infoFormat("spm start treatment ended and status is not SPM!!! status: {0} - setting selectedVds to null!", spmStatus.argvalue.getSpmStatus().toString());
    } else {
        Init(selectedVds.argvalue);
        storagePool.setLVER(spmStatus.argvalue.getSpmLVER());
        storagePool.setspm_vds_id(selectedVds.argvalue.getId());
        // host move pool to up
        if (prevStatus != StoragePoolStatus.NotOperational && prevStatus != StoragePoolStatus.NonResponsive) {
            storagePool.setStatus(prevStatus);
        } else {
            storagePool.setStatus(StoragePoolStatus.Up);
        }
        DbFacade.getInstance().getStoragePoolDao().update(storagePool);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getStatus());
        returnValue = selectedVds.argvalue.getHostName();
        log.infoFormat("Initialize Irs proxy from vds: {0}", returnValue);
        AuditLogableBase logable = new AuditLogableBase(selectedVds.argvalue.getId());
        logable.addCustomValue("ServerIp", returnValue);
        AuditLogDirector.log(logable, AuditLogType.IRS_HOSTED_ON_VDS);
    }
    return returnValue;
}
#method_after
private String handleSelectedVdsForSPM(StoragePool storagePool, RefObject<VDS> selectedVds, RefObject<SpmStatusResult> spmStatus, StoragePoolStatus prevStatus) {
    String returnValue = null;
    if (spmStatus.argvalue == null || spmStatus.argvalue.getSpmStatus() != SpmStatus.SPM) {
        movePoolToProblematicInDB(storagePool);
        selectedVds.argvalue = null;
        log.infoFormat("spm start treatment ended and status is not SPM!!! status: {0} - setting selectedVds to null!", spmStatus.argvalue.getSpmStatus().toString());
    } else {
        init(selectedVds.argvalue);
        storagePool.setLVER(spmStatus.argvalue.getSpmLVER());
        storagePool.setspm_vds_id(selectedVds.argvalue.getId());
        // host move pool to up
        if (prevStatus != StoragePoolStatus.NotOperational && prevStatus != StoragePoolStatus.NonResponsive) {
            storagePool.setStatus(prevStatus);
        } else {
            storagePool.setStatus(StoragePoolStatus.Up);
        }
        DbFacade.getInstance().getStoragePoolDao().update(storagePool);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getStatus());
        returnValue = selectedVds.argvalue.getHostName();
        log.infoFormat("Initialize Irs proxy from vds: {0}", returnValue);
        AuditLogableBase logable = new AuditLogableBase(selectedVds.argvalue.getId());
        logable.addCustomValue("ServerIp", returnValue);
        AuditLogDirector.log(logable, AuditLogType.IRS_HOSTED_ON_VDS);
    }
    return returnValue;
}
#end_block

#method_before
private void waitForVdsIfIsInitializing(Guid curVdsId) {
    if (!Guid.Empty.equals(curVdsId)) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        String vdsName = vds.getName();
        if (vds.getStatus() == VDSStatus.Initializing) {
            // 5 Sec
            final int DELAY = 5;
            int total = 0;
            Integer maxSecToWait = Config.GetValue(ConfigValues.WaitForVdsInitInSec);
            while (total <= maxSecToWait && DbFacade.getInstance().getVdsDynamicDao().get(curVdsId).getStatus() == VDSStatus.Initializing) {
                try {
                    Thread.sleep(DELAY * 1000);
                } catch (InterruptedException e) {
                    log.errorFormat("Interrupt exception {0}", e.getMessage());
                    // exit the while block
                    break;
                }
                total += DELAY;
                log.infoFormat("Waiting to Host {0} to finish initialization for {1} Sec.", vdsName, total);
            }
        }
    }
}
#method_after
private void waitForVdsIfIsInitializing(Guid curVdsId) {
    if (!Guid.Empty.equals(curVdsId)) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        String vdsName = vds.getName();
        if (vds.getStatus() == VDSStatus.Initializing) {
            // 5 Sec
            final int DELAY = 5;
            int total = 0;
            Integer maxSecToWait = Config.getValue(ConfigValues.WaitForVdsInitInSec);
            while (total <= maxSecToWait && DbFacade.getInstance().getVdsDynamicDao().get(curVdsId).getStatus() == VDSStatus.Initializing) {
                try {
                    Thread.sleep(DELAY * 1000);
                } catch (InterruptedException e) {
                    log.errorFormat("Interrupt exception {0}", e.getMessage());
                    // exit the while block
                    break;
                }
                total += DELAY;
                log.infoFormat("Waiting to Host {0} to finish initialization for {1} Sec.", vdsName, total);
            }
        }
    }
}
#end_block

#method_before
public void updateVdsDomainsData(final Guid vdsId, final String vdsName, final ArrayList<VDSDomainsData> data) {
    Set<Guid> domainsInProblems = null;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null && (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive)) {
        try {
            // build a list of all domains in pool
            // which are in status Active or Unknown
            Set<Guid> domainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Active));
            domainsInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
            Set<Guid> inActiveDomainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.InActive));
            // build a list of all the domains in
            // pool (domainsInPool) that are not
            // visible by the host.
            List<Guid> domainsInPoolThatNonVisibleByVds = new ArrayList<Guid>();
            Set<Guid> dataDomainIds = new HashSet<Guid>();
            for (VDSDomainsData tempData : data) {
                dataDomainIds.add(tempData.getDomainId());
            }
            for (Guid tempDomainId : domainsInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsInPoolThatNonVisibleByVds.add(tempDomainId);
                }
            }
            // build a list of domains that the host
            // reports as in problem (code!=0) or (code==0
            // && lastChecl >
            // ConfigValues.MaxStorageVdsTimeoutCheckSec)
            // and are contained in the Active or
            // Unknown domains in pool
            List<Guid> domainsSeenByVdsInProblem = new ArrayList<Guid>();
            for (VDSDomainsData tempData : data) {
                if (domainsInPool.contains(tempData.getDomainId())) {
                    if (isDomainReportedAsProblematic(tempData, false)) {
                        domainsSeenByVdsInProblem.add(tempData.getDomainId());
                    } else if (tempData.getDelay() > Config.<Double>GetValue(ConfigValues.MaxStorageVdsDelayCheckSec)) {
                        logDelayedDomain(vdsId, tempData);
                    }
                } else if (inActiveDomainsInPool.contains(tempData.getDomainId()) && !isDomainReportedAsProblematic(tempData, false)) {
                    log.warnFormat("Storage Domain {0} was reported by Host {1} as Active in Pool {2}, moving to active status", getDomainIdTuple(tempData.getDomainId()), vdsName, _storagePoolId);
                    StoragePoolIsoMap map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(tempData.getDomainId(), _storagePoolId));
                    map.setStatus(StorageDomainStatus.Active);
                    DbFacade.getInstance().getStoragePoolIsoMapDao().update(map);
                }
            }
            // build a list of all potential domains
            // in problem
            domainsInProblems = new HashSet<Guid>();
            domainsInProblems.addAll(domainsInPoolThatNonVisibleByVds);
            domainsInProblems.addAll(domainsSeenByVdsInProblem);
        } catch (RuntimeException ex) {
            log.error("error in updateVdsDomainsData", ex);
        }
    }
    updateDomainInProblem(vdsId, vdsName, domainsInProblems);
}
#method_after
public void updateVdsDomainsData(final Guid vdsId, final String vdsName, final ArrayList<VDSDomainsData> data) {
    Set<Guid> domainsInProblems = null;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null && (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive)) {
        try {
            // build a list of all domains in pool
            // which are in status Active or Unknown
            Set<Guid> domainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Active));
            domainsInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
            Set<Guid> inActiveDomainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.InActive));
            // build a list of all the domains in
            // pool (domainsInPool) that are not
            // visible by the host.
            List<Guid> domainsInPoolThatNonVisibleByVds = new ArrayList<Guid>();
            Set<Guid> dataDomainIds = new HashSet<Guid>();
            for (VDSDomainsData tempData : data) {
                dataDomainIds.add(tempData.getDomainId());
            }
            for (Guid tempDomainId : domainsInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsInPoolThatNonVisibleByVds.add(tempDomainId);
                }
            }
            // build a list of domains that the host
            // reports as in problem (code!=0) or (code==0
            // && lastChecl >
            // ConfigValues.MaxStorageVdsTimeoutCheckSec)
            // and are contained in the Active or
            // Unknown domains in pool
            List<Guid> domainsSeenByVdsInProblem = new ArrayList<Guid>();
            for (VDSDomainsData tempData : data) {
                if (domainsInPool.contains(tempData.getDomainId())) {
                    if (isDomainReportedAsProblematic(tempData, false)) {
                        domainsSeenByVdsInProblem.add(tempData.getDomainId());
                    } else if (tempData.getDelay() > Config.<Double>getValue(ConfigValues.MaxStorageVdsDelayCheckSec)) {
                        logDelayedDomain(vdsId, tempData);
                    }
                } else if (inActiveDomainsInPool.contains(tempData.getDomainId()) && !isDomainReportedAsProblematic(tempData, false)) {
                    log.warnFormat("Storage Domain {0} was reported by Host {1} as Active in Pool {2}, moving to active status", getDomainIdTuple(tempData.getDomainId()), vdsName, _storagePoolId);
                    StoragePoolIsoMap map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(tempData.getDomainId(), _storagePoolId));
                    map.setStatus(StorageDomainStatus.Active);
                    DbFacade.getInstance().getStoragePoolIsoMapDao().update(map);
                }
            }
            // build a list of all potential domains
            // in problem
            domainsInProblems = new HashSet<Guid>();
            domainsInProblems.addAll(domainsInPoolThatNonVisibleByVds);
            domainsInProblems.addAll(domainsSeenByVdsInProblem);
        } catch (RuntimeException ex) {
            log.error("error in updateVdsDomainsData", ex);
        }
    }
    updateDomainInProblem(vdsId, vdsName, domainsInProblems);
}
#end_block

#method_before
private boolean isDomainReportedAsProblematic(VDSDomainsData tempData, boolean isLog) {
    if (tempData.getCode() != 0) {
        if (isLog) {
            log.errorFormat("Domain {0} was reported with error code {1}", getDomainIdTuple(tempData.getDomainId()), tempData.getCode());
        }
        return true;
    }
    if (tempData.getLastCheck() > Config.<Double>GetValue(ConfigValues.MaxStorageVdsTimeoutCheckSec)) {
        if (isLog) {
            log.errorFormat("Domain {0} check timeot {1} is too big", getDomainIdTuple(tempData.getDomainId()), tempData.getLastCheck());
        }
        return true;
    }
    return false;
}
#method_after
private boolean isDomainReportedAsProblematic(VDSDomainsData tempData, boolean isLog) {
    if (tempData.getCode() != 0) {
        if (isLog) {
            log.errorFormat("Domain {0} was reported with error code {1}", getDomainIdTuple(tempData.getDomainId()), tempData.getCode());
        }
        return true;
    }
    if (tempData.getLastCheck() > Config.<Double>getValue(ConfigValues.MaxStorageVdsTimeoutCheckSec)) {
        if (isLog) {
            log.errorFormat("Domain {0} check timeot {1} is too big", getDomainIdTuple(tempData.getDomainId()), tempData.getLastCheck());
        }
        return true;
    }
    return false;
}
#end_block

#method_before
private void addDomainInProblemData(Guid domainId, Guid vdsId, String vdsName) {
    _domainsInProblem.put(domainId, new java.util.HashSet<Guid>(java.util.Arrays.asList(vdsId)));
    log.warnFormat("domain {0} in problem. vds: {1}", getDomainIdTuple(domainId), vdsName);
    Class[] inputType = new Class[] { Guid.class };
    Object[] inputParams = new Object[] { domainId };
    String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "OnTimer", inputType, inputParams, Config.<Integer>GetValue(ConfigValues.StorageDomainFalureTimeoutInMinutes), TimeUnit.MINUTES);
    clearTimer(domainId);
    _timers.put(domainId, jobId);
}
#method_after
private void addDomainInProblemData(Guid domainId, Guid vdsId, String vdsName) {
    _domainsInProblem.put(domainId, new java.util.HashSet<Guid>(java.util.Arrays.asList(vdsId)));
    log.warnFormat("domain {0} in problem. vds: {1}", getDomainIdTuple(domainId), vdsName);
    Class[] inputType = new Class[] { Guid.class };
    Object[] inputParams = new Object[] { domainId };
    String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "onTimer", inputType, inputParams, Config.<Integer>getValue(ConfigValues.StorageDomainFalureTimeoutInMinutes), TimeUnit.MINUTES);
    clearTimer(domainId);
    _timers.put(domainId, jobId);
}
#end_block

#method_before
private void failover() {
    if ((getParameters().getIgnoreFailoverLimit() || _failoverCounter < Config.<Integer>GetValue(ConfigValues.SpmCommandFailOverRetries) - 1) && getCurrentIrsProxyData().getHasVdssForSpmSelection() && getCurrentIrsProxyData().failover()) {
        _failoverCounter++;
        executeCommand();
    } else {
        getVDSReturnValue().setSucceeded(false);
    }
}
#method_after
private void failover() {
    if ((getParameters().getIgnoreFailoverLimit() || _failoverCounter < Config.<Integer>getValue(ConfigValues.SpmCommandFailOverRetries) - 1) && getCurrentIrsProxyData().getHasVdssForSpmSelection() && getCurrentIrsProxyData().failover()) {
        _failoverCounter++;
        executeCommand();
    } else {
        getVDSReturnValue().setSucceeded(false);
    }
}
#end_block

#method_before
protected boolean checkStorageDomainNameLengthValid() {
    boolean result = true;
    if (getStorageDomain().getStorageName().length() > Config.<Integer>GetValue(ConfigValues.StorageDomainNameSizeLimit)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        result = false;
    }
    return result;
}
#method_after
protected boolean checkStorageDomainNameLengthValid() {
    boolean result = true;
    if (getStorageDomain().getStorageName().length() > Config.<Integer>getValue(ConfigValues.StorageDomainNameSizeLimit)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        result = false;
    }
    return result;
}
#end_block

#method_before
private VDS getFenceProxy(final boolean onlyUpHost, final boolean filterSelf, final PMProxyOptions proxyOptions) {
    List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
    VDS proxyHost = LinqUtils.firstOrNull(hosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS vds) {
            if (proxyOptions == PMProxyOptions.CLUSTER) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getVdsGroupId().equals(_vds.getVdsGroupId()) && vds.getStatus() == VDSStatus.Up && isAgentSupported(vds);
                    } else {
                        return vds.getStatus() == VDSStatus.Up && vds.getVdsGroupId().equals(_vds.getVdsGroupId()) && isAgentSupported(vds);
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId()) && vds.getVdsGroupId().equals(_vds.getVdsGroupId()) && isAgentSupported(vds);
                    } else {
                        return !isHostNetworkUnreacable(vds) && vds.getVdsGroupId().equals(_vds.getVdsGroupId()) && isAgentSupported(vds);
                    }
                }
            } else if (proxyOptions == PMProxyOptions.DC) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getStoragePoolId().equals(_vds.getStoragePoolId()) && vds.getStatus() == VDSStatus.Up && isAgentSupported(vds);
                    } else {
                        return vds.getStatus() == VDSStatus.Up && vds.getStoragePoolId().equals(_vds.getStoragePoolId()) && isAgentSupported(vds);
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId()) && vds.getStoragePoolId().equals(_vds.getStoragePoolId()) && isAgentSupported(vds);
                    } else {
                        return !isHostNetworkUnreacable(vds) && vds.getStoragePoolId().equals(_vds.getStoragePoolId()) && isAgentSupported(vds);
                    }
                }
            }
            return false;
        }

        private boolean isAgentSupported(VDS vds) {
            boolean ret = false;
            // Checks if the requested _vds PM agent is supported by the candidate proxy (vds)
            VdsFenceOptions options = new VdsFenceOptions(vds.getVdsGroupCompatibilityVersion().getValue());
            if (!StringUtils.isEmpty(_vds.getManagementIp())) {
                ret = options.isAgentSupported(_vds.getPmType());
            }
            // Secondary PM agent should attempt to fence the Host
            if (!StringUtils.isEmpty(_vds.getPmSecondaryIp())) {
                ret = options.isAgentSupported(_vds.getPmSecondaryType());
            }
            return ret;
        }
    });
    return proxyHost;
}
#method_after
private VDS getFenceProxy(final boolean onlyUpHost, final boolean filterSelf, final PMProxyOptions proxyOptions) {
    List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
    VDS proxyHost = LinqUtils.firstOrNull(hosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS vds) {
            if (!isAgentSupported(vds)) {
                return false;
            }
            if (proxyOptions == PMProxyOptions.CLUSTER) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getVdsGroupId().equals(_vds.getVdsGroupId()) && vds.getStatus() == VDSStatus.Up;
                    } else {
                        return vds.getStatus() == VDSStatus.Up && vds.getVdsGroupId().equals(_vds.getVdsGroupId());
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId()) && vds.getVdsGroupId().equals(_vds.getVdsGroupId());
                    } else {
                        return !isHostNetworkUnreacable(vds) && vds.getVdsGroupId().equals(_vds.getVdsGroupId());
                    }
                }
            } else if (proxyOptions == PMProxyOptions.DC) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getStoragePoolId().equals(_vds.getStoragePoolId()) && vds.getStatus() == VDSStatus.Up;
                    } else {
                        return vds.getStatus() == VDSStatus.Up && vds.getStoragePoolId().equals(_vds.getStoragePoolId());
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId()) && vds.getStoragePoolId().equals(_vds.getStoragePoolId());
                    } else {
                        return !isHostNetworkUnreacable(vds) && vds.getStoragePoolId().equals(_vds.getStoragePoolId());
                    }
                }
            }
            return false;
        }

        private boolean isAgentSupported(VDS vds) {
            boolean ret = false;
            // Checks if the requested _vds PM agent is supported by the candidate proxy (vds)
            VdsFenceOptions options = new VdsFenceOptions(vds.getVdsGroupCompatibilityVersion().getValue());
            if (StringUtils.isNotEmpty(_vds.getManagementIp())) {
                ret = options.isAgentSupported(_vds.getPmType());
            }
            // Secondary PM agent should attempt to fence the Host
            if (StringUtils.isNotEmpty(_vds.getPmSecondaryIp())) {
                ret = options.isAgentSupported(_vds.getPmSecondaryType());
            }
            return ret;
        }
    });
    return proxyHost;
}
#end_block

#method_before
@Test
public void testGetAllInterfacesByLabelForCluster() {
    List<VdsNetworkInterface> interfaces = dao.getAllInterfacesByLabelForCluster(CLUSTER_ID, LABEL);
    assertNotNull(interfaces);
    assertEquals(1, interfaces.size());
}
#method_after
@Test
public void testGetAllInterfacesByLabelForCluster() {
    List<VdsNetworkInterface> interfaces = dao.getAllInterfacesByLabelForCluster(CLUSTER_ID, LABEL);
    assertNotNull(interfaces);
    assertFalse(interfaces.isEmpty());
    for (VdsNetworkInterface nic : interfaces) {
        assertTrue(nic.getLabels().contains(LABEL));
    }
}
#end_block

#method_before
@Override
public void saveInterfaceForVds(VdsNetworkInterface stats) {
    MapSqlParameterSource parameterSource = createInterfaceParametersMapper(stats);
    getCallsHandler().executeModification("Insertvds_interface", parameterSource);
}
#method_after
@Override
public void saveInterfaceForVds(VdsNetworkInterface nic) {
    MapSqlParameterSource parameterSource = createInterfaceParametersMapper(nic);
    getCallsHandler().executeModification("Insertvds_interface", parameterSource);
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(getName()).append(" {id=").append(getId()).append(", vdsId=").append(getVdsId()).append(", macAddress=").append(getMacAddress()).append(", networkName=").append(getNetworkName()).append(", vlanId=").append(getVlanId()).append(", bonded=").append(getBonded()).append(", bondName=").append(getBondName()).append(", bondOptions=").append(getBondOptions()).append(", bootProtocol=").append(getBootProtocol()).append(", address=").append(getAddress()).append(", subnet=").append(getSubnet()).append(", gateway=").append(getGateway()).append(", mtu=").append(getMtu()).append(", bridged=").append(isBridged()).append(", speed=").append(getSpeed()).append(", type=").append(getType()).append(", networkImplementationDetails=").append(getNetworkImplementationDetails()).append(", labels=").append(labels).append("}");
    return builder.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(getName()).append(" {id=").append(getId()).append(", vdsId=").append(getVdsId()).append(", macAddress=").append(getMacAddress()).append(", networkName=").append(getNetworkName()).append(", vlanId=").append(getVlanId()).append(", bonded=").append(getBonded()).append(", bondName=").append(getBondName()).append(", bondOptions=").append(getBondOptions()).append(", bootProtocol=").append(getBootProtocol()).append(", address=").append(getAddress()).append(", subnet=").append(getSubnet()).append(", gateway=").append(getGateway()).append(", mtu=").append(getMtu()).append(", bridged=").append(isBridged()).append(", speed=").append(getSpeed()).append(", type=").append(getType()).append(", networkImplementationDetails=").append(getNetworkImplementationDetails()).append(", labels=").append(getLabels()).append("}");
    return builder.toString();
}
#end_block

#method_before
public void validate() {
    // validate mandatory properties
    for (String property : new String[] { NotificationProperties.DAYS_TO_KEEP_HISTORY, NotificationProperties.ENGINE_INTERVAL_IN_SECONDS, NotificationProperties.ENGINE_TIMEOUT_IN_SECONDS, NotificationProperties.INTERVAL_IN_SECONDS, NotificationProperties.IS_HTTPS_PROTOCOL, NotificationProperties.MAIL_PORT, NotificationProperties.MAIL_SERVER, NotificationProperties.REPEAT_NON_RESPONSIVE_NOTIFICATION }) {
        if (StringUtils.isEmpty(getProperty(property))) {
            throw new IllegalArgumentException(String.format("Check configuration file, '%s' is missing", property));
        }
    }
    if (!isSmtpEncryptionOptionValid()) {
        throw new IllegalArgumentException(String.format("Check configuration file, '%s' value has to be one of: '%s', '%s'.", NotificationProperties.MAIL_SMTP_ENCRYPTION, NotificationProperties.MAIL_SMTP_ENCRYPTION_NONE, NotificationProperties.MAIL_SMTP_ENCRYPTION_SSL));
    }
    // try to resolve MAIL_SERVER host
    try {
        InetAddress.getAllByName(getProperty(NotificationProperties.MAIL_SERVER));
    } catch (Exception ex) {
        throw new IllegalArgumentException(String.format("Check configuration file, cannot verify '%s' value", NotificationProperties.MAIL_SERVER), ex);
    }
    // validate email addresses
    for (String property : new String[] { NotificationProperties.MAIL_USER, NotificationProperties.MAIL_FROM, NotificationProperties.MAIL_REPLY_TO }) {
        String candidate = getProperty(property);
        if (!StringUtils.isEmpty(candidate)) {
            try {
                new InternetAddress(candidate);
            } catch (Exception ex) {
                throw new IllegalArgumentException(String.format("Check configuration file, invalid format in '%s'", property), ex);
            }
        }
    }
    // validate mail user value
    String emailUser = getProperty(NotificationProperties.MAIL_USER, true);
    if (StringUtils.isEmpty(emailUser) && (isSmtpEncryptionSsl() || StringUtils.isNotEmpty(getProperty(NotificationProperties.MAIL_PASSWORD, true)))) {
        throw new IllegalArgumentException(String.format("'%s' must be set when SSL is enabled or when password is set", NotificationProperties.MAIL_USER));
    }
}
#method_after
public void validate() {
    // validate mandatory properties
    for (String property : new String[] { NotificationProperties.DAYS_TO_KEEP_HISTORY, NotificationProperties.ENGINE_INTERVAL_IN_SECONDS, NotificationProperties.ENGINE_TIMEOUT_IN_SECONDS, NotificationProperties.INTERVAL_IN_SECONDS, NotificationProperties.IS_HTTPS_PROTOCOL, NotificationProperties.MAIL_PORT, NotificationProperties.MAIL_SERVER, NotificationProperties.REPEAT_NON_RESPONSIVE_NOTIFICATION }) {
        if (StringUtils.isEmpty(getProperty(property))) {
            throw new IllegalArgumentException(String.format("Check configuration file, '%s' is missing", property));
        }
    }
    if (!isSmtpEncryptionOptionValid()) {
        throw new IllegalArgumentException(String.format("Check configuration file, '%s' value has to be one of: '%s', '%s'.", NotificationProperties.MAIL_SMTP_ENCRYPTION, NotificationProperties.MAIL_SMTP_ENCRYPTION_NONE, NotificationProperties.MAIL_SMTP_ENCRYPTION_SSL));
    }
    // try to resolve MAIL_SERVER host
    try {
        InetAddress.getAllByName(getProperty(NotificationProperties.MAIL_SERVER));
    } catch (Exception ex) {
        throw new IllegalArgumentException(String.format("Check configuration file, cannot verify '%s' value", NotificationProperties.MAIL_SERVER), ex);
    }
    // validate email addresses
    for (String property : new String[] { NotificationProperties.MAIL_USER, NotificationProperties.MAIL_FROM, NotificationProperties.MAIL_REPLY_TO }) {
        String candidate = getProperty(property);
        if (!StringUtils.isEmpty(candidate)) {
            try {
                new InternetAddress(candidate);
            } catch (Exception ex) {
                throw new IllegalArgumentException(String.format("Check configuration file, invalid format in '%s'", property), ex);
            }
        }
    }
    // validate mail user value
    String emailUser = getProperty(NotificationProperties.MAIL_USER, true);
    if (StringUtils.isEmpty(emailUser) && (MAIL_SMTP_ENCRYPTION_SSL.equals(getProperty(MAIL_SMTP_ENCRYPTION, true)) || StringUtils.isNotEmpty(getProperty(NotificationProperties.MAIL_PASSWORD, true)))) {
        throw new IllegalArgumentException(String.format("'%s' must be set when SSL is enabled or when password is set", NotificationProperties.MAIL_USER));
    }
}
#end_block

#method_before
public boolean isSmtpEncryptionOptionValid() {
    return isSmtpEncryptionNone() || isSmtpEncryptionSsl();
}
#method_after
public boolean isSmtpEncryptionOptionValid() {
    return MAIL_SMTP_ENCRYPTION_NONE.equals(getProperty(MAIL_SMTP_ENCRYPTION, true)) || MAIL_SMTP_ENCRYPTION_SSL.equals(getProperty(MAIL_SMTP_ENCRYPTION, true));
}
#end_block

#method_before
public static boolean isNetworkInSync(VdsNetworkInterface iface, Network network) {
    return (network.getMtu() == 0 || iface.getMtu() == network.getMtu()) && ObjectUtils.equals(iface.getVlanId(), network.getVlanId()) && iface.isBridged() == network.isVmNetwork();
}
#method_after
public static boolean isNetworkInSync(VdsNetworkInterface iface, Network network) {
    return (network.getMtu() == 0 || iface.getMtu() == network.getMtu()) && Objects.equals(iface.getVlanId(), network.getVlanId()) && iface.isBridged() == network.isVmNetwork();
}
#end_block

#method_before
private void createJobToMonitor(VDSGroup cluster, GlusterAsyncTask task) {
    if (task.getStatus() != JobExecutionStatus.STARTED) {
        // there's no need to monitor jobs that are failed or completed
        return;
    }
    StepEnum step = task.getType().getStep();
    VdcActionType actionType;
    switch(step) {
        case REBALANCING_VOLUME:
            actionType = VdcActionType.StartRebalanceGlusterVolume;
            break;
        case REMOVING_BRICKS:
            actionType = VdcActionType.StartRemoveGlusterVolumeBricks;
            break;
        default:
            actionType = VdcActionType.Unknown;
    }
    Guid jobId = addJob(cluster, task, actionType);
    Guid execStepId = addExecutingStep(jobId);
    Guid asyncStepId = addAsyncTaskStep(cluster, task, step, execStepId);
    Step asyncStep = getStepDao().get(asyncStepId);
    ExecutionHandler.updateStepExternalId(asyncStep, task.getTaskId(), ExternalSystemType.GLUSTER);
    updateVolumeBricksAndLock(cluster, task);
}
#method_after
private void createJobToMonitor(VDSGroup cluster, GlusterAsyncTask task) {
    if (!isTaskToBeMonitored(task)) {
        // there's no need to monitor jobs that are failed or completed
        return;
    }
    StepEnum step = task.getType().getStep();
    VdcActionType actionType;
    switch(step) {
        case REBALANCING_VOLUME:
            actionType = VdcActionType.StartRebalanceGlusterVolume;
            break;
        case REMOVING_BRICKS:
            actionType = VdcActionType.StartRemoveGlusterVolumeBricks;
            break;
        default:
            actionType = VdcActionType.Unknown;
    }
    String volumeName = task.getTaskParameters().getVolumeName();
    GlusterVolumeEntity vol = getVolumeDao().getByName(cluster.getId(), volumeName);
    if (vol == null) {
        log.infoFormat("Volume {0} does not exist yet for task detected from CLI {1}, not adding to engine", volumeName, task);
        return;
    }
    Guid jobId = addJob(cluster, task, actionType, vol);
    Guid execStepId = addExecutingStep(jobId);
    Guid asyncStepId = addAsyncTaskStep(cluster, task, step, execStepId);
    Step asyncStep = getStepDao().get(asyncStepId);
    ExecutionHandler.updateStepExternalId(asyncStep, task.getTaskId(), ExternalSystemType.GLUSTER);
    updateVolumeBricksAndLock(cluster, task, vol);
}
#end_block

#method_before
private Guid addJob(VDSGroup cluster, GlusterAsyncTask task, VdcActionType actionType) {
    VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.AddInternalJob, new AddInternalJobParameters(ExecutionMessageDirector.resolveJobMessage(actionType, getGlusterTaskUtils().getMessageMap(cluster, task)), actionType, true));
    if (!result.getSucceeded()) {
        // log and return
        throw new VdcBLLException(result.getFault().getError());
    }
    Guid jobId = (Guid) result.getActionReturnValue();
    return jobId;
}
#method_after
private Guid addJob(VDSGroup cluster, GlusterAsyncTask task, VdcActionType actionType, final GlusterVolumeEntity vol) {
    VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.AddInternalJob, new AddInternalJobParameters(ExecutionMessageDirector.resolveJobMessage(actionType, getGlusterTaskUtils().getMessageMap(cluster, task)), actionType, true, VdcObjectType.GlusterVolume, vol.getId()));
    if (!result.getSucceeded()) {
        // log and return
        throw new VdcBLLException(result.getFault().getError());
    }
    Guid jobId = (Guid) result.getActionReturnValue();
    return jobId;
}
#end_block

#method_before
private void updateVolumeBricksAndLock(VDSGroup cluster, GlusterAsyncTask task) {
    // get volume associated with task
    String volumeName = task.getTaskParameters().getVolumeName();
    GlusterVolumeEntity vol = getVolumeDao().getByName(cluster.getId(), volumeName);
    if (vol != null) {
        try {
            // acquire lock on volume
            acquireLock(vol.getId());
            // update volume with task id
            getVolumeDao().updateVolumeTask(vol.getId(), task.getTaskId());
            if (GlusterTaskType.REMOVE_BRICK == task.getType()) {
                // update bricks associated with task id
                String[] bricks = task.getTaskParameters().getBricks();
                if (bricks != null) {
                    List<GlusterBrickEntity> brickEntities = new ArrayList<>();
                    for (String brick : bricks) {
                        String[] brickParts = brick.split(":", -1);
                        String hostnameOrIp = brickParts[0];
                        String brickDir = brickParts[1];
                        GlusterBrickEntity brickEntity = new GlusterBrickEntity();
                        VdsStatic server = GlusterDBUtils.getInstance().getServer(cluster.getId(), hostnameOrIp);
                        if (server == null) {
                            log.warnFormat("Could not find server {0} in cluster {1}", hostnameOrIp, cluster.getId());
                        } else {
                            brickEntity.setServerId(server.getId());
                            brickEntity.setBrickDirectory(brickDir);
                            brickEntity.setAsyncTask(new GlusterAsyncTask());
                            brickEntity.getAsyncTask().setTaskId(task.getTaskId());
                            brickEntities.add(brickEntity);
                        }
                    }
                    getBrickDao().updateAllBrickTasksByHostIdBrickDirInBatch(brickEntities);
                }
            }
            logTaskStartedFromCLI(cluster, task, vol);
        } catch (Exception e) {
            log.error(e);
            throw new VdcBLLException(VdcBllErrors.GeneralException, e.getMessage());
        } finally {
            releaseLock(vol.getId());
        }
    } else {
        log.debugFormat("Did not find a volume associated with volumeName {0} and task {1} ", volumeName, task.getTaskId());
    }
}
#method_after
private void updateVolumeBricksAndLock(VDSGroup cluster, GlusterAsyncTask task, final GlusterVolumeEntity vol) {
    try {
        // acquire lock on volume
        acquireLock(vol.getId());
        // update volume with task id
        getVolumeDao().updateVolumeTask(vol.getId(), task.getTaskId());
        if (GlusterTaskType.REMOVE_BRICK == task.getType()) {
            // update bricks associated with task id
            String[] bricks = task.getTaskParameters().getBricks();
            if (bricks != null) {
                List<GlusterBrickEntity> brickEntities = new ArrayList<>();
                for (String brick : bricks) {
                    String[] brickParts = brick.split(":", -1);
                    String hostnameOrIp = brickParts[0];
                    String brickDir = brickParts[1];
                    GlusterBrickEntity brickEntity = new GlusterBrickEntity();
                    VdsStatic server = GlusterDBUtils.getInstance().getServer(cluster.getId(), hostnameOrIp);
                    if (server == null) {
                        log.warnFormat("Could not find server {0} in cluster {1}", hostnameOrIp, cluster.getId());
                    } else {
                        brickEntity.setServerId(server.getId());
                        brickEntity.setBrickDirectory(brickDir);
                        brickEntity.setAsyncTask(new GlusterAsyncTask());
                        brickEntity.getAsyncTask().setTaskId(task.getTaskId());
                        brickEntities.add(brickEntity);
                    }
                }
                getBrickDao().updateAllBrickTasksByHostIdBrickDirInBatch(brickEntities);
            }
        }
        logTaskStartedFromCLI(cluster, task, vol);
    } catch (Exception e) {
        log.error(e);
        throw new VdcBLLException(VdcBllErrors.GeneralException, e.getMessage());
    } finally {
        releaseLock(vol.getId());
    }
}
#end_block

#method_before
private void cleanUpOrphanTasks(Map<Guid, Set<Guid>> runningTasksInClusterMap) {
    // if map is empty, no tasks from clusters fetched. so return
    if (runningTasksInClusterMap.isEmpty()) {
        log.debug("Clean up of tasks has been skipped");
        return;
    }
    // Populate the list of tasks that need to be monitored from database
    List<Guid> taskListInDB = getProvider().getMonitoredTaskIDsInDB();
    if (taskListInDB == null || taskListInDB.isEmpty()) {
        return;
    }
    Set<Guid> allRunningTasksInCluster = new HashSet<>();
    for (Set<Guid> taskSet : runningTasksInClusterMap.values()) {
        if (taskSet != null) {
            allRunningTasksInCluster.addAll(taskSet);
        }
    }
    // if task is in DB but not in running task list
    final Set<Guid> tasksNotRunning = new HashSet<Guid>(taskListInDB);
    tasksNotRunning.removeAll(allRunningTasksInCluster);
    log.debugFormat("tasks to be cleaned up in db {0}", tasksNotRunning);
    for (Guid taskId : tasksNotRunning) {
        GlusterVolumeEntity vol = getVolumeDao().getVolumeByGlusterTask(taskId);
        if (vol != null && vol.getStatus() != GlusterStatus.UP && !runningTasksInClusterMap.keySet().contains((vol.getClusterId()))) {
            // contain the cluster id in such case
            continue;
        }
        // Volume is up, but gluster does not know of task
        // will mark job ended with status unknown.
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        for (Step step : steps) {
            step.markStepEnded(JobExecutionStatus.UNKNOWN);
            step.setStatus(JobExecutionStatus.UNKNOWN);
            Map<String, String> values = new HashMap<String, String>();
            values.put(GlusterConstants.CLUSTER, vol == null ? "" : vol.getVdsGroupName());
            values.put(GlusterConstants.VOLUME, vol == null ? "" : vol.getName());
            values.put(GlusterConstants.JOB_STATUS, JobExecutionStatus.UNKNOWN.toString());
            values.put(GlusterConstants.JOB_INFO, " ");
            step.setDescription(ExecutionMessageDirector.resolveStepMessage(step.getStepType(), values));
            getGlusterTaskUtils().endStepJob(step);
            if (vol != null) {
                logTaskStoppedFromCLI(step, vol);
            }
        }
        getGlusterTaskUtils().releaseVolumeLock(taskId);
    }
}
#method_after
private void cleanUpOrphanTasks(Map<Guid, Set<Guid>> runningTasksInClusterMap) {
    // if map is empty, no tasks from clusters fetched. so return
    if (runningTasksInClusterMap.isEmpty()) {
        log.debug("Clean up of tasks has been skipped");
        return;
    }
    // Populate the list of tasks that need to be monitored from database
    List<Guid> taskListInDB = getProvider().getMonitoredTaskIDsInDB();
    if (taskListInDB == null || taskListInDB.isEmpty()) {
        return;
    }
    Set<Guid> allRunningTasksInCluster = new HashSet<>();
    for (Set<Guid> taskSet : runningTasksInClusterMap.values()) {
        if (taskSet != null) {
            allRunningTasksInCluster.addAll(taskSet);
        }
    }
    // if task is in DB but not in running task list
    final Set<Guid> tasksNotRunning = new HashSet<Guid>(taskListInDB);
    tasksNotRunning.removeAll(allRunningTasksInCluster);
    log.debugFormat("tasks to be cleaned up in db {0}", tasksNotRunning);
    for (Guid taskId : tasksNotRunning) {
        GlusterVolumeEntity vol = getVolumeDao().getVolumeByGlusterTask(taskId);
        if (vol != null && vol.getStatus() != GlusterStatus.UP && !runningTasksInClusterMap.keySet().contains((vol.getClusterId()))) {
            // contain the cluster id in such case
            continue;
        }
        // Volume is up, but gluster does not know of task
        // will mark job ended with status unknown.
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        Map<String, String> values = new HashMap<String, String>();
        values.put(GlusterConstants.CLUSTER, vol == null ? "" : vol.getVdsGroupName());
        values.put(GlusterConstants.VOLUME, vol == null ? "" : vol.getName());
        values.put(GlusterConstants.JOB_STATUS, JobExecutionStatus.UNKNOWN.toString());
        values.put(GlusterConstants.JOB_INFO, " ");
        for (Step step : steps) {
            step.markStepEnded(JobExecutionStatus.UNKNOWN);
            step.setStatus(JobExecutionStatus.UNKNOWN);
            step.setDescription(ExecutionMessageDirector.resolveStepMessage(step.getStepType(), values));
            getGlusterTaskUtils().endStepJob(step);
            if (vol != null) {
                logTaskStoppedFromCLI(step, vol);
            }
        }
        getGlusterTaskUtils().releaseVolumeLock(taskId);
    }
}
#end_block

#method_before
protected void addStyles() {
    volumeTypeEditor.addContentWidgetStyleName(style.editorContentWidget());
    replicaCountEditor.addContentWidgetStyleName(style.editorContentWidget());
    stripeCountEditor.addContentWidgetStyleName(style.editorContentWidget());
}
#method_after
protected void addStyles() {
    volumeTypeEditor.addContentWidgetStyleName(style.editorContentWidget());
    replicaCountEditor.addContentWidgetStyleName(style.editorContentWidget());
    stripeCountEditor.addContentWidgetStyleName(style.editorContentWidget());
    forceEditor.addContentWidgetStyleName(style.forceEditorWidget());
}
#end_block

#method_before
private void initButtons() {
    addBrickButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            addBrickButton.getCommand().execute();
            clearSelections();
        }
    });
    removeBricksButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            removeBricksButton.getCommand().execute();
            clearSelections();
        }
    });
    removeAllBricksButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            removeAllBricksButton.getCommand().execute();
            clearSelections();
        }
    });
    moveBricksUpButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            moveBricksUpButton.getCommand().execute();
        }
    });
    moveBricksDownButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            moveBricksDownButton.getCommand().execute();
        }
    });
}
#method_after
private void initButtons() {
    addBrickButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            addBrickButton.getCommand().execute();
            clearSelections();
        }
    });
    removeBricksButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            removeBricksButton.getCommand().execute();
            clearSelections();
            bricksTable.flush();
            bricksTable.redraw();
        }
    });
    removeAllBricksButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            removeAllBricksButton.getCommand().execute();
            clearSelections();
            bricksTable.flush();
            bricksTable.redraw();
        }
    });
    moveBricksUpButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            moveBricksUpButton.getCommand().execute();
        }
    });
    moveBricksDownButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            moveBricksDownButton.getCommand().execute();
        }
    });
}
#end_block

#method_before
@Override
public void edit(final VolumeBrickModel object) {
    bricksTable.asEditor().edit(object.getBricks());
    driver.edit(object);
    addBrickButton.setCommand(object.getAddBrickCommand());
    removeBricksButton.setCommand(object.getRemoveBricksCommand());
    removeAllBricksButton.setCommand(object.getRemoveAllBricksCommand());
    moveBricksUpButton.setCommand(object.getMoveBricksUpCommand());
    moveBricksDownButton.setCommand(object.getMoveBricksDownCommand());
    GlusterVolumeType volumeType = (GlusterVolumeType) object.getVolumeType().getEntity();
    if (volumeType == GlusterVolumeType.DISTRIBUTED_REPLICATE) {
        infoLabel.setText(constants.distributedReplicateVolumeBrickInfoLabel());
    } else if (volumeType == GlusterVolumeType.DISTRIBUTED_STRIPE) {
        infoLabel.setText(constants.distributedStripeVolumeBrickInfoLabel());
    } else {
        infoLabel.setText(null);
    }
    forceWarningLabel.setVisible(false);
    object.getForce().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            forceWarningLabel.setVisible(object.getForce().getEntity());
        }
    });
}
#method_after
@Override
public void edit(final VolumeBrickModel object) {
    bricksTable.asEditor().edit(object.getBricks());
    driver.edit(object);
    addBrickButton.setCommand(object.getAddBrickCommand());
    removeBricksButton.setCommand(object.getRemoveBricksCommand());
    removeAllBricksButton.setCommand(object.getRemoveAllBricksCommand());
    moveBricksUpButton.setCommand(object.getMoveBricksUpCommand());
    moveBricksDownButton.setCommand(object.getMoveBricksDownCommand());
    GlusterVolumeType volumeType = (GlusterVolumeType) object.getVolumeType().getEntity();
    if (volumeType == GlusterVolumeType.DISTRIBUTED_REPLICATE) {
        infoLabel.setText(constants.distributedReplicateVolumeBrickInfoLabel());
    } else if (volumeType == GlusterVolumeType.DISTRIBUTED_STRIPE) {
        infoLabel.setText(constants.distributedStripeVolumeBrickInfoLabel());
    } else {
        infoLabel.setText(null);
    }
    forceWarningLabel.setVisible((Boolean) object.getForce().getEntity());
    object.getForce().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            forceWarningLabel.setVisible((Boolean) object.getForce().getEntity());
        }
    });
}
#end_block

#method_before
@Override
protected void onEntityChanged() {
    super.onEntityChanged();
    if (getEntity() != null) {
        GlusterVolumeEntity glusterVolumeEntity = (GlusterVolumeEntity) getEntity();
        setItems(glusterVolumeEntity.getBricks());
    } else {
        setItems(null);
    }
}
#method_after
@Override
protected void onEntityChanged() {
    super.onEntityChanged();
    getSearchCommand().execute();
}
#end_block

#method_before
private void onAddBricksInternal() {
    cancelConfirmation();
    VolumeBrickModel volumeBrickModel = (VolumeBrickModel) getWindow();
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    ArrayList<GlusterBrickEntity> brickList = new ArrayList<GlusterBrickEntity>();
    for (Object model : volumeBrickModel.getBricks().getItems()) {
        GlusterBrickEntity brickEntity = (GlusterBrickEntity) ((EntityModel) model).getEntity();
        brickEntity.setVolumeId(volumeEntity.getId());
        brickList.add(brickEntity);
    }
    volumeBrickModel.startProgress(null);
    GlusterVolumeBricksActionParameters parameter = new GlusterVolumeBricksActionParameters(volumeEntity.getId(), brickList, volumeBrickModel.getReplicaCountValue(), volumeBrickModel.getStripeCountValue(), volumeBrickModel.getForce().getEntity());
    Frontend.RunAction(VdcActionType.AddBricksToGlusterVolume, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VolumeBrickListModel localModel = (VolumeBrickListModel) result.getState();
            localModel.postOnAddBricks(result.getReturnValue());
        }
    }, this);
}
#method_after
private void onAddBricksInternal() {
    cancelConfirmation();
    VolumeBrickModel volumeBrickModel = (VolumeBrickModel) getWindow();
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    ArrayList<GlusterBrickEntity> brickList = new ArrayList<GlusterBrickEntity>();
    for (Object model : volumeBrickModel.getBricks().getItems()) {
        GlusterBrickEntity brickEntity = (GlusterBrickEntity) ((EntityModel) model).getEntity();
        brickEntity.setVolumeId(volumeEntity.getId());
        brickList.add(brickEntity);
    }
    volumeBrickModel.startProgress(null);
    GlusterVolumeBricksActionParameters parameter = new GlusterVolumeBricksActionParameters(volumeEntity.getId(), brickList, volumeBrickModel.getReplicaCountValue(), volumeBrickModel.getStripeCountValue(), (Boolean) volumeBrickModel.getForce().getEntity());
    Frontend.getInstance().runAction(VdcActionType.AddBricksToGlusterVolume, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VolumeBrickListModel localModel = (VolumeBrickListModel) result.getState();
            localModel.postOnAddBricks(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
private void removeBricks() {
    if (getSelectedItems() == null || getSelectedItems().isEmpty()) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    RemoveBrickModel removeBrickModel = new RemoveBrickModel();
    // $NON-NLS-1$
    removeBrickModel.setHashName("volume_remove_bricks");
    removeBrickModel.setTitle(ConstantsManager.getInstance().getConstants().removeBricksTitle());
    setWindow(removeBrickModel);
    removeBrickModel.setReplicaCount(volumeEntity.getReplicaCount());
    removeBrickModel.setStripeCount(volumeEntity.getStripeCount());
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity item : Linq.<GlusterBrickEntity>cast(getSelectedItems())) {
        list.add(item.getQualifiedName());
    }
    removeBrickModel.setItems(list);
    if (!validateRemoveBricks(volumeEntity.getVolumeType(), Linq.<GlusterBrickEntity>cast(getSelectedItems()), volumeEntity.getBricks(), removeBrickModel)) {
        removeBrickModel.setMigrationSupported(false);
        removeBrickModel.setMessage(removeBrickModel.getValidationMessage());
    } else {
        removeBrickModel.setMigrationSupported(volumeEntity.getVolumeType().isDistributedType());
        removeBrickModel.getMigrateData().setEntity(removeBrickModel.isMigrationSupported());
        if (removeBrickModel.isReduceReplica()) {
            removeBrickModel.setMessage(ConstantsManager.getInstance().getMessages().removeBricksReplicateVolumeMessage(volumeEntity.getReplicaCount(), volumeEntity.getReplicaCount() - 1));
        } else {
            removeBrickModel.setMessage(ConstantsManager.getInstance().getConstants().removeBricksMessage());
        }
        // $NON-NLS-1$
        UICommand command = new UICommand("OnRemove", this);
        command.setTitle(ConstantsManager.getInstance().getConstants().ok());
        command.setIsDefault(true);
        removeBrickModel.getCommands().add(command);
    }
    // $NON-NLS-1$
    UICommand command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    removeBrickModel.getCommands().add(command);
}
#method_after
private void removeBricks() {
    if (getSelectedItems() == null || getSelectedItems().isEmpty()) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    RemoveBrickModel removeBrickModel = new RemoveBrickModel();
    // $NON-NLS-1$
    removeBrickModel.setHashName("volume_remove_bricks");
    removeBrickModel.setTitle(ConstantsManager.getInstance().getConstants().removeBricksTitle());
    setWindow(removeBrickModel);
    removeBrickModel.setReplicaCount(volumeEntity.getReplicaCount());
    removeBrickModel.setStripeCount(volumeEntity.getStripeCount());
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity item : Linq.<GlusterBrickEntity>cast(getSelectedItems())) {
        list.add(item.getQualifiedName());
    }
    removeBrickModel.setItems(list);
    if (!validateRemoveBricks(volumeEntity.getVolumeType(), Linq.<GlusterBrickEntity>cast(getSelectedItems()), volumeEntity.getBricks(), removeBrickModel)) {
        removeBrickModel.setMigrationSupported(false);
        removeBrickModel.setMessage(removeBrickModel.getValidationMessage());
    } else {
        removeBrickModel.setMigrationSupported(volumeEntity.getVolumeType().isDistributedType());
        removeBrickModel.getMigrateData().setEntity(removeBrickModel.isMigrationSupported());
        if (removeBrickModel.isReduceReplica()) {
            removeBrickModel.setMessage(ConstantsManager.getInstance().getMessages().removeBricksReplicateVolumeMessage(volumeEntity.getReplicaCount(), volumeEntity.getReplicaCount() - 1));
            removeBrickModel.setMigrationSupported(false);
            removeBrickModel.getMigrateData().setEntity(false);
        } else {
            removeBrickModel.setMessage(ConstantsManager.getInstance().getConstants().removeBricksMessage());
        }
        // $NON-NLS-1$
        UICommand command = new UICommand("OnRemove", this);
        command.setTitle(ConstantsManager.getInstance().getConstants().ok());
        command.setIsDefault(true);
        removeBrickModel.getCommands().add(command);
    }
    // $NON-NLS-1$
    UICommand command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    removeBrickModel.getCommands().add(command);
}
#end_block

#method_before
public boolean validateDistriputedReplicateRemove(GlusterVolumeType volumeType, List<GlusterBrickEntity> selectedBricks, List<GlusterBrickEntity> brickList, RemoveBrickModel removeBrickModel) {
    int replicaCount = removeBrickModel.getReplicaCount();
    int distributions = brickList.size() / replicaCount;
    if (selectedBricks.size() != replicaCount && selectedBricks.size() != distributions) {
        return false;
    }
    for (int i = 0; i < distributions; i++) {
        List<GlusterBrickEntity> subBrickList = brickList.subList((i * replicaCount), (i * replicaCount) + replicaCount);
        if (subBrickList.containsAll(selectedBricks)) {
            return true;
        }
        int count = 0;
        for (GlusterBrickEntity brick : selectedBricks) {
            if (subBrickList.contains(brick)) {
                count++;
            }
        }
        if (count == 1 && i == (distributions - 1)) {
            removeBrickModel.setReplicaCount(removeBrickModel.getReplicaCount() - 1);
            removeBrickModel.setReduceReplica(true);
            return true;
        } else if (count > 1) {
            return false;
        }
    }
    return false;
}
#method_after
public boolean validateDistriputedReplicateRemove(GlusterVolumeType volumeType, List<GlusterBrickEntity> selectedBricks, List<GlusterBrickEntity> brickList, RemoveBrickModel removeBrickModel) {
    int replicaCount = removeBrickModel.getReplicaCount();
    int distributions = brickList.size() / replicaCount;
    // Key - No.of.bricks selected in sub-volume
    // Value - No.of sub-volumes which has 'Key' no.of bricks selected
    Map<Integer, Integer> selectedBricksToSubVolumesMap = new HashMap<Integer, Integer>();
    for (int distIndex = 0; distIndex < distributions; distIndex++) {
        List<GlusterBrickEntity> bricksInSubVolumeList = brickList.subList((distIndex * replicaCount), (distIndex * replicaCount) + replicaCount);
        int selectedBricksInSubVolume = 0;
        for (GlusterBrickEntity brick : bricksInSubVolumeList) {
            if (selectedBricks.contains(brick)) {
                selectedBricksInSubVolume++;
            }
        }
        if (selectedBricksInSubVolume > 0) {
            if (!selectedBricksToSubVolumesMap.containsKey(selectedBricksInSubVolume)) {
                selectedBricksToSubVolumesMap.put(selectedBricksInSubVolume, 0);
            }
            selectedBricksToSubVolumesMap.put(selectedBricksInSubVolume, selectedBricksToSubVolumesMap.get(selectedBricksInSubVolume) + 1);
        }
    }
    // sub-volumes, hence not valid for removal.
    if (selectedBricksToSubVolumesMap.size() == 1) {
        // If the user has selected once brick from each sub-volume, then replica count needs to be reduced
        if (selectedBricksToSubVolumesMap.containsKey(1) && selectedBricksToSubVolumesMap.get(1) == distributions) {
            removeBrickModel.setReplicaCount(removeBrickModel.getReplicaCount() - 1);
            removeBrickModel.setReduceReplica(true);
            return true;
        } else if (selectedBricksToSubVolumesMap.containsKey(replicaCount)) {
            return true;
        }
        return false;
    }
    return false;
}
#end_block

#method_before
private void onRemoveBricks() {
    if (getWindow() == null) {
        return;
    }
    RemoveBrickModel model = (RemoveBrickModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (getSelectedItems() == null || getSelectedItems().isEmpty()) {
        return;
    }
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), getSelectedItems());
    if (volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE) {
        parameter.setReplicaCount(volumeEntity.getReplicaCount() - 1);
    } else if (volumeEntity.getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) {
        if (model.isReduceReplica()) {
            parameter.setReplicaCount(volumeEntity.getReplicaCount() - 1);
        } else {
            parameter.setReplicaCount(volumeEntity.getReplicaCount());
        }
    }
    model.startProgress(null);
    boolean isMigrate = (Boolean) model.getMigrateData().getEntity();
    Frontend.RunAction(isMigrate ? VdcActionType.StartRemoveGlusterVolumeBricks : VdcActionType.GlusterVolumeRemoveBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setWindow(null);
        }
    }, model);
}
#method_after
private void onRemoveBricks() {
    if (getWindow() == null) {
        return;
    }
    RemoveBrickModel model = (RemoveBrickModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (getSelectedItems() == null || getSelectedItems().isEmpty()) {
        return;
    }
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), getSelectedItems());
    if (volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE) {
        parameter.setReplicaCount(volumeEntity.getReplicaCount() - 1);
    } else if (volumeEntity.getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) {
        if (model.isReduceReplica()) {
            parameter.setReplicaCount(volumeEntity.getReplicaCount() - 1);
        } else {
            parameter.setReplicaCount(volumeEntity.getReplicaCount());
        }
    }
    model.startProgress(null);
    boolean isMigrate = (Boolean) model.getMigrateData().getEntity();
    Frontend.getInstance().runAction(isMigrate ? VdcActionType.StartRemoveGlusterVolumeBricks : VdcActionType.GlusterVolumeRemoveBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setWindow(null);
        }
    }, model);
}
#end_block

#method_before
private void onStopRemoveBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<GlusterBrickEntity>();
    for (Object brickName : model.getItems()) {
        GlusterBrickEntity brick = volumeEntity.getBrickWithQualifiedName((String) brickName);
        if (brick != null) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress(null);
    Frontend.RunAction(VdcActionType.StopRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
            if (result.getReturnValue().getSucceeded()) {
                showRemoveBricksStatus();
            }
        }
    }, model);
}
#method_after
private void onStopRemoveBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<GlusterBrickEntity>();
    for (Object brickName : model.getItems()) {
        GlusterBrickEntity brick = volumeEntity.getBrickWithQualifiedName((String) brickName);
        if (brick != null) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.StopRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
            if (result.getReturnValue().getSucceeded()) {
                showRemoveBricksStatus();
            }
        }
    }, model);
}
#end_block

#method_before
private void onCommitRemoveBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<GlusterBrickEntity>();
    for (Object brickName : model.getItems()) {
        GlusterBrickEntity brick = volumeEntity.getBrickWithQualifiedName((String) brickName);
        if (brick != null) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress(null);
    Frontend.RunAction(VdcActionType.CommitRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
        }
    }, model);
}
#method_after
private void onCommitRemoveBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<GlusterBrickEntity>();
    for (Object brickName : model.getItems()) {
        GlusterBrickEntity brick = volumeEntity.getBrickWithQualifiedName((String) brickName);
        if (brick != null) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.CommitRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
            if (result.getReturnValue().getSucceeded()) {
                disableRemoveBrickStatusPopUpActions();
            }
        }
    }, model);
}
#end_block

#method_before
private void showRemoveBricksStatus() {
    if (getWindow() != null) {
        return;
    }
    final GlusterVolumeEntity volumeEntity = getVolumeEntity();
    ArrayList<GlusterBrickEntity> bricks = new ArrayList<GlusterBrickEntity>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null) {
            bricks.add(brick);
        }
    }
    final RemoveBrickStatusModel removeBrickStatusModel = new RemoveBrickStatusModel(volumeEntity, bricks);
    removeBrickStatusModel.setTitle(ConstantsManager.getInstance().getConstants().removeBricksStatusTitle());
    // //$NON-NLS-1$
    removeBrickStatusModel.setHashName("remove_bricks_status");
    setWindow(removeBrickStatusModel);
    removeBrickStatusModel.startProgress(null);
    removeBrickStatusModel.getVolume().setEntity(volumeEntity.getName());
    removeBrickStatusModel.getCluster().setEntity(volumeEntity.getVdsGroupName());
    // $NON-NLS-1$
    UICommand stopRemoveBrickFromStatus = new UICommand("StopRemoveBricksOnStatus", this);
    stopRemoveBrickFromStatus.setTitle(ConstantsManager.getInstance().getConstants().stopRemoveBricksButton());
    stopRemoveBrickFromStatus.setIsExecutionAllowed(false);
    removeBrickStatusModel.addStopRemoveBricksCommand(stopRemoveBrickFromStatus);
    // $NON-NLS-1$
    UICommand commitRemoveBrickFromStatus = new UICommand("CommitRemoveBricksOnStatus", this);
    commitRemoveBrickFromStatus.setTitle(ConstantsManager.getInstance().getConstants().commitRemoveBricksButton());
    commitRemoveBrickFromStatus.setIsExecutionAllowed(false);
    removeBrickStatusModel.addCommitRemoveBricksCommand(commitRemoveBrickFromStatus);
    // $NON-NLS-1$
    UICommand retainBricksFromStatus = new UICommand("RetainBricksOnStatus", this);
    retainBricksFromStatus.setTitle(ConstantsManager.getInstance().getConstants().retainBricksButton());
    retainBricksFromStatus.setIsExecutionAllowed(false);
    removeBrickStatusModel.addRetainBricksCommand(retainBricksFromStatus);
    AsyncDataProvider.getGlusterRemoveBricksStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            removeBrickStatusModel.stopProgress();
            GlusterVolumeTaskStatusEntity removeBrickStatusEntity = (GlusterVolumeTaskStatusEntity) returnValue;
            removeBrickStatusModel.showStatus(removeBrickStatusEntity);
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId(), bricks);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelRemoveBricksStatus", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    removeBrickStatusModel.getCommands().add(cancelCommand);
}
#method_after
private void showRemoveBricksStatus() {
    final GlusterVolumeEntity volumeEntity = getVolumeEntity();
    final ArrayList<GlusterBrickEntity> bricks = new ArrayList<GlusterBrickEntity>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null) {
            bricks.add(brick);
        }
    }
    final ConfirmationModel cModel = new ConfirmationModel();
    // $NON-NLS-1$
    UICommand removeBrickStatusOk = new UICommand("CancelConfirmation", VolumeBrickListModel.this);
    removeBrickStatusOk.setTitle(ConstantsManager.getInstance().getConstants().ok());
    removeBrickStatusOk.setIsCancel(true);
    cModel.startProgress(ConstantsManager.getInstance().getConstants().rebalanceStatusFetchMessage());
    cModel.getCommands().add(removeBrickStatusOk);
    cModel.setTitle(ConstantsManager.getInstance().getConstants().removeBricksStatusTitle());
    setConfirmWindow(cModel);
    // $NON-NLS-1$
    final UICommand stopRemoveBrickFromStatus = new UICommand("StopRemoveBricksOnStatus", this);
    stopRemoveBrickFromStatus.setTitle(ConstantsManager.getInstance().getConstants().stopRemoveBricksButton());
    stopRemoveBrickFromStatus.setIsExecutionAllowed(false);
    // $NON-NLS-1$
    final UICommand commitRemoveBrickFromStatus = new UICommand("CommitRemoveBricksOnStatus", this);
    commitRemoveBrickFromStatus.setTitle(ConstantsManager.getInstance().getConstants().commitRemoveBricksButton());
    commitRemoveBrickFromStatus.setIsExecutionAllowed(false);
    // $NON-NLS-1$
    final UICommand retainBricksFromStatus = new UICommand("RetainBricksOnStatus", this);
    retainBricksFromStatus.setTitle(ConstantsManager.getInstance().getConstants().retainBricksButton());
    retainBricksFromStatus.setIsExecutionAllowed(false);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("CancelRemoveBricksStatus", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    AsyncDataProvider.getGlusterRemoveBricksStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            cModel.stopProgress();
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            if (vdcValue.getSucceeded() && vdcValue.getReturnValue() != null) {
                cancelConfirmation();
                RemoveBrickStatusModel removeBrickStatusModel;
                GlusterVolumeTaskStatusEntity removeBrickStatusEntity = vdcValue.getReturnValue();
                if (getWindow() == null) {
                    removeBrickStatusModel = new RemoveBrickStatusModel(volumeEntity, bricks);
                    removeBrickStatusModel.setTitle(ConstantsManager.getInstance().getConstants().removeBricksStatusTitle());
                    // //$NON-NLS-1$
                    removeBrickStatusModel.setHashName("remove_bricks_status");
                    setWindow(removeBrickStatusModel);
                    removeBrickStatusModel.getVolume().setEntity(volumeEntity.getName());
                    removeBrickStatusModel.getCluster().setEntity(volumeEntity.getVdsGroupName());
                    removeBrickStatusModel.addStopRemoveBricksCommand(stopRemoveBrickFromStatus);
                    removeBrickStatusModel.addCommitRemoveBricksCommand(commitRemoveBrickFromStatus);
                    removeBrickStatusModel.addRetainBricksCommand(retainBricksFromStatus);
                    removeBrickStatusModel.getCommands().add(cancelCommand);
                } else {
                    removeBrickStatusModel = (RemoveBrickStatusModel) getWindow();
                }
                removeBrickStatusModel.showStatus(removeBrickStatusEntity);
            } else {
                cModel.setMessage(ConstantsManager.getInstance().getMessages().removeBrickStatusFailed(volumeEntity.getName()));
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId(), bricks);
}
#end_block

#method_before
private void onRetainBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<GlusterBrickEntity>();
    for (Object brickName : model.getItems()) {
        GlusterBrickEntity brick = volumeEntity.getBrickWithQualifiedName((String) brickName);
        if (brick != null) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress(null);
    Frontend.RunAction(VdcActionType.StopRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
        }
    }, model);
}
#method_after
private void onRetainBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<GlusterBrickEntity>();
    for (Object brickName : model.getItems()) {
        GlusterBrickEntity brick = volumeEntity.getBrickWithQualifiedName((String) brickName);
        if (brick != null) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.StopRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
            if (result.getReturnValue().getSucceeded()) {
                showRemoveBricksStatus();
                disableRemoveBrickStatusPopUpActions();
            }
        }
    }, model);
}
#end_block

#method_before
private void onReplaceBrick() {
    ReplaceBrickModel replaceBrickModel = (ReplaceBrickModel) getWindow();
    if (replaceBrickModel == null) {
        return;
    }
    if (!replaceBrickModel.validate()) {
        return;
    }
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    if (volumeEntity == null) {
        return;
    }
    GlusterBrickEntity existingBrick = (GlusterBrickEntity) getSelectedItem();
    if (existingBrick == null) {
        return;
    }
    VDS server = (VDS) replaceBrickModel.getServers().getSelectedItem();
    GlusterBrickEntity newBrick = new GlusterBrickEntity();
    newBrick.setVolumeId(volumeEntity.getId());
    newBrick.setServerId(server.getId());
    newBrick.setServerName(server.getHostName());
    newBrick.setBrickDirectory((String) replaceBrickModel.getBrickDirectory().getEntity());
    replaceBrickModel.startProgress(null);
    GlusterVolumeReplaceBrickActionParameters parameter = new GlusterVolumeReplaceBrickActionParameters(volumeEntity.getId(), GlusterTaskOperation.START, existingBrick, newBrick, false);
    Frontend.RunAction(VdcActionType.ReplaceGlusterVolumeBrick, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ReplaceBrickModel localModel = (ReplaceBrickModel) result.getState();
            localModel.stopProgress();
            setWindow(null);
        }
    }, replaceBrickModel);
}
#method_after
private void onReplaceBrick() {
    ReplaceBrickModel replaceBrickModel = (ReplaceBrickModel) getWindow();
    if (replaceBrickModel == null) {
        return;
    }
    if (!replaceBrickModel.validate()) {
        return;
    }
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    if (volumeEntity == null) {
        return;
    }
    GlusterBrickEntity existingBrick = (GlusterBrickEntity) getSelectedItem();
    if (existingBrick == null) {
        return;
    }
    VDS server = (VDS) replaceBrickModel.getServers().getSelectedItem();
    GlusterBrickEntity newBrick = new GlusterBrickEntity();
    newBrick.setVolumeId(volumeEntity.getId());
    newBrick.setServerId(server.getId());
    newBrick.setServerName(server.getHostName());
    newBrick.setBrickDirectory((String) replaceBrickModel.getBrickDirectory().getEntity());
    replaceBrickModel.startProgress(null);
    GlusterVolumeReplaceBrickActionParameters parameter = new GlusterVolumeReplaceBrickActionParameters(volumeEntity.getId(), GlusterTaskOperation.START, existingBrick, newBrick, false);
    Frontend.getInstance().runAction(VdcActionType.ReplaceGlusterVolumeBrick, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ReplaceBrickModel localModel = (ReplaceBrickModel) result.getState();
            localModel.stopProgress();
            setWindow(null);
        }
    }, replaceBrickModel);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getAddBricksCommand())) {
        checkUpServerAndAddBricks();
    } else if (command.getName().equals("OnAddBricks")) {
        // $NON-NLS-1$
        onAddBricks();
    } else if (command.getName().equals("OnAddBricksInternal")) {
        // $NON-NLS-1$
        onAddBricksInternal();
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        cancelConfirmation();
    } else if (command.equals(getRemoveBricksCommand())) {
        removeBricks();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveBricks();
    } else if (command.equals(getStopRemoveBricksCommand())) {
        stopRemoveBricks();
    } else if (command.getName().equals("OnStopRemoveBricks")) {
        // $NON-NLS-1$
        onStopRemoveBricks();
    } else if (command.equals(getCommitRemoveBricksCommand())) {
        commitRemoveBricks();
    } else if (command.getName().equals("OnCommitRemoveBricks")) {
        // $NON-NLS-1$
        onCommitRemoveBricks();
    } else if (command.equals(getStatusRemoveBricksCommand())) {
        showRemoveBricksStatus();
    } else if (command.getName().equals("StopRemoveBricksOnStatus")) {
        // $NON-NLS-1$
        getStopRemoveBricksCommand().execute();
    } else if (command.getName().equals("CommitRemoveBricksOnStatus")) {
        // $NON-NLS-1$
        getCommitRemoveBricksCommand().execute();
    } else if (command.getName().equals("CancelRemoveBricksStatus")) {
        // $NON-NLS-1$
        cancelRemoveBrickStatus();
    } else if (command.equals(getRetainBricksCommand())) {
        retainBricks();
    } else if (command.getName().equals("OnRetainBricks")) {
        // $NON-NLS-1$
        onRetainBricks();
    } else if (command.getName().equals("RetainBricksOnStatus")) {
        // $NON-NLS-1$
        getRetainBricksCommand().execute();
    } else if (command.equals(getReplaceBrickCommand())) {
        replaceBrick();
    } else if (command.getName().equals("OnReplace")) {
        // $NON-NLS-1$
        onReplaceBrick();
    } else if (command.equals(getBrickAdvancedDetailsCommand())) {
        showBrickAdvancedDetails();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getAddBricksCommand())) {
        checkUpServerAndAddBricks();
    } else if (command.getName().equals("OnAddBricks")) {
        // $NON-NLS-1$
        onAddBricks();
    } else if (command.getName().equals("OnAddBricksInternal")) {
        // $NON-NLS-1$
        onAddBricksInternal();
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        cancelConfirmation();
    } else if (command.equals(getRemoveBricksCommand())) {
        removeBricks();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveBricks();
    } else if (command.equals(getStopRemoveBricksCommand())) {
        stopRemoveBricks();
    } else if (command.getName().equals("OnStopRemoveBricks")) {
        // $NON-NLS-1$
        onStopRemoveBricks();
    } else if (command.equals(getCommitRemoveBricksCommand())) {
        commitRemoveBricks();
    } else if (command.getName().equals("OnCommitRemoveBricks")) {
        // $NON-NLS-1$
        onCommitRemoveBricks();
    } else if (command.equals(getStatusRemoveBricksCommand())) {
        showRemoveBricksStatus();
    } else if (command.getName().equals("StopRemoveBricksOnStatus")) {
        // $NON-NLS-1$
        getStopRemoveBricksCommand().execute();
    } else if (command.getName().equals("CommitRemoveBricksOnStatus")) {
        // $NON-NLS-1$
        getCommitRemoveBricksCommand().execute();
    } else if (command.getName().equals("CancelRemoveBricksStatus")) {
        // $NON-NLS-1$
        cancelRemoveBrickStatus();
    } else if (command.equals(getRetainBricksCommand())) {
        retainBricks();
    } else if (command.getName().equals("OnRetainBricks")) {
        // $NON-NLS-1$
        onRetainBricks();
    } else if (command.getName().equals("RetainBricksOnStatus")) {
        // $NON-NLS-1$
        getRetainBricksCommand().execute();
    } else if (command.equals(getReplaceBrickCommand())) {
        replaceBrick();
    } else if (command.getName().equals("OnReplace")) {
        // $NON-NLS-1$
        onReplaceBrick();
    } else if (command.equals(getBrickAdvancedDetailsCommand())) {
        showBrickAdvancedDetails();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#end_block

#method_before
private void onRemoveVolume() {
    if (getWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        GlusterVolumeEntity volume = (GlusterVolumeEntity) item;
        list.add(new GlusterVolumeActionParameters(volume.getId(), false));
    }
    model.startProgress(null);
    Frontend.RunMultipleAction(VdcActionType.DeleteGlusterVolume, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onRemoveVolume() {
    if (getWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        GlusterVolumeEntity volume = (GlusterVolumeEntity) item;
        list.add(new GlusterVolumeActionParameters(volume.getId(), false));
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.DeleteGlusterVolume, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(getSearchString(), SearchType.GlusterVolume);
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#method_after
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(getSearchString(), SearchType.GlusterVolume, isCaseSensitiveSearch());
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#end_block

#method_before
private void updateActionAvailability() {
    boolean allowStart = true;
    boolean allowStop = true;
    boolean allowRemove = true;
    boolean allowStartRebalance = true;
    boolean allowStopRebalance = true;
    boolean allowStatusRebalance = true;
    boolean allowOptimize = true;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowStart = false;
        allowStop = false;
        allowRemove = false;
        allowStartRebalance = false;
        allowStopRebalance = false;
        allowStatusRebalance = false;
        allowOptimize = false;
    } else {
        List<GlusterVolumeEntity> list = Linq.<GlusterVolumeEntity>cast(getSelectedItems());
        for (GlusterVolumeEntity volume : list) {
            if (volume.getStatus() == GlusterStatus.UP) {
                allowStart = false;
                allowRemove = false;
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                allowStop = false;
                allowStartRebalance = false;
            }
            GlusterAsyncTask asyncTask = volume.getAsyncTask();
            if (asyncTask != null) {
                allowStartRebalance = allowStartRebalance && asyncTask.getStatus() != JobExecutionStatus.STARTED;
            }
        }
        if (list.size() == 1) {
            GlusterVolumeEntity volumeEntity = list.get(0);
            GlusterAsyncTask asyncTask = volumeEntity.getAsyncTask();
            allowStopRebalance = volumeEntity.getStatus() == GlusterStatus.UP && asyncTask != null && asyncTask.getType() == GlusterTaskType.REBALANCE && asyncTask.getStatus() == JobExecutionStatus.STARTED;
        } else {
            allowStopRebalance = false;
        }
        allowStatusRebalance = getRebalanceStatusAvailability(getSelectedItems());
    }
    getStartCommand().setIsExecutionAllowed(allowStart);
    getStopCommand().setIsExecutionAllowed(allowStop);
    getRemoveVolumeCommand().setIsExecutionAllowed(allowRemove);
    getStartRebalanceCommand().setIsExecutionAllowed(allowStartRebalance);
    getStopRebalanceCommand().setIsExecutionAllowed(allowStopRebalance);
    getStatusRebalanceCommand().setIsExecutionAllowed(allowStatusRebalance);
    getOptimizeForVirtStoreCommand().setIsExecutionAllowed(allowOptimize);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getNewVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
}
#method_after
private void updateActionAvailability() {
    boolean allowStart = true;
    boolean allowStop = true;
    boolean allowRemove = true;
    boolean allowStartRebalance = true;
    boolean allowStopRebalance = true;
    boolean allowStatusRebalance = true;
    boolean allowOptimize = true;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowStart = false;
        allowStop = false;
        allowRemove = false;
        allowStartRebalance = false;
        allowStopRebalance = false;
        allowStatusRebalance = false;
        allowOptimize = false;
    } else {
        List<GlusterVolumeEntity> list = Linq.<GlusterVolumeEntity>cast(getSelectedItems());
        for (GlusterVolumeEntity volume : list) {
            if (volume.getStatus() == GlusterStatus.UP) {
                allowStart = false;
                allowRemove = false;
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                allowStop = false;
                allowStartRebalance = false;
            }
            GlusterAsyncTask asyncTask = volume.getAsyncTask();
            if (asyncTask != null) {
                allowStartRebalance = allowStartRebalance && asyncTask.getStatus() == null ? asyncTask.getJobStatus() != JobExecutionStatus.STARTED : asyncTask.getStatus() != JobExecutionStatus.STARTED;
            }
        }
        if (list.size() == 1) {
            GlusterVolumeEntity volumeEntity = list.get(0);
            GlusterAsyncTask asyncTask = volumeEntity.getAsyncTask();
            allowStopRebalance = volumeEntity.getStatus() == GlusterStatus.UP && asyncTask != null && asyncTask.getType() == GlusterTaskType.REBALANCE && asyncTask.getStatus() == JobExecutionStatus.STARTED;
        } else {
            allowStopRebalance = false;
        }
        allowStatusRebalance = getRebalanceStatusAvailability(getSelectedItems());
    }
    getStartCommand().setIsExecutionAllowed(allowStart);
    getStopCommand().setIsExecutionAllowed(allowStop);
    getRemoveVolumeCommand().setIsExecutionAllowed(allowRemove);
    getStartRebalanceCommand().setIsExecutionAllowed(allowStartRebalance);
    getStopRebalanceCommand().setIsExecutionAllowed(allowStopRebalance);
    getStatusRebalanceCommand().setIsExecutionAllowed(allowStatusRebalance);
    getOptimizeForVirtStoreCommand().setIsExecutionAllowed(allowOptimize);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getNewVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
}
#end_block

#method_before
private void startRebalance() {
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        GlusterVolumeEntity volume = (GlusterVolumeEntity) item;
        list.add(new GlusterVolumeRebalanceParameters(volume.getId(), false, false));
    }
    Frontend.RunMultipleAction(VdcActionType.StartRebalanceGlusterVolume, list);
}
#method_after
private void startRebalance() {
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        GlusterVolumeEntity volume = (GlusterVolumeEntity) item;
        list.add(new GlusterVolumeRebalanceParameters(volume.getId(), false, false));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.StartRebalanceGlusterVolume, list);
}
#end_block

#method_before
private void stopRebalance() {
    if (getSelectedItems() == null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceTitle());
    // $NON-NLS-1$
    model.setHashName("volume_rebalance_stop");
    model.setMessage(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceMsg());
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterVolumeEntity item : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
        list.add(item.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("onStopRebalance", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void stopRebalance() {
    if (getSelectedItem() == null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceTitle());
    // $NON-NLS-1$
    model.setHashName("volume_rebalance_stop");
    model.setMessage(ConstantsManager.getInstance().getMessages().confirmStopVolumeRebalance(volumeEntity.getName()));
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("onStopRebalance", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void onStopRebalance() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (getSelectedItems() == null) {
        return;
    }
    model.startProgress(null);
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    GlusterVolumeRebalanceParameters param = new GlusterVolumeRebalanceParameters(volumeEntity.getId(), false, false);
    Frontend.RunAction(VdcActionType.StopRebalanceGlusterVolume, param, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) getConfirmWindow();
            localModel.stopProgress();
            setConfirmWindow(null);
            if (result.getReturnValue().getSucceeded()) {
                showRebalanceStatus();
            }
        }
    });
}
#method_after
private void onStopRebalance() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (getSelectedItems() == null) {
        return;
    }
    model.startProgress(null);
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    GlusterVolumeRebalanceParameters param = new GlusterVolumeRebalanceParameters(volumeEntity.getId(), false, false);
    Frontend.getInstance().runAction(VdcActionType.StopRebalanceGlusterVolume, param, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) getConfirmWindow();
            localModel.stopProgress();
            setConfirmWindow(null);
            if (result.getReturnValue().getSucceeded()) {
                showRebalanceStatus();
            }
        }
    });
}
#end_block

#method_before
private void optimizeVolumesForVirtStore(final List<Guid> volumeList) {
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, final Object result) {
            AsyncQuery aQueryInner = new AsyncQuery();
            aQueryInner.setModel(this);
            aQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object modelInner, final Object resultInner) {
                    AsyncQuery aQueryInner1 = new AsyncQuery();
                    aQueryInner1.setModel(this);
                    aQueryInner1.asyncCallback = new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object modelInner1, Object resultInner1) {
                            String optionGroupVirt = (String) result;
                            String optionOwnerUserVirt = (String) resultInner;
                            String optionOwnerGroupVirt = (String) resultInner1;
                            ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
                            for (Guid volumeId : volumeList) {
                                GlusterVolumeOptionEntity optionGroup = new GlusterVolumeOptionEntity();
                                optionGroup.setVolumeId(volumeId);
                                // $NON-NLS-1$
                                optionGroup.setKey("group");
                                optionGroup.setValue(optionGroupVirt);
                                list.add(new GlusterVolumeOptionParameters(optionGroup));
                                GlusterVolumeOptionEntity optionOwnerUser = new GlusterVolumeOptionEntity();
                                optionOwnerUser.setVolumeId(volumeId);
                                // $NON-NLS-1$
                                optionOwnerUser.setKey("storage.owner-uid");
                                optionOwnerUser.setValue(optionOwnerUserVirt);
                                list.add(new GlusterVolumeOptionParameters(optionOwnerUser));
                                GlusterVolumeOptionEntity optionOwnerGroup = new GlusterVolumeOptionEntity();
                                optionOwnerGroup.setVolumeId(volumeId);
                                // $NON-NLS-1$
                                optionOwnerGroup.setKey("storage.owner-gid");
                                optionOwnerGroup.setValue(optionOwnerGroupVirt);
                                list.add(new GlusterVolumeOptionParameters(optionOwnerGroup));
                            }
                            Frontend.RunMultipleAction(VdcActionType.SetGlusterVolumeOption, list);
                        }
                    };
                    AsyncDataProvider.getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionOwnerGroupVirtValue, AsyncDataProvider.getDefaultConfigurationVersion()), aQueryInner1);
                }
            };
            AsyncDataProvider.getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionOwnerUserVirtValue, AsyncDataProvider.getDefaultConfigurationVersion()), aQueryInner);
        }
    };
    AsyncDataProvider.getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionGroupVirtValue, AsyncDataProvider.getDefaultConfigurationVersion()), aQuery);
}
#method_after
private void optimizeVolumesForVirtStore(final List<Guid> volumeList) {
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, final Object result) {
            AsyncQuery aQueryInner = new AsyncQuery();
            aQueryInner.setModel(this);
            aQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object modelInner, final Object resultInner) {
                    AsyncQuery aQueryInner1 = new AsyncQuery();
                    aQueryInner1.setModel(this);
                    aQueryInner1.asyncCallback = new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object modelInner1, Object resultInner1) {
                            String optionGroupVirt = (String) result;
                            String optionOwnerUserVirt = (String) resultInner;
                            String optionOwnerGroupVirt = (String) resultInner1;
                            ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
                            for (Guid volumeId : volumeList) {
                                GlusterVolumeOptionEntity optionGroup = new GlusterVolumeOptionEntity();
                                optionGroup.setVolumeId(volumeId);
                                // $NON-NLS-1$
                                optionGroup.setKey("group");
                                optionGroup.setValue(optionGroupVirt);
                                list.add(new GlusterVolumeOptionParameters(optionGroup));
                                GlusterVolumeOptionEntity optionOwnerUser = new GlusterVolumeOptionEntity();
                                optionOwnerUser.setVolumeId(volumeId);
                                // $NON-NLS-1$
                                optionOwnerUser.setKey("storage.owner-uid");
                                optionOwnerUser.setValue(optionOwnerUserVirt);
                                list.add(new GlusterVolumeOptionParameters(optionOwnerUser));
                                GlusterVolumeOptionEntity optionOwnerGroup = new GlusterVolumeOptionEntity();
                                optionOwnerGroup.setVolumeId(volumeId);
                                // $NON-NLS-1$
                                optionOwnerGroup.setKey("storage.owner-gid");
                                optionOwnerGroup.setValue(optionOwnerGroupVirt);
                                list.add(new GlusterVolumeOptionParameters(optionOwnerGroup));
                            }
                            Frontend.getInstance().runMultipleAction(VdcActionType.SetGlusterVolumeOption, list);
                        }
                    };
                    AsyncDataProvider.getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionOwnerGroupVirtValue, AsyncDataProvider.getDefaultConfigurationVersion()), aQueryInner1);
                }
            };
            AsyncDataProvider.getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionOwnerUserVirtValue, AsyncDataProvider.getDefaultConfigurationVersion()), aQueryInner);
        }
    };
    AsyncDataProvider.getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionGroupVirtValue, AsyncDataProvider.getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void onStop() {
    if (getWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        GlusterVolumeEntity volume = (GlusterVolumeEntity) item;
        list.add(new GlusterVolumeActionParameters(volume.getId(), false));
    }
    model.startProgress(null);
    Frontend.RunMultipleAction(VdcActionType.StopGlusterVolume, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
public void onStop() {
    if (getWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        GlusterVolumeEntity volume = (GlusterVolumeEntity) item;
        list.add(new GlusterVolumeActionParameters(volume.getId(), false));
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.StopGlusterVolume, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
private void start() {
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        GlusterVolumeEntity volume = (GlusterVolumeEntity) item;
        list.add(new GlusterVolumeActionParameters(volume.getId(), false));
    }
    Frontend.RunMultipleAction(VdcActionType.StartGlusterVolume, list);
}
#method_after
private void start() {
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        GlusterVolumeEntity volume = (GlusterVolumeEntity) item;
        list.add(new GlusterVolumeActionParameters(volume.getId(), false));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.StartGlusterVolume, list);
}
#end_block

#method_before
private void onCreateVolume() {
    VolumeModel volumeModel = (VolumeModel) getWindow();
    if (!volumeModel.validate()) {
        return;
    }
    Guid clusterId = ((VDSGroup) volumeModel.getCluster().getSelectedItem()).getId();
    GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setClusterId(clusterId);
    volume.setName((String) volumeModel.getName().getEntity());
    GlusterVolumeType type = (GlusterVolumeType) volumeModel.getTypeList().getSelectedItem();
    if (type.isStripedType()) {
        volume.setStripeCount(volumeModel.getStripeCountValue());
    }
    if (type.isReplicatedType()) {
        volume.setReplicaCount(volumeModel.getReplicaCountValue());
    }
    volume.setVolumeType(type);
    if ((Boolean) volumeModel.getTcpTransportType().getEntity()) {
        volume.getTransportTypes().add(TransportType.TCP);
    }
    if ((Boolean) volumeModel.getRdmaTransportType().getEntity()) {
        volume.getTransportTypes().add(TransportType.RDMA);
    }
    ArrayList<GlusterBrickEntity> brickList = new ArrayList<GlusterBrickEntity>();
    for (Object model : volumeModel.getBricks().getItems()) {
        brickList.add((GlusterBrickEntity) ((EntityModel) model).getEntity());
    }
    volume.setBricks(brickList);
    if ((Boolean) volumeModel.getNfs_accecssProtocol().getEntity()) {
        volume.enableNFS();
    } else {
        volume.disableNFS();
    }
    if ((Boolean) volumeModel.getCifs_accecssProtocol().getEntity()) {
        volume.enableCifs();
    } else {
        volume.disableCifs();
    }
    volume.setAccessControlList((String) volumeModel.getAllowAccess().getEntity());
    volumeModel.startProgress(null);
    CreateGlusterVolumeParameters parameter = new CreateGlusterVolumeParameters(volume, volumeModel.isForceAddBricks());
    Frontend.RunAction(VdcActionType.CreateGlusterVolume, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VolumeListModel localModel = (VolumeListModel) result.getState();
            localModel.postOnCreateVolume(result.getReturnValue());
        }
    }, this);
}
#method_after
private void onCreateVolume() {
    VolumeModel volumeModel = (VolumeModel) getWindow();
    if (!volumeModel.validate()) {
        return;
    }
    Guid clusterId = ((VDSGroup) volumeModel.getCluster().getSelectedItem()).getId();
    GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setClusterId(clusterId);
    volume.setName((String) volumeModel.getName().getEntity());
    GlusterVolumeType type = (GlusterVolumeType) volumeModel.getTypeList().getSelectedItem();
    if (type.isStripedType()) {
        volume.setStripeCount(volumeModel.getStripeCountValue());
    }
    if (type.isReplicatedType()) {
        volume.setReplicaCount(volumeModel.getReplicaCountValue());
    }
    volume.setVolumeType(type);
    if ((Boolean) volumeModel.getTcpTransportType().getEntity()) {
        volume.getTransportTypes().add(TransportType.TCP);
    }
    if ((Boolean) volumeModel.getRdmaTransportType().getEntity()) {
        volume.getTransportTypes().add(TransportType.RDMA);
    }
    ArrayList<GlusterBrickEntity> brickList = new ArrayList<GlusterBrickEntity>();
    for (Object model : volumeModel.getBricks().getItems()) {
        brickList.add((GlusterBrickEntity) ((EntityModel) model).getEntity());
    }
    volume.setBricks(brickList);
    if ((Boolean) volumeModel.getNfs_accecssProtocol().getEntity()) {
        volume.enableNFS();
    } else {
        volume.disableNFS();
    }
    if ((Boolean) volumeModel.getCifs_accecssProtocol().getEntity()) {
        volume.enableCifs();
    } else {
        volume.disableCifs();
    }
    volume.setAccessControlList((String) volumeModel.getAllowAccess().getEntity());
    volumeModel.startProgress(null);
    CreateGlusterVolumeParameters parameter = new CreateGlusterVolumeParameters(volume, volumeModel.isForceAddBricks());
    Frontend.getInstance().runAction(VdcActionType.CreateGlusterVolume, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VolumeListModel localModel = (VolumeListModel) result.getState();
            localModel.postOnCreateVolume(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
public EntityModel<Boolean> getForce() {
    return force;
}
#method_after
public EntityModel getForce() {
    return force;
}
#end_block

#method_before
public void setForce(EntityModel<Boolean> force) {
    this.force = force;
}
#method_after
public void setForce(EntityModel force) {
    this.force = force;
}
#end_block

#method_before
public static boolean validateBrickCount(GlusterVolumeType selectedVolumeType, int brickCount, int replicaCount, int stripeCount, boolean isCreateVolume) {
    if (brickCount < 1) {
        return false;
    }
    boolean valid = true;
    // so the validation will be performed for the corresponding distributed types
    if (!isCreateVolume) {
        if (selectedVolumeType == GlusterVolumeType.REPLICATE) {
            selectedVolumeType = GlusterVolumeType.DISTRIBUTED_REPLICATE;
        } else if (selectedVolumeType == GlusterVolumeType.STRIPE) {
            selectedVolumeType = GlusterVolumeType.DISTRIBUTED_STRIPE;
        }
    }
    switch(selectedVolumeType) {
        case DISTRIBUTE:
            if (brickCount < 1) {
                valid = false;
            }
            break;
        case REPLICATE:
            if (brickCount != replicaCount) {
                valid = false;
            }
            break;
        case STRIPE:
            if (brickCount != stripeCount) {
                valid = false;
            }
            break;
        case DISTRIBUTED_REPLICATE:
            if (brickCount < replicaCount || (brickCount % replicaCount) != 0) {
                valid = false;
            }
            break;
        case DISTRIBUTED_STRIPE:
            if (brickCount < stripeCount || (brickCount % stripeCount) != 0) {
                valid = false;
            }
            break;
        case STRIPED_REPLICATE:
            if (brickCount != stripeCount * replicaCount) {
                valid = false;
            }
            break;
        case DISTRIBUTED_STRIPED_REPLICATE:
            if (brickCount < stripeCount * replicaCount || (brickCount % (stripeCount * replicaCount)) != 0) {
                valid = false;
            }
            break;
    }
    return valid;
}
#method_after
public static boolean validateBrickCount(GlusterVolumeType selectedVolumeType, int brickCount, int replicaCount, int stripeCount, boolean isCreateVolume) {
    if (brickCount < 1) {
        return false;
    }
    boolean valid = true;
    // so the validation will be performed for the corresponding distributed types
    if (!isCreateVolume) {
        if (selectedVolumeType == GlusterVolumeType.REPLICATE) {
            selectedVolumeType = GlusterVolumeType.DISTRIBUTED_REPLICATE;
        } else if (selectedVolumeType == GlusterVolumeType.STRIPE) {
            selectedVolumeType = GlusterVolumeType.DISTRIBUTED_STRIPE;
        }
    }
    switch(selectedVolumeType) {
        case DISTRIBUTE:
            if (brickCount < 1) {
                valid = false;
            }
            break;
        case REPLICATE:
            if (brickCount != replicaCount) {
                valid = false;
            }
            break;
        case STRIPE:
            if (brickCount != stripeCount) {
                valid = false;
            }
            break;
        case DISTRIBUTED_REPLICATE:
            if (brickCount <= replicaCount || (brickCount % replicaCount) != 0) {
                valid = false;
            }
            break;
        case DISTRIBUTED_STRIPE:
            if (brickCount <= stripeCount || (brickCount % stripeCount) != 0) {
                valid = false;
            }
            break;
        case STRIPED_REPLICATE:
            if (brickCount != stripeCount * replicaCount) {
                valid = false;
            }
            break;
        case DISTRIBUTED_STRIPED_REPLICATE:
            if (brickCount <= stripeCount * replicaCount || (brickCount % (stripeCount * replicaCount)) != 0) {
                valid = false;
            }
            break;
    }
    return valid;
}
#end_block

#method_before
private void onAddBricksInternal() {
    VolumeBrickModel volumeBrickModel = (VolumeBrickModel) getWindow();
    cancelConfirmation();
    if (!volumeBrickModel.validate()) {
        return;
    }
    GlusterVolumeType selectedVolumeType = (GlusterVolumeType) getTypeList().getSelectedItem();
    if (selectedVolumeType.isReplicatedType()) {
        getReplicaCount().setEntity(volumeBrickModel.getReplicaCount().getEntity());
    }
    if (selectedVolumeType.isStripedType()) {
        getStripeCount().setEntity(volumeBrickModel.getStripeCount().getEntity());
    }
    ArrayList<EntityModel> brickList = new ArrayList<EntityModel>();
    for (Object object : volumeBrickModel.getBricks().getItems()) {
        EntityModel entityModel = (EntityModel) object;
        brickList.add(entityModel);
    }
    volumeBrickModel.getBricks().setItems(null);
    ListModel brickListModel = new ListModel();
    brickListModel.setItems(brickList);
    brickListModel.setSelectedItems(brickList);
    setBricks(brickListModel);
    setForceAddBricks(volumeBrickModel.getForce().getEntity());
    setWindow(null);
}
#method_after
private void onAddBricksInternal() {
    VolumeBrickModel volumeBrickModel = (VolumeBrickModel) getWindow();
    cancelConfirmation();
    if (!volumeBrickModel.validate()) {
        return;
    }
    GlusterVolumeType selectedVolumeType = (GlusterVolumeType) getTypeList().getSelectedItem();
    if (selectedVolumeType.isReplicatedType()) {
        getReplicaCount().setEntity(volumeBrickModel.getReplicaCount().getEntity());
    }
    if (selectedVolumeType.isStripedType()) {
        getStripeCount().setEntity(volumeBrickModel.getStripeCount().getEntity());
    }
    ArrayList<EntityModel> brickList = new ArrayList<EntityModel>();
    for (Object object : volumeBrickModel.getBricks().getItems()) {
        EntityModel entityModel = (EntityModel) object;
        brickList.add(entityModel);
    }
    volumeBrickModel.getBricks().setItems(null);
    ListModel brickListModel = new ListModel();
    brickListModel.setItems(brickList);
    brickListModel.setSelectedItems(brickList);
    setBricks(brickListModel);
    setForceAddBricks((Boolean) volumeBrickModel.getForce().getEntity());
    setWindow(null);
}
#end_block

#method_before
private void createJobToMonitor(VDSGroup cluster, GlusterAsyncTask task) {
    if (task.getStatus() != JobExecutionStatus.STARTED) {
        // there's no need to monitor jobs that are failed or completed
        return;
    }
    StepEnum step = task.getType().getStep();
    VdcActionType actionType;
    switch(step) {
        case REBALANCING_VOLUME:
            actionType = VdcActionType.StartRebalanceGlusterVolume;
            break;
        case REMOVING_BRICKS:
            actionType = VdcActionType.StartRemoveGlusterVolumeBricks;
            break;
        default:
            actionType = VdcActionType.Unknown;
    }
    Guid jobId = addJob(cluster, task, actionType);
    Guid execStepId = addExecutingStep(jobId);
    Guid asyncStepId = addAsyncTaskStep(cluster, task, step, execStepId);
    Step asyncStep = getStepDao().get(asyncStepId);
    ExecutionHandler.updateStepExternalId(asyncStep, task.getTaskId(), ExternalSystemType.GLUSTER);
    updateVolumeBricksAndLock(cluster, task);
}
#method_after
private void createJobToMonitor(VDSGroup cluster, GlusterAsyncTask task) {
    if (!isTaskToBeMonitored(task)) {
        // there's no need to monitor jobs that are failed or completed
        return;
    }
    StepEnum step = task.getType().getStep();
    VdcActionType actionType;
    switch(step) {
        case REBALANCING_VOLUME:
            actionType = VdcActionType.StartRebalanceGlusterVolume;
            break;
        case REMOVING_BRICKS:
            actionType = VdcActionType.StartRemoveGlusterVolumeBricks;
            break;
        default:
            actionType = VdcActionType.Unknown;
    }
    String volumeName = task.getTaskParameters().getVolumeName();
    GlusterVolumeEntity vol = getVolumeDao().getByName(cluster.getId(), volumeName);
    if (vol == null) {
        log.infoFormat("Volume {0} does not exist yet for task detected from CLI {1}, not adding to engine", volumeName, task);
        return;
    }
    Guid jobId = addJob(cluster, task, actionType, vol);
    Guid execStepId = addExecutingStep(jobId);
    Guid asyncStepId = addAsyncTaskStep(cluster, task, step, execStepId);
    Step asyncStep = getStepDao().get(asyncStepId);
    ExecutionHandler.updateStepExternalId(asyncStep, task.getTaskId(), ExternalSystemType.GLUSTER);
    updateVolumeBricksAndLock(cluster, task, vol);
}
#end_block

#method_before
private Guid addJob(VDSGroup cluster, GlusterAsyncTask task, VdcActionType actionType) {
    String volumeName = task.getTaskParameters().getVolumeName();
    GlusterVolumeEntity vol = getVolumeDao().getByName(cluster.getId(), volumeName);
    VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.AddInternalJob, new AddInternalJobParameters(ExecutionMessageDirector.resolveJobMessage(actionType, getGlusterTaskUtils().getMessageMap(cluster, task)), actionType, true, VdcObjectType.GlusterVolume, vol.getId()));
    if (!result.getSucceeded()) {
        // log and return
        throw new VdcBLLException(result.getFault().getError());
    }
    Guid jobId = (Guid) result.getActionReturnValue();
    return jobId;
}
#method_after
private Guid addJob(VDSGroup cluster, GlusterAsyncTask task, VdcActionType actionType, final GlusterVolumeEntity vol) {
    VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.AddInternalJob, new AddInternalJobParameters(ExecutionMessageDirector.resolveJobMessage(actionType, getGlusterTaskUtils().getMessageMap(cluster, task)), actionType, true, VdcObjectType.GlusterVolume, vol.getId()));
    if (!result.getSucceeded()) {
        // log and return
        throw new VdcBLLException(result.getFault().getError());
    }
    Guid jobId = (Guid) result.getActionReturnValue();
    return jobId;
}
#end_block

#method_before
private void updateVolumeBricksAndLock(VDSGroup cluster, GlusterAsyncTask task) {
    // get volume associated with task
    String volumeName = task.getTaskParameters().getVolumeName();
    GlusterVolumeEntity vol = getVolumeDao().getByName(cluster.getId(), volumeName);
    if (vol != null) {
        try {
            // acquire lock on volume
            acquireLock(vol.getId());
            // update volume with task id
            getVolumeDao().updateVolumeTask(vol.getId(), task.getTaskId());
            if (GlusterTaskType.REMOVE_BRICK == task.getType()) {
                // update bricks associated with task id
                String[] bricks = task.getTaskParameters().getBricks();
                if (bricks != null) {
                    List<GlusterBrickEntity> brickEntities = new ArrayList<>();
                    for (String brick : bricks) {
                        String[] brickParts = brick.split(":", -1);
                        String hostnameOrIp = brickParts[0];
                        String brickDir = brickParts[1];
                        GlusterBrickEntity brickEntity = new GlusterBrickEntity();
                        VdsStatic server = GlusterDBUtils.getInstance().getServer(cluster.getId(), hostnameOrIp);
                        if (server == null) {
                            log.warnFormat("Could not find server {0} in cluster {1}", hostnameOrIp, cluster.getId());
                        } else {
                            brickEntity.setServerId(server.getId());
                            brickEntity.setBrickDirectory(brickDir);
                            brickEntity.setAsyncTask(new GlusterAsyncTask());
                            brickEntity.getAsyncTask().setTaskId(task.getTaskId());
                            brickEntities.add(brickEntity);
                        }
                    }
                    getBrickDao().updateAllBrickTasksByHostIdBrickDirInBatch(brickEntities);
                }
            }
            logTaskStartedFromCLI(cluster, task, vol);
        } catch (Exception e) {
            log.error(e);
            throw new VdcBLLException(VdcBllErrors.GeneralException, e.getMessage());
        } finally {
            releaseLock(vol.getId());
        }
    } else {
        log.debugFormat("Did not find a volume associated with volumeName {0} and task {1} ", volumeName, task.getTaskId());
    }
}
#method_after
private void updateVolumeBricksAndLock(VDSGroup cluster, GlusterAsyncTask task, final GlusterVolumeEntity vol) {
    try {
        // acquire lock on volume
        acquireLock(vol.getId());
        // update volume with task id
        getVolumeDao().updateVolumeTask(vol.getId(), task.getTaskId());
        if (GlusterTaskType.REMOVE_BRICK == task.getType()) {
            // update bricks associated with task id
            String[] bricks = task.getTaskParameters().getBricks();
            if (bricks != null) {
                List<GlusterBrickEntity> brickEntities = new ArrayList<>();
                for (String brick : bricks) {
                    String[] brickParts = brick.split(":", -1);
                    String hostnameOrIp = brickParts[0];
                    String brickDir = brickParts[1];
                    GlusterBrickEntity brickEntity = new GlusterBrickEntity();
                    VdsStatic server = GlusterDBUtils.getInstance().getServer(cluster.getId(), hostnameOrIp);
                    if (server == null) {
                        log.warnFormat("Could not find server {0} in cluster {1}", hostnameOrIp, cluster.getId());
                    } else {
                        brickEntity.setServerId(server.getId());
                        brickEntity.setBrickDirectory(brickDir);
                        brickEntity.setAsyncTask(new GlusterAsyncTask());
                        brickEntity.getAsyncTask().setTaskId(task.getTaskId());
                        brickEntities.add(brickEntity);
                    }
                }
                getBrickDao().updateAllBrickTasksByHostIdBrickDirInBatch(brickEntities);
            }
        }
        logTaskStartedFromCLI(cluster, task, vol);
    } catch (Exception e) {
        log.error(e);
        throw new VdcBLLException(VdcBllErrors.GeneralException, e.getMessage());
    } finally {
        releaseLock(vol.getId());
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    createJob(getParameters().getActionType(), false);
    if (getSucceeded() && getParameters().getJobEntityType() != null && getParameters().getJobEntityId() != null) {
        getDbFacade().getJobSubjectEntityDao().save((Guid) getActionReturnValue(), getParameters().getJobEntityId(), getParameters().getJobEntityType());
    }
}
#method_after
@Override
protected void executeCommand() {
    createJob(getParameters().getActionType(), false);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, getParameters().getActionType().getActionGroup()));
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    if (getParameters().getJobEntityType() != null && getParameters().getJobEntityId() != null) {
        permissionList.add(new PermissionSubject(getParameters().getJobEntityId(), getParameters().getJobEntityType(), getParameters().getActionType().getActionGroup()));
    } else {
        permissionList.add(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, getParameters().getActionType().getActionGroup()));
    }
    return permissionList;
}
#end_block

#method_before
protected VnicProfileModel createDefaultProfile() {
    if (defaultProfile != null) {
        return defaultProfile;
    }
    defaultProfile = new NewVnicProfileModel();
    // make sure default profile's name is in sync with network's name
    defaultProfile.getName().setEntity(getName().getEntity());
    final IEventListener networkNameListener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            defaultProfile.getName().setEntity(getName().getEntity());
        }
    };
    getName().getEntityChangedEvent().addListener(networkNameListener);
    // if user overrides default name, stop tracking network's name
    defaultProfile.getName().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!defaultProfile.getName().getEntity().equals(getName().getEntity())) {
                getName().getEntityChangedEvent().removeListener(networkNameListener);
                defaultProfile.getName().getEntityChangedEvent().removeListener(this);
            }
        }
    });
    return defaultProfile;
}
#method_after
private VnicProfileModel createDefaultProfile() {
    final VnicProfileModel defaultProfile = new NewVnicProfileModel();
    // make sure default profile's name is in sync with network's name
    defaultProfile.getName().setEntity(getName().getEntity());
    final IEventListener networkNameListener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            defaultProfile.getName().setEntity(getName().getEntity());
        }
    };
    getName().getEntityChangedEvent().addListener(networkNameListener);
    // if user overrides default name, stop tracking network's name
    defaultProfile.getName().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!defaultProfile.getName().getEntity().equals(getName().getEntity())) {
                getName().getEntityChangedEvent().removeListener(networkNameListener);
                defaultProfile.getName().getEntityChangedEvent().removeListener(this);
            }
        }
    });
    return defaultProfile;
}
#end_block

#method_before
public void syncWithBackend() {
    final StoragePool dc = getSelectedDc();
    if (dc == null) {
        return;
    }
    // Get IsSupportBridgesReportByVDSM
    boolean isSupportBridgesReportByVDSM = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.SupportBridgesReportByVDSM, dc.getcompatibility_version().toString());
    setSupportBridgesReportByVDSM(isSupportBridgesReportByVDSM);
    // Get IsMTUOverrideSupported
    boolean isMTUOverrideSupported = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MTUOverrideSupported, dc.getcompatibility_version().toString());
    setMTUOverrideSupported(isMTUOverrideSupported);
    onExportChanged();
    updateProfiles();
}
#method_after
public void syncWithBackend() {
    final StoragePool dc = getSelectedDc();
    if (dc == null) {
        return;
    }
    // Get IsSupportBridgesReportByVDSM
    boolean isSupportBridgesReportByVDSM = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.SupportBridgesReportByVDSM, dc.getcompatibility_version().toString());
    setSupportBridgesReportByVDSM(isSupportBridgesReportByVDSM);
    // Get IsMTUOverrideSupported
    boolean isMTUOverrideSupported = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MTUOverrideSupported, dc.getcompatibility_version().toString());
    setMTUOverrideSupported(isMTUOverrideSupported);
    onExportChanged();
    getProfiles().updateDcId(dc.getId());
}
#end_block

#method_before
@Override
public void edit(final NetworkProfilesModel model) {
    super.edit(model);
    model.getDcId().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            init(model);
        }
    });
}
#method_after
@Override
public void edit(final NetworkProfilesModel model) {
    defaultProfile = model.getDefaultProfile();
    super.edit(model);
    model.getDcId().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            dcId = model.getDcId().getEntity();
        }
    });
}
#end_block

#method_before
protected void init(M model) {
    items.clear();
    contentPanel.clear();
    modelItems = (Collection<T>) model.getItems();
    if (modelItems == null) {
        modelItems = new LinkedList<T>();
        // this will invoke init() again with the empty list as values instead of null
        model.setItems(modelItems);
        return;
    }
    for (T value : modelItems) {
        addEntry(value);
    }
    addGhostEntry();
}
#method_after
protected void init(M model) {
    items.clear();
    contentPanel.clear();
    modelItems = (Collection<T>) model.getItems();
    if (modelItems == null) {
        modelItems = new LinkedList<T>();
        // this will invoke init() again with the empty list as values instead of null
        model.setItems(modelItems);
        return;
    }
    for (T value : modelItems) {
        addEntry(value);
    }
    T additionalValue = addGhostEntry().getFirst();
    modelItems.add(additionalValue);
}
#end_block

#method_before
private void addGhostEntry() {
    T value = createGhostValue();
    addEntry(value);
    modelItems.add(value);
}
#method_after
private Pair<T, V> addGhostEntry() {
    T value = createGhostValue();
    V widget = addEntry(value);
    return new Pair<T, V>(value, widget);
}
#end_block

#method_before
private void addEntry(T value) {
    final V widget = createWidget(value);
    Pair<T, V> item = new Pair<T, V>(value, widget);
    items.add(item);
    PushButton button = createButton(item);
    final boolean ghost = isGhost(value);
    toggleGhost(value, widget, ghost);
    widget.addValueChangeHandler(new ValueChangeHandler<T>() {

        private boolean wasGhost = ghost;

        @Override
        public void onValueChange(ValueChangeEvent<T> event) {
            T value = event.getValue();
            boolean becomingGhost = isGhost(value);
            if (becomingGhost != wasGhost) {
                ((AddRemoveRowPanel) widget.getParent()).setButtonEnabled(!becomingGhost);
                toggleGhost(value, widget, becomingGhost);
                wasGhost = becomingGhost;
            }
        }
    });
    AddRemoveRowPanel entry = new AddRemoveRowPanel(widget, button);
    contentPanel.add(entry);
}
#method_after
private V addEntry(T value) {
    final V widget = createWidget(value);
    Pair<T, V> item = new Pair<T, V>(value, widget);
    items.add(item);
    PushButton button = createButton(item);
    final boolean ghost = isGhost(value);
    toggleGhost(value, widget, ghost);
    widget.addValueChangeHandler(new ValueChangeHandler<T>() {

        private boolean wasGhost = ghost;

        @Override
        public void onValueChange(ValueChangeEvent<T> event) {
            T value = event.getValue();
            boolean becomingGhost = isGhost(value);
            if (becomingGhost != wasGhost) {
                ((AddRemoveRowPanel) widget.getParent()).setButtonEnabled(!becomingGhost);
                toggleGhost(value, widget, becomingGhost);
                wasGhost = becomingGhost;
            }
        }
    });
    AddRemoveRowPanel entry = new AddRemoveRowPanel(widget, button);
    contentPanel.add(entry);
    return widget;
}
#end_block

#method_before
private PushButton createButton(final Pair<T, V> item) {
    final T value = item.getFirst();
    final V widget = item.getSecond();
    boolean ghostItem = isGhost(value);
    final PushButton button = new PushButton(new Image(ghostItem ? resources.increaseIcon() : resources.decreaseIcon()));
    button.addStyleName(style.buttonStyle());
    button.setEnabled(!ghostItem);
    button.addClickHandler(ghostItem ? new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            ((AddRemoveRowPanel) widget.getParent()).swapButton(createButton(item));
            addGhostEntry();
            onAdd(value, widget);
        }
    } : new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            removeEntry(item);
            onRemove(value, widget);
        }
    });
    return button;
}
#method_after
private PushButton createButton(final Pair<T, V> item) {
    final T value = item.getFirst();
    final V widget = item.getSecond();
    boolean ghostItem = isGhost(value);
    final PushButton button = new PushButton(new Image(ghostItem ? resources.increaseIcon() : resources.decreaseIcon()));
    button.addStyleName(style.buttonStyle());
    button.setEnabled(!ghostItem);
    button.addClickHandler(ghostItem ? new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            ((AddRemoveRowPanel) widget.getParent()).swapButton(createButton(item));
            Pair<T, V> item = addGhostEntry();
            onAdd(item.getFirst(), item.getSecond());
        }
    } : new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            removeEntry(item);
            onRemove(value, widget);
        }
    });
    return button;
}
#end_block

#method_before
protected void onAdd(T value, V widget) {
// do nothing
}
#method_after
protected void onAdd(T value, V widget) {
    modelItems.add(value);
}
#end_block

#method_before
private void onSave() {
    if (getProgress() != null) {
        return;
    }
    if (!validate()) {
        return;
    }
    // Save changes.
    flush();
    startProgress(null);
    Frontend.RunAction(getVdcActionType(), getActionParameters(), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            stopProgress();
            if (returnValue != null && returnValue.getSucceeded()) {
                cancel();
            }
        }
    }, this);
}
#method_after
private void onSave() {
    if (getProgress() != null) {
        return;
    }
    if (!validate()) {
        return;
    }
    // Save changes.
    flush();
    startProgress(null);
    Frontend.getInstance().runAction(getVdcActionType(), getActionParameters(), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            stopProgress();
            if (returnValue != null && returnValue.getSucceeded()) {
                cancel();
            }
        }
    }, this);
}
#end_block

#method_before
private void initCustomPropertySheet(Version dcCompatibilityVersion) {
    if (!customPropertiesVisible) {
        return;
    }
    GetDeviceCustomPropertiesParameters params = new GetDeviceCustomPropertiesParameters();
    params.setVersion(dcCompatibilityVersion);
    params.setDeviceType(VmDeviceGeneralType.INTERFACE);
    startProgress(null);
    Frontend.RunQuery(VdcQueryType.GetDeviceCustomProperties, params, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            if (returnValue != null) {
                Map<String, String> customPropertiesList = ((Map<String, String>) ((VdcQueryReturnValue) returnValue).getReturnValue());
                List<String> lines = new ArrayList<String>();
                for (Map.Entry<String, String> keyValue : customPropertiesList.entrySet()) {
                    lines.add(keyValue.getKey() + '=' + keyValue.getValue());
                }
                getCustomPropertySheet().setKeyValueString(lines);
                getCustomPropertySheet().setIsChangable(!lines.isEmpty());
                initCustomProperties();
            }
            stopProgress();
        }
    }));
}
#method_after
private void initCustomPropertySheet(Version dcCompatibilityVersion) {
    if (!customPropertiesVisible) {
        return;
    }
    GetDeviceCustomPropertiesParameters params = new GetDeviceCustomPropertiesParameters();
    params.setVersion(dcCompatibilityVersion);
    params.setDeviceType(VmDeviceGeneralType.INTERFACE);
    startProgress(null);
    Frontend.getInstance().runQuery(VdcQueryType.GetDeviceCustomProperties, params, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            if (returnValue != null) {
                Map<String, String> customPropertiesList = ((Map<String, String>) ((VdcQueryReturnValue) returnValue).getReturnValue());
                List<String> lines = new ArrayList<String>();
                for (Map.Entry<String, String> keyValue : customPropertiesList.entrySet()) {
                    lines.add(keyValue.getKey() + '=' + keyValue.getValue());
                }
                getCustomPropertySheet().setKeyValueString(lines);
                getCustomPropertySheet().setIsChangable(!lines.isEmpty());
                initCustomProperties();
            }
            stopProgress();
        }
    }));
}
#end_block

#method_before
public void initNetworkQoSList(Guid dcId) {
    if (dcId == null) {
        return;
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            ArrayList<NetworkQoS> networkQoSes = (ArrayList<NetworkQoS>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            networkQoSes.add(0, getEmptyQos());
            getNetworkQoS().setItems(networkQoSes);
            setSelectedNetworkQoSId(defaultQosId);
        }
    };
    IdQueryParameters queryParams = new IdQueryParameters(dcId);
    Frontend.RunQuery(VdcQueryType.GetAllNetworkQosByStoragePoolId, queryParams, _asyncQuery);
}
#method_after
public void initNetworkQoSList(Guid dcId) {
    if (dcId == null) {
        return;
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            ArrayList<NetworkQoS> networkQoSes = (ArrayList<NetworkQoS>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            networkQoSes.add(0, getEmptyQos());
            getNetworkQoS().setItems(networkQoSes);
            setSelectedNetworkQoSId(defaultQosId);
        }
    };
    IdQueryParameters queryParams = new IdQueryParameters(dcId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworkQosByStoragePoolId, queryParams, _asyncQuery);
}
#end_block

#method_before
private static void setVmTemplateStatus(Guid vmTemplateGuid, VmTemplateStatus status, CompensationContext compensationContext) {
    VmTemplate vmTemplate = DbFacade.getInstance().getVmTemplateDao().get(vmTemplateGuid);
    if (vmTemplate != null) {
        if (compensationContext != null) {
            compensationContext.snapshotEntityStatus(vmTemplate);
        }
        vmTemplate.setStatus(status);
        DbFacade.getInstance().getVmTemplateDao().update(vmTemplate);
    } else {
        log.warnFormat("VmTemplateHandler::setVmTemplateStatus: vmTemplate is null, not setting status '{0}' to vmTemplate", status);
    }
}
#method_after
private static void setVmTemplateStatus(Guid vmTemplateGuid, VmTemplateStatus status, CompensationContext compensationContext) {
    VmTemplate vmTemplate = DbFacade.getInstance().getVmTemplateDao().get(vmTemplateGuid);
    if (vmTemplate != null) {
        if (compensationContext != null) {
            compensationContext.snapshotEntityStatus(vmTemplate);
        }
        vmTemplate.setStatus(status);
        DbFacade.getInstance().getVmTemplateDao().update(vmTemplate);
    } else {
        log.warnFormat("setVmTemplateStatus: vmTemplate is null, not setting status '{0}' to vmTemplate", status);
    }
}
#end_block

#method_before
@Override
public void vdsNotResponding(final VDS vds, final boolean executeSshSoftFencing) {
    ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, false);
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            log.infoFormat("ResourceManager::vdsNotResponding entered for Host {0}, {1}", vds.getId(), vds.getHostName());
            boolean shouldExecRealFencing = true;
            if (executeSshSoftFencing) {
                VdcReturnValueBase retVal = Backend.getInstance().runInternalAction(VdcActionType.SshSoftFencing, new VdsActionParameters(vds.getId()), ExecutionHandler.createInternalJobContext());
                // if SSH Soft Fencing command execution was successful, do not execute
                // standard fencing immediately, but wait to see if it helped
                shouldExecRealFencing = !retVal.getSucceeded();
            }
            if (MonitoringStrategyFactory.getMonitoringStrategyForVds(vds).isPowerManagementSupported() && shouldExecRealFencing) {
                Backend.getInstance().runInternalAction(VdcActionType.VdsNotRespondingTreatment, new FenceVdsActionParameters(vds.getId(), FenceActionType.Restart), ExecutionHandler.createInternalJobContext());
            }
        }
    });
}
#method_after
@Override
public void vdsNotResponding(final VDS vds, final boolean executeSshSoftFencing) {
    ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, false);
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            log.infoFormat("ResourceManager::vdsNotResponding entered for Host {0}, {1}", vds.getId(), vds.getHostName());
            boolean shouldExecRealFencing = true;
            if (executeSshSoftFencing) {
                VdcReturnValueBase retVal = Backend.getInstance().runInternalAction(VdcActionType.SshSoftFencing, new VdsActionParameters(vds.getId()), ExecutionHandler.createInternalJobContext());
                // if SSH Soft Fencing command execution was successful, do not execute
                // standard fencing immediately, but wait to see if it helped
                shouldExecRealFencing = !retVal.getSucceeded();
            }
            if (MonitoringStrategyFactory.getMonitoringStrategyForVds(vds).isPowerManagementSupported() && shouldExecRealFencing) {
                Backend.getInstance().runInternalAction(VdcActionType.VdsNotRespondingTreatment, new FenceVdsActionParameters(vds.getId(), FenceActionType.Restart), ExecutionHandler.createInternalJobContext());
            }
            moveBricksToUnknown(vds);
        }
    });
}
#end_block

#method_before
private static void initGlusterSeverities() {
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_MODIFIED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_ALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_MIGRATE_BRICK_DATA_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_CONFLICT_DETECTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_NEW, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_GETCONTENT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICES_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_TYPE_ADDED_TO_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_ADDED_TO_SERVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOPPED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_BRICK_STATUS_CHANGED, AuditLogSeverity.WARNING);
}
#method_after
private static void initGlusterSeverities() {
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_MODIFIED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_ALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_MIGRATE_BRICK_DATA_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_CONFLICT_DETECTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_NEW, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_GETCONTENT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICES_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_TYPE_ADDED_TO_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_ADDED_TO_SERVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOPPED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOST_UUID_ALREADY_EXISTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_BRICK_STATUS_CHANGED, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initMLASeverities() {
    severities.put(AuditLogType.USER_VDC_LOGIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_VDC_LOGIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDC_LOGOUT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_VDC_LOGOUT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.AD_COMPUTER_ACCOUNT_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.AD_COMPUTER_ACCOUNT_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACHED_ACTION_GROUP_TO_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACHED_ACTION_GROUP_TO_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACHED_ACTION_GROUP_FROM_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACHED_ACTION_GROUP_FROM_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_ROLE_WITH_ACTION_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_ROLE_WITH_ACTION_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_ADUSER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_ADUSER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_ADUSER, AuditLogSeverity.WARNING);
}
#method_after
private static void initMLASeverities() {
    severities.put(AuditLogType.USER_VDC_LOGIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_VDC_LOGIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDC_LOGOUT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_VDC_LOGOUT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.AD_COMPUTER_ACCOUNT_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.AD_COMPUTER_ACCOUNT_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACHED_ACTION_GROUP_TO_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACHED_ACTION_GROUP_TO_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACHED_ACTION_GROUP_FROM_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACHED_ACTION_GROUP_FROM_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_ROLE_WITH_ACTION_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_ROLE_WITH_ACTION_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_ADUSER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_ADUSER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_ADUSER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_SYSTEM_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_SYSTEM_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SYSTEM_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SYSTEM_PERMISSION_FAILED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
public void setFormPanel(AbstractFormPanel formPanel) {
    this.formPanel = formPanel;
}
#method_after
public void setFormPanel(AbstractFormPanel formPanel) {
    this.formPanel = formPanel;
    // Compute autoPlacementRow if this item is available
    if (autoPlacement && getIsAvailable()) {
        this.autoPlacementRow = formPanel.getNextAvailableRow(column);
    }
}
#end_block

#method_before
public int getRow() {
    return row;
}
#method_after
public int getRow() {
    return (autoPlacement && autoPlacementRow != UNASSIGNED_ROW) ? autoPlacementRow : row;
}
#end_block

#method_before
public FormItem addFormItem(FormItem item) {
    formPanel.addFormItem(item);
    items.add(item);
    // Update property name mapping, if necessary
    String isAvailablePropertyName = item.getIsAvailablePropertyName();
    if (isAvailablePropertyName != null) {
        getItemsForPropertyName(isAvailablePropertyName).add(item);
    }
    return item;
}
#method_after
public void addFormItem(FormItem item) {
    // Adopt item
    item.setFormPanel(formPanel);
    // Validate and add item
    if (item.isValid()) {
        formPanel.addFormItem(item);
        items.add(item);
        // Update property name mapping, if necessary
        String isAvailablePropertyName = item.getIsAvailablePropertyName();
        if (isAvailablePropertyName != null) {
            getItemsForPropertyName(isAvailablePropertyName).add(item);
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getParameters().getSaveToDb()) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.NonOperational, getParameters().getNonOperationalReason()));
    }
    // if host failed to recover, no point in sending migrate, as it would fail.
    if (getParameters().getNonOperationalReason() != NonOperationalReason.TIMEOUT_RECOVERING_FROM_CRASH) {
        orderListOfRunningVmsOnVds(getVdsId());
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                // migrate vms according to cluster migrateOnError option
                switch(getVdsGroup().getMigrateOnError()) {
                    case YES:
                        migrateAllVms(getExecutionContext());
                        break;
                    case HA_ONLY:
                        migrateAllVms(getExecutionContext(), true);
                        break;
                    default:
                        break;
                }
            }
        });
    }
    if (getParameters().getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE) {
        log.errorFormat("Host '{0}' is set to Non-Operational, it is missing the following networks: '{1}'", getVds().getName(), getParameters().getCustomLogValues().get("Networks"));
    }
    if (getParameters().getNonOperationalReason() == NonOperationalReason.VM_NETWORK_IS_BRIDGELESS) {
        log.errorFormat("Host '{0}' is set to Non-Operational, the following networks are implemented as non-VM instead of a VM networks: '{1}'", getVds().getName(), getParameters().getCustomLogValues().get("Networks"));
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (getParameters().getSaveToDb()) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.NonOperational, getParameters().getNonOperationalReason()));
        if (getVdsGroup() != null && getVdsGroup().supportsGlusterService()) {
            updateBrickStatusDown();
        }
    }
    // if host failed to recover, no point in sending migrate, as it would fail.
    if (getParameters().getNonOperationalReason() != NonOperationalReason.TIMEOUT_RECOVERING_FROM_CRASH) {
        orderListOfRunningVmsOnVds(getVdsId());
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                // migrate vms according to cluster migrateOnError option
                switch(getVdsGroup().getMigrateOnError()) {
                    case YES:
                        migrateAllVms(getExecutionContext());
                        break;
                    case HA_ONLY:
                        migrateAllVms(getExecutionContext(), true);
                        break;
                    default:
                        break;
                }
            }
        });
    }
    if (getParameters().getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE) {
        log.errorFormat("Host '{0}' is set to Non-Operational, it is missing the following networks: '{1}'", getVds().getName(), getParameters().getCustomLogValues().get("Networks"));
    }
    if (getParameters().getNonOperationalReason() == NonOperationalReason.VM_NETWORK_IS_BRIDGELESS) {
        log.errorFormat("Host '{0}' is set to Non-Operational, the following networks are implemented as non-VM instead of a VM networks: '{1}'", getVds().getName(), getParameters().getCustomLogValues().get("Networks"));
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    for (Entry<String, String> e : getParameters().getCustomLogValues().entrySet()) {
        addCustomValue(e.getKey(), e.getValue());
    }
    switch(getParameters().getNonOperationalReason()) {
        case NETWORK_UNREACHABLE:
            return (getSucceeded()) ? AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK : AuditLogType.VDS_SET_NONOPERATIONAL_FAILED;
        case STORAGE_DOMAIN_UNREACHABLE:
            return (getSucceeded()) ? AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN : AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED;
        case TIMEOUT_RECOVERING_FROM_CRASH:
            return AuditLogType.VDS_RECOVER_FAILED;
        case KVM_NOT_RUNNING:
            return AuditLogType.VDS_RUN_IN_NO_KVM_MODE;
        case VERSION_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER;
        case CLUSTER_VERSION_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED;
        case VM_NETWORK_IS_BRIDGELESS:
            return AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS;
        case GLUSTER_COMMAND_FAILED:
            return AuditLogType.GLUSTER_COMMAND_FAILED;
        case GLUSTER_HOST_UUID_NOT_FOUND:
            return AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND;
        case GLUSTER_HOST_UUID_ALREADY_FOUND:
            return AuditLogType.GLUSTER_HOST_UUID_ALREADY_FOUND;
        case EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER;
        case UNTRUSTED:
            return AuditLogType.VDS_UNTRUSTED;
        default:
            return (getSucceeded()) ? AuditLogType.VDS_SET_NONOPERATIONAL : AuditLogType.VDS_SET_NONOPERATIONAL_FAILED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    for (Entry<String, String> e : getParameters().getCustomLogValues().entrySet()) {
        addCustomValue(e.getKey(), e.getValue());
    }
    switch(getParameters().getNonOperationalReason()) {
        case NETWORK_UNREACHABLE:
            return (getSucceeded()) ? AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK : AuditLogType.VDS_SET_NONOPERATIONAL_FAILED;
        case STORAGE_DOMAIN_UNREACHABLE:
            return (getSucceeded()) ? AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN : AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED;
        case TIMEOUT_RECOVERING_FROM_CRASH:
            return AuditLogType.VDS_RECOVER_FAILED;
        case KVM_NOT_RUNNING:
            return AuditLogType.VDS_RUN_IN_NO_KVM_MODE;
        case VERSION_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER;
        case CLUSTER_VERSION_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED;
        case VM_NETWORK_IS_BRIDGELESS:
            return AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS;
        case GLUSTER_COMMAND_FAILED:
            return AuditLogType.GLUSTER_COMMAND_FAILED;
        case GLUSTER_HOST_UUID_NOT_FOUND:
            return AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND;
        case GLUSTER_HOST_UUID_ALREADY_EXISTS:
            return AuditLogType.GLUSTER_HOST_UUID_ALREADY_EXISTS;
        case EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER;
        case UNTRUSTED:
            return AuditLogType.VDS_UNTRUSTED;
        default:
            return (getSucceeded()) ? AuditLogType.VDS_SET_NONOPERATIONAL : AuditLogType.VDS_SET_NONOPERATIONAL_FAILED;
    }
}
#end_block

#method_before
private boolean initGlusterHost() {
    glusterHostUuidFound = true;
    if (GlusterFeatureSupported.glusterHostUuidSupported(getVdsGroup().getcompatibility_version())) {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterHostUUID, new VdsIdVDSCommandParametersBase(getVds().getId()));
        Guid addServerGlusterUuid = Guid.createGuidFromString((String) returnValue.getReturnValue());
        if (returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
            if (!validateGlusterHostUuid(addServerGlusterUuid)) {
                glusterHostUuidFound = true;
                setNonOperational(NonOperationalReason.GLUSTER_HOST_UUID_ALREADY_FOUND, null);
                return false;
            }
            saveGlusterHostUuid(addServerGlusterUuid);
        } else {
            glusterHostUuidFound = false;
            setNonOperational(NonOperationalReason.GLUSTER_HOST_UUID_NOT_FOUND, null);
        }
    }
    return glusterHostUuidFound && initGlusterPeerProcess();
}
#method_after
private boolean initGlusterHost() {
    glusterHostUuidFound = true;
    if (GlusterFeatureSupported.glusterHostUuidSupported(getVdsGroup().getcompatibility_version())) {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterHostUUID, new VdsIdVDSCommandParametersBase(getVds().getId()));
        if (returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
            Guid addedServerUuid = Guid.createGuidFromString((String) returnValue.getReturnValue());
            if (hostUuidExists(addedServerUuid)) {
                setNonOperational(NonOperationalReason.GLUSTER_HOST_UUID_ALREADY_EXISTS, null);
                return false;
            }
            saveGlusterHostUuid(addedServerUuid);
        } else {
            glusterHostUuidFound = false;
            setNonOperational(NonOperationalReason.GLUSTER_HOST_UUID_NOT_FOUND, null);
        }
    }
    return glusterHostUuidFound && initGlusterPeerProcess();
}
#end_block

#method_before
private boolean initGlusterPeerProcess() {
    glusterPeerListSucceeded = true;
    glusterPeerProbeSucceeded = true;
    List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(getVdsGroupId(), VDSStatus.Up);
    // If the cluster already having Gluster servers, get an up server
    if (vdsList != null && vdsList.size() > 0) {
        VDS upServer = null;
        for (VDS vds : vdsList) {
            if (!getVdsId().equals(vds.getId())) {
                upServer = vds;
                break;
            }
        }
        // If new server is not part of the existing gluster peers, add into peer group
        if (upServer != null) {
            List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer.getId());
            Map<String, String> customLogValues = new HashMap<String, String>();
            customLogValues.put("Server", upServer.getHostName());
            if (glusterServers.size() == 0) {
                customLogValues.put("Command", "gluster peer status");
                setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                return false;
            } else if (!hostExists(glusterServers, getVds())) {
                if (!glusterPeerProbe(upServer.getId(), getVds().getHostName())) {
                    customLogValues.put("Command", "gluster peer probe " + getVds().getHostName());
                    setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                    return false;
                }
            }
        }
    }
    return true;
}
#method_after
private boolean initGlusterPeerProcess() {
    // condition.
    try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(getVds().getVdsGroupId())) {
        glusterPeerListSucceeded = true;
        glusterPeerProbeSucceeded = true;
        Map<String, String> customLogValues = new HashMap<String, String>();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(getVdsGroupId(), VDSStatus.Up);
        // If the cluster already having Gluster servers, get an up server
        if (vdsList != null && vdsList.size() > 0) {
            VDS upServer = null;
            for (VDS vds : vdsList) {
                if (!getVdsId().equals(vds.getId())) {
                    upServer = vds;
                    break;
                }
            }
            // If new server is not part of the existing gluster peers, add into peer group
            if (upServer != null) {
                List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer.getId());
                customLogValues.put("Server", upServer.getHostName());
                if (glusterServers.size() == 0) {
                    customLogValues.put("Command", "gluster peer status");
                    setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                    return false;
                } else if (!hostExists(glusterServers, getVds())) {
                    if (!glusterPeerProbe(upServer.getId(), getVds().getHostName())) {
                        customLogValues.put("Command", "gluster peer probe " + getVds().getHostName());
                        setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                        return false;
                    }
                }
            }
        }
        return true;
    }
}
#end_block

#method_before
private void saveGlusterHostUuid(Guid addServerGlusterUuid) {
    GlusterServerDao glusterServerDao = DbFacade.getInstance().getGlusterServerDao();
    GlusterServer glusterServer = glusterServerDao.getByServerId(getVds().getId());
    if (glusterServer == null) {
        glusterServer = new GlusterServer();
        glusterServer.setId(getVds().getId());
        glusterServer.setGlusterServerUuid(addServerGlusterUuid);
        glusterServerDao.save(glusterServer);
    }
}
#method_after
private void saveGlusterHostUuid(Guid addedServerUuid) {
    GlusterServerDao glusterServerDao = DbFacade.getInstance().getGlusterServerDao();
    GlusterServer glusterServer = glusterServerDao.getByServerId(getVds().getId());
    if (glusterServer == null) {
        glusterServer = new GlusterServer();
        glusterServer.setId(getVds().getId());
        glusterServer.setGlusterServerUuid(addedServerUuid);
        glusterServerDao.save(glusterServer);
    }
}
#end_block

#method_before
private static void initGlusterSeverities() {
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_MODIFIED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_ALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_CONFLICT_DETECTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_NEW, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_GETCONTENT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICES_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_TYPE_ADDED_TO_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_ADDED_TO_SERVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOPPED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOST_UUID_ALREADY_FOUND, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_BRICK_STATUS_CHANGED, AuditLogSeverity.WARNING);
}
#method_after
private static void initGlusterSeverities() {
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_MODIFIED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_ALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_MIGRATE_BRICK_DATA_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_CONFLICT_DETECTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_NEW, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_GETCONTENT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICES_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_TYPE_ADDED_TO_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_ADDED_TO_SERVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOPPED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOST_UUID_ALREADY_EXISTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_BRICK_STATUS_CHANGED, AuditLogSeverity.WARNING);
}
#end_block

#method_before
protected VdsDynamicDAO getVdsDynamicDAO() {
    return DbFacade.getInstance().getVdsDynamicDao();
}
#method_after
protected VdsDynamicDAO getVdsDynamicDAO() {
    return getDbFacade().getVdsDynamicDao();
}
#end_block

#method_before
private void RemoveVdsFromCollection() {
    // ResourceManager.Instance.removeVds(VdsId);
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(getVdsId()));
}
#method_after
private void RemoveVdsFromCollection() {
    // ResourceManager.Instance.removeVds(VdsId);
    getBackend().getResourceManager().RunVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(getVdsId()));
}
#end_block

#method_before
private void RemoveVdsStaticFromDb() {
    DbFacade.getInstance().getVdsStaticDao().remove(getVdsId());
}
#method_after
private void RemoveVdsStaticFromDb() {
    getVdsStaticDao().remove(getVdsId());
}
#end_block

#method_before
private void RemoveVdsStatisticsFromDb() {
    DbFacade.getInstance().getVdsStatisticsDao().remove(getVdsId());
}
#method_after
private void RemoveVdsStatisticsFromDb() {
    getVdsStatisticsDao().remove(getVdsId());
}
#end_block

#method_before
private void glusterHostRemove() {
    if (clusterHasMultipleHosts() && !hasVolumeBricksOnServer()) {
        try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(getVds().getVdsGroupId())) {
            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.RemoveGlusterServer, new RemoveGlusterServerVDSParameters(upServer.getId(), getVds().getHostName(), getParameters().isForceAction()));
            setSucceeded(returnValue.getSucceeded());
            if (!getSucceeded()) {
                getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
                getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
                errorType = AuditLogType.GLUSTER_SERVER_REMOVE_FAILED;
                return;
            }
        }
    }
}
#method_after
private void glusterHostRemove() {
    if (clusterHasMultipleHosts() && !hasVolumeBricksOnServer()) {
        try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(getVdsGroupId())) {
            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.RemoveGlusterServer, new RemoveGlusterServerVDSParameters(upServer.getId(), getVds().getHostName(), getParameters().isForceAction()));
            setSucceeded(returnValue.getSucceeded());
            if (!getSucceeded()) {
                getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
                getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
                errorType = AuditLogType.GLUSTER_SERVER_REMOVE_FAILED;
                return;
            }
        }
    }
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    Map<String, Pair<String, String>> locks = new HashMap<String, Pair<String, String>>();
    VDSGroup cluster = getVdsGroup();
    if (cluster == null || cluster.supportsVirtService()) {
        locks.put(getParameters().getVdsId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VDS, VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return locks;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    Map<String, Pair<String, String>> locks = new HashMap<String, Pair<String, String>>();
    locks.put(getParameters().getVdsId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VDS, VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    return locks;
}
#end_block

#method_before
public void eventMessageLogger(GlusterAsyncTask task, JobExecutionStatus oldStatus, VDSGroup cluster) {
    GlusterVolumeEntity volume;
    if (getVolumeDao().getVolumeByGlusterTask(task.getTaskId()) != null) {
        volume = getVolumeDao().getVolumeByGlusterTask(task.getTaskId());
    } else {
        String vol = task.getTaskParameters().getVolumeName();
        volume = getVolumeDao().getByName(cluster.getId(), vol);
    }
    if (JobExecutionStatus.ABORTED == task.getStatus() || JobExecutionStatus.FINISHED == task.getStatus() || JobExecutionStatus.FAILED == task.getStatus()) {
        if (oldStatus != task.getStatus()) {
            logMessage(cluster.getId(), volume, taskTypeStrMap.get(task.getType()), task.getStatus().name().toLowerCase(), taskTypeAuditMsg.get(task.getType()));
        }
    }
}
#method_after
public void eventMessageLogger(GlusterAsyncTask task, JobExecutionStatus oldStatus, VDSGroup cluster) {
    GlusterVolumeEntity volume = getVolumeDao().getVolumeByGlusterTask(task.getTaskId());
    if (volume == null) {
        if (task.getTaskParameters() != null) {
            String volName = task.getTaskParameters().getVolumeName();
            volume = getVolumeDao().getByName(cluster.getId(), volName);
        } else {
            return;
        }
    }
    if (JobExecutionStatus.ABORTED == task.getStatus() || JobExecutionStatus.FINISHED == task.getStatus() || JobExecutionStatus.FAILED == task.getStatus()) {
        if (oldStatus != task.getStatus()) {
            logMessage(cluster.getId(), volume, taskTypeStrMap.get(task.getType()), task.getStatus().name().toLowerCase(), taskTypeAuditMsg.get(task.getType()));
        }
    }
}
#end_block

#method_before
public static Pair<SizeUnit, Double> autoConvert(long size, SizeUnit inUnit) {
    for (Pair<Long, SizeUnit> currentUnitPair : SizeUnit.weightToUnit) {
        if (size / Math.pow(CONVERT_FACTOR, currentUnitPair.getFirst() - inUnit.getUnitWeight()) >= 1) {
            return new Pair<SizeConverter.SizeUnit, Double>(currentUnitPair.getSecond(), Double.valueOf(SizeConverter.convert(size, inUnit, currentUnitPair.getSecond()).doubleValue()));
        }
    }
    return new Pair<SizeConverter.SizeUnit, Double>(SizeUnit.BYTES, new Double(Long.valueOf(size)));
}
#method_after
public static Pair<SizeUnit, Double> autoConvert(long size, SizeUnit inUnit) {
    for (Pair<Long, SizeUnit> currentUnitPair : SizeUnit.weightToUnit) {
        if (size / Math.pow(CONVERT_FACTOR, currentUnitPair.getFirst() - inUnit.getUnitWeight()) >= 1) {
            return new Pair<SizeConverter.SizeUnit, Double>(currentUnitPair.getSecond(), SizeConverter.convert(size, inUnit, currentUnitPair.getSecond()).doubleValue());
        }
    }
    return new Pair<SizeConverter.SizeUnit, Double>(SizeUnit.BYTES, (double) size);
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeBrickStatusColumn(), constants.bricksStatusVolume(), "150px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(list), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeBrickStatusColumn(), constants.bricksStatusVolume(), "150px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    List<HasCell<GlusterTaskSupport, ?>> compositeList = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeTaskWaitingCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivityCompositeCell<GlusterTaskSupport>(list)) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(new VolumeActivityCompositeCell<GlusterTaskSupport>(compositeList) {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return !(value == null || value.getAsyncTask() == null);
        }
    }), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
}
#end_block

#method_before
private void initHandlers() {
    mTagsHandler = HandlersFactory.createTagsHandler();
    BaseConditionFieldAutoCompleter.TagsHandler = mTagsHandler;
    VmHandler.init();
    VdsHandler.Init();
    VmTemplateHandler.Init();
    log.info("Completed initializing handlers");
}
#method_after
private void initHandlers() {
    mTagsHandler = HandlersFactory.createTagsHandler();
    BaseConditionFieldAutoCompleter.tagsHandler = mTagsHandler;
    VmHandler.init();
    VdsHandler.Init();
    VmTemplateHandler.Init();
    log.info("Completed initializing handlers");
}
#end_block

#method_before
private void cleanUpOrphanTasks(Map<Guid, Set<Guid>> runningTasksinClusterMap) {
    // Populate the list of tasks that need to be monitored from database
    List<Guid> taskListInDB = getProvider().getMonitoredTaskIDsInDB();
    if (taskListInDB == null || taskListInDB.isEmpty()) {
        return;
    }
    Set<Guid> allRunningTasksInCluster = new HashSet<>();
    for (Set<Guid> taskSet : runningTasksinClusterMap.values()) {
        if (taskSet != null) {
            allRunningTasksInCluster.addAll(taskSet);
        }
    }
    // if task is in DB but not in running task list
    final Set<Guid> tasksNotRunning = new HashSet<Guid>(taskListInDB);
    tasksNotRunning.removeAll(allRunningTasksInCluster);
    for (Guid taskId : tasksNotRunning) {
        GlusterVolumeEntity vol = getVolumeDao().getVolumeByGlusterTask(taskId);
        if (vol != null && vol.getStatus() != GlusterStatus.UP && !runningTasksinClusterMap.keySet().contains((vol.getClusterId()))) {
            // contain the cluster id in such case
            continue;
        }
        // Volume is up, but gluster does not know of task
        // will mark job ended with status unknown.
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        for (Step step : steps) {
            step.markStepEnded(JobExecutionStatus.UNKNOWN);
            getGlusterTaskUtils().endStepJob(step);
        }
        getGlusterTaskUtils().releaseVolumeLock(taskId);
    }
}
#method_after
private void cleanUpOrphanTasks(Map<Guid, Set<Guid>> runningTasksInClusterMap) {
    // if map is empty, no tasks from clusters fetched. so return
    if (runningTasksInClusterMap.isEmpty()) {
        log.debug("Clean up of tasks has been skipped");
        return;
    }
    // Populate the list of tasks that need to be monitored from database
    List<Guid> taskListInDB = getProvider().getMonitoredTaskIDsInDB();
    if (taskListInDB == null || taskListInDB.isEmpty()) {
        return;
    }
    Set<Guid> allRunningTasksInCluster = new HashSet<>();
    for (Set<Guid> taskSet : runningTasksInClusterMap.values()) {
        if (taskSet != null) {
            allRunningTasksInCluster.addAll(taskSet);
        }
    }
    // if task is in DB but not in running task list
    final Set<Guid> tasksNotRunning = new HashSet<Guid>(taskListInDB);
    tasksNotRunning.removeAll(allRunningTasksInCluster);
    log.debugFormat("tasks to be cleaned up in db {0}", tasksNotRunning);
    for (Guid taskId : tasksNotRunning) {
        GlusterVolumeEntity vol = getVolumeDao().getVolumeByGlusterTask(taskId);
        if (vol != null && vol.getStatus() != GlusterStatus.UP && !runningTasksInClusterMap.keySet().contains((vol.getClusterId()))) {
            // contain the cluster id in such case
            continue;
        }
        // Volume is up, but gluster does not know of task
        // will mark job ended with status unknown.
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        for (Step step : steps) {
            step.markStepEnded(JobExecutionStatus.UNKNOWN);
            getGlusterTaskUtils().endStepJob(step);
        }
        getGlusterTaskUtils().releaseVolumeLock(taskId);
    }
}
#end_block

#method_before
public LinkedHashSet<Guid> getDiskIdsToIgnoreInChecks() {
    return diskIdsToIgnoreInChecks;
}
#method_after
public Set<Guid> getDiskIdsToIgnoreInChecks() {
    return diskIdsToIgnoreInChecks;
}
#end_block

#method_before
public void setDiskIdsToIgnoreInChecks(LinkedHashSet<Guid> diskIdsToIgnoreInChecks) {
    this.diskIdsToIgnoreInChecks = diskIdsToIgnoreInChecks;
}
#method_after
public void setDiskIdsToIgnoreInChecks(Set<Guid> diskIdsToIgnoreInChecks) {
    this.diskIdsToIgnoreInChecks = diskIdsToIgnoreInChecks;
}
#end_block

#method_before
private LiveMigrateDiskParameters createLiveMigrateDiskParameters(MoveDiskParameters moveDiskParameters, Guid vmId) {
    LiveMigrateDiskParameters toReturn = new LiveMigrateDiskParameters(moveDiskParameters.getImageId(), moveDiskParameters.getSourceDomainId(), moveDiskParameters.getStorageDomainId(), vmId, moveDiskParameters.getQuotaId());
    toReturn.setImageGroupID(diskMap.get(moveDiskParameters.getImageId()).getId());
    return toReturn;
}
#method_after
private LiveMigrateDiskParameters createLiveMigrateDiskParameters(MoveDiskParameters moveDiskParameters, Guid vmId) {
    return new LiveMigrateDiskParameters(moveDiskParameters.getImageId(), moveDiskParameters.getSourceDomainId(), moveDiskParameters.getStorageDomainId(), vmId, moveDiskParameters.getQuotaId(), diskMap.get(moveDiskParameters.getImageId()).getId());
}
#end_block

#method_before
protected void setImageStatus(ImageStatus imageStatus) {
    DiskImage diskImage = getRelevantDiskImage();
    if (diskImage != null) {
        diskImage.setImageStatus(imageStatus);
        ImagesHandler.updateImageStatus(diskImage.getImage().getId(), imageStatus);
    }
}
#method_after
protected void setImageStatus(ImageStatus imageStatus) {
    DiskImage diskImage = getRelevantDiskImage();
    if (diskImage != null && diskImage.getImageStatus() != imageStatus) {
        diskImage.setImageStatus(imageStatus);
        ImagesHandler.updateImageStatus(diskImage.getImage().getId(), imageStatus);
    }
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (getDestinationDiskImage() != null) {
        Guid storagePoolId = getDestinationDiskImage().getStoragePoolId() != null ? getDestinationDiskImage().getStoragePoolId() : Guid.Empty;
        Guid newImageGroupId = getDestinationDiskImage().getId() != null ? getDestinationDiskImage().getId() : Guid.Empty;
        Guid newImageId = getDestinationDiskImage().getImageId();
        Guid newStorageDomainID = getDestinationDiskImage().getStorageIds().get(0);
        // complete IRS data to DB disk image:
        DiskImage newImageIRS = (DiskImage) runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, newStorageDomainID, newImageGroupId, newImageId)).getReturnValue();
        if (newImageIRS != null) {
            completeImageData(newImageIRS);
        }
        // Unlock destination image:
        if (!getParameters().isShouldLeaveLocked()) {
            getDestinationDiskImage().setImageStatus(ImageStatus.OK);
            getImageDao().update(getDestinationDiskImage().getImage());
        }
    }
    if (!getParameters().isShouldLeaveLocked()) {
        unLockImage();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    if (getDestinationDiskImage() != null) {
        Guid storagePoolId = getDestinationDiskImage().getStoragePoolId() != null ? getDestinationDiskImage().getStoragePoolId() : Guid.Empty;
        Guid newImageGroupId = getDestinationDiskImage().getId() != null ? getDestinationDiskImage().getId() : Guid.Empty;
        Guid newImageId = getDestinationDiskImage().getImageId();
        Guid newStorageDomainID = getDestinationDiskImage().getStorageIds().get(0);
        // complete IRS data to DB disk image:
        try {
            DiskImage newImageIRS = (DiskImage) runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, newStorageDomainID, newImageGroupId, newImageId)).getReturnValue();
            if (newImageIRS != null) {
                completeImageData(newImageIRS);
            }
        } catch (VdcBLLException e) {
            // Logging only
            log.errorFormat("Unable to update the image info for image {0} (image group: {1}) on domain {2}", newImageId, newImageGroupId, newStorageDomainID);
        } finally {
            if (!getParameters().isLeaveLocked()) {
                getDestinationDiskImage().setImageStatus(ImageStatus.OK);
            }
            getImageDao().update(getDestinationDiskImage().getImage());
        }
    }
    if (!getParameters().isLeaveLocked()) {
        unLockImage();
    }
    setSucceeded(true);
}
#end_block

#method_before
protected List<DiskImage> getDisksListForChecks() {
    if (getParameters().getDiskIdsToIgnoreInChecks() == null) {
        return getDisksList();
    }
    List<DiskImage> toReturn = new LinkedList<>();
    for (DiskImage diskImage : getDisksList()) {
        if (!getParameters().getDiskIdsToIgnoreInChecks().contains(diskImage.getId())) {
            toReturn.add(diskImage);
        }
    }
    return toReturn;
}
#method_after
protected List<DiskImage> getDisksListForChecks() {
    if (getParameters().getDiskIdsToIgnoreInChecks().isEmpty()) {
        return getDisksList();
    }
    List<DiskImage> toReturn = new LinkedList<>();
    for (DiskImage diskImage : getDisksList()) {
        if (!getParameters().getDiskIdsToIgnoreInChecks().contains(diskImage.getId())) {
            toReturn.add(diskImage);
        }
    }
    return toReturn;
}
#end_block

#method_before
private ImagesActionsParametersBase buildCreateSnapshotParameters(DiskImage image) {
    VdcActionType parentCommand = getParameters().getParentCommand() != VdcActionType.Unknown ? getParameters().getParentCommand() : VdcActionType.CreateAllSnapshotsFromVm;
    ImagesActionsParametersBase result = new ImagesActionsParametersBase(image.getImageId());
    result.setDescription(getParameters().getDescription());
    result.setSessionId(getParameters().getSessionId());
    result.setQuotaId(image.getQuotaId());
    result.setVmSnapshotId(newActiveSnapshotId);
    result.setEntityInfo(getParameters().getEntityInfo());
    result.setParentCommand(parentCommand);
    result.setParentParameters(getParametersForTask(parentCommand, getParameters()));
    if (getParameters().getDiskIdsToIgnoreInChecks().contains(image.getId())) {
        result.setShouldLeaveLocked(true);
    }
    return result;
}
#method_after
private ImagesActionsParametersBase buildCreateSnapshotParameters(DiskImage image) {
    VdcActionType parentCommand = getParameters().getParentCommand() != VdcActionType.Unknown ? getParameters().getParentCommand() : VdcActionType.CreateAllSnapshotsFromVm;
    ImagesActionsParametersBase result = new ImagesActionsParametersBase(image.getImageId());
    result.setDescription(getParameters().getDescription());
    result.setSessionId(getParameters().getSessionId());
    result.setQuotaId(image.getQuotaId());
    result.setVmSnapshotId(newActiveSnapshotId);
    result.setEntityInfo(getParameters().getEntityInfo());
    result.setParentCommand(parentCommand);
    result.setParentParameters(getParametersForTask(parentCommand, getParameters()));
    if (getParameters().getDiskIdsToIgnoreInChecks().contains(image.getId())) {
        result.setLeaveLocked(true);
    }
    return result;
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
    // if the snapshot was not created in the DB
    // the command should also be handled as a failure
    boolean taskGroupSucceeded = createdSnapshot != null && getParameters().getTaskGroupSuccess();
    if (taskGroupSucceeded) {
        getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
        if (isLiveSnapshotApplicable()) {
            performLiveSnapshot(createdSnapshot);
        } else {
            // they are not going to be in use since no live snapshot is created
            if (createdSnapshot.containsMemory()) {
                logMemorySavingFailed();
                getSnapshotDao().removeMemoryFromSnapshot(createdSnapshot.getId());
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        }
    } else {
        if (createdSnapshot != null) {
            revertToActiveSnapshot(createdSnapshot.getId());
            // If the removed snapshot contained memory, remove the memory volumes
            // Note that the memory volumes might not have been created
            removeMemoryVolumesOfSnapshot(createdSnapshot);
        } else {
            log.warnFormat("No snapshot was created for VM {0} which is in LOCKED status", getVmId());
        }
    }
    incrementVmGeneration();
    endActionOnDisks();
    setSucceeded(taskGroupSucceeded);
    getReturnValue().setEndActionTryAgain(false);
}
#method_after
@Override
protected void endVmCommand() {
    Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
    // if the snapshot was not created in the DB
    // the command should also be handled as a failure
    boolean taskGroupSucceeded = createdSnapshot != null && getParameters().getTaskGroupSuccess();
    boolean liveSnapshotRequired = isLiveSnapshotApplicable();
    boolean liveSnapshotSucceeded = false;
    if (taskGroupSucceeded) {
        getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
        if (liveSnapshotRequired) {
            liveSnapshotSucceeded = performLiveSnapshot(createdSnapshot);
        } else {
            // they are not going to be in use since no live snapshot is created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                logMemorySavingFailed();
                getSnapshotDao().removeMemoryFromSnapshot(createdSnapshot.getId());
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        }
    } else {
        if (createdSnapshot != null) {
            revertToActiveSnapshot(createdSnapshot.getId());
            // Note that the memory volumes might not have been created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        } else {
            log.warnFormat("No snapshot was created for VM {0} which is in LOCKED status", getVmId());
        }
    }
    incrementVmGeneration();
    endActionOnDisks();
    setSucceeded(taskGroupSucceeded && (!liveSnapshotRequired || liveSnapshotSucceeded));
    getReturnValue().setEndActionTryAgain(false);
}
#end_block

#method_before
protected void performLiveSnapshot(final Snapshot snapshot) {
    try {
        TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                runVdsCommand(VDSCommandType.Snapshot, buildLiveSnapshotParameters(snapshot));
                return null;
            }
        });
    } catch (VdcBLLException e) {
        handleVdsLiveSnapshotFailure(e);
    }
}
#method_after
protected boolean performLiveSnapshot(final Snapshot snapshot) {
    try {
        TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                runVdsCommand(VDSCommandType.Snapshot, buildLiveSnapshotParameters(snapshot));
                return null;
            }
        });
    } catch (VdcBLLException e) {
        handleVdsLiveSnapshotFailure(e);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public void execute() {
    TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (LiveMigrateDiskParameters parameters : enclosingCommand.getParameters().getParametersList()) {
                CommandContext commandContext = ExecutionHandler.createInternalJobContext();
                ExecutionHandler.setAsyncJob(commandContext.getExecutionContext(), true);
                parameters.setSessionId(enclosingCommand.getParameters().getSessionId());
                VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.LiveMigrateDisk, parameters, commandContext);
                if (!vdcReturnValue.getSucceeded()) {
                    ImagesHandler.updateAllDiskImageSnapshotsStatus(parameters.getImageGroupID(), ImageStatus.OK);
                }
                enclosingCommand.getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                if (!parameters.getTaskGroupSuccess()) {
                    ExecutionHandler.endTaskJob(commandContext.getExecutionContext(), false);
                    log.errorFormat("Failed LiveMigrateDisk (Disk {0} , VM {1})", parameters.getImageGroupID(), parameters.getVmId());
                }
            }
            enclosingCommand.getReturnValue().setSucceeded(true);
            return null;
        }
    });
}
#method_after
@Override
public void execute() {
    if (!enclosingCommand.getReturnValue().getSucceeded()) {
        throw new VdcBLLException(VdcBllErrors.imageErr, "Auto-generated live snapshot for VM " + enclosingCommand.getParameters().getVmId() + " failed");
    }
    TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (LiveMigrateDiskParameters parameters : enclosingCommand.getParameters().getParametersList()) {
                CommandContext commandContext = ExecutionHandler.createInternalJobContext();
                ExecutionHandler.setAsyncJob(commandContext.getExecutionContext(), true);
                parameters.setSessionId(enclosingCommand.getParameters().getSessionId());
                VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.LiveMigrateDisk, parameters, commandContext);
                if (!vdcReturnValue.getSucceeded()) {
                    ImagesHandler.updateAllDiskImageSnapshotsStatus(parameters.getImageGroupID(), ImageStatus.OK);
                }
                enclosingCommand.getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                if (!parameters.getTaskGroupSuccess()) {
                    ExecutionHandler.endTaskJob(commandContext.getExecutionContext(), false);
                    log.errorFormat("Failed LiveMigrateDisk (Disk {0} , VM {1})", parameters.getImageGroupID(), parameters.getVmId());
                }
            }
            enclosingCommand.getReturnValue().setSucceeded(true);
            return null;
        }
    });
}
#end_block

#method_before
private List<LiveMigrateDiskParameters> createLiveMigrateVmDisksParameters() {
    return Arrays.asList(new LiveMigrateDiskParameters(diskImageId, srcStorageId, dstStorageId, vmId, quotaId));
}
#method_after
private List<LiveMigrateDiskParameters> createLiveMigrateVmDisksParameters() {
    return Arrays.asList(new LiveMigrateDiskParameters(diskImageId, srcStorageId, dstStorageId, vmId, quotaId, diskImageId));
}
#end_block

#method_before
public SPMAsyncTask concreteCreateTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, getAsyncTask(taskId, asyncTaskCreationInfo, parentCommand));
    p.setEntityInfo(getParameters().getEntityInfo());
    return CreateTask(internalGetTaskType(), p);
}
#method_after
public SPMAsyncTask concreteCreateTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, getAsyncTask(taskId, asyncTaskCreationInfo, parentCommand));
    p.setEntityInfo(getParameters().getEntityInfo());
    return createTask(internalGetTaskType(), p);
}
#end_block

#method_before
protected Guid createTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    Transaction transaction = TransactionSupport.suspend();
    try {
        return createTaskImpl(taskId, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during createTask for command: {0}. Exception {1}", getClass().getName(), ex);
    } finally {
        TransactionSupport.resume(transaction);
    }
    return Guid.Empty;
}
#method_after
public SPMAsyncTask createTask(AsyncTaskType taskType, AsyncTaskParameters taskParameters) {
    return AsyncTaskFactory.construct(taskType, taskParameters, false);
}
#end_block

#method_before
private void endCreateAllSnapshots() {
    Backend.getInstance().endAction(VdcActionType.CreateAllSnapshotsFromVm, getCreateSnapshotParameters(), ExecutionHandler.createDefaultContexForTasks(enclosingCommand.getExecutionContext()));
}
#method_after
private void endCreateAllSnapshots() {
    VdcReturnValueBase returnValue = Backend.getInstance().endAction(VdcActionType.CreateAllSnapshotsFromVm, getCreateSnapshotParameters(), ExecutionHandler.createDefaultContexForTasks(enclosingCommand.getExecutionContext()));
    enclosingCommand.getReturnValue().setSucceeded(returnValue.getSucceeded());
}
#end_block

#method_before
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, List<String> messages) {
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        for (VDS host : hosts) {
            if (host.getId().equals(vm.getDedicatedVmForVds())) {
                return Arrays.asList(host);
            }
        }
        // if flow reaches here, the VM is pinned but there is no dedicated host.
        return new ArrayList<>();
    }
    return hosts;
}
#method_after
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, List<String> messages) {
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        // host has been specified for pin to host.
        if (vm.getDedicatedVmForVds() != null) {
            for (VDS host : hosts) {
                if (host.getId().equals(vm.getDedicatedVmForVds())) {
                    return Arrays.asList(host);
                }
            }
        } else {
            // check pin to any (the VM should be down/ no migration allowed).
            if (vm.getRunOnVds() == null) {
                return hosts;
            }
        }
        // if flow reaches here, the VM is pinned but there is no dedicated host.
        return new ArrayList<>();
    }
    return hosts;
}
#end_block

#method_before
protected boolean initVm() {
    if (getVm() == null) {
        log.warnFormat("ResourceManager::{0}::No such vm (where id = '{1}' )in database", getClass().getName(), getVmId().toString());
        throw new VdcBLLException(VdcBllErrors.DB_NO_SUCH_VM);
    }
    if ((getVm().getStatus() == VMStatus.ImageIllegal) || (getVm().getStatus() == VMStatus.ImageLocked)) {
        log.warnFormat("ResourceManager::{0}::vm '{1}' has {2}", getClass().getName(), getVmId().toString(), (getVm().getStatus() == VMStatus.ImageLocked ? "a locked image" : "an illegal image"));
        setActionReturnValue(getVm().getStatus());
        return false;
    } else if (!getSnapshotsValidator().vmNotDuringSnapshot(getVmId()).isValid()) {
        log.warnFormat("ResourceManager::{0}::VM {1} is during snapshot", getClass().getName(), getVmId().toString());
        return false;
    } else {
        handleMemoryAdjustments();
        VmHandler.updateDisksFromDb(getVm());
        getVm().setKvmEnable(getParameters().getKvmEnable());
        getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
        getVm().setAcpiEnable(getParameters().getAcpiEnable());
        // Clear the first user:
        getVm().setConsoleUserId(null);
        getParameters().setRunAsStateless(getParameters().getRunAsStateless() != null ? getParameters().getRunAsStateless() : getVm().isStateless());
        getVm().setDisplayType(getParameters().getUseVnc() == null ? getVm().getDefaultDisplayType() : // the VM can run with display type which is different from its default display type
        (getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl));
        if (getParameters().getInitializationType() == null) {
            // if vm not initialized, use sysprep/cloud-init
            if (!getVm().isInitialized()) {
                getVm().setInitializationType(osRepository.isWindows(getVm().getVmOsId()) ? InitializationType.Sysprep : InitializationType.CloudInit);
            }
        } else {
            getVm().setInitializationType(getParameters().getInitializationType());
        }
        // if we attach floppy we don't need the sysprep
        if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
            getVmStaticDAO().update(getVm().getStaticData());
        }
        // get what cpu flags should be passed to vdsm according to cluster
        // cpu name
        getVm().setVdsGroupCpuFlagsData(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
        return true;
    }
}
#method_after
protected boolean initVm() {
    if (getVm() == null) {
        log.warnFormat("ResourceManager::{0}::No such vm (where id = '{1}' )in database", getClass().getName(), getVmId().toString());
        throw new VdcBLLException(VdcBllErrors.DB_NO_SUCH_VM);
    }
    if ((getVm().getStatus() == VMStatus.ImageIllegal) || (getVm().getStatus() == VMStatus.ImageLocked)) {
        log.warnFormat("ResourceManager::{0}::vm '{1}' has {2}", getClass().getName(), getVmId().toString(), (getVm().getStatus() == VMStatus.ImageLocked ? "a locked image" : "an illegal image"));
        setActionReturnValue(getVm().getStatus());
        return false;
    } else if (!getSnapshotsValidator().vmNotDuringSnapshot(getVmId()).isValid()) {
        log.warnFormat("ResourceManager::{0}::VM {1} is during snapshot", getClass().getName(), getVmId().toString());
        return false;
    } else {
        handleMemoryAdjustments();
        VmHandler.updateDisksFromDb(getVm());
        getVm().setKvmEnable(getParameters().getKvmEnable());
        getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
        getVm().setAcpiEnable(getParameters().getAcpiEnable());
        // Clear the first user:
        getVm().setConsoleUserId(null);
        getParameters().setRunAsStateless(getParameters().getRunAsStateless() != null ? getParameters().getRunAsStateless() : getVm().isStateless());
        getVm().setDisplayType(getParameters().getUseVnc() == null ? getVm().getDefaultDisplayType() : // the VM can run with display type which is different from its default display type
        (getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl));
        if (getParameters().getInitializationType() == null) {
            // if vm not initialized, use sysprep/cloud-init
            if (!getVm().isInitialized()) {
                getVm().setInitializationType(osRepository.isWindows(getVm().getVmOsId()) ? InitializationType.Sysprep : // TODO: we should use cloud init automatically only when cloud init configuration will be available
                InitializationType.None);
            }
        } else {
            getVm().setInitializationType(getParameters().getInitializationType());
        }
        // if we attach floppy we don't need the sysprep
        if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
            getVmStaticDAO().update(getVm().getStaticData());
        }
        // get what cpu flags should be passed to vdsm according to cluster
        // cpu name
        getVm().setVdsGroupCpuFlagsData(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
        return true;
    }
}
#end_block

#method_before
private boolean deviceCanBeRemoved(VmDevice vmDevice) {
    if (!vmDevice.getDevice().equals(VmDeviceType.DISK.getName())) {
        return true;
    }
    return vmDevice.getSnapshotId() == null && getDiskDao().get(vmDevice.getDeviceId()).isAllowSnapshot();
}
#method_after
private boolean deviceCanBeRemoved(VmDevice vmDevice) {
    if (!vmDevice.getDevice().equals(VmDeviceType.DISK.getName())) {
        return true;
    }
    if (vmDevice.getSnapshotId() == null) {
        Disk disk = getDiskDao().get(vmDevice.getDeviceId());
        return disk != null && disk.isAllowSnapshot();
    }
    return false;
}
#end_block

#method_before
public String translateErrorTextSingle(String errorMsg, Boolean changeIfNotFound) {
    // $NON-NLS-1$
    String ret = "";
    try {
        if ((errorMsg != null) && (errorMsg.length() > 0)) {
            // Taking a copy of the error message
            String errMsgCopy = errorMsg;
            if (!isDynamicVariable(errorMsg)) {
                errorMsg = errorMsg.replace('.', '_');
            }
            if (errors.getString(errorMsg) != null) {
                // $NON-NLS-1$ //$NON-NLS-2$
                ret = errors.getString(errorMsg).replace("\n", "<br/>");
            } else {
                // The error message is not found in the errors map, revert to original one
                // without replacement of "." with "_"
                errorMsg = errMsgCopy;
                if ((isDynamicVariable(errorMsg)) || (!changeIfNotFound)) {
                    ret = errorMsg;
                } else {
                    // just a message that doesn't have a value in the resource:
                    // $NON-NLS-1$
                    String[] splitted = errorMsg.toLowerCase().split("_");
                    // $NON-NLS-1$
                    ret = StringHelper.join(" ", splitted);
                }
            }
        }
    } catch (MissingResourceException e) {
        ret = errorMsg;
    }
    return ret;
}
#method_after
public String translateErrorTextSingle(String errorMsg, Boolean changeIfNotFound) {
    // $NON-NLS-1$
    String ret = "";
    try {
        if ((errorMsg != null) && (errorMsg.length() > 0)) {
            // Taking a copy of the error message
            String errMsgCopy = errorMsg;
            if (!isDynamicVariable(errorMsg)) {
                errorMsg = errorMsg.replace('.', '_');
            }
            if (errors.getString(errorMsg) != null) {
                // $NON-NLS-1$ //$NON-NLS-2$
                ret = errors.getString(errorMsg).replace("\n", "<br/>");
            } else {
                if ((isDynamicVariable(errorMsg)) || (!changeIfNotFound)) {
                    ret = errorMsg;
                } else {
                    // The error message is not found in the errors map, revert to original one
                    // without replacement of "." with "_"
                    errorMsg = errMsgCopy;
                    // just a message that doesn't have a value in the resource:
                    // $NON-NLS-1$
                    String[] splitted = errorMsg.toLowerCase().split("_");
                    // $NON-NLS-1$
                    ret = StringHelper.join(" ", splitted);
                }
            }
        }
    } catch (MissingResourceException e) {
        ret = errorMsg;
    }
    return ret;
}
#end_block

#method_before
@Test
public void testExecuteQueryWithDirectOnly() {
    PermissionDAO permissionDAOMock = mock(PermissionDAO.class);
    when(permissionDAOMock.getAllForEntity(objectID, getUser().getUserId(), getQueryParameters().isFiltered(), false)).thenReturn(mockedPermissions);
    when(getDbFacadeMockInstance().getPermissionDao()).thenReturn(permissionDAOMock);
    assertQueryDAOCall(true);
}
#method_after
@Test
public void testExecuteQueryWithDirectOnly() {
    PermissionDAO permissionDAOMock = mock(PermissionDAO.class);
    when(permissionDAOMock.getAllForEntity(objectID, getUser().getId(), getQueryParameters().isFiltered(), false)).thenReturn(mockedPermissions);
    when(getDbFacadeMockInstance().getPermissionDao()).thenReturn(permissionDAOMock);
    assertQueryDAOCall(true);
}
#end_block

#method_before
@Test
public void testExecuteQueryWithoutDirectOnly() {
    VdcObjectType type = RandomUtils.instance().pickRandom(VdcObjectType.values());
    when(getQueryParameters().getVdcObjectType()).thenReturn(type);
    PermissionDAO permissionDAOMock = mock(PermissionDAO.class);
    when(permissionDAOMock.getTreeForEntity(objectID, type, getUser().getUserId(), getQueryParameters().isFiltered())).thenReturn(mockedPermissions);
    when(getDbFacadeMockInstance().getPermissionDao()).thenReturn(permissionDAOMock);
    assertQueryDAOCall(false);
}
#method_after
@Test
public void testExecuteQueryWithoutDirectOnly() {
    VdcObjectType type = RandomUtils.instance().pickRandom(VdcObjectType.values());
    when(getQueryParameters().getVdcObjectType()).thenReturn(type);
    PermissionDAO permissionDAOMock = mock(PermissionDAO.class);
    when(permissionDAOMock.getTreeForEntity(objectID, type, getUser().getId(), getQueryParameters().isFiltered())).thenReturn(mockedPermissions);
    when(getDbFacadeMockInstance().getPermissionDao()).thenReturn(permissionDAOMock);
    assertQueryDAOCall(false);
}
#end_block

#method_before
@Override
public List<permissions> getAllForAdElement(Guid id, Guid userID, boolean isFiltered) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("ad_element_id", id).addValue("user_id", userID).addValue("is_filtered", isFiltered);
    return getCallsHandler().executeReadList("GetPermissionsByAdElementId", PermissionRowMapper.instance, parameterSource);
}
#method_after
@Override
public List<permissions> getAllForAdElement(Guid id, Guid userID, boolean isFiltered) {
    int appMode = Config.<Integer>GetValue(ConfigValues.ApplicationMode);
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("ad_element_id", id).addValue("user_id", userID).addValue("is_filtered", isFiltered).addValue("app_mode", appMode);
    return getCallsHandler().executeReadList("GetPermissionsByAdElementId", PermissionRowMapper.instance, parameterSource);
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removePermissionTitle());
    // $NON-NLS-1$
    model.setHashName("remove_permission");
    model.setMessage(ConstantsManager.getInstance().getConstants().permissionMsg());
    model.setItems(getSelectedItems());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removePermissionTitle());
    // $NON-NLS-1$
    model.setHashName("remove_permission");
    model.setItems(getSelectedItems());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.getIsEveryoneSelected() && model.getSelectedItems() == null) {
        cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    if (model.getIsEveryoneSelected()) {
        DbUser tempVar = new DbUser();
        tempVar.setId(ApplicationGuids.everyone.asGuid());
        items.add(tempVar);
    } else {
        for (Object item : model.getItems()) {
            EntityModel entityModel = (EntityModel) item;
            if (entityModel.getIsSelected()) {
                items.add((DbUser) entityModel.getEntity());
            }
        }
    }
    Role role = (Role) model.getRole().getSelectedItem();
    // adGroup/user
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (DbUser user : items) {
        permissions tempVar2 = new permissions();
        tempVar2.setad_element_id(user.getId());
        tempVar2.setrole_id(role.getId());
        permissions perm = tempVar2;
        perm.setObjectId(getEntityGuid());
        perm.setObjectType(this.getObjectType());
        if (user.isGroup()) {
            PermissionsOperationsParametes tempVar3 = new PermissionsOperationsParametes();
            tempVar3.setPermission(perm);
            tempVar3.setAdGroup(new LdapGroup(user.getId(), user.getFirstName(), user.getDomain()));
            list.add(tempVar3);
        } else {
            PermissionsOperationsParametes tempVar4 = new PermissionsOperationsParametes();
            tempVar4.setPermission(perm);
            tempVar4.setVdcUser(new VdcUser(user.getId(), user.getLoginName(), user.getDomain()));
            list.add(tempVar4);
        }
    }
    model.startProgress(null);
    Frontend.RunMultipleAction(VdcActionType.AddPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.getIsEveryoneSelected() && model.getSelectedItems() == null) {
        cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    if (model.getIsEveryoneSelected()) {
        DbUser tempVar = new DbUser();
        tempVar.setId(ApplicationGuids.everyone.asGuid());
        items.add(tempVar);
    } else {
        for (Object item : model.getItems()) {
            EntityModel entityModel = (EntityModel) item;
            if (entityModel.getIsSelected()) {
                items.add((DbUser) entityModel.getEntity());
            }
        }
    }
    Role role = (Role) model.getRole().getSelectedItem();
    // adGroup/user
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (DbUser user : items) {
        permissions tempVar2 = new permissions();
        tempVar2.setad_element_id(user.getId());
        tempVar2.setrole_id(role.getId());
        permissions perm = tempVar2;
        perm.setObjectId(getEntityGuid());
        perm.setObjectType(this.getObjectType());
        if (user.isGroup()) {
            PermissionsOperationsParametes tempVar3 = new PermissionsOperationsParametes();
            tempVar3.setPermission(perm);
            tempVar3.setAdGroup(new LdapGroup(user.getId(), user.getFirstName(), user.getDomain()));
            list.add(tempVar3);
        } else {
            PermissionsOperationsParametes tempVar4 = new PermissionsOperationsParametes();
            tempVar4.setPermission(perm);
            tempVar4.setUser(user);
            list.add(tempVar4);
        }
    }
    model.startProgress(null);
    Frontend.RunMultipleAction(VdcActionType.AddPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    if (getEntity() != null) {
        GlusterVolumeEntity glusterVolumeEntity = (GlusterVolumeEntity) getEntity();
        // If the items are same, just fire the item changed event to make sure that items are displayed
        if (getItems() == glusterVolumeEntity.getBricks()) {
            getItemsChangedEvent().raise(this, EventArgs.Empty);
        } else {
            setItems(glusterVolumeEntity.getBricks());
        }
    } else {
        setItems(null);
    }
}
#method_after
@Override
protected void syncSearch() {
    if (getEntity() != null) {
        GlusterVolumeEntity glusterVolumeEntity = (GlusterVolumeEntity) getEntity();
        // If the items are same, just fire the item changed event to make sure that items are displayed
        if (getItems() == glusterVolumeEntity.getBricks()) {
            getItemsChangedEvent().raise(this, EventArgs.Empty);
        } else {
            setItems(glusterVolumeEntity.getBricks());
        }
    } else {
        setItems(null);
    }
}
#end_block

#method_before
private void updateBrickStatusDown() {
    List<GlusterBrickEntity> brickEntities = getDbFacade().getGlusterBrickDao().getGlusterVolumeBricksByServerId(getVdsId());
    for (GlusterBrickEntity brick : brickEntities) {
        brick.setStatus(GlusterStatus.DOWN);
    }
    getDbFacade().getGlusterBrickDao().updateAll(brickEntities);
}
#method_after
private void updateBrickStatusDown() {
    List<GlusterBrickEntity> brickEntities = getDbFacade().getGlusterBrickDao().getGlusterVolumeBricksByServerId(getVdsId());
    for (GlusterBrickEntity brick : brickEntities) {
        brick.setStatus(GlusterStatus.DOWN);
    }
    getDbFacade().getGlusterBrickDao().updateBrickStatuses(brickEntities);
}
#end_block

#method_before
private boolean isRemovableStatus(VDSStatus status) {
    switch(status) {
        case Up:
        case Down:
        case Maintenance:
            return true;
        default:
            return false;
    }
}
#method_after
private boolean isRemovableStatus(VDSStatus status) {
    switch(status) {
        case Up:
        case Down:
            return true;
        default:
            return false;
    }
}
#end_block

#method_before
private void refreshBrickStatuses(VDS upServer, GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricksToUpdate = new ArrayList<GlusterBrickEntity>();
    Map<Guid, GlusterStatus> brickStatusMap = getBrickStatusMap(getVolumeAdvancedDetails(upServer, volume.getClusterId(), volume.getName()));
    for (GlusterBrickEntity brick : volume.getBricks()) {
        GlusterStatus fetchedStatus = brickStatusMap.get(brick.getId());
        // DB yet. Don't do anything, wait for it to be added by the 'lightweight' refresh job
        if (fetchedStatus != null && fetchedStatus != brick.getStatus()) {
            brick.setStatus(fetchedStatus);
            bricksToUpdate.add(brick);
        }
    }
    if (!bricksToUpdate.isEmpty()) {
        getBrickDao().updateBrickStatuses(bricksToUpdate);
    }
}
#method_after
private void refreshBrickStatuses(VDS upServer, GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricksToUpdate = new ArrayList<GlusterBrickEntity>();
    Map<Guid, GlusterStatus> brickStatusMap = getBrickStatusMap(getVolumeAdvancedDetails(upServer, volume.getClusterId(), volume.getName()));
    for (GlusterBrickEntity brick : volume.getBricks()) {
        GlusterStatus fetchedStatus = brickStatusMap.get(brick.getId());
        // DB yet. Don't do anything, wait for it to be added by the 'lightweight' refresh job
        if (fetchedStatus != null && fetchedStatus != brick.getStatus()) {
            logBrickStatusChange(volume, brick, fetchedStatus);
            brick.setStatus(fetchedStatus);
            bricksToUpdate.add(brick);
        }
    }
    if (!bricksToUpdate.isEmpty()) {
        getBrickDao().updateBrickStatuses(bricksToUpdate);
    }
}
#end_block

#method_before
private boolean glusterHostRemove(Guid sourceClusterId) {
    String hostName = (getVds().getHostName().isEmpty()) ? getVds().getManagementIp() : getVds().getHostName();
    VDS runningHostInSourceCluster = getClusterUtils().getUpServer(sourceClusterId);
    if (runningHostInSourceCluster == null) {
        log.error("Cannot remove host from source cluster, no host in Up status found in source cluster");
        handleError(-1, "No host in Up status found in source cluster");
        errorType = AuditLogType.GLUSTER_SERVER_REMOVE_FAILED;
        return false;
    }
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.RemoveGlusterServer, new RemoveGlusterServerVDSParameters(runningHostInSourceCluster.getId(), hostName, false));
    if (!returnValue.getSucceeded()) {
        handleVdsError(returnValue);
        errorType = AuditLogType.GLUSTER_SERVER_REMOVE_FAILED;
        return false;
    }
    return true;
}
#method_after
private boolean glusterHostRemove(Guid sourceClusterId) {
    // condition.
    try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(sourceClusterId)) {
        String hostName = (getVds().getHostName().isEmpty()) ? getVds().getManagementIp() : getVds().getHostName();
        VDS runningHostInSourceCluster = getClusterUtils().getUpServer(sourceClusterId);
        if (runningHostInSourceCluster == null) {
            log.error("Cannot remove host from source cluster, no host in Up status found in source cluster");
            handleError(-1, "No host in Up status found in source cluster");
            errorType = AuditLogType.GLUSTER_SERVER_REMOVE_FAILED;
            return false;
        }
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.RemoveGlusterServer, new RemoveGlusterServerVDSParameters(runningHostInSourceCluster.getId(), hostName, false));
        if (!returnValue.getSucceeded()) {
            handleVdsError(returnValue);
            errorType = AuditLogType.GLUSTER_SERVER_REMOVE_FAILED;
            return false;
        }
        return true;
    }
}
#end_block

#method_before
private boolean glusterHostAdd(Guid targetClusterId) {
    String hostName = (getVds().getHostName().isEmpty()) ? getVds().getManagementIp() : getVds().getHostName();
    VDS runningHostInTargetCluster = getClusterUtils().getUpServer(targetClusterId);
    if (runningHostInTargetCluster == null) {
        log.error("Cannot add host to target cluster, no host in Up status found in target cluster");
        handleError(-1, "No host in Up status found in target cluster");
        errorType = AuditLogType.GLUSTER_SERVER_ADD_FAILED;
        return false;
    }
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.AddGlusterServer, new AddGlusterServerVDSParameters(runningHostInTargetCluster.getId(), hostName));
    if (!returnValue.getSucceeded()) {
        handleVdsError(returnValue);
        errorType = AuditLogType.GLUSTER_SERVER_ADD_FAILED;
        return false;
    }
    return true;
}
#method_after
private boolean glusterHostAdd(Guid targetClusterId) {
    // condition.
    try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(targetClusterId)) {
        String hostName = (getVds().getHostName().isEmpty()) ? getVds().getManagementIp() : getVds().getHostName();
        VDS runningHostInTargetCluster = getClusterUtils().getUpServer(targetClusterId);
        if (runningHostInTargetCluster == null) {
            log.error("Cannot add host to target cluster, no host in Up status found in target cluster");
            handleError(-1, "No host in Up status found in target cluster");
            errorType = AuditLogType.GLUSTER_SERVER_ADD_FAILED;
            return false;
        }
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.AddGlusterServer, new AddGlusterServerVDSParameters(runningHostInTargetCluster.getId(), hostName));
        if (!returnValue.getSucceeded()) {
            handleVdsError(returnValue);
            errorType = AuditLogType.GLUSTER_SERVER_ADD_FAILED;
            return false;
        }
        return true;
    }
}
#end_block

#method_before
@Override
protected GlusterVolumeTaskStatusEntity fetchTaskStatusDetails() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeRemoveBricksStatus, new GlusterVolumeRemoveBricksVDSParameters(getUpServerId(clusterId), volume.getName(), getParameters().getBricks(), volume.getReplicaCount()));
    // Set the volume remove bricks start time
    GlusterVolumeTaskStatusEntity entity = setStartTime((GlusterVolumeTaskStatusEntity) returnValue.getReturnValue());
    // Set the host ip in status details
    updateHostIP(entity);
    return entity.sort();
}
#method_after
@Override
protected GlusterVolumeTaskStatusEntity fetchTaskStatusDetails() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeRemoveBricksStatus, new GlusterVolumeRemoveBricksVDSParameters(getUpServerId(clusterId), volume.getName(), getParameters().getBricks(), volume.getReplicaCount()));
    // update the status entity with required details
    return updateStatusEntity((GlusterVolumeTaskStatusEntity) returnValue.getReturnValue());
}
#end_block

#method_before
@Override
protected GlusterVolumeTaskStatusEntity fetchTaskStatusDetails() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeRebalanceStatus, new GlusterVolumeVDSParameters(getUpServerId(clusterId), volume.getName()));
    // Set the volume re-balance start time
    GlusterVolumeTaskStatusEntity entity = setStartTime((GlusterVolumeTaskStatusEntity) returnValue.getReturnValue());
    // Set the host ip in status details
    updateHostIP(entity);
    return entity.sort();
}
#method_after
@Override
protected GlusterVolumeTaskStatusEntity fetchTaskStatusDetails() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeRebalanceStatus, new GlusterVolumeVDSParameters(getUpServerId(clusterId), volume.getName()));
    return updateStatusEntity((GlusterVolumeTaskStatusEntity) returnValue.getReturnValue());
}
#end_block

#method_before
@Override
public void executeQueryCommand() {
    clusterId = getParameters().getClusterId();
    Guid volumeId = getParameters().getVolumeId();
    if (volumeId != null) {
        volume = getGlusterVolumeDao().getById(volumeId);
        if (volume == null) {
            throw new RuntimeException(VdcBllMessages.GLUSTER_VOLUME_ID_INVALID.toString());
        }
    }
    if (clusterId == null) {
        clusterId = volume.getClusterId();
    }
    getQueryReturnValue().setReturnValue(fetchTaskStatusDetails());
}
#method_after
@Override
public void executeQueryCommand() {
    clusterId = getParameters().getClusterId();
    volume = getGlusterVolumeDao().getById(getParameters().getVolumeId());
    if (volume == null) {
        throw new RuntimeException(VdcBllMessages.GLUSTER_VOLUME_ID_INVALID.toString());
    }
    if (clusterId == null) {
        clusterId = volume.getClusterId();
    }
    getQueryReturnValue().setReturnValue(fetchTaskStatusDetails());
}
#end_block

#method_before
protected void updateHostIP(GlusterVolumeTaskStatusEntity taskStatus) {
    if (taskStatus != null) {
        for (GlusterVolumeTaskStatusForHost hostStatus : taskStatus.getHostwiseStatusDetails()) {
            GlusterServer glusterServer = getGlusterServerDao().getByGlusterServerUuid(hostStatus.getHostUuid());
            if (glusterServer != null) {
                VDS host = getVdsDao().get(glusterServer.getId());
                if (host != null) {
                    hostStatus.setHostName(host.getName());
                    hostStatus.setHostId(host.getId());
                }
            }
        }
    }
}
#method_after
private void updateHostIP(GlusterVolumeTaskStatusEntity taskStatus) {
    if (taskStatus != null) {
        for (GlusterVolumeTaskStatusForHost hostStatus : taskStatus.getHostwiseStatusDetails()) {
            GlusterServer glusterServer = getGlusterServerDao().getByGlusterServerUuid(hostStatus.getHostUuid());
            if (glusterServer != null) {
                VDS host = getVdsDao().get(glusterServer.getId());
                if (host != null) {
                    hostStatus.setHostName(host.getName());
                    hostStatus.setHostId(host.getId());
                }
            }
        }
    }
}
#end_block

#method_before
protected GlusterVolumeTaskStatusEntity setStartTime(GlusterVolumeTaskStatusEntity status) {
    if (status == null) {
        return null;
    }
    GlusterAsyncTask asyncTask = volume.getAsyncTask();
    if (asyncTask != null && asyncTask.getTaskId() != null) {
        List<Step> stepsList = getStepDao().getStepsByExternalId(asyncTask.getTaskId());
        if (stepsList != null && !stepsList.isEmpty()) {
            status.setStartTime(stepsList.get(0).getStartTime());
        }
    }
    return status;
}
#method_after
private GlusterVolumeTaskStatusEntity setStartTime(GlusterVolumeTaskStatusEntity status) {
    if (status == null) {
        return null;
    }
    GlusterAsyncTask asyncTask = volume.getAsyncTask();
    if (asyncTask != null && asyncTask.getTaskId() != null) {
        List<Step> stepsList = getStepDao().getStepsByExternalId(asyncTask.getTaskId());
        if (stepsList != null && !stepsList.isEmpty()) {
            status.setStartTime(stepsList.get(0).getStartTime());
        }
    }
    return status;
}
#end_block

#method_before
private static void initGlusterSeverities() {
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_MODIFIED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_ALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_CONFLICT_DETECTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_NEW, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_GETCONTENT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICES_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_TYPE_ADDED_TO_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_ADDED_TO_SERVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOPPED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND, AuditLogSeverity.ERROR);
}
#method_after
private static void initGlusterSeverities() {
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_MODIFIED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_ALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_CONFLICT_DETECTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_NEW, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_GETCONTENT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICES_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_TYPE_ADDED_TO_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_ADDED_TO_SERVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOPPED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_BRICK_STATUS_CHANGED, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initVMsPoolSeverities() {
    severities.put(AuditLogType.USER_ADD_VM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_POOL_WITH_VMS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_POOL_WITH_VMS_ADD_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_POOL_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_POOL_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_AD_GROUP_TO_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_AD_GROUP_TO_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_AD_GROUP_FROM_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_AD_GROUP_FROM_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_TIME_LEASED_POOL_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_TIME_LEASED_POOL_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_AD_GROUP_FROM_TIME_LEASED_POOL_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_AD_GROUP_FROM_TIME_LEASED_POOL_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_USER_TO_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_USER_TO_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VM_POOL_MAX_SUBSEQUENT_FAILURES_REACHED, AuditLogSeverity.WARNING);
}
#method_after
private static void initVMsPoolSeverities() {
    severities.put(AuditLogType.USER_ADD_VM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_POOL_WITH_VMS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_POOL_WITH_VMS_ADD_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_POOL_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_POOL_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VM_POOL_MAX_SUBSEQUENT_FAILURES_REACHED, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initMLASeverities() {
    severities.put(AuditLogType.USER_VDC_LOGIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_VDC_LOGIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDC_LOGOUT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_VDC_LOGOUT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_AD_GROUP_TO_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_AD_GROUP_TO_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.AD_COMPUTER_ACCOUNT_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.AD_COMPUTER_ACCOUNT_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACHED_ACTION_GROUP_TO_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACHED_ACTION_GROUP_TO_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACHED_ACTION_GROUP_FROM_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACHED_ACTION_GROUP_FROM_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_ROLE_WITH_ACTION_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_ROLE_WITH_ACTION_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_ADUSER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_ADUSER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_ADUSER, AuditLogSeverity.WARNING);
}
#method_after
private static void initMLASeverities() {
    severities.put(AuditLogType.USER_VDC_LOGIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_VDC_LOGIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDC_LOGOUT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_VDC_LOGOUT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.AD_COMPUTER_ACCOUNT_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.AD_COMPUTER_ACCOUNT_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACHED_ACTION_GROUP_TO_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACHED_ACTION_GROUP_TO_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACHED_ACTION_GROUP_FROM_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACHED_ACTION_GROUP_FROM_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_ROLE_WITH_ACTION_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_ROLE_WITH_ACTION_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_ADUSER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_ADUSER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_ADUSER, AuditLogSeverity.WARNING);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
}
#method_after
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
}
#method_after
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initClusterPolicySeverities() {
    severities.put(AuditLogType.USER_ADD_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_ADD_CLUSTER_POLICY, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_REMOVE_CLUSTER_POLICY, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_UPDATE_CLUSTER_POLICY, AuditLogSeverity.ERROR);
}
#method_after
private static void initClusterPolicySeverities() {
    severities.put(AuditLogType.USER_ADD_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_ADD_CLUSTER_POLICY, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_REMOVE_CLUSTER_POLICY, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_UPDATE_CLUSTER_POLICY, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.FAILED_TO_CONNECT_TO_SCHEDULER_PROXY, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void updateTimeoutLogableObject(AuditLogableBase auditLogable, AuditLogType logType) {
    int duplicateEventsIntrvalValue = (auditLogable.isExternal()) ? // Min duration for External Events is 30 sec
    Math.max(auditLogable.getEventFloodInSec(), 30) : logType.getDuplicateEventsIntervalValue();
    if (duplicateEventsIntrvalValue > 0) {
        auditLogable.setEndTime(TimeUnit.SECONDS.toMillis(duplicateEventsIntrvalValue));
        auditLogable.setTimeoutObjectId(composeObjectId(auditLogable, logType));
    }
}
#method_after
private static void updateTimeoutLogableObject(AuditLogableBase auditLogable, AuditLogType logType) {
    int eventFloodRate = (auditLogable.isExternal()) ? // Min duration for External Events is 30 sec
    Math.max(auditLogable.getEventFloodInSec(), 30) : logType.getEventFloodRate();
    if (eventFloodRate > 0) {
        auditLogable.setEndTime(TimeUnit.SECONDS.toMillis(eventFloodRate));
        auditLogable.setTimeoutObjectId(composeObjectId(auditLogable, logType));
    }
}
#end_block

#method_before
private static String composeObjectId(AuditLogableBase logable, AuditLogType logType) {
    final char DELIMITER = ',';
    StringBuilder sb = new StringBuilder();
    sb.append("type=");
    sb.append(logType);
    sb.append(DELIMITER);
    sb.append("sd=");
    sb.append(logable.getStorageDomainId() == null ? "" : logable.getStorageDomainId().toString());
    sb.append(DELIMITER);
    sb.append("dc=");
    sb.append(logable.getStoragePoolId() == null ? "" : logable.getStoragePoolId().toString());
    sb.append(DELIMITER);
    sb.append("user=");
    sb.append(logable.getUserId() == null ? "" : logable.getUserId().toString());
    sb.append(DELIMITER);
    sb.append("cluster=");
    sb.append(logable.getVdsGroupId().toString());
    sb.append(DELIMITER);
    sb.append("vds=");
    sb.append(logable.getVdsId().toString());
    sb.append(DELIMITER);
    sb.append("vm=");
    sb.append(logable.getVmId().equals(Guid.Empty) ? "" : logable.getVmId().toString());
    sb.append(DELIMITER);
    sb.append("template=");
    sb.append(logable.getVmTemplateId().equals(Guid.Empty) ? "" : logable.getVmTemplateId().toString());
    sb.append(DELIMITER);
    sb.append("customId=");
    sb.append(logable.getCustomId() == null ? "" : logable.getCustomId().toString());
    sb.append(DELIMITER);
    return sb.toString();
}
#method_after
private static String composeObjectId(AuditLogableBase logable, AuditLogType logType) {
    final char DELIMITER = ',';
    StringBuilder sb = new StringBuilder();
    sb.append("type=");
    sb.append(logType);
    sb.append(DELIMITER);
    sb.append("sd=");
    sb.append(logable.getStorageDomainId() == null ? "" : logable.getStorageDomainId().toString());
    sb.append(DELIMITER);
    sb.append("dc=");
    sb.append(logable.getStoragePoolId() == null ? "" : logable.getStoragePoolId().toString());
    sb.append(DELIMITER);
    sb.append("user=");
    sb.append(logable.getUserId() == null ? "" : logable.getUserId().toString());
    sb.append(DELIMITER);
    sb.append("cluster=");
    sb.append(logable.getVdsGroupId().toString());
    sb.append(DELIMITER);
    sb.append("vds=");
    sb.append(logable.getVdsId().toString());
    sb.append(DELIMITER);
    sb.append("vm=");
    sb.append(logable.getVmId().equals(Guid.Empty) ? "" : logable.getVmId().toString());
    sb.append(DELIMITER);
    sb.append("template=");
    sb.append(logable.getVmTemplateId().equals(Guid.Empty) ? "" : logable.getVmTemplateId().toString());
    sb.append(DELIMITER);
    sb.append("customId=");
    sb.append(StringUtils.defaultString(logable.getCustomId()));
    sb.append(DELIMITER);
    return sb.toString();
}
#end_block

#method_before
@Override
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = GetReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterGeneralException:
        case GlusterPermissionDeniedException:
        case GlusterSyntaxErrorException:
        case GlusterMissingArgumentException:
        case GlusterCmdExecFailedException:
        case GlusterXmlErrorException:
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case GlusterHostRemoveFailedException:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
        case GlusterHookFailed:
        case GlusterHookEnableFailed:
        case GlusterHookDisableFailed:
        case GlusterHookNotFound:
        case GlusterHookListException:
        case GlusterHostUUIDNotFound:
        case GlusterHookConflict:
        case GlusterServicesListFailed:
        case GlusterHookUpdateFailed:
        case GlusterHookAlreadyExists:
        case GlusterHookChecksumMismatch:
        case GlusterHookAddFailed:
        case GlusterHookRemoveFailed:
        case GlusterServicesActionFailed:
        case GlusterServiceActionNotSupported:
        case GlusterVolumeRebalanceStopFailed:
        case GlusterVolumeStatusAllFailedException:
        case GlusterVolumeRebalanceStatusFailedException:
        case GlusterVolumeRemoveBricksStartFailed:
        case GlusterVolumeRemoveBricksStopFailed:
        case GlusterVolumeRemoveBrickStatusFailed:
        case GlusterVolumeRemoveBricksCommitFailed:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.proceedProxyReturnValue();
            break;
    }
}
#method_after
@Override
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = getReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterGeneralException:
        case GlusterPermissionDeniedException:
        case GlusterSyntaxErrorException:
        case GlusterMissingArgumentException:
        case GlusterCmdExecFailedException:
        case GlusterXmlErrorException:
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case GlusterHostRemoveFailedException:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
        case GlusterHookFailed:
        case GlusterHookEnableFailed:
        case GlusterHookDisableFailed:
        case GlusterHookNotFound:
        case GlusterHookListException:
        case GlusterHostUUIDNotFound:
        case GlusterHookConflict:
        case GlusterServicesListFailed:
        case GlusterHookUpdateFailed:
        case GlusterHookAlreadyExists:
        case GlusterHookChecksumMismatch:
        case GlusterHookAddFailed:
        case GlusterHookRemoveFailed:
        case GlusterServicesActionFailed:
        case GlusterServiceActionNotSupported:
        case GlusterVolumeRebalanceStopFailed:
        case GlusterVolumeStatusAllFailedException:
        case GlusterVolumeRebalanceStatusFailedException:
        case GlusterVolumeRemoveBricksStartFailed:
        case GlusterVolumeRemoveBricksStopFailed:
        case GlusterVolumeRemoveBrickStatusFailed:
        case GlusterVolumeRemoveBricksCommitFailed:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.proceedProxyReturnValue();
            break;
    }
}
#end_block

#method_before
private void stopRebalance() {
    if (getSelectedItem() == null) {
        return;
    }
    final ConfirmationModel model = new ConfirmationModel();
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceTitle());
    // $NON-NLS-1$
    model.setHashName("volume_rebalance_stop");
    model.setMessage(ConstantsManager.getInstance().getMessages().confirmStopVolumeRebalance(volumeEntity.getName()));
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("onStopRebalance", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void stopRebalance() {
    if (getSelectedItem() == null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceTitle());
    // $NON-NLS-1$
    model.setHashName("volume_rebalance_stop");
    model.setMessage(ConstantsManager.getInstance().getMessages().confirmStopVolumeRebalance(volumeEntity.getName()));
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("onStopRebalance", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
public void onBrowserEvent(Context context, Element parent, T value, NativeEvent event, ValueUpdater<T> valueUpdater) {
    super.onBrowserEvent(context, parent, value, event, valueUpdater);
    int eventX = event.getClientX();
    int eventY = event.getClientY();
    // Handle the click event.
    if ("click".equals(event.getType())) {
        // $NON-NLS-1$
        // Ignore clicks that occur outside of the outermost element.
        EventTarget eventTarget = event.getEventTarget();
        if (parent.getFirstChildElement().isOrHasChild(Element.as(eventTarget))) {
            menuPanelPopup.asPopupPanel().showAndFitToScreen(eventX, eventY);
        }
    }
    if ("mouseover".equals(event.getType())) {
        // $NON-NLS-1$
        if (isVisible(value)) {
            // $NON-NLS-1$
            parent.getStyle().setBorderColor("#96B7D6");
        }
    } else {
        // $NON-NLS-1$
        // $NON-NLS-1$
        parent.getStyle().setBorderColor("transparent");
    }
}
#method_after
public void onBrowserEvent(Context context, Element parent, T value, NativeEvent event, ValueUpdater<T> valueUpdater) {
    super.onBrowserEvent(context, parent, value, event, valueUpdater);
    int eventX = event.getClientX();
    int eventY = event.getClientY();
    // Handle the click event.
    if ("click".equals(event.getType())) {
        // $NON-NLS-1$
        // Ignore clicks that occur outside of the outermost element.
        EventTarget eventTarget = event.getEventTarget();
        if (parent.getFirstChildElement().isOrHasChild(Element.as(eventTarget))) {
            menuPanelPopup.asPopupPanel().showAndFitToScreen(eventX, eventY);
        }
    } else if ("mouseover".equals(event.getType())) {
        // $NON-NLS-1$
        if (isVisible(value)) {
            // $NON-NLS-1$
            parent.getFirstChildElement().getStyle().setBorderColor("#96B7D6");
        }
    } else {
        // $NON-NLS-1$
        parent.getFirstChildElement().getStyle().setBorderColor("transparent");
    }
}
#end_block

#method_before
public void addMenuItem(String title, final UICommand command) {
    final MenuItem menuItem = new MenuItem(title, new Command() {

        @Override
        public void execute() {
            menuPanelPopup.asPopupPanel().hide();
            command.execute();
        }
    });
    menuItem.setEnabled(command.getIsExecutionAllowed());
    command.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName.equals("IsExecutionAllowed")) {
                // $NON-NLS-1$
                menuItem.setEnabled(command.getIsExecutionAllowed());
            }
        }
    });
    menuPanelPopup.getMenuBar().addItem(menuItem);
}
#method_after
public void addMenuItem(final ActionButtonDefinition<T> buttonDef) {
    final MenuItem menuItem = new MenuItem(buttonDef.getTitle(), new Command() {

        @Override
        public void execute() {
            menuPanelPopup.asPopupPanel().hide();
            buttonDef.onClick(null);
        }
    });
    menuItem.setEnabled(buttonDef.isEnabled(null));
    // Update button whenever its definition gets re-initialized
    buttonDef.addInitializeHandler(new InitializeHandler() {

        @Override
        public void onInitialize(InitializeEvent event) {
            menuItem.setEnabled(buttonDef.isEnabled(null));
        }
    });
    menuPanelPopup.getMenuBar().addItem(menuItem);
}
#end_block

#method_before
public Map<String, String> getMessageMap(VDSGroup cluster, GlusterAsyncTask task) {
    Map<String, String> values = new HashMap<String, String>();
    values.put(GlusterConstants.CLUSTER, cluster.getName());
    values.put(GlusterConstants.VOLUME, task.getTaskParameters().getVolumeName());
    String jobStatus = getJobStatusInfo(task);
    values.put(GlusterConstants.JOB_STATUS, jobStatus);
    values.put(GlusterConstants.JOB_INFO, task.getMessage());
    return values;
}
#method_after
public Map<String, String> getMessageMap(VDSGroup cluster, GlusterAsyncTask task) {
    Map<String, String> values = new HashMap<String, String>();
    values.put(GlusterConstants.CLUSTER, cluster.getName());
    GlusterTaskParameters params = task.getTaskParameters();
    values.put(GlusterConstants.VOLUME, params != null ? params.getVolumeName() : "");
    String jobStatus = getJobStatusInfo(task);
    values.put(GlusterConstants.JOB_STATUS, jobStatus);
    values.put(GlusterConstants.JOB_INFO, task.getMessage());
    return values;
}
#end_block

