335
#method_before
public static void updateVmDevicesBootOrder(VmBase vmBase, List<VmDevice> devices, BootSequence bootSequence, boolean isOldCluster) {
    int bootOrder = 0;
    // reset current boot order of all relevant devices before recomputing it.
    for (VmDevice device : devices) {
        if (isBootable(device)) {
            device.setBootOrder(0);
        }
    }
    switch(bootSequence) {
        case C:
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            break;
        case CD:
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case CDN:
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case CN:
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case CND:
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case D:
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case DC:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            break;
        case DCN:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case DN:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case DNC:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            break;
        case N:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case NC:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            break;
        case NCD:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case ND:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case NDC:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            break;
    }
}
#method_after
public static void updateVmDevicesBootOrder(VmBase vmBase, List<VmDevice> devices, BootSequence bootSequence, boolean isOldCluster) {
    int bootOrder = 0;
    // reset current boot order of all relevant devices before recomputing it.
    for (VmDevice device : devices) {
        if (isBootable(device)) {
            // a boot order of 0 prevents it from being sent to VDSM
            device.setBootOrder(0);
        }
    }
    switch(bootSequence) {
        case C:
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            break;
        case CD:
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case CDN:
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case CN:
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case CND:
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case D:
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case DC:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            break;
        case DCN:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case DN:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case DNC:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            break;
        case N:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case NC:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            break;
        case NCD:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case ND:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case NDC:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            break;
    }
}
#end_block

#method_before
private static boolean isBootable(VmDevice device) {
    return (device.getType().equals(VmDeviceType.DISK.getName()) || device.getType().equals(VmDeviceType.INTERFACE.getName()));
}
#method_after
private static boolean isBootable(VmDevice device) {
    return (VmDeviceType.DISK.getName().equals(device.getType()) || VmDeviceType.INTERFACE.getName().equals(device.getType()));
}
#end_block

#method_before
@Before
@Override
public void setUp() throws Exception {
    super.setUp();
    when(Config.GetValue(ConfigValues.DefaultTimeZone)).thenReturn("Israel Standard Time");
}
#method_after
@Before
@Override
public void setUp() throws Exception {
    super.setUp();
    when(Config.GetValue(ConfigValues.DefaultTimeZone)).thenReturn(DEFAULT_TIME_ZONE);
}
#end_block

#method_before
@Test
public void testExecuteQueryCommand() {
    getQuery().executeQueryCommand();
    @SuppressWarnings("unchecked")
    KeyValuePairCompat<String, String> result = (KeyValuePairCompat<String, String>) getQuery().getQueryReturnValue().getReturnValue();
    assertTrue("Wrong default time zone", result.getValue().contains("Israel"));
}
#method_after
@Test
public void testExecuteQueryCommand() {
    getQuery().executeQueryCommand();
    @SuppressWarnings("unchecked")
    KeyValuePairCompat<String, String> result = (KeyValuePairCompat<String, String>) getQuery().getQueryReturnValue().getReturnValue();
    assertTrue("Wrong default time zone", result.getValue().equals(DEFAULT_TIME_ZONE));
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    // sysprep handler and be done with it
    synchronized (o) {
        if (timezones == null) {
            timezones = new HashMap<String, String>();
            for (String value : SysprepHandler.timeZoneIndex.keySet()) {
                // we use:
                // key = "Afghanistan Standard Time"
                // value = "(GMT+04:30) Afghanistan Standard Time"
                String key = SysprepHandler.getTimezoneKey(value);
                timezones.put(key, value);
            }
            timezones = sortMapByValue(timezones);
        }
    }
    getQueryReturnValue().setReturnValue(timezones);
}
#method_after
@Override
protected void executeQueryCommand() {
    // sysprep handler and be done with it
    synchronized (LOCK) {
        if (timezones == null) {
            timezones = new HashMap<String, String>();
            for (String value : SysprepHandler.timeZoneIndex.keySet()) {
                // we use:
                // key = "Afghanistan Standard Time"
                // value = "(GMT+04:30) Afghanistan Standard Time"
                String key = SysprepHandler.getTimezoneKey(value);
                timezones.put(key, value);
            }
            timezones = sortMapByValue(timezones);
        }
    }
    getQueryReturnValue().setReturnValue(timezones);
}
#end_block

#method_before
private Map<String, String> sortMapByValue(Map<String, String> map) {
    List<Map.Entry<String, String>> list = new LinkedList<Map.Entry<String, String>>(map.entrySet());
    Collections.sort(list, new Comparator<Map.Entry<String, String>>() {

        private Pattern regex = Pattern.compile(SysprepHandler.TimzeZoneExtractTimePattern);

        // we get a string like "(GMT-04:30) Afghanistan Standard Time"
        // we use regex to extract the time only and replace it to number
        // in this sample we get -430
        @Override
        public int compare(Map.Entry<String, String> o1, Map.Entry<String, String> o2) {
            int a = 0, b = 0;
            Matcher match1 = regex.matcher(o1.toString());
            Matcher match2 = regex.matcher(o2.toString());
            if (match1.matches() && match1.groupCount() > 0) {
                a = Integer.parseInt(match1.group(1).substring(3).replace(":", "").replace("+", ""));
            }
            if (match2.matches() && match2.groupCount() > 0) {
                b = Integer.parseInt(match2.group(1).substring(3).replace(":", "").replace("+", ""));
            }
            return (a > b) ? 1 : 0;
        }
    });
    Map<String, String> result = new LinkedHashMap<String, String>();
    for (Iterator<Map.Entry<String, String>> it = list.iterator(); it.hasNext(); ) {
        Map.Entry<String, String> entry = it.next();
        result.put(entry.getKey(), entry.getValue());
    }
    return result;
}
#method_after
private static Map<String, String> sortMapByValue(Map<String, String> map) {
    List<Map.Entry<String, String>> list = new LinkedList<Map.Entry<String, String>>(map.entrySet());
    Collections.sort(list, TimeZoneTimeExtractComperator.instance);
    Map<String, String> result = new LinkedHashMap<String, String>();
    for (Iterator<Map.Entry<String, String>> it = list.iterator(); it.hasNext(); ) {
        Map.Entry<String, String> entry = it.next();
        result.put(entry.getKey(), entry.getValue());
    }
    return result;
}
#end_block

#method_before
@Override
public boolean IsConnectSucceeded(java.util.HashMap<String, String> returnValue, List<storage_server_connections> connections) {
    boolean result = true;
    for (Map.Entry<String, String> entry : returnValue.entrySet()) {
        if (!"0".equals(entry.getValue())) {
            String connectionField = addToAuditLogErrorMessage(entry.getKey(), entry.getValue(), connections);
            printLog(getLog(), connectionField, entry.getValue());
            result = false;
        }
    }
    return result;
}
#method_after
@Override
public boolean IsConnectSucceeded(Map<String, String> returnValue, List<storage_server_connections> connections) {
    boolean result = true;
    for (Map.Entry<String, String> entry : returnValue.entrySet()) {
        if (!"0".equals(entry.getValue())) {
            String connectionField = addToAuditLogErrorMessage(entry.getKey(), entry.getValue(), connections);
            printLog(getLog(), connectionField, entry.getValue());
            result = false;
        }
    }
    return result;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setVmTicket(String vmId, String otp64, String sec) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.setVmTicket(vmId, otp64, sec);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc setVmTicket(String vmId, String otp64, String sec, String connectionAction, Map<String, String> params) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.setVmTicket(vmId, otp64, sec, connectionAction, params);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc glusterVolumeCreate(Map<String, Object> volumeData) {
    try {
        return new OneUuidReturnForXmlRpc(vdsServer.glusterVolumeCreate(volumeData));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public OneUuidReturnForXmlRpc glusterVolumeCreate(String volumeName, String[] brickList, int replicaCount, int stripeCount, String[] transportList) {
    try {
        return new OneUuidReturnForXmlRpc(vdsServer.glusterVolumeCreate(volumeName, brickList, replicaCount, stripeCount, transportList));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
private void setUpDAOMocks() {
    // Mock some devices
    VmDevice pluggedDevice = createVMDevice(vmID, pluggedDisk);
    // Mock the DAOs
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    // Disk Image DAO
    diskImageDAOMock = mock(DiskImageDAO.class);
    when(dbFacadeMock.getDiskImageDAO()).thenReturn(diskImageDAOMock);
    when(diskImageDAOMock.getAllForVm(vmID, getUser().getUserId(), getQueryParameters().isFiltered())).thenReturn(Arrays.asList(pluggedDisk, unpluggedDisk, inactiveDisk));
    // VM Device DAO
    vmDeviceDAOMock = mock(VmDeviceDAO.class);
    when(dbFacadeMock.getVmDeviceDAO()).thenReturn(vmDeviceDAOMock);
    when(vmDeviceDAOMock.getVmDeviceByVmIdTypeAndDevice(vmID, VmDeviceType.DISK.getName(), VmDeviceType.DISK.getName(), getUser().getUserId(), getQueryParameters().isFiltered())).thenReturn(Collections.singletonList(pluggedDevice));
    // Image handler
    mockStatic(ImagesHandler.class);
    when(ImagesHandler.getAllImageSnapshots(pluggedDisk.getImageId(), pluggedDisk.getit_guid())).thenReturn(new ArrayList<DiskImage>(Collections.nCopies(NUM_DISKS_OF_EACH_KIND, createDiskSnapshots(pluggedDisk.getId()))));
    when(ImagesHandler.getAllImageSnapshots(unpluggedDisk.getImageId(), unpluggedDisk.getit_guid())).thenReturn(new ArrayList<DiskImage>(Collections.nCopies(NUM_DISKS_OF_EACH_KIND, createDiskSnapshots(unpluggedDisk.getId()))));
}
#method_after
private void setUpDAOMocks() {
    // Mock some devices
    VmDevice pluggedDevice = createVMDevice(vmID, pluggedDisk);
    // Mock the DAOs
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    // Disk Image DAO
    diskImageDAOMock = mock(DiskImageDAO.class);
    when(dbFacadeMock.getDiskImageDAO()).thenReturn(diskImageDAOMock);
    when(diskImageDAOMock.getAllForVm(vmID, getUser().getUserId(), getQueryParameters().isFiltered())).thenReturn(Arrays.asList(pluggedDisk, unpluggedDisk, inactiveDisk));
    // VM Device DAO
    vmDeviceDAOMock = mock(VmDeviceDAO.class);
    when(dbFacadeMock.getVmDeviceDAO()).thenReturn(vmDeviceDAOMock);
    when(vmDeviceDAOMock.getVmDeviceByVmIdTypeAndDevice(vmID, VmDeviceType.DISK.getName(), VmDeviceType.DISK.getName(), getUser().getUserId(), getQueryParameters().isFiltered())).thenReturn(Collections.singletonList(pluggedDevice));
    // Image handler
    mockStatic(ImagesHandler.class);
    when(ImagesHandler.getAllImageSnapshots(pluggedDisk.getImageId(), pluggedDisk.getit_guid())).thenReturn(new ArrayList<DiskImage>(Collections.nCopies(NUM_DISKS_OF_EACH_KIND, createDiskSnapshot(pluggedDisk.getId()))));
    when(ImagesHandler.getAllImageSnapshots(unpluggedDisk.getImageId(), unpluggedDisk.getit_guid())).thenReturn(new ArrayList<DiskImage>(Collections.nCopies(NUM_DISKS_OF_EACH_KIND, createDiskSnapshot(unpluggedDisk.getId()))));
}
#end_block

#method_before
private static void assertCorrectSnapshots(DiskImage disk) {
    for (int i = 0; i < NUM_DISKS_OF_EACH_KIND; ++i) {
        assertEquals("Wrong snapshot " + i + " for disk ", disk.getId(), disk.getSnapshots().get(i).getImageId());
    }
}
#method_after
private static void assertCorrectSnapshots(DiskImage disk) {
    for (int i = 0; i < NUM_DISKS_OF_EACH_KIND; ++i) {
        assertEquals("Wrong snapshot " + i + " for disk ", disk.getId(), disk.getSnapshots().get(i).getId());
    }
}
#end_block

#method_before
private boolean checkQuotaValidationCommon(Quota quota, List<String> messages) {
    if (quota == null) {
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
        return false;
    }
    // Check if quota name isn't reserved.
    if (!checkQuotaNameReserved(quota, messages)) {
        return false;
    }
    // Check if quota name exists.
    if (!checkQuotaNameExisting(quota, messages)) {
        return false;
    }
    // If specific Quota for storage is specified
    if (!validateQuotaStorageLimitation(quota, messages)) {
        return false;
    }
    // If specific Quota for VDS Group is specific
    if (!validateQuotaVdsGroupLimitation(quota, messages)) {
        return false;
    }
    return true;
}
#method_after
private boolean checkQuotaValidationCommon(Quota quota, List<String> messages) {
    if (quota == null) {
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
        return false;
    }
    // If a user manually tries to add a quota with this reserved name, it should not be allowed.
    if (!checkQuotaNamePrefixReserved(quota, messages)) {
        return false;
    }
    // Check if quota name exists.
    if (!checkQuotaNameExisting(quota, messages)) {
        return false;
    }
    // If specific Quota for storage is specified
    if (!validateQuotaStorageLimitation(quota, messages)) {
        return false;
    }
    // If specific Quota for VDS Group is specific
    if (!validateQuotaVdsGroupLimitation(quota, messages)) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Test
public void testQuotaWithReservedName() throws Exception {
    List<String> messages = new ArrayList<String>();
    Quota mockQuota = mockGeneralStorageQuota();
    mockQuota.setIsDefaultQuota(false);
    mockQuota.setQuotaName("DefaultQuota-Storage pool name");
    boolean isQuotaValid = quotaHelper.checkQuotaNameReserved(mockQuota, messages);
    assertTrue(messages.contains(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NAME_RESERVED_FOR_DEFAULT.toString()));
    assertFalse(isQuotaValid);
}
#method_after
@Test
public void testQuotaWithReservedName() throws Exception {
    List<String> messages = new ArrayList<String>();
    Quota mockQuota = mockGeneralStorageQuota();
    mockQuota.setIsDefaultQuota(false);
    mockQuota.setQuotaName("DefaultQuota-Storage pool name");
    boolean isQuotaValid = quotaHelper.checkQuotaNamePrefixReserved(mockQuota, messages);
    assertTrue(messages.contains(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NAME_RESERVED_FOR_DEFAULT.toString()));
    assertFalse(isQuotaValid);
}
#end_block

#method_before
private void setQuotaParameter() {
    Quota quotaParameter = getParameters().getQuota();
    setStoragePoolId(quotaParameter.getStoragePoolId());
    setQuotaName(quotaParameter.getQuotaName());
    if (!quotaParameter.isEmptyStorageQuota()) {
        for (QuotaStorage quotaStorage : quotaParameter.getQuotaStorages()) {
            quotaStorage.setQuotaId(getQuotaId());
            quotaStorage.setQuotaStorageId(Guid.NewGuid());
        }
    }
    if (!quotaParameter.isEmptyVdsGroupQuota()) {
        for (QuotaVdsGroup quotaVdsGroup : quotaParameter.getQuotaVdsGroups()) {
            quotaVdsGroup.setQuotaId(getQuotaId());
            quotaVdsGroup.setQuotaVdsGroupId(Guid.NewGuid());
        }
    }
    setQuota(quotaParameter);
}
#method_after
private void setQuotaParameter() {
    Quota quotaParameter = getParameters().getQuota();
    setStoragePoolId(quotaParameter.getStoragePoolId());
    setQuotaName(quotaParameter.getQuotaName());
    quotaParameter.setIsDefaultQuota(false);
    if (!quotaParameter.isEmptyStorageQuota()) {
        for (QuotaStorage quotaStorage : quotaParameter.getQuotaStorages()) {
            quotaStorage.setQuotaId(getQuotaId());
            quotaStorage.setQuotaStorageId(Guid.NewGuid());
        }
    }
    if (!quotaParameter.isEmptyVdsGroupQuota()) {
        for (QuotaVdsGroup quotaVdsGroup : quotaParameter.getQuotaVdsGroups()) {
            quotaVdsGroup.setQuotaId(getQuotaId());
            quotaVdsGroup.setQuotaVdsGroupId(Guid.NewGuid());
        }
    }
    setQuota(quotaParameter);
}
#end_block

#method_before
@Test
public void testExecuteQueryCommand() {
    // Mock parameters
    Guid roleId = Guid.NewGuid();
    when(getQueryParameters().getRoleId()).thenReturn(roleId);
    // Mock the expected result
    ActionGroup group = RandomUtils.instance().pickRandom(ActionGroup.values());
    List<ActionGroup> expected = Collections.singletonList(group);
    // Mock the DAO
    ActionGroupDAO actionGroupDAOMock = mock(ActionGroupDAO.class);
    when(actionGroupDAOMock.getAllForRole(roleId)).thenReturn(expected);
    when(getDbFacadeMockInstance().getActionGroupDAO()).thenReturn(actionGroupDAOMock);
    // Execute the query and assert the result
    getQuery().executeQueryCommand();
    assertEquals("Wrong query result", expected, getQuery().getQueryReturnValue().getReturnValue());
}
#method_after
@Test
public void testExecuteQueryCommand() {
    // Mock parameters
    Guid roleId = Guid.NewGuid();
    when(getQueryParameters().getRoleId()).thenReturn(roleId);
    // Mock the expected result
    ActionGroup group = RandomUtils.instance().nextEnum(ActionGroup.class);
    List<ActionGroup> expected = Collections.singletonList(group);
    // Mock the DAO
    ActionGroupDAO actionGroupDAOMock = mock(ActionGroupDAO.class);
    when(actionGroupDAOMock.getAllForRole(roleId)).thenReturn(expected);
    when(getDbFacadeMockInstance().getActionGroupDAO()).thenReturn(actionGroupDAOMock);
    // Execute the query and assert the result
    getQuery().executeQueryCommand();
    assertEquals("Wrong query result", expected, getQuery().getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
@Test
public void testGetAllForEntity() {
    List<permissions> result = dao.getAllForEntity(VM_ENTITY_ID);
    assertGetllForEntityResult(result);
}
#method_after
@Test
public void testGetAllForEntity() {
    List<permissions> result = dao.getAllForEntity(VM_ENTITY_ID);
    assertGetAllForEntityResult(result);
}
#end_block

#method_before
@Test
public void testGetAllForEntityFilteredWithPermissions() {
    List<permissions> result = dao.getAllForEntity(VM_ENTITY_ID, PRIVILEGED_USER_ID, true);
    assertGetllForEntityResult(result);
}
#method_after
@Test
public void testGetAllForEntityFilteredWithPermissions() {
    List<permissions> result = dao.getAllForEntity(VM_ENTITY_ID, PRIVILEGED_USER_ID, true);
    assertGetAllForEntityResult(result);
}
#end_block

#method_before
@Test
public void testGetAllForEntityFilteredWithNoPermissionsFilteringDisabled() {
    List<permissions> result = dao.getAllForEntity(VM_ENTITY_ID, UNPRIVILEGED_USER_ID, false);
    assertGetllForEntityResult(result);
}
#method_after
@Test
public void testGetAllForEntityFilteredWithNoPermissionsFilteringDisabled() {
    List<permissions> result = dao.getAllForEntity(VM_ENTITY_ID, UNPRIVILEGED_USER_ID, false);
    assertGetAllForEntityResult(result);
}
#end_block

#method_before
public void Edit() {
    VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    ClusterModel model = new ClusterModel();
    model.setEntity(cluster);
    model.Init(true, getGlusterModeEnum());
    setWindow(model);
    model.setTitle("Edit Cluster");
    model.setHashName("edit_cluster");
    model.setOriginalName(cluster.getname());
    model.getName().setEntity(cluster.getname());
    model.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster) {
        model.getName().setIsChangable(false);
        model.getName().setInfo("Cannot edit Cluster's Name in tree context");
    }
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle("OK");
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle("Cancel");
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void Edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    ClusterModel model = new ClusterModel();
    model.setEntity(cluster);
    model.Init(true, getGlusterModeEnum());
    setWindow(model);
    model.setTitle("Edit Cluster");
    model.setHashName("edit_cluster");
    model.setOriginalName(cluster.getname());
    model.getName().setEntity(cluster.getname());
    model.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(model);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model1, Object result) {
            ClusterModel clusterModel = (ClusterModel) model1;
            java.util.ArrayList<GlusterVolumeEntity> volumes = (java.util.ArrayList<GlusterVolumeEntity>) result;
            if (volumes.size() != 0) {
                if (cluster.supportsGlusterService()) {
                    clusterModel.getEnableGlusterService().setIsChangable(false);
                }
            }
        }
    };
    AsyncDataProvider.GetVolumeList(asyncQuery, cluster.getname());
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster) {
        model.getName().setIsChangable(false);
        model.getName().setInfo("Cannot edit Cluster's Name in tree context");
    }
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle("OK");
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle("Cancel");
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void OnSaveInternal() {
    ClusterModel model = (ClusterModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    // cancel confirm window if there is
    CancelConfirmation();
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = (Version) model.getVersion().getSelectedItem();
    cluster.setname((String) model.getName().getEntity());
    cluster.setdescription((String) model.getDescription().getEntity());
    cluster.setstorage_pool_id(((storage_pool) model.getDataCenter().getSelectedItem()).getId());
    cluster.setcpu_name(((ServerCpu) model.getCPU().getSelectedItem()).getCpuName());
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setGlusterService((Boolean) model.getEnableGlusterService().getEntity());
    cluster.setVirtService(true);
    model.StartProgress(null);
    Frontend.RunAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            localModel.PostOnSaveInternal(result.getReturnValue());
        }
    }, this);
}
#method_after
public void OnSaveInternal() {
    ClusterModel model = (ClusterModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    // cancel confirm window if there is
    CancelConfirmation();
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = (Version) model.getVersion().getSelectedItem();
    cluster.setname((String) model.getName().getEntity());
    cluster.setdescription((String) model.getDescription().getEntity());
    cluster.setstorage_pool_id(((storage_pool) model.getDataCenter().getSelectedItem()).getId());
    cluster.setcpu_name(((ServerCpu) model.getCPU().getSelectedItem()).getCpuName());
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setGlusterService((Boolean) model.getEnableGlusterService().getEntity());
    model.StartProgress(null);
    Frontend.RunAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            localModel.PostOnSaveInternal(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
@Override
public DevicesResource<Disk, Disks> getDisksResource() {
    return inject(new BackendDisksResource(guid, VdcQueryType.GetAllDisksByVmId, new GetAllDisksByVmIdParameters(guid)));
}
#method_after
@Override
public DisksResource getDisksResource() {
    return inject(new BackendDisksResource(guid, VdcQueryType.GetAllDisksByVmId, new GetAllDisksByVmIdParameters(guid)));
}
#end_block

#method_before
@Override
public BackendVmNicsResource getNicsResource() {
    return inject(new BackendVmNicsResource(guid));
}
#method_after
@Override
public VmNicsResource getNicsResource() {
    return inject(new BackendVmNicsResource(guid));
}
#end_block

#method_before
@Override
public Response activate(Action action) {
    HotPlugDiskToVmParameters params = new HotPlugDiskToVmParameters(((BackendDisksResource) collection).parentId, Guid.createGuidFromString(id));
    return performAction(VdcActionType.HotPlugDiskToVm, params);
}
#method_after
@Override
public Response activate(Action action) {
    HotPlugDiskToVmParameters params = new HotPlugDiskToVmParameters(((BackendDisksResource) collection).parentId, guid);
    return performAction(VdcActionType.HotPlugDiskToVm, params);
}
#end_block

#method_before
@Override
public Response deactivate(Action action) {
    HotPlugDiskToVmParameters params = new HotPlugDiskToVmParameters(((BackendDisksResource) collection).parentId, Guid.createGuidFromString(id));
    return performAction(VdcActionType.HotUnPlugDiskFromVm, params);
}
#method_after
@Override
public Response deactivate(Action action) {
    HotPlugDiskToVmParameters params = new HotPlugDiskToVmParameters(((BackendDisksResource) collection).parentId, guid);
    return performAction(VdcActionType.HotUnPlugDiskFromVm, params);
}
#end_block

#method_before
@Override
protected void ExecuteVdsIdCommand() {
    if (_vdsManager != null) {
        final DestroyVmVDSCommandParameters parameters = getParameters();
        ResourceManager.getInstance().RemoveAsyncRunningVm(parameters.getVmId());
        final VM curVm = DbFacade.getInstance().getVmDAO().get(parameters.getVmId());
        // TODO: This is done to keep consistency with VmDAO.getById(Guid).
        // It should probably be removed, but some research is required.
        curVm.setInterfaces(DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(curVm.getId()));
        DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(parameters);
        vdsBrokerCommand.Execute();
        if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
            if (curVm.getstatus() == VMStatus.Down) {
                getVDSReturnValue().setReturnValue(VMStatus.Down);
            }
            // Updating the DB
            ResourceManager.getInstance().InternalSetVmStatus(curVm, parameters.getGracefully() ? VMStatus.PoweringDown : VMStatus.Down);
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        curVm.guestLogoutTimeTreatmentAfterDestroy();
                        // SaveVmDynamicToDBThreaded(curVm);
                        DbFacade.getInstance().getVmDynamicDAO().update(curVm.getDynamicData());
                        DbFacade.getInstance().getVmStatisticsDAO().update(curVm.getStatisticsData());
                        List<VmNetworkInterface> interfaces = curVm.getInterfaces();
                        if (interfaces != null && interfaces.size() > 0) {
                            for (VmNetworkInterface ifc : interfaces) {
                                VmNetworkStatistics stats = ifc.getStatistics();
                                DbFacade.getInstance().getVmNetworkStatisticsDAO().update(stats);
                            }
                        }
                        // will not be called from UpdateRunTimeInfo
                        if (!parameters.getGracefully()) {
                            ResourceManager.getInstance().getEventListener().processOnVmStop(curVm.getId());
                        }
                    } catch (RepositoryException ex) {
                        log.errorFormat("VDS::destroy Failed to update vds status in database,  vds = {1} : {2}, error = {3}", getVds().getId(), getVds().getvds_name(), ex.getMessage());
                        log.error("Exception: ", ex);
                        throw ex;
                    }
                    getVds().setmem_commited(getVds().getmem_commited() - curVm.getvm_mem_size_mb());
                    getVds().setmem_commited(getVds().getmem_commited() - getVds().getguest_overhead());
                    getVds().setvms_cores_count(getVds().getvms_cores_count() - curVm.getnum_of_cpus());
                    _vdsManager.UpdateDynamicData(getVds().getDynamicData());
                    return null;
                }
            });
            getVDSReturnValue().setReturnValue(curVm.getstatus());
        } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
            log.errorFormat("VDS::destroy Failed destroying vm '{0}' in vds = {1} : {2}, error = {3}", parameters.getVmId(), getVds().getId(), getVds().getvds_name(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
            getVDSReturnValue().setSucceeded(false);
            getVDSReturnValue().setExceptionString(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
            getVDSReturnValue().setExceptionObject(vdsBrokerCommand.getVDSReturnValue().getExceptionObject());
            getVDSReturnValue().setVdsError(vdsBrokerCommand.getVDSReturnValue().getVdsError());
        }
    } else {
        getVDSReturnValue().setSucceeded(false);
    }
}
#method_after
@Override
protected void ExecuteVdsIdCommand() {
    if (_vdsManager != null) {
        final DestroyVmVDSCommandParameters parameters = getParameters();
        ResourceManager.getInstance().RemoveAsyncRunningVm(parameters.getVmId());
        final VM curVm = DbFacade.getInstance().getVmDAO().get(parameters.getVmId());
        curVm.setInterfaces(DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(curVm.getId()));
        DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(parameters);
        vdsBrokerCommand.Execute();
        if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
            if (curVm.getstatus() == VMStatus.Down) {
                getVDSReturnValue().setReturnValue(VMStatus.Down);
            }
            // Updating the DB
            ResourceManager.getInstance().InternalSetVmStatus(curVm, parameters.getGracefully() ? VMStatus.PoweringDown : VMStatus.Down);
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        curVm.guestLogoutTimeTreatmentAfterDestroy();
                        // SaveVmDynamicToDBThreaded(curVm);
                        DbFacade.getInstance().getVmDynamicDAO().update(curVm.getDynamicData());
                        DbFacade.getInstance().getVmStatisticsDAO().update(curVm.getStatisticsData());
                        List<VmNetworkInterface> interfaces = curVm.getInterfaces();
                        if (interfaces != null && interfaces.size() > 0) {
                            for (VmNetworkInterface ifc : interfaces) {
                                VmNetworkStatistics stats = ifc.getStatistics();
                                DbFacade.getInstance().getVmNetworkStatisticsDAO().update(stats);
                            }
                        }
                        // will not be called from UpdateRunTimeInfo
                        if (!parameters.getGracefully()) {
                            ResourceManager.getInstance().getEventListener().processOnVmStop(curVm.getId());
                        }
                    } catch (RepositoryException ex) {
                        log.errorFormat("VDS::destroy Failed to update vds status in database,  vds = {1} : {2}, error = {3}", getVds().getId(), getVds().getvds_name(), ex.getMessage());
                        log.error("Exception: ", ex);
                        throw ex;
                    }
                    getVds().setmem_commited(getVds().getmem_commited() - curVm.getvm_mem_size_mb());
                    getVds().setmem_commited(getVds().getmem_commited() - getVds().getguest_overhead());
                    getVds().setvms_cores_count(getVds().getvms_cores_count() - curVm.getnum_of_cpus());
                    _vdsManager.UpdateDynamicData(getVds().getDynamicData());
                    return null;
                }
            });
            getVDSReturnValue().setReturnValue(curVm.getstatus());
        } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
            log.errorFormat("VDS::destroy Failed destroying vm '{0}' in vds = {1} : {2}, error = {3}", parameters.getVmId(), getVds().getId(), getVds().getvds_name(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
            getVDSReturnValue().setSucceeded(false);
            getVDSReturnValue().setExceptionString(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
            getVDSReturnValue().setExceptionObject(vdsBrokerCommand.getVDSReturnValue().getExceptionObject());
            getVDSReturnValue().setVdsError(vdsBrokerCommand.getVDSReturnValue().getVdsError());
        }
    } else {
        getVDSReturnValue().setSucceeded(false);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    initializeObjectState();
    // Since 'VmId' is overriden, 'Vm' should be retrieved manually.
    VM vm = DbFacade.getInstance().getVmDAO().get(getVmId());
    if (vm != null) {
        // TODO: This is done to be consistent with the behavior of VMDAO.getById.
        // It's probably redundant, but some research is required to validate this.
        VmHandler.updateNetworkInterfacesFromDb(vm);
    }
    setVm(vm);
    getReturnValue().setCanDoAction(validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())));
    if (!ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, true, true, true, true, true, true, true, true, null)) {
        getReturnValue().setCanDoAction(false);
    }
    // check that we are not deleting the template
    if (DbFacade.getInstance().getVmTemplateDAO().get(getSourceImages().get(0).getId()) != null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_IMAGE_TEMPLATE);
        getReturnValue().setCanDoAction(false);
    }
    // check that we are not deleting the vm working snapshot
    if (DbFacade.getInstance().getDiskImageDAO().get(getSourceImages().get(0).getId()) != null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_ACTIVE_IMAGE);
        getReturnValue().setCanDoAction(false);
    }
    if (!getReturnValue().getCanDoAction()) {
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__SNAPSHOT);
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REMOVE);
    }
    return getReturnValue().getCanDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    initializeObjectState();
    // Since 'VmId' is overriden, 'Vm' should be retrieved manually.
    setVm(DbFacade.getInstance().getVmDAO().get(getVmId()));
    getReturnValue().setCanDoAction(validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())));
    if (!ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, true, true, true, true, true, true, true, true, null)) {
        getReturnValue().setCanDoAction(false);
    }
    // check that we are not deleting the template
    if (DbFacade.getInstance().getVmTemplateDAO().get(getSourceImages().get(0).getId()) != null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_IMAGE_TEMPLATE);
        getReturnValue().setCanDoAction(false);
    }
    // check that we are not deleting the vm working snapshot
    if (DbFacade.getInstance().getDiskImageDAO().get(getSourceImages().get(0).getId()) != null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_ACTIVE_IMAGE);
        getReturnValue().setCanDoAction(false);
    }
    if (!getReturnValue().getCanDoAction()) {
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__SNAPSHOT);
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REMOVE);
    }
    return getReturnValue().getCanDoAction();
}
#end_block

#method_before
@Override
protected void ExecuteVdsIdCommand() {
    MigrateVDSCommandParameters parameters = getParameters();
    if (_vdsManager != null) {
        VMStatus retval;
        MigrateBrokerVDSCommand<MigrateVDSCommandParameters> command = new MigrateBrokerVDSCommand<MigrateVDSCommandParameters>(parameters);
        command.Execute();
        VDSReturnValue vdsReturnValue = command.getVDSReturnValue();
        if (vdsReturnValue.getSucceeded()) {
            retval = VMStatus.MigratingFrom;
        } else {
            log.error("VDS::migrate:: Failed migration setting vm status to ERROR");
            retval = VMStatus.NotResponding;
            getVDSReturnValue().setSucceeded(false);
            getVDSReturnValue().setVdsError(vdsReturnValue.getVdsError());
            getVDSReturnValue().setExceptionString(vdsReturnValue.getExceptionString());
            getVDSReturnValue().setExceptionObject(vdsReturnValue.getExceptionObject());
        }
        // update the db
        // VM vm = _vdsManager.VmDict[parameters.VmId];
        final VM vm = DbFacade.getInstance().getVmDAO().get(parameters.getVmId());
        // TODO: This is done to keep consistency with VmDAO.getById(Guid).
        // It should probably be removed, but some research is required.
        vm.setInterfaces(DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()));
        ResourceManager.getInstance().InternalSetVmStatus(vm, retval);
        if (retval == VMStatus.MigratingFrom) {
            vm.setmigrating_to_vds(parameters.getDstVdsId());
            // get vdsEventListener from callback channel (if wcf-user backend) or resource manager
            if (ResourceManager.getInstance().getBackendCallback() != null) {
                ResourceManager.getInstance().AddAsyncRunningVm(parameters.getVmId(), ResourceManager.getInstance().getBackendCallback());
            }
        }
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                DbFacade.getInstance().getVmDynamicDAO().update(vm.getDynamicData());
                return null;
            }
        });
        if (retval == VMStatus.MigratingFrom) {
            UpdateDestinationVdsThreaded(parameters.getDstVdsId(), vm);
        }
        getVDSReturnValue().setReturnValue(retval);
    } else {
        getVDSReturnValue().setSucceeded(false);
    }
}
#method_after
@Override
protected void ExecuteVdsIdCommand() {
    MigrateVDSCommandParameters parameters = getParameters();
    if (_vdsManager != null) {
        VMStatus retval;
        MigrateBrokerVDSCommand<MigrateVDSCommandParameters> command = new MigrateBrokerVDSCommand<MigrateVDSCommandParameters>(parameters);
        command.Execute();
        VDSReturnValue vdsReturnValue = command.getVDSReturnValue();
        if (vdsReturnValue.getSucceeded()) {
            retval = VMStatus.MigratingFrom;
        } else {
            log.error("VDS::migrate:: Failed migration setting vm status to ERROR");
            retval = VMStatus.NotResponding;
            getVDSReturnValue().setSucceeded(false);
            getVDSReturnValue().setVdsError(vdsReturnValue.getVdsError());
            getVDSReturnValue().setExceptionString(vdsReturnValue.getExceptionString());
            getVDSReturnValue().setExceptionObject(vdsReturnValue.getExceptionObject());
        }
        // update the db
        // VM vm = _vdsManager.VmDict[parameters.VmId];
        final VM vm = DbFacade.getInstance().getVmDAO().get(parameters.getVmId());
        ResourceManager.getInstance().InternalSetVmStatus(vm, retval);
        if (retval == VMStatus.MigratingFrom) {
            vm.setmigrating_to_vds(parameters.getDstVdsId());
            // get vdsEventListener from callback channel (if wcf-user backend) or resource manager
            if (ResourceManager.getInstance().getBackendCallback() != null) {
                ResourceManager.getInstance().AddAsyncRunningVm(parameters.getVmId(), ResourceManager.getInstance().getBackendCallback());
            }
        }
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                DbFacade.getInstance().getVmDynamicDAO().update(vm.getDynamicData());
                return null;
            }
        });
        if (retval == VMStatus.MigratingFrom) {
            UpdateDestinationVdsThreaded(parameters.getDstVdsId(), vm);
        }
        getVDSReturnValue().setReturnValue(retval);
    } else {
        getVDSReturnValue().setSucceeded(false);
    }
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    List<VM> vms = DbFacade.getInstance().getVmDAO().getAllForDedicatedPowerClientByVds(getVdsId());
    if (vms != null && vms.size() != 0) {
        vms.get(0).setdedicated_vm_for_vds(null);
        DbFacade.getInstance().getVmStaticDAO().update(vms.get(0).getStaticData());
    }
    VM vm = DbFacade.getInstance().getVmDAO().get(getVmId());
    // TODO: This is done to keep consistency with VmDAO.getById(Guid).
    // It should probably be removed, but some research is required.
    VmHandler.updateNetworkInterfacesFromDb(vm);
    vm.setdedicated_vm_for_vds(!(getVdsId().equals(Guid.Empty)) ? getVdsId() : null);
    DbFacade.getInstance().getVmStaticDAO().update(vm.getStaticData());
    setSucceeded(true);
}
#method_after
@Override
protected void ExecuteVmCommand() {
    List<VM> vms = getVmDAO().getAllForDedicatedPowerClientByVds(getVdsId());
    if (vms != null && vms.size() != 0) {
        vms.get(0).setdedicated_vm_for_vds(null);
        getVmStaticDAO().update(vms.get(0).getStaticData());
    }
    VM vm = getVmDAO().get(getVmId());
    vm.setdedicated_vm_for_vds(!(getVdsId().equals(Guid.Empty)) ? getVdsId() : null);
    getVmStaticDAO().update(vm.getStaticData());
    setSucceeded(true);
}
#end_block

#method_before
public String getRelatedTableNameWithOutTags(String obj) {
    String retval;
    if (obj == null) {
        return null;
    }
    if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        retval = "vdc_users";
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        retval = "vms";
    } else if (StringHelper.EqOp(obj, SearchObjects.DISK_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.DISK_PLU_OBJ_NAME)) {
        retval = "vm_images_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        retval = "vm_templates_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        retval = "vds";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        retval = "vds_groups";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        retval = "storage_pool";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        retval = "storage_domains_without_storage_pools";
    } else {
        retval = getRelatedTableName(obj);
    }
    return retval;
}
#method_after
public String getRelatedTableNameWithOutTags(String obj) {
    String retval;
    if (obj == null) {
        return null;
    }
    if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        retval = "vdc_users";
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        retval = "vms";
    } else if (StringHelper.EqOp(obj, SearchObjects.DISK_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.DISK_PLU_OBJ_NAME)) {
        retval = "vm_images_storage_domains_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        retval = "vm_templates_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        retval = "vds";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        retval = "vds_groups";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        retval = "storage_pool";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        retval = "storage_domains_without_storage_pools";
    } else {
        retval = getRelatedTableName(obj);
    }
    return retval;
}
#end_block

#method_before
public String getRelatedTableName(String obj) {
    String retval = null;
    if (obj == null) {
        return retval;
    }
    if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        retval = "vds_with_tags";
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        retval = "vms_with_tags";
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        retval = "vm_templates_storage_domain";
    } else if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        retval = "audit_log";
    } else if (StringHelper.EqOp(obj, SearchObjects.DISK_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.DISK_PLU_OBJ_NAME)) {
        retval = "vm_images_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        retval = "vdc_users_with_tags";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_POOL_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_POOL_PLU_OBJ_NAME)) {
        retval = "vm_pools_full_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        retval = "vds_groups_storage_domain";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        retval = "storage_pool_with_storage_domain";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        retval = "storage_domains_with_hosts_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_PLU_OBJ_NAME)) {
        retval = "gluster_volumes";
    }
    return retval;
}
#method_after
public String getRelatedTableName(String obj) {
    String retval = null;
    if (obj == null) {
        return retval;
    }
    if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        retval = "vds_with_tags";
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        retval = "vms_with_tags";
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        retval = "vm_templates_storage_domain";
    } else if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        retval = "audit_log";
    } else if (StringHelper.EqOp(obj, SearchObjects.DISK_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.DISK_PLU_OBJ_NAME)) {
        retval = "vm_images_storage_domains_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        retval = "vdc_users_with_tags";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_POOL_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_POOL_PLU_OBJ_NAME)) {
        retval = "vm_pools_full_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        retval = "vds_groups_storage_domain";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        retval = "storage_pool_with_storage_domain";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        retval = "storage_domains_with_hosts_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_PLU_OBJ_NAME)) {
        retval = "gluster_volumes";
    }
    return retval;
}
#end_block

#method_before
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
}
#method_after
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_NETWORK_MTU_DIFFER_FROM_LOGICAL_NETWORK, AuditLogSeverity.WARNING);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getGlusterVolume().isOnline()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_ALREADY_STOPPED);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (!getGlusterVolume().isOnline()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_ALREADY_STOPPED);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getGlusterVolume().isOnline()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_ALREADY_STARTED);
        return false;
    }
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getGlusterVolume().isOnline()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_ALREADY_STARTED);
        return false;
    }
    return true;
}
#end_block

#method_before
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
}
#method_after
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_NETWORK_MTU_DIFFER_FROM_LOGICAL_NETWORK, AuditLogSeverity.WARNING);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeStart(String volumeName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeStart(volumeName, force.toString()));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeStart(String volumeName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeStart(volumeName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
protected String callValidateSession(String sessionID) {
    try {
        // Formatting data
        String data = String.format(SESSION_DATA_FORMAT, URLEncoder.encode(sessionID, "UTF-8"));
        HttpURLConnection servletConnection = createURLConnection();
        if (servletConnection == null) {
            logger.error("Unable to create servlet connection.");
            return null;
        }
        // Sending the sessionID parameter
        DataOutputStream output = new DataOutputStream(servletConnection.getOutputStream());
        output.writeBytes(data);
        output.flush();
        output.close();
        // Checking the result
        if (servletConnection.getResponseCode() != HttpURLConnection.HTTP_OK) {
            logger.error("ValidateSession servlet returned " + servletConnection.getResponseCode());
            return null;
        }
        // Getting the user name
        InputStream inputStream = servletConnection.getInputStream();
        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
        String inputLine;
        inputLine = reader.readLine();
        return inputLine;
    } catch (MalformedURLException e) {
        e.printStackTrace();
        logger.error(e);
        return null;
    } catch (IOException e) {
        e.printStackTrace();
        logger.error(e);
        return null;
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
        logger.error(e);
        return null;
    } catch (CertificateException e) {
        e.printStackTrace();
        logger.error(e);
        return null;
    } catch (KeyStoreException e) {
        e.printStackTrace();
        logger.error(e);
        return null;
    } catch (KeyManagementException e) {
        e.printStackTrace();
        logger.error(e);
        return null;
    }
}
#method_after
protected String callValidateSession(String sessionID) {
    DataOutputStream output = null;
    try {
        // Formatting data
        String data = String.format(SESSION_DATA_FORMAT, URLEncoder.encode(sessionID, "UTF-8"));
        HttpURLConnection servletConnection = createURLConnection();
        if (servletConnection == null) {
            logger.error("Unable to create servlet connection.");
            return null;
        }
        // Sending the sessionID parameter
        output = new DataOutputStream(servletConnection.getOutputStream());
        output.writeBytes(data);
        output.flush();
        output.close();
        // Checking the result
        if (servletConnection.getResponseCode() != HttpURLConnection.HTTP_OK) {
            logger.error("ValidateSession servlet returned " + servletConnection.getResponseCode());
            return null;
        }
        // Getting the user name
        InputStream inputStream = servletConnection.getInputStream();
        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
        String inputLine;
        inputLine = reader.readLine();
        return inputLine;
    } catch (Exception ex) {
        logger.error(ex);
    } finally {
        try {
            if (output != null)
                output.close();
        } catch (IOException ex) {
            logger.error(ex);
        }
    }
    return null;
}
#end_block

#method_before
public UsernamePasswordAuthenticationToken getAuthRequest(HttpServletRequest request, String sessionID) {
    UsernamePasswordAuthenticationToken authRequest = null;
    if (sessionID != null) {
        String result = callValidateSession(sessionID);
        if (result == null) {
            return null;
        } else if (result.isEmpty()) {
            return null;
        }
        String userName = result;
        String password = "";
        userName = userName.trim();
        GrantedAuthority[] grantedAuthorities = new GrantedAuthority[1];
        grantedAuthorities[0] = new GrantedAuthorityImpl("ROLE_ADMINISTRATOR");
        Calendar recheckOn = Calendar.getInstance();
        recheckOn.setTime(new Date());
        recheckOn.add(Calendar.MINUTE, sessionTimeout);
        EngineUserDetails userDetails = new EngineUserDetails(userName, password, grantedAuthorities, sessionID, recheckOn, true, true, true, true);
        authRequest = new UsernamePasswordAuthenticationToken(userDetails, password, grantedAuthorities);
        setDetails(request, authRequest);
    }
    return authRequest;
}
#method_after
public UsernamePasswordAuthenticationToken getAuthRequest(HttpServletRequest request, String sessionID) {
    UsernamePasswordAuthenticationToken authRequest = null;
    if (sessionID != null) {
        String result = callValidateSession(sessionID);
        if (result == null) {
            return null;
        } else if (result.isEmpty()) {
            return null;
        }
        String userName = result;
        String password = "";
        userName = userName.trim();
        GrantedAuthority[] grantedAuthorities = new GrantedAuthority[1];
        grantedAuthorities[0] = new GrantedAuthorityImpl("ROLE_USER");
        Calendar recheckOn = Calendar.getInstance();
        recheckOn.setTime(new Date());
        recheckOn.add(Calendar.MINUTE, pollingTimeout);
        EngineUserDetails userDetails = new EngineUserDetails(userName, password, grantedAuthorities, sessionID, recheckOn, true, true, true, true);
        authRequest = new UsernamePasswordAuthenticationToken(userDetails, password, grantedAuthorities);
        setDetails(request, authRequest);
    }
    return authRequest;
}
#end_block

#method_before
@Test
public void testExecuteQuery() {
    Guid vmID = Guid.NewGuid();
    VM expectedResult = new VM();
    expectedResult.setId(vmID);
    GetVmByVmIdParameters paramsMock = getQueryParameters();
    when(paramsMock.getId()).thenReturn(vmID);
    VmDAO vmDAOMock = mock(VmDAO.class);
    when(vmDAOMock.getById(vmID, getUser().getUserId(), paramsMock.isFiltered())).thenReturn(expectedResult);
    DiskImage disk = new DiskImage();
    disk.setvm_guid(vmID);
    disk.setactive(true);
    DiskImageDAO diskImageDAO = mock(DiskImageDAO.class);
    when(diskImageDAO.getAllForVm(vmID)).thenReturn(Collections.singletonList(disk));
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    when(dbFacadeMock.getVmDAO()).thenReturn(vmDAOMock);
    when(dbFacadeMock.getDiskImageDAO()).thenReturn(diskImageDAO);
    getQuery().executeQueryCommand();
    VM result = (VM) getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("Wrong VM pool returned", expectedResult, result);
    assertEquals("Wrong number of disks on the VM", 1, result.getDiskList().size());
    assertEquals("Wrong disk on the VM", disk, result.getDiskList().get(0));
}
#method_after
@Test
public void testExecuteQuery() {
    Guid vmID = Guid.NewGuid();
    VM expectedResult = new VM();
    expectedResult.setId(vmID);
    GetVmByVmIdParameters paramsMock = getQueryParameters();
    when(paramsMock.getId()).thenReturn(vmID);
    VmDAO vmDAOMock = mock(VmDAO.class);
    when(vmDAOMock.getById(vmID, getUser().getUserId(), paramsMock.isFiltered())).thenReturn(expectedResult);
    DiskImage disk = new DiskImage();
    disk.setvm_guid(vmID);
    disk.setactive(true);
    DiskImageDAO diskImageDAO = mock(DiskImageDAO.class);
    when(diskImageDAO.getAllForVm(vmID)).thenReturn(Collections.singletonList(disk));
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    when(dbFacadeMock.getVmDAO()).thenReturn(vmDAOMock);
    when(dbFacadeMock.getDiskImageDAO()).thenReturn(diskImageDAO);
    getQuery().executeQueryCommand();
    VM result = (VM) getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("Wrong VM returned", expectedResult, result);
    assertEquals("Wrong number of disks on the VM", 1, result.getDiskList().size());
    assertEquals("Wrong disk on the VM", disk, result.getDiskList().get(0));
}
#end_block

#method_before
@Override
public Response add(VM vm) {
    validateParameters(vm, "name", "template.id|name", "cluster.id|name");
    Guid templateId = getTemplateId(vm);
    VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, getMapper(VmTemplate.class, VmStatic.class).map(lookupTemplate(templateId), null));
    if (namedCluster(vm)) {
        staticVm.setvds_group_id(getClusterId(vm));
    }
    // resolve the host's ID, because it will be needed down the line
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
        vm.getPlacementPolicy().getHost().setId(getHostId(vm.getPlacementPolicy().getHost().getName()));
    }
    Response response = null;
    Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
    if (vm.isSetSnapshots() && vm.getSnapshots().getSnapshots() != null && !vm.getSnapshots().getSnapshots().isEmpty()) {
        // If Vm has snapshots collection - this is a clone vm from snapshot operation
        String snapshotId = getSnapshotId(vm.getSnapshots());
        org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getVmConfiguration(snapshotId);
        getMapper(VM.class, VmStatic.class).map(vm, vmConfiguration.getStaticData());
        // If vm passed in the call has disks attached on them,
        // merge their data with the data of the disks on the configuration
        // The parameters to AddVmFromSnapshot hold an array list of Disks
        // and not List of Disks, as this is a GWT serialization limitation,
        // and this parameter class serves GWT clients as well.
        ArrayList<DiskImage> changedDisks = null;
        if (vm.isSetDisks()) {
            Map<Guid, DiskImage> diskImagesById = getDiskImagesByIdMap(vmConfiguration.getDiskMap().values());
            changedDisks = getDiskImagesForCloneFromSnapshotParams(vm.getDisks(), diskImagesById);
        }
        response = cloneVmFromSnapshot(vmConfiguration.getStaticData(), snapshotId, changedDisks);
    } else if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
        // disks are always cloned on the storage-domain, which contains the disk from which they are cloned.
        // therefore, even if user passed storage-domain, it is ignored in this context.
        response = cloneVmFromTemplate(staticVm, vm.getDisks(), templateId);
    } else if (Guid.Empty.equals(templateId)) {
        response = addVmFromScratch(staticVm, storageDomainId, vm.getDisks());
    } else {
        response = addVm(staticVm, storageDomainId, vm.getDisks(), templateId);
    }
    return response;
}
#method_after
@Override
public Response add(VM vm) {
    validateParameters(vm, "name", "template.id|name", "cluster.id|name");
    Guid templateId = getTemplateId(vm);
    VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, getMapper(VmTemplate.class, VmStatic.class).map(lookupTemplate(templateId), null));
    if (namedCluster(vm)) {
        staticVm.setvds_group_id(getClusterId(vm));
    }
    // resolve the host's ID, because it will be needed down the line
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
        vm.getPlacementPolicy().getHost().setId(getHostId(vm.getPlacementPolicy().getHost().getName()));
    }
    Response response = null;
    Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
    if (vm.isSetSnapshots() && vm.getSnapshots().getSnapshots() != null && !vm.getSnapshots().getSnapshots().isEmpty()) {
        // If Vm has snapshots collection - this is a clone vm from snapshot operation
        String snapshotId = getSnapshotId(vm.getSnapshots());
        org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getVmConfiguration(snapshotId);
        getMapper(VM.class, VmStatic.class).map(vm, vmConfiguration.getStaticData());
        // If vm passed in the call has disks attached on them,
        // merge their data with the data of the disks on the configuration
        // The parameters to AddVmFromSnapshot hold an array list of Disks
        // and not List of Disks, as this is a GWT serialization limitation,
        // and this parameter class serves GWT clients as well.
        ArrayList<DiskImage> changedDisks = null;
        if (vm.isSetDisks()) {
            Map<Guid, DiskImage> diskImagesById = getDiskImagesByIdMap(vmConfiguration.getDiskMap().values());
            changedDisks = getDiskImagesForCloneFromSnapshotParams(vm.getDisks(), diskImagesById);
        }
        response = cloneVmFromSnapshot(vmConfiguration.getStaticData(), snapshotId, changedDisks);
    } else if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
        response = cloneVmFromTemplate(staticVm, vm.getDisks(), templateId);
    } else if (Guid.Empty.equals(templateId)) {
        response = addVmFromScratch(staticVm, storageDomainId, vm.getDisks());
    } else {
        response = addVm(staticVm, storageDomainId, vm.getDisks(), templateId);
    }
    return response;
}
#end_block

#method_before
private void updateDefaultQuota() {
    if (_oldStoragePool.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED && getStoragePool().getQuotaEnforcementType() == QuotaEnforcementTypeEnum.DISABLED) {
        RefObject<Boolean> reuseQuota = new RefObject<Boolean>(true);
        Quota newDefaultQuota = getQutoaHelper().getUnlimitedQuota(getStoragePool(), true, reuseQuota);
        if (reuseQuota.argvalue) {
            log.infoFormat("Reusing quota {0} as the default quota for Storage Pool {1}", newDefaultQuota.getId(), newDefaultQuota.getStoragePoolId());
        } else {
            newDefaultQuota.setQuotaName(getQutoaHelper().getDefaultQuotaName(getStoragePool()));
        }
        getQutoaHelper().saveQuotaForUser(newDefaultQuota, MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID, reuseQuota.argvalue);
    }
}
#method_after
private void updateDefaultQuota() {
    if (wasQuotaEnforcementDisabled()) {
        Pair<Quota, Boolean> defaultQuotaPair = getQutoaHelper().getUnlimitedQuota(getStoragePool(), true, true);
        Quota defaultQuota = defaultQuotaPair.getFirst();
        boolean isQuotaReused = defaultQuotaPair.getSecond();
        if (isQuotaReused) {
            log.debugFormat("Reusing quota {0} as the default quota for Storage Pool {1}", defaultQuota.getId(), defaultQuota.getStoragePoolId());
        } else {
            defaultQuota.setQuotaName(getQutoaHelper().getDefaultQuotaName(getStoragePool()));
        }
        getQutoaHelper().saveOrUpdateQuotaForUser(defaultQuota, MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID, isQuotaReused);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = super.canDoAction() && checkStoragePool();
    _oldStoragePool = getStoragePoolDAO().get(getStoragePool().getId());
    if (returnValue && !StringHelper.EqOp(_oldStoragePool.getname(), getStoragePool().getname()) && getStoragePoolDAO().getByName(getStoragePool().getname()) != null) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
    }
    if (returnValue && _oldStoragePool.getstorage_pool_type() != getStoragePool().getstorage_pool_type() && getStorageDomainStaticDAO().getAllForStoragePool(getStoragePool().getId()).size() > 0) {
        returnValue = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_CHANGE_STORAGE_POOL_TYPE_WITH_DOMAINS.toString());
    }
    returnValue = returnValue && CheckStoragePoolNameLengthValid();
    if (returnValue && Version.OpInequality(_oldStoragePool.getcompatibility_version(), getStoragePool().getcompatibility_version())) {
        if (!isVersionSupported()) {
            addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
            returnValue = false;
        } else // decreasing of compatibility version is not allowed
        if (getStoragePool().getcompatibility_version().compareTo(_oldStoragePool.getcompatibility_version()) < 0) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        } else {
            // check all clusters has at least the same compatibility
            // version
            List<VDSGroup> clusters = getVdsGroupDAO().getAllForStoragePool(getStoragePool().getId());
            for (VDSGroup cluster : clusters) {
                if (getStoragePool().getcompatibility_version().compareTo(cluster.getcompatibility_version()) > 0) {
                    returnValue = false;
                    getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_UPDATE_STORAGE_POOL_COMPATIBILITY_VERSION_BIGGER_THAN_CLUSTERS.toString());
                    break;
                }
            }
        }
    }
    returnValue = returnValue && isNotLocalfsWithDefaultCluster();
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = super.canDoAction() && checkStoragePool();
    _oldStoragePool = getStoragePoolDAO().get(getStoragePool().getId());
    if (returnValue && !StringHelper.EqOp(_oldStoragePool.getname(), getStoragePool().getname()) && getStoragePoolDAO().getByName(getStoragePool().getname()) != null) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
    }
    if (returnValue && _oldStoragePool.getstorage_pool_type() != getStoragePool().getstorage_pool_type() && getStorageDomainStaticDAO().getAllForStoragePool(getStoragePool().getId()).size() > 0) {
        returnValue = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_CHANGE_STORAGE_POOL_TYPE_WITH_DOMAINS.toString());
    }
    returnValue = returnValue && CheckStoragePoolNameLengthValid();
    if (returnValue && Version.OpInequality(_oldStoragePool.getcompatibility_version(), getStoragePool().getcompatibility_version())) {
        if (!isStoragePoolVersionSupported()) {
            addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
            returnValue = false;
        } else // decreasing of compatibility version is not allowed
        if (getStoragePool().getcompatibility_version().compareTo(_oldStoragePool.getcompatibility_version()) < 0) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        } else {
            // check all clusters has at least the same compatibility
            // version
            List<VDSGroup> clusters = getVdsGroupDAO().getAllForStoragePool(getStoragePool().getId());
            for (VDSGroup cluster : clusters) {
                if (getStoragePool().getcompatibility_version().compareTo(cluster.getcompatibility_version()) > 0) {
                    returnValue = false;
                    getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_UPDATE_STORAGE_POOL_COMPATIBILITY_VERSION_BIGGER_THAN_CLUSTERS.toString());
                    break;
                }
            }
        }
    }
    returnValue = returnValue && isNotLocalfsWithDefaultCluster();
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = super.canDoAction() && checkStoragePool();
    _oldStoragePool = getStoragePoolDAO().get(getStoragePool().getId());
    if (returnValue && !StringHelper.EqOp(_oldStoragePool.getname(), getStoragePool().getname()) && getStoragePoolDAO().getByName(getStoragePool().getname()) != null) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
    }
    if (returnValue && _oldStoragePool.getstorage_pool_type() != getStoragePool().getstorage_pool_type() && getStorageDomainStaticDAO().getAllForStoragePool(getStoragePool().getId()).size() > 0) {
        returnValue = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_CHANGE_STORAGE_POOL_TYPE_WITH_DOMAINS.toString());
    }
    returnValue = returnValue && CheckStoragePoolNameLengthValid();
    if (returnValue && Version.OpInequality(_oldStoragePool.getcompatibility_version(), getStoragePool().getcompatibility_version())) {
        if (!isVersionSupported()) {
            addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
            returnValue = false;
        } else // decreasing of compatibility version is not allowed
        if (getStoragePool().getcompatibility_version().compareTo(_oldStoragePool.getcompatibility_version()) < 0) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        } else {
            // check all clusters has at least the same compatibility
            // version
            List<VDSGroup> clusters = getVdsGroupDAO().getAllForStoragePool(getStoragePool().getId());
            for (VDSGroup cluster : clusters) {
                if (getStoragePool().getcompatibility_version().compareTo(cluster.getcompatibility_version()) > 0) {
                    returnValue = false;
                    getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_UPDATE_STORAGE_POOL_COMPATIBILITY_VERSION_BIGGER_THAN_CLUSTERS.toString());
                    break;
                }
            }
        }
    }
    returnValue = returnValue && isNotLocalfsWithDefaultCluster();
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = super.canDoAction() && checkStoragePool();
    _oldStoragePool = getStoragePoolDAO().get(getStoragePool().getId());
    if (returnValue && !StringHelper.EqOp(_oldStoragePool.getname(), getStoragePool().getname()) && getStoragePoolDAO().getByName(getStoragePool().getname()) != null) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
    }
    if (returnValue && _oldStoragePool.getstorage_pool_type() != getStoragePool().getstorage_pool_type() && getStorageDomainStaticDAO().getAllForStoragePool(getStoragePool().getId()).size() > 0) {
        returnValue = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_CHANGE_STORAGE_POOL_TYPE_WITH_DOMAINS.toString());
    }
    returnValue = returnValue && CheckStoragePoolNameLengthValid();
    if (returnValue && Version.OpInequality(_oldStoragePool.getcompatibility_version(), getStoragePool().getcompatibility_version())) {
        if (!isStoragePoolVersionSupported()) {
            addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
            returnValue = false;
        } else // decreasing of compatibility version is not allowed
        if (getStoragePool().getcompatibility_version().compareTo(_oldStoragePool.getcompatibility_version()) < 0) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        } else {
            // check all clusters has at least the same compatibility
            // version
            List<VDSGroup> clusters = getVdsGroupDAO().getAllForStoragePool(getStoragePool().getId());
            for (VDSGroup cluster : clusters) {
                if (getStoragePool().getcompatibility_version().compareTo(cluster.getcompatibility_version()) > 0) {
                    returnValue = false;
                    getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_UPDATE_STORAGE_POOL_COMPATIBILITY_VERSION_BIGGER_THAN_CLUSTERS.toString());
                    break;
                }
            }
        }
    }
    returnValue = returnValue && isNotLocalfsWithDefaultCluster();
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    return returnValue;
}
#end_block

#method_before
protected void spyCommand(StoragePoolManagementParameter params) {
    cmd = spy(new UpdateStoragePoolCommand<StoragePoolManagementParameter>(params));
    doReturn(10).when(cmd).getStoragePoolNameSizeLimit();
    doReturn(createVersionSet().contains(cmd.getStoragePool().getcompatibility_version())).when(cmd).isVersionSupported();
    doReturn(spDao).when(cmd).getStoragePoolDAO();
    doReturn(sdDao).when(cmd).getStorageDomainStaticDAO();
    doReturn(vdsDao).when(cmd).getVdsGroupDAO();
}
#method_after
protected void spyCommand(StoragePoolManagementParameter params) {
    cmd = spy(new UpdateStoragePoolCommand<StoragePoolManagementParameter>(params));
    doReturn(10).when(cmd).getStoragePoolNameSizeLimit();
    doReturn(createVersionSet().contains(cmd.getStoragePool().getcompatibility_version())).when(cmd).isStoragePoolVersionSupported();
    doReturn(spDao).when(cmd).getStoragePoolDAO();
    doReturn(sdDao).when(cmd).getStorageDomainStaticDAO();
    doReturn(vdsDao).when(cmd).getVdsGroupDAO();
}
#end_block

#method_before
protected Guid getMasterDomainIdFromDb() {
    if (getStoragePool() != null) {
        return DbFacade.getInstance().getStorageDomainDAO().getMasterStorageDomainIdForPool(getStoragePool().getId());
    }
    return Guid.Empty;
}
#method_after
protected Guid getMasterDomainIdFromDb() {
    Guid ret = Guid.Empty;
    if (getStoragePool() != null) {
        ret = DbFacade.getInstance().getStorageDomainDAO().getMasterStorageDomainIdForPool(getStoragePool().getId());
    }
    return ret;
}
#end_block

#method_before
protected void CalcStoragePoolStatusByDomainsStatus() {
    List<storage_domains> domains = DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(getStoragePool().getId());
    storage_domains masterDomain = LinqUtils.firstOrNull(domains, new Predicate<storage_domains>() {

        @Override
        public boolean eval(storage_domains a) {
            return a.getstorage_domain_type() == StorageDomainType.Master;
        }
    });
    // if no master then Uninitialized
    // if master not active maintenance
    StoragePoolStatus newStatus = (masterDomain == null) ? StoragePoolStatus.Uninitialized : (masterDomain.getstatus() != null && masterDomain.getstatus() == StorageDomainStatus.Maintenance) ? StoragePoolStatus.Maintanance : (masterDomain.getstatus() != null && masterDomain.getstatus() == StorageDomainStatus.Active) ? StoragePoolStatus.Up : StoragePoolStatus.Problematic;
    if (newStatus != getStoragePool().getstatus()) {
        getCompensationContext().snapshotEntity(getStoragePool());
        getStoragePool().setstatus(newStatus);
        storage_pool poolFromDb = DbFacade.getInstance().getStoragePoolDAO().get(getStoragePool().getId());
        if ((getStoragePool().getspm_vds_id() == null && poolFromDb.getspm_vds_id() != null) || (getStoragePool().getspm_vds_id() != null && !getStoragePool().getspm_vds_id().equals(poolFromDb.getspm_vds_id()))) {
            getStoragePool().setspm_vds_id(poolFromDb.getspm_vds_id());
        }
        if (getStoragePool().getstatus() == StoragePoolStatus.Uninitialized) {
            getStoragePool().setspm_vds_id(null);
        }
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<storage_pool>() {

            @Override
            public storage_pool runInTransaction() {
                DbFacade.getInstance().getStoragePoolDAO().update(getStoragePool());
                return null;
            }
        });
        StoragePoolStatusHandler.PoolStatusChanged(getStoragePool().getId(), getStoragePool().getstatus());
    }
}
#method_after
protected void CalcStoragePoolStatusByDomainsStatus() {
    List<storage_domains> domains = DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(getStoragePool().getId());
    // set masterDomain to the first element of domains with type=master, or null if non have this type.
    storage_domains masterDomain = LinqUtils.firstOrNull(domains, new Predicate<storage_domains>() {

        @Override
        public boolean eval(storage_domains a) {
            return a.getstorage_domain_type() == StorageDomainType.Master;
        }
    });
    // if no master then Uninitialized
    // if master not active maintenance
    StoragePoolStatus newStatus = (masterDomain == null) ? StoragePoolStatus.Uninitialized : (masterDomain.getstatus() != null && masterDomain.getstatus() == StorageDomainStatus.Maintenance) ? StoragePoolStatus.Maintanance : (masterDomain.getstatus() != null && masterDomain.getstatus() == StorageDomainStatus.Active) ? StoragePoolStatus.Up : StoragePoolStatus.Problematic;
    if (newStatus != getStoragePool().getstatus()) {
        getCompensationContext().snapshotEntity(getStoragePool());
        getStoragePool().setstatus(newStatus);
        storage_pool poolFromDb = DbFacade.getInstance().getStoragePoolDAO().get(getStoragePool().getId());
        if ((getStoragePool().getspm_vds_id() == null && poolFromDb.getspm_vds_id() != null) || (getStoragePool().getspm_vds_id() != null && !getStoragePool().getspm_vds_id().equals(poolFromDb.getspm_vds_id()))) {
            getStoragePool().setspm_vds_id(poolFromDb.getspm_vds_id());
        }
        if (getStoragePool().getstatus() == StoragePoolStatus.Uninitialized) {
            getStoragePool().setspm_vds_id(null);
        }
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<storage_pool>() {

            @Override
            public storage_pool runInTransaction() {
                DbFacade.getInstance().getStoragePoolDAO().update(getStoragePool());
                return null;
            }
        });
        StoragePoolStatusHandler.PoolStatusChanged(getStoragePool().getId(), getStoragePool().getstatus());
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!QuotaHelper.getInstance().checkQuotaValidationForAddEdit(getParameters().getQuota(), getReturnValue().getCanDoActionMessages())) {
        return false;
    } else if (getParameters().getQuota().getId() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID);
        return false;
    } else if (getQuotaDAO().getById(getParameters().getQuota().getId()) == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!QuotaHelper.getInstance().checkQuotaValidationForEdit(getParameters().getQuota(), getReturnValue().getCanDoActionMessages())) {
        return false;
    } else if (getParameters().getQuota().getId() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID);
        return false;
    } else if (getQuotaDAO().getById(getParameters().getQuota().getId()) == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    return true;
}
#end_block

#method_before
private Quota generateUnlimitedQuota(storage_pool storagePool) {
    // Set new Quota definition.
    Quota quota = new Quota();
    Guid quotaId = Guid.NewGuid();
    quota.setId(quotaId);
    quota.setStoragePoolId(storagePool.getId());
    quota.setQuotaName(getDefaultQuotaName(storagePool));
    quota.setDescription("Automatic generated Quota for Data Center " + storagePool.getname());
    quota.setThresholdVdsGroupPercentage(getIntegerConfig(ConfigValues.QuotaThresholdVdsGroup));
    quota.setThresholdStoragePercentage(getIntegerConfig(ConfigValues.QuotaThresholdStorage));
    quota.setGraceVdsGroupPercentage(getIntegerConfig(ConfigValues.QuotaGraceVdsGroup));
    quota.setGraceStoragePercentage(getIntegerConfig(ConfigValues.QuotaGraceStorage));
    quota.setQuotaVdsGroups(new ArrayList<QuotaVdsGroup>());
    quota.setQuotaStorages(new ArrayList<QuotaStorage>());
    // Set Quota storage capacity definition.
    QuotaStorage quotaStorage = new QuotaStorage();
    quotaStorage.setStorageSizeGB(UNLIMITED);
    quota.setGlobalQuotaStorage(quotaStorage);
    // Set Quota cluster virtual memory definition and virtual CPU definition.
    QuotaVdsGroup quotaVdsGroup = new QuotaVdsGroup();
    quotaVdsGroup.setVirtualCpu(UNLIMITED.intValue());
    quotaVdsGroup.setMemSizeMB(UNLIMITED);
    quota.setGlobalQuotaVdsGroup(quotaVdsGroup);
    return quota;
}
#method_after
private Quota generateUnlimitedQuota(storage_pool storagePool) {
    // Set new Quota definition.
    Quota quota = new Quota();
    Guid quotaId = Guid.NewGuid();
    quota.setId(quotaId);
    quota.setStoragePoolId(storagePool.getId());
    quota.setQuotaName(getDefaultQuotaName(storagePool));
    quota.setDescription("Automatic generated Quota for Data Center " + storagePool.getname());
    quota.setThresholdVdsGroupPercentage(getQuotaThresholdVdsGroup());
    quota.setThresholdStoragePercentage(getQuotaThresholdStorage());
    quota.setGraceVdsGroupPercentage(getQuotaGraceVdsGroup());
    quota.setGraceStoragePercentage(getQuotaGraceStorage());
    quota.setQuotaVdsGroups(new ArrayList<QuotaVdsGroup>());
    quota.setQuotaStorages(new ArrayList<QuotaStorage>());
    // Set Quota storage capacity definition.
    QuotaStorage quotaStorage = new QuotaStorage();
    quotaStorage.setStorageSizeGB(UNLIMITED);
    quota.setGlobalQuotaStorage(quotaStorage);
    // Set Quota cluster virtual memory definition and virtual CPU definition.
    QuotaVdsGroup quotaVdsGroup = new QuotaVdsGroup();
    quotaVdsGroup.setVirtualCpu(UNLIMITED.intValue());
    quotaVdsGroup.setMemSizeMB(UNLIMITED);
    quota.setGlobalQuotaVdsGroup(quotaVdsGroup);
    return quota;
}
#end_block

#method_before
public void saveQuotaForUser(Quota quota, Guid ad_element_id) {
    saveQuotaForUser(quota, ad_element_id, false);
}
#method_after
public void saveQuotaForUser(Quota quota, Guid ad_element_id) {
    saveOrUpdateQuotaForUser(quota, ad_element_id, false);
}
#end_block

#method_before
protected Integer getIntegerConfig(ConfigValues value) {
    return Config.GetValue(value);
}
#method_after
private static int getIntegerConfig(ConfigValues value) {
    return Config.<Integer>GetValue(value);
}
#end_block

#method_before
public void saveQuotaForUser(Quota quota, Guid ad_element_id) {
    saveQuotaForUser(quota, ad_element_id, false);
}
#method_after
public void saveQuotaForUser(Quota quota, Guid ad_element_id) {
    saveOrUpdateQuotaForUser(quota, ad_element_id, false);
}
#end_block

#method_before
public Quota getUnlimitedQuota(storage_pool storagePool, boolean isDefaultQuota) {
    if (storagePool == null || storagePool.getId() == null) {
        log.error("Unlimited Quota cannot be created, Storage pool is not valid ");
        return null;
    }
    // Set new Quota definition.
    Quota quota = new Quota();
    Guid quotaId = Guid.NewGuid();
    quota.setId(quotaId);
    quota.setStoragePoolId(storagePool.getId());
    quota.setQuotaName(getDefaultQuotaName(storagePool));
    quota.setDescription("Automatic generated Quota for Data Center " + storagePool.getname());
    quota.setThresholdVdsGroupPercentage(getIntegerConfig(ConfigValues.QuotaThresholdVdsGroup));
    quota.setThresholdStoragePercentage(getIntegerConfig(ConfigValues.QuotaThresholdStorage));
    quota.setGraceVdsGroupPercentage(getIntegerConfig(ConfigValues.QuotaGraceVdsGroup));
    quota.setGraceStoragePercentage(getIntegerConfig(ConfigValues.QuotaGraceStorage));
    quota.setIsDefaultQuota(isDefaultQuota);
    quota.setQuotaVdsGroups(new ArrayList<QuotaVdsGroup>());
    quota.setQuotaStorages(new ArrayList<QuotaStorage>());
    // Set Quota storage capacity definition.
    QuotaStorage quotaStorage = new QuotaStorage();
    quotaStorage.setStorageSizeGB(UNLIMITED);
    quota.setGlobalQuotaStorage(quotaStorage);
    // Set Quota cluster virtual memory definition and virtual CPU definition.
    QuotaVdsGroup quotaVdsGroup = new QuotaVdsGroup();
    quotaVdsGroup.setVirtualCpu(UNLIMITED.intValue());
    quotaVdsGroup.setMemSizeMB(UNLIMITED);
    quota.setGlobalQuotaVdsGroup(quotaVdsGroup);
    return quota;
}
#method_after
public Quota getUnlimitedQuota(storage_pool storagePool, boolean isDefaultQuota) {
    if (storagePool == null || storagePool.getId() == null) {
        log.error("Unlimited Quota cannot be created, Storage pool is not valid ");
        return null;
    }
    // Set new Quota definition.
    Quota quota = new Quota();
    Guid quotaId = Guid.NewGuid();
    quota.setId(quotaId);
    quota.setStoragePoolId(storagePool.getId());
    quota.setQuotaName(getDefaultQuotaName(storagePool));
    quota.setDescription("Automatic generated Quota for Data Center " + storagePool.getname());
    quota.setThresholdVdsGroupPercentage(getQuotaThresholdVdsGroup());
    quota.setThresholdStoragePercentage(getQuotaThresholdStorage());
    quota.setGraceVdsGroupPercentage(getQuotaGraceVdsGroup());
    quota.setGraceStoragePercentage(getQuotaGraceStorage());
    quota.setIsDefaultQuota(isDefaultQuota);
    quota.setQuotaVdsGroups(new ArrayList<QuotaVdsGroup>());
    quota.setQuotaStorages(new ArrayList<QuotaStorage>());
    // Set Quota storage capacity definition.
    QuotaStorage quotaStorage = new QuotaStorage();
    quotaStorage.setStorageSizeGB(UNLIMITED);
    quota.setGlobalQuotaStorage(quotaStorage);
    // Set Quota cluster virtual memory definition and virtual CPU definition.
    QuotaVdsGroup quotaVdsGroup = new QuotaVdsGroup();
    quotaVdsGroup.setVirtualCpu(UNLIMITED.intValue());
    quotaVdsGroup.setMemSizeMB(UNLIMITED);
    quota.setGlobalQuotaVdsGroup(quotaVdsGroup);
    return quota;
}
#end_block

#method_before
protected Integer getIntegerConfig(ConfigValues value) {
    return Config.GetValue(value);
}
#method_after
private static int getIntegerConfig(ConfigValues value) {
    return Config.<Integer>GetValue(value);
}
#end_block

#method_before
private void mockConfig() {
    doReturn(80).when(quotaHelper).getIntegerConfig(ConfigValues.QuotaThresholdVdsGroup);
    doReturn(80).when(quotaHelper).getIntegerConfig(ConfigValues.QuotaThresholdStorage);
    doReturn(20).when(quotaHelper).getIntegerConfig(ConfigValues.QuotaGraceVdsGroup);
    doReturn(20).when(quotaHelper).getIntegerConfig(ConfigValues.QuotaGraceStorage);
}
#method_after
private void mockConfig() {
    doReturn(80).when(quotaHelper).getQuotaThresholdVdsGroup();
    doReturn(80).when(quotaHelper).getQuotaThresholdStorage();
    doReturn(20).when(quotaHelper).getQuotaGraceVdsGroup();
    doReturn(20).when(quotaHelper).getQuotaGraceStorage();
}
#end_block

#method_before
@Before
public void setUp() {
    setUpPoolToAdd();
    setUpCommandWithMocks();
}
#method_after
@Before
public void setUp() {
    initMocks(this);
    setUpPoolToAdd();
    setUpCommandWithMocks();
}
#end_block

#method_before
protected void setUpPoolToAdd() {
    poolToAdd = new storage_pool();
    poolToAdd.setname(RandomUtils.instance().nextString(10));
    poolToAdd.setId(Guid.NewGuid());
}
#method_after
protected void setUpPoolToAdd() {
    poolToAdd = new storage_pool();
    poolToAdd.setname(RandomUtils.instance().nextString(10));
    poolToAdd.setId(Guid.NewGuid());
    poolToAdd.setQuotaEnforcementType(type);
}
#end_block

#method_before
private Quota generateQuotaForNewStoragePool() {
    boolean isDefaultQuota = (getStoragePool().getQuotaEnforcementType() == QuotaEnforcementTypeEnum.DISABLED);
    Quota defaultStoragePoolQuota = getQuotaHelper().getUnlimitedQuota(getStoragePool(), isDefaultQuota);
    return defaultStoragePoolQuota;
}
#method_after
private Quota generateQuotaForNewStoragePool() {
    return getQuotaHelper().getUnlimitedQuota(getStoragePool(), true);
}
#end_block

#method_before
private void validateSession(String sessionID) {
    getQueryReturnValue().setSucceeded(false);
    if (sessionID != null) {
        log.debug("Input session ID is: " + sessionID);
        VdcUser vdcUser = (VdcUser) SessionDataContainer.getInstance().GetData(sessionID, USER_SESSION_KEY);
        if (vdcUser != null) {
            log.debug("Found session user");
            getQueryReturnValue().setReturnValue(vdcUser);
            getQueryReturnValue().setSucceeded(true);
        } else {
            log.debug("Didn't find session user");
        }
    }
}
#method_after
private void validateSession(String sessionID) {
    getQueryReturnValue().setSucceeded(false);
    if (sessionID != null) {
        log.debug("Input session ID is: " + sessionID);
        VdcUser vdcUser = (VdcUser) getSessionUser(sessionID);
        if (vdcUser != null) {
            log.debug("Found session user");
            getQueryReturnValue().setReturnValue(vdcUser);
            getQueryReturnValue().setSucceeded(true);
        } else {
            log.debug("Didn't find session user");
        }
    }
}
#end_block

#method_before
@Test
public void testGetRelevantQuotasExistingVdsGroupNoSpecificQuotas() throws Exception {
    // there are no specific quotas, but all the general quotas relate to the storage pool containing this group
    assertGetAllRelevantQuoatsForVdsGroup(FixturesTool.VDS_GROUP_RHEL6_NFS_OTHER, NUM_QUOTAS - 1);
}
#method_after
@Test
public void testGetRelevantQuotasExistingVdsGroupNoSpecificQuotas() throws Exception {
    // there are no specific quotas, but all the general quotas relate to the storage pool containing this group
    assertGetAllRelevantQuoatsForVdsGroup(FixturesTool.VDS_GROUP_RHEL6_NFS_NO_SPECIFIC_QUOTAS, NUM_QUOTAS - 1);
}
#end_block

#method_before
@Test
public void testGetRelevantQuotasExistingVdsGroupNoSpecificQuotas() throws Exception {
    // there are no specific quotas, but all the general quotas relate to the storage pool containing this group
    assertGetAllRelevantQuoatsForVdsGroup(FixturesTool.VDS_GROUP_RHEL6_NFS_OTHER, NUM_QUOTAS - 1);
}
#method_after
@Test
public void testGetRelevantQuotasExistingVdsGroupNoSpecificQuotas() throws Exception {
    // there are no specific quotas, but all the general quotas relate to the storage pool containing this group
    assertGetAllRelevantQuoatsForVdsGroup(FixturesTool.VDS_GROUP_RHEL6_NFS_NO_SPECIFIC_QUOTAS, NUM_QUOTAS - 1);
}
#end_block

#method_before
@Test
public void testGetRelevantQuotasExistingVdsGroupNoSpecificQuotas() throws Exception {
    // there are no specific quotas, but all the general quotas relate to the storage pool containing this group
    assertGetAllRelevantQuoatsForVdsGroup(FixturesTool.VDS_GROUP_RHEL6_NFS_OTHER, NUM_QUOTAS - 1);
}
#method_after
@Test
public void testGetRelevantQuotasExistingVdsGroupNoSpecificQuotas() throws Exception {
    // there are no specific quotas, but all the general quotas relate to the storage pool containing this group
    assertGetAllRelevantQuoatsForVdsGroup(FixturesTool.VDS_GROUP_RHEL6_NFS_NO_SPECIFIC_QUOTAS, NUM_QUOTAS - 1);
}
#end_block

#method_before
private <T extends QuotaStorageProperties> ParameterizedRowMapper<QuotaVdsGroup> getVdsGroupQuotaResultSet() {
    ParameterizedRowMapper<QuotaVdsGroup> mapperQuotaLimitation = new ParameterizedRowMapper<QuotaVdsGroup>() {

        @Override
        public QuotaVdsGroup mapRow(ResultSet rs, int rowNum) throws SQLException {
            QuotaVdsGroup entity = new QuotaVdsGroup();
            entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
            entity.setQuotaVdsGroupId(Guid.createGuidFromString(rs.getString("quota_vds_group_id")));
            entity.setVdsGroupId(Guid.createGuidFromString(rs.getString("vds_group_id")));
            entity.setVdsGroupName(rs.getString("vds_group_name"));
            mapVdsGroupResultSet(rs, entity);
            return entity;
        }
    };
    return mapperQuotaLimitation;
}
#method_after
private ParameterizedRowMapper<QuotaVdsGroup> getVdsGroupQuotaResultSet() {
    ParameterizedRowMapper<QuotaVdsGroup> mapperQuotaLimitation = new ParameterizedRowMapper<QuotaVdsGroup>() {

        @Override
        public QuotaVdsGroup mapRow(ResultSet rs, int rowNum) throws SQLException {
            QuotaVdsGroup entity = new QuotaVdsGroup();
            entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
            entity.setQuotaVdsGroupId(Guid.createGuidFromString(rs.getString("quota_vds_group_id")));
            entity.setVdsGroupId(Guid.createGuidFromString(rs.getString("vds_group_id")));
            entity.setVdsGroupName(rs.getString("vds_group_name"));
            entity.setMemSizeMB((Long) rs.getObject("mem_size_mb"));
            entity.setMemSizeMBUsage((Long) rs.getObject("mem_size_mb_usage"));
            entity.setVirtualCpu((Integer) rs.getObject("virtual_cpu"));
            entity.setVirtualCpuUsage((Integer) rs.getObject("virtual_cpu_usage"));
            return entity;
        }
    };
    return mapperQuotaLimitation;
}
#end_block

#method_before
private ParameterizedRowMapper<QuotaStorage> getQuotaStorageResultSet() {
    ParameterizedRowMapper<QuotaStorage> mapperQuotaLimitation = new ParameterizedRowMapper<QuotaStorage>() {

        @Override
        public QuotaStorage mapRow(ResultSet rs, int rowNum) throws SQLException {
            QuotaStorage entity = new QuotaStorage();
            entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
            entity.setQuotaStorageId(Guid.createGuidFromString(rs.getString("quota_storage_id")));
            entity.setStorageId(Guid.createGuidFromString(rs.getString("storage_id")));
            entity.setStorageName(rs.getString("storage_name"));
            mapStorageResultSet(rs, entity);
            return entity;
        }
    };
    return mapperQuotaLimitation;
}
#method_after
private ParameterizedRowMapper<QuotaStorage> getQuotaStorageResultSet() {
    ParameterizedRowMapper<QuotaStorage> mapperQuotaLimitation = new ParameterizedRowMapper<QuotaStorage>() {

        @Override
        public QuotaStorage mapRow(ResultSet rs, int rowNum) throws SQLException {
            QuotaStorage entity = new QuotaStorage();
            entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
            entity.setQuotaStorageId(Guid.createGuidFromString(rs.getString("quota_storage_id")));
            entity.setStorageId(Guid.createGuidFromString(rs.getString("storage_id")));
            entity.setStorageName(rs.getString("storage_name"));
            entity.setStorageSizeGB((Long) rs.getObject("storage_size_gb"));
            entity.setStorageSizeGBUsage((Double) rs.getObject("storage_size_gb_usage"));
            return entity;
        }
    };
    return mapperQuotaLimitation;
}
#end_block

#method_before
private ParameterizedRowMapper<Quota> getQuotaFromResultSet() {
    ParameterizedRowMapper<Quota> mapper = new ParameterizedRowMapper<Quota>() {

        @Override
        public Quota mapRow(ResultSet rs, int rowNum) throws SQLException {
            Quota entity = getQuotaMetaDataFromResultSet(rs);
            mapVdsGroupResultSet(rs, entity);
            mapStorageResultSet(rs, entity);
            return entity;
        }
    };
    return mapper;
}
#method_after
private ParameterizedRowMapper<Quota> getQuotaFromResultSet() {
    ParameterizedRowMapper<Quota> mapper = new ParameterizedRowMapper<Quota>() {

        @Override
        public Quota mapRow(ResultSet rs, int rowNum) throws SQLException {
            Quota entity = getQuotaMetaDataFromResultSet(rs);
            // not, since global limitation must be for all the quota vds group parameters.
            if (rs.getObject("mem_size_mb") != null) {
                // Set global vds group quota.
                QuotaVdsGroup vdsGroupEntity = new QuotaVdsGroup();
                vdsGroupEntity.setMemSizeMB((Long) rs.getObject("mem_size_mb"));
                vdsGroupEntity.setMemSizeMBUsage((Long) rs.getObject("mem_size_mb_usage"));
                vdsGroupEntity.setVirtualCpu((Integer) rs.getObject("virtual_cpu"));
                vdsGroupEntity.setVirtualCpuUsage((Integer) rs.getObject("virtual_cpu_usage"));
                entity.setGlobalQuotaVdsGroup(vdsGroupEntity);
            }
            // not.
            if (rs.getObject("storage_size_gb") != null) {
                // Set global storage quota.
                QuotaStorage storageEntity = new QuotaStorage();
                storageEntity.setStorageSizeGB((Long) rs.getObject("storage_size_gb"));
                storageEntity.setStorageSizeGBUsage((Double) rs.getObject("storage_size_gb_usage"));
                entity.setGlobalQuotaStorage(storageEntity);
            }
            return entity;
        }
    };
    return mapper;
}
#end_block

#method_before
private MapSqlParameterSource getQuotaStorageParameterMap(Guid quotaId, QuotaStorage quotaStorage) {
    MapSqlParameterSource storageQuotaParameterMap = createQuotaIdParameterMapper(quotaStorage.getQuotaStorageId()).addValue("quota_id", quotaId).addValue("storage_id", quotaStorage.getStorageId()).addValue("vds_group_id", null);
    addQuotaStorageLimitMapper(quotaStorage, storageQuotaParameterMap);
    // Add null to storage parameter map to indicate the limit is only for specific storage.
    addQuotaVdsGroupLimitMapper(null, storageQuotaParameterMap);
    return storageQuotaParameterMap;
}
#method_after
private MapSqlParameterSource getQuotaStorageParameterMap(Guid quotaId, QuotaStorage quotaStorage) {
    MapSqlParameterSource storageQuotaParameterMap = createQuotaIdParameterMapper(quotaStorage.getQuotaStorageId()).addValue("quota_id", quotaId).addValue("storage_id", quotaStorage.getStorageId()).addValue("vds_group_id", null).addValue("storage_size_gb", quotaStorage.getStorageSizeGB()).addValue("virtual_cpu", null).addValue("mem_size_mb", null);
    return storageQuotaParameterMap;
}
#end_block

#method_before
private MapSqlParameterSource getQuotaVdsGroupParameterMap(Guid quotaId, QuotaVdsGroup quotaVdsGroup) {
    MapSqlParameterSource vdsGroupQuotaParameterMap = createQuotaIdParameterMapper(quotaVdsGroup.getQuotaVdsGroupId()).addValue("quota_id", quotaId).addValue("vds_group_id", quotaVdsGroup.getVdsGroupId()).addValue("storage_id", null);
    // Add null to vds group parameter map to indicate the limit is only for specific vdsGroup.
    addQuotaStorageLimitMapper(null, vdsGroupQuotaParameterMap);
    addQuotaVdsGroupLimitMapper(quotaVdsGroup, vdsGroupQuotaParameterMap);
    return vdsGroupQuotaParameterMap;
}
#method_after
private MapSqlParameterSource getQuotaVdsGroupParameterMap(Guid quotaId, QuotaVdsGroup quotaVdsGroup) {
    MapSqlParameterSource vdsGroupQuotaParameterMap = createQuotaIdParameterMapper(quotaVdsGroup.getQuotaVdsGroupId()).addValue("quota_id", quotaId).addValue("vds_group_id", quotaVdsGroup.getVdsGroupId()).addValue("storage_id", null).addValue("storage_size_gb", null).addValue("virtual_cpu", quotaVdsGroup.getVirtualCpu()).addValue("mem_size_mb", quotaVdsGroup.getMemSizeMB());
    return vdsGroupQuotaParameterMap;
}
#end_block

#method_before
private MapSqlParameterSource getFullQuotaParameterMap(Quota quota) {
    MapSqlParameterSource quotaParameterMap = getCustomMapSqlParameterSource().addValue("id", quota.getId()).addValue("quota_id", quota.getId()).addValue("vds_group_id", null).addValue("storage_id", null);
    addQuotaStorageLimitMapper(quota, quotaParameterMap);
    addQuotaVdsGroupLimitMapper(quota, quotaParameterMap);
    return quotaParameterMap;
}
#method_after
private MapSqlParameterSource getFullQuotaParameterMap(Quota quota) {
    MapSqlParameterSource quotaParameterMap = getCustomMapSqlParameterSource().addValue("id", quota.getId()).addValue("quota_id", quota.getId()).addValue("vds_group_id", null).addValue("storage_id", null).addValue("storage_size_gb", quota.getGlobalQuotaStorage() != null ? quota.getGlobalQuotaStorage().getStorageSizeGB() : null).addValue("virtual_cpu", quota.getGlobalQuotaVdsGroup() != null ? quota.getGlobalQuotaVdsGroup().getVirtualCpu() : null).addValue("mem_size_mb", quota.getGlobalQuotaVdsGroup() != null ? quota.getGlobalQuotaVdsGroup().getMemSizeMB() : null);
    return quotaParameterMap;
}
#end_block

#method_before
@Test
public void testSpecificAndGeneralQuotaLimitations() throws Exception {
    // Set new Quota definition.
    Quota quota = new Quota();
    Guid quotaId = Guid.NewGuid();
    quota.setId(quotaId);
    quota.setStoragePoolId(FixturesTool.STORAGE_POOL_NFS);
    quota.setQuotaName("Watson");
    quota.setDescription("General and specific quota");
    quota.setThresholdVdsGroupPercentage(Config.<Integer>GetValue(ConfigValues.QuotaThresholdVdsGroup));
    quota.setThresholdStoragePercentage(Config.<Integer>GetValue(ConfigValues.QuotaThresholdStorage));
    quota.setGraceVdsGroupPercentage(Config.<Integer>GetValue(ConfigValues.QuotaGraceVdsGroup));
    quota.setGraceStoragePercentage(Config.<Integer>GetValue(ConfigValues.QuotaGraceStorage));
    quota.setQuotaVdsGroups(getQuotaVdsGroup(getSpecificQuotaVdsGroup(quotaId)));
    quota.setQuotaStorages(getQuotaStorage(null));
    quota.setStorageSizeGB(10000l);
    quota.setStorageSizeGBUsage(0d);
    dao.save(quota);
    Quota quotaEntity = dao.getById(quota.getId());
    assertNotNull(quotaEntity);
    assertEquals(quotaEntity, quota);
}
#method_after
@Test
public void testSpecificAndGeneralQuotaLimitations() throws Exception {
    // Set new Quota definition.
    Quota quota = new Quota();
    Guid quotaId = Guid.NewGuid();
    quota.setId(quotaId);
    quota.setStoragePoolId(FixturesTool.STORAGE_POOL_NFS);
    quota.setQuotaName("Watson");
    quota.setDescription("General and specific quota");
    quota.setThresholdVdsGroupPercentage(Config.<Integer>GetValue(ConfigValues.QuotaThresholdVdsGroup));
    quota.setThresholdStoragePercentage(Config.<Integer>GetValue(ConfigValues.QuotaThresholdStorage));
    quota.setGraceVdsGroupPercentage(Config.<Integer>GetValue(ConfigValues.QuotaGraceVdsGroup));
    quota.setGraceStoragePercentage(Config.<Integer>GetValue(ConfigValues.QuotaGraceStorage));
    quota.setQuotaVdsGroups(getQuotaVdsGroup(getSpecificQuotaVdsGroup(quotaId)));
    quota.setQuotaStorages(getQuotaStorage(null));
    quota.setGlobalQuotaStorage(new QuotaStorage(null, null, null, 10000l, 0d));
    dao.save(quota);
    Quota quotaEntity = dao.getById(quota.getId());
    assertNotNull(quotaEntity);
    assertEquals(quotaEntity, quota);
}
#end_block

#method_before
@Test
public void testUpdateQuota() throws Exception {
    Quota quotaGeneralToSpecific = dao.getById(FixturesTool.QUOTA_GENERAL);
    // Save quotaName and vdsGroup list for future check.
    String quotaName = "New Temporary name";
    List<QuotaVdsGroup> quotaVdsGroupList = getQuotaVdsGroup(getSpecificQuotaVdsGroup(quotaGeneralToSpecific.getId()));
    Long newStorageLimit = new Long("2345");
    // Check before the update, that the fields are not equal.
    assertEquals(quotaName.equals(quotaGeneralToSpecific.getQuotaName()), false);
    assertEquals(quotaVdsGroupList.size() == quotaGeneralToSpecific.getQuotaVdsGroups().size(), false);
    assertEquals(quotaGeneralToSpecific.getStorageSizeGB().equals(newStorageLimit), false);
    // Update
    quotaGeneralToSpecific.setQuotaName(quotaName);
    quotaGeneralToSpecific.setStorageSizeGB(newStorageLimit);
    quotaGeneralToSpecific.setQuotaVdsGroups(quotaVdsGroupList);
    dao.update(quotaGeneralToSpecific);
    quotaGeneralToSpecific = dao.getById(FixturesTool.QUOTA_GENERAL);
    // Check after the update, that the fields are equal now.
    assertEquals(quotaName.equals(quotaGeneralToSpecific.getQuotaName()), true);
    assertEquals(quotaVdsGroupList.size() == quotaGeneralToSpecific.getQuotaVdsGroups().size(), true);
    assertEquals(quotaGeneralToSpecific.getStorageSizeGB().equals(newStorageLimit), true);
}
#method_after
@Test
public void testUpdateQuota() throws Exception {
    Quota quotaGeneralToSpecific = dao.getById(FixturesTool.QUOTA_GENERAL);
    // Save quotaName and vdsGroup list for future check.
    String quotaName = "New Temporary name";
    List<QuotaVdsGroup> quotaVdsGroupList = getQuotaVdsGroup(getSpecificQuotaVdsGroup(quotaGeneralToSpecific.getId()));
    Long newStorageLimit = new Long("2345");
    // Check before the update, that the fields are not equal.
    assertEquals(quotaName.equals(quotaGeneralToSpecific.getQuotaName()), false);
    assertEquals(quotaVdsGroupList.size() == quotaGeneralToSpecific.getQuotaVdsGroups().size(), false);
    assertEquals(quotaGeneralToSpecific.getGlobalQuotaStorage().getStorageSizeGB().equals(newStorageLimit), false);
    // Update
    quotaGeneralToSpecific.setQuotaName(quotaName);
    quotaGeneralToSpecific.getGlobalQuotaStorage().setStorageSizeGB(newStorageLimit);
    quotaGeneralToSpecific.setQuotaVdsGroups(quotaVdsGroupList);
    dao.update(quotaGeneralToSpecific);
    quotaGeneralToSpecific = dao.getById(FixturesTool.QUOTA_GENERAL);
    // Check after the update, that the fields are equal now.
    assertEquals(quotaName.equals(quotaGeneralToSpecific.getQuotaName()), true);
    assertEquals(quotaVdsGroupList.size() == quotaGeneralToSpecific.getQuotaVdsGroups().size(), true);
    assertEquals(quotaGeneralToSpecific.getGlobalQuotaStorage().getStorageSizeGB().equals(newStorageLimit), true);
}
#end_block

#method_before
private static void setQuotaGlobalLimitations(Quota quota) {
    // Set Quota storage capacity definition.
    quota.setStorageSizeGB(10000l);
    quota.setStorageSizeGBUsage(0d);
    // Set Quota cluster virtual memory definition.
    quota.setMemSizeMB(16000000l);
    quota.setMemSizeMBUsage(0l);
    // Set Quota cluster virtual CPU definition.
    quota.setVirtualCpu(2880);
    quota.setVirtualCpuUsage(0);
}
#method_after
private static void setQuotaGlobalLimitations(Quota quota) {
    QuotaStorage quotaStorage = new QuotaStorage();
    QuotaVdsGroup quotaVdsGroup = new QuotaVdsGroup();
    // Set Quota storage capacity definition.
    quotaStorage.setStorageSizeGB(10000l);
    quotaStorage.setStorageSizeGBUsage(0d);
    // Set Quota cluster virtual memory definition.
    quotaVdsGroup.setMemSizeMB(16000000l);
    quotaVdsGroup.setMemSizeMBUsage(0l);
    // Set Quota cluster virtual CPU definition.
    quotaVdsGroup.setVirtualCpu(2880);
    quotaVdsGroup.setVirtualCpuUsage(0);
    quota.setGlobalQuotaStorage(quotaStorage);
    quota.setGlobalQuotaVdsGroup(quotaVdsGroup);
}
#end_block

#method_before
public GlusterVolumeOption getVolumeOption() {
    return volumeOption;
}
#method_after
public GlusterVolumeOptionEntity getVolumeOption() {
    return volumeOption;
}
#end_block

#method_before
public void setVolumeOption(GlusterVolumeOption volumeOption) {
    this.volumeOption = volumeOption;
}
#method_after
public void setVolumeOption(GlusterVolumeOptionEntity volumeOption) {
    this.volumeOption = volumeOption;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CREATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_VOLUME);
    if (!super.canDoAction()) {
        return false;
    }
    volume = getParameters().getVolume();
    if (volume == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_REQUIRED);
        return false;
    }
    // set the cluster id
    setVdsGroupId(volume.getClusterId());
    VDSGroup cluster = getVdsGroup();
    if (cluster == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_IS_NOT_VALID);
        return false;
    }
    if (!cluster.supportsGlusterService()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_DOES_NOT_SUPPORT_GLUSTER);
        return false;
    }
    if (StringHelper.isNullOrEmpty(volume.getName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_NAME_REQUIRED);
        return false;
    }
    if (volume.getVolumeType() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_TYPE_REQUIRED);
        return false;
    }
    if (volume.getTransportType() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TRANSPORT_TYPE_REQUIRED);
        return false;
    }
    return validateBricks(volume);
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VDSGroup cluster = getVdsGroup();
    if (cluster == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_IS_NOT_VALID);
        return false;
    }
    if (!cluster.supportsGlusterService()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_DOES_NOT_SUPPORT_GLUSTER);
        return false;
    }
    return validateBricks(volume);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // set the gluster volume name for audit purpose
    setGlusterVolumeName(volume.getName());
    // GLUSTER access protocol is enabled by default
    if (volume.getAccessProtocols() == null) {
        volume.setAccessProtocol(AccessProtocol.GLUSTER);
    }
    VDSReturnValue returnValue = executeVdsCommand(VDSCommandType.CreateGlusterVolume, new CreateGlusterVolumeVDSParameters(getUpServer().getId(), volume));
    if (!getSucceeded()) {
        errorType = AuditLogType.GLUSTER_VOLUME_CREATE_FAILED;
        return;
    }
    // Volume created successfully. Insert it to database.
    GlusterVolumeEntity createdVolume = (GlusterVolumeEntity) returnValue.getReturnValue();
    addVolumeToDb(createdVolume);
    // set all options of the volume
    setVolumeOptions(createdVolume);
}
#method_after
@Override
protected void executeCommand() {
    // set the gluster volume name for audit purpose
    setGlusterVolumeName(volume.getName());
    // GLUSTER access protocol is enabled by default
    volume.addAccessProtocol(AccessProtocol.GLUSTER);
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.CreateGlusterVolume, new CreateGlusterVolumeVDSParameters(getUpServer().getId(), volume));
    setSucceeded(returnValue.getSucceeded());
    // Volume created successfully. Insert it to database.
    GlusterVolumeEntity createdVolume = (GlusterVolumeEntity) returnValue.getReturnValue();
    addVolumeToDb(createdVolume);
    // set all options of the volume
    setVolumeOptions(createdVolume);
}
#end_block

#method_before
private void setVolumeOptions(GlusterVolumeEntity volume) {
    List<String> errors = new ArrayList<String>();
    for (GlusterVolumeOption option : volume.getOptions()) {
        // make sure that volume id is set
        option.setVolumeId(volume.getId());
        VdcReturnValueBase setOptionReturnValue = executeBllAction(VdcActionType.SetGlusterVolumeOption, new GlusterVolumeOptionParameters(option));
        if (!getSucceeded()) {
            errors.addAll(setOptionReturnValue.getCanDoActionMessages());
            errors.addAll(setOptionReturnValue.getExecuteFailedMessages());
        }
    }
    if (!errors.isEmpty()) {
        setSucceeded(false);
        errorType = AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED;
        getReturnValue().getExecuteFailedMessages().addAll(errors);
    }
}
#method_after
private void setVolumeOptions(GlusterVolumeEntity volume) {
    List<String> errors = new ArrayList<String>();
    for (GlusterVolumeOptionEntity option : volume.getOptions()) {
        // make sure that volume id is set
        option.setVolumeId(volume.getId());
        VdcReturnValueBase setOptionReturnValue = runBllAction(VdcActionType.SetGlusterVolumeOption, new GlusterVolumeOptionParameters(option));
        if (!getSucceeded()) {
            errors.addAll(setOptionReturnValue.getCanDoActionMessages());
            errors.addAll(setOptionReturnValue.getExecuteFailedMessages());
        }
    }
    if (!errors.isEmpty()) {
        errorType = AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED;
        getReturnValue().getExecuteFailedMessages().addAll(errors);
    }
}
#end_block

#method_before
private boolean validateBricks(GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricks = volume.getBricks();
    if (bricks == null || bricks.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        return false;
    }
    switch(volume.getVolumeType()) {
        case REPLICATE:
        case DISTRIBUTED_REPLICATE:
            if (!validateReplicaCount(bricks.size(), volume.getReplicaCount())) {
                return false;
            }
            break;
        case STRIPE:
        case DISTRIBUTED_STRIPE:
            if (!validateStripeCount(bricks.size(), volume.getReplicaCount())) {
                return false;
            }
            break;
    }
    return true;
}
#method_after
private boolean validateBricks(GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricks = volume.getBricks();
    if (bricks.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        return false;
    }
    int brickCount = bricks.size();
    int replicaCount = volume.getReplicaCount();
    int stripeCount = volume.getStripeCount();
    switch(volume.getVolumeType()) {
        case REPLICATE:
            if (replicaCount < 2) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_REPLICA_COUNT_MIN_2);
                return false;
            }
            if (brickCount != replicaCount) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_COUNT_FOR_REPLICATE);
                return false;
            }
            break;
        case DISTRIBUTED_REPLICATE:
            if (replicaCount < 4) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_REPLICA_COUNT_MIN_4);
                return false;
            }
            if (brickCount < replicaCount || Math.IEEEremainder(brickCount, replicaCount) != 0) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_COUNT_FOR_DISTRIBUTED_REPLICATE);
                return false;
            }
            break;
        case STRIPE:
            if (stripeCount < 4) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STRIPE_COUNT_MIN_4);
                return false;
            }
            if (brickCount != stripeCount) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_COUNT_FOR_STRIPE);
                return false;
            }
            break;
        case DISTRIBUTED_STRIPE:
            if (stripeCount < 8) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STRIPE_COUNT_MIN_8);
                return false;
            }
            if (brickCount < stripeCount || Math.IEEEremainder(brickCount, stripeCount) != 0) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_COUNT_FOR_DISTRIBUTED_STRIPE);
                return false;
            }
            break;
    }
    return true;
}
#end_block

#method_before
private void addVolumeToDb(final GlusterVolumeEntity createdVolume) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            // volume fetched from VDSM doesn't contain cluster id GlusterFS
            // is not aware of multiple clusters
            createdVolume.setClusterId(getVdsGroupId());
            DbFacade.getInstance().getGlusterVolumeDao().save(createdVolume);
            return null;
        }
    });
}
#method_after
private void addVolumeToDb(final GlusterVolumeEntity createdVolume) {
    // volume fetched from VDSM doesn't contain cluster id GlusterFS
    // is not aware of multiple clusters
    createdVolume.setClusterId(getVdsGroupId());
    DbFacade.getInstance().getGlusterVolumeDao().save(createdVolume);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__SET);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_VOLUME_OPTION);
    if (!super.canDoAction()) {
        return false;
    }
    if (option == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_OPTION_REQUIRED);
        return false;
    }
    if (StringHelper.isNullOrEmpty(option.getKey())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_OPTION_KEY_REQUIRED);
        return false;
    }
    if (StringHelper.isNullOrEmpty(option.getValue())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_OPTION_VALUE_REQUIRED);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    return super.canDoAction();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // set volume details for audit purpose
    setGlusterVolumeId(option.getVolumeId());
    setGlusterVolumeName(getGlusterVolume().getName());
    executeVdsCommand(VDSCommandType.SetGlusterVolumeOption, new GlusterVolumeOptionVDSParameters(getUpServer().getId(), getGlusterVolumeName(), getParameters().getVolumeOption()));
    if (getSucceeded()) {
        updateOptionInDb(getParameters().getVolumeOption());
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.SetGlusterVolumeOption, new GlusterVolumeOptionVDSParameters(getUpServer().getId(), getGlusterVolumeName(), getParameters().getVolumeOption()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        updateOptionInDb(getParameters().getVolumeOption());
    }
}
#end_block

#method_before
private void updateOptionInDb(final GlusterVolumeOption option) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            // update the option value if it exists, else add it
            if (getGlusterVolume().getOptionValue(option.getKey()) != null) {
                glusterVolumeDao.updateVolumeOption(option);
            } else {
                glusterVolumeDao.addVolumeOption(option);
            }
            return null;
        }
    });
}
#method_after
private void updateOptionInDb(final GlusterVolumeOptionEntity option) {
    // update the option value if it exists, else add it
    if (getGlusterVolume().getOptionValue(option.getKey()) != null) {
        getGlusterVolumeDao().updateVolumeOption(option);
    } else {
        getGlusterVolumeDao().addVolumeOption(option);
    }
}
#end_block

#method_before
@Override
protected void ExecuteVdsBrokerCommand() {
    GlusterVolumeEntity volume = getParameters().getVolume();
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put("volumeName", volume.getName());
    parameters.put("volumeType", volume.getVolumeType().toString());
    parameters.put("replicaCount", volume.getReplicaCount());
    parameters.put("stripeCount", volume.getStripeCount());
    TransportType transportType = volume.getTransportType();
    parameters.put("transportType", transportType.toString());
    parameters.put("bricks", volume.getBrickDirectories().toArray());
    OneUuidReturnForXmlRpc uuidReturn = getBroker().glusterVolumeCreate(parameters);
    status = uuidReturn.mStatus;
    volume.setId(Guid.createGuidFromString(uuidReturn.mUuid));
    // Proceed only if there were no errors in the VDS command
    ProceedProxyReturnValue();
    if (!volume.isNfsEnabled()) {
        status = getBroker().glusterVolumeSet(volume.getName(), GlusterConstants.OPTION_NFS_DISABLE, "on").mStatus;
        ProceedProxyReturnValue();
    }
    for (GlusterVolumeOption option : volume.getOptions()) {
        status = getBroker().glusterVolumeSet(volume.getName(), option.getKey(), option.getValue()).mStatus;
        ProceedProxyReturnValue();
    }
    // set the volume updated with id as the return value
    setReturnValue(volume);
}
#method_after
@Override
protected void ExecuteVdsBrokerCommand() {
    GlusterVolumeEntity volume = getParameters().getVolume();
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put("volumeName", volume.getName());
    parameters.put("volumeType", volume.getVolumeType().name());
    parameters.put("replicaCount", volume.getReplicaCount());
    parameters.put("stripeCount", volume.getStripeCount());
    TransportType transportType = volume.getTransportType();
    parameters.put("transportType", transportType.name());
    parameters.put("bricks", volume.getBrickDirectories().toArray());
    OneUuidReturnForXmlRpc uuidReturn = getBroker().glusterVolumeCreate(parameters);
    status = uuidReturn.mStatus;
    volume.setId(Guid.createGuidFromString(uuidReturn.mUuid));
    // Proceed only if there were no errors in the VDS command
    ProceedProxyReturnValue();
    if (!volume.isNfsEnabled()) {
        status = getBroker().glusterVolumeSet(volume.getName(), GlusterConstants.OPTION_NFS_DISABLE, "on").mStatus;
        ProceedProxyReturnValue();
    }
    for (GlusterVolumeOptionEntity option : volume.getOptions()) {
        status = getBroker().glusterVolumeSet(volume.getName(), option.getKey(), option.getValue()).mStatus;
        ProceedProxyReturnValue();
    }
    // set the volume updated with id as the return value
    setReturnValue(volume);
}
#end_block

#method_before
public GlusterVolumeOption getVolumeOption() {
    return volumeOption;
}
#method_after
public GlusterVolumeOptionEntity getVolumeOption() {
    return volumeOption;
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
}
#method_after
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
}
#method_after
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_NETWORK_MTU_DIFFER_FROM_LOGICAL_NETWORK, AuditLogSeverity.WARNING);
}
#end_block

#method_before
public String getGlusterVolumeName() {
    return glusterVolumeName;
}
#method_after
public String getGlusterVolumeName() {
    if (glusterVolumeName == null && getGlusterVolume() != null) {
        glusterVolumeName = getGlusterVolume().getName();
    }
    return glusterVolumeName;
}
#end_block

#method_before
@Test
public void testDetermineMessageReturnsClassNameForNoParameterExpansion() throws Exception {
    Log log = mock(Log.class);
    when(log.isDebugEnabled()).thenReturn(false);
    assertEquals("LoggedUtils.determineMessage shouldn't return parameter expansion for a disabled log level.", Object.class.getName(), LoggedUtils.determineMessage(log, LoggedOverridingSubclassNoParameters.class.getAnnotation(Logged.class), new Object()));
    assertEquals("LoggedUtils.determineMessage shouldn't return parameter expansion when diabled completely.", Object.class.getName(), LoggedUtils.determineMessage(log, LoggedClass.class.getAnnotation(Logged.class), new Object()));
}
#method_after
@Test
public void testDetermineMessageReturnsClassNameForNoParameterExpansion() throws Exception {
    Log log = mock(Log.class);
    assertEquals("LoggedUtils.determineMessage shouldn't return parameter expansion for a disabled log level.", Object.class.getName(), LoggedUtils.determineMessage(log, LoggedOverridingSubclassNoParameters.class.getAnnotation(Logged.class), new Object()));
    assertEquals("LoggedUtils.determineMessage shouldn't return parameter expansion when diabled completely.", Object.class.getName(), LoggedUtils.determineMessage(log, LoggedClass.class.getAnnotation(Logged.class), new Object()));
}
#end_block

#method_before
/* --- Tests for the method "logEntry" --- */
@Test
public void testLogEntryDoesntLogWhenNoAnnotation() throws Exception {
    Log log = mock(Log.class);
    LoggedUtils.logEntry(log, "", new Object());
}
#method_after
/* --- Tests for the method "logEntry" --- */
@Test
public void testLogEntryDoesntLogWhenNoAnnotation() throws Exception {
    Log log = mock(Log.class);
    LoggedUtils.logEntry(log, "", new Object());
    verifyZeroInteractions(log);
}
#end_block

#method_before
@Test
public void testLogEntryDoesntLogWhenLogLevelInactive() throws Exception {
    Log log = mock(Log.class);
    when(log.isDebugEnabled()).thenReturn(false);
    LoggedUtils.logEntry(log, "", new LoggedOverridingSubclass());
}
#method_after
@Test
public void testLogEntryDoesntLogWhenLogLevelInactive() throws Exception {
    Log log = mock(Log.class);
    LoggedUtils.logEntry(log, "", new LoggedOverridingSubclass());
    verifyNoLogging(log);
}
#end_block

#method_before
/* --- Tests for the method "logReturn" --- */
@Test
public void testLogReturnDoesntLogWhenNoAnnotation() throws Exception {
    Log log = mock(Log.class);
    LoggedUtils.logReturn(log, "", new Object(), new Object());
}
#method_after
/* --- Tests for the method "logReturn" --- */
@Test
public void testLogReturnDoesntLogWhenNoAnnotation() throws Exception {
    Log log = mock(Log.class);
    LoggedUtils.logReturn(log, "", new Object(), new Object());
    verifyZeroInteractions(log);
}
#end_block

#method_before
@Test
public void testLogReturnDoesntLogWhenLogLevelInactive() throws Exception {
    Log log = mock(Log.class);
    when(log.isDebugEnabled()).thenReturn(false);
    LoggedUtils.logReturn(log, "", new LoggedOverridingSubclass(), new Object());
}
#method_after
@Test
public void testLogReturnDoesntLogWhenLogLevelInactive() throws Exception {
    Log log = mock(Log.class);
    LoggedUtils.logReturn(log, "", new LoggedOverridingSubclass(), new Object());
    verifyNoLogging(log);
}
#end_block

#method_before
/* --- Tests for the method "logError" --- */
@Test
public void testLogErrorDoesntLogWhenNoAnnotation() throws Exception {
    Log log = mock(Log.class);
    LoggedUtils.logError(log, "", new Object(), new Exception());
}
#method_after
/* --- Tests for the method "logError" --- */
@Test
public void testLogErrorDoesntLogWhenNoAnnotation() throws Exception {
    Log log = mock(Log.class);
    LoggedUtils.logError(log, "", new Object(), new Exception());
    verifyZeroInteractions(log);
}
#end_block

#method_before
@Test
public void testLogErrorDoesntLogWhenLogLevelInactive() throws Exception {
    Log log = mock(Log.class);
    when(log.isWarnEnabled()).thenReturn(false);
    LoggedUtils.logError(log, "", new LoggedOverridingSubclass(), new Exception());
}
#method_after
@Test
public void testLogErrorDoesntLogWhenLogLevelInactive() throws Exception {
    Log log = mock(Log.class);
    LoggedUtils.logError(log, "", new LoggedOverridingSubclass(), new Exception());
    verifyNoLogging(log);
}
#end_block

#method_before
/* --- Helper methods --- */
private static void helpTestLog(LogLevel logLevel, LogSetup logSetup) {
    Log log = mock(Log.class);
    String message = "{0}";
    Object args = new Object();
    logSetup.setup(log, message, args);
    LoggedUtils.log(log, logLevel, message, args);
    logSetup.verifyCall(log, message, args);
}
#method_after
private static void helpTestLog(LogLevel logLevel, LogSetup logSetup) {
    Log log = mock(Log.class);
    String message = "{0}";
    Object args = new Object();
    logSetup.setup(log, message, args);
    LoggedUtils.log(log, logLevel, message, args);
    logSetup.verifyCall(log, message, args);
}
#end_block

#method_before
public void RemoveVmFromDownVms(Guid vdsId, Guid vmId) {
    java.util.HashSet<Guid> vms = null;
    if ((vms = _vdsAndVmsList.get(vdsId)) != null) {
        vms.remove(vmId);
    }
}
#method_after
public void RemoveVmFromDownVms(Guid vdsId, Guid vmId) {
    HashSet<Guid> vms = null;
    if ((vms = _vdsAndVmsList.get(vdsId)) != null) {
        vms.remove(vmId);
    }
}
#end_block

#method_before
public void HandleVdsFinishedInit(Guid vdsId) {
    java.util.HashSet<Guid> vms = null;
    if ((vms = _vdsAndVmsList.get(vdsId)) != null) {
        for (Guid vmId : vms) {
            getEventListener().processOnVmStop(vmId);
            log.info("Procceed on vm stop entered: " + vmId.toString());
        }
        _vdsAndVmsList.remove(vdsId);
    }
}
#method_after
public void HandleVdsFinishedInit(Guid vdsId) {
    HashSet<Guid> vms = null;
    if ((vms = _vdsAndVmsList.get(vdsId)) != null) {
        for (Guid vmId : vms) {
            getEventListener().processOnVmStop(vmId);
            log.info("Procceed on vm stop entered: " + vmId.toString());
        }
        _vdsAndVmsList.remove(vdsId);
    }
}
#end_block

#method_before
@Override
public void vdsNonOperational(Guid vdsId, NonOperationalReason reason, boolean logCommand, boolean saveToDb, Guid domainId, Map<String, String> customLogValues) {
    log.info("ResourceManager:vdsMaintanance - no event listener defined, nothing done.");
}
#method_after
@Override
public void vdsNonOperational(Guid vdsId, NonOperationalReason reason, boolean logCommand, boolean saveToDb, Guid domainId) {
    log.info("ResourceManager:vdsMaintanance - no event listener defined, nothing done.");
}
#end_block

#method_before
public void UpdateVdsDomainsData(Guid vdsId, String vdsName, Guid storagePoolId, java.util.ArrayList<VDSDomainsData> vdsDomainData) {
    IrsBrokerCommand.UpdateVdsDomainsData(vdsId, vdsName, storagePoolId, vdsDomainData);
}
#method_after
public void UpdateVdsDomainsData(Guid vdsId, String vdsName, Guid storagePoolId, ArrayList<VDSDomainsData> vdsDomainData) {
    IrsBrokerCommand.UpdateVdsDomainsData(vdsId, vdsName, storagePoolId, vdsDomainData);
}
#end_block

#method_before
protected boolean canDetachDomain(boolean isDestroyStoragePool, boolean isRemoveLast, boolean isInternal) {
    return CheckStoragePool() && CheckStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.InActive, StorageDomainStatus.Maintenance) && (isMaster() || isDestroyStoragePool || CheckMasterDomainIsUp()) && isNotLocalData(isInternal) && isDetachAllowed(isRemoveLast);
}
#method_after
protected boolean canDetachDomain(boolean isDestroyStoragePool, boolean isRemoveLast, boolean isInternal) {
    return checkStoragePool() && CheckStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.InActive, StorageDomainStatus.Maintenance) && (isMaster() || isDestroyStoragePool || CheckMasterDomainIsUp()) && isNotLocalData(isInternal) && isDetachAllowed(isRemoveLast);
}
#end_block

#method_before
private boolean hasImages() {
    return DbFacade.getInstance().getDiskImageDAO().getAllSnapshotsForStorageDomain(getStorageDomain().getId()).size() != 0 || DbFacade.getInstance().getStorageDomainDAO().getAllImageStorageDomainMapsForStorageDomain(getStorageDomain().getId()).size() != 0;
}
#method_after
private boolean hasImages() {
    return DbFacade.getInstance().getDiskImageDAO().getAllSnapshotsForStorageDomain(getStorageDomain().getId()).size() != 0 || DbFacade.getInstance().getImageStorageDomainMapDao().getAllByStorageDomainId(getStorageDomain().getId()).size() != 0;
}
#end_block

#method_before
protected void RefreshAllVdssInPool(boolean connect) {
    java.util.ArrayList<Guid> vdsIdsToSetNonOperational = new java.util.ArrayList<Guid>();
    runSynchronizeOperation(new RefreshPoolSingleAsyncOperationFactory(), vdsIdsToSetNonOperational);
    for (Guid vdsId : vdsIdsToSetNonOperational) {
        SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(vdsId, STORAGE_DOMAIN_UNREACHABLE, null);
        tempVar.setSaveToDb(true);
        tempVar.setStorageDomainId(getStorageDomain().getId());
        tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar);
    }
}
#method_after
protected void RefreshAllVdssInPool(boolean connect) {
    java.util.ArrayList<Guid> vdsIdsToSetNonOperational = new java.util.ArrayList<Guid>();
    runSynchronizeOperation(new RefreshPoolSingleAsyncOperationFactory(), vdsIdsToSetNonOperational);
    for (Guid vdsId : vdsIdsToSetNonOperational) {
        SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(vdsId, STORAGE_DOMAIN_UNREACHABLE);
        tempVar.setSaveToDb(true);
        tempVar.setStorageDomainId(getStorageDomain().getId());
        tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public static void updateNetworkData(VDS vds, XmlRpcStruct xmlRpcStruct) {
    List<VdsNetworkInterface> oldInterfaces = DbFacade.getInstance().getInterfaceDAO().getAllInterfacesForVds(vds.getId());
    vds.getInterfaces().clear();
    // Interfaces list
    java.util.Map nics = (java.util.Map) ((xmlRpcStruct.getItem(VdsProperties.network_nics) instanceof java.util.Map) ? xmlRpcStruct.getItem(VdsProperties.network_nics) : null);
    if (nics != null) {
        for (Object keyAsObject : nics.keySet()) {
            String key = (String) keyAsObject;
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.NewGuid());
            iface.setId(iStats.getId());
            iface.setName(key);
            iface.setVdsId(vds.getId());
            // name value of nic property, i.e.: speed = 1000
            java.util.Map<String, Object> dataAsMap = (java.util.Map) ((nics.get(key) instanceof java.util.Map) ? nics.get(key) : null);
            XmlRpcStruct data = new XmlRpcStruct(dataAsMap);
            if (data != null) {
                if (data.getItem("speed") != null) {
                    Object speed = data.getItem("speed");
                    iface.setSpeed((Integer) speed);
                }
                if (data.getItem("addr") != null) {
                    iface.setAddress((String) ((data.getItem("addr") instanceof String) ? data.getItem("addr") : null));
                }
                if (data.getItem("netmask") != null) {
                    iface.setSubnet((String) ((data.getItem("netmask") instanceof String) ? data.getItem("netmask") : null));
                }
                if (data.getItem("hwaddr") != null) {
                    iface.setMacAddress((String) ((data.getItem("hwaddr") instanceof String) ? data.getItem("hwaddr") : null));
                }
                // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
                if (data.getItem("permhwaddr") != null) {
                    iface.setMacAddress((String) ((data.getItem("permhwaddr") instanceof String) ? data.getItem("permhwaddr") : null));
                }
            }
            iStats.setVdsId(vds.getId());
            vds.getInterfaces().add(iface);
        }
    }
    // interface to vlan map
    Map<String, Integer> currVlans = new java.util.HashMap<String, Integer>();
    // vlans
    java.util.Map<String, Object> vlans = (java.util.Map) ((xmlRpcStruct.getItem(VdsProperties.network_vlans) instanceof java.util.Map) ? xmlRpcStruct.getItem(VdsProperties.network_vlans) : null);
    if (vlans != null) {
        for (String key : vlans.keySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.NewGuid());
            iface.setId(iStats.getId());
            iface.setName(key);
            iface.setVdsId(vds.getId());
            if (key.contains(".")) {
                String[] names = key.split("[.]", -1);
                String vlan = names[1];
                iface.setVlanId(Integer.parseInt(vlan));
                currVlans.put(key, iface.getVlanId());
            }
            java.util.Map dataAsMap = (java.util.Map) ((vlans.get(key) instanceof java.util.Map) ? vlans.get(key) : null);
            XmlRpcStruct data = new XmlRpcStruct(dataAsMap);
            if (data.getItem("addr") != null) {
                iface.setAddress((String) ((data.getItem("addr") instanceof String) ? data.getItem("addr") : null));
            }
            if (data.getItem("netmask") != null) {
                iface.setSubnet((String) ((data.getItem("netmask") instanceof String) ? data.getItem("netmask") : null));
            }
            iStats.setVdsId(vds.getId());
            vds.getInterfaces().add(iface);
        }
    }
    // bonds
    java.util.Map<String, Object> bonds = (java.util.Map) ((xmlRpcStruct.getItem(VdsProperties.network_bondings) instanceof java.util.Map) ? xmlRpcStruct.getItem(VdsProperties.network_bondings) : null);
    if (bonds != null) {
        for (String key : bonds.keySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.NewGuid());
            iface.setId(iStats.getId());
            iface.setName(key);
            iface.setVdsId(vds.getId());
            iface.setBonded(true);
            java.util.Map dataAsMap = (java.util.Map) ((bonds.get(key) instanceof java.util.Map) ? bonds.get(key) : null);
            XmlRpcStruct data = new XmlRpcStruct(dataAsMap);
            if (data != null) {
                if (data.getItem("hwaddr") != null) {
                    iface.setMacAddress((String) ((data.getItem("hwaddr") instanceof String) ? data.getItem("hwaddr") : null));
                }
                if (data.getItem("addr") != null) {
                    iface.setAddress((String) ((data.getItem("addr") instanceof String) ? data.getItem("addr") : null));
                }
                if (data.getItem("netmask") != null) {
                    iface.setSubnet((String) ((data.getItem("netmask") instanceof String) ? data.getItem("netmask") : null));
                }
                if (data.getItem(VdsProperties.GLOBAL_GATEWAY) != null) {
                    iface.setGateway((String) ((data.getItem(VdsProperties.GLOBAL_GATEWAY) instanceof String) ? data.getItem(VdsProperties.GLOBAL_GATEWAY) : null));
                }
                if (data.getItem("slaves") != null) {
                    Object[] interfaces = (Object[]) ((data.getItem("slaves") instanceof Object[]) ? data.getItem("slaves") : null);
                    iStats.setVdsId(vds.getId());
                    AddBond(vds, iface, interfaces);
                }
                XmlRpcStruct config = (data.getItem("cfg") instanceof Map) ? new XmlRpcStruct((Map) data.getItem("cfg")) : null;
                if (config != null && config.getItem("BONDING_OPTS") != null) {
                    iface.setBondOptions(config.getItem("BONDING_OPTS").toString());
                }
                AddBootProtocol(config, iface);
            }
        }
    }
    // network to vlan map
    Map<String, Integer> networkVlans = new java.util.HashMap<String, Integer>();
    // Networks collection (name point to list of nics or bonds)
    java.util.Map<String, Object> networks = (java.util.Map) ((xmlRpcStruct.getItem(VdsProperties.network_networks) instanceof java.util.Map) ? xmlRpcStruct.getItem(VdsProperties.network_networks) : null);
    if (networks != null) {
        vds.getNetworks().clear();
        for (String key : networks.keySet()) {
            java.util.Map<String, Object> networkAsMap = (java.util.Map) ((networks.get(key) instanceof java.util.Map) ? networks.get(key) : null);
            XmlRpcStruct network = new XmlRpcStruct(networkAsMap);
            if (network != null) {
                network net = new network();
                net.setname(key);
                if (network.getItem("addr") != null) {
                    net.setaddr(network.getItem("addr").toString());
                }
                if (network.getItem("netmask") != null) {
                    net.setsubnet(network.getItem("netmask").toString());
                }
                if (network.getItem(VdsProperties.GLOBAL_GATEWAY) != null) {
                    net.setgateway(network.getItem(VdsProperties.GLOBAL_GATEWAY).toString());
                }
                // map interface to network
                Object[] ports = (Object[]) ((network.getItem("ports") instanceof Object[]) ? network.getItem("ports") : null);
                if (ports != null) {
                    for (Object port : ports) {
                        VdsNetworkInterface iface = null;
                        for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                            if (tempInterface.getName().equals(port.toString())) {
                                iface = tempInterface;
                                break;
                            }
                        }
                        if (iface != null) {
                            iface.setNetworkName(net.getname());
                            if (currVlans.containsKey(iface.getName())) {
                                networkVlans.put(net.getname(), currVlans.get(iface.getName()));
                            }
                            iface.setAddress(net.getaddr());
                            // ifaces is bridged if it is reported as one of the bridge ports
                            iface.setBridged(true);
                            // set the management ip
                            if (StringHelper.EqOp(iface.getNetworkName(), NetworkUtils.EngineNetwork)) {
                                iface.setType(iface.getType() | VdsInterfaceType.Management.getValue());
                            }
                            iface.setSubnet(net.getsubnet());
                            iface.setGateway(net.getgateway());
                            java.util.Map networkConfigAsMap = (java.util.Map) ((network.getItem("cfg") instanceof java.util.Map) ? network.getItem("cfg") : null);
                            XmlRpcStruct networkConfig = networkConfigAsMap == null ? null : new XmlRpcStruct(networkConfigAsMap);
                            AddBootProtocol(networkConfig, iface);
                        }
                    }
                }
                vds.getNetworks().add(net);
            }
        }
    }
    // Check vlans are line with Clusters vlans
    checkClusterVlans(vds, networkVlans);
    // set bonding options
    setBondingOptions(vds, oldInterfaces);
}
#method_after
@SuppressWarnings("unchecked")
public static void updateNetworkData(VDS vds, XmlRpcStruct xmlRpcStruct) {
    List<VdsNetworkInterface> oldInterfaces = DbFacade.getInstance().getInterfaceDAO().getAllInterfacesForVds(vds.getId());
    vds.getInterfaces().clear();
    // Interfaces list
    java.util.Map nics = (java.util.Map) ((xmlRpcStruct.getItem(VdsProperties.network_nics) instanceof java.util.Map) ? xmlRpcStruct.getItem(VdsProperties.network_nics) : null);
    if (nics != null) {
        for (Object keyAsObject : nics.keySet()) {
            String key = (String) keyAsObject;
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.NewGuid());
            iface.setId(iStats.getId());
            iface.setName(key);
            iface.setVdsId(vds.getId());
            // name value of nic property, i.e.: speed = 1000
            java.util.Map<String, Object> dataAsMap = (java.util.Map) ((nics.get(key) instanceof java.util.Map) ? nics.get(key) : null);
            XmlRpcStruct data = new XmlRpcStruct(dataAsMap);
            if (data != null) {
                if (data.getItem("speed") != null) {
                    Object speed = data.getItem("speed");
                    iface.setSpeed((Integer) speed);
                }
                if (data.getItem("addr") != null) {
                    iface.setAddress((String) ((data.getItem("addr") instanceof String) ? data.getItem("addr") : null));
                }
                if (data.getItem("netmask") != null) {
                    iface.setSubnet((String) ((data.getItem("netmask") instanceof String) ? data.getItem("netmask") : null));
                }
                if (data.getItem("hwaddr") != null) {
                    iface.setMacAddress((String) ((data.getItem("hwaddr") instanceof String) ? data.getItem("hwaddr") : null));
                }
                // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
                if (data.getItem("permhwaddr") != null) {
                    iface.setMacAddress((String) ((data.getItem("permhwaddr") instanceof String) ? data.getItem("permhwaddr") : null));
                }
                if (StringUtils.isNotBlank((String) data.getItem(mtu))) {
                    iface.setMtu(Integer.parseInt((String) data.getItem(mtu)));
                }
            }
            iStats.setVdsId(vds.getId());
            vds.getInterfaces().add(iface);
        }
    }
    // interface to vlan map
    Map<String, Integer> currVlans = new java.util.HashMap<String, Integer>();
    // vlans
    java.util.Map<String, Object> vlans = (java.util.Map) ((xmlRpcStruct.getItem(VdsProperties.network_vlans) instanceof java.util.Map) ? xmlRpcStruct.getItem(VdsProperties.network_vlans) : null);
    if (vlans != null) {
        for (String key : vlans.keySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.NewGuid());
            iface.setId(iStats.getId());
            iface.setName(key);
            iface.setVdsId(vds.getId());
            if (key.contains(".")) {
                String[] names = key.split("[.]", -1);
                String vlan = names[1];
                iface.setVlanId(Integer.parseInt(vlan));
                currVlans.put(key, iface.getVlanId());
            }
            java.util.Map dataAsMap = (java.util.Map) ((vlans.get(key) instanceof java.util.Map) ? vlans.get(key) : null);
            XmlRpcStruct data = new XmlRpcStruct(dataAsMap);
            if (data.getItem("addr") != null) {
                iface.setAddress((String) ((data.getItem("addr") instanceof String) ? data.getItem("addr") : null));
            }
            if (data.getItem("netmask") != null) {
                iface.setSubnet((String) ((data.getItem("netmask") instanceof String) ? data.getItem("netmask") : null));
            }
            if (StringUtils.isNotBlank((String) data.getItem(mtu))) {
                iface.setMtu(Integer.parseInt((String) data.getItem(mtu)));
            }
            iStats.setVdsId(vds.getId());
            vds.getInterfaces().add(iface);
        }
    }
    // bonds
    java.util.Map<String, Object> bonds = (java.util.Map) ((xmlRpcStruct.getItem(VdsProperties.network_bondings) instanceof java.util.Map) ? xmlRpcStruct.getItem(VdsProperties.network_bondings) : null);
    if (bonds != null) {
        for (String key : bonds.keySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.NewGuid());
            iface.setId(iStats.getId());
            iface.setName(key);
            iface.setVdsId(vds.getId());
            iface.setBonded(true);
            java.util.Map dataAsMap = (java.util.Map) ((bonds.get(key) instanceof java.util.Map) ? bonds.get(key) : null);
            XmlRpcStruct data = new XmlRpcStruct(dataAsMap);
            if (data != null) {
                if (data.getItem("hwaddr") != null) {
                    iface.setMacAddress((String) ((data.getItem("hwaddr") instanceof String) ? data.getItem("hwaddr") : null));
                }
                if (data.getItem("addr") != null) {
                    iface.setAddress((String) ((data.getItem("addr") instanceof String) ? data.getItem("addr") : null));
                }
                if (data.getItem("netmask") != null) {
                    iface.setSubnet((String) ((data.getItem("netmask") instanceof String) ? data.getItem("netmask") : null));
                }
                if (data.getItem(VdsProperties.GLOBAL_GATEWAY) != null) {
                    iface.setGateway((String) ((data.getItem(VdsProperties.GLOBAL_GATEWAY) instanceof String) ? data.getItem(VdsProperties.GLOBAL_GATEWAY) : null));
                }
                if (data.getItem("slaves") != null) {
                    Object[] interfaces = (Object[]) ((data.getItem("slaves") instanceof Object[]) ? data.getItem("slaves") : null);
                    iStats.setVdsId(vds.getId());
                    AddBond(vds, iface, interfaces);
                }
                if (StringUtils.isNotBlank((String) data.getItem(mtu))) {
                    iface.setMtu(Integer.parseInt((String) data.getItem(mtu)));
                }
                XmlRpcStruct config = (data.getItem("cfg") instanceof Map) ? new XmlRpcStruct((Map) data.getItem("cfg")) : null;
                if (config != null && config.getItem("BONDING_OPTS") != null) {
                    iface.setBondOptions(config.getItem("BONDING_OPTS").toString());
                }
                AddBootProtocol(config, iface);
            }
        }
    }
    // network to vlan map
    Map<String, Integer> networkVlans = new java.util.HashMap<String, Integer>();
    // Networks collection (name point to list of nics or bonds)
    java.util.Map<String, Object> networks = (java.util.Map) ((xmlRpcStruct.getItem(VdsProperties.network_networks) instanceof java.util.Map) ? xmlRpcStruct.getItem(VdsProperties.network_networks) : null);
    if (networks != null) {
        vds.getNetworks().clear();
        for (String key : networks.keySet()) {
            java.util.Map<String, Object> networkAsMap = (java.util.Map) ((networks.get(key) instanceof java.util.Map) ? networks.get(key) : null);
            XmlRpcStruct network = new XmlRpcStruct(networkAsMap);
            if (network != null) {
                network net = new network();
                net.setname(key);
                if (network.getItem("addr") != null) {
                    net.setaddr(network.getItem("addr").toString());
                }
                if (network.getItem("netmask") != null) {
                    net.setsubnet(network.getItem("netmask").toString());
                }
                if (network.getItem(VdsProperties.GLOBAL_GATEWAY) != null) {
                    net.setgateway(network.getItem(VdsProperties.GLOBAL_GATEWAY).toString());
                }
                if (StringUtils.isNotBlank((String) network.getItem(mtu))) {
                    net.setMtu(Integer.parseInt((String) network.getItem(mtu)));
                }
                // map interface to network
                Object[] ports = (Object[]) ((network.getItem("ports") instanceof Object[]) ? network.getItem("ports") : null);
                if (ports != null) {
                    for (Object port : ports) {
                        VdsNetworkInterface iface = null;
                        for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                            if (tempInterface.getName().equals(port.toString())) {
                                iface = tempInterface;
                                break;
                            }
                        }
                        if (iface != null) {
                            iface.setNetworkName(net.getname());
                            if (currVlans.containsKey(iface.getName())) {
                                networkVlans.put(net.getname(), currVlans.get(iface.getName()));
                            }
                            iface.setAddress(net.getaddr());
                            // ifaces is bridged if it is reported as one of the bridge ports
                            iface.setBridged(true);
                            // set the management ip
                            if (StringHelper.EqOp(iface.getNetworkName(), NetworkUtils.EngineNetwork)) {
                                iface.setType(iface.getType() | VdsInterfaceType.Management.getValue());
                            }
                            iface.setSubnet(net.getsubnet());
                            iface.setGateway(net.getgateway());
                            java.util.Map networkConfigAsMap = (java.util.Map) ((network.getItem("cfg") instanceof java.util.Map) ? network.getItem("cfg") : null);
                            XmlRpcStruct networkConfig = networkConfigAsMap == null ? null : new XmlRpcStruct(networkConfigAsMap);
                            AddBootProtocol(networkConfig, iface);
                        }
                    }
                }
                vds.getNetworks().add(net);
            }
        }
    }
    // Check vlans are line with Clusters vlans
    checkClusterVlans(vds, networkVlans);
    // set bonding options
    setBondingOptions(vds, oldInterfaces);
}
#end_block

#method_before
@Override
public void vdsNonOperational(Guid vdsId, NonOperationalReason reason, boolean logCommand, boolean saveToDb, Guid domainId, Map<String, String> customLogValues) {
    ExecutionHandler.updateSpecificActionJobCompleted(vdsId, VdcActionType.MaintananceVds, false);
    SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(vdsId, reason, customLogValues);
    tempVar.setSaveToDb(saveToDb);
    tempVar.setStorageDomainId(domainId);
    tempVar.setShouldBeLogged(logCommand);
    Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar);
}
#method_after
@Override
public void vdsNonOperational(Guid vdsId, NonOperationalReason reason, boolean logCommand, boolean saveToDb, Guid domainId) {
    vdsNonOperational(vdsId, reason, logCommand, saveToDb, domainId, null);
}
#end_block

#method_before
@Override
public void processOnCpuFlagsChange(Guid vdsId) {
    Backend.getInstance().runInternalAction(VdcActionType.HandleVdsCpuFlagsOrClusterChanged, new VdsActionParameters(vdsId));
    Backend.getInstance().runInternalAction(VdcActionType.HandleVdsVersion, new VdsActionParameters(vdsId));
}
#method_after
@Override
public void processOnCpuFlagsChange(Guid vdsId) {
    Backend.getInstance().runInternalAction(VdcActionType.HandleVdsCpuFlagsOrClusterChanged, new VdsActionParameters(vdsId));
}
#end_block

#method_before
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer() {
    try {
        setIsSetNonOperationalExecuted(false);
        Guid vdsId = null;
        Guid storagePoolId = null;
        String vdsName = null;
        ArrayList<VDSDomainsData> domainsList = null;
        synchronized (getLockObj()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    {
                        _vds = DbFacade.getInstance().getVdsDAO().get(getVdsId());
                        if (_vds == null) {
                            log.errorFormat("ResourceManager::refreshVdsRunTimeInfo - OnTimer is NULL for {0}", getVdsId());
                            return null;
                        }
                        try {
                            if (_refreshIteration == _numberRefreshesBeforeSave) {
                                _refreshIteration = 1;
                            } else {
                                _refreshIteration++;
                            }
                            if ((_vds.getstatus() != VDSStatus.NonOperational || (_vds.getvm_count() > 0)) && (_vds.getstatus() != VDSStatus.Installing && _vds.getstatus() != VDSStatus.InstallFailed && _vds.getstatus() != VDSStatus.Reboot && _vds.getstatus() != VDSStatus.Maintenance && _vds.getstatus() != VDSStatus.PendingApproval && _vds.getstatus() != VDSStatus.Down)) {
                                _vdsUpdater = new VdsUpdateRunTimeInfo(VdsManager.this, _vds);
                                _vdsUpdater.Refresh();
                                mUnrespondedAttempts.set(0);
                                mLastUpdate = DateTime.getNow();
                            }
                            if (!getInitialized() && getVds().getstatus() != VDSStatus.NonResponsive && getVds().getstatus() != VDSStatus.PendingApproval) {
                                log.info("Initializing Host: " + getVds().getvds_name());
                                ResourceManager.getInstance().HandleVdsFinishedInit(_vds.getId());
                                setInitialized(true);
                            }
                        } catch (VDSNetworkException e) {
                            logNetworkException(e);
                        } catch (VDSRecoveringException ex) {
                            HandleVdsRecoveringException(ex);
                        } catch (IRSErrorException ex) {
                            logFailureMessage(ex);
                            if (log.isDebugEnabled()) {
                                logException(ex);
                            }
                        } catch (RuntimeException ex) {
                            logFailureMessage(ex);
                            logException(ex);
                        }
                    }
                    return null;
                }

                private void logFailureMessage(RuntimeException ex) {
                    log.warnFormat("ResourceManager::refreshVdsRunTimeInfo::Failed to refresh VDS , vds = {0} : {1}, error = '{2}', continuing.", _vds.getId(), _vds.getvds_name(), ExceptionUtils.getMessage(ex));
                }
            });
            try {
                if (_vdsUpdater != null) {
                    _vdsUpdater.AfterRefreshTreatment();
                    // the storage anymore (so there is no sense in updating the domains list in that case).
                    if (_vds != null && _vds.getstatus() != VDSStatus.Maintenance) {
                        vdsId = _vds.getId();
                        vdsName = _vds.getvds_name();
                        storagePoolId = _vds.getstorage_pool_id();
                        domainsList = _vds.getDomains();
                    }
                }
                _vds = null;
                _vdsUpdater = null;
            } catch (IRSErrorException ex) {
                logFailureMessage(ex);
                if (log.isDebugEnabled()) {
                    logException(ex);
                }
            } catch (RuntimeException ex) {
                logFailureMessage(ex);
                logException(ex);
            }
        }
        // synchronized part of code
        if (domainsList != null) {
            IrsBrokerCommand.UpdateVdsDomainsData(vdsId, vdsName, storagePoolId, domainsList);
        }
    } catch (Exception e) {
        log.error("Timer update runtimeinfo failed. Exception:", e);
    }
}
#method_after
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer() {
    try {
        setIsSetNonOperationalExecuted(false);
        Guid vdsId = null;
        Guid storagePoolId = null;
        String vdsName = null;
        ArrayList<VDSDomainsData> domainsList = null;
        synchronized (getLockObj()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    {
                        _vds = DbFacade.getInstance().getVdsDAO().get(getVdsId());
                        if (_vds == null) {
                            log.errorFormat("ResourceManager::refreshVdsRunTimeInfo - OnTimer is NULL for {0}", getVdsId());
                            return null;
                        }
                        try {
                            if (_refreshIteration == _numberRefreshesBeforeSave) {
                                _refreshIteration = 1;
                            } else {
                                _refreshIteration++;
                            }
                            if (isMonitoringNeeded()) {
                                _vdsUpdater = new VdsUpdateRunTimeInfo(VdsManager.this, _vds);
                                _vdsUpdater.Refresh();
                                mUnrespondedAttempts.set(0);
                                mLastUpdate = DateTime.getNow();
                            }
                            if (!getInitialized() && getVds().getstatus() != VDSStatus.NonResponsive && getVds().getstatus() != VDSStatus.PendingApproval) {
                                log.info("Initializing Host: " + getVds().getvds_name());
                                ResourceManager.getInstance().HandleVdsFinishedInit(_vds.getId());
                                setInitialized(true);
                            }
                        } catch (VDSNetworkException e) {
                            logNetworkException(e);
                        } catch (VDSRecoveringException ex) {
                            HandleVdsRecoveringException(ex);
                        } catch (IRSErrorException ex) {
                            logFailureMessage(ex);
                            if (log.isDebugEnabled()) {
                                logException(ex);
                            }
                        } catch (RuntimeException ex) {
                            logFailureMessage(ex);
                            logException(ex);
                        }
                    }
                    return null;
                }

                private void logFailureMessage(RuntimeException ex) {
                    log.warnFormat("ResourceManager::refreshVdsRunTimeInfo::Failed to refresh VDS , vds = {0} : {1}, error = '{2}', continuing.", _vds.getId(), _vds.getvds_name(), ExceptionUtils.getMessage(ex));
                }
            });
            try {
                if (_vdsUpdater != null) {
                    _vdsUpdater.AfterRefreshTreatment();
                    // the storage anymore (so there is no sense in updating the domains list in that case).
                    if (_vds != null && _vds.getstatus() != VDSStatus.Maintenance) {
                        vdsId = _vds.getId();
                        vdsName = _vds.getvds_name();
                        storagePoolId = _vds.getstorage_pool_id();
                        domainsList = _vds.getDomains();
                    }
                }
                _vds = null;
                _vdsUpdater = null;
            } catch (IRSErrorException ex) {
                logFailureMessage(ex);
                if (log.isDebugEnabled()) {
                    logException(ex);
                }
            } catch (RuntimeException ex) {
                logFailureMessage(ex);
                logException(ex);
            }
        }
        // synchronized part of code
        if (domainsList != null) {
            IrsBrokerCommand.UpdateVdsDomainsData(vdsId, vdsName, storagePoolId, domainsList);
        }
    } catch (Exception e) {
        log.error("Timer update runtimeinfo failed. Exception:", e);
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("onTimerHandleVdsRecovering")
public void onTimerHandleVdsRecovering() {
    recoveringJobIdMap.remove(getVdsId());
    VDS vds = DbFacade.getInstance().getVdsDAO().get(getVdsId());
    if (vds.getstatus() == VDSStatus.Initializing) {
        try {
            ResourceManager.getInstance().getEventListener().vdsNonOperational(vds.getId(), NonOperationalReason.TIMEOUT_RECOVERING_FROM_CRASH, true, true, Guid.Empty, null);
            setIsSetNonOperationalExecuted(true);
        } catch (RuntimeException exp) {
            log.errorFormat("HandleVdsRecoveringException::Error in recovery timer treatment, vds = {0} : {1}, error = {2}.", vds.getId(), vds.getvds_name(), exp.getMessage());
        }
    }
}
#method_after
@OnTimerMethodAnnotation("onTimerHandleVdsRecovering")
public void onTimerHandleVdsRecovering() {
    recoveringJobIdMap.remove(getVdsId());
    VDS vds = DbFacade.getInstance().getVdsDAO().get(getVdsId());
    if (vds.getstatus() == VDSStatus.Initializing) {
        try {
            ResourceManager.getInstance().getEventListener().vdsNonOperational(vds.getId(), NonOperationalReason.TIMEOUT_RECOVERING_FROM_CRASH, true, true, Guid.Empty);
            setIsSetNonOperationalExecuted(true);
        } catch (RuntimeException exp) {
            log.errorFormat("HandleVdsRecoveringException::Error in recovery timer treatment, vds = {0} : {1}, error = {2}.", vds.getId(), vds.getvds_name(), exp.getMessage());
        }
    }
}
#end_block

#method_before
public void activate() {
    VDS vds = null;
    boolean cpuFlagsChanged = false;
    try {
        // new VdsIdVDSCommandParametersBase(_vds.vds_id));
        if (log.isDebugEnabled()) {
            log.debugFormat("ResourceManager::activateVds - trying to activate host {0} , meanwhile setting status to Unassigned meanwhile", getVdsId());
        }
        vds = DbFacade.getInstance().getVdsDAO().get(getVdsId());
        /**
         * refresh capabilities
         */
        RefObject<Boolean> tempRefObject = new RefObject<Boolean>(cpuFlagsChanged);
        VDSStatus newStatus = refreshCapabilities(tempRefObject, vds);
        if (log.isDebugEnabled()) {
            log.debugFormat("ResourceManager::activateVds - success to refreshCapabilities for host {0} , new status will be {1} ", getVdsId(), newStatus);
        }
        cpuFlagsChanged = tempRefObject.argvalue;
    } catch (java.lang.Exception e) {
        log.infoFormat("ResourceManager::activateVds - failed to get VDS = {0} capabilities with error: {1}.", getVdsId(), e.getMessage());
        log.infoFormat("ResourceManager::activateVds - failed to activate VDS = {0}", getVdsId());
    } finally {
        if (vds != null) {
            UpdateDynamicData(vds.getDynamicData());
            // always check flags in case host cluster changed
            ResourceManager.getInstance().getEventListener().processOnCpuFlagsChange(vds.getId());
        }
    }
}
#method_after
public void activate() {
    VDS vds = null;
    boolean processHardwareCapsNeeded = false;
    try {
        // new VdsIdVDSCommandParametersBase(_vds.vds_id));
        if (log.isDebugEnabled()) {
            log.debugFormat("ResourceManager::activateVds - trying to activate host {0} , meanwhile setting status to Unassigned meanwhile", getVdsId());
        }
        vds = DbFacade.getInstance().getVdsDAO().get(getVdsId());
        /**
         * refresh capabilities
         */
        RefObject<Boolean> tempRefObject = new RefObject<Boolean>(processHardwareCapsNeeded);
        VDSStatus newStatus = refreshCapabilities(tempRefObject, vds);
        if (log.isDebugEnabled()) {
            log.debugFormat("ResourceManager::activateVds - success to refreshCapabilities for host {0} , new status will be {1} ", getVdsId(), newStatus);
        }
        processHardwareCapsNeeded = tempRefObject.argvalue;
    } catch (java.lang.Exception e) {
        log.infoFormat("ResourceManager::activateVds - failed to get VDS = {0} capabilities with error: {1}.", getVdsId(), e.getMessage());
        log.infoFormat("ResourceManager::activateVds - failed to activate VDS = {0}", getVdsId());
    } finally {
        if (vds != null) {
            UpdateDynamicData(vds.getDynamicData());
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            ResourceManager.getInstance().getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#end_block

#method_before
public VDSStatus refreshCapabilities(RefObject<Boolean> cpuFlagsHasChanged, VDS vds) {
    log.debug("refreshCapabilities:GetCapabilitiesVDSCommand started method");
    String oldFlags = vds.getcpu_flags();
    GetCapabilitiesVDSCommand vdsBrokerCommand = new GetCapabilitiesVDSCommand(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.Execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        VDSStatus returnStatus = vds.getstatus();
        boolean isSetNonOperational = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (isSetNonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        if (isSetNonOperational && returnStatus != VDSStatus.NonOperational) {
            if (log.isDebugEnabled()) {
                log.debugFormat("refreshCapabilities:GetCapabilitiesVDSCommand vds {0} networks  not match it's cluster networks, vds will be moved to NonOperational", vds.getStaticData().getId());
            }
            vds.setstatus(VDSStatus.NonOperational);
            vds.setNonOperationalReason(NonOperationalReason.NETWORK_UNREACHABLE);
            returnStatus = vds.getstatus();
        }
        if (vds.getkvm_enabled() != null && vds.getkvm_enabled().equals(false) && vds.getstatus() != VDSStatus.NonOperational) {
            if (log.isDebugEnabled()) {
                log.debugFormat("refreshCapabilities:GetCapabilitiesVDSCommand vds {0} has not kvm, vds will be moved to NonOperational", vds.getStaticData().getId());
            }
            ResourceManager.getInstance().getEventListener().vdsNonOperational(vds.getId(), NonOperationalReason.KVM_NOT_RUNNING, true, true, Guid.Empty, null);
            vds.setstatus(VDSStatus.NonOperational);
            returnStatus = vds.getstatus();
            setIsSetNonOperationalExecuted(true);
        }
        cpuFlagsHasChanged.argvalue = (!StringHelper.EqOp(oldFlags, vds.getcpu_flags()));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            UpdateDynamicData(vds.getDynamicData());
            UpdateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#method_after
public VDSStatus refreshCapabilities(RefObject<Boolean> processHardwareCapsNeeded, VDS vds) {
    log.debug("refreshCapabilities:GetCapabilitiesVDSCommand started method");
    MonitoringStrategy vdsMonitoringStrategy = MonitoringStrategyFactory.getMonitoringStrategyForVds(vds);
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand vdsBrokerCommand = new GetCapabilitiesVDSCommand(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.Execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        VDSStatus returnStatus = vds.getstatus();
        boolean isSetNonOperational = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (isSetNonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        if (isSetNonOperational && returnStatus != VDSStatus.NonOperational) {
            if (log.isDebugEnabled()) {
                log.debugFormat("refreshCapabilities:GetCapabilitiesVDSCommand vds {0} networks  not match it's cluster networks, vds will be moved to NonOperational", vds.getStaticData().getId());
            }
            vds.setstatus(VDSStatus.NonOperational);
            vds.setNonOperationalReason(NonOperationalReason.NETWORK_UNREACHABLE);
            returnStatus = vds.getstatus();
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getstatus();
        vdsMonitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getstatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.argvalue = monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds);
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            UpdateDynamicData(vds.getDynamicData());
            UpdateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#end_block

#method_before
@Override
protected void ExecuteVdsBrokerCommand() {
    XmlRpcStruct bonds = new XmlRpcStruct();
    XmlRpcStruct networks = new XmlRpcStruct();
    Map<String, String> removeObj = new HashMap<String, String>();
    removeObj.put("remove", "true");
    // Networks
    for (network net : getParameters().getNetworks()) {
        Map<String, String> opts = new HashMap<String, String>();
        VdsNetworkInterface i = findNetworkInterface(net.getname(), getParameters().getInterfaces(), getParameters().getBonds());
        String type = (i.getBonded() != null && i.getBonded()) ? "bonding" : "nic";
        opts.put(type, NetworkUtils.StripVlan(i.getName()));
        if (net.getvlan_id() != null) {
            opts.put("vlan", net.getvlan_id().toString());
        }
        // TODO: add bootproto to network object
        switch(i.getBootProtocol()) {
            case Dhcp:
                opts.put(VdsProperties.bootproto, VdsProperties.dhcp);
                break;
            case StaticIp:
                if (!StringHelper.isNullOrEmpty(i.getAddress())) {
                    opts.put("ipaddr", i.getAddress());
                }
                if (!StringHelper.isNullOrEmpty(i.getSubnet())) {
                    opts.put("netmask", i.getSubnet());
                }
                if (!StringHelper.isNullOrEmpty(i.getGateway())) {
                    opts.put("gateway", i.getGateway());
                }
                break;
        }
        opts.put("bridged", net.isVmNetwork() ? "true" : "false");
        networks.add(net.getname(), opts);
    }
    // Removed Networks
    for (network net : getParameters().getRemovedNetworks()) {
        networks.add(net.getname(), removeObj);
    }
    // Bonds
    for (VdsNetworkInterface bond : getParameters().getBonds()) {
        XmlRpcStruct opts = new XmlRpcStruct();
        opts.add("nics", getBondNics(bond, getParameters().getInterfaces()));
        if (!StringHelper.isNullOrEmpty(bond.getBondOptions())) {
            opts.add("BONDING_OPTS", bond.getBondOptions());
        }
        bonds.add(bond.getName(), opts);
    }
    // Removed Bonds
    for (VdsNetworkInterface bond : getParameters().getRemovedBonds()) {
        bonds.add(bond.getName(), removeObj);
    }
    // Options
    XmlRpcStruct options = new XmlRpcStruct();
    if (getParameters().isCheckConnectivity()) {
        options.add(VdsProperties.connectivityCheck, "true");
    } else {
        options.add(VdsProperties.connectivityCheck, "false");
    }
    if (getParameters().getConectivityTimeout() >= 0) {
        options.add(VdsProperties.connectivityTimeout, (new Integer(getParameters().getConectivityTimeout())).toString());
    }
    httpTask = getBroker().setupNetworks(networks, bonds, options);
}
#method_after
@Override
protected void ExecuteVdsBrokerCommand() {
    XmlRpcStruct bonds = new XmlRpcStruct();
    XmlRpcStruct networks = new XmlRpcStruct();
    Map<String, String> removeObj = new HashMap<String, String>();
    removeObj.put("remove", "true");
    // Networks
    for (network net : getParameters().getNetworks()) {
        Map<String, String> opts = new HashMap<String, String>();
        VdsNetworkInterface i = findNetworkInterface(net.getname(), getParameters().getInterfaces(), getParameters().getBonds());
        String type = (i.getBonded() != null && i.getBonded()) ? "bonding" : "nic";
        opts.put(type, NetworkUtils.StripVlan(i.getName()));
        if (net.getvlan_id() != null) {
            opts.put("vlan", net.getvlan_id().toString());
        }
        // TODO: add bootproto to network object
        switch(i.getBootProtocol()) {
            case Dhcp:
                opts.put(VdsProperties.bootproto, VdsProperties.dhcp);
                break;
            case StaticIp:
                if (!StringHelper.isNullOrEmpty(i.getAddress())) {
                    opts.put("ipaddr", i.getAddress());
                }
                if (!StringHelper.isNullOrEmpty(i.getSubnet())) {
                    opts.put("netmask", i.getSubnet());
                }
                if (!StringHelper.isNullOrEmpty(i.getGateway())) {
                    opts.put("gateway", i.getGateway());
                }
                break;
        }
        if (net.getMtu() != 0) {
            opts.put("mtu", String.valueOf(net.getMtu()));
        }
        opts.put("bridged", Boolean.toString(net.isVmNetwork()));
        networks.add(net.getname(), opts);
    }
    // Removed Networks
    for (network net : getParameters().getRemovedNetworks()) {
        networks.add(net.getname(), removeObj);
    }
    // Bonds
    for (VdsNetworkInterface bond : getParameters().getBonds()) {
        XmlRpcStruct opts = new XmlRpcStruct();
        opts.add("nics", getBondNics(bond, getParameters().getInterfaces()));
        if (!StringHelper.isNullOrEmpty(bond.getBondOptions())) {
            opts.add("BONDING_OPTS", bond.getBondOptions());
        }
        bonds.add(bond.getName(), opts);
    }
    // Removed Bonds
    for (VdsNetworkInterface bond : getParameters().getRemovedBonds()) {
        bonds.add(bond.getName(), removeObj);
    }
    // Options
    XmlRpcStruct options = new XmlRpcStruct();
    if (getParameters().isCheckConnectivity()) {
        options.add(VdsProperties.connectivityCheck, "true");
    } else {
        options.add(VdsProperties.connectivityCheck, "false");
    }
    if (getParameters().getConectivityTimeout() >= 0) {
        options.add(VdsProperties.connectivityTimeout, (new Integer(getParameters().getConectivityTimeout())).toString());
    }
    httpTask = getBroker().setupNetworks(networks, bonds, options);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    boolean retVal = ImportExportCommon.checkStoragePool(getStoragePool(), canDoActionMessages);
    Map<Guid, storage_domains> domainsMap = null;
    if (retVal) {
        domainsMap = new HashMap<Guid, storage_domains>();
        for (Guid destGuid : imageToDestinationDomainMap.values()) {
            storage_domains storageDomain = getStorageDomain(destGuid);
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validator.isDomainExistAndActive(canDoActionMessages) || !validator.domainIsValidDestination(canDoActionMessages)) {
                retVal = false;
                break;
            } else {
                domainsMap.put(destGuid, storageDomain);
            }
        }
    }
    if (retVal) {
        SetSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        retVal = validator.isDomainExistAndActive(canDoActionMessages);
        if (retVal && getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    if (retVal) {
        // Load images from Import/Export domain
        GetAllFromExportDomainQueryParamenters tempVar = new GetAllFromExportDomainQueryParamenters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        tempVar.setGetAll(true);
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            List<VM> vms = (List<VM>) qretVal.getReturnValue();
            VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

                @Override
                public boolean eval(VM vm) {
                    return vm.getId().equals(getParameters().getVm().getId());
                }
            });
            if (vm != null) {
                // At this point we should work with the VM that was read from
                // the OVF
                setVm(vm);
                for (DiskImage image : getVm().getImages()) {
                    for (DiskImage p : imageList) {
                        // only if requested by the user
                        if (getParameters().getCopyCollapse()) {
                            if (p.getId().equals(image.getId())) {
                                if (p.getvolume_format() != null) {
                                    image.setvolume_format(p.getvolume_format());
                                }
                                if (p.getvolume_type() != null) {
                                    image.setvolume_type(p.getvolume_type());
                                }
                            }
                        }
                        if (image.getimage_group_id().equals(p.getimage_group_id()) && !imageToDestinationDomainMap.containsKey(image.getId())) {
                            imageToDestinationDomainMap.put(image.getId(), imageToDestinationDomainMap.get(p.getId()));
                        }
                    }
                    retVal = ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(image.getId())).getStorageStaticData(), image, canDoActionMessages);
                    if (!retVal) {
                        break;
                    } else {
                        image.setstorage_pool_id(getParameters().getStoragePoolId());
                        // we put the source domain id in order that copy will
                        // work
                        // ok
                        // we fix it to DestDomainId in
                        // MoveOrCopyAllImageGroups();
                        image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
                    }
                }
                if (retVal) {
                    Map<String, List<DiskImage>> images = GetImagesLeaf(getVm().getImages());
                    for (String drive : images.keySet()) {
                        List<DiskImage> list = images.get(drive);
                        getVm().addDriveToImageMap(drive, list.get(list.size() - 1));
                    }
                }
            } else {
                retVal = false;
            }
        }
    }
    // check that the imported vm guid is not in engine
    if (retVal) {
        VmStatic duplicateVm = getVmStaticDAO().get(getParameters().getVm().getId());
        if (duplicateVm != null) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            addCanDoActionMessage(String.format("$VmName %1$s", duplicateVm.getvm_name()));
            retVal = false;
        }
    }
    // check that the imported vm name is not in engine
    if (retVal) {
        List<VmStatic> dupVmNames = getVmStaticDAO().getAllByName(getParameters().getVm().getvm_name());
        if (dupVmNames.size() >= 1) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            addCanDoActionMessage(String.format("$VmName %1$s", getVm().getvm_name()));
            retVal = false;
        }
    }
    setVmTemplateId(getVm().getvmt_guid());
    if (retVal) {
        if (!TemplateExists() || !CheckTemplateInStorageDomain() || !CheckImagesGUIDsLegal() || !CanAddVm()) {
            retVal = false;
        }
    }
    if (retVal && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && getVmTemplate() != null && getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
        retVal = false;
    }
    if (retVal && getParameters().getCopyCollapse() && getParameters().getDiskInfoList() != null) {
        for (DiskImageBase imageBase : getParameters().getDiskInfoList().values()) {
            DiskImage key = getVm().getDiskMap().get(imageBase.getinternal_drive_mapping());
            if (key != null) {
                retVal = ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), imageBase, canDoActionMessages);
                if (!retVal) {
                    break;
                }
            }
        }
    }
    // (backup) domain
    if (retVal && getParameters().getCopyCollapse() && !TemplateExistsOnExportDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING);
        addCanDoActionMessage(String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getstorage_name()));
        retVal = false;
    }
    if (retVal) {
        boolean inCluster = false;
        List<VDSGroup> groups = getVdsGroupDAO().getAllForStoragePool(getParameters().getStoragePoolId());
        for (VDSGroup group : groups) {
            if (group.getId().equals(getParameters().getVdsGroupId())) {
                inCluster = true;
                break;
            }
        }
        if (!inCluster) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            retVal = false;
        }
    }
    if (retVal) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    if (retVal && Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVdsGroup().getcompatibility_version().toString())) {
        // version 2.x)
        if (!VmCommand.validateNumberOfNics(getParameters().getVm().getInterfaces(), null)) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            retVal = false;
        }
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retVal;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    boolean retVal = checkStoragePool();
    Map<Guid, storage_domains> domainsMap = null;
    if (retVal) {
        domainsMap = new HashMap<Guid, storage_domains>();
        Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
        for (Guid destGuid : destGuids) {
            storage_domains storageDomain = getStorageDomain(destGuid);
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validator.isDomainExistAndActive(canDoActionMessages) || !validator.domainIsValidDestination(canDoActionMessages)) {
                retVal = false;
                break;
            } else {
                domainsMap.put(destGuid, storageDomain);
            }
        }
    }
    if (retVal) {
        SetSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        retVal = validator.isDomainExistAndActive(canDoActionMessages);
        if (retVal && getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    if (retVal) {
        // Load images from Import/Export domain
        GetAllFromExportDomainQueryParamenters tempVar = new GetAllFromExportDomainQueryParamenters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        tempVar.setGetAll(true);
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            List<VM> vms = (List<VM>) qretVal.getReturnValue();
            VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

                @Override
                public boolean eval(VM vm) {
                    return vm.getId().equals(getParameters().getVm().getId());
                }
            });
            if (vm != null) {
                // At this point we should work with the VM that was read from
                // the OVF
                setVm(vm);
                for (DiskImage image : getVm().getImages()) {
                    for (DiskImage p : imageList) {
                        // only if requested by the user
                        if (getParameters().getCopyCollapse()) {
                            if (p.getId().equals(image.getId())) {
                                if (p.getvolume_format() != null) {
                                    image.setvolume_format(p.getvolume_format());
                                }
                                if (p.getvolume_type() != null) {
                                    image.setvolume_type(p.getvolume_type());
                                }
                            }
                        }
                        if (image.getimage_group_id().equals(p.getimage_group_id()) && !imageToDestinationDomainMap.containsKey(image.getId())) {
                            imageToDestinationDomainMap.put(image.getId(), imageToDestinationDomainMap.get(p.getId()));
                        }
                    }
                    retVal = ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(image.getId())).getStorageStaticData(), image, canDoActionMessages);
                    if (!retVal) {
                        break;
                    } else {
                        image.setstorage_pool_id(getParameters().getStoragePoolId());
                        // we put the source domain id in order that copy will
                        // work
                        // ok
                        // we fix it to DestDomainId in
                        // MoveOrCopyAllImageGroups();
                        image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
                    }
                }
                if (retVal) {
                    Map<String, List<DiskImage>> images = GetImagesLeaf(getVm().getImages());
                    for (String drive : images.keySet()) {
                        List<DiskImage> list = images.get(drive);
                        getVm().addDriveToImageMap(drive, list.get(list.size() - 1));
                    }
                }
            } else {
                retVal = false;
            }
        }
    }
    // check that the imported vm guid is not in engine
    if (retVal) {
        VmStatic duplicateVm = getVmStaticDAO().get(getParameters().getVm().getId());
        if (duplicateVm != null) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            addCanDoActionMessage(String.format("$VmName %1$s", duplicateVm.getvm_name()));
            retVal = false;
        }
    }
    setVmTemplateId(getVm().getvmt_guid());
    if (retVal) {
        if (!TemplateExists() || !CheckTemplateInStorageDomain() || !CheckImagesGUIDsLegal() || !CanAddVm()) {
            retVal = false;
        }
    }
    if (retVal && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && getVmTemplate() != null && getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
        retVal = false;
    }
    if (retVal && getParameters().getCopyCollapse() && getParameters().getDiskInfoList() != null) {
        for (DiskImageBase imageBase : getParameters().getDiskInfoList().values()) {
            DiskImage key = getVm().getDiskMap().get(imageBase.getinternal_drive_mapping());
            if (key != null) {
                retVal = ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), imageBase, canDoActionMessages);
                if (!retVal) {
                    break;
                }
            }
        }
    }
    // (backup) domain
    if (retVal && getParameters().getCopyCollapse() && !TemplateExistsOnExportDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING);
        addCanDoActionMessage(String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getstorage_name()));
        retVal = false;
    }
    if (retVal) {
        boolean inCluster = false;
        List<VDSGroup> groups = getVdsGroupDAO().getAllForStoragePool(getParameters().getStoragePoolId());
        for (VDSGroup group : groups) {
            if (group.getId().equals(getParameters().getVdsGroupId())) {
                inCluster = true;
                break;
            }
        }
        if (!inCluster) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            retVal = false;
        }
    }
    if (retVal) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    if (retVal && Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVdsGroup().getcompatibility_version().toString())) {
        // version 2.x)
        if (!VmCommand.validateNumberOfNics(getParameters().getVm().getInterfaces(), null)) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            retVal = false;
        }
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retVal;
}
#end_block

#method_before
private void processImages() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVmImages();
            MoveOrCopyAllImageGroups();
            VmDeviceUtils.addImportedDevices(getVm().getStaticData(), getVm().getId());
            VmHandler.LockVm(getVm().getId());
            return null;
        }
    });
}
#method_after
private void processImages() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmImagesAndSnapshots();
            updateSnapshotsFromExport();
            MoveOrCopyAllImageGroups();
            VmDeviceUtils.addImportedDevices(getVm().getStaticData(), getVm().getId(), new ArrayList<VmDevice>(), new ArrayList<VmDevice>());
            VmHandler.LockVm(getVm().getId());
            return null;
        }
    });
}
#end_block

#method_before
public static Map<String, List<DiskImage>> GetImagesLeaf(List<DiskImage> images) {
    Map<String, List<DiskImage>> retVal = new HashMap<String, List<DiskImage>>();
    for (DiskImage image : images) {
        if (!retVal.keySet().contains(image.getinternal_drive_mapping())) {
            retVal.put(image.getinternal_drive_mapping(), new ArrayList<DiskImage>(Arrays.asList(new DiskImage[] { image })));
        } else {
            retVal.get(image.getinternal_drive_mapping()).add(image);
        }
    }
    for (String key : retVal.keySet()) {
        SortImageList(retVal.get(key));
    }
    return retVal;
}
#method_after
public static Map<String, List<DiskImage>> GetImagesLeaf(List<DiskImage> images) {
    Map<String, List<DiskImage>> retVal = new HashMap<String, List<DiskImage>>();
    for (DiskImage image : images) {
        MultiValueMapUtils.addToMap(image.getinternal_drive_mapping(), image, retVal);
    }
    for (String key : retVal.keySet()) {
        SortImageList(retVal.get(key));
    }
    return retVal;
}
#end_block

#method_before
private void addInterfacesFromTemplate() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        iface.setId(Guid.NewGuid());
        iface.setVmTemplateId(null);
        iface.setVmId(getVm().getStaticData().getId());
        iface.setVmName(getVm().getvm_name());
        macAdded = vmInterfaceManager.add(iface, getCompensationContext());
    }
}
#method_after
private void addInterfacesFromTemplate() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        if (iface.getId() == null) {
            iface.setId(Guid.NewGuid());
        }
        iface.setVmTemplateId(null);
        iface.setVmId(getVm().getStaticData().getId());
        iface.setVmName(getVm().getvm_name());
        macAdded = vmInterfaceManager.add(iface, getCompensationContext());
    }
}
#end_block

#method_before
protected void EndImportCommand() {
    setVm(null);
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm().getId());
        UpdateVmImSpm();
    } else {
        setCommandShouldBeLogged(false);
        log.warn("ImportVmCommand::EndImportCommand: Vm is null - not performing full EndAction");
    }
    setSucceeded(true);
}
#method_after
protected void EndImportCommand() {
    setVm(null);
    EndActionOnAllImageGroups();
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm().getId());
        UpdateVmImSpm();
    } else {
        setCommandShouldBeLogged(false);
        log.warn("ImportVmCommand::EndImportCommand: Vm is null - not performing full EndAction");
    }
    setSucceeded(true);
}
#end_block

#method_before
private void auditInvalidInterfaces() {
    List<VmNetworkInterface> interfaces = getVm().getInterfaces();
    Map<String, network> networksByName = Entities.entitiesByName(DbFacade.getInstance().getNetworkDAO().getAllForCluster(getVm().getvds_group_id()));
    StringBuffer networks = new StringBuffer();
    for (VmNetworkInterface iface : interfaces) {
        if (networksByName.containsKey(iface.getNetworkName()) && !networksByName.get(iface.getNetworkName()).isVmNetwork()) {
            networks.append(iface.getNetworkName()).append(",");
        }
    }
    if (networks.length() > 0) {
        // remove the last comma
        networks.deleteCharAt(networks.length());
        AuditLogableBase logable = new AuditLogableBase();
        logable.AddCustomValue("Newtorks", networks.toString());
        AuditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_IMPORT_VM_INTERFACES_ON_NON_VM_NETWORKS);
    }
}
#method_after
private void auditInvalidInterfaces() {
    List<VmNetworkInterface> interfaces = getVm().getInterfaces();
    Map<String, network> networksByName = Entities.entitiesByName(DbFacade.getInstance().getNetworkDAO().getAllForCluster(getVm().getvds_group_id()));
    StringBuilder networks = new StringBuilder();
    StringBuilder ifaces = new StringBuilder();
    for (VmNetworkInterface iface : interfaces) {
        if (networksByName.containsKey(iface.getNetworkName()) && !networksByName.get(iface.getNetworkName()).isVmNetwork()) {
            networks.append(iface.getNetworkName()).append(",");
            ifaces.append(iface.getName()).append(",");
        }
    }
    if (networks.length() > 0) {
        // remove the last comma
        networks.deleteCharAt(networks.length());
        AuditLogableBase logable = new AuditLogableBase();
        logable.AddCustomValue("Newtorks", networks.toString());
        logable.AddCustomValue("Interfaces", ifaces.toString());
        AuditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_IMPORT_VM_INTERFACES_ON_NON_VM_NETWORKS);
    }
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    setActionReturnValue(VMStatus.Down);
    if (InitVm()) {
        if (getVm().getstatus() == VMStatus.Paused) {
            // resume
            ResumeVm();
        } else {
            // run vm
            if (!_isRerun && Boolean.TRUE.equals(getParameters().getRunAsStateless()) && !getVm().getDiskList().isEmpty() && getVm().getstatus() != VMStatus.Suspended) {
                StatelessVmTreatment();
            } else if (!getParameters().getIsInternal() && !_isRerun && getVm().getstatus() != VMStatus.Suspended && DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVm().getId()).size() > 0) {
                removeVmStatlessImages();
            } else {
                RunVm();
            }
        }
    } else {
        setActionReturnValue(getVm().getstatus());
    }
}
#method_after
@Override
protected void ExecuteVmCommand() {
    setActionReturnValue(VMStatus.Down);
    if (InitVm()) {
        if (getVm().getstatus() == VMStatus.Paused) {
            // resume
            ResumeVm();
        } else {
            // run vm
            if (!_isRerun && Boolean.TRUE.equals(getParameters().getRunAsStateless()) && !getVm().getDiskList().isEmpty() && getVm().getstatus() != VMStatus.Suspended) {
                StatelessVmTreatment();
            } else if (!getParameters().getIsInternal() && !_isRerun && getVm().getstatus() != VMStatus.Suspended && statelessSnapshotExistsForVm()) {
                removeVmStatlessImages();
            } else {
                RunVm();
            }
        }
    } else {
        setActionReturnValue(getVm().getstatus());
    }
}
#end_block

#method_before
private void StatelessVmTreatment() {
    /**
     * if one of vm's images is in the DB dont do anything.
     */
    if (DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVm().getId()).size() == 0) {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getvm_name(), getVm().getId());
        lockVmWithCompensationIfNeeded();
        CreateAllSnapshotsFromVmParameters tempVar = new CreateAllSnapshotsFromVmParameters(getVm().getId(), "stateless snapshot");
        tempVar.setShouldBeLogged(false);
        tempVar.setParentCommand(VdcActionType.RunVm);
        tempVar.setEntityId(getParameters().getEntityId());
        CreateAllSnapshotsFromVmParameters p = tempVar;
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, p, new CommandContext(getCompensationContext()));
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            // RestoreAllSnapshots)
            for (DiskImage disk : getVm().getDiskMap().values()) {
                /**
                 * add new stateless vm image to db
                 */
                DbFacade.getInstance().getDiskImageDAO().addStatelessVmImageMap(new stateless_vm_image_map(disk.getId(), disk.getinternal_drive_mapping(), getVm().getId()));
            }
            getParameters().getImagesParameters().add(p);
            getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the EndAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            if (vdcReturnValue.getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_IS_LOCKED.name())) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            } else {
                getReturnValue().setFault(vdcReturnValue.getFault());
            }
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getvm_name());
        }
    } else {
        log.errorFormat("RunVmAsStateless - {0} - found existing vm images in stateless_vm_image_map table - skipped creating snapshots.", getVm().getvm_name());
        removeVmStatlessImages();
    }
}
#method_after
private void StatelessVmTreatment() {
    if (statelessSnapshotExistsForVm()) {
        log.errorFormat("RunVmAsStateless - {0} - found existing vm images in stateless_vm_image_map table - skipped creating snapshots.", getVm().getvm_name());
        removeVmStatlessImages();
    } else {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getvm_name(), getVm().getId());
        CreateAllSnapshotsFromVmParameters tempVar = new CreateAllSnapshotsFromVmParameters(getVm().getId(), "stateless snapshot");
        tempVar.setShouldBeLogged(false);
        tempVar.setParentCommand(VdcActionType.RunVm);
        tempVar.setEntityId(getParameters().getEntityId());
        CreateAllSnapshotsFromVmParameters p = tempVar;
        p.setSnapshotType(SnapshotType.STATELESS);
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, p, new CommandContext(getCompensationContext()));
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getParameters().getImagesParameters().add(p);
            getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the EndAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            if (vdcReturnValue.getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_IS_LOCKED.name())) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            }
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getvm_name());
        }
    }
}
#end_block

#method_before
public static boolean CanRunVm(VM vm, java.util.ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector, SnapshotsValidator snapshotsValidator) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        if (message != null) {
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
        }
    } else if (!(validationErrors = VmPropertiesUtils.validateVMProperties(vm.getStaticData())).isEmpty()) {
        handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getdefault_boot_sequence();
        Guid storagePoolId = vm.getstorage_pool_id();
        // Block from running a VM with no HDD when its first boot device is
        // HD
        // and no other boot devices are configured
        List<DiskImage> vmImages = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vm.getId());
        if (boot_sequence == BootSequence.C && !checkVmHasPluggedDisk(vm)) {
            String messageStr = !vmImages.isEmpty() ? VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_PLUGGED_DISK.toString() : VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString();
            message.add(messageStr);
            retValue = false;
        } else {
            if (boot_sequence == BootSequence.CD && findActiveISODomain(storagePoolId) == null) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else // custom properties allowed only from cluster 2.3
            if (!StringHelper.isNullOrEmpty(vm.getStaticData().getCustomProperties()) && !Config.<Boolean>GetValue(ConfigValues.SupportCustomProperties, vm.getvds_group_compatibility_version().getValue())) {
                message.add(VdcBllMessages.CUSTOM_VM_PROPERTIES_INVALID_VALUES_NOT_ALLOWED_IN_CURRENT_CLUSTER.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence.toString().indexOf(NETWORK_BOOT_SEQUENCE_CHAR) > -1 && DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else if (vmImages.size() > 0) {
                    Guid storageDomainId = vmImages.get(0).getstorage_ids().get(0);
                    ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vm.getId());
                    if (!vmDuringSnapshotResult.isValid()) {
                        message.add(vmDuringSnapshotResult.getMessage().name());
                        retValue = false;
                    }
                    // if VM is not HA VM
                    if (retValue && !ImagesHandler.PerformImagesChecks(vm.getId(), message, vm.getstorage_pool_id(), storageDomainId, !vm.getauto_startup(), true, false, false, false, false, !vm.getauto_startup() && !storageDomainId.equals(Guid.Empty) || !runParams.getIsInternal() && vm.getauto_startup(), !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup())) {
                        retValue = false;
                    } else // Check if iso and floppy path exists
                    if (!vm.getauto_startup() && !validateIsoPath(findActiveISODomain(vm.getstorage_pool_id()), runParams, message)) {
                        retValue = false;
                    } else {
                        boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
                        if (vm.isStatusUp() || (vm.getstatus() == VMStatus.NotResponding) || isVmDuringInit) {
                            retValue = false;
                            if (message != null) {
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                            }
                        } else if (vm.getstatus() == VMStatus.Paused && vm.getrun_on_vds() != null) {
                            VDS vds = DbFacade.getInstance().getVdsDAO().get(new Guid(vm.getrun_on_vds().toString()));
                            if (vds.getstatus() != VDSStatus.Up) {
                                retValue = false;
                                if (message != null) {
                                    message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                                }
                            }
                        }
                        boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                        if (retValue && isStatelessVm && ImagesHandler.isVmInPreview(vmImages)) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                        }
                        // if the VM itself is stateless or run once as stateless
                        if (retValue && isStatelessVm && vm.getauto_startup()) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                        }
                        retValue = retValue == false ? retValue : vdsSelector.CanFindVdsToRunOn(message, false);
                        /**
                         * only if can do action ok then check with actions matrix that status is valid for this
                         * action
                         */
                        if (retValue && !VdcActionUtils.CanExecute(new java.util.ArrayList<IVdcQueryable>(java.util.Arrays.asList(new IVdcQueryable[] { vm })), VM.class, VdcActionType.RunVm)) {
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                            retValue = false;
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#method_after
public static boolean CanRunVm(VM vm, ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector, SnapshotsValidator snapshotsValidator) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        if (message != null) {
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
        }
    } else if (!(validationErrors = VmPropertiesUtils.validateVMProperties(vm.getStaticData())).isEmpty()) {
        handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getdefault_boot_sequence();
        Guid storagePoolId = vm.getstorage_pool_id();
        // Block from running a VM with no HDD when its first boot device is
        // HD
        // and no other boot devices are configured
        List<DiskImage> vmImages = getPluggedImages(vm);
        if (boot_sequence == BootSequence.C && vmImages.size() == 0) {
            String messageStr = !vmImages.isEmpty() ? VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_PLUGGED_DISK.toString() : VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString();
            message.add(messageStr);
            retValue = false;
        } else {
            if (boot_sequence == BootSequence.CD && findActiveISODomain(storagePoolId) == null) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else // custom properties allowed only from cluster 2.3
            if (!StringHelper.isNullOrEmpty(vm.getStaticData().getCustomProperties()) && !Config.<Boolean>GetValue(ConfigValues.SupportCustomProperties, vm.getvds_group_compatibility_version().getValue())) {
                message.add(VdcBllMessages.CUSTOM_VM_PROPERTIES_INVALID_VALUES_NOT_ALLOWED_IN_CURRENT_CLUSTER.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence == BootSequence.N && DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else if (vmImages.size() > 0) {
                    ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vm.getId());
                    if (!vmDuringSnapshotResult.isValid()) {
                        message.add(vmDuringSnapshotResult.getMessage().name());
                        retValue = false;
                    }
                    // if VM is not HA VM
                    if (retValue && !ImagesHandler.PerformImagesChecks(vm, message, vm.getstorage_pool_id(), Guid.Empty, !vm.getauto_startup(), true, false, false, false, false, !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup(), !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup(), vmImages)) {
                        retValue = false;
                    }
                    // Check if iso and floppy path exists
                    if (retValue && !vm.getauto_startup() && !validateIsoPath(findActiveISODomain(vm.getstorage_pool_id()), runParams, message)) {
                        retValue = false;
                    } else if (retValue) {
                        boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
                        if (vm.isStatusUp() || (vm.getstatus() == VMStatus.NotResponding) || isVmDuringInit) {
                            retValue = false;
                            if (message != null) {
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                            }
                        } else if (vm.getstatus() == VMStatus.Paused && vm.getrun_on_vds() != null) {
                            VDS vds = DbFacade.getInstance().getVdsDAO().get(new Guid(vm.getrun_on_vds().toString()));
                            if (vds.getstatus() != VDSStatus.Up) {
                                retValue = false;
                                if (message != null) {
                                    message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                                }
                            }
                        }
                        boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                        if (retValue && isStatelessVm && ImagesHandler.isVmInPreview(vm.getId())) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                        }
                        // if the VM itself is stateless or run once as stateless
                        if (retValue && isStatelessVm && vm.getauto_startup()) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                        }
                        retValue = retValue == false ? retValue : vdsSelector.CanFindVdsToRunOn(message, false);
                        /**
                         * only if can do action ok then check with actions matrix that status is valid for this
                         * action
                         */
                        if (retValue && !VdcActionUtils.CanExecute(Arrays.asList(vm), VM.class, VdcActionType.RunVm)) {
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                            retValue = false;
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected static boolean validateIsoPath(Guid storageDomainId, RunVmParams runParams, java.util.ArrayList<String> messages) {
    if (!StringHelper.isNullOrEmpty(runParams.getDiskPath())) {
        if (storageDomainId == null) {
            messages.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
            return false;
        }
        boolean retValForIso = false;
        VdcQueryReturnValue ret = Backend.getInstance().runInternalQuery(VdcQueryType.GetAllIsoImagesList, new GetAllIsoImagesListParameters(storageDomainId));
        if (ret != null && ret.getReturnValue() != null && ret.getSucceeded()) {
            List<RepoFileMetaData> repoFileNameList = (List<RepoFileMetaData>) ret.getReturnValue();
            if (repoFileNameList != null) {
                for (RepoFileMetaData isoFileMetaData : (List<RepoFileMetaData>) ret.getReturnValue()) {
                    if (isoFileMetaData.getRepoFileName().equals(runParams.getDiskPath())) {
                        retValForIso = true;
                        break;
                    }
                }
            }
        }
        if (!retValForIso) {
            messages.add(VdcBllMessages.ERROR_CANNOT_FIND_ISO_IMAGE_PATH.toString());
            return false;
        }
    }
    if (!StringHelper.isNullOrEmpty(runParams.getFloppyPath())) {
        boolean retValForFloppy = false;
        VdcQueryReturnValue ret = Backend.getInstance().runInternalQuery(VdcQueryType.GetAllFloppyImagesList, new GetAllIsoImagesListParameters(storageDomainId));
        if (ret != null && ret.getReturnValue() != null && ret.getSucceeded()) {
            List<RepoFileMetaData> repoFileNameList = (List<RepoFileMetaData>) ret.getReturnValue();
            if (repoFileNameList != null) {
                for (RepoFileMetaData isoFileMetaData : (List<RepoFileMetaData>) ret.getReturnValue()) {
                    if (isoFileMetaData.getRepoFileName().equals(runParams.getFloppyPath())) {
                        retValForFloppy = true;
                        break;
                    }
                }
            }
        }
        if (!retValForFloppy) {
            messages.add(VdcBllMessages.ERROR_CANNOT_FIND_FLOPPY_IMAGE_PATH.toString());
            return false;
        }
    }
    return true;
}
#method_after
@SuppressWarnings("unchecked")
protected static boolean validateIsoPath(Guid storageDomainId, RunVmParams runParams, ArrayList<String> messages) {
    if (!StringHelper.isNullOrEmpty(runParams.getDiskPath())) {
        if (storageDomainId == null) {
            messages.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
            return false;
        }
        boolean retValForIso = false;
        VdcQueryReturnValue ret = Backend.getInstance().runInternalQuery(VdcQueryType.GetAllIsoImagesList, new GetAllIsoImagesListParameters(storageDomainId));
        if (ret != null && ret.getReturnValue() != null && ret.getSucceeded()) {
            List<RepoFileMetaData> repoFileNameList = (List<RepoFileMetaData>) ret.getReturnValue();
            if (repoFileNameList != null) {
                for (RepoFileMetaData isoFileMetaData : (List<RepoFileMetaData>) ret.getReturnValue()) {
                    if (isoFileMetaData.getRepoFileName().equals(runParams.getDiskPath())) {
                        retValForIso = true;
                        break;
                    }
                }
            }
        }
        if (!retValForIso) {
            messages.add(VdcBllMessages.ERROR_CANNOT_FIND_ISO_IMAGE_PATH.toString());
            return false;
        }
    }
    if (!StringHelper.isNullOrEmpty(runParams.getFloppyPath())) {
        boolean retValForFloppy = false;
        VdcQueryReturnValue ret = Backend.getInstance().runInternalQuery(VdcQueryType.GetAllFloppyImagesList, new GetAllIsoImagesListParameters(storageDomainId));
        if (ret != null && ret.getReturnValue() != null && ret.getSucceeded()) {
            List<RepoFileMetaData> repoFileNameList = (List<RepoFileMetaData>) ret.getReturnValue();
            if (repoFileNameList != null) {
                for (RepoFileMetaData isoFileMetaData : (List<RepoFileMetaData>) ret.getReturnValue()) {
                    if (isoFileMetaData.getRepoFileName().equals(runParams.getFloppyPath())) {
                        retValForFloppy = true;
                        break;
                    }
                }
            }
        }
        if (!retValForFloppy) {
            messages.add(VdcBllMessages.ERROR_CANNOT_FIND_FLOPPY_IMAGE_PATH.toString());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // setting the RunVmParams Internal flag according to the command Internal flag.
    // we can not use only the command Internal flag and remove this flag from RunVmParams
    // since canRunVm is static and can not call non-static method isInternalExecution
    getParameters().setIsInternal(isInternalExecution());
    boolean canDoAction = CanRunVm();
    return canDoAction;
}
#method_after
@Override
protected boolean canDoAction() {
    // setting the RunVmParams Internal flag according to the command Internal flag.
    // we can not use only the command Internal flag and remove this flag from RunVmParams
    // since canRunVm is static and can not call non-static method isInternalExecution
    getParameters().setIsInternal(isInternalExecution());
    boolean canDoAction = CanRunVm(getVm(), getReturnValue().getCanDoActionMessages(), getParameters(), getVdsSelector(), getSnapshotsValidator()) && isVmInterfacesAttachedToVmNetworks();
    return canDoAction;
}
#end_block

#method_before
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__RUN);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__RUN);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
}
#end_block

#method_before
@Override
protected void EndWithFailure() {
    SetIsVmRunningStateless();
    if (_isVmRunningStateless) {
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), new CommandContext(getCompensationContext()));
        if (getVm() != null) {
            VmHandler.updateDisksFromDb(getVm());
            for (DiskImage disk : getVm().getDiskMap().values()) {
                /**
                 * remove stateless vm image from db:
                 */
                DbFacade.getInstance().getDiskImageDAO().removeStatelessVmImageMap(disk.getId());
            }
        } else {
            setCommandShouldBeLogged(false);
            log.warn("RunVmCommand::EndWithFailure [stateless]: Vm is null - not performing full EndAction");
        }
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snpashot.
    } else {
        super.EndWithFailure();
    }
}
#method_after
@Override
protected void EndWithFailure() {
    SetIsVmRunningStateless();
    if (_isVmRunningStateless) {
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), new CommandContext(getCompensationContext()));
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snpashot.
    } else {
        super.EndWithFailure();
    }
}
#end_block

#method_before
private void SetIsVmRunningStateless() {
    List<stateless_vm_image_map> list = DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVmId());
    _isVmRunningStateless = (list != null && list.size() > 0);
}
#method_after
private void SetIsVmRunningStateless() {
    _isVmRunningStateless = statelessSnapshotExistsForVm();
}
#end_block

#method_before
protected void removeQuotaCommandLeftOver() {
    QuotaManager.removeVdsGroupDeltaQuotaCommand(getQuotaId(), getVm().getvds_group_id(), getCommandId());
}
#method_after
@Override
protected void removeQuotaCommandLeftOver() {
    QuotaManager.removeVdsGroupDeltaQuotaCommand(getQuotaId(), getVm().getvds_group_id(), getCommandId());
}
#end_block

#method_before
private boolean isVmInterfacesAttachedToVmNetworks() {
    Map<String, VmNetworkInterface> interfacesByNetworkName = Entities.interfacesByNetworkName(getVm().getInterfaces());
    List<String> nonVmNetworkNames = NetworkUtils.filterNonVmNetworkNames(DbFacade.getInstance().getNetworkDAO().getAllForCluster(getVm().getvds_group_id()), interfacesByNetworkName.keySet());
    if (nonVmNetworkNames.size() > 0) {
        AddCustomValue("Networks", StringUtils.join(nonVmNetworkNames, ","));
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK);
        return false;
    }
    return true;
}
#method_after
private boolean isVmInterfacesAttachedToVmNetworks() {
    List<String> nonVmNetworkNames = NetworkUtils.filterNonVmNetworkNames(DbFacade.getInstance().getNetworkDAO().getAllForCluster(getVm().getvds_group_id()), Entities.interfacesByNetworkName(getVm().getInterfaces()).keySet());
    if (nonVmNetworkNames.size() > 0) {
        AddCustomValue("Networks", StringUtils.join(nonVmNetworkNames, ","));
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK);
        return false;
    }
    return true;
}
#end_block

#method_before
public static <E extends Nameble> Map<String, E> entitiesByName(List<E> entityList) {
    if (entityList != null) {
        Map<String, E> map = new HashMap<String, E>();
        for (E e : entityList) {
            map.put(e.getName(), e);
        }
        return map;
    } else {
        return Collections.emptyMap();
    }
}
#method_after
public static <E extends Nameable> Map<String, E> entitiesByName(List<E> entityList) {
    if (entityList != null) {
        Map<String, E> map = new HashMap<String, E>();
        for (E e : entityList) {
            map.put(e.getName(), e);
        }
        return map;
    } else {
        return Collections.emptyMap();
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((addr == null) ? 0 : addr.hashCode());
    // FIXME: remove cluster from hashCode calculation - breaks the tests when working in JDBC template mode
    /*
        result = prime * result + ((cluster == null) ? 0 : cluster.hashCode());
        */
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((gateway == null) ? 0 : gateway.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((storage_pool_id == null) ? 0 : storage_pool_id.hashCode());
    result = prime * result + (stp ? 1231 : 1237);
    result = prime * result + ((subnet == null) ? 0 : subnet.hashCode());
    result = prime * result + ((type == null) ? 0 : type.hashCode());
    result = prime * result + ((vlan_id == null) ? 0 : vlan_id.hashCode());
    result = prime * result + ((vmNetwork) ? 11 : 13);
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((addr == null) ? 0 : addr.hashCode());
    // FIXME: remove cluster from hashCode calculation - breaks the tests when working in JDBC template mode
    /*
        result = prime * result + ((cluster == null) ? 0 : cluster.hashCode());
        */
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((gateway == null) ? 0 : gateway.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((storage_pool_id == null) ? 0 : storage_pool_id.hashCode());
    result = prime * result + (stp ? 1231 : 1237);
    result = prime * result + ((subnet == null) ? 0 : subnet.hashCode());
    result = prime * result + ((type == null) ? 0 : type.hashCode());
    result = prime * result + ((vlan_id == null) ? 0 : vlan_id.hashCode());
    result = prime * result + (mtu);
    result = prime * result + ((vmNetwork) ? 11 : 13);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    network other = (network) obj;
    if (addr == null) {
        if (other.addr != null)
            return false;
    } else if (!addr.equals(other.addr))
        return false;
    /*
        if (cluster == null) {
            if (other.cluster != null)
                return false;
        } else if (!cluster.equals(other.cluster))
            return false;
            */
    if (description == null) {
        if (other.description != null)
            return false;
    } else if (!description.equals(other.description))
        return false;
    if (gateway == null) {
        if (other.gateway != null)
            return false;
    } else if (!gateway.equals(other.gateway))
        return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (name == null) {
        if (other.name != null)
            return false;
    } else if (!name.equals(other.name))
        return false;
    if (storage_pool_id == null) {
        if (other.storage_pool_id != null)
            return false;
    } else if (!storage_pool_id.equals(other.storage_pool_id))
        return false;
    if (stp != other.stp)
        return false;
    if (subnet == null) {
        if (other.subnet != null)
            return false;
    } else if (!subnet.equals(other.subnet))
        return false;
    if (type == null) {
        if (other.type != null)
            return false;
    } else if (!type.equals(other.type))
        return false;
    if (vlan_id == null) {
        if (other.vlan_id != null)
            return false;
    } else if (!vlan_id.equals(other.vlan_id))
        return false;
    if (vmNetwork != other.vmNetwork) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    network other = (network) obj;
    if (addr == null) {
        if (other.addr != null)
            return false;
    } else if (!addr.equals(other.addr))
        return false;
    /*
        if (cluster == null) {
            if (other.cluster != null)
                return false;
        } else if (!cluster.equals(other.cluster))
            return false;
            */
    if (description == null) {
        if (other.description != null)
            return false;
    } else if (!description.equals(other.description))
        return false;
    if (gateway == null) {
        if (other.gateway != null)
            return false;
    } else if (!gateway.equals(other.gateway))
        return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (name == null) {
        if (other.name != null)
            return false;
    } else if (!name.equals(other.name))
        return false;
    if (storage_pool_id == null) {
        if (other.storage_pool_id != null)
            return false;
    } else if (!storage_pool_id.equals(other.storage_pool_id))
        return false;
    if (stp != other.stp)
        return false;
    if (subnet == null) {
        if (other.subnet != null)
            return false;
    } else if (!subnet.equals(other.subnet))
        return false;
    if (type == null) {
        if (other.type != null)
            return false;
    } else if (!type.equals(other.type))
        return false;
    if (vlan_id == null) {
        if (other.vlan_id != null)
            return false;
    } else if (!vlan_id.equals(other.vlan_id))
        return false;
    if (mtu != other.mtu)
        return false;
    if (vmNetwork != other.vmNetwork) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Test
public /**
 * test setup: 2 existing cluster networks, red and blue, only blue is currently attached to the host
 * test case: sending "red" as the network to add
 * expected: network blue should return from the function
 */
void extractRemovedNetwork() {
    initMocks(null, null);
    SetupNetworksHelper helper = createHelper(new SetupNetworksParameters());
    String[] networkNames = { "red" };
    Map<String, network> clusterNetworksMap = new HashMap<String, network>();
    clusterNetworksMap.put("red", new network(null, null, null, "red", null, null, 1, 100, false, true));
    clusterNetworksMap.put("blue", new network(null, null, null, "blue", null, null, 1, 100, false, true));
    List<network> removeNetworks = helper.extractRemoveNetworks(new HashSet<String>(asList(networkNames)), clusterNetworksMap, Arrays.asList("blue"));
    assertTrue(removeNetworks.get(0).getname().equals("blue"));
}
#method_after
@Test
public /**
 * test setup: 2 existing cluster networks, red and blue, only blue is currently attached to the host
 * test case: sending "red" as the network to add
 * expected: network blue should return from the function
 */
void extractRemovedNetwork() {
    initMocks(null, null);
    SetupNetworksHelper helper = createHelper(new SetupNetworksParameters());
    String[] networkNames = { "red" };
    Map<String, network> clusterNetworksMap = new HashMap<String, network>();
    clusterNetworksMap.put("red", new network(null, null, null, "red", null, null, 1, 100, false, 1500, true));
    clusterNetworksMap.put("blue", new network(null, null, null, "blue", null, null, 1, 100, false, 1500, true));
    List<network> removeNetworks = helper.extractRemoveNetworks(new HashSet<String>(asList(networkNames)), clusterNetworksMap, Arrays.asList("blue"));
    assertTrue(removeNetworks.get(0).getname().equals("blue"));
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(network network) {
    return getCustomMapSqlParameterSource().addValue("addr", network.getaddr()).addValue("description", network.getdescription()).addValue("id", network.getId()).addValue("name", network.getname()).addValue("subnet", network.getsubnet()).addValue("gateway", network.getgateway()).addValue("type", network.gettype()).addValue("vlan_id", network.getvlan_id()).addValue("stp", network.getstp()).addValue("storage_pool_id", network.getstorage_pool_id()).addValue("vm_network", network.isVmNetwork());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(network network) {
    return getCustomMapSqlParameterSource().addValue("addr", network.getaddr()).addValue("description", network.getdescription()).addValue("id", network.getId()).addValue("name", network.getname()).addValue("subnet", network.getsubnet()).addValue("gateway", network.getgateway()).addValue("type", network.gettype()).addValue("vlan_id", network.getvlan_id()).addValue("stp", network.getstp()).addValue("storage_pool_id", network.getstorage_pool_id()).addValue("mtu", network.getMtu()).addValue("vm_network", network.isVmNetwork());
}
#end_block

#method_before
@Override
public void saveInterfaceForVds(VdsNetworkInterface stats) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("addr", stats.getAddress()).addValue("bond_name", stats.getBondName()).addValue("bond_type", stats.getBondType()).addValue("gateway", stats.getGateway()).addValue("id", stats.getId()).addValue("is_bond", stats.getBonded()).addValue("bond_opts", stats.getBondOptions()).addValue("mac_addr", stats.getMacAddress()).addValue("name", stats.getName()).addValue("network_name", stats.getNetworkName()).addValue("speed", stats.getSpeed()).addValue("subnet", stats.getSubnet()).addValue("boot_protocol", stats.getBootProtocol()).addValue("type", stats.getType()).addValue("vds_id", stats.getVdsId()).addValue("vlan_id", stats.getVlanId()).addValue("bridged", stats.isBridged());
    getCallsHandler().executeModification("Insertvds_interface", parameterSource);
}
#method_after
@Override
public void saveInterfaceForVds(VdsNetworkInterface stats) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("addr", stats.getAddress()).addValue("bond_name", stats.getBondName()).addValue("bond_type", stats.getBondType()).addValue("gateway", stats.getGateway()).addValue("id", stats.getId()).addValue("is_bond", stats.getBonded()).addValue("bond_opts", stats.getBondOptions()).addValue("mac_addr", stats.getMacAddress()).addValue("name", stats.getName()).addValue("network_name", stats.getNetworkName()).addValue("speed", stats.getSpeed()).addValue("subnet", stats.getSubnet()).addValue("boot_protocol", stats.getBootProtocol()).addValue("type", stats.getType()).addValue("vds_id", stats.getVdsId()).addValue("vlan_id", stats.getVlanId()).addValue("mtu", stats.getMtu()).addValue("bridged", stats.isBridged());
    getCallsHandler().executeModification("Insertvds_interface", parameterSource);
}
#end_block

#method_before
@Override
public void updateInterfaceForVds(VdsNetworkInterface stats) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("addr", stats.getAddress()).addValue("bond_name", stats.getBondName()).addValue("bond_type", stats.getBondType()).addValue("gateway", stats.getGateway()).addValue("id", stats.getId()).addValue("is_bond", stats.getBonded()).addValue("bond_opts", stats.getBondOptions()).addValue("mac_addr", stats.getMacAddress()).addValue("name", stats.getName()).addValue("network_name", stats.getNetworkName()).addValue("speed", stats.getSpeed()).addValue("subnet", stats.getSubnet()).addValue("boot_protocol", stats.getBootProtocol()).addValue("type", stats.getType()).addValue("vds_id", stats.getVdsId()).addValue("vlan_id", stats.getVlanId()).addValue("bridged", stats.isBridged());
    getCallsHandler().executeModification("Updatevds_interface", parameterSource);
}
#method_after
@Override
public void updateInterfaceForVds(VdsNetworkInterface stats) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("addr", stats.getAddress()).addValue("bond_name", stats.getBondName()).addValue("bond_type", stats.getBondType()).addValue("gateway", stats.getGateway()).addValue("id", stats.getId()).addValue("is_bond", stats.getBonded()).addValue("bond_opts", stats.getBondOptions()).addValue("mac_addr", stats.getMacAddress()).addValue("name", stats.getName()).addValue("network_name", stats.getNetworkName()).addValue("speed", stats.getSpeed()).addValue("subnet", stats.getSubnet()).addValue("boot_protocol", stats.getBootProtocol()).addValue("type", stats.getType()).addValue("vds_id", stats.getVdsId()).addValue("vlan_id", stats.getVlanId()).addValue("mtu", stats.getMtu()).addValue("bridged", stats.isBridged());
    getCallsHandler().executeModification("Updatevds_interface", parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<VdsNetworkInterface> getAllInterfacesForVds(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_id", id);
    ParameterizedRowMapper<VdsNetworkInterface> mapper = new ParameterizedRowMapper<VdsNetworkInterface>() {

        @Override
        public VdsNetworkInterface mapRow(ResultSet rs, int rowNum) throws SQLException {
            VdsNetworkInterface entity = new VdsNetworkInterface();
            entity.getStatistics().setId(Guid.createGuidFromString(rs.getString("id")));
            entity.getStatistics().setReceiveRate(rs.getDouble("rx_rate"));
            entity.getStatistics().setTransmitRate(rs.getDouble("tx_rate"));
            entity.getStatistics().setReceiveDropRate(rs.getDouble("rx_drop"));
            entity.getStatistics().setTransmitDropRate(rs.getDouble("tx_drop"));
            entity.getStatistics().setStatus(InterfaceStatus.forValue(rs.getInt("iface_status")));
            entity.getStatistics().setVdsId(Guid.createGuidFromString(rs.getString("vds_id")));
            entity.setType((Integer) rs.getObject("type"));
            entity.setGateway(rs.getString("gateway"));
            entity.setSubnet(rs.getString("subnet"));
            entity.setAddress(rs.getString("addr"));
            entity.setSpeed((Integer) rs.getObject("speed"));
            entity.setVlanId((Integer) rs.getObject("vlan_id"));
            entity.setBondType((Integer) rs.getObject("bond_type"));
            entity.setBondName(rs.getString("bond_name"));
            entity.setBonded((Boolean) rs.getObject("is_bond"));
            entity.setBondOptions(rs.getString("bond_opts"));
            entity.setMacAddress(rs.getString("mac_addr"));
            entity.setNetworkName(rs.getString("network_name"));
            entity.setName(rs.getString("name"));
            entity.setVdsId(NGuid.createGuidFromString(rs.getString("vds_id")));
            entity.setVdsName(rs.getString("vds_name"));
            entity.setId(Guid.createGuidFromString(rs.getString("id")));
            entity.setBootProtocol(NetworkBootProtocol.forValue(rs.getInt("boot_protocol")));
            entity.setBridged(rs.getBoolean("bridged"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("Getinterface_viewByvds_id", mapper, parameterSource);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public List<VdsNetworkInterface> getAllInterfacesForVds(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_id", id);
    ParameterizedRowMapper<VdsNetworkInterface> mapper = new ParameterizedRowMapper<VdsNetworkInterface>() {

        @Override
        public VdsNetworkInterface mapRow(ResultSet rs, int rowNum) throws SQLException {
            VdsNetworkInterface entity = new VdsNetworkInterface();
            entity.getStatistics().setId(Guid.createGuidFromString(rs.getString("id")));
            entity.getStatistics().setReceiveRate(rs.getDouble("rx_rate"));
            entity.getStatistics().setTransmitRate(rs.getDouble("tx_rate"));
            entity.getStatistics().setReceiveDropRate(rs.getDouble("rx_drop"));
            entity.getStatistics().setTransmitDropRate(rs.getDouble("tx_drop"));
            entity.getStatistics().setStatus(InterfaceStatus.forValue(rs.getInt("iface_status")));
            entity.getStatistics().setVdsId(Guid.createGuidFromString(rs.getString("vds_id")));
            entity.setType((Integer) rs.getObject("type"));
            entity.setGateway(rs.getString("gateway"));
            entity.setSubnet(rs.getString("subnet"));
            entity.setAddress(rs.getString("addr"));
            entity.setSpeed((Integer) rs.getObject("speed"));
            entity.setVlanId((Integer) rs.getObject("vlan_id"));
            entity.setBondType((Integer) rs.getObject("bond_type"));
            entity.setBondName(rs.getString("bond_name"));
            entity.setBonded((Boolean) rs.getObject("is_bond"));
            entity.setBondOptions(rs.getString("bond_opts"));
            entity.setMacAddress(rs.getString("mac_addr"));
            entity.setNetworkName(rs.getString("network_name"));
            entity.setName(rs.getString("name"));
            entity.setVdsId(NGuid.createGuidFromString(rs.getString("vds_id")));
            entity.setVdsName(rs.getString("vds_name"));
            entity.setId(Guid.createGuidFromString(rs.getString("id")));
            entity.setBootProtocol(NetworkBootProtocol.forValue(rs.getInt("boot_protocol")));
            entity.setMtu(rs.getInt("mtu"));
            entity.setBridged(rs.getBoolean("bridged"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("Getinterface_viewByvds_id", mapper, parameterSource);
}
#end_block

#method_before
@Override
protected void buildVmBootSequence() {
    // Check if boot sequence in parameters is diffrent from default boot sequence
    if (managedDevices != null) {
        // recalculate boot order from source devices and set it to target devices
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm.getStaticData(), managedDevices, vm.getboot_sequence(), VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version()));
        for (VmDevice vmDevice : managedDevices) {
            for (int i = 0; i < devices.size(); i++) {
                XmlRpcStruct struct = (XmlRpcStruct) devices.get(i);
                Object o = struct.getItem(VdsProperties.SpecParams);
                if (o instanceof Map<?, ?>) {
                    if (StringUtils.map2String((Map<String, String>) o).indexOf(vmDevice.getDeviceId().toString()) > 0) {
                        struct.add(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
                        break;
                    }
                }
            }
        }
    }
}
#method_after
@Override
protected void buildVmBootSequence() {
    // Check if boot sequence in parameters is diffrent from default boot sequence
    if (managedDevices != null) {
        // recalculate boot order from source devices and set it to target devices
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm.getStaticData(), managedDevices, vm.getboot_sequence(), VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version()));
        for (VmDevice vmDevice : managedDevices) {
            for (XmlRpcStruct struct : devices) {
                Object o = struct.getItem(VdsProperties.SpecParams);
                if (o instanceof Map<?, ?>) {
                    if (StringUtils.map2String((Map<String, String>) o).contains(vmDevice.getDeviceId().toString())) {
                        struct.add(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
                        break;
                    }
                } else {
                    log.errorFormat("Improper value of spec_params for VM {0} : {1}", vm.getvm_name(), o.toString());
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    storage_domains dom = getStorageDomain();
    if (dom == null) {
        addCanDoActionMessage(VdcBllMessages.CANNOT_REMOVE_STORAGE_DOMAIN_INVALID_STORAGE_DOMAIN_ID);
        return false;
    }
    VDS vds = getVds();
    boolean format = getParameters().getDoFormat();
    boolean localFs = isLocalFs(dom);
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REMOVE);
    if (!CheckStorageDomain() || !checkStorageDomainSharedStatusNotLocked(dom)) {
        return false;
    }
    if (!localFs && !CheckStorageDomainNotInPool()) {
        return false;
    }
    if (localFs && isDomainAttached(dom) && !canDetachDomain(getParameters().getDestroyingPool(), false, true)) {
        return false;
    }
    if (vds == null) {
        if (localFs) {
            if (!InitializeVds()) {
                return false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.CANNOT_REMOVE_STORAGE_DOMAIN_INVALID_HOST_ID);
            return false;
        }
    }
    if (isDataDomain(dom) && !format) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_REMOVE_STORAGE_DOMAIN_DO_FORMAT);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    storage_domains dom = getStorageDomain();
    if (dom == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
        return false;
    }
    VDS vds = getVds();
    boolean format = getParameters().getDoFormat();
    boolean localFs = isLocalFs(dom);
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REMOVE);
    if (!CheckStorageDomain() || !checkStorageDomainSharedStatusNotLocked(dom)) {
        return false;
    }
    if (!localFs && !CheckStorageDomainNotInPool()) {
        return false;
    }
    if (localFs && isDomainAttached(dom) && !canDetachDomain(getParameters().getDestroyingPool(), false, true)) {
        return false;
    }
    if (vds == null) {
        if (localFs) {
            if (!InitializeVds()) {
                return false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.CANNOT_REMOVE_STORAGE_DOMAIN_INVALID_HOST_ID);
            return false;
        }
    }
    if (isDataDomain(dom) && !format) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_REMOVE_STORAGE_DOMAIN_DO_FORMAT);
        return false;
    }
    return true;
}
#end_block

#method_before
@Test
public void testCanDoActionNonExistingStorageDomain() {
    // All the mock DAOs return nulls (which mocks the objects do not exist)
    // canDoAction should return false, not crash with NullPointerExcpetion
    assertFalse("canDoActtion shouldn't be possible for a non-existant storage domain", command.canDoAction());
    List<String> messages = command.getReturnValue().getCanDoActionMessages();
    assertEquals("Wrong number of messages", 2, messages.size());
    assertEquals("Wrong message", VdcBllMessages.VAR__TYPE__STORAGE__DOMAIN.name(), messages.get(0));
    assertEquals("Wrong message", VdcBllMessages.CANNOT_REMOVE_STORAGE_DOMAIN_INVALID_STORAGE_DOMAIN_ID.name(), messages.get(1));
}
#method_after
@Test
public void testCanDoActionNonExistingStorageDomain() {
    // All the mock DAOs return nulls (which mocks the objects do not exist)
    // canDoAction should return false, not crash with NullPointerExcpetion
    assertFalse("canDoActtion shouldn't be possible for a non-existant storage domain", command.canDoAction());
    List<String> messages = command.getReturnValue().getCanDoActionMessages();
    assertEquals("Wrong number of messages", 2, messages.size());
    assertEquals("Wrong message", VdcBllMessages.VAR__TYPE__STORAGE__DOMAIN.name(), messages.get(0));
    assertEquals("Wrong message", VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.name(), messages.get(1));
}
#end_block

#method_before
public static boolean CanRunVm(VM vm, ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector, SnapshotsValidator snapshotsValidator) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        if (message != null) {
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
        }
    } else if (!(validationErrors = VmPropertiesUtils.validateVMProperties(vm.getStaticData())).isEmpty()) {
        handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getdefault_boot_sequence();
        Guid storagePoolId = vm.getstorage_pool_id();
        // Block from running a VM with no HDD when its first boot device is
        // HD
        // and no other boot devices are configured
        List<DiskImage> vmImages = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vm.getId());
        if (boot_sequence == BootSequence.C && !checkVmHasPluggedDisk(vm)) {
            String messageStr = !vmImages.isEmpty() ? VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_PLUGGED_DISK.toString() : VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString();
            message.add(messageStr);
            retValue = false;
        } else {
            if (boot_sequence == BootSequence.CD && findActiveISODomain(storagePoolId) == null) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else // custom properties allowed only from cluster 2.3
            if (!StringHelper.isNullOrEmpty(vm.getStaticData().getCustomProperties()) && !Config.<Boolean>GetValue(ConfigValues.SupportCustomProperties, vm.getvds_group_compatibility_version().getValue())) {
                message.add(VdcBllMessages.CUSTOM_VM_PROPERTIES_INVALID_VALUES_NOT_ALLOWED_IN_CURRENT_CLUSTER.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence == BootSequence.N && DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else if (vmImages.size() > 0) {
                    ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vm.getId());
                    if (!vmDuringSnapshotResult.isValid()) {
                        message.add(vmDuringSnapshotResult.getMessage().name());
                        retValue = false;
                    }
                    // if VM is not HA VM
                    if (retValue && !ImagesHandler.PerformImagesChecks(vm, message, vm.getstorage_pool_id(), Guid.Empty, !vm.getauto_startup(), true, false, false, false, false, !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup(), !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup(), vmImages)) {
                        retValue = false;
                    }
                    // Check if iso and floppy path exists
                    if (retValue && !vm.getauto_startup() && !validateIsoPath(findActiveISODomain(vm.getstorage_pool_id()), runParams, message)) {
                        retValue = false;
                    } else if (retValue) {
                        boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
                        if (vm.isStatusUp() || (vm.getstatus() == VMStatus.NotResponding) || isVmDuringInit) {
                            retValue = false;
                            if (message != null) {
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                            }
                        } else if (vm.getstatus() == VMStatus.Paused && vm.getrun_on_vds() != null) {
                            VDS vds = DbFacade.getInstance().getVdsDAO().get(new Guid(vm.getrun_on_vds().toString()));
                            if (vds.getstatus() != VDSStatus.Up) {
                                retValue = false;
                                if (message != null) {
                                    message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                                }
                            }
                        }
                        boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                        if (retValue && isStatelessVm && ImagesHandler.isVmInPreview(vm.getId())) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                        }
                        // if the VM itself is stateless or run once as stateless
                        if (retValue && isStatelessVm && vm.getauto_startup()) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                        }
                        retValue = retValue == false ? retValue : vdsSelector.CanFindVdsToRunOn(message, false);
                        /**
                         * only if can do action ok then check with actions matrix that status is valid for this
                         * action
                         */
                        if (retValue && !VdcActionUtils.CanExecute(Arrays.asList(vm), VM.class, VdcActionType.RunVm)) {
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                            retValue = false;
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#method_after
public static boolean CanRunVm(VM vm, ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector, SnapshotsValidator snapshotsValidator) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        if (message != null) {
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
        }
    } else if (!(validationErrors = VmPropertiesUtils.validateVMProperties(vm.getStaticData())).isEmpty()) {
        handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getdefault_boot_sequence();
        Guid storagePoolId = vm.getstorage_pool_id();
        // Block from running a VM with no HDD when its first boot device is
        // HD
        // and no other boot devices are configured
        List<DiskImage> vmImages = getPluggedImages(vm);
        if (boot_sequence == BootSequence.C && vmImages.size() == 0) {
            String messageStr = !vmImages.isEmpty() ? VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_PLUGGED_DISK.toString() : VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString();
            message.add(messageStr);
            retValue = false;
        } else {
            if (boot_sequence == BootSequence.CD && findActiveISODomain(storagePoolId) == null) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else // custom properties allowed only from cluster 2.3
            if (!StringHelper.isNullOrEmpty(vm.getStaticData().getCustomProperties()) && !Config.<Boolean>GetValue(ConfigValues.SupportCustomProperties, vm.getvds_group_compatibility_version().getValue())) {
                message.add(VdcBllMessages.CUSTOM_VM_PROPERTIES_INVALID_VALUES_NOT_ALLOWED_IN_CURRENT_CLUSTER.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence == BootSequence.N && DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else if (vmImages.size() > 0) {
                    ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vm.getId());
                    if (!vmDuringSnapshotResult.isValid()) {
                        message.add(vmDuringSnapshotResult.getMessage().name());
                        retValue = false;
                    }
                    // if VM is not HA VM
                    if (retValue && !ImagesHandler.PerformImagesChecks(vm, message, vm.getstorage_pool_id(), Guid.Empty, !vm.getauto_startup(), true, false, false, false, false, !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup(), !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup(), vmImages)) {
                        retValue = false;
                    }
                    // Check if iso and floppy path exists
                    if (retValue && !vm.getauto_startup() && !validateIsoPath(findActiveISODomain(vm.getstorage_pool_id()), runParams, message)) {
                        retValue = false;
                    } else if (retValue) {
                        boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
                        if (vm.isStatusUp() || (vm.getstatus() == VMStatus.NotResponding) || isVmDuringInit) {
                            retValue = false;
                            if (message != null) {
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                            }
                        } else if (vm.getstatus() == VMStatus.Paused && vm.getrun_on_vds() != null) {
                            VDS vds = DbFacade.getInstance().getVdsDAO().get(new Guid(vm.getrun_on_vds().toString()));
                            if (vds.getstatus() != VDSStatus.Up) {
                                retValue = false;
                                if (message != null) {
                                    message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                                }
                            }
                        }
                        boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                        if (retValue && isStatelessVm && ImagesHandler.isVmInPreview(vm.getId())) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                        }
                        // if the VM itself is stateless or run once as stateless
                        if (retValue && isStatelessVm && vm.getauto_startup()) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                        }
                        retValue = retValue == false ? retValue : vdsSelector.CanFindVdsToRunOn(message, false);
                        /**
                         * only if can do action ok then check with actions matrix that status is valid for this
                         * action
                         */
                        if (retValue && !VdcActionUtils.CanExecute(Arrays.asList(vm), VM.class, VdcActionType.RunVm)) {
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                            retValue = false;
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#end_block

#method_before
private String getGlusterVolumeRegexString(SearchObjectAutoCompleter search) {
    return ".*" + search.getDefaultSort(SearchObjects.GLUSTER_VOLUMES_OBJ_NAME) + ".*" + search.getRelatedTableNameWithOutTags(SearchObjects.GLUSTER_VOLUMES_OBJ_NAME) + ".* " + search.getPrimeryKeyName(SearchObjects.GLUSTER_VOLUMES_OBJ_NAME) + ".*";
}
#method_after
private String getGlusterVolumeRegexString(SearchObjectAutoCompleter search) {
    return ".*" + search.getDefaultSort(SearchObjects.GLUSTER_VOLUME_OBJ_NAME) + ".*" + search.getRelatedTableNameWithOutTags(SearchObjects.GLUSTER_VOLUME_OBJ_NAME) + ".* " + search.getPrimeryKeyName(SearchObjects.GLUSTER_VOLUME_OBJ_NAME) + ".*";
}
#end_block

#method_before
public IAutoCompleter getCrossRefAutoCompleter(String obj) {
    if (obj == null) {
        return null;
    }
    if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        return new AuditCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        return new TemplateCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        return new UserCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        return new VdsCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        return new VmCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        return new ClusterCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        return new StoragePoolCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        return new StorageDomainCrossRefAutoCompleter();
    // no need for empty case before default: case
    // SearchObjects.VDC_POOL_OBJ_NAME:
    // no need for empty case before default: case
    // SearchObjects.VDC_POOL_PLU_OBJ_NAME:
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUMES_OBJ_NAME)) {
        return GlusterVolumeCrossRefAutoCompleter.INSTANCE;
    } else {
        return null;
    }
}
#method_after
public IAutoCompleter getCrossRefAutoCompleter(String obj) {
    if (obj == null) {
        return null;
    }
    if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        return new AuditCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        return new TemplateCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        return new UserCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        return new VdsCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        return new VmCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        return new ClusterCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        return new StoragePoolCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        return new StorageDomainCrossRefAutoCompleter();
    // no need for empty case before default: case
    // SearchObjects.VDC_POOL_OBJ_NAME:
    // no need for empty case before default: case
    // SearchObjects.VDC_POOL_PLU_OBJ_NAME:
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_PLU_OBJ_NAME)) {
        return GlusterVolumeCrossRefAutoCompleter.INSTANCE;
    } else {
        return null;
    }
}
#end_block

#method_before
public IConditionFieldAutoCompleter getFieldAutoCompleter(String obj) {
    IConditionFieldAutoCompleter retval = null;
    if (obj == null) {
        return null;
    }
    if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        retval = new VdsConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        retval = new VmConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        retval = new VmTemplateConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        retval = new AuditLogConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        retval = new VdcUserConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_POOL_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_POOL_PLU_OBJ_NAME)) {
        retval = new PoolConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_PLU_OBJ_NAME)) {
        retval = new DiskImageConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        retval = new ClusterConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        retval = new StoragePoolFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        retval = new StorageDomainFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUMES_OBJ_NAME)) {
        retval = GlusterVolumeConditionFieldAutoCompleter.INSTANCE;
    }
    return retval;
}
#method_after
public IConditionFieldAutoCompleter getFieldAutoCompleter(String obj) {
    IConditionFieldAutoCompleter retval = null;
    if (obj == null) {
        return null;
    }
    if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        retval = new VdsConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        retval = new VmConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        retval = new VmTemplateConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        retval = new AuditLogConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        retval = new VdcUserConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_POOL_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_POOL_PLU_OBJ_NAME)) {
        retval = new PoolConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_PLU_OBJ_NAME)) {
        retval = new DiskImageConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        retval = new ClusterConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        retval = new StoragePoolFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        retval = new StorageDomainFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_PLU_OBJ_NAME)) {
        retval = GlusterVolumeConditionFieldAutoCompleter.INSTANCE;
    }
    return retval;
}
#end_block

#method_before
public String getRelatedTableName(String obj) {
    String retval = null;
    if (obj == null) {
        return retval;
    }
    if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        retval = "vds_with_tags";
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        retval = "vms_with_tags";
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        retval = "vm_templates_storage_domain";
    } else if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        retval = "audit_log";
    } else if (StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_PLU_OBJ_NAME)) {
        retval = "vm_images_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        retval = "vdc_users_with_tags";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_POOL_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_POOL_PLU_OBJ_NAME)) {
        retval = "vm_pools_full_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        retval = "vds_groups_storage_domain";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        retval = "storage_pool_with_storage_domain";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        retval = "storage_domains_with_hosts_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUMES_OBJ_NAME)) {
        retval = "gluster_volumes";
    }
    return retval;
}
#method_after
public String getRelatedTableName(String obj) {
    String retval = null;
    if (obj == null) {
        return retval;
    }
    if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        retval = "vds_with_tags";
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        retval = "vms_with_tags";
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        retval = "vm_templates_storage_domain";
    } else if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        retval = "audit_log";
    } else if (StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_PLU_OBJ_NAME)) {
        retval = "vm_images_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        retval = "vdc_users_with_tags";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_POOL_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_POOL_PLU_OBJ_NAME)) {
        retval = "vm_pools_full_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        retval = "vds_groups_storage_domain";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        retval = "storage_pool_with_storage_domain";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        retval = "storage_domains_with_hosts_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_PLU_OBJ_NAME)) {
        retval = "gluster_volumes";
    }
    return retval;
}
#end_block

#method_before
public String getPrimeryKeyName(String obj) {
    String retval = null;
    if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        retval = "vds_id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        retval = "vm_guid";
    } else if (StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_PLU_OBJ_NAME)) {
        retval = "image_guid";
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        retval = "vmt_guid";
    } else if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        retval = "audit_log_id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        retval = "user_id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_POOL_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_POOL_PLU_OBJ_NAME)) {
        retval = "vm_pool_id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        retval = "vds_group_id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        retval = "id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        retval = "id";
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUMES_OBJ_NAME)) {
        retval = "id";
    }
    return retval;
}
#method_after
public String getPrimeryKeyName(String obj) {
    String retval = null;
    if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        retval = "vds_id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        retval = "vm_guid";
    } else if (StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_PLU_OBJ_NAME)) {
        retval = "image_guid";
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        retval = "vmt_guid";
    } else if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        retval = "audit_log_id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        retval = "user_id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_POOL_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_POOL_PLU_OBJ_NAME)) {
        retval = "vm_pool_id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        retval = "vds_group_id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        retval = "id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        retval = "id";
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_PLU_OBJ_NAME)) {
        retval = "id";
    }
    return retval;
}
#end_block

#method_before
public String getDefaultSort(String obj) {
    String retval = "";
    if (obj == null) {
        return retval;
    }
    if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        retval = "vds_name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        retval = "vm_name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_PLU_OBJ_NAME)) {
        retval = "disk_name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        retval = "audit_log_id DESC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        retval = "name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        retval = "name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_POOL_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_POOL_PLU_OBJ_NAME)) {
        retval = "vm_pool_name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        retval = "name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        retval = "storage_name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        retval = "name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUMES_OBJ_NAME)) {
        retval = "vol_name ASC ";
    }
    return retval;
}
#method_after
public String getDefaultSort(String obj) {
    String retval = "";
    if (obj == null) {
        return retval;
    }
    if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        retval = "vds_name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        retval = "vm_name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_PLU_OBJ_NAME)) {
        retval = "disk_name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        retval = "audit_log_id DESC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        retval = "name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        retval = "name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_POOL_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_POOL_PLU_OBJ_NAME)) {
        retval = "vm_pool_name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        retval = "name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        retval = "storage_name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        retval = "name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_PLU_OBJ_NAME)) {
        retval = "vol_name ASC ";
    }
    return retval;
}
#end_block

#method_before
private static void init() {
    final char SEPERATOR = ':';
    SAFE_SEARCH_EXPR.add(VDS_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDS_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VM_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VM_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(AUDIT_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(AUDIT_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(TEMPLATE_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(TEMPLATE_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_USER_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_USER_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_POOL_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_POOL_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_CLUSTER_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_CLUSTER_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_STORAGE_POOL_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_STORAGE_DOMAIN_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(DISK_IMAGE_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(DISK_IMAGE_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(GLUSTER_VOLUMES_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(ALERT.toLowerCase());
    SAFE_SEARCH_EXPR.add(ERROR.toLowerCase());
    SAFE_SEARCH_EXPR.add(HOST_BY_CPU.toLowerCase());
    SAFE_SEARCH_EXPR.add(DATACENTER_BY_NAME.toLowerCase());
    SAFE_SEARCH_EXPR.add(VM_BY_STATUS.toLowerCase());
}
#method_after
private static void init() {
    final char SEPERATOR = ':';
    SAFE_SEARCH_EXPR.add(VDS_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDS_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VM_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VM_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(AUDIT_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(AUDIT_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(TEMPLATE_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(TEMPLATE_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_USER_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_USER_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_POOL_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_POOL_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_CLUSTER_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_CLUSTER_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_STORAGE_POOL_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_STORAGE_DOMAIN_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(DISK_IMAGE_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(DISK_IMAGE_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(GLUSTER_VOLUME_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(GLUSTER_VOLUME_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(ALERT.toLowerCase());
    SAFE_SEARCH_EXPR.add(ERROR.toLowerCase());
    SAFE_SEARCH_EXPR.add(HOST_BY_CPU.toLowerCase());
    SAFE_SEARCH_EXPR.add(DATACENTER_BY_NAME.toLowerCase());
    SAFE_SEARCH_EXPR.add(VM_BY_STATUS.toLowerCase());
}
#end_block

#method_before
public boolean isOnline() {
    return status == GlusterBrickStatus.ONLINE;
}
#method_after
public boolean isOnline() {
    return status == GlusterBrickStatus.UP;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((volumeId == null) ? 0 : serverId.hashCode());
    result = prime * result + ((serverId == null) ? 0 : serverId.hashCode());
    result = prime * result + ((serverName == null) ? 0 : serverName.hashCode());
    result = prime * result + ((brickDirectory == null) ? 0 : brickDirectory.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((volumeId == null) ? 0 : volumeId.hashCode());
    result = prime * result + ((serverId == null) ? 0 : serverId.hashCode());
    result = prime * result + ((serverName == null) ? 0 : serverName.hashCode());
    result = prime * result + ((brickDirectory == null) ? 0 : brickDirectory.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof GlusterBrickEntity)) {
        return false;
    }
    GlusterBrickEntity brick = (GlusterBrickEntity) obj;
    return (volumeId.equals(brick.getVolumeId()) && serverId.equals(brick.getServerId()) && brickDirectory.equals(brick.getBrickDirectory()) && status == brick.getStatus());
}
#method_after
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof GlusterBrickEntity)) {
        return false;
    }
    GlusterBrickEntity brick = (GlusterBrickEntity) obj;
    return (volumeId.equals(brick.getVolumeId()) && serverId.equals(brick.getServerId()) && serverName.equals(brick.getServerName()) && brickDirectory.equals(brick.getBrickDirectory()) && status == brick.getStatus());
}
#end_block

#method_before
public boolean isOnline() {
    return this.status == GlusterVolumeStatus.ONLINE;
}
#method_after
public boolean isOnline() {
    return this.status == GlusterVolumeStatus.UP;
}
#end_block

#method_before
@Override
protected void ReadGeneralData() {
    // General Vm
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node = content.SelectSingleNode("Name");
    if (node != null) {
        _vmTemplate.setname(node.InnerText);
        name = _vmTemplate.getname();
    }
    node = content.SelectSingleNode("TemplateId");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setId(new Guid(node.InnerText));
        }
    }
    node = content.SelectSingleNode("Description");
    if (node != null) {
        _vmTemplate.setdescription(node.InnerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        _vmTemplate.setdomain(node.InnerText);
    }
    node = content.SelectSingleNode("CreationDate");
    java.util.Date creationDate = new java.util.Date(0);
    RefObject<java.util.Date> tempRefObject = new RefObject<java.util.Date>(creationDate);
    boolean tempVar = node != null && OvfParser.UtcDateStringToLocaDate(node.InnerText, tempRefObject);
    creationDate = tempRefObject.argvalue;
    if (tempVar) {
        _vmTemplate.setcreation_date(creationDate);
    }
    node = content.SelectSingleNode("ExportDate");
    java.util.Date exportDate = new java.util.Date(0);
    tempRefObject = new RefObject<java.util.Date>(exportDate);
    tempVar = node != null && OvfParser.UtcDateStringToLocaDate(node.InnerText, tempRefObject);
    exportDate = tempRefObject.argvalue;
    if (tempVar) {
        _vmTemplate.set_export_date(exportDate);
    }
    node = content.SelectSingleNode("IsAutoSuspend");
    if (node != null) {
        _vmTemplate.setis_auto_suspend(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        _vmTemplate.settime_zone(node.InnerText);
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setvm_type(VmType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setdefault_boot_sequence(BootSequence.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setinitrd_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setkernel_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setkernel_params((node.InnerText));
        }
    }
    XmlNodeList list = content.SelectNodes("Section");
    for (XmlNode section : list) {
        String value = section.Attributes.get("xsi:type").getValue();
        if (StringHelper.EqOp(value, "ovf:OperatingSystemSection_Type")) {
            ReadOsSection(section);
        } else if (StringHelper.EqOp(value, "ovf:VirtualHardwareSection_Type")) {
            ReadHardwareSection(section);
        }
    }
    node = content.SelectSingleNode("default_display_type");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setdefault_display_type(DisplayType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
}
#method_after
@Override
protected void ReadGeneralData() {
    // General Vm
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node = content.SelectSingleNode("Name");
    if (node != null) {
        _vmTemplate.setname(node.InnerText);
        name = _vmTemplate.getname();
    }
    node = content.SelectSingleNode("TemplateId");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setId(new Guid(node.InnerText));
        }
    }
    node = content.SelectSingleNode("Description");
    if (node != null) {
        _vmTemplate.setdescription(node.InnerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        _vmTemplate.setdomain(node.InnerText);
    }
    node = content.SelectSingleNode("CreationDate");
    java.util.Date creationDate = new java.util.Date(0);
    RefObject<java.util.Date> tempRefObject = new RefObject<java.util.Date>(creationDate);
    boolean tempVar = node != null && OvfParser.UtcDateStringToLocaDate(node.InnerText, tempRefObject);
    creationDate = tempRefObject.argvalue;
    if (tempVar) {
        _vmTemplate.setcreation_date(creationDate);
    }
    node = content.SelectSingleNode("ExportDate");
    java.util.Date exportDate = new java.util.Date(0);
    tempRefObject = new RefObject<java.util.Date>(exportDate);
    tempVar = node != null && OvfParser.UtcDateStringToLocaDate(node.InnerText, tempRefObject);
    exportDate = tempRefObject.argvalue;
    if (tempVar) {
        _vmTemplate.setExportDate(exportDate);
    }
    node = content.SelectSingleNode("IsAutoSuspend");
    if (node != null) {
        _vmTemplate.setis_auto_suspend(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        _vmTemplate.settime_zone(node.InnerText);
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setvm_type(VmType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setdefault_boot_sequence(BootSequence.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setinitrd_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setkernel_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setkernel_params((node.InnerText));
        }
    }
    XmlNodeList list = content.SelectNodes("Section");
    for (XmlNode section : list) {
        String value = section.Attributes.get("xsi:type").getValue();
        if (StringHelper.EqOp(value, "ovf:OperatingSystemSection_Type")) {
            ReadOsSection(section);
        } else if (StringHelper.EqOp(value, "ovf:VirtualHardwareSection_Type")) {
            ReadHardwareSection(section);
        }
    }
    node = content.SelectSingleNode("default_display_type");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setdefault_display_type(DisplayType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
}
#end_block

#method_before
@Override
protected void ReadGeneralData() {
    // General Vm
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node = content.SelectSingleNode("Name");
    if (node != null) {
        _vm.getStaticData().setvm_name(node.InnerText);
        name = _vm.getStaticData().getvm_name();
    }
    node = content.SelectSingleNode("TemplateId");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.getStaticData().setvmt_guid(new Guid(node.InnerText));
        }
    }
    node = content.SelectSingleNode("TemplateName");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setvmt_name(node.InnerText);
        }
    }
    node = content.SelectSingleNode("Description");
    if (node != null) {
        _vm.getStaticData().setdescription(node.InnerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        _vm.getStaticData().setdomain(node.InnerText);
    }
    node = content.SelectSingleNode("CreationDate");
    java.util.Date creationDate = new java.util.Date(0);
    RefObject<java.util.Date> tempRefObject = new RefObject<java.util.Date>(creationDate);
    boolean tempVar = node != null && OvfParser.UtcDateStringToLocaDate(node.InnerText, tempRefObject);
    creationDate = tempRefObject.argvalue;
    if (tempVar) {
        _vm.getStaticData().setcreation_date(creationDate);
    }
    node = content.SelectSingleNode("ExportDate");
    java.util.Date exportDate = new java.util.Date(0);
    tempRefObject = new RefObject<java.util.Date>(exportDate);
    tempVar = node != null && OvfParser.UtcDateStringToLocaDate(node.InnerText, tempRefObject);
    exportDate = tempRefObject.argvalue;
    if (tempVar) {
        _vm.getStaticData().set_export_date(exportDate);
    }
    node = content.SelectSingleNode("IsInitilized");
    if (node != null) {
        _vm.getStaticData().setis_initialized(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("IsAutoSuspend");
    if (node != null) {
        _vm.getStaticData().setis_auto_suspend(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        _vm.getStaticData().settime_zone(node.InnerText);
    }
    node = content.SelectSingleNode("IsStateless");
    if (node != null) {
        _vm.getStaticData().setis_stateless(Boolean.parseBoolean(node.InnerText));
    }
    XmlNodeList list = content.SelectNodes("Section");
    for (XmlNode section : list) {
        String value = section.Attributes.get("xsi:type").getValue();
        if (StringHelper.EqOp(value, "ovf:OperatingSystemSection_Type")) {
            ReadOsSection(section);
        } else if (StringHelper.EqOp(value, "ovf:VirtualHardwareSection_Type")) {
            ReadHardwareSection(section);
        }
    }
    node = content.SelectSingleNode("Origin");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setorigin(OriginType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setinitrd_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setdefault_boot_sequence(BootSequence.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setkernel_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setkernel_params((node.InnerText));
        }
    }
    OvfLogEventHandler<VmStatic> handler = new VMStaticOvfLogHandler(_vm.getStaticData());
    // Gets a list of all the aliases of the fields that should be logged in
    // ovd For each one of these fields, the proper value will be read from
    // the ovf and field in vm static
    List<String> aliases = handler.getAliases();
    for (String alias : aliases) {
        String value = readEventLogValue(content, alias);
        if (!StringHelper.isNullOrEmpty(value)) {
            handler.addValueForAlias(alias, value);
        }
    }
    node = content.SelectSingleNode("app_list");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setapp_list(node.InnerText);
        }
    } else // if no app list in VM, get it from one of the leafs
    if (_images != null && _images.size() > 0) {
        int root = GetFirstImage(_images, _images.get(0));
        if (root != -1) {
            for (int i = 0; i < _images.size(); i++) {
                int x = GetNextImage(_images, _images.get(i));
                if (x == -1) {
                    _vm.setapp_list(_images.get(i).getappList());
                }
            }
        } else {
            _vm.setapp_list(_images.get(0).getappList());
        }
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setvm_type(VmType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("DefaultDisplayType");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setdefault_display_type(DisplayType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("MinAllocatedMem");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setMinAllocatedMem(Integer.parseInt(node.InnerText));
        }
    }
}
#method_after
@Override
protected void ReadGeneralData() {
    // General Vm
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node = content.SelectSingleNode("Name");
    if (node != null) {
        _vm.getStaticData().setvm_name(node.InnerText);
        name = _vm.getStaticData().getvm_name();
    }
    node = content.SelectSingleNode("TemplateId");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.getStaticData().setvmt_guid(new Guid(node.InnerText));
        }
    }
    node = content.SelectSingleNode("TemplateName");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setvmt_name(node.InnerText);
        }
    }
    node = content.SelectSingleNode("Description");
    if (node != null) {
        _vm.getStaticData().setdescription(node.InnerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        _vm.getStaticData().setdomain(node.InnerText);
    }
    node = content.SelectSingleNode("CreationDate");
    java.util.Date creationDate = new java.util.Date(0);
    RefObject<java.util.Date> tempRefObject = new RefObject<java.util.Date>(creationDate);
    boolean tempVar = node != null && OvfParser.UtcDateStringToLocaDate(node.InnerText, tempRefObject);
    creationDate = tempRefObject.argvalue;
    if (tempVar) {
        _vm.getStaticData().setcreation_date(creationDate);
    }
    node = content.SelectSingleNode("ExportDate");
    java.util.Date exportDate = new java.util.Date(0);
    tempRefObject = new RefObject<java.util.Date>(exportDate);
    tempVar = node != null && OvfParser.UtcDateStringToLocaDate(node.InnerText, tempRefObject);
    exportDate = tempRefObject.argvalue;
    if (tempVar) {
        _vm.getStaticData().setExportDate(exportDate);
    }
    node = content.SelectSingleNode("IsInitilized");
    if (node != null) {
        _vm.getStaticData().setis_initialized(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("IsAutoSuspend");
    if (node != null) {
        _vm.getStaticData().setis_auto_suspend(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        _vm.getStaticData().settime_zone(node.InnerText);
    }
    node = content.SelectSingleNode("IsStateless");
    if (node != null) {
        _vm.getStaticData().setis_stateless(Boolean.parseBoolean(node.InnerText));
    }
    XmlNodeList list = content.SelectNodes("Section");
    for (XmlNode section : list) {
        String value = section.Attributes.get("xsi:type").getValue();
        if (StringHelper.EqOp(value, "ovf:OperatingSystemSection_Type")) {
            ReadOsSection(section);
        } else if (StringHelper.EqOp(value, "ovf:VirtualHardwareSection_Type")) {
            ReadHardwareSection(section);
        }
    }
    node = content.SelectSingleNode("Origin");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setorigin(OriginType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setinitrd_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setdefault_boot_sequence(BootSequence.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setkernel_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setkernel_params((node.InnerText));
        }
    }
    OvfLogEventHandler<VmStatic> handler = new VMStaticOvfLogHandler(_vm.getStaticData());
    // Gets a list of all the aliases of the fields that should be logged in
    // ovd For each one of these fields, the proper value will be read from
    // the ovf and field in vm static
    List<String> aliases = handler.getAliases();
    for (String alias : aliases) {
        String value = readEventLogValue(content, alias);
        if (!StringHelper.isNullOrEmpty(value)) {
            handler.addValueForAlias(alias, value);
        }
    }
    node = content.SelectSingleNode("app_list");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setapp_list(node.InnerText);
        }
    } else // if no app list in VM, get it from one of the leafs
    if (_images != null && _images.size() > 0) {
        int root = GetFirstImage(_images, _images.get(0));
        if (root != -1) {
            for (int i = 0; i < _images.size(); i++) {
                int x = GetNextImage(_images, _images.get(i));
                if (x == -1) {
                    _vm.setapp_list(_images.get(i).getappList());
                }
            }
        } else {
            _vm.setapp_list(_images.get(0).getappList());
        }
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setvm_type(VmType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("DefaultDisplayType");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setdefault_display_type(DisplayType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("MinAllocatedMem");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setMinAllocatedMem(Integer.parseInt(node.InnerText));
        }
    }
}
#end_block

#method_before
@Test
public void testGetAllForQuotaId() {
    List<DiskImage> disks = dao.getAllForQuotaId(FixturesTool.QUOTA_GENERAL);
    assertEquals("Wrong number of disk images for quota ", 12, disks.size());
}
#method_after
@Test
public void testGetAllForQuotaId() {
    List<DiskImage> disks = dao.getAllForQuotaId(FixturesTool.QUOTA_GENERAL);
    assertEquals("Wrong number of disk images for quota ", TOTAL_DISK_IMAGES_FOR_QAUOTA, disks.size());
}
#end_block

#method_before
@Override
public Map<Boolean, List<VM>> getForImage(Guid id) {
    Map<Boolean, List<VM>> result = new HashMap<Boolean, List<VM>>(2);
    List<VMWithPlugInfo> vms = getCallsHandler().executeReadList("GetVmByImageId", VMWithPlugInfoRowMapper.instance, getCustomMapSqlParameterSource().addValue("image_guid", id));
    for (VMWithPlugInfo vm : vms) {
        MultiValueMapUtils.addToMap(vm.isPlugged(), vm.getVM(), result);
    }
    return result;
}
#method_after
@Override
public Map<Boolean, List<VM>> getForImage(Guid id) {
    Map<Boolean, List<VM>> result = new HashMap<Boolean, List<VM>>();
    List<VMWithPlugInfo> vms = getCallsHandler().executeReadList("GetVmsByImageId", VMWithPlugInfoRowMapper.instance, getCustomMapSqlParameterSource().addValue("image_guid", id));
    for (VMWithPlugInfo vm : vms) {
        MultiValueMapUtils.addToMap(vm.isPlugged(), vm.getVM(), result);
    }
    return result;
}
#end_block

#method_before
protected List<VmNetworkInterface> getVmInterfaces() {
    if (_vmInterfaces == null) {
        _vmInterfaces = ((DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForTemplate(getVmTemplate().getId())) != null) ? DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForTemplate(getVmTemplate().getId()) : new ArrayList<VmNetworkInterface>();
    }
    return _vmInterfaces;
}
#method_after
protected List<VmNetworkInterface> getVmInterfaces() {
    if (_vmInterfaces == null) {
        List<VmNetworkInterface> vmNetworkInterfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForTemplate(getVmTemplate().getId());
        _vmInterfaces = (vmNetworkInterfaces != null) ? vmNetworkInterfaces : new ArrayList<VmNetworkInterface>();
    }
    return _vmInterfaces;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    returnValue = buildAndCheckDestStorageDomains();
    if (returnValue) {
        buildStorageToDiskMap();
        returnValue = CanDoAddVmCommand();
    }
    String vmName = getParameters().getVm().getvm_name();
    if (vmName == null || vmName.isEmpty()) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    } else {
        // check that VM name is not too long
        boolean vmNameValidLength = isVmNameValidLength(getParameters().getVm());
        if (!vmNameValidLength) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        }
    }
    if (returnValue && Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVdsGroup().getcompatibility_version().toString())) {
        // check that we have no more then 8 interfaces (kvm limitation in version 2.x)
        if (!validateNumberOfNics(getVmInterfaces(), null)) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            returnValue = false;
        }
    }
    return returnValue && checkCpuSockets();
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    returnValue = buildAndCheckDestStorageDomains();
    if (returnValue) {
        storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getVmTemplate().getDiskMap().values(), imageToDestinationDomainMap);
        returnValue = CanDoAddVmCommand();
    }
    String vmName = getParameters().getVm().getvm_name();
    if (vmName == null || vmName.isEmpty()) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    } else {
        // check that VM name is not too long
        boolean vmNameValidLength = isVmNameValidLength(getParameters().getVm());
        if (!vmNameValidLength) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        }
    }
    if (returnValue && Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVdsGroup().getcompatibility_version().toString())) {
        // check that we have no more then 8 interfaces (kvm limitation in version 2.x)
        if (!validateNumberOfNics(getVmInterfaces(), null)) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            returnValue = false;
        }
    }
    return returnValue && checkCpuSockets();
}
#end_block

#method_before
protected boolean buildAndCheckDestStorageDomains() {
    boolean returnValue = true;
    ensureDomainMap();
    Set<Guid> destStorageDomains = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destStorageDomain : destStorageDomains) {
        storage_domains storage = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(destStorageDomain, getStoragePoolId());
        StorageDomainValidator validator = new StorageDomainValidator(storage);
        if (!validator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages()) || !validator.domainIsValidDestination(getReturnValue().getCanDoActionMessages())) {
            returnValue = false;
            break;
        }
        destStorages.put(storage.getId(), storage);
    }
    return returnValue;
}
#method_after
protected boolean buildAndCheckDestStorageDomains() {
    boolean retValue = true;
    if (imageToDestinationDomainMap.isEmpty()) {
        retValue = fillDestMap();
    } else {
        retValue = validateProvidedDestinations();
    }
    if (retValue && getVmTemplate().getDiskMap().values().size() != imageToDestinationDomainMap.size()) {
        log.errorFormat("Can not found any default active domain for one of the disks of template with id : {0}", getVmTemplate().getId());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
        retValue = false;
    }
    return retValue;
}
#end_block

#method_before
protected boolean canAddVm(ArrayList<String> reasons, int vmsCount, String name, Guid storagePoolId, int vmPriority) {
    boolean returnValue;
    // Checking if a desktop with same name already exists
    boolean exists = (Boolean) Backend.getInstance().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(name)).getReturnValue();
    if (exists) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST.toString());
        }
        return false;
    }
    boolean checkTemplateLock = getParameters().getParentCommand() == VdcActionType.AddVmPoolWithVms ? false : true;
    returnValue = VmHandler.VerifyAddVm(reasons, vmsCount, getVmTemplate(), storagePoolId, null, false, checkTemplateLock, vmPriority);
    if (!getParameters().getDontCheckTemplateImages()) {
        for (storage_domains storage : destStorages.values()) {
            if (!VmTemplateCommand.isVmTemplateImagesReady(getVmTemplate(), storage.getId(), reasons, false, checkTemplateLock, true, true, storageToDisksMap.get(storage.getId()))) {
                return false;
            }
        }
    }
    return returnValue;
}
#method_after
protected boolean canAddVm(ArrayList<String> reasons, int vmsCount, String name, Guid storagePoolId, int vmPriority) {
    boolean returnValue;
    // Checking if a desktop with same name already exists
    boolean exists = (Boolean) Backend.getInstance().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(name)).getReturnValue();
    if (exists) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST.toString());
        }
        return false;
    }
    boolean checkTemplateLock = getParameters().getParentCommand() == VdcActionType.AddVmPoolWithVms ? false : true;
    returnValue = VmHandler.VerifyAddVm(reasons, vmsCount, getVmTemplate(), storagePoolId, vmPriority);
    if (returnValue && !getParameters().getDontCheckTemplateImages()) {
        for (storage_domains storage : destStorages.values()) {
            if (!VmTemplateCommand.isVmTemplateImagesReady(getVmTemplate(), storage.getId(), reasons, false, checkTemplateLock, true, true, storageToDisksMap.get(storage.getId()))) {
                return false;
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
private boolean checkVmIsDown() {
    return Config.<Boolean>GetValue(ConfigValues.LiveSnapshotEnabled, getStoragePool().getcompatibility_version().getValue());
}
#method_after
private boolean checkVmIsDown() {
    return !Config.<Boolean>GetValue(ConfigValues.LiveSnapshotEnabled, getStoragePool().getcompatibility_version().getValue());
}
#end_block

#method_before
@Override
protected boolean validateQuota() {
    // Set default quota id if storage pool enforcement is disabled.
    getParameters().setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getVmTemplate().getQuotaId(), getStoragePool()));
    for (DiskImage diskImage : mImages) {
        diskImage.setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getVmTemplate().getQuotaId(), getStoragePool()));
    }
    if (!isInternalExecution()) {
        return QuotaManager.validateMultiStorageQuota(getStoragePool().getQuotaEnforcementType(), getQuotaConsumeMap(), getCommandId(), getReturnValue().getCanDoActionMessages());
    }
    return true;
}
#method_after
@Override
protected boolean validateQuota() {
    // Set default quota id if storage pool enforcement is disabled.
    getParameters().setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getQuotaId(), getStoragePool()));
    for (DiskImage diskImage : mImages) {
        diskImage.setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getQuotaId(), getStoragePool()));
    }
    if (!isInternalExecution()) {
        return QuotaManager.validateMultiStorageQuota(getStoragePool().getQuotaEnforcementType(), getQuotaConsumeMap(), getCommandId(), getReturnValue().getCanDoActionMessages());
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null || !getVm().getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    for (DiskImage diskImage : getVm().getDiskList()) {
        mImages.add(diskImage);
    }
    if (mImages.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getos(), getParameters().getMasterVm().getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!IsVmPriorityValueLegal(getParameters().getMasterVm().getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Guid srcStorageDomainId = mImages.get(0).getstorage_ids().get(0);
    // or populate storage domain id from the vm domain (of the first disk)
    if (getParameters().getDestinationStorageDomainId() != null) {
        setStorageDomainId(getParameters().getDestinationStorageDomainId());
    } else {
        setStorageDomainId(srcStorageDomainId);
    }
    if (!validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (!ImagesHandler.PerformImagesChecks(getParameters().getMasterVm().getId(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), srcStorageDomainId, true, true, true, true, true, false, true)) {
        return false;
    }
    VM vm = DbFacade.getInstance().getVmDAO().getById(getParameters().getMasterVm().getId());
    if (vm.getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_DUPLICATE_NAME);
        return false;
    }
    if (getStorageDomainId() != null) {
        storage_domains storage = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(getStorageDomainId().getValue(), getVm().getstorage_pool_id());
        // if source and destination domains are different we need to check destination domain also
        if (!srcStorageDomainId.equals(getStorageDomainId().getValue())) {
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDAO().get(getStorageDomainId().getValue()) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getstatus() == null || storage.getstatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
                return false;
            }
        }
        if (storage.getstorage_domain_type() == StorageDomainType.ImportExport || storage.getstorage_domain_type() == StorageDomainType.ISO) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            return false;
        }
        // update vm snapshots for storage free space check
        for (DiskImage diskImage : getVm().getDiskMap().values()) {
            diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getId(), diskImage.getit_guid()));
        }
        if (!StorageDomainSpaceChecker.hasSpaceForRequest(storage, (int) getVm().getActualDiskWithSnapshotsSize())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
            return false;
        }
    }
    if (!AddVmCommand.CheckCpuSockets(getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null || !getVm().getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    for (DiskImage diskImage : getVm().getDiskList()) {
        mImages.add(diskImage);
    }
    if (mImages.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getos(), getParameters().getMasterVm().getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!IsVmPriorityValueLegal(getParameters().getMasterVm().getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (getVm().getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_DUPLICATE_NAME);
        return false;
    }
    Map<Guid, List<DiskImage>> sourceImageDomainsImageMap = new HashMap<Guid, List<DiskImage>>();
    if (imageToDestinationDomainMap == null) {
        imageToDestinationDomainMap = new HashMap<Guid, Guid>();
    }
    for (DiskImage image : mImages) {
        List<DiskImage> diskImageList = sourceImageDomainsImageMap.get(image.getstorage_ids().get(0));
        if (diskImageList == null) {
            diskImageList = new ArrayList<DiskImage>();
            sourceImageDomainsImageMap.put(image.getstorage_ids().get(0), diskImageList);
        }
        diskImageList.add(image);
        if (!imageToDestinationDomainMap.containsKey(image.getId())) {
            Guid destImageId = getParameters().getDestinationStorageDomainId() != null ? getParameters().getDestinationStorageDomainId() : image.getstorage_ids().get(0);
            imageToDestinationDomainMap.put(image.getId(), destImageId);
        }
    }
    for (Guid srcStorageDomainId : sourceImageDomainsImageMap.keySet()) {
        boolean checkIsValid = true;
        if (!ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), srcStorageDomainId, false, true, true, true, true, false, true, checkIsValid, sourceImageDomainsImageMap.get(srcStorageDomainId))) {
            return false;
        }
        checkIsValid = false;
    }
    Map<Guid, storage_domains> storageDomains = new HashMap<Guid, storage_domains>();
    Set<Guid> destImageDomains = new HashSet<Guid>(imageToDestinationDomainMap.values());
    destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
    for (Guid destImageDomain : destImageDomains) {
        storage_domains storage = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(destImageDomain, getVm().getstorage_pool_id());
        if (storage == null) {
            // domain is not in the same storage pool as the vm
            if (DbFacade.getInstance().getStorageDomainStaticDAO().get(destImageDomain) == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
            } else {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
            }
            return false;
        }
        if (storage.getstatus() == null || storage.getstatus() != StorageDomainStatus.Active) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
            return false;
        }
        if (storage.getstorage_domain_type() == StorageDomainType.ImportExport || storage.getstorage_domain_type() == StorageDomainType.ISO) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            return false;
        }
        storageDomains.put(destImageDomain, storage);
    }
    // update vm snapshots for storage free space check
    for (DiskImage diskImage : getVm().getDiskMap().values()) {
        diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getId(), diskImage.getit_guid()));
    }
    Map<storage_domains, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(getVmTemplate().getDiskImageMap().values(), storageDomains, imageToDestinationDomainMap);
    for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
        if (!StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
            return false;
        }
    }
    return AddVmCommand.CheckCpuSockets(getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected void AddVmInterfaces() {
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getMasterVm().getId());
    for (VmNetworkInterface iface : interfaces) {
        VmNetworkInterface iDynamic = new VmNetworkInterface();
        // \\interface_statistics iStat = new interface_statistics();
        iDynamic.setId(Guid.NewGuid());
        iDynamic.setVmTemplateId(getVmTemplateId());
        // TODO why is a VM interface getting VDS details?
        // iDynamic.setAddress(iface.getInterfaceDynamic().getAddress());
        // iDynamic.setBondName(iface.getInterfaceDynamic().getBondName());
        // iDynamic.setBondType(iface.getInterfaceDynamic().getBondType());
        // iDynamic.setGateway(iface.getInterfaceDynamic().getGateway());
        iDynamic.setName(iface.getName());
        iDynamic.setNetworkName(iface.getNetworkName());
        iDynamic.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        // iDynamic.setSubnet(iface.getInterfaceDynamic().getSubnet());
        iDynamic.setType(iface.getType());
        DbFacade.getInstance().getVmNetworkInterfaceDAO().save(iDynamic);
    // \\DbFacade.Instance.addInterfaceStatistics(iStat);
    }
}
#method_after
protected void AddVmInterfaces() {
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getMasterVm().getId());
    for (VmNetworkInterface iface : interfaces) {
        VmNetworkInterface iDynamic = new VmNetworkInterface();
        iDynamic.setId(Guid.NewGuid());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        iDynamic.setNetworkName(iface.getNetworkName());
        iDynamic.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iDynamic.setType(iface.getType());
        DbFacade.getInstance().getVmNetworkInterfaceDAO().save(iDynamic);
    }
}
#end_block

#method_before
protected void AddVmTemplateImages() {
    Guid srcStorageDomain = mImages.get(0).getstorage_ids().get(0);
    Guid vmSnapshotId = Guid.NewGuid();
    for (DiskImage diskImage : mImages) {
        CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getId(), getVmTemplateId(), getVmTemplateName(), getVmId());
        if (!Guid.Empty.equals(diskImage.getstorage_ids().get(0))) {
            createParams.setStorageDomainId(diskImage.getstorage_ids().get(0));
        } else {
            createParams.setStorageDomainId(srcStorageDomain);
        }
        createParams.setVmSnapshotId(vmSnapshotId);
        createParams.setEntityId(getParameters().getEntityId());
        createParams.setDestinationStorageDomainId(getStorageDomainId().getValue());
        createParams.setParentParemeters(getParameters());
        getParameters().getImagesParameters().add(createParams);
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, createParams, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        getReturnValue().getTaskIdList().addAll(retValue.getInternalTaskIdList());
    }
}
#method_after
protected void AddVmTemplateImages() {
    Guid vmSnapshotId = Guid.NewGuid();
    for (DiskImage diskImage : mImages) {
        CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getId(), getVmTemplateId(), getVmTemplateName(), getVmId());
        createParams.setStorageDomainId(diskImage.getstorage_ids().get(0));
        createParams.setVmSnapshotId(vmSnapshotId);
        createParams.setEntityId(getParameters().getEntityId());
        createParams.setDestinationStorageDomainId(imageToDestinationDomainMap.get(diskImage.getId()));
        createParams.setParentParemeters(getParameters());
        getParameters().getImagesParameters().add(createParams);
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, createParams, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        if (!retValue.getSucceeded()) {
            throw new VdcBLLException(retValue.getFault().getError(), retValue.getFault().getMessage());
        }
        getReturnValue().getTaskIdList().addAll(retValue.getInternalTaskIdList());
    }
}
#end_block

#method_before
@Override
protected void EndWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    VmTemplate template = getVmTemplate();
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        RemoveTemplateInSpm(getVmTemplate().getstorage_pool_id().getValue(), getVmTemplateId());
        DbFacade.getInstance().getVmTemplateDAO().remove(getVmTemplateId());
        RemoveNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.UnLockVm(getVmId());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void EndWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        RemoveTemplateInSpm(getVmTemplate().getstorage_pool_id().getValue(), getVmTemplateId());
        DbFacade.getInstance().getVmTemplateDAO().remove(getVmTemplateId());
        RemoveNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.UnLockVm(getVmId());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> list = new ArrayList<PermissionSubject>();
    Guid storagePoolId = getVdsGroup() == null || getVdsGroup().getstorage_pool_id() == null ? null : getVdsGroup().getstorage_pool_id().getValue();
    list.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
    list = QuotaHelper.getInstance().addQuotaPermissionSubject(list, getStoragePool(), getVm().getStaticData().getQuotaId());
    list = setPermissionListForDiskImage(list);
    return list;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permissionCheckSubject == null) {
        permissionCheckSubject = new ArrayList<PermissionSubject>();
        Guid storagePoolId = getVdsGroup() == null || getVdsGroup().getstorage_pool_id() == null ? null : getVdsGroup().getstorage_pool_id().getValue();
        permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
        permissionCheckSubject = QuotaHelper.getInstance().addQuotaPermissionSubject(permissionCheckSubject, getStoragePool(), getQuotaId());
        permissionCheckSubject = setPermissionListForDiskImage(permissionCheckSubject);
    }
    return permissionCheckSubject;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Guid tryingImage = Guid.Empty;
    DiskImage activeDisk = findImageForDrive(SnapshotType.ACTIVE);
    DiskImage inactiveDisk = findImageForDrive(SnapshotType.PREVIEW);
    ;
    if (getDiskImageDao().getAllForVm(getParameters().getId(), getUserID(), getParameters().isFiltered()).isEmpty() || activeDisk == null || imageBeforePreviewIsMissing(activeDisk, inactiveDisk)) {
        log.warnFormat("Vm {0} images data incorrect", getParameters().getId());
        getQueryReturnValue().setReturnValue(new ArrayList<DiskImage>());
        return;
    }
    if (inactiveDisk != null) {
        tryingImage = activeDisk.getParentId();
    }
    Guid topmostImageGuid = inactiveDisk == null ? activeDisk.getId() : inactiveDisk.getId();
    // Note that no additional permission filtering is needed -
    // if a user could read the disk of a VM, all its snapshots are OK too
    getQueryReturnValue().setReturnValue(ImagesHandler.getAllImageSnapshots(topmostImageGuid, activeDisk.getit_guid()));
    getQueryReturnValue().setTryingImage(tryingImage);
}
#method_after
@Override
protected void executeQueryCommand() {
    Guid tryingImage = Guid.Empty;
    DiskImage activeDisk = findImageForDrive(SnapshotType.ACTIVE);
    DiskImage inactiveDisk = findImageForDrive(SnapshotType.PREVIEW);
    if (getDiskImageDao().getAllForVm(getParameters().getId(), getUserID(), getParameters().isFiltered()).isEmpty() || activeDisk == null || imageBeforePreviewIsMissing(activeDisk, inactiveDisk)) {
        log.warnFormat("Vm {0} images data incorrect", getParameters().getId());
        getQueryReturnValue().setReturnValue(new ArrayList<DiskImage>());
        return;
    }
    if (inactiveDisk != null) {
        tryingImage = activeDisk.getParentId();
    }
    Guid topmostImageGuid = inactiveDisk == null ? activeDisk.getId() : inactiveDisk.getId();
    // Note that no additional permission filtering is needed -
    // if a user could read the disk of a VM, all its snapshots are OK too
    getQueryReturnValue().setReturnValue(ImagesHandler.getAllImageSnapshots(topmostImageGuid, activeDisk.getit_guid()));
    getQueryReturnValue().setTryingImage(tryingImage);
}
#end_block

#method_before
// Sysprep section is displayed only when VM's OS-type is 'Windows'
// and [Reinitialize-sysprep == true || IsVmFirstRun == true (IsVmFirstRun == !VM.is_initialized) and no attached
private void UpdateIsSysprepEnabled() {
    boolean isFloppyAttached = (Boolean) getAttachFloppy().getEntity();
    boolean isVmFirstRun = (Boolean) getIsVmFirstRun().getEntity();
    getIsSysprepEnabled().setEntity(getIsWindowsOS() && (getReinitialize()));
}
#method_after
// Sysprep section is displayed only when VM's OS-type is 'Windows'
// and [Reinitialize-sysprep == true || IsVmFirstRun == true (IsVmFirstRun == !VM.is_initialized) and no attached
private void UpdateIsSysprepEnabled() {
    boolean isFloppyAttached = (Boolean) getAttachFloppy().getEntity();
    boolean isVmFirstRun = (Boolean) getIsVmFirstRun().getEntity();
    getIsSysprepEnabled().setEntity(getIsWindowsOS() && getReinitialize());
}
#end_block

#method_before
@Override
protected void buildVmDrives() {
    List<Map<String, String>> drives = new ArrayList<Map<String, String>>(vm.getDiskMap().size());
    int ideCount = 0, pciCount = 0;
    List<DiskImage> diskImages = getSortedDiskImages();
    for (DiskImage disk : diskImages) {
        // get vm device for this disk from DB
        VmDevice vmDevice = DbFacade.getInstance().getVmDeviceDAO().get(new VmDeviceId(disk.getDisk().getId(), disk.getvm_guid()));
        if (vmDevice.getIsPlugged()) {
            Map<String, String> drive = new HashMap<String, String>();
            drive.put("domainID", disk.getstorage_ids().get(0).toString());
            drive.put("poolID", disk.getstorage_pool_id().toString());
            drive.put("volumeID", disk.getId().toString());
            drive.put("imageID", disk.getimage_group_id().toString());
            drive.put("format", disk.getvolume_format().toString().toLowerCase());
            drive.put("propagateErrors", disk.getpropagate_errors().toString().toLowerCase());
            switch(disk.getdisk_interface()) {
                case IDE:
                    try {
                        drive.put("if", "ide");
                        drive.put("index", String.valueOf(ideIndexSlots[ideCount]));
                        ideCount++;
                    } catch (IndexOutOfBoundsException e) {
                        log.errorFormat("buildVmDrives throws IndexOutOfBoundsException for index {0}, IDE slots are limited to 4.", ideCount);
                        throw e;
                    }
                    break;
                case VirtIO:
                    drive.put("if", "virtio");
                    drive.put("index", String.valueOf(pciCount));
                    drive.put("boot", String.valueOf(disk.getboot()).toLowerCase());
                    pciCount++;
                    break;
                default:
                    // ISCI not supported
                    logUnsupportedInterfaceType();
                    break;
            }
            drives.add(drive);
        }
    }
    @SuppressWarnings("unchecked")
    Map<String, String>[] drivesArray = new Map[drives.size()];
    createInfo.add("drives", drives.toArray(drivesArray));
}
#method_after
@Override
protected void buildVmDrives() {
    List<Map<String, String>> drives = new ArrayList<Map<String, String>>(vm.getDiskMap().size());
    int ideCount = 0, pciCount = 0;
    List<DiskImage> diskImages = getSortedDiskImages();
    List<VmDevice> vmDiskDevices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.DISK.getName(), VmDeviceType.DISK.getName());
    for (DiskImage disk : diskImages) {
        // Get the VM device for this disk
        VmDevice vmDevice = findVmDeviceForDisk(disk.getDisk().getId(), vmDiskDevices);
        if (vmDevice == null || vmDevice.getIsPlugged()) {
            Map<String, String> drive = new HashMap<String, String>();
            drive.put("domainID", disk.getstorage_ids().get(0).toString());
            drive.put("poolID", disk.getstorage_pool_id().toString());
            drive.put("volumeID", disk.getId().toString());
            drive.put("imageID", disk.getimage_group_id().toString());
            drive.put("format", disk.getvolume_format().toString().toLowerCase());
            drive.put("propagateErrors", disk.getpropagate_errors().toString().toLowerCase());
            switch(disk.getdisk_interface()) {
                case IDE:
                    try {
                        drive.put("if", "ide");
                        drive.put("index", String.valueOf(ideIndexSlots[ideCount]));
                        ideCount++;
                    } catch (IndexOutOfBoundsException e) {
                        log.errorFormat("buildVmDrives throws IndexOutOfBoundsException for index {0}, IDE slots are limited to 4.", ideCount);
                        throw e;
                    }
                    break;
                case VirtIO:
                    drive.put("if", "virtio");
                    drive.put("index", String.valueOf(pciCount));
                    drive.put("boot", String.valueOf(disk.getboot()).toLowerCase());
                    pciCount++;
                    break;
                default:
                    // ISCI not supported
                    logUnsupportedInterfaceType();
                    break;
            }
            drives.add(drive);
        }
    }
    @SuppressWarnings("unchecked")
    Map<String, String>[] drivesArray = new Map[drives.size()];
    createInfo.add("drives", drives.toArray(drivesArray));
}
#end_block

#method_before
public Collection<DetailedLink> getLinks() throws ClassNotFoundException, IOException {
    // SortedSet<Link> results = new TreeSet<Link>();
    List<DetailedLink> results = new ArrayList<DetailedLink>();
    List<Class<?>> classes = ReflectionHelper.getClasses(RESOURCES_PACKAGE);
    for (String path : apiResource.getRels()) {
        Class<?> resource = findResource(path, classes);
        results.addAll(describe(resource, entryPoint + path, new HashMap<String, Type>()));
    }
    return results;
}
#method_after
public Collection<DetailedLink> getLinks() throws ClassNotFoundException, IOException {
    // SortedSet<Link> results = new TreeSet<Link>();
    List<DetailedLink> results = new ArrayList<DetailedLink>();
    List<Class<?>> classes = ReflectionHelper.getClasses(RESOURCES_PACKAGE);
    for (String path : apiResource.getRels()) {
        Class<?> resource = findResource(path, classes);
        results.addAll(describe(resource, entryPoint + "/" + path, new HashMap<String, Type>()));
    }
    return results;
}
#end_block

#method_before
private void addBodyParams(ParametersSet ps, Set<Entry<Object, Object>> entrySet, boolean mandatory) {
    for (Entry<Object, Object> paramData : entrySet) {
        Parameter param = createBodyParam(paramData, mandatory);
        ps.getParameters().add(param);
    }
}
#method_after
private void addBodyParams(ParametersSet ps, Set<Entry<Object, Object>> entrySet, boolean required) {
    for (Entry<Object, Object> paramData : entrySet) {
        Parameter param = createBodyParam(paramData, required);
        ps.getParameters().add(param);
    }
}
#end_block

#method_before
private Parameter createBodyParam(Entry<Object, Object> mandatoryKeyValuePair, boolean mandatory) {
    Parameter param = new Parameter();
    param.setMandatory(mandatory);
    String paramName = mandatoryKeyValuePair.getKey().toString();
    if (paramName.endsWith(LIST_PARAMETER_YAML)) {
        param.setName(paramName.substring(0, paramName.length() - (LIST_PARAMETER_YAML.length())));
        param.setType(LIST_PARAMETER_RSDL);
        @SuppressWarnings("unchecked")
        Map<Object, Object> listParams = (Map<Object, Object>) mandatoryKeyValuePair.getValue();
        param.setParametersSet(new ParametersSet());
        for (Entry<Object, Object> listParamData : listParams.entrySet()) {
            Parameter listParam = createBodyParam(listParamData, mandatory);
            param.getParametersSet().getParameters().add(listParam);
        }
    } else {
        param.setName(paramName);
        param.setType(mandatoryKeyValuePair.getValue().toString());
    }
    return param;
}
#method_after
private Parameter createBodyParam(Entry<Object, Object> mandatoryKeyValuePair, boolean required) {
    Parameter param = new Parameter();
    param.setRequired(required);
    String paramName = mandatoryKeyValuePair.getKey().toString();
    if (paramName.endsWith(COLLECTION_PARAMETER_YAML)) {
        param.setName(paramName.substring(0, paramName.length() - (COLLECTION_PARAMETER_YAML.length())));
        param.setType(COLLECTION_PARAMETER_RSDL);
        @SuppressWarnings("unchecked")
        Map<Object, Object> listParams = (Map<Object, Object>) mandatoryKeyValuePair.getValue();
        param.setParametersSet(new ParametersSet());
        for (Entry<Object, Object> listParamData : listParams.entrySet()) {
            Parameter listParam = createBodyParam(listParamData, required);
            param.getParametersSet().getParameters().add(listParam);
        }
    } else {
        param.setName(paramName);
        param.setType(mandatoryKeyValuePair.getValue().toString());
    }
    return param;
}
#end_block

#method_before
private void addUrlParams(DetailedLink link, Action action) {
    if (action.getRequest().getUrlparams() != null && !action.getRequest().getUrlparams().isEmpty()) {
        link.getRequest().setUrl(new Url());
        ParametersSet ps = new ParametersSet();
        for (Object key : action.getRequest().getUrlparams().keySet()) {
            Parameter param = new Parameter();
            param.setName(key.toString());
            Object value = action.getRequest().getUrlparams().get(key);
            if (value != null) {
                param.setValue(value.toString());
            }
            ps.getParameters().add(param);
        }
        link.getRequest().getUrl().getParametersSets().add(ps);
    }
}
#method_after
private void addUrlParams(DetailedLink link, Action action) {
    if (action.getRequest().getUrlparams() != null && !action.getRequest().getUrlparams().isEmpty()) {
        link.getRequest().setUrl(new Url());
        ParametersSet ps = new ParametersSet();
        for (Object key : action.getRequest().getUrlparams().keySet()) {
            Parameter param = new Parameter();
            param.setName(key.toString());
            Object value = action.getRequest().getUrlparams().get(key);
            if (value != null) {
                UrlParamData urlParamData = (UrlParamData) value;
                param.setType(urlParamData.getType());
                param.setContext(urlParamData.getContext());
                param.setValue(urlParamData.getValue());
                param.setRequired(urlParamData.getRequired() == null ? false : urlParamData.getRequired());
            }
            ps.getParameters().add(param);
        }
        link.getRequest().getUrl().getParametersSets().add(ps);
    }
}
#end_block

#method_before
public static void addDiskImage(DiskImage image, boolean active, image_storage_domain_map imageStorageDomainMap) {
    // Adding new disk to the image table in the DB
    try {
        addImage(image, active, imageStorageDomainMap);
        addDiskToVmIfNotExists(image.getDisk(), image.getvm_guid());
    } catch (RuntimeException ex) {
        log.error("Failed adding new disk image and related entities to db", ex);
        throw new VdcBLLException(VdcBllErrors.DB, ex);
    }
}
#method_after
public static void addDiskImage(DiskImage image, boolean active, image_storage_domain_map imageStorageDomainMap) {
    try {
        addImage(image, active, imageStorageDomainMap);
        addDiskToVmIfNotExists(image.getDisk(), image.getvm_guid());
    } catch (RuntimeException ex) {
        log.error("Failed adding new disk image and related entities to db", ex);
        throw new VdcBLLException(VdcBllErrors.DB, ex);
    }
}
#end_block

#method_before
public static void addDiskImage(DiskImage image) {
    addDiskImage(image, image.getactive(), new image_storage_domain_map(image.getId(), image.getstorage_ids().get(0)));
}
#method_after
public static void addDiskImage(DiskImage image) {
    addDiskImage(image, image.getactive(), new image_storage_domain_map(image.getId(), getStorageDomainId(image)));
}
#end_block

#method_before
public static Map<String, String> string2Map(String str) {
    // remove map markers
    str = str.replaceAll("[{}]", "");
    Map<String, String> map = new HashMap<String, String>();
    if (str.length() > 0) {
        String[] keyValPairs = str.split(",");
        for (String pair : keyValPairs) {
            String[] keyval = pair.split("=");
            if (keyval.length == 2)
                map.put(keyval[0], keyval[1]);
            else if (keyval.length == 1)
                map.put(keyval[0], "");
        }
    }
    return map;
}
#method_after
public static Map<String, String> string2Map(String str) {
    Map<String, String> map = new HashMap<String, String>();
    if (str != null) {
        // remove map markers
        str = str.replaceAll("[{}]", "");
        if (str.length() > 0) {
            String[] keyValPairs = str.split(DELIMITER);
            for (String pair : keyValPairs) {
                String[] keyval = pair.split(SEP);
                if (keyval.length == 2)
                    map.put(keyval[0], keyval[1]);
                else if (keyval.length == 1)
                    map.put(keyval[0], "");
            }
        }
    }
    return map;
}
#end_block

#method_before
public Guid getStorageDomainIdForPoolByType(Guid pool, StorageDomainType type) {
    Guid returnValue = Guid.Empty;
    List<storage_domains> domains = getAllForStoragePool(pool);
    for (storage_domains domain : domains) {
        if (domain.getstorage_domain_type() == StorageDomainType.Master) {
            returnValue = domain.getId();
            break;
        }
    }
    return returnValue;
}
#method_after
public Guid getStorageDomainIdForPoolByType(Guid pool, StorageDomainType type) {
    Guid returnValue = Guid.Empty;
    List<storage_domains> domains = getAllForStoragePool(pool);
    for (storage_domains domain : domains) {
        if (domain.getstorage_domain_type() == type) {
            returnValue = domain.getId();
            break;
        }
    }
    return returnValue;
}
#end_block

#method_before
public void add(String key, XmlRpcStruct[] devices) {
    int i = 0;
    Map[] map = new Map[devices.length];
    for (XmlRpcStruct device : devices) {
        map[i++] = device.getInnerMap();
    }
    this.add(key, map);
}
#method_after
public void add(String key, XmlRpcStruct[] devices) {
    int i = 0;
    // TODO work with typed collection
    Map[] map = new Map[devices.length];
    for (XmlRpcStruct device : devices) {
        map[i++] = device.getInnerMap();
    }
    this.add(key, map);
}
#end_block

#method_before
@Override
protected void ExecuteVdsBrokerCommand() {
    List<String> vmIds = ((FullListVDSCommandParameters) getParameters()).getVmIds();
    String[] vmIdsArray = vmIds.toArray(new String[vmIds.size()]);
    fullVmListReturn = getBroker().list("true", vmIdsArray);
    ProceedProxyReturnValue();
    XmlRpcStruct[] struct = fullVmListReturn.mVmList;
    setReturnValue(struct);
}
#method_after
@Override
protected void ExecuteVdsBrokerCommand() {
    List<String> vmIds = getParameters().getVmIds();
    String[] vmIdsArray = vmIds.toArray(new String[vmIds.size()]);
    fullVmListReturn = getBroker().list(Boolean.TRUE.toString(), vmIdsArray);
    ProceedProxyReturnValue();
    XmlRpcStruct[] struct = fullVmListReturn.mVmList;
    setReturnValue(struct);
}
#end_block

#method_before
public String getSpecParams() {
    this.specParams = VmDeviceCommonUtils.appendDeviceIdToSpecParams(this.getId().getDeviceId(), this.specParams);
    return this.specParams;
}
#method_after
public String getSpecParams() {
    specParams = VmDeviceCommonUtils.appendDeviceIdToSpecParams(this.getId().getDeviceId(), specParams);
    return this.specParams;
}
#end_block

#method_before
public Boolean getIsPlugged() {
    return isPlugged;
}
#method_after
public Boolean getIsPlugged() {
    return isPlugged == null ? Boolean.FALSE : isPlugged;
}
#end_block

#method_before
@Override
protected void buildVmCD() {
    // get vm device for this CD from DB
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM));
    for (VmDevice vmDevice : vmDevices) {
        String file = StringUtils.string2Map(vmDevice.getSpecParams()).get("path");
        if (!(file == null) && !(file.isEmpty())) {
            XmlRpcStruct struct = new XmlRpcStruct();
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            // IDE slot 2 is reserved by VDSM to CDROM
            struct.add(VdsProperties.Index, "2");
            addAddress(vmDevice, struct);
            struct.add(VdsProperties.Iface, "ide");
            struct.add(VdsProperties.PoolId, vm.getstorage_pool_id().toString());
            struct.add(VdsProperties.DomainId, DbFacade.getInstance().getStorageDomainDAO().getIsoStorageDomainIdForPool(vm.getstorage_pool_id()).toString());
            struct.add(VdsProperties.ImageId, VmDeviceCommonUtils.CDROM_IMAGE_ID);
            struct.add(VdsProperties.VolumeId, file.substring(file.lastIndexOf('/') + 1));
            struct.add(VdsProperties.Path, file);
            // CDROM is always read only
            struct.add(VdsProperties.ReadOnly, "true");
            addBootOrder(vmDevice, struct);
            devices.add(struct);
            // currently only one is supported, may change in future releases
            break;
        }
    }
}
#method_after
@Override
protected void buildVmCD() {
    // get vm device for this CD from DB
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM));
    for (VmDevice vmDevice : vmDevices) {
        String file = StringUtils.string2Map(vmDevice.getSpecParams()).get("path");
        if (!(file == null) && !(file.isEmpty())) {
            XmlRpcStruct struct = new XmlRpcStruct();
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            // IDE slot 2 is reserved by VDSM to CDROM
            struct.add(VdsProperties.Index, "2");
            addAddress(vmDevice, struct);
            struct.add(VdsProperties.Iface, "ide");
            struct.add(VdsProperties.PoolId, vm.getstorage_pool_id().toString());
            struct.add(VdsProperties.DomainId, DbFacade.getInstance().getStorageDomainDAO().getIsoStorageDomainIdForPool(vm.getstorage_pool_id()).toString());
            struct.add(VdsProperties.ImageId, VmDeviceCommonUtils.CDROM_IMAGE_ID);
            struct.add(VdsProperties.VolumeId, file.substring(file.lastIndexOf('/') + 1));
            struct.add(VdsProperties.Path, file);
            // CDROM is always read only
            struct.add(VdsProperties.ReadOnly, Boolean.TRUE.toString());
            addBootOrder(vmDevice, struct);
            devices.add(struct);
            // currently only one is supported, may change in future releases
            break;
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmFloppy() {
    // get vm device for this Floppy from DB
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.FLOPPY));
    for (VmDevice vmDevice : vmDevices) {
        XmlRpcStruct struct = new XmlRpcStruct();
        struct.add(VdsProperties.Type, vmDevice.getType());
        struct.add(VdsProperties.Device, vmDevice.getDevice());
        struct.add(VdsProperties.Index, "0");
        addAddress(vmDevice, struct);
        struct.add(VdsProperties.Iface, "fdc");
        struct.add(VdsProperties.PoolId, vm.getstorage_pool_id().toString());
        struct.add(VdsProperties.DomainId, DbFacade.getInstance().getStorageDomainDAO().getIsoStorageDomainIdForPool(vm.getstorage_pool_id()).toString());
        struct.add(VdsProperties.ImageId, Guid.Empty.toString());
        String file = StringUtils.string2Map(vmDevice.getSpecParams()).get("path");
        struct.add(VdsProperties.VolumeId, file.substring(file.lastIndexOf('/') + 1));
        struct.add(VdsProperties.Path, file);
        struct.add(VdsProperties.ReadOnly, new Boolean(vmDevice.getIsReadOnly()).toString());
        devices.add(struct);
        // currently only one is supported, may change in future releases
        break;
    }
}
#method_after
@Override
protected void buildVmFloppy() {
    // get vm device for this Floppy from DB
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.FLOPPY));
    for (VmDevice vmDevice : vmDevices) {
        XmlRpcStruct struct = new XmlRpcStruct();
        struct.add(VdsProperties.Type, vmDevice.getType());
        struct.add(VdsProperties.Device, vmDevice.getDevice());
        struct.add(VdsProperties.Index, "0");
        addAddress(vmDevice, struct);
        struct.add(VdsProperties.Iface, "fdc");
        struct.add(VdsProperties.PoolId, vm.getstorage_pool_id().toString());
        struct.add(VdsProperties.DomainId, DbFacade.getInstance().getStorageDomainDAO().getIsoStorageDomainIdForPool(vm.getstorage_pool_id()).toString());
        struct.add(VdsProperties.ImageId, Guid.Empty.toString());
        String file = StringUtils.string2Map(vmDevice.getSpecParams()).get("path");
        struct.add(VdsProperties.VolumeId, file.substring(file.lastIndexOf('/') + 1));
        struct.add(VdsProperties.Path, file);
        struct.add(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
        devices.add(struct);
        // currently only one is supported, may change in future releases
        break;
    }
}
#end_block

#method_before
@Override
protected void buildVmDrives() {
    // \\int ideCount = 0, pciCount = 0;
    List<DiskImage> diskImages = getSortedDiskImages();
    for (DiskImage disk : diskImages) {
        XmlRpcStruct struct = new XmlRpcStruct();
        // get vm device for this disk from DB
        VmDevice vmDevice = DbFacade.getInstance().getVmDeviceDAO().get(new VmDeviceId(disk.getDisk().getId(), disk.getvm_guid()));
        if (vmDevice.getIsPlugged()) {
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getdisk_interface()) {
                case IDE:
                    struct.add(VdsProperties.Iface, "ide");
                    // \\ideCount++;
                    break;
                case VirtIO:
                    struct.add(VdsProperties.Iface, VdsProperties.Virtio);
                    // \\pciCount++;
                    break;
                default:
                    // ISCI not supported
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that system disk is created first.
            Guid diskId = vmDevice.getDeviceId();
            if (DbFacade.getInstance().getDiskDao().get(diskId).getDiskType().equals(DiskType.System)) {
                struct.add(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            struct.add(VdsProperties.PoolId, disk.getstorage_pool_id().toString());
            struct.add(VdsProperties.DomainId, disk.getstorage_ids().get(0).toString());
            struct.add(VdsProperties.ImageId, disk.getimage_group_id().toString());
            struct.add(VdsProperties.VolumeId, disk.getId().toString());
            addBootOrder(vmDevice, struct);
            struct.add(VdsProperties.Format, disk.getvolume_format().toString().toLowerCase());
            struct.add(VdsProperties.PropagateErrors, disk.getpropagate_errors().toString().toLowerCase());
            struct.add(VdsProperties.Optional, "false");
            struct.add(VdsProperties.ReadOnly, new Boolean(vmDevice.getIsReadOnly()).toString());
            struct.add(VdsProperties.SpecParams, StringUtils.string2Map(vmDevice.getSpecParams()));
            devices.add(struct);
        }
    }
}
#method_after
@Override
protected void buildVmDrives() {
    // \\int ideCount = 0, pciCount = 0;
    List<DiskImage> diskImages = getSortedDiskImages();
    for (DiskImage disk : diskImages) {
        XmlRpcStruct struct = new XmlRpcStruct();
        // get vm device for this disk from DB
        VmDevice vmDevice = DbFacade.getInstance().getVmDeviceDAO().get(new VmDeviceId(disk.getDisk().getId(), disk.getvm_guid()));
        if (vmDevice.getIsPlugged()) {
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getdisk_interface()) {
                case IDE:
                    struct.add(VdsProperties.Iface, "ide");
                    // \\ideCount++;
                    break;
                case VirtIO:
                    struct.add(VdsProperties.Iface, VdsProperties.Virtio);
                    // \\pciCount++;
                    break;
                default:
                    // ISCI not supported
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that system disk is created first.
            Guid diskId = vmDevice.getDeviceId();
            if (DbFacade.getInstance().getDiskDao().get(diskId).getDiskType().equals(DiskType.System)) {
                struct.add(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            struct.add(VdsProperties.PoolId, disk.getstorage_pool_id().toString());
            struct.add(VdsProperties.DomainId, disk.getstorage_ids().get(0).toString());
            struct.add(VdsProperties.ImageId, disk.getimage_group_id().toString());
            struct.add(VdsProperties.VolumeId, disk.getId().toString());
            addBootOrder(vmDevice, struct);
            struct.add(VdsProperties.Format, disk.getvolume_format().toString().toLowerCase());
            struct.add(VdsProperties.PropagateErrors, disk.getpropagate_errors().toString().toLowerCase());
            struct.add(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.add(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.add(VdsProperties.SpecParams, StringUtils.string2Map(vmDevice.getSpecParams()));
            devices.add(struct);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmVideoCards() {
    // vnc,qxl
    createInfo.add(VdsProperties.display, vm.getdisplay_type().toString());
    createInfo.add(VdsProperties.num_of_monitors, (new Integer(vm.getnum_of_monitors())).toString());
}
#method_after
@Override
protected void buildVmVideoCards() {
    // vnc,qxl
    createInfo.add(VdsProperties.display, vm.getdisplay_type().toString());
    createInfo.add(VdsProperties.num_of_monitors, String.valueOf(vm.getnum_of_monitors()));
}
#end_block

#method_before
@Override
protected void buildVmDrives() {
    Map<String, String>[] drives = new Map[vm.getDiskMap().size()];
    int ideCount = 0, pciCount = 0;
    int i = 0;
    List<DiskImage> diskImages = getSortedDiskImages();
    for (DiskImage disk : diskImages) {
        VmDevice vmDevice = DbFacade.getInstance().getVmDeviceDAO().get(new VmDeviceId(disk.getId(), vm.getId()));
        Map<String, String> drive = new HashMap<String, String>();
        drive.put("domainID", disk.getstorage_ids().get(0).toString());
        drive.put("poolID", disk.getstorage_pool_id().toString());
        drive.put("volumeID", disk.getId().toString());
        drive.put("imageID", disk.getimage_group_id().toString());
        drive.put("format", disk.getvolume_format().toString().toLowerCase());
        drive.put("propagateErrors", disk.getpropagate_errors().toString().toLowerCase());
        switch(disk.getdisk_interface()) {
            case IDE:
                try {
                    drive.put("if", "ide");
                    drive.put("index", String.valueOf(ideIndexSlots[ideCount]));
                    ideCount++;
                } catch (IndexOutOfBoundsException e) {
                    log.errorFormat("buildVmDrives throws IndexOutOfBoundsException for index {0}, IDE slots are limited to 4.", ideCount);
                    throw e;
                }
                break;
            case VirtIO:
                drive.put("if", "virtio");
                drive.put("index", String.valueOf(pciCount));
                drive.put("boot", String.valueOf(disk.getboot()).toLowerCase());
                pciCount++;
                break;
            default:
                // ISCI not supported
                logUnsupportedInterfaceType();
                break;
        }
        drives[i] = drive;
        i++;
    }
    createInfo.add("drives", drives);
}
#method_after
@Override
protected void buildVmDrives() {
    Map<String, String>[] drives = new Map[vm.getDiskMap().size()];
    int ideCount = 0, pciCount = 0;
    int i = 0;
    List<DiskImage> diskImages = getSortedDiskImages();
    for (DiskImage disk : diskImages) {
        Map<String, String> drive = new HashMap<String, String>();
        drive.put("domainID", disk.getstorage_ids().get(0).toString());
        drive.put("poolID", disk.getstorage_pool_id().toString());
        drive.put("volumeID", disk.getId().toString());
        drive.put("imageID", disk.getimage_group_id().toString());
        drive.put("format", disk.getvolume_format().toString().toLowerCase());
        drive.put("propagateErrors", disk.getpropagate_errors().toString().toLowerCase());
        switch(disk.getdisk_interface()) {
            case IDE:
                try {
                    drive.put("if", "ide");
                    drive.put("index", String.valueOf(ideIndexSlots[ideCount]));
                    ideCount++;
                } catch (IndexOutOfBoundsException e) {
                    log.errorFormat("buildVmDrives throws IndexOutOfBoundsException for index {0}, IDE slots are limited to 4.", ideCount);
                    throw e;
                }
                break;
            case VirtIO:
                drive.put("if", "virtio");
                drive.put("index", String.valueOf(pciCount));
                drive.put("boot", String.valueOf(disk.getboot()).toLowerCase());
                pciCount++;
                break;
            default:
                // ISCI not supported
                logUnsupportedInterfaceType();
                break;
        }
        drives[i] = drive;
        i++;
    }
    createInfo.add("drives", drives);
}
#end_block

#method_before
private VmInfoBuilderBase createBuilder() {
    if (VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version()))
        // backward compatibility for 3.0
        return new VmOldInfoBuilder(vm, createInfo);
    else
        return new VmInfoBuilder(vm, createInfo);
}
#method_after
private VmInfoBuilderBase createBuilder() {
    if (VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version())) {
        // backward compatibility for 3.0
        return new VmOldInfoBuilder(vm, createInfo);
    } else {
        return new VmInfoBuilder(vm, createInfo);
    }
}
#end_block

#method_before
private void SaveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.UpdateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.UpdateStatisticsData(stat);
        CheckVdsMemoryThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    DbFacade.getInstance().getInterfaceDAO().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    updateAllInTransaction(_vmDynamicToSave.values(), DbFacade.getInstance().getVmDynamicDAO());
    updateAllInTransaction(_vmStatisticsToSave.values(), DbFacade.getInstance().getVmStatisticsDAO());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    updateAllInTransaction(allVmInterfaceStatistics, DbFacade.getInstance().getVmNetworkStatisticsDAO());
    updateAllInTransaction(_vmDiskImageDynamicToSave.values(), DbFacade.getInstance().getDiskImageDynamicDAO());
}
#method_after
private void SaveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.UpdateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.UpdateStatisticsData(stat);
        CheckVdsMemoryThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    DbFacade.getInstance().getInterfaceDAO().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    updateAllInTransaction(_vmDynamicToSave.values(), DbFacade.getInstance().getVmDynamicDAO());
    updateAllInTransaction(_vmStatisticsToSave.values(), DbFacade.getInstance().getVmStatisticsDAO());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    updateAllInTransaction(allVmInterfaceStatistics, DbFacade.getInstance().getVmNetworkStatisticsDAO());
    updateAllInTransaction(_vmDiskImageDynamicToSave.values(), DbFacade.getInstance().getDiskImageDynamicDAO());
    saveVmDevicesToDb();
}
#end_block

#method_before
public void Refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getstatus() && _vds.getstatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                IrsBrokerCommand.lockDbSave(_vds.getstorage_pool_id());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getvds_name());
                }
                ResourceManager.getInstance().getEventListener().VdsUpEvent(_vds.getId());
                markIsSetNonOperationalExecuted();
                // Check cpu flags if vm moved to up
                _cpuFlagsChanged = true;
            }
            // save all data to db
            SaveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        } finally {
            IrsBrokerCommand.unlockDbSave(_vds.getstorage_pool_id());
        }
    }
}
#method_after
public void Refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getstatus() && _vds.getstatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                IrsBrokerCommand.lockDbSave(_vds.getstorage_pool_id());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getvds_name());
                }
                ResourceManager.getInstance().getEventListener().vdsUpEvent(_vds.getId());
                markIsSetNonOperationalExecuted();
                // Check cpu flags if vm moved to up
                _cpuFlagsChanged = true;
            }
            // save all data to db
            SaveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        } finally {
            IrsBrokerCommand.unlockDbSave(_vds.getstorage_pool_id());
        }
    }
}
#end_block

#method_before
public void AfterRefreshTreatment() {
    try {
        if (_cpuFlagsChanged) {
            ResourceManager.getInstance().getEventListener().ProcessOnCpuFlagsChange(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getstatus() == VDSStatus.Maintenance) {
            try {
                ResourceManager.getInstance().getEventListener().VdsMovedToMaintanance(_vds.getId());
            } catch (RuntimeException ex) {
                log.error("Host encounter a problem moving to maintenance mode. The Host status will change to Non operational status.");
                ResourceManager.getInstance().getEventListener().VdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, true, Guid.Empty);
                throw ex;
            }
        } else if (_vds.getstatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().VdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), false, false, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getvds_name());
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getvds_name());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.SuccededToRunVm(vm_guid);
        }
        // run all vms that crushed that marked with auto startup
        for (Guid vm_guid : _autoVmsToRun) {
            // Refrain from auto-start HA VM during its re-run attempts.
            if (!_vmsToRerun.contains(vm_guid)) {
                ResourceManager.getInstance().getEventListener().RunFailedAutoStartVM(vm_guid);
            }
        }
        // process all vms that their ip changed.
        for (java.util.Map.Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            ResourceManager.getInstance().getEventListener().ProcessOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().ProcessOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getdisplay_ip(), runningVm.getdisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            ResourceManager.getInstance().getEventListener().ProcessOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void AfterRefreshTreatment() {
    try {
        if (_cpuFlagsChanged) {
            ResourceManager.getInstance().getEventListener().processOnCpuFlagsChange(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getstatus() == VDSStatus.Maintenance) {
            try {
                ResourceManager.getInstance().getEventListener().vdsMovedToMaintanance(_vds.getId());
            } catch (RuntimeException ex) {
                log.error("Host encounter a problem moving to maintenance mode. The Host status will change to Non operational status.");
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, true, Guid.Empty);
                throw ex;
            }
        } else if (_vds.getstatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), false, false, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getvds_name());
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getvds_name());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.SuccededToRunVm(vm_guid);
        }
        // run all vms that crushed that marked with auto startup
        for (Guid vm_guid : _autoVmsToRun) {
            // Refrain from auto-start HA VM during its re-run attempts.
            if (!_vmsToRerun.contains(vm_guid)) {
                ResourceManager.getInstance().getEventListener().runFailedAutoStartVM(vm_guid);
            }
        }
        // process all vms that their ip changed.
        for (java.util.Map.Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            ResourceManager.getInstance().getEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getdisplay_ip(), runningVm.getdisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            ResourceManager.getInstance().getEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#end_block

#method_before
private void handleVmDeviceChange() {
    List<String> vmsToUpdate = new ArrayList<String>();
    for (java.util.Map.Entry<VmDynamic, VmStatistics> vm_helper : _runningVms.values()) {
        VmDynamic vm = vm_helper.getKey();
        String dbHash = _vmDict.get(vm.getId()).getHash();
        if ((dbHash == null && vm.getHash() != null) || !dbHash.equals(vm.getHash())) {
            vmsToUpdate.add(vm.getId().toString());
            // update new hash value
            vm.setHash(vm.getHash());
            // DbFacade.getInstance().getVmDynamicDAO().update(vm);
            AddVmDynamicToList(vm);
        }
    }
    if (vmsToUpdate.size() > 0) {
        updateVmDevices(vmsToUpdate);
    }
}
#method_after
private void handleVmDeviceChange() {
    List<String> vmsToUpdate = new ArrayList<String>();
    for (Map.Entry<VmDynamic, VmStatistics> vmHelper : _runningVms.values()) {
        VmDynamic vmDynamic = vmHelper.getKey();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                String dbHash = vm.getHash();
                if ((dbHash == null && vmDynamic.getHash() != null) || !dbHash.equals(vmDynamic.getHash())) {
                    vmsToUpdate.add(vmDynamic.getId().toString());
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        _vmDynamicToSave.get(vm.getId()).setHash(vmDynamic.getHash());
                    } else {
                        AddVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
    if (vmsToUpdate.size() > 0) {
        updateVmDevices(vmsToUpdate);
    }
}
#end_block

#method_before
private XmlRpcStruct[] getVmInfo(List<String> vmsToUpdate) {
    return (XmlRpcStruct[]) (new FullListVdsCommand<VdsIdAndVdsVDSCommandParametersBase>(new FullListVDSCommandParameters(_vds.getId(), vmsToUpdate)).ExecuteWithReturnValue());
}
#method_after
private XmlRpcStruct[] getVmInfo(List<String> vmsToUpdate) {
    return (XmlRpcStruct[]) (new FullListVdsCommand<FullListVDSCommandParameters>(new FullListVDSCommandParameters(_vds.getId(), vmsToUpdate)).ExecuteWithReturnValue());
}
#end_block

#method_before
private void processVmDevices(XmlRpcStruct vm) {
    int i = 0;
    if (vm == null || vm.getItem("vmId") == null) {
        log.errorFormat("Recieved NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem("vmId"));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem("devices");
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem("address")) == null) {
            log.infoFormat("Recieved a Device without an address when processing VM devices, skipping device: {0}.", device.getInnerMap().toString());
            continue;
        }
        VmDevice vmDevice = DbFacade.getInstance().getVmDeviceDAO().get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.getItem("address")).toString());
            DbFacade.getInstance().getVmDeviceDAO().update(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices);
}
#method_after
private void processVmDevices(XmlRpcStruct vm) {
    if (vm == null || vm.getItem(VdsProperties.vm_guid) == null) {
        log.errorFormat("Recieved NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem(VdsProperties.vm_guid));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem(VdsProperties.Devices);
    List<VmDevice> devices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = new HashMap<VmDeviceId, VmDevice>();
    for (VmDevice device : devices) {
        deviceMap.put(device.getId(), device);
    }
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem(VdsProperties.Address)) == null) {
            log.infoFormat("Recieved a Device without an address when processing VM {0} devices, skipping device: {1}.", vmId, device.getInnerMap().toString());
            continue;
        }
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.getItem(VdsProperties.Address)).toString());
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private void handleRemovedDevices(Guid vmId, HashSet<Guid> processedDevices) {
    List<VmDevice> devices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmId(vmId);
    for (VmDevice device : devices) {
        if (!processedDevices.contains(device.getDeviceId())) {
            if (device.getIsManaged()) {
                if (device.getIsPlugged()) {
                    log.errorFormat("Managed non plugable device was removed unexpetedly from libvirt: {0}", device.toString());
                } else {
                    device.setAddress("");
                    DbFacade.getInstance().getVmDeviceDAO().update(device);
                    log.debugFormat("Unmanaged pluggable device was unplugged : {0}", device.toString());
                }
            } else {
                DbFacade.getInstance().getVmDeviceDAO().remove(device.getId());
                log.debugFormat("unmanaged device was removed : {0}", device.toString());
            }
        }
    }
}
#method_after
private void handleRemovedDevices(Guid vmId, HashSet<Guid> processedDevices, List<VmDevice> devices) {
    for (VmDevice device : devices) {
        if (!processedDevices.contains(device.getDeviceId())) {
            if (device.getIsManaged()) {
                if (device.getIsPlugged()) {
                    log.errorFormat("VM {0} managed non plugable device was removed unexpetedly from libvirt: {1}", vmId, device.toString());
                } else {
                    device.setAddress("");
                    addVmDeviceToList(device);
                    log.debugFormat("VM {0} unmanaged pluggable device was unplugged : {1}", vmId, device.toString());
                }
            } else {
                removedDeviceIds.add(device.getId());
                log.debugFormat("VM {0} unmanaged device was marked for remove : {1}", vmId, device.toString());
            }
        }
    }
}
#end_block

#method_before
private Guid addNewVmDevice(Guid vmId, XmlRpcStruct device) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.getItem("type");
    String deviceName = (String) device.getItem("device");
    // do not allow null or empty device or type values
    if (!StringUtils.isEmpty(typeName) && !StringUtils.isEmpty(deviceName)) {
        String address = ((Map<String, String>) device.getItem("address")).toString();
        String specParams = "";
        Object o = device.getItem("specParams");
        newDeviceId = Guid.NewGuid();
        if (o != null) {
            specParams = ((Map<String, String>) o).toString();
        }
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, typeName, deviceName, address, 0, specParams, false, true, false);
        DbFacade.getInstance().getVmDeviceDAO().save(newDevice);
        log.debugFormat("New device was added to VM Devices : {0}", newDevice.toString());
    } else {
        log.error("Empty or NULL values were passed for a VM device, Device is skipped");
    }
    return newDeviceId;
}
#method_after
private Guid addNewVmDevice(Guid vmId, XmlRpcStruct device) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.getItem(VdsProperties.Type);
    String deviceName = (String) device.getItem(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (!StringUtils.isEmpty(typeName) && !StringUtils.isEmpty(deviceName)) {
        String address = ((Map<String, String>) device.getItem(VdsProperties.Address)).toString();
        String specParams = "";
        Object o = device.getItem(VdsProperties.SpecParams);
        newDeviceId = Guid.NewGuid();
        if (o != null) {
            specParams = org.ovirt.engine.core.utils.StringUtils.map2String((Map<String, String>) o);
        }
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, typeName, deviceName, address, 0, specParams, false, true, false);
        newVmDevices.add(newDevice);
        log.debugFormat("New device was marked for adding to VM {0} Devices : {1}", vmId, newDevice.toString());
    } else {
        log.errorFormat("Empty or NULL values were passed for a VM {0} device, Device is skipped", vmId);
    }
    return newDeviceId;
}
#end_block

#method_before
@XmlElement(name = "Interfaces")
public List<VmNetworkInterface> getInterfaces() {
    if (mVmStatic == null)
        return new ArrayList<VmNetworkInterface>();
    else
        return mVmStatic.getInterfaces();
}
#method_after
@XmlElement(name = "Interfaces")
public List<VmNetworkInterface> getInterfaces() {
    if (mVmStatic == null) {
        mVmStatic = new VmStatic();
    }
    return mVmStatic.getInterfaces();
}
#end_block

#method_before
public void setInterfaces(List<VmNetworkInterface> value) {
    mVmStatic.setInterfaces(value);
}
#method_after
public void setInterfaces(List<VmNetworkInterface> value) {
    if (mVmStatic == null) {
        mVmStatic = new VmStatic();
    }
    mVmStatic.setInterfaces(value);
}
#end_block

#method_before
public java.util.ArrayList<DiskImage> getImages() {
    if (mVmStatic == null)
        return new ArrayList<DiskImage>();
    else
        return mVmStatic.getImages();
}
#method_after
public ArrayList<DiskImage> getImages() {
    if (mVmStatic == null) {
        mVmStatic = new VmStatic();
    }
    return mVmStatic.getImages();
}
#end_block

#method_before
public void setImages(java.util.ArrayList<DiskImage> value) {
    mVmStatic.setImages(value);
}
#method_after
public void setImages(ArrayList<DiskImage> value) {
    if (mVmStatic == null) {
        mVmStatic = new VmStatic();
    }
    mVmStatic.setImages(value);
}
#end_block

#method_before
// This function is left only to leave the option of creating a VM without
// having all the data in the DB
// Currently it is used mainly by tests and VdcClient (for direct acccess to
// the VDS)
public void addDriveToImageMap(String drive, DiskImage image) {
    mDiskMap.put(drive, image);
    mVmStatic.getDiskList().add(image);
}
#method_after
// This function is left only to leave the option of creating a VM without
// having all the data in the DB
// Currently it is used mainly by tests and VdcClient (for direct acccess to
// the VDS)
public void addDriveToImageMap(String drive, DiskImage image) {
    mDiskMap.put(drive, image);
    getDiskList().add(image);
}
#end_block

#method_before
public java.util.ArrayList<DiskImage> getDiskList() {
    return mVmStatic.getDiskList();
}
#method_after
public ArrayList<DiskImage> getDiskList() {
    if (mVmStatic == null) {
        mVmStatic = new VmStatic();
    }
    return mVmStatic.getDiskList();
}
#end_block

#method_before
public static boolean VerifyAddVm(java.util.ArrayList<String> reasons, int vmsCount, Object vmTemplateId, Guid storagePoolId, Guid storageDomainId, boolean checkVmTemplateImages, boolean checkTemplateLock, int vmPriority) {
    boolean returnValue = true;
    if (MacPoolManager.getInstance().getavailableMacsCount() < vmsCount) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else {
        boolean isValid = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(storagePoolId)).getReturnValue()).booleanValue();
        if (isValid) {
            if (!VmTemplateCommand.IsVmPriorityValueLegal(vmPriority, reasons)) {
                returnValue = false;
            } else if (checkVmTemplateImages) {
                returnValue = VmTemplateCommand.isVmTemplateImagesReady((Guid) vmTemplateId, storageDomainId, reasons, true, checkTemplateLock, true, true);
            }
        } else {
            if (reasons != null) {
                reasons.add(VdcBllMessages.IMAGE_REPOSITORY_NOT_FOUND.toString());
            }
            returnValue = false;
        }
    }
    return returnValue;
}
#method_after
public static boolean VerifyAddVm(java.util.ArrayList<String> reasons, int vmsCount, VmTemplate vmTemplate, Guid storagePoolId, Guid storageDomainId, boolean checkVmTemplateImages, boolean checkTemplateLock, int vmPriority) {
    boolean returnValue = true;
    if (MacPoolManager.getInstance().getavailableMacsCount() < vmsCount) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else {
        boolean isValid = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(storagePoolId)).getReturnValue()).booleanValue();
        if (isValid) {
            if (!VmTemplateCommand.IsVmPriorityValueLegal(vmPriority, reasons)) {
                returnValue = false;
            } else if (checkVmTemplateImages) {
                returnValue = VmTemplateCommand.isVmTemplateImagesReady(vmTemplate, storageDomainId, reasons, true, checkTemplateLock, true, true);
            }
        } else {
            if (reasons != null) {
                reasons.add(VdcBllMessages.IMAGE_REPOSITORY_NOT_FOUND.toString());
            }
            returnValue = false;
        }
    }
    return returnValue;
}
#end_block

#method_before
public java.util.ArrayList<DiskImage> getImages() {
    return images;
}
#method_after
public ArrayList<DiskImage> getImages() {
    return images;
}
#end_block

#method_before
public java.util.ArrayList<DiskImage> getDiskList() {
    return diskList;
}
#method_after
public ArrayList<DiskImage> getDiskList() {
    return diskList;
}
#end_block

#method_before
@XmlElement
public java.util.Date getcreation_date() {
    return this.creationDate;
}
#method_after
@XmlElement
public Date getcreation_date() {
    return this.creationDate;
}
#end_block

#method_before
public static void addManagedDevice(VmDeviceId id, VmDeviceType type, VmDeviceType device, String specParams, boolean is_plugged, boolean isReadOnly) {
    VmDevice managedDevice = new VmDevice(id, VmDeviceType.getName(type), VmDeviceType.getName(device), "", 0, specParams, true, is_plugged, isReadOnly);
    dao.save(managedDevice);
}
#method_after
public static void addManagedDevice(VmDeviceId id, VmDeviceType type, VmDeviceType device, String specParams, boolean is_plugged, boolean isReadOnly) {
    VmDevice managedDevice = new VmDevice(id, type.getName(), device.getName(), "", 0, specParams, true, is_plugged, isReadOnly);
    dao.save(managedDevice);
}
#end_block

#method_before
private static void updateCdInVmDevice(VmBase oldVmBase, VmBase newVmBase) {
    String newIsoPath = newVmBase.getiso_path();
    String oldIsoPath = oldVmBase.getiso_path();
    if (StringUtils.isEmpty(oldIsoPath) && StringUtils.isNotEmpty(newIsoPath)) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmBase.getId()), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM), "", 0, newIsoPath, true, null, false);
        dao.save(cd);
    } else {
        if (StringUtils.isNotEmpty(oldIsoPath) && StringUtils.isEmpty(newIsoPath)) {
            // existing CD was removed
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmBase.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM));
            dao.remove(list.get(0).getId());
        } else if (StringUtils.isNotEmpty(oldIsoPath) && StringUtils.isNotEmpty(newIsoPath) && !oldIsoPath.equals(newIsoPath)) {
            // CD was changed
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmBase.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM));
            VmDevice cd = list.get(0);
            cd.setSpecParams(newIsoPath);
            dao.update(cd);
        }
    }
}
#method_after
private static void updateCdInVmDevice(VmBase oldVmBase, VmBase newVmBase) {
    String newIsoPath = newVmBase.getiso_path();
    String oldIsoPath = oldVmBase.getiso_path();
    if (StringUtils.isEmpty(oldIsoPath) && StringUtils.isNotEmpty(newIsoPath)) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmBase.getId()), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName(), "", 0, newIsoPath, true, null, false);
        dao.save(cd);
    } else {
        if (StringUtils.isNotEmpty(oldIsoPath) && StringUtils.isEmpty(newIsoPath)) {
            // existing CD was removed
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmBase.getId(), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName());
            dao.remove(list.get(0).getId());
        } else if (StringUtils.isNotEmpty(oldIsoPath) && StringUtils.isNotEmpty(newIsoPath) && !oldIsoPath.equals(newIsoPath)) {
            // CD was changed
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmBase.getId(), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName());
            VmDevice cd = list.get(0);
            cd.setSpecParams(newIsoPath);
            dao.update(cd);
        }
    }
}
#end_block

#method_before
/**
 * updates new VM CD ROM in vm_device
 * @param newVmBase
 */
private static void updateCdInVmDevice(VmBase newVmBase) {
    if (StringUtils.isNotEmpty(newVmBase.getiso_path())) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmBase.getId()), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM), "", 0, newVmBase.getiso_path(), true, null, false);
        dao.save(cd);
    }
}
#method_after
/**
 * updates new VM CD ROM in vm_device
 * @param newVmBase
 */
private static void updateCdInVmDevice(VmBase newVmBase) {
    if (StringUtils.isNotEmpty(newVmBase.getiso_path())) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmBase.getId()), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName(), "", 0, newVmBase.getiso_path(), true, null, false);
        dao.save(cd);
    }
}
#end_block

#method_before
private static int setNetworkBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.getName(VmDeviceType.INTERFACE)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.BRIDGE))) {
            device.setBootOrder(bootOrder++);
        }
    }
    return bootOrder;
}
#method_after
private static int setNetworkBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.INTERFACE.getName()) && device.getDevice().equals(VmDeviceType.BRIDGE.getName())) {
            device.setBootOrder(bootOrder++);
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static int setCDBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.getName(VmDeviceType.DISK)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.CDROM))) {
            device.setBootOrder(bootOrder++);
            // only one CD is currently supported.
            break;
        }
    }
    return bootOrder;
}
#method_after
private static int setCDBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.DISK.getName()) && device.getDevice().equals(VmDeviceType.CDROM.getName())) {
            device.setBootOrder(bootOrder++);
            // only one CD is currently supported.
            break;
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static int setDiskBootOrder(List<VmDevice> devices, int bootOrder) {
    boolean isOldCluster = VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version());
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.getName(VmDeviceType.DISK)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.DISK))) {
            Guid id = device.getDeviceId();
            Disk disk = DbFacade.getInstance().getDiskDao().get(id);
            if (id != null && !id.equals(Guid.Empty)) {
                if (isOldCluster) {
                    // old version.
                    if (disk != null && disk.getDiskType().equals(DiskType.System)) {
                        device.setBootOrder(bootOrder++);
                        break;
                    }
                } else {
                    // supporting more than 1 bootable disk in 3.1 and up.
                    device.setBootOrder(bootOrder++);
                }
            }
        }
    }
    return bootOrder;
}
#method_after
private static int setDiskBootOrder(List<VmDevice> devices, int bootOrder) {
    boolean isOldCluster = VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version());
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.DISK.getName()) && device.getDevice().equals(VmDeviceType.DISK.getName())) {
            Guid id = device.getDeviceId();
            Disk disk = DbFacade.getInstance().getDiskDao().get(id);
            if (id != null && !id.equals(Guid.Empty)) {
                if (isOldCluster) {
                    // old version.
                    if (disk != null && disk.getDiskType().equals(DiskType.System)) {
                        device.setBootOrder(bootOrder++);
                        break;
                    }
                } else {
                    // supporting more than 1 bootable disk in 3.1 and up.
                    device.setBootOrder(bootOrder++);
                }
            }
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static void updateNumOfMonitorsInVmDevice(VmBase oldVmBase, VmBase newStatic) {
    int prevNumOfMonitors = 0;
    if (oldVmBase != null) {
        prevNumOfMonitors = oldVmBase.getnum_of_monitors();
    }
    if (newStatic.getnum_of_monitors() > prevNumOfMonitors) {
        Guid newId = Guid.NewGuid();
        String mem = (newStatic.getnum_of_monitors() > 2 ? LOW_VIDEO_MEM : HIGH_VIDEO_MEM);
        StringBuilder sb = new StringBuilder();
        sb.append(VRAM);
        sb.append("=");
        sb.append(mem);
        sb = new StringBuilder(appendDeviceIdToSpecParams(newId, sb.toString()));
        // monitors were added
        for (int i = prevNumOfMonitors; i < newStatic.getnum_of_monitors(); i++) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.NewGuid(), newStatic.getId()), VmDeviceType.VIDEO, VmDeviceType.QXL, sb.toString(), true, false);
        }
    } else {
        // delete video cards
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(newStatic.getId(), VmDeviceType.getName(VmDeviceType.VIDEO));
        for (int i = 0; i < (prevNumOfMonitors - newStatic.getnum_of_monitors()); i++) {
            dao.remove(list.get(i).getId());
        }
    }
}
#method_after
private static void updateNumOfMonitorsInVmDevice(VmBase oldVmBase, VmBase newStatic) {
    int prevNumOfMonitors = 0;
    if (oldVmBase != null) {
        prevNumOfMonitors = oldVmBase.getnum_of_monitors();
    }
    if (newStatic.getnum_of_monitors() > prevNumOfMonitors) {
        Guid newId = Guid.NewGuid();
        String mem = (newStatic.getnum_of_monitors() > 2 ? LOW_VIDEO_MEM : HIGH_VIDEO_MEM);
        StringBuilder sb = new StringBuilder();
        sb.append(VRAM);
        sb.append("=");
        sb.append(mem);
        sb = new StringBuilder(appendDeviceIdToSpecParams(newId, sb.toString()));
        // monitors were added
        for (int i = prevNumOfMonitors; i < newStatic.getnum_of_monitors(); i++) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.NewGuid(), newStatic.getId()), VmDeviceType.VIDEO, VmDeviceType.QXL, sb.toString(), true, false);
        }
    } else {
        // delete video cards
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(newStatic.getId(), VmDeviceType.VIDEO.getName());
        for (int i = 0; i < (prevNumOfMonitors - newStatic.getnum_of_monitors()); i++) {
            dao.remove(list.get(i).getId());
        }
    }
}
#end_block

#method_before
private static <T extends VmBase> void addImportedDisks(T entity) {
    Guid id = Guid.Empty;
    id = entity.getId();
    List<DiskImage> disks = entity.getImages();
    for (DiskImage disk : disks) {
        Guid deviceId = disk.getDisk().getId();
        String specParams = appendDeviceIdToSpecParams(deviceId, "");
        addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceType.DISK, VmDeviceType.DISK, specParams, true, false);
    }
}
#method_after
private static <T extends VmBase> void addImportedDisks(T entity) {
    final Guid id = entity.getId();
    List<DiskImage> disks;
    if (entity instanceof VmTemplate) {
        disks = entity.getDiskList();
    } else {
        disks = entity.getImages();
    }
    for (DiskImage disk : disks) {
        Guid deviceId = disk.getDisk().getId();
        String specParams = appendDeviceIdToSpecParams(deviceId, "");
        addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceType.DISK, VmDeviceType.DISK, specParams, true, false);
    }
}
#end_block

#method_before
private static <T extends VmBase> void addImportedInterfaces(T entity) {
    Guid id = Guid.Empty;
    id = entity.getId();
    List<VmNetworkInterface> ifaces = entity.getInterfaces();
    for (VmNetworkInterface iface : ifaces) {
        Guid deviceId = iface.getId();
        String specParams = appendDeviceIdToSpecParams(deviceId, "");
        addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceType.INTERFACE, VmDeviceType.BRIDGE, specParams, true, false);
    }
}
#method_after
private static <T extends VmBase> void addImportedInterfaces(T entity) {
    final Guid id = entity.getId();
    for (VmNetworkInterface iface : entity.getInterfaces()) {
        Guid deviceId = iface.getId();
        String specParams = appendDeviceIdToSpecParams(deviceId, "");
        addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceType.INTERFACE, VmDeviceType.BRIDGE, specParams, true, false);
    }
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId) {
    Guid id;
    VmBase vmBase = DbFacade.getInstance().getVmStaticDAO().get(dstId);
    List<DiskImage> disks = DbFacade.getInstance().getDiskImageDAO().getAllForVm(dstId);
    List<VmNetworkInterface> ifaces;
    int diskCount = 0;
    int ifaceCount = 0;
    boolean isVm = (vmBase != null);
    if (isVm) {
        ifaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(dstId);
    } else {
        vmBase = DbFacade.getInstance().getVmTemplateDAO().get(dstId);
        ifaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForTemplate(dstId);
    }
    List<VmDevice> devices = dao.getVmDeviceByVmId(srcId);
    for (VmDevice device : devices) {
        id = Guid.NewGuid();
        String specParams = "";
        if (srcId.equals(Guid.Empty)) {
            // only update number of monitors if this is a desktop
            if (vmBase.getvm_type() == VmType.Desktop) {
                updateNumOfMonitorsInVmDevice(null, vmBase);
            }
            // skip Blank template devices
            continue;
        }
        if (device.getType().equalsIgnoreCase(VmDeviceType.DISK.name()) && device.getDevice().equalsIgnoreCase(VmDeviceType.DISK.name())) {
            if (diskCount < disks.size()) {
                id = (disks.get(diskCount++)).getimage_group_id();
            }
        } else if (device.getType().equalsIgnoreCase(VmDeviceType.INTERFACE.name())) {
            if (ifaceCount < ifaces.size()) {
                id = ifaces.get(ifaceCount++).getId();
            }
        } else if (device.getType().equalsIgnoreCase(VmDeviceType.VIDEO.name())) {
            specParams = getMemExpr(vmBase.getnum_of_monitors());
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(appendDeviceIdToSpecParams(id, specParams));
        dao.save(device);
    }
    // if destination is a VM , update devices boot order
    if (isVm) {
        updateBootOrderInVmDevice(vmBase);
    }
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId) {
    Guid id;
    VmBase vmBase = DbFacade.getInstance().getVmStaticDAO().get(dstId);
    List<DiskImage> disks = DbFacade.getInstance().getDiskImageDAO().getAllForVm(dstId);
    List<VmNetworkInterface> ifaces;
    int diskCount = 0;
    int ifaceCount = 0;
    boolean isVm = (vmBase != null);
    if (isVm) {
        ifaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(dstId);
    } else {
        vmBase = DbFacade.getInstance().getVmTemplateDAO().get(dstId);
        ifaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForTemplate(dstId);
    }
    List<VmDevice> devices = dao.getVmDeviceByVmId(srcId);
    for (VmDevice device : devices) {
        id = Guid.NewGuid();
        String specParams = "";
        if (srcId.equals(Guid.Empty)) {
            // only update number of monitors if this is a desktop
            if (vmBase.getvm_type() == VmType.Desktop) {
                updateNumOfMonitorsInVmDevice(null, vmBase);
            }
            // skip Blank template devices
            continue;
        }
        if (VmDeviceType.DISK.getName().equals(device.getType()) && VmDeviceType.DISK.getName().equals(device.getDevice())) {
            if (diskCount < disks.size()) {
                id = (disks.get(diskCount++)).getimage_group_id();
            }
        } else if (VmDeviceType.INTERFACE.getName().equals(device.getType())) {
            if (ifaceCount < ifaces.size()) {
                id = ifaces.get(ifaceCount++).getId();
            }
        } else if (VmDeviceType.VIDEO.getName().equals(device.getType())) {
            specParams = getMemExpr(vmBase.getnum_of_monitors());
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(appendDeviceIdToSpecParams(id, specParams));
        dao.save(device);
    }
    // if destination is a VM , update devices boot order
    if (isVm) {
        updateBootOrderInVmDevice(vmBase);
    }
}
#end_block

#method_before
public static void addManagedDevice(VmDeviceId id, VmDeviceType type, VmDeviceType device, String specParams, boolean is_plugged, boolean isReadOnly) {
    VmDevice managedDevice = new VmDevice(id, VmDeviceType.getName(type), VmDeviceType.getName(device), "", 0, specParams, true, is_plugged, isReadOnly);
    dao.save(managedDevice);
}
#method_after
public static void addManagedDevice(VmDeviceId id, VmDeviceType type, VmDeviceType device, String specParams, boolean is_plugged, boolean isReadOnly) {
    VmDevice managedDevice = new VmDevice(id, type.getName(), device.getName(), "", 0, specParams, true, is_plugged, isReadOnly);
    dao.save(managedDevice);
}
#end_block

#method_before
private static void updateCdInVmDevice(VmBase oldVmBase, VmBase newVmBase) {
    String newIsoPath = newVmBase.getiso_path();
    String oldIsoPath = oldVmBase.getiso_path();
    if (StringUtils.isEmpty(oldIsoPath) && StringUtils.isNotEmpty(newIsoPath)) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmBase.getId()), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM), "", 0, newIsoPath, true, null, false);
        dao.save(cd);
    } else {
        if (StringUtils.isNotEmpty(oldIsoPath) && StringUtils.isEmpty(newIsoPath)) {
            // existing CD was removed
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmBase.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM));
            dao.remove(list.get(0).getId());
        } else if (StringUtils.isNotEmpty(oldIsoPath) && StringUtils.isNotEmpty(newIsoPath) && !oldIsoPath.equals(newIsoPath)) {
            // CD was changed
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmBase.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM));
            VmDevice cd = list.get(0);
            cd.setSpecParams(newIsoPath);
            dao.update(cd);
        }
    }
}
#method_after
private static void updateCdInVmDevice(VmBase oldVmBase, VmBase newVmBase) {
    String newIsoPath = newVmBase.getiso_path();
    String oldIsoPath = oldVmBase.getiso_path();
    if (StringUtils.isEmpty(oldIsoPath) && StringUtils.isNotEmpty(newIsoPath)) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmBase.getId()), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName(), "", 0, newIsoPath, true, null, false);
        dao.save(cd);
    } else {
        if (StringUtils.isNotEmpty(oldIsoPath) && StringUtils.isEmpty(newIsoPath)) {
            // existing CD was removed
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmBase.getId(), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName());
            dao.remove(list.get(0).getId());
        } else if (StringUtils.isNotEmpty(oldIsoPath) && StringUtils.isNotEmpty(newIsoPath) && !oldIsoPath.equals(newIsoPath)) {
            // CD was changed
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmBase.getId(), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName());
            VmDevice cd = list.get(0);
            cd.setSpecParams(newIsoPath);
            dao.update(cd);
        }
    }
}
#end_block

#method_before
/**
 * updates new VM CD ROM in vm_device
 * @param newVmBase
 */
private static void updateCdInVmDevice(VmBase newVmBase) {
    if (StringUtils.isNotEmpty(newVmBase.getiso_path())) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmBase.getId()), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM), "", 0, newVmBase.getiso_path(), true, null, false);
        dao.save(cd);
    }
}
#method_after
/**
 * updates new VM CD ROM in vm_device
 * @param newVmBase
 */
private static void updateCdInVmDevice(VmBase newVmBase) {
    if (StringUtils.isNotEmpty(newVmBase.getiso_path())) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmBase.getId()), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName(), "", 0, newVmBase.getiso_path(), true, null, false);
        dao.save(cd);
    }
}
#end_block

#method_before
private static int setNetworkBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.getName(VmDeviceType.INTERFACE)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.BRIDGE))) {
            device.setBootOrder(bootOrder++);
        }
    }
    return bootOrder;
}
#method_after
private static int setNetworkBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.INTERFACE.getName()) && device.getDevice().equals(VmDeviceType.BRIDGE.getName())) {
            device.setBootOrder(bootOrder++);
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static int setCDBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.getName(VmDeviceType.DISK)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.CDROM))) {
            device.setBootOrder(bootOrder++);
            // only one CD is currently supported.
            break;
        }
    }
    return bootOrder;
}
#method_after
private static int setCDBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.DISK.getName()) && device.getDevice().equals(VmDeviceType.CDROM.getName())) {
            device.setBootOrder(bootOrder++);
            // only one CD is currently supported.
            break;
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static int setDiskBootOrder(List<VmDevice> devices, int bootOrder) {
    boolean isOldCluster = VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version());
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.getName(VmDeviceType.DISK)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.DISK))) {
            Guid id = device.getDeviceId();
            Disk disk = DbFacade.getInstance().getDiskDao().get(id);
            if (id != null && !id.equals(Guid.Empty)) {
                if (isOldCluster) {
                    // old version.
                    if (disk != null && disk.getDiskType().equals(DiskType.System)) {
                        device.setBootOrder(bootOrder++);
                        break;
                    }
                } else {
                    // supporting more than 1 bootable disk in 3.1 and up.
                    device.setBootOrder(bootOrder++);
                }
            }
        }
    }
    return bootOrder;
}
#method_after
private static int setDiskBootOrder(List<VmDevice> devices, int bootOrder) {
    boolean isOldCluster = VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version());
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.DISK.getName()) && device.getDevice().equals(VmDeviceType.DISK.getName())) {
            Guid id = device.getDeviceId();
            Disk disk = DbFacade.getInstance().getDiskDao().get(id);
            if (id != null && !id.equals(Guid.Empty)) {
                if (isOldCluster) {
                    // old version.
                    if (disk != null && disk.getDiskType().equals(DiskType.System)) {
                        device.setBootOrder(bootOrder++);
                        break;
                    }
                } else {
                    // supporting more than 1 bootable disk in 3.1 and up.
                    device.setBootOrder(bootOrder++);
                }
            }
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static void updateNumOfMonitorsInVmDevice(VmBase oldVmBase, VmBase newStatic) {
    int prevNumOfMonitors = 0;
    if (oldVmBase != null) {
        prevNumOfMonitors = oldVmBase.getnum_of_monitors();
    }
    if (newStatic.getnum_of_monitors() > prevNumOfMonitors) {
        // monitors were added
        for (int i = prevNumOfMonitors; i < newStatic.getnum_of_monitors(); i++) {
            Guid newId = Guid.NewGuid();
            StringBuilder sb = new StringBuilder(appendDeviceIdToSpecParams(newId, getMemExpr(newStatic.getnum_of_monitors())));
            VmDeviceUtils.addManagedDevice(new VmDeviceId(newId, newStatic.getId()), VmDeviceType.VIDEO, VmDeviceType.QXL, sb.toString(), true, false);
        }
    } else {
        // delete video cards
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(newStatic.getId(), VmDeviceType.getName(VmDeviceType.VIDEO));
        for (int i = 0; i < (prevNumOfMonitors - newStatic.getnum_of_monitors()); i++) {
            dao.remove(list.get(i).getId());
        }
    }
}
#method_after
private static void updateNumOfMonitorsInVmDevice(VmBase oldVmBase, VmBase newStatic) {
    int prevNumOfMonitors = 0;
    if (oldVmBase != null) {
        prevNumOfMonitors = oldVmBase.getnum_of_monitors();
    }
    if (newStatic.getnum_of_monitors() > prevNumOfMonitors) {
        // monitors were added
        for (int i = prevNumOfMonitors; i < newStatic.getnum_of_monitors(); i++) {
            Guid newId = Guid.NewGuid();
            StringBuilder sb = new StringBuilder(appendDeviceIdToSpecParams(newId, getMemExpr(newStatic.getnum_of_monitors())));
            VmDeviceUtils.addManagedDevice(new VmDeviceId(newId, newStatic.getId()), VmDeviceType.VIDEO, VmDeviceType.QXL, sb.toString(), true, false);
        }
    } else {
        // delete video cards
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(newStatic.getId(), VmDeviceType.VIDEO.getName());
        for (int i = 0; i < (prevNumOfMonitors - newStatic.getnum_of_monitors()); i++) {
            dao.remove(list.get(i).getId());
        }
    }
}
#end_block

#method_before
private static <T extends VmBase> void addImportedDisks(T entity) {
    Guid id = entity.getId();
    List<DiskImage> disks = entity.getImages();
    for (DiskImage disk : disks) {
        Guid deviceId = disk.getDisk().getId();
        String specParams = appendDeviceIdToSpecParams(deviceId, "");
        addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceType.DISK, VmDeviceType.DISK, specParams, true, false);
    }
}
#method_after
private static <T extends VmBase> void addImportedDisks(T entity) {
    final Guid id = entity.getId();
    List<DiskImage> disks;
    if (entity instanceof VmTemplate) {
        disks = entity.getDiskList();
    } else {
        disks = entity.getImages();
    }
    for (DiskImage disk : disks) {
        Guid deviceId = disk.getDisk().getId();
        String specParams = appendDeviceIdToSpecParams(deviceId, "");
        addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceType.DISK, VmDeviceType.DISK, specParams, true, false);
    }
}
#end_block

#method_before
private static <T extends VmBase> void addImportedInterfaces(T entity) {
    Guid id = entity.getId();
    List<VmNetworkInterface> ifaces = entity.getInterfaces();
    for (VmNetworkInterface iface : ifaces) {
        Guid deviceId = iface.getId();
        String specParams = appendDeviceIdToSpecParams(deviceId, "");
        addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceType.INTERFACE, VmDeviceType.BRIDGE, specParams, true, false);
    }
}
#method_after
private static <T extends VmBase> void addImportedInterfaces(T entity) {
    final Guid id = entity.getId();
    for (VmNetworkInterface iface : entity.getInterfaces()) {
        Guid deviceId = iface.getId();
        String specParams = appendDeviceIdToSpecParams(deviceId, "");
        addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceType.INTERFACE, VmDeviceType.BRIDGE, specParams, true, false);
    }
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId) {
    Guid id;
    VmBase vmBase = DbFacade.getInstance().getVmStaticDAO().get(dstId);
    List<DiskImage> disks = DbFacade.getInstance().getDiskImageDAO().getAllForVm(dstId);
    List<VmNetworkInterface> ifaces;
    int diskCount = 0;
    int ifaceCount = 0;
    boolean isVm = (vmBase != null);
    if (isVm) {
        ifaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(dstId);
    } else {
        vmBase = DbFacade.getInstance().getVmTemplateDAO().get(dstId);
        ifaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForTemplate(dstId);
    }
    List<VmDevice> devices = dao.getVmDeviceByVmId(srcId);
    for (VmDevice device : devices) {
        id = Guid.NewGuid();
        String specParams = "";
        if (srcId.equals(Guid.Empty)) {
            // only update number of monitors if this is a desktop
            if (vmBase.getvm_type() == VmType.Desktop) {
                updateNumOfMonitorsInVmDevice(null, vmBase);
            }
            // skip Blank template devices
            continue;
        }
        if (device.getType().equalsIgnoreCase(VmDeviceType.DISK.name()) && device.getDevice().equalsIgnoreCase(VmDeviceType.DISK.name())) {
            if (diskCount < disks.size()) {
                id = (disks.get(diskCount++)).getimage_group_id();
            }
        } else if (device.getType().equalsIgnoreCase(VmDeviceType.INTERFACE.name())) {
            if (ifaceCount < ifaces.size()) {
                id = ifaces.get(ifaceCount++).getId();
            }
        } else if (device.getType().equalsIgnoreCase(VmDeviceType.VIDEO.name())) {
            specParams = getMemExpr(vmBase.getnum_of_monitors());
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(appendDeviceIdToSpecParams(id, specParams));
        dao.save(device);
    }
    // if destination is a VM , update devices boot order
    if (isVm) {
        updateBootOrderInVmDevice(vmBase);
    }
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId) {
    Guid id;
    VmBase vmBase = DbFacade.getInstance().getVmStaticDAO().get(dstId);
    List<DiskImage> disks = DbFacade.getInstance().getDiskImageDAO().getAllForVm(dstId);
    List<VmNetworkInterface> ifaces;
    int diskCount = 0;
    int ifaceCount = 0;
    boolean isVm = (vmBase != null);
    if (isVm) {
        ifaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(dstId);
    } else {
        vmBase = DbFacade.getInstance().getVmTemplateDAO().get(dstId);
        ifaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForTemplate(dstId);
    }
    List<VmDevice> devices = dao.getVmDeviceByVmId(srcId);
    for (VmDevice device : devices) {
        id = Guid.NewGuid();
        String specParams = "";
        if (srcId.equals(Guid.Empty)) {
            // only update number of monitors if this is a desktop
            if (vmBase.getvm_type() == VmType.Desktop) {
                updateNumOfMonitorsInVmDevice(null, vmBase);
            }
            // skip Blank template devices
            continue;
        }
        if (VmDeviceType.DISK.getName().equals(device.getType()) && VmDeviceType.DISK.getName().equals(device.getDevice())) {
            if (diskCount < disks.size()) {
                id = (disks.get(diskCount++)).getimage_group_id();
            }
        } else if (VmDeviceType.INTERFACE.getName().equals(device.getType())) {
            if (ifaceCount < ifaces.size()) {
                id = ifaces.get(ifaceCount++).getId();
            }
        } else if (VmDeviceType.VIDEO.getName().equals(device.getType())) {
            specParams = getMemExpr(vmBase.getnum_of_monitors());
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(appendDeviceIdToSpecParams(id, specParams));
        dao.save(device);
    }
    // if destination is a VM , update devices boot order
    if (isVm) {
        updateBootOrderInVmDevice(vmBase);
    }
}
#end_block

#method_before
public static void addManagedDevice(VmDeviceId id, VmDeviceType type, VmDeviceType device, String specParams, boolean is_plugged, boolean isReadOnly) {
    VmDevice managedDevice = new VmDevice(id, VmDeviceType.getName(type), VmDeviceType.getName(device), "", 0, specParams, true, is_plugged, isReadOnly);
    dao.save(managedDevice);
}
#method_after
public static void addManagedDevice(VmDeviceId id, VmDeviceType type, VmDeviceType device, String specParams, boolean is_plugged, boolean isReadOnly) {
    VmDevice managedDevice = new VmDevice(id, type.getName(), device.getName(), "", 0, specParams, true, is_plugged, isReadOnly);
    dao.save(managedDevice);
}
#end_block

#method_before
private static void updateCdInVmDevice(VmBase oldVmBase, VmBase newVmBase) {
    String newIsoPath = newVmBase.getiso_path();
    String oldIsoPath = oldVmBase.getiso_path();
    if (StringUtils.isEmpty(oldIsoPath) && StringUtils.isNotEmpty(newIsoPath)) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmBase.getId()), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM), "", 0, newIsoPath, true, null, false);
        dao.save(cd);
    } else {
        if (StringUtils.isNotEmpty(oldIsoPath) && StringUtils.isEmpty(newIsoPath)) {
            // existing CD was removed
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmBase.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM));
            dao.remove(list.get(0).getId());
        } else if (StringUtils.isNotEmpty(oldIsoPath) && StringUtils.isNotEmpty(newIsoPath) && !oldIsoPath.equals(newIsoPath)) {
            // CD was changed
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmBase.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM));
            VmDevice cd = list.get(0);
            cd.setSpecParams(newIsoPath);
            dao.update(cd);
        }
    }
}
#method_after
private static void updateCdInVmDevice(VmBase oldVmBase, VmBase newVmBase) {
    String newIsoPath = newVmBase.getiso_path();
    String oldIsoPath = oldVmBase.getiso_path();
    if (StringUtils.isEmpty(oldIsoPath) && StringUtils.isNotEmpty(newIsoPath)) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmBase.getId()), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName(), "", 0, newIsoPath, true, null, false);
        dao.save(cd);
    } else {
        if (StringUtils.isNotEmpty(oldIsoPath) && StringUtils.isEmpty(newIsoPath)) {
            // existing CD was removed
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmBase.getId(), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName());
            dao.remove(list.get(0).getId());
        } else if (StringUtils.isNotEmpty(oldIsoPath) && StringUtils.isNotEmpty(newIsoPath) && !oldIsoPath.equals(newIsoPath)) {
            // CD was changed
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmBase.getId(), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName());
            VmDevice cd = list.get(0);
            cd.setSpecParams(newIsoPath);
            dao.update(cd);
        }
    }
}
#end_block

#method_before
/**
 * updates new VM CD ROM in vm_device
 * @param newVmBase
 */
private static void updateCdInVmDevice(VmBase newVmBase) {
    if (StringUtils.isNotEmpty(newVmBase.getiso_path())) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmBase.getId()), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM), "", 0, newVmBase.getiso_path(), true, null, false);
        dao.save(cd);
    }
}
#method_after
/**
 * updates new VM CD ROM in vm_device
 * @param newVmBase
 */
private static void updateCdInVmDevice(VmBase newVmBase) {
    if (StringUtils.isNotEmpty(newVmBase.getiso_path())) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmBase.getId()), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName(), "", 0, newVmBase.getiso_path(), true, null, false);
        dao.save(cd);
    }
}
#end_block

#method_before
private static int setNetworkBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.getName(VmDeviceType.INTERFACE)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.BRIDGE))) {
            device.setBootOrder(bootOrder++);
        }
    }
    return bootOrder;
}
#method_after
private static int setNetworkBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.INTERFACE.getName()) && device.getDevice().equals(VmDeviceType.BRIDGE.getName())) {
            device.setBootOrder(bootOrder++);
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static int setCDBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.getName(VmDeviceType.DISK)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.CDROM))) {
            device.setBootOrder(bootOrder++);
            // only one CD is currently supported.
            break;
        }
    }
    return bootOrder;
}
#method_after
private static int setCDBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.DISK.getName()) && device.getDevice().equals(VmDeviceType.CDROM.getName())) {
            device.setBootOrder(bootOrder++);
            // only one CD is currently supported.
            break;
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static int setDiskBootOrder(List<VmDevice> devices, int bootOrder) {
    VM vm = DbFacade.getInstance().getVmDAO().get(vmBaseInstance.getId());
    boolean isOldCluster = VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version());
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.getName(VmDeviceType.DISK)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.DISK))) {
            Guid id = device.getDeviceId();
            Disk disk = DbFacade.getInstance().getDiskDao().get(id);
            if (id != null && !id.equals(Guid.Empty)) {
                if (isOldCluster) {
                    // old version.
                    if (disk != null && disk.getDiskType().equals(DiskType.System)) {
                        device.setBootOrder(bootOrder++);
                        break;
                    }
                } else {
                    // supporting more than 1 bootable disk in 3.1 and up.
                    device.setBootOrder(bootOrder++);
                }
            }
        }
    }
    return bootOrder;
}
#method_after
private static int setDiskBootOrder(List<VmDevice> devices, int bootOrder) {
    VM vm = DbFacade.getInstance().getVmDAO().get(vmBaseInstance.getId());
    boolean isOldCluster = VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version());
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.DISK.getName()) && device.getDevice().equals(VmDeviceType.DISK.getName())) {
            Guid id = device.getDeviceId();
            Disk disk = DbFacade.getInstance().getDiskDao().get(id);
            if (id != null && !id.equals(Guid.Empty)) {
                if (isOldCluster) {
                    // old version.
                    if (disk != null && disk.getDiskType().equals(DiskType.System)) {
                        device.setBootOrder(bootOrder++);
                        break;
                    }
                } else {
                    // supporting more than 1 bootable disk in 3.1 and up.
                    device.setBootOrder(bootOrder++);
                }
            }
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static void updateNumOfMonitorsInVmDevice(VmBase oldVmBase, VmBase newStatic) {
    int prevNumOfMonitors = 0;
    if (oldVmBase != null) {
        prevNumOfMonitors = oldVmBase.getnum_of_monitors();
    }
    if (newStatic.getnum_of_monitors() > prevNumOfMonitors) {
        // monitors were added
        for (int i = prevNumOfMonitors; i < newStatic.getnum_of_monitors(); i++) {
            Guid newId = Guid.NewGuid();
            StringBuilder sb = new StringBuilder(appendDeviceIdToSpecParams(newId, getMemExpr(newStatic.getnum_of_monitors())));
            VmDeviceUtils.addManagedDevice(new VmDeviceId(newId, newStatic.getId()), VmDeviceType.VIDEO, VmDeviceType.QXL, sb.toString(), true, false);
        }
    } else {
        // delete video cards
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(newStatic.getId(), VmDeviceType.getName(VmDeviceType.VIDEO));
        for (int i = 0; i < (prevNumOfMonitors - newStatic.getnum_of_monitors()); i++) {
            dao.remove(list.get(i).getId());
        }
    }
}
#method_after
private static void updateNumOfMonitorsInVmDevice(VmBase oldVmBase, VmBase newStatic) {
    int prevNumOfMonitors = 0;
    if (oldVmBase != null) {
        prevNumOfMonitors = oldVmBase.getnum_of_monitors();
    }
    if (newStatic.getnum_of_monitors() > prevNumOfMonitors) {
        // monitors were added
        for (int i = prevNumOfMonitors; i < newStatic.getnum_of_monitors(); i++) {
            Guid newId = Guid.NewGuid();
            StringBuilder sb = new StringBuilder(appendDeviceIdToSpecParams(newId, getMemExpr(newStatic.getnum_of_monitors())));
            VmDeviceUtils.addManagedDevice(new VmDeviceId(newId, newStatic.getId()), VmDeviceType.VIDEO, VmDeviceType.QXL, sb.toString(), true, false);
        }
    } else {
        // delete video cards
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(newStatic.getId(), VmDeviceType.VIDEO.getName());
        for (int i = 0; i < (prevNumOfMonitors - newStatic.getnum_of_monitors()); i++) {
            dao.remove(list.get(i).getId());
        }
    }
}
#end_block

#method_before
private static <T extends VmBase> void addImportedDisks(T entity) {
    Guid id = entity.getId();
    List<DiskImage> disks = entity.getImages();
    if (entity instanceof VmTemplate) {
        disks = entity.getDiskList();
    }
    for (DiskImage disk : disks) {
        Guid deviceId = disk.getDisk().getId();
        String specParams = appendDeviceIdToSpecParams(deviceId, "");
        addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceType.DISK, VmDeviceType.DISK, specParams, true, false);
    }
}
#method_after
private static <T extends VmBase> void addImportedDisks(T entity) {
    final Guid id = entity.getId();
    List<DiskImage> disks;
    if (entity instanceof VmTemplate) {
        disks = entity.getDiskList();
    } else {
        disks = entity.getImages();
    }
    for (DiskImage disk : disks) {
        Guid deviceId = disk.getDisk().getId();
        String specParams = appendDeviceIdToSpecParams(deviceId, "");
        addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceType.DISK, VmDeviceType.DISK, specParams, true, false);
    }
}
#end_block

#method_before
private static <T extends VmBase> void addImportedInterfaces(T entity) {
    Guid id = entity.getId();
    List<VmNetworkInterface> ifaces = entity.getInterfaces();
    for (VmNetworkInterface iface : ifaces) {
        Guid deviceId = iface.getId();
        String specParams = appendDeviceIdToSpecParams(deviceId, "");
        addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceType.INTERFACE, VmDeviceType.BRIDGE, specParams, true, false);
    }
}
#method_after
private static <T extends VmBase> void addImportedInterfaces(T entity) {
    final Guid id = entity.getId();
    for (VmNetworkInterface iface : entity.getInterfaces()) {
        Guid deviceId = iface.getId();
        String specParams = appendDeviceIdToSpecParams(deviceId, "");
        addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceType.INTERFACE, VmDeviceType.BRIDGE, specParams, true, false);
    }
}
#end_block

#method_before
private DetailedLink addParametersMetadata(DetailedLink link) {
    String link_name = link.getHref() + "|rel=" + link.getRel();
    if (this.parametersMetaData.containsKey(link_name)) {
        Action action = this.parametersMetaData.get(link_name);
        if (action.getRequest() != null) {
            if (action.getRequest().getUrlparams() != null && !action.getRequest().getUrlparams().isEmpty()) {
                link.getRequest().setUrl(new Url());
                ParametersSet ps = new ParametersSet();
                for (Object key : action.getRequest().getUrlparams().keySet()) {
                    Parameter param = new Parameter();
                    param.setName(key.toString());
                    Object value = action.getRequest().getUrlparams().get(key);
                    if (value != null) {
                        UrlParamData urlParamData = (UrlParamData) value;
                        param.setType(urlParamData.getType());
                        param.setContext(urlParamData.getContext());
                        param.setValue(urlParamData.getDescription());
                    }
                    ps.getParameters().add(param);
                }
                link.getRequest().getUrl().getParametersSets().add(ps);
            }
            if (action.getRequest().getHeaders() != null && !action.getRequest().getHeaders().isEmpty()) {
                link.getRequest().setHeaders(new Headers());
                for (Object key : action.getRequest().getHeaders().keySet()) {
                    Header header = new Header();
                    header.setName(key.toString());
                    Object value = action.getRequest().getHeaders().get(key);
                    if (value != null) {
                        header.setValue(value.toString());
                    }
                    link.getRequest().getHeaders().getHeaders().add(header);
                }
            }
            if (action.getRequest().getBody() != null) {
                if (action.getRequest().getBody().getSignatures() != null) {
                    for (Signature signature : action.getRequest().getBody().getSignatures()) {
                        ParametersSet ps = new ParametersSet();
                        for (Entry<Object, Object> mandatoryKeyValuePair : signature.getMandatoryArguments().entrySet()) {
                            Parameter mandatory_param = new Parameter();
                            mandatory_param.setName(mandatoryKeyValuePair.getKey().toString());
                            mandatory_param.setType(mandatoryKeyValuePair.getValue().toString());
                            mandatory_param.setMandatory(true);
                            ps.getParameters().add(mandatory_param);
                        }
                        for (Entry<Object, Object> optionalKeyValuePair : signature.getOptionalArguments().entrySet()) {
                            Parameter optional_param = new Parameter();
                            optional_param.setName(optionalKeyValuePair.getKey().toString());
                            optional_param.setType(optionalKeyValuePair.getValue().toString());
                            optional_param.setMandatory(false);
                            ps.getParameters().add(optional_param);
                        }
                        link.getRequest().getBody().getParametersSets().add(ps);
                    }
                }
            }
        }
    }
    return link;
}
#method_after
private DetailedLink addParametersMetadata(DetailedLink link) {
    String link_name = link.getHref() + "|rel=" + link.getRel();
    if (this.parametersMetaData.containsKey(link_name)) {
        Action action = this.parametersMetaData.get(link_name);
        if (action.getRequest() != null) {
            if (action.getRequest().getUrlparams() != null && !action.getRequest().getUrlparams().isEmpty()) {
                link.getRequest().setUrl(new Url());
                ParametersSet ps = new ParametersSet();
                for (Object key : action.getRequest().getUrlparams().keySet()) {
                    Parameter param = new Parameter();
                    param.setName(key.toString());
                    Object value = action.getRequest().getUrlparams().get(key);
                    if (value != null) {
                        UrlParamData urlParamData = (UrlParamData) value;
                        param.setType(urlParamData.getType());
                        param.setContext(urlParamData.getContext());
                        param.setValue(urlParamData.getValue());
                        param.setRequired(urlParamData.getRequired() == null ? false : urlParamData.getRequired());
                    }
                    ps.getParameters().add(param);
                }
                link.getRequest().getUrl().getParametersSets().add(ps);
            }
            if (action.getRequest().getHeaders() != null && !action.getRequest().getHeaders().isEmpty()) {
                link.getRequest().setHeaders(new Headers());
                for (Object key : action.getRequest().getHeaders().keySet()) {
                    Header header = new Header();
                    header.setName(key.toString());
                    Object value = action.getRequest().getHeaders().get(key);
                    if (value != null) {
                        header.setValue(value.toString());
                    }
                    link.getRequest().getHeaders().getHeaders().add(header);
                }
            }
            if (action.getRequest().getBody() != null) {
                if (action.getRequest().getBody().getSignatures() != null) {
                    for (Signature signature : action.getRequest().getBody().getSignatures()) {
                        ParametersSet ps = new ParametersSet();
                        for (Entry<Object, Object> mandatoryKeyValuePair : signature.getMandatoryArguments().entrySet()) {
                            Parameter mandatory_param = new Parameter();
                            mandatory_param.setName(mandatoryKeyValuePair.getKey().toString());
                            mandatory_param.setType(mandatoryKeyValuePair.getValue().toString());
                            mandatory_param.setRequired(true);
                            ps.getParameters().add(mandatory_param);
                        }
                        for (Entry<Object, Object> optionalKeyValuePair : signature.getOptionalArguments().entrySet()) {
                            Parameter optional_param = new Parameter();
                            optional_param.setName(optionalKeyValuePair.getKey().toString());
                            optional_param.setType(optionalKeyValuePair.getValue().toString());
                            optional_param.setRequired(false);
                            ps.getParameters().add(optional_param);
                        }
                        link.getRequest().getBody().getParametersSets().add(ps);
                    }
                }
            }
        }
    }
    return link;
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    VdsDAO vdsDAO = prepareDAO(dbFacade.getVdsDAO());
    existingVds = vdsDAO.get(new NGuid("afce7a39-8e8c-4819-ba9c-796d316592e6"));
    StoragePoolDAO storagePoolDAO = prepareDAO(dbFacade.getStoragePoolDAO());
    storagePool = storagePoolDAO.get(new Guid("6d849ebf-755f-4552-ad09-9a090cda105d"));
    dao = prepareDAO(dbFacade.getVdsGroupDAO());
    existingVdsGroup = dao.get(existingVds.getvds_group_id());
    groupWithNoRunningVms = dbFacade.getVdsGroupDAO().get(new Guid("b399944a-81ab-4ec5-8266-e19ba7c3c9d3"));
    newGroup = new VDSGroup();
    newGroup.setname("New VDS Group");
    newGroup.setcompatibility_version(new Version("3.0"));
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    VdsDAO vdsDAO = prepareDAO(dbFacade.getVdsDAO());
    existingVds = vdsDAO.get(FixturesTool.VDS_RHEL6_NFS_SPM);
    StoragePoolDAO storagePoolDAO = prepareDAO(dbFacade.getStoragePoolDAO());
    storagePool = storagePoolDAO.get(FixturesTool.STORAGE_POOL_RHEL6_ISCSI_OTHER);
    dao = prepareDAO(dbFacade.getVdsGroupDAO());
    existingVdsGroup = dao.get(existingVds.getvds_group_id());
    groupWithNoRunningVms = dbFacade.getVdsGroupDAO().get(FixturesTool.VDS_GROUP_NO_RUNNING_VMS);
    newGroup = new VDSGroup();
    newGroup.setname("New VDS Group");
    newGroup.setcompatibility_version(new Version("3.0"));
}
#end_block

#method_before
@Override
public Map<Guid, VdcObjectType> getPermissionCheckSubjects() {
    return Collections.singletonMap(getVmPoolId() == null ? null : getVmPoolId().getValue(), VdcObjectType.VmPool);
}
#method_after
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(getVmPoolId() == null ? null : getVmPoolId().getValue(), VdcObjectType.VmPool, getActionType().getActionGroup()));
    return permissionList;
}
#end_block

#method_before
private void managePrestartedVmsInPool(vm_pools vmPool) {
    int prestartedVms;
    int missingPrestartedVms;
    int vmsToPrestart;
    Guid vmGuid;
    prestartedVms = VmPoolCommandBase.getNumOfPrestartedVmsInPool(vmPool.getvm_pool_id());
    missingPrestartedVms = vmPool.getPrestartedVms() - prestartedVms;
    if (missingPrestartedVms > 0) {
        // We do not want to start too many vms at once
        int batchSize = Config.<Integer>GetValue(ConfigValues.VmPoolMonitorBatchSize);
        if (missingPrestartedVms > batchSize) {
            vmsToPrestart = batchSize;
        } else {
            vmsToPrestart = missingPrestartedVms;
        }
        log.infoFormat("Missing {0} prestarted Vms, attempting to prestart {1} Vms", missingPrestartedVms, vmsToPrestart);
        for (int i = 0; i < vmsToPrestart; i++) {
            vmGuid = VmPoolCommandBase.getNonPrestartedVmToAttach(vmPool.getvm_pool_id());
            if (vmGuid != Guid.Empty) {
                // If failed to prestart a Vm, stop trying
                if (!prestartVm(vmGuid)) {
                    break;
                }
            } else {
                log.infoFormat("No Vms avaialable for prestarting");
                break;
            }
        }
    }
}
#method_after
private void managePrestartedVmsInPool(vm_pools vmPool) {
    int prestartedVms;
    int missingPrestartedVms;
    int numOfVmsToPrestart;
    prestartedVms = VmPoolCommandBase.getNumOfPrestartedVmsInPool(vmPool.getvm_pool_id());
    missingPrestartedVms = vmPool.getPrestartedVms() - prestartedVms;
    if (missingPrestartedVms > 0) {
        // We do not want to start too many vms at once
        int batchSize = Config.<Integer>GetValue(ConfigValues.VmPoolMonitorBatchSize);
        if (missingPrestartedVms > batchSize) {
            numOfVmsToPrestart = batchSize;
        } else {
            numOfVmsToPrestart = missingPrestartedVms;
        }
        log.infoFormat("VmPool {0} is missing {1} prestarted Vms, attempting to prestart {2} Vms", vmPool.getvm_pool_id(), missingPrestartedVms, numOfVmsToPrestart);
        prestartVms(vmPool, numOfVmsToPrestart);
    }
}
#end_block

#method_before
private boolean prestartVm(Guid vmGuid) {
    log.infoFormat("Prestarting Vm {0}", vmGuid);
    boolean prestartingVmSucceeded = false;
    RunVmParams runVmParams = new RunVmParams(vmGuid);
    VM vm = DbFacade.getInstance().getVmDAO().get(vmGuid);
    runVmParams.setUseVnc(vm.getvm_type() == VmType.Server);
    runVmParams.setEntityId(vm);
    runVmParams.setParentCommand(VdcActionType.RunVm);
    runVmParams.setUseVnc(vm.getvm_type() == VmType.Server);
    runVmParams.setRunAsStateless(true);
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RunVm, runVmParams);
    prestartingVmSucceeded = vdcReturnValue.getSucceeded();
    if (prestartingVmSucceeded) {
        log.infoFormat("Prestarting Vm {0} succeeded", vmGuid);
    } else {
        log.infoFormat("Prestarting Vm {0} failed", vmGuid);
    }
    return prestartingVmSucceeded;
}
#method_after
private boolean prestartVm(VM vmToPrestart) {
    log.infoFormat("Prestarting Vm {0}", vmToPrestart);
    boolean prestartingVmSucceeded = false;
    RunVmParams runVmParams = new RunVmParams(vmToPrestart.getId());
    runVmParams.setUseVnc(vmToPrestart.getvm_type() == VmType.Server);
    runVmParams.setEntityId(vmToPrestart);
    runVmParams.setRunAsStateless(true);
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RunVm, runVmParams);
    prestartingVmSucceeded = vdcReturnValue.getSucceeded();
    if (prestartingVmSucceeded) {
        log.infoFormat("Prestarting Vm {0} succeeded", vmToPrestart);
    } else {
        log.infoFormat("Prestarting Vm {0} failed", vmToPrestart);
    }
    return prestartingVmSucceeded;
}
#end_block

#method_before
private void RestoreVmFromBaseSnapshot(VM vm) {
    if (DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(vm.getId()).size() > 0) {
        log.infoFormat("Deleting snapshots for stateless vm {0}", vm.getId());
        Backend.getInstance().runInternalAction(VdcActionType.RestoreStatelessVm, new VmOperationParameterBase(vm.getId()), new CommandContext(getCompensationContext()));
    }
}
#method_after
private void RestoreVmFromBaseSnapshot(VM vm) {
    if (getDiskImageDAO().getAllStatelessVmImageMapsForVm(vm.getId()).size() > 0) {
        log.infoFormat("Deleting snapshots for stateless vm {0}", vm.getId());
        Backend.getInstance().runInternalAction(VdcActionType.RestoreStatelessVm, new VmOperationParameterBase(vm.getId()), new CommandContext(getCompensationContext()));
    }
}
#end_block

#method_before
@Override
public vm_pools get(NGuid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_pool_id", id);
    ParameterizedRowMapper<vm_pools> mapper = new ParameterizedRowMapper<vm_pools>() {

        @Override
        public vm_pools mapRow(ResultSet rs, int rowNum) throws SQLException {
            vm_pools entity = new vm_pools();
            entity.setvm_pool_description(rs.getString("vm_pool_description"));
            entity.setvm_pool_id(Guid.createGuidFromString(rs.getString("vm_pool_id")));
            entity.setvm_pool_name(rs.getString("vm_pool_name"));
            entity.setvm_pool_type(VmPoolType.forValue(rs.getInt("vm_pool_type")));
            entity.setparameters(rs.getString("parameters"));
            entity.setPrestartedVms(rs.getInt("prestarted_vms"));
            entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
            entity.setvds_group_name(rs.getString("vds_group_name"));
            entity.setvm_assigned_count(rs.getInt("assigned_vm_count"));
            entity.setvm_running_count(rs.getInt("vm_running_count"));
            return entity;
        }
    };
    return getCallsHandler().executeRead("GetVm_poolsByvm_pool_id", mapper, parameterSource);
}
#method_after
@Override
public vm_pools get(NGuid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_pool_id", id);
    return getCallsHandler().executeRead("GetVm_poolsByvm_pool_id", vmPoolFullRowMapper, parameterSource);
}
#end_block

#method_before
@Override
public vm_pools getByName(String name) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_pool_name", name);
    ParameterizedRowMapper<vm_pools> mapper = new ParameterizedRowMapper<vm_pools>() {

        @Override
        public vm_pools mapRow(ResultSet rs, int rowNum) throws SQLException {
            vm_pools entity = new vm_pools();
            entity.setvm_pool_description(rs.getString("vm_pool_description"));
            entity.setvm_pool_id(Guid.createGuidFromString(rs.getString("vm_pool_id")));
            entity.setvm_pool_name(rs.getString("vm_pool_name"));
            entity.setvm_pool_type(VmPoolType.forValue(rs.getInt("vm_pool_type")));
            entity.setparameters(rs.getString("parameters"));
            entity.setPrestartedVms(rs.getInt("prestarted_vms"));
            entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
            entity.setvds_group_name(rs.getString("vds_group_name"));
            return entity;
        }
    };
    return getCallsHandler().executeRead("GetVm_poolsByvm_pool_name", mapper, parameterSource);
}
#method_after
@Override
public vm_pools getByName(String name) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_pool_name", name);
    return getCallsHandler().executeRead("GetVm_poolsByvm_pool_name", vmPoolNonFullRowMapper, parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<vm_pools> getAll() {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource();
    ParameterizedRowMapper<vm_pools> mapper = new ParameterizedRowMapper<vm_pools>() {

        @Override
        public vm_pools mapRow(ResultSet rs, int rowNum) throws SQLException {
            vm_pools entity = new vm_pools();
            entity.setvm_pool_description(rs.getString("vm_pool_description"));
            entity.setvm_pool_id(Guid.createGuidFromString(rs.getString("vm_pool_id")));
            entity.setvm_pool_name(rs.getString("vm_pool_name"));
            entity.setvm_pool_type(VmPoolType.forValue(rs.getInt("vm_pool_type")));
            entity.setparameters(rs.getString("parameters"));
            entity.setPrestartedVms(rs.getInt("prestarted_vms"));
            entity.setvm_assigned_count(rs.getInt("assigned_vm_count"));
            entity.setvm_running_count(rs.getInt("vm_running_count"));
            entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
            entity.setvds_group_name(rs.getString("vds_group_name"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetAllFromVm_pools", mapper, parameterSource);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public List<vm_pools> getAll() {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource();
    return getCallsHandler().executeReadList("GetAllFromVm_pools", vmPoolFullRowMapper, parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<vm_pools> getAllForUser(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("user_id", id);
    ParameterizedRowMapper<vm_pools> mapper = new ParameterizedRowMapper<vm_pools>() {

        @Override
        public vm_pools mapRow(ResultSet rs, int rowNum) throws SQLException {
            vm_pools entity = new vm_pools();
            entity.setvm_pool_id(Guid.createGuidFromString(rs.getString("vm_pool_id")));
            entity.setvm_pool_name(rs.getString("vm_pool_name"));
            entity.setvm_pool_description(rs.getString("vm_pool_description"));
            entity.setvm_pool_type(VmPoolType.forValue(rs.getInt("vm_pool_type")));
            entity.setparameters(rs.getString("parameters"));
            entity.setPrestartedVms(rs.getInt("prestarted_vms"));
            entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
            entity.setvds_group_name(rs.getString("vds_group_name"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetAllVm_poolsByUser_id_with_groups_and_UserRoles", mapper, parameterSource);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public List<vm_pools> getAllForUser(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("user_id", id);
    return getCallsHandler().executeReadList("GetAllVm_poolsByUser_id_with_groups_and_UserRoles", vmPoolNonFullRowMapper, parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<vm_pools> getAllForAdGroup(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("ad_group_id", id);
    ParameterizedRowMapper<vm_pools> mapper = new ParameterizedRowMapper<vm_pools>() {

        @Override
        public vm_pools mapRow(ResultSet rs, int rowNum) throws SQLException {
            vm_pools entity = new vm_pools();
            entity.setvm_pool_id(Guid.createGuidFromString(rs.getString("vm_pool_id")));
            entity.setvm_pool_name(rs.getString("vm_pool_name"));
            entity.setvm_pool_description(rs.getString("vm_pool_description"));
            entity.setvm_pool_type(VmPoolType.forValue(rs.getInt("vm_pool_type")));
            entity.setparameters(rs.getString("parameters"));
            entity.setPrestartedVms(rs.getInt("prestarted_vms"));
            entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
            entity.setvds_group_name(rs.getString("vds_group_name"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetVm_poolsByAdGroup_id", mapper, parameterSource);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public List<vm_pools> getAllForAdGroup(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("ad_group_id", id);
    return getCallsHandler().executeReadList("GetVm_poolsByAdGroup_id", vmPoolNonFullRowMapper, parameterSource);
}
#end_block

#method_before
@Override
public List<vm_pools> getAllWithQuery(String query) {
    ParameterizedRowMapper<vm_pools> mapper = new ParameterizedRowMapper<vm_pools>() {

        @Override
        public vm_pools mapRow(ResultSet rs, int rowNum) throws SQLException {
            vm_pools entity = new vm_pools();
            entity.setvm_pool_description(rs.getString("vm_pool_description"));
            entity.setvm_pool_id(Guid.createGuidFromString(rs.getString("vm_pool_id")));
            entity.setvm_pool_name(rs.getString("vm_pool_name"));
            entity.setvm_pool_type(VmPoolType.forValue(rs.getInt("vm_pool_type")));
            entity.setparameters(rs.getString("parameters"));
            entity.setPrestartedVms(rs.getInt("prestarted_vms"));
            entity.setvm_assigned_count(rs.getInt("assigned_vm_count"));
            entity.setvm_running_count(rs.getInt("vm_running_count"));
            entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
            entity.setvds_group_name(rs.getString("vds_group_name"));
            return entity;
        }
    };
    return new SimpleJdbcTemplate(jdbcTemplate).query(query, mapper);
}
#method_after
@Override
public List<vm_pools> getAllWithQuery(String query) {
    return new SimpleJdbcTemplate(jdbcTemplate).query(query, vmPoolFullRowMapper);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getParameters().setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
    initUser();
    boolean isPrestartedVm = false;
    Guid vmToAttach = Guid.Empty;
    synchronized (_lockObject) {
        vmToAttach = getPrestartedVmToAttach(getParameters().getVmPoolId());
        if (!Guid.Empty.equals(vmToAttach)) {
            isPrestartedVm = true;
        } else {
            vmToAttach = getNonPrestartedVmToAttach(getParameters().getVmPoolId());
        }
        if (!Guid.Empty.equals(vmToAttach)) {
            getParameters().setEntityId(vmToAttach);
            setVmId(vmToAttach);
            permissions perm = new permissions(getAdUserId(), PredefinedRoles.ENGINE_USER.getId(), vmToAttach, VdcObjectType.VM);
            PermissionsOperationsParametes permParams = new PermissionsOperationsParametes(perm);
            permParams.setShouldBeLogged(false);
            permParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
            VdcReturnValueBase vdcReturnValueFromAddPerm = Backend.getInstance().runInternalAction(VdcActionType.AddPermission, permParams, new CommandContext(getCompensationContext()));
            if (!vdcReturnValueFromAddPerm.getSucceeded()) {
                log.infoFormat("Failed to give user {0} permission to Vm {1} ", getAdUserId(), vmToAttach);
                setActionReturnValue(vdcReturnValueFromAddPerm);
                return;
            } else {
                log.infoFormat("Succceeded giving user {0} permission to Vm {1} ", getAdUserId(), vmToAttach);
            }
        } else {
            log.infoFormat("No free Vms in pool {0}. Cannot allocate for user {1} ", getVmPoolId(), getAdUserId());
            throw new VdcBLLException(VdcBllErrors.NO_FREE_VM_IN_POOL);
        }
    }
    // Only when using a Vm that is not prestarted do we need to run the vm
    if (!isPrestartedVm) {
        setVm(DbFacade.getInstance().getVmDAO().get(vmToAttach));
        RunVmParams runVmParams = new RunVmParams(vmToAttach);
        runVmParams.setSessionId(getParameters().getSessionId());
        runVmParams.setUseVnc(getVm().getvm_type() == VmType.Server);
        runVmParams.setParentParemeters(getParameters());
        runVmParams.setEntityId(vmToAttach);
        runVmParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
        runVmParams.setRunAsStateless(true);
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RunVm, runVmParams);
        getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
        setSucceeded(vdcReturnValue.getSucceeded());
        setActionReturnValue(vmToAttach);
        getReturnValue().getTaskIdList().addAll(getReturnValue().getInternalTaskIdList());
    }
}
#method_after
@Override
protected void executeCommand() {
    getParameters().setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
    initUser();
    boolean isPrestartedVm = false;
    Guid vmToAttach = Guid.Empty;
    synchronized (_lockObject) {
        vmToAttach = getPrestartedVmToAttach(getParameters().getVmPoolId());
        if (!Guid.Empty.equals(vmToAttach)) {
            isPrestartedVm = true;
        } else {
            vmToAttach = getNonPrestartedVmToAttach(getParameters().getVmPoolId());
        }
        if (!Guid.Empty.equals(vmToAttach)) {
            getParameters().setEntityId(vmToAttach);
            setVmId(vmToAttach);
            permissions perm = new permissions(getAdUserId(), PredefinedRoles.ENGINE_USER.getId(), vmToAttach, VdcObjectType.VM);
            PermissionsOperationsParametes permParams = new PermissionsOperationsParametes(perm);
            permParams.setShouldBeLogged(false);
            permParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
            VdcReturnValueBase vdcReturnValueFromAddPerm = Backend.getInstance().runInternalAction(VdcActionType.AddPermission, permParams, new CommandContext(getCompensationContext()));
            if (!vdcReturnValueFromAddPerm.getSucceeded()) {
                log.infoFormat("Failed to give user {0} permission to Vm {1} ", getAdUserId(), vmToAttach);
                setActionReturnValue(vdcReturnValueFromAddPerm);
                return;
            } else {
                log.infoFormat("Succceeded giving user {0} permission to Vm {1} ", getAdUserId(), vmToAttach);
            }
        } else {
            log.infoFormat("No free Vms in pool {0}. Cannot allocate for user {1} ", getVmPoolId(), getAdUserId());
            throw new VdcBLLException(VdcBllErrors.NO_FREE_VM_IN_POOL);
        }
    }
    // Only when using a Vm that is not prestarted do we need to run the vm
    if (!isPrestartedVm) {
        setVm(getVmDAO().get(vmToAttach));
        RunVmParams runVmParams = new RunVmParams(vmToAttach);
        runVmParams.setSessionId(getParameters().getSessionId());
        runVmParams.setUseVnc(getVm().getvm_type() == VmType.Server);
        runVmParams.setParentParemeters(getParameters());
        runVmParams.setEntityId(vmToAttach);
        runVmParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
        runVmParams.setRunAsStateless(true);
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RunVm, runVmParams);
        getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
        setSucceeded(vdcReturnValue.getSucceeded());
        setActionReturnValue(vmToAttach);
        getReturnValue().getTaskIdList().addAll(getReturnValue().getInternalTaskIdList());
    }
}
#end_block

#method_before
@Override
public DiskImage get(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("image_guid", id);
    ParameterizedRowMapper<DiskImage> mapper = new ParameterizedRowMapper<DiskImage>() {

        @Override
        public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
            DiskImage entity = new DiskImage();
            entity.setactive((Boolean) rs.getObject("active"));
            entity.setvm_guid(Guid.createGuidFromString(rs.getString("vm_guid")));
            entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
            entity.setactual_size(rs.getLong("actual_size"));
            entity.setdescription(rs.getString("description"));
            entity.setId(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setit_guid(Guid.createGuidFromString(rs.getString("it_guid")));
            entity.setsize(rs.getLong("size"));
            entity.setParentId(Guid.createGuidFromString(rs.getString("ParentId")));
            entity.setimageStatus(ImageStatus.forValue(rs.getInt("imageStatus")));
            entity.setlastModified(DbFacadeUtils.fromDate(rs.getTimestamp("lastModified")));
            entity.setappList(rs.getString("app_list"));
            entity.setstorage_id(NGuid.createGuidFromString(rs.getString("storage_id")));
            entity.setvm_snapshot_id(NGuid.createGuidFromString(rs.getString("vm_snapshot_id")));
            entity.setvolume_type(VolumeType.forValue(rs.getInt("volume_type")));
            entity.setvolume_format(VolumeFormat.forValue(rs.getInt("volume_format")));
            entity.setdisk_type(DiskType.forValue(rs.getInt("disk_type")));
            entity.setimage_group_id(Guid.createGuidFromString(rs.getString("image_group_id")));
            entity.setstorage_path(rs.getString("storage_path"));
            entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
            entity.setdisk_interface(DiskInterface.forValue(rs.getInt("disk_interface")));
            entity.setboot(rs.getBoolean("boot"));
            entity.setwipe_after_delete(rs.getBoolean("wipe_after_delete"));
            entity.setpropagate_errors(PropagateErrors.forValue(rs.getInt("propagate_errors")));
            entity.setread_rate(rs.getInt("read_rate"));
            entity.setwrite_rate(rs.getInt("write_rate"));
            return entity;
        }
    };
    return getCallsHandler().executeRead("GetImageByImageGuid", mapper, parameterSource);
}
#method_after
@Override
public DiskImage get(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("image_guid", id);
    List<DiskImage> images = groupImagesStorage(getCallsHandler().executeReadList("GetImageByImageGuid", fullDiskImageRowMapper, parameterSource));
    if (images == null || images.isEmpty()) {
        return null;
    }
    return images.get(0);
}
#end_block

#method_before
@Override
public DiskImage getSnapshotById(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("image_guid", id);
    ParameterizedRowMapper<DiskImage> mapper = new ParameterizedRowMapper<DiskImage>() {

        @Override
        public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
            DiskImage entity = new DiskImage();
            entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
            entity.setactual_size(rs.getLong("actual_size"));
            entity.setdescription(rs.getString("description"));
            entity.setId(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setit_guid(Guid.createGuidFromString(rs.getString("it_guid")));
            entity.setsize(rs.getLong("size"));
            entity.setParentId(Guid.createGuidFromString(rs.getString("ParentId")));
            entity.setimageStatus(ImageStatus.forValue(rs.getInt("imageStatus")));
            entity.setlastModified(DbFacadeUtils.fromDate(rs.getTimestamp("lastModified")));
            entity.setappList(rs.getString("app_list"));
            entity.setstorage_id(NGuid.createGuidFromString(rs.getString("storage_id")));
            entity.setvm_snapshot_id(NGuid.createGuidFromString(rs.getString("vm_snapshot_id")));
            entity.setvolume_type(VolumeType.forValue(rs.getInt("volume_type")));
            entity.setvolume_format(VolumeFormat.forValue(rs.getInt("volume_format")));
            entity.setdisk_type(DiskType.forValue(rs.getInt("disk_type")));
            entity.setimage_group_id(Guid.createGuidFromString(rs.getString("image_group_id")));
            entity.setstorage_path(rs.getString("storage_path"));
            entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
            entity.setdisk_interface(DiskInterface.forValue(rs.getInt("disk_interface")));
            entity.setboot(rs.getBoolean("boot"));
            entity.setwipe_after_delete(rs.getBoolean("wipe_after_delete"));
            entity.setpropagate_errors(PropagateErrors.forValue(rs.getInt("propagate_errors")));
            entity.setread_rate(rs.getInt("read_rate"));
            entity.setwrite_rate(rs.getInt("write_rate"));
            return entity;
        }
    };
    return getCallsHandler().executeRead("GetSnapshotByGuid", mapper, parameterSource);
}
#method_after
@Override
public DiskImage getSnapshotById(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("image_guid", id);
    return getCallsHandler().executeRead("GetSnapshotByGuid", diskImageRowMapper, parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<DiskImage> getAllForVm(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_guid", id);
    ParameterizedRowMapper<DiskImage> mapper = new ParameterizedRowMapper<DiskImage>() {

        @Override
        public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
            DiskImage entity = new DiskImage();
            entity.setactive((Boolean) rs.getObject("active"));
            entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
            entity.setactual_size(rs.getLong("actual_size"));
            entity.setdescription(rs.getString("description"));
            entity.setId(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setit_guid(Guid.createGuidFromString(rs.getString("it_guid")));
            entity.setsize(rs.getLong("size"));
            entity.setvm_guid(Guid.createGuidFromString(rs.getString("vm_guid")));
            entity.setParentId(Guid.createGuidFromString(rs.getString("ParentId")));
            entity.setimageStatus(ImageStatus.forValue(rs.getInt("imageStatus")));
            entity.setlastModified(DbFacadeUtils.fromDate(rs.getTimestamp("lastModified")));
            entity.setappList(rs.getString("app_list"));
            entity.setstorage_id(NGuid.createGuidFromString(rs.getString("storage_id")));
            entity.setvm_snapshot_id(NGuid.createGuidFromString(rs.getString("vm_snapshot_id")));
            entity.setimage_group_id(Guid.createGuidFromString(rs.getString("image_group_id")));
            entity.setvolume_type(VolumeType.forValue(rs.getInt("volume_type")));
            entity.setvolume_format(VolumeFormat.forValue(rs.getInt("volume_format")));
            entity.setdisk_type(DiskType.forValue(rs.getInt("disk_type")));
            entity.setstorage_path(rs.getString("storage_path"));
            entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
            entity.setdisk_interface(DiskInterface.forValue(rs.getInt("disk_interface")));
            entity.setboot(rs.getBoolean("boot"));
            entity.setwipe_after_delete(rs.getBoolean("wipe_after_delete"));
            entity.setpropagate_errors(PropagateErrors.forValue(rs.getInt("propagate_errors")));
            entity.setread_rate(rs.getInt("read_rate"));
            entity.setwrite_rate(rs.getInt("write_rate"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetImagesByVmGuid", mapper, parameterSource);
}
#method_after
@Override
public List<DiskImage> getAllForVm(Guid id) {
    return getAllForVm(id, null, false);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<DiskImage> getAllForVm(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_guid", id);
    ParameterizedRowMapper<DiskImage> mapper = new ParameterizedRowMapper<DiskImage>() {

        @Override
        public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
            DiskImage entity = new DiskImage();
            entity.setactive((Boolean) rs.getObject("active"));
            entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
            entity.setactual_size(rs.getLong("actual_size"));
            entity.setdescription(rs.getString("description"));
            entity.setId(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setit_guid(Guid.createGuidFromString(rs.getString("it_guid")));
            entity.setsize(rs.getLong("size"));
            entity.setvm_guid(Guid.createGuidFromString(rs.getString("vm_guid")));
            entity.setParentId(Guid.createGuidFromString(rs.getString("ParentId")));
            entity.setimageStatus(ImageStatus.forValue(rs.getInt("imageStatus")));
            entity.setlastModified(DbFacadeUtils.fromDate(rs.getTimestamp("lastModified")));
            entity.setappList(rs.getString("app_list"));
            entity.setstorage_id(NGuid.createGuidFromString(rs.getString("storage_id")));
            entity.setvm_snapshot_id(NGuid.createGuidFromString(rs.getString("vm_snapshot_id")));
            entity.setimage_group_id(Guid.createGuidFromString(rs.getString("image_group_id")));
            entity.setvolume_type(VolumeType.forValue(rs.getInt("volume_type")));
            entity.setvolume_format(VolumeFormat.forValue(rs.getInt("volume_format")));
            entity.setdisk_type(DiskType.forValue(rs.getInt("disk_type")));
            entity.setstorage_path(rs.getString("storage_path"));
            entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
            entity.setdisk_interface(DiskInterface.forValue(rs.getInt("disk_interface")));
            entity.setboot(rs.getBoolean("boot"));
            entity.setwipe_after_delete(rs.getBoolean("wipe_after_delete"));
            entity.setpropagate_errors(PropagateErrors.forValue(rs.getInt("propagate_errors")));
            entity.setread_rate(rs.getInt("read_rate"));
            entity.setwrite_rate(rs.getInt("write_rate"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetImagesByVmGuid", mapper, parameterSource);
}
#method_after
@Override
public List<DiskImage> getAllForVm(Guid id, Guid userID, boolean isFiltered) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_guid", id).addValue("user_id", userID).addValue("is_filtered", isFiltered);
    return groupImagesStorage(getCallsHandler().executeReadList("GetImagesByVmGuid", fullDiskImageRowMapper, parameterSource));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<DiskImage> getAllSnapshotsForParent(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("parent_guid", id);
    ParameterizedRowMapper<DiskImage> mapper = new ParameterizedRowMapper<DiskImage>() {

        @Override
        public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
            DiskImage entity = new DiskImage();
            entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
            entity.setactual_size(rs.getLong("actual_size"));
            entity.setdescription(rs.getString("description"));
            entity.setId(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setit_guid(Guid.createGuidFromString(rs.getString("it_guid")));
            entity.setsize(rs.getLong("size"));
            entity.setParentId(Guid.createGuidFromString(rs.getString("ParentId")));
            entity.setimageStatus(ImageStatus.forValue(rs.getInt("imageStatus")));
            entity.setlastModified(DbFacadeUtils.fromDate(rs.getTimestamp("lastModified")));
            entity.setappList(rs.getString("app_list"));
            entity.setstorage_id(NGuid.createGuidFromString(rs.getString("storage_id")));
            entity.setvm_snapshot_id(NGuid.createGuidFromString(rs.getString("vm_snapshot_id")));
            entity.setvolume_type(VolumeType.forValue(rs.getInt("volume_type")));
            entity.setvolume_format(VolumeFormat.forValue(rs.getInt("volume_format")));
            entity.setdisk_type(DiskType.forValue(rs.getInt("disk_type")));
            entity.setimage_group_id(Guid.createGuidFromString(rs.getString("image_group_id")));
            entity.setstorage_path(rs.getString("storage_path"));
            entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
            entity.setdisk_interface(DiskInterface.forValue(rs.getInt("disk_interface")));
            entity.setboot(rs.getBoolean("boot"));
            entity.setwipe_after_delete(rs.getBoolean("wipe_after_delete"));
            entity.setpropagate_errors(PropagateErrors.forValue(rs.getInt("propagate_errors")));
            entity.setread_rate(rs.getInt("read_rate"));
            entity.setwrite_rate(rs.getInt("write_rate"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetSnapshotByParentGuid", mapper, parameterSource);
}
#method_after
@Override
public List<DiskImage> getAllSnapshotsForParent(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("parent_guid", id);
    return getCallsHandler().executeReadList("GetSnapshotByParentGuid", diskImageRowMapper, parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<DiskImage> getAllSnapshotsForStorageDomain(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("storage_domain_id", id);
    ParameterizedRowMapper<DiskImage> mapper = new ParameterizedRowMapper<DiskImage>() {

        @Override
        public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
            DiskImage entity = new DiskImage();
            entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
            entity.setactual_size(rs.getLong("actual_size"));
            entity.setdescription(rs.getString("description"));
            entity.setId(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setit_guid(Guid.createGuidFromString(rs.getString("it_guid")));
            entity.setsize(rs.getLong("size"));
            entity.setParentId(Guid.createGuidFromString(rs.getString("ParentId")));
            entity.setimageStatus(ImageStatus.forValue(rs.getInt("imageStatus")));
            entity.setlastModified(DbFacadeUtils.fromDate(rs.getTimestamp("lastModified")));
            entity.setappList(rs.getString("app_list"));
            entity.setstorage_id(NGuid.createGuidFromString(rs.getString("storage_id")));
            entity.setvm_snapshot_id(NGuid.createGuidFromString(rs.getString("vm_snapshot_id")));
            entity.setvolume_type(VolumeType.forValue(rs.getInt("volume_type")));
            entity.setvolume_format(VolumeFormat.forValue(rs.getInt("volume_format")));
            entity.setdisk_type(DiskType.forValue(rs.getInt("disk_type")));
            entity.setimage_group_id(Guid.createGuidFromString(rs.getString("image_group_id")));
            entity.setstorage_path(rs.getString("storage_path"));
            entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
            entity.setdisk_interface(DiskInterface.forValue(rs.getInt("disk_interface")));
            entity.setboot(rs.getBoolean("boot"));
            entity.setwipe_after_delete(rs.getBoolean("wipe_after_delete"));
            entity.setpropagate_errors(PropagateErrors.forValue(rs.getInt("propagate_errors")));
            entity.setread_rate(rs.getInt("read_rate"));
            entity.setwrite_rate(rs.getInt("write_rate"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetSnapshotsByStorageDomainId", mapper, parameterSource);
}
#method_after
@Override
public List<DiskImage> getAllSnapshotsForStorageDomain(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("storage_domain_id", id);
    return getCallsHandler().executeReadList("GetSnapshotsByStorageDomainId", diskImageRowMapper, parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<DiskImage> getAllSnapshotsForVmSnapshot(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_snapshot_id", id);
    ParameterizedRowMapper<DiskImage> mapper = new ParameterizedRowMapper<DiskImage>() {

        @Override
        public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
            DiskImage entity = new DiskImage();
            entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
            entity.setactual_size(rs.getLong("actual_size"));
            entity.setdescription(rs.getString("description"));
            entity.setId(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setit_guid(Guid.createGuidFromString(rs.getString("it_guid")));
            entity.setsize(rs.getLong("size"));
            entity.setParentId(Guid.createGuidFromString(rs.getString("ParentId")));
            entity.setimageStatus(ImageStatus.forValue(rs.getInt("imageStatus")));
            entity.setlastModified(DbFacadeUtils.fromDate(rs.getTimestamp("lastModified")));
            entity.setappList(rs.getString("app_list"));
            entity.setstorage_id(NGuid.createGuidFromString(rs.getString("storage_id")));
            entity.setvm_snapshot_id(NGuid.createGuidFromString(rs.getString("vm_snapshot_id")));
            entity.setvolume_type(VolumeType.forValue(rs.getInt("volume_type")));
            entity.setvolume_format(VolumeFormat.forValue(rs.getInt("volume_format")));
            entity.setdisk_type(DiskType.forValue(rs.getInt("disk_type")));
            entity.setimage_group_id(Guid.createGuidFromString(rs.getString("image_group_id")));
            entity.setstorage_path(rs.getString("storage_path"));
            entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
            entity.setdisk_interface(DiskInterface.forValue(rs.getInt("disk_interface")));
            entity.setboot(rs.getBoolean("boot"));
            entity.setwipe_after_delete(rs.getBoolean("wipe_after_delete"));
            entity.setpropagate_errors(PropagateErrors.forValue(rs.getInt("propagate_errors")));
            entity.setread_rate(rs.getInt("read_rate"));
            entity.setwrite_rate(rs.getInt("write_rate"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetSnapshotsByVmSnapshotId", mapper, parameterSource);
}
#method_after
@Override
public List<DiskImage> getAllSnapshotsForVmSnapshot(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_snapshot_id", id);
    return getCallsHandler().executeReadList("GetSnapshotsByVmSnapshotId", diskImageRowMapper, parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<DiskImage> getAllSnapshotsForImageGroup(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("image_group_id", id);
    ParameterizedRowMapper<DiskImage> mapper = new ParameterizedRowMapper<DiskImage>() {

        @Override
        public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
            DiskImage entity = new DiskImage();
            entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
            entity.setactual_size(rs.getLong("actual_size"));
            entity.setdescription(rs.getString("description"));
            entity.setId(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setit_guid(Guid.createGuidFromString(rs.getString("it_guid")));
            entity.setsize(rs.getLong("size"));
            entity.setParentId(Guid.createGuidFromString(rs.getString("ParentId")));
            entity.setimageStatus(ImageStatus.forValue(rs.getInt("imageStatus")));
            entity.setlastModified(DbFacadeUtils.fromDate(rs.getTimestamp("lastModified")));
            entity.setappList(rs.getString("app_list"));
            entity.setstorage_id(NGuid.createGuidFromString(rs.getString("storage_id")));
            entity.setvm_snapshot_id(NGuid.createGuidFromString(rs.getString("vm_snapshot_id")));
            entity.setvolume_type(VolumeType.forValue(rs.getInt("volume_type")));
            entity.setvolume_format(VolumeFormat.forValue(rs.getInt("volume_format")));
            entity.setdisk_type(DiskType.forValue(rs.getInt("disk_type")));
            entity.setimage_group_id(Guid.createGuidFromString(rs.getString("image_group_id")));
            entity.setstorage_path(rs.getString("storage_path"));
            entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
            entity.setdisk_interface(DiskInterface.forValue(rs.getInt("disk_interface")));
            entity.setboot(rs.getBoolean("boot"));
            entity.setwipe_after_delete(rs.getBoolean("wipe_after_delete"));
            entity.setpropagate_errors(PropagateErrors.forValue(rs.getInt("propagate_errors")));
            entity.setread_rate(rs.getInt("read_rate"));
            entity.setwrite_rate(rs.getInt("write_rate"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetSnapshotsByImageGroupId", mapper, parameterSource);
}
#method_after
@Override
public List<DiskImage> getAllSnapshotsForImageGroup(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("image_group_id", id);
    return getCallsHandler().executeReadList("GetSnapshotsByImageGroupId", diskImageRowMapper, parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<DiskImage> getAll() {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource();
    ParameterizedRowMapper<DiskImage> mapper = new ParameterizedRowMapper<DiskImage>() {

        @Override
        public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
            DiskImage entity = new DiskImage();
            entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
            entity.setactual_size(rs.getLong("actual_size"));
            entity.setdescription(rs.getString("description"));
            entity.setId(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setit_guid(Guid.createGuidFromString(rs.getString("it_guid")));
            entity.setsize(rs.getLong("size"));
            entity.setParentId(Guid.createGuidFromString(rs.getString("ParentId")));
            entity.setimageStatus(ImageStatus.forValue(rs.getInt("imageStatus")));
            entity.setlastModified(DbFacadeUtils.fromDate(rs.getTimestamp("lastModified")));
            entity.setappList(rs.getString("app_list"));
            entity.setstorage_id(NGuid.createGuidFromString(rs.getString("storage_id")));
            entity.setvm_snapshot_id(NGuid.createGuidFromString(rs.getString("vm_snapshot_id")));
            entity.setvolume_type(VolumeType.forValue(rs.getInt("volume_type")));
            entity.setvolume_format(VolumeFormat.forValue(rs.getInt("volume_format")));
            entity.setdisk_type(DiskType.forValue(rs.getInt("disk_type")));
            entity.setimage_group_id(Guid.createGuidFromString(rs.getString("image_group_id")));
            entity.setstorage_path(rs.getString("storage_path"));
            entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
            entity.setdisk_interface(DiskInterface.forValue(rs.getInt("disk_interface")));
            entity.setboot(rs.getBoolean("boot"));
            entity.setwipe_after_delete(rs.getBoolean("wipe_after_delete"));
            entity.setpropagate_errors(PropagateErrors.forValue(rs.getInt("propagate_errors")));
            entity.setread_rate(rs.getInt("read_rate"));
            entity.setwrite_rate(rs.getInt("write_rate"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetAllFromImages", mapper, parameterSource);
}
#method_after
@Override
public List<DiskImage> getAll() {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource();
    return groupImagesStorage(getCallsHandler().executeReadList("GetAllFromImages", diskImageRowMapper, parameterSource));
}
#end_block

#method_before
@Override
public void save(DiskImage image) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("creation_date", image.getcreation_date()).addValue("description", image.getdescription()).addValue("image_guid", image.getId()).addValue("internal_drive_mapping", image.getinternal_drive_mapping()).addValue("it_guid", image.getit_guid()).addValue("size", image.getsize()).addValue("ParentId", image.getParentId()).addValue("imageStatus", image.getimageStatus()).addValue("lastModified", image.getlastModified()).addValue("app_list", image.getappList()).addValue("storage_id", image.getstorage_id()).addValue("vm_snapshot_id", image.getvm_snapshot_id()).addValue("volume_type", image.getvolume_type()).addValue("volume_format", image.getvolume_format()).addValue("disk_type", image.getdisk_type()).addValue("image_group_id", image.getimage_group_id()).addValue("disk_interface", image.getdisk_interface()).addValue("boot", image.getboot()).addValue("wipe_after_delete", image.getwipe_after_delete()).addValue("propagate_errors", image.getpropagate_errors());
    getCallsHandler().executeModification("InsertImage", parameterSource);
}
#method_after
@Override
public void save(DiskImage image) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("creation_date", image.getcreation_date()).addValue("description", image.getdescription()).addValue("image_guid", image.getId()).addValue("internal_drive_mapping", image.getinternal_drive_mapping()).addValue("it_guid", image.getit_guid()).addValue("size", image.getsize()).addValue("ParentId", image.getParentId()).addValue("imageStatus", image.getimageStatus()).addValue("lastModified", image.getlastModified()).addValue("app_list", image.getappList()).addValue("vm_snapshot_id", image.getvm_snapshot_id()).addValue("volume_type", image.getvolume_type()).addValue("volume_format", image.getvolume_format()).addValue("disk_type", image.getdisk_type()).addValue("image_group_id", image.getimage_group_id()).addValue("disk_interface", image.getdisk_interface()).addValue("boot", image.getboot()).addValue("wipe_after_delete", image.getwipe_after_delete()).addValue("propagate_errors", image.getpropagate_errors()).addValue("quota_id", image.getQuotaId());
    getCallsHandler().executeModification("InsertImage", parameterSource);
}
#end_block

#method_before
@Override
public void update(DiskImage image) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("creation_date", image.getcreation_date()).addValue("description", image.getdescription()).addValue("image_guid", image.getId()).addValue("internal_drive_mapping", image.getinternal_drive_mapping()).addValue("it_guid", image.getit_guid()).addValue("size", image.getsize()).addValue("ParentId", image.getParentId()).addValue("imageStatus", image.getimageStatus()).addValue("lastModified", image.getlastModified()).addValue("app_list", image.getappList()).addValue("storage_id", image.getstorage_id()).addValue("vm_snapshot_id", image.getvm_snapshot_id()).addValue("volume_type", image.getvolume_type()).addValue("volume_format", image.getvolume_format()).addValue("disk_type", image.getdisk_type()).addValue("image_group_id", image.getimage_group_id()).addValue("disk_interface", image.getdisk_interface()).addValue("boot", image.getboot()).addValue("wipe_after_delete", image.getwipe_after_delete()).addValue("propagate_errors", image.getpropagate_errors());
    getCallsHandler().executeModification("UpdateImage", parameterSource);
}
#method_after
@Override
public void update(DiskImage image) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("creation_date", image.getcreation_date()).addValue("description", image.getdescription()).addValue("image_guid", image.getId()).addValue("internal_drive_mapping", image.getinternal_drive_mapping()).addValue("it_guid", image.getit_guid()).addValue("size", image.getsize()).addValue("ParentId", image.getParentId()).addValue("imageStatus", image.getimageStatus()).addValue("lastModified", image.getlastModified()).addValue("app_list", image.getappList()).addValue("vm_snapshot_id", image.getvm_snapshot_id()).addValue("volume_type", image.getvolume_type()).addValue("volume_format", image.getvolume_format()).addValue("disk_type", image.getdisk_type()).addValue("image_group_id", image.getimage_group_id()).addValue("disk_interface", image.getdisk_interface()).addValue("boot", image.getboot()).addValue("wipe_after_delete", image.getwipe_after_delete()).addValue("propagate_errors", image.getpropagate_errors()).addValue("quota_id", image.getQuotaId());
    getCallsHandler().executeModification("UpdateImage", parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<stateless_vm_image_map> getAllStatelessVmImageMapsForVm(Guid vmId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_guid", vmId);
    ParameterizedRowMapper<stateless_vm_image_map> mapper = new ParameterizedRowMapper<stateless_vm_image_map>() {

        @Override
        public stateless_vm_image_map mapRow(ResultSet rs, int rowNum) throws SQLException {
            stateless_vm_image_map entity = new stateless_vm_image_map();
            entity.setimage_guid(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setvm_guid(Guid.createGuidFromString(rs.getString("vm_guid")));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("Getstateless_vm_image_mapByvm_guid", mapper, parameterSource);
}
#method_after
@Override
public List<stateless_vm_image_map> getAllStatelessVmImageMapsForVm(Guid vmId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_guid", vmId);
    ParameterizedRowMapper<stateless_vm_image_map> mapper = new ParameterizedRowMapper<stateless_vm_image_map>() {

        @Override
        public stateless_vm_image_map mapRow(ResultSet rs, int rowNum) throws SQLException {
            stateless_vm_image_map entity = new stateless_vm_image_map();
            entity.setimage_guid(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setvm_guid(Guid.createGuidFromString(rs.getString("vm_guid")));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("Getstateless_vm_image_mapByvm_guid", mapper, parameterSource);
}
#end_block

#method_before
@Override
public DiskImage getAncestor(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("image_guid", id);
    ParameterizedRowMapper<DiskImage> mapper = new ParameterizedRowMapper<DiskImage>() {

        @Override
        public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
            DiskImage entity = new DiskImage();
            entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
            entity.setdescription(rs.getString("description"));
            entity.setId(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setit_guid(Guid.createGuidFromString(rs.getString("it_guid")));
            entity.setsize(rs.getLong("size"));
            entity.setParentId(Guid.createGuidFromString(rs.getString("ParentId")));
            entity.setimageStatus(ImageStatus.forValue(rs.getInt("imageStatus")));
            entity.setlastModified(DbFacadeUtils.fromDate(rs.getTimestamp("lastModified")));
            entity.setappList(rs.getString("app_list"));
            entity.setstorage_id(NGuid.createGuidFromString(rs.getString("storage_id")));
            entity.setvm_snapshot_id(NGuid.createGuidFromString(rs.getString("vm_snapshot_id")));
            entity.setvolume_type(VolumeType.forValue(rs.getInt("volume_type")));
            entity.setvolume_format(VolumeFormat.forValue(rs.getInt("volume_format")));
            entity.setdisk_type(DiskType.forValue(rs.getInt("disk_type")));
            entity.setimage_group_id(Guid.createGuidFromString(rs.getString("image_group_id")));
            entity.setdisk_interface(DiskInterface.forValue(rs.getInt("disk_interface")));
            entity.setboot(rs.getBoolean("boot"));
            entity.setwipe_after_delete(rs.getBoolean("wipe_after_delete"));
            entity.setpropagate_errors(PropagateErrors.forValue(rs.getInt("propagate_errors")));
            return entity;
        }
    };
    return getCallsHandler().executeRead("GetAncestralImageByImageGuid", mapper, parameterSource);
}
#method_after
@Override
public DiskImage getAncestor(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("image_guid", id);
    return getCallsHandler().executeRead("GetAncestralImageByImageGuid", diskImageRowMapper, parameterSource);
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    diskImageDynamicDao = prepareDAO(dbFacade.getDiskImageDynamicDAO());
    diskDao = prepareDAO(dbFacade.getDiskDao());
    existingStatelessMapping = dao.getStatelessVmImageMapForImageId(EXISTING_IMAGE_ID);
    newImage = new DiskImage();
    newImage.setactive(true);
    newImage.setvm_guid(EXISTING_VM_ID);
    newImage.setit_guid(EXISTING_IMAGE_DISK_TEMPLATE);
    newImage.setId(Guid.NewGuid());
    newImage.setinternal_drive_mapping("4");
    newImage.setvolume_format(VolumeFormat.COW);
    newImage.setvolume_type(VolumeType.Sparse);
    newImage.setdisk_interface(DiskInterface.IDE);
    newImage.setdisk_type(DiskType.Data);
    newImage.setimage_group_id(Guid.NewGuid());
    newImageVmPoolMapping = new stateless_vm_image_map(FREE_IMAGE_ID, "z", FREE_VM_ID);
    existingStatelessDiskImageMap = dao.getStatelessVmImageMapForImageId(existingEntity.getId());
    newStatelessVmImageMap = new stateless_vm_image_map(FREE_IMAGE_ID, "q", FREE_VM_ID);
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    diskImageDynamicDao = prepareDAO(dbFacade.getDiskImageDynamicDAO());
    diskDao = prepareDAO(dbFacade.getDiskDao());
    existingStatelessMapping = dao.getStatelessVmImageMapForImageId(EXISTING_IMAGE_ID);
    newImage = new DiskImage();
    newImage.setactive(true);
    newImage.setvm_guid(FixturesTool.VM_RHEL5_POOL_57);
    newImage.setit_guid(EXISTING_IMAGE_DISK_TEMPLATE);
    newImage.setId(Guid.NewGuid());
    newImage.setinternal_drive_mapping("4");
    newImage.setvolume_format(VolumeFormat.COW);
    newImage.setvolume_type(VolumeType.Sparse);
    newImage.setdisk_interface(DiskInterface.IDE);
    newImage.setdisk_type(DiskType.Data);
    newImage.setimage_group_id(Guid.NewGuid());
    newImage.setQuotaId(Guid.NewGuid());
    newImage.setstorage_ids(new ArrayList<Guid>(Arrays.asList(Guid.Empty)));
    newImageVmPoolMapping = new stateless_vm_image_map(FREE_IMAGE_ID, "z", FREE_VM_ID);
    existingStatelessDiskImageMap = dao.getStatelessVmImageMapForImageId(existingEntity.getId());
    newStatelessVmImageMap = new stateless_vm_image_map(FREE_IMAGE_ID, "q", FREE_VM_ID);
    existingTemplate = dao.get(EXISTING_IMAGE_DISK_TEMPLATE);
}
#end_block

#method_before
@Test
@Override
public void testSave() {
    dao.save(newImage);
    // TODO this call is only necessary when we have a DbFacade implementation
    if (dao instanceof BaseDAODbFacade) {
        dbFacade.getImageVmMapDAO().save(new image_vm_map(true, newImage.getId(), EXISTING_VM_ID));
    }
    DiskImageDynamic dynamic = new DiskImageDynamic();
    dynamic.setId(newImage.getId());
    diskDao.save(newImage.getDisk());
    diskImageDynamicDao.save(dynamic);
    DiskImageDynamic dynamicFromDB = diskImageDynamicDao.get(dynamic.getId());
    assertNotNull(dynamicFromDB);
    DiskImage result = dao.get(newImage.getId());
    assertNotNull(result);
    assertEquals(newImage, result);
    image_vm_map mapping = dbFacade.getImageVmMapDAO().getByImageId(result.getId());
    assertNotNull(mapping);
    assertTrue(mapping.getactive());
    assertEquals(newImage.getId(), mapping.getimage_id());
    assertEquals(newImage.getvm_guid(), mapping.getvm_id());
}
#method_after
@Test
@Override
public void testSave() {
    dao.save(newImage);
    // TODO this call is only necessary when we have a DbFacade implementation
    if (dao instanceof BaseDAODbFacade) {
        dbFacade.getImageVmMapDAO().save(new image_vm_map(true, newImage.getId(), FixturesTool.VM_RHEL5_POOL_57));
    }
    DiskImageDynamic dynamic = new DiskImageDynamic();
    dynamic.setId(newImage.getId());
    diskDao.save(newImage.getDisk());
    diskImageDynamicDao.save(dynamic);
    DiskImageDynamic dynamicFromDB = diskImageDynamicDao.get(dynamic.getId());
    assertNotNull(dynamicFromDB);
    DiskImage result = dao.get(newImage.getId());
    assertNotNull(result);
    assertEquals(newImage, result);
    image_vm_map mapping = dbFacade.getImageVmMapDAO().getByImageId(result.getId());
    assertNotNull(mapping);
    assertTrue(mapping.getactive());
    assertEquals(newImage.getId(), mapping.getimage_id());
    assertEquals(newImage.getvm_guid(), mapping.getvm_id());
}
#end_block

#method_before
@Test
public void testGetStatelessImageMapByVmId() {
    List<stateless_vm_image_map> result = dao.getAllStatelessVmImageMapsForVm(EXISTING_VM_ID);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (stateless_vm_image_map map : result) {
        assertEquals(EXISTING_VM_ID, map.getvm_guid());
    }
}
#method_after
@Test
public void testGetStatelessImageMapByVmId() {
    List<stateless_vm_image_map> result = dao.getAllStatelessVmImageMapsForVm(FixturesTool.VM_RHEL5_POOL_57);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (stateless_vm_image_map map : result) {
        assertEquals(FixturesTool.VM_RHEL5_POOL_57, map.getvm_guid());
    }
}
#end_block

#method_before
@Test
public void testGetAllStatelessDiskImagesForVm() {
    List<stateless_vm_image_map> result = dao.getAllStatelessVmImageMapsForVm(EXISTING_VM_ID);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (stateless_vm_image_map mapping : result) {
        assertEquals(EXISTING_VM_ID, mapping.getvm_guid());
    }
}
#method_after
@Test
public void testGetAllStatelessDiskImagesForVm() {
    List<stateless_vm_image_map> result = dao.getAllStatelessVmImageMapsForVm(FixturesTool.VM_RHEL5_POOL_57);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (stateless_vm_image_map mapping : result) {
        assertEquals(FixturesTool.VM_RHEL5_POOL_57, mapping.getvm_guid());
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // if (CanAddVmToPool(VmId,null,null))
    // {
    DbFacade.getInstance().getVmPoolDAO().addVmToPool(new vm_pool_map(getVmId(), getVmPoolId()));
    // VM vm = DbFacade.Instance.GetvmsBy_vm_guid(VmId);
    VmHandler.updateDisksFromDb(getVm());
    // todo: omer - save only vm_snapshot_id instead all vm images
    for (DiskImage image : getVm()) {
        DbFacade.getInstance().getDiskImageDAO().addStatelessVmImageMap(new stateless_vm_image_map(image.getId(), image.getinternal_drive_mapping(), getVmId()));
    }
    setSucceeded(true);
// }
}
#method_after
@Override
protected void executeCommand() {
    DbFacade.getInstance().getVmPoolDAO().addVmToPool(new vm_pool_map(getVmId(), getVmPoolId()));
    setSucceeded(true);
}
#end_block

#method_before
protected void DetachAllVmsFromUser() {
    List<VM> vms = DbFacade.getInstance().getVmDAO().getAllForUser(getAdUserId());
    for (VM vm : vms) {
        if (getVmPoolId() != null && getVmPoolId().equals(vm.getVmPoolId())) {
            permissions perm = DbFacade.getInstance().getPermissionDAO().getForRoleAndAdElementAndObject(PredefinedRoles.ENGINE_USER.getId(), getAdUserId(), vm.getvm_guid());
            if (perm != null) {
                DbFacade.getInstance().getPermissionDAO().remove(perm.getId());
                RestoreVmFromBaseSnapshot(vm);
            }
        }
    }
}
#method_after
protected void DetachAllVmsFromUser() {
    List<VM> vms = DbFacade.getInstance().getVmDAO().getAllForUser(getAdUserId());
    for (VM vm : vms) {
        if (getVmPoolId() != null && getVmPoolId().equals(vm.getVmPoolId())) {
            permissions perm = DbFacade.getInstance().getPermissionDAO().getForRoleAndAdElementAndObject(PredefinedRoles.ENGINE_USER.getId(), getAdUserId(), vm.getId());
            if (perm != null) {
                DbFacade.getInstance().getPermissionDAO().remove(perm.getId());
                RestoreVmFromBaseSnapshot(vm);
            }
        }
    }
}
#end_block

#method_before
private void RestoreVmFromBaseSnapshot(VM vm) {
    List<stateless_vm_image_map> list = DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(vm.getvm_guid());
    // java.util.ArrayList<DiskImage> imagesList = null; // LINQ 32934
    // list.Select(a =>
    // DbFacade.Instance.GetSnapshotById(a.image_guid)).ToList();
    List<DiskImage> imagesList = LinqUtils.foreach(list, new Function<stateless_vm_image_map, DiskImage>() {

        @Override
        public DiskImage eval(stateless_vm_image_map a) {
            return DbFacade.getInstance().getDiskImageDAO().getSnapshotById(a.getimage_guid());
        }
    });
    if (imagesList.size() > 0) {
        /**
         * restore all snapshots
         */
        RestoreAllSnapshotsParameters tempVar = new RestoreAllSnapshotsParameters(vm.getvm_guid(), Guid.Empty);
        tempVar.setShouldBeLogged(false);
        tempVar.setImagesList(imagesList);
        Backend.getInstance().runInternalAction(VdcActionType.RestoreAllSnapshots, tempVar);
    }
}
#method_after
private void RestoreVmFromBaseSnapshot(VM vm) {
    List<stateless_vm_image_map> list = DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(vm.getId());
    // java.util.ArrayList<DiskImage> imagesList = null; // LINQ 32934
    // list.Select(a =>
    // DbFacade.Instance.GetSnapshotById(a.image_guid)).ToList();
    List<DiskImage> imagesList = LinqUtils.foreach(list, new Function<stateless_vm_image_map, DiskImage>() {

        @Override
        public DiskImage eval(stateless_vm_image_map a) {
            return DbFacade.getInstance().getDiskImageDAO().getSnapshotById(a.getimage_guid());
        }
    });
    if (imagesList.size() > 0) {
        /**
         * restore all snapshots
         */
        RestoreAllSnapshotsParameters tempVar = new RestoreAllSnapshotsParameters(vm.getId(), Guid.Empty);
        tempVar.setShouldBeLogged(false);
        tempVar.setImagesList(imagesList);
        Backend.getInstance().runInternalAction(VdcActionType.RestoreAllSnapshots, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    }
}
#end_block

#method_before
public static boolean CanRemoveVmFromPool(Guid vmId, java.util.ArrayList<String> messages) {
    boolean returnValue = false;
    // Check if the vm is in a pool.
    if (DbFacade.getInstance().getVmPoolDAO().getVmPoolMapByVmGuid(vmId) == null) {
        // Check if the vm is in a time leased pool.
        if (DbFacade.getInstance().getVmPoolDAO().getTimeLeasedVmPoolMapByIdForVmPool(vmId, Guid.Empty) == null) {
            messages.add(VdcBllMessages.VM_POOL_CANNOT_DETACH_VM_NOT_ATTACHED_TO_POOL.toString());
            returnValue = true;
        }
    } else {
        returnValue = RemoveVmCommand.IsVmRunning(vmId);
        if (returnValue) {
            messages.add(VdcBllMessages.VM_POOL_CANNOT_REMOVE_RUNNING_VM_FROM_POOL.toString());
        }
    }
    return !returnValue;
}
#method_after
public static boolean CanRemoveVmFromPool(Guid vmId, java.util.ArrayList<String> messages) {
    boolean returnValue = true;
    // Check if the vm is in a pool.
    if (DbFacade.getInstance().getVmPoolDAO().getVmPoolMapByVmGuid(vmId) == null) {
        messages.add(VdcBllMessages.VM_POOL_CANNOT_DETACH_VM_NOT_ATTACHED_TO_POOL.toString());
        returnValue = false;
    }
    if (returnValue) {
        if (RemoveVmCommand.IsVmRunning(vmId)) {
            messages.add(VdcBllMessages.VM_POOL_CANNOT_REMOVE_RUNNING_VM_FROM_POOL.toString());
            returnValue = false;
        }
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVmPoolId() != null) {
        List<stateless_vm_image_map> list = DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVmId());
        for (stateless_vm_image_map imageMap : list) {
            DbFacade.getInstance().getDiskImageDAO().removeStatelessVmImageMap(imageMap.getimage_guid());
        }
        DbFacade.getInstance().getVmPoolDAO().removeVmFromVmPool(getVmId());
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVmPoolId() != null) {
        DbFacade.getInstance().getVmPoolDAO().removeVmFromVmPool(getVmId());
        setSucceeded(true);
    }
}
#end_block

#method_before
public static Guid GetVmToAttach(NGuid poolId) {
    Guid vmGuid = Guid.Empty;
    vmGuid = getPrestartedVmToAttach(poolId);
    if (vmGuid == null || vmGuid.equals(Guid.Empty)) {
        vmGuid = getNonPrestartedVmToAttach(poolId);
    }
    return vmGuid;
}
#method_after
public static Guid GetVmToAttach(NGuid poolId) {
    Guid vmGuid = Guid.Empty;
    vmGuid = getPrestartedVmToAttach(poolId);
    if (vmGuid == null || Guid.Empty.equals(vmGuid)) {
        vmGuid = getNonPrestartedVmToAttach(poolId);
    }
    return vmGuid;
}
#end_block

#method_before
protected static Guid getNonPrestartedVmToAttach(NGuid poolId) {
    List<vm_pool_map> vmPools = DbFacade.getInstance().getVmPoolDAO().getVmPoolsMapByVmPoolId(poolId);
    if (vmPools != null) {
        for (vm_pool_map map : vmPools) {
            if (CanAttacheVmToUser(map.getvm_guid())) {
                return map.getvm_guid();
            }
        }
    }
    return Guid.Empty;
}
#method_after
protected static Guid getNonPrestartedVmToAttach(NGuid vmPoolId) {
    List<vm_pool_map> vmPoolMaps = DbFacade.getInstance().getVmPoolDAO().getVmMapsInVmPoolByVmPoolIdAndStatus(vmPoolId, VMStatus.Down);
    if (vmPoolMaps != null) {
        for (vm_pool_map map : vmPoolMaps) {
            if (CanAttachNonPrestartedVmToUser(map.getvm_guid())) {
                return map.getvm_guid();
            }
        }
    }
    return Guid.Empty;
}
#end_block

#method_before
protected static Guid getPrestartedVmToAttach(NGuid poolId) {
    // TODO: implement prestarted Vm logic
    return Guid.Empty;
}
#method_after
protected static Guid getPrestartedVmToAttach(NGuid vmPoolId) {
    List<vm_pool_map> vmPoolMaps = DbFacade.getInstance().getVmPoolDAO().getVmMapsInVmPoolByVmPoolIdAndStatus(vmPoolId, VMStatus.Up);
    if (vmPoolMaps != null) {
        for (vm_pool_map map : vmPoolMaps) {
            if (CanAttachPrestartedVmToUser(map.getvm_guid())) {
                return map.getvm_guid();
            }
        }
    }
    return Guid.Empty;
}
#end_block

#method_before
protected static boolean IsVmFree(Guid vmId, java.util.ArrayList<String> messages) {
    boolean returnValue;
    // check that there isn't another user already attached to this VM:
    if (DbFacade.getInstance().getDbUserDAO().getAllForVm(vmId).size() > 0) {
        returnValue = false;
        if (messages != null) {
            messages.add(VdcBllMessages.VM_POOL_CANNOT_ADD_VM_WITH_USERS_ATTACHED_TO_POOL.toString());
        }
    } else // check that vm can be run:
    if (!CanRunPoolVm(vmId, messages)) {
        returnValue = false;
    } else // check vm images:
    {
        List<DiskImage> vmImages = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vmId);
        Guid storageDomainId = vmImages.size() > 0 ? vmImages.get(0).getstorage_id().getValue() : Guid.Empty;
        returnValue = ImagesHandler.PerformImagesChecks(vmId, messages, DbFacade.getInstance().getVmDAO().getById(vmId).getstorage_pool_id(), storageDomainId, false, true, false, false, true, false, !storageDomainId.equals(Guid.Empty));
        if (!returnValue) {
            if (messages != null) {
                messages.add(VdcBllMessages.VAR__TYPE__DESKTOP_POOL.toString());
                messages.add(VdcBllMessages.VAR__ACTION__ATTACHE_DESKTOP_TO.toString());
            }
        }
    }
    return returnValue;
}
#method_after
protected static boolean IsVmFree(Guid vmId, java.util.ArrayList<String> messages) {
    boolean returnValue;
    // check that there isn't another user already attached to this VM:
    if (vmAssignedToUser(vmId, messages)) {
        returnValue = false;
    } else // check that vm can be run:
    if (!CanRunPoolVm(vmId, messages)) {
        returnValue = false;
    } else // check vm images:
    {
        ValidationResult vmDuringSnapshotResult = new SnapshotsValidator().vmNotDuringSnapshot(vmId);
        if (!vmDuringSnapshotResult.isValid()) {
            messages.add(vmDuringSnapshotResult.getMessage().name());
            returnValue = false;
        } else {
            List<DiskImage> vmImages = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vmId);
            Guid storageDomainId = vmImages.size() > 0 ? vmImages.get(0).getstorage_ids().get(0) : Guid.Empty;
            returnValue = ImagesHandler.PerformImagesChecks(vmId, messages, DbFacade.getInstance().getVmDAO().getById(vmId).getstorage_pool_id(), storageDomainId, false, true, false, false, true, false, !storageDomainId.equals(Guid.Empty));
        }
        if (!returnValue) {
            if (messages != null) {
                messages.add(VdcBllMessages.VAR__TYPE__DESKTOP_POOL.toString());
                messages.add(VdcBllMessages.VAR__ACTION__ATTACHE_DESKTOP_TO.toString());
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
protected static boolean CanRunPoolVm(Guid vmId, java.util.ArrayList<String> messages) {
    VM vm = DbFacade.getInstance().getVmDAO().getById(vmId);
    RunVmParams tempVar = new RunVmParams(vmId);
    tempVar.setUseVnc(vm.getvm_os().isLinux() || vm.getvm_type() == VmType.Server);
    RunVmParams runVmParams = tempVar;
    VdsSelector vdsSelector = new VdsSelector(vm, ((runVmParams.getDestinationVdsId()) != null) ? runVmParams.getDestinationVdsId() : vm.getdedicated_vm_for_vds(), true);
    return RunVmCommand.CanRunVm(vm, messages, runVmParams, vdsSelector);
}
#method_after
protected static boolean CanRunPoolVm(Guid vmId, java.util.ArrayList<String> messages) {
    VM vm = DbFacade.getInstance().getVmDAO().getById(vmId);
    RunVmParams tempVar = new RunVmParams(vmId);
    tempVar.setUseVnc(vm.getvm_os().isLinux() || vm.getvm_type() == VmType.Server);
    RunVmParams runVmParams = tempVar;
    VdsSelector vdsSelector = new VdsSelector(vm, ((runVmParams.getDestinationVdsId()) != null) ? runVmParams.getDestinationVdsId() : vm.getdedicated_vm_for_vds(), true);
    return RunVmCommand.CanRunVm(vm, messages, runVmParams, vdsSelector, new SnapshotsValidator());
}
#end_block

#method_before
@Override
public Map<Guid, VdcObjectType> getPermissionCheckSubjects() {
    return Collections.singletonMap(getVmPoolId() == null ? null : getVmPoolId().getValue(), VdcObjectType.VmPool);
}
#method_after
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(getVmPoolId() == null ? null : getVmPoolId().getValue(), VdcObjectType.VmPool, getActionType().getActionGroup()));
    return permissionList;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    synchronized (_lockObject) {
        // no available VMs:
        if (GetVmToAttach(getParameters().getVmPoolId()).equals(Guid.Empty)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_AVAILABLE_POOL_VMS);
            returnValue = false;
        }
    }
    // check user isn't already attached to vm from this pool
    if (returnValue) {
        List<VM> vmsForUser = DbFacade.getInstance().getVmDAO().getAllForUser(getAdUserId());
        for (VM vm : vmsForUser) {
            if (vm.getVmPoolId() != null && getVmPoolId().equals(vm.getVmPoolId())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_USER_ATTACHED_TO_POOL);
                returnValue = false;
            }
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ALLOCATE_AND_RUN);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_FROM_VM_POOL);
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    synchronized (_lockObject) {
        // no available VMs:
        if (Guid.Empty.equals(GetVmToAttach(getParameters().getVmPoolId()))) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_AVAILABLE_POOL_VMS);
            returnValue = false;
        }
    }
    // check user isn't already attached to vm from this pool
    if (returnValue) {
        List<VM> vmsForUser = DbFacade.getInstance().getVmDAO().getAllForUser(getAdUserId());
        for (VM vm : vmsForUser) {
            if (vm.getVmPoolId() != null && getVmPoolId().equals(vm.getVmPoolId())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_USER_ATTACHED_TO_POOL);
                returnValue = false;
            }
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ALLOCATE_AND_RUN);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_FROM_VM_POOL);
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getParameters().setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
    // we are setting 'Vm' since VmId is overriden and 'Vm' is null
    // (since 'Vm' is dependant on 'mVmId', which is not set here).
    setVm(DbFacade.getInstance().getVmDAO().getById(getVmId()));
    /**
     * TODO: check users throw their groups as well
     */
    initUser();
    boolean isPrestartedVm = false;
    synchronized (_lockObject) {
        // check vm is not attached to user and attach
        List<permissions> vmUserPermissions = DbFacade.getInstance().getPermissionDAO().getAllForRoleAndObject(PredefinedRoles.ENGINE_USER.getId(), getVmId());
        if (vmUserPermissions == null || vmUserPermissions.isEmpty()) {
            setVmId(getPrestartedVmToAttach(getParameters().getVmPoolId()));
            if (!getVmId().equals(Guid.Empty)) {
                isPrestartedVm = true;
            } else {
                setVmId(getNonPrestartedVmToAttach(getParameters().getVmPoolId()));
            }
            if (!getVmId().equals(Guid.Empty)) {
                getParameters().setEntityId(getVmId());
                permissions perm = new permissions(getAdUserId(), PredefinedRoles.ENGINE_USER.getId(), getVmId(), VdcObjectType.VM);
                PermissionsOperationsParametes permParams = new PermissionsOperationsParametes(perm);
                permParams.setShouldBeLogged(false);
                permParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
                VdcReturnValueBase vdcReturnValueFromAddPerm = Backend.getInstance().runInternalAction(VdcActionType.AddPermission, permParams, getCompensationContext());
                if (!vdcReturnValueFromAddPerm.getSucceeded()) {
                    log.infoFormat("Failed to give user {0} permission to Vm {1} ", getAdUserId(), getVmId());
                    setActionReturnValue(vdcReturnValueFromAddPerm);
                    return;
                }
                log.infoFormat("Vm {0} was attached to user {1} ", getVmId(), getAdUserId());
            } else {
                log.infoFormat("No free Vms in pool {0}. Cannot allocate for user {1} ", getVmPoolId(), getAdUserId());
                throw new VdcBLLException(VdcBllErrors.NO_FREE_VM_IN_POOL);
            }
        }
    }
    if (getVmId().equals(Guid.Empty)) {
        log.infoFormat("No free Vms in pool. Cannot allocate for user {1} ", getAdUserId());
        throw new VdcBLLException(VdcBllErrors.NO_FREE_VM_IN_POOL);
    }
    // Only when using a Vm that is not prestarted do we need to run the vm
    if (!isPrestartedVm) {
        // Used to be when it was CreateAllSnapshotsCommand tempVar.setEntityId(getParameters().getEntityId());
        RunVmParams runVmParams = new RunVmParams(getVm().getvm_guid());
        runVmParams.setSessionId(getParameters().getSessionId());
        runVmParams.setUseVnc(getVm().getvm_type() == VmType.Server);
        runVmParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
        runVmParams.setRunAsStateless(true);
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RunVm, runVmParams);
        // Are the following necessary ?
        getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
        setSucceeded(vdcReturnValue.getSucceeded());
        setActionReturnValue(getVmId());
        getReturnValue().getTaskIdList().addAll(getReturnValue().getInternalTaskIdList());
    }
}
#method_after
@Override
protected void executeCommand() {
    getParameters().setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
    initUser();
    boolean isPrestartedVm = false;
    Guid vmToAttach = Guid.Empty;
    synchronized (_lockObject) {
        vmToAttach = getPrestartedVmToAttach(getParameters().getVmPoolId());
        if (!Guid.Empty.equals(vmToAttach)) {
            isPrestartedVm = true;
        } else {
            vmToAttach = getNonPrestartedVmToAttach(getParameters().getVmPoolId());
        }
        if (!Guid.Empty.equals(vmToAttach)) {
            getParameters().setEntityId(vmToAttach);
            setVmId(vmToAttach);
            permissions perm = new permissions(getAdUserId(), PredefinedRoles.ENGINE_USER.getId(), vmToAttach, VdcObjectType.VM);
            PermissionsOperationsParametes permParams = new PermissionsOperationsParametes(perm);
            permParams.setShouldBeLogged(false);
            permParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
            VdcReturnValueBase vdcReturnValueFromAddPerm = Backend.getInstance().runInternalAction(VdcActionType.AddPermission, permParams, new CommandContext(getCompensationContext()));
            if (!vdcReturnValueFromAddPerm.getSucceeded()) {
                log.infoFormat("Failed to give user {0} permission to Vm {1} ", getAdUserId(), vmToAttach);
                setActionReturnValue(vdcReturnValueFromAddPerm);
                return;
            } else {
                log.infoFormat("Succceeded giving user {0} permission to Vm {1} ", getAdUserId(), vmToAttach);
            }
        } else {
            log.infoFormat("No free Vms in pool {0}. Cannot allocate for user {1} ", getVmPoolId(), getAdUserId());
            throw new VdcBLLException(VdcBllErrors.NO_FREE_VM_IN_POOL);
        }
    }
    // Only when using a Vm that is not prestarted do we need to run the vm
    if (!isPrestartedVm) {
        RunVmParams runVmParams = new RunVmParams(vmToAttach);
        runVmParams.setSessionId(getParameters().getSessionId());
        runVmParams.setUseVnc(getVm().getvm_type() == VmType.Server);
        runVmParams.setParentParemeters(getParameters());
        runVmParams.setEntityId(vmToAttach);
        runVmParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
        runVmParams.setRunAsStateless(true);
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RunVm, runVmParams);
        getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
        setSucceeded(vdcReturnValue.getSucceeded());
        setActionReturnValue(vmToAttach);
        getReturnValue().getTaskIdList().addAll(getReturnValue().getInternalTaskIdList());
    }
}
#end_block

#method_before
@Override
protected void EndSuccessfully() {
    // we are setting 'Vm' since VmId is overriden and 'Vm' is null
    // (since 'Vm' is dependant on 'mVmId', which is not set here).
    setVm(DbFacade.getInstance().getVmDAO().getById(getVmId()));
    if (getVm() != null) {
        // next line is for retrieving the VmPool from the DB
        // so we won't get a log-deadlock because of the transaction.
        vm_pools vmPool = getVmPool();
        if (DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVm().getvm_guid()).size() > 0) {
            setSucceeded(Backend.getInstance().endAction(VdcActionType.RunVm, getParameters().getImagesParameters().get(0), getCompensationContext()).getSucceeded());
            if (!getSucceeded()) {
                log.warn("EndSuccessfully: EndAction of RunVm failed, detaching user from Vm");
                // just in case.
                detachUserFromVmFromPool();
                getReturnValue().setEndActionTryAgain(false);
            }
        } else // Pool-snapshot is gone (probably due to ProcessVmPoolOnStopVm
        // treatment) ->
        // no point in running the VM or trying to run again the EndAction
        // method:
        {
            log.warn("EndSuccessfully: No images were created for Vm, detaching user from Vm");
            // just in case.
            detachUserFromVmFromPool();
            getReturnValue().setEndActionTryAgain(false);
        }
    } else {
        setCommandShouldBeLogged(false);
        log.warn("AttachUserToVmFromPoolAndRunCommand::EndSuccessfully: Vm is null - not performing full EndAction");
        setSucceeded(true);
    }
}
#method_after
@Override
protected void EndSuccessfully() {
    if (getVm() != null) {
        if (DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVm().getId()).size() > 0) {
            setSucceeded(Backend.getInstance().endAction(VdcActionType.RunVm, getParameters().getImagesParameters().get(0), new CommandContext(getCompensationContext())).getSucceeded());
            if (!getSucceeded()) {
                log.warn("EndSuccessfully: EndAction of RunVm failed, detaching user from Vm");
                // just in case.
                detachUserFromVmFromPool();
                getReturnValue().setEndActionTryAgain(false);
            }
        } else // Pool-snapshot is gone (probably due to ProcessVmPoolOnStopVm
        // treatment) ->
        // no point in running the VM or trying to run again the EndAction
        // method:
        {
            log.warn("EndSuccessfully: No images were created for Vm, detaching user from Vm");
            // just in case.
            detachUserFromVmFromPool();
            getReturnValue().setEndActionTryAgain(false);
        }
    } else {
        setCommandShouldBeLogged(false);
        log.warn("AttachUserToVmFromPoolAndRunCommand::EndSuccessfully: Vm is null - not performing full EndAction");
        setSucceeded(true);
    }
}
#end_block

#method_before
@Override
protected void EndWithFailure() {
    // we are setting 'Vm' since VmId is overriden and 'Vm' is null
    // (since 'Vm' is dependant on 'mVmId', which is not set here).
    setVm(DbFacade.getInstance().getVmDAO().getById(getVmId()));
    // next line is for retrieving the VmPool (and Vm, implicitly) from
    // the DB so we won't get a log-deadlock because of the transaction.
    vm_pools vmPool = getVmPool();
    setSucceeded(Backend.getInstance().endAction(VdcActionType.RunVm, getParameters().getImagesParameters().get(0), getCompensationContext()).getSucceeded());
    if (!getSucceeded()) {
        log.warn("AttachUserToVmFromPoolAndRunCommand::EndWitFailure: EndAction of RunVm Failed");
    }
    detachUserFromVmFromPool();
}
#method_after
@Override
protected void EndWithFailure() {
    setSucceeded(Backend.getInstance().endAction(VdcActionType.RunVm, getParameters().getImagesParameters().get(0), new CommandContext(getCompensationContext())).getSucceeded());
    if (!getSucceeded()) {
        log.warn("AttachUserToVmFromPoolAndRunCommand::EndWitFailure: EndAction of RunVm Failed");
    }
    detachUserFromVmFromPool();
}
#end_block

#method_before
protected void detachUserFromVmFromPool() {
    // Detach user from vm from pool:
    if (!getAdUserId().equals(Guid.Empty)) {
        permissions perm = DbFacade.getInstance().getPermissionDAO().getForRoleAndAdElementAndObject(PredefinedRoles.ENGINE_USER.getId(), getAdUserId(), getVmId());
        if (perm != null) {
            DbFacade.getInstance().getPermissionDAO().remove(perm.getId());
        }
    }
}
#method_after
protected void detachUserFromVmFromPool() {
    // Detach user from vm from pool:
    if (!Guid.Empty.equals(getAdUserId())) {
        permissions perm = DbFacade.getInstance().getPermissionDAO().getForRoleAndAdElementAndObject(PredefinedRoles.ENGINE_USER.getId(), getAdUserId(), getVmId());
        if (perm != null) {
            DbFacade.getInstance().getPermissionDAO().remove(perm.getId());
        }
    }
}
#end_block

#method_before
@Override
public void setSession(Session session) {
    super.setSession(session);
    imageDAO.setSession(session);
    dynamicDAO.setSession(session);
    templateDAO.setSession(session);
    imageVmMapDAO.setSession(session);
}
#method_after
@Override
public void setSession(Session session) {
    super.setSession(session);
    imageDAO.setSession(session);
    dynamicDAO.setSession(session);
    imageVmMapDAO.setSession(session);
}
#end_block

#method_before
@Override
public List<DiskImage> getAllForVm(Guid id) {
    return imageDAO.getAllForVm(id);
}
#method_after
@Override
public List<DiskImage> getAllForVm(Guid id, Guid userID, boolean isFiltered) {
    throw new NotImplementedException("This method is not implemented for Hibernate yet");
}
#end_block

#method_before
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getchild_count()).addValue("creation_date", template.getcreation_date()).addValue("description", template.getdescription()).addValue("mem_size_mb", template.getmem_size_mb()).addValue("name", template.getname()).addValue("num_of_sockets", template.getnum_of_sockets()).addValue("cpu_per_socket", template.getcpu_per_socket()).addValue("os", template.getos()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getvds_group_id()).addValue("domain", template.getdomain()).addValue("num_of_monitors", template.getnum_of_monitors()).addValue("status", template.getstatus()).addValue("usb_policy", template.getusb_policy()).addValue("time_zone", template.gettime_zone()).addValue("fail_back", template.getfail_back()).addValue("is_auto_suspend", template.getis_auto_suspend()).addValue("vm_type", template.getvm_type()).addValue("hypervisor_type", template.gethypervisor_type()).addValue("operation_mode", template.getoperation_mode()).addValue("nice_level", template.getnice_level()).addValue("default_boot_sequence", template.getdefault_boot_sequence()).addValue("default_display_type", template.getdefault_display_type()).addValue("priority", template.getpriority()).addValue("auto_startup", template.getauto_startup()).addValue("is_stateless", template.getis_stateless()).addValue("iso_path", template.getiso_path()).addValue("origin", template.getorigin()).addValue("initrd_url", template.getinitrd_url()).addValue("kernel_url", template.getkernel_url()).addValue("kernel_params", template.getkernel_params());
}
#method_after
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getchild_count()).addValue("creation_date", template.getcreation_date()).addValue("description", template.getdescription()).addValue("mem_size_mb", template.getmem_size_mb()).addValue("name", template.getname()).addValue("num_of_sockets", template.getnum_of_sockets()).addValue("cpu_per_socket", template.getcpu_per_socket()).addValue("os", template.getos()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getvds_group_id()).addValue("domain", template.getdomain()).addValue("num_of_monitors", template.getnum_of_monitors()).addValue("status", template.getstatus()).addValue("usb_policy", template.getusb_policy()).addValue("time_zone", template.gettime_zone()).addValue("fail_back", template.getfail_back()).addValue("is_auto_suspend", template.getis_auto_suspend()).addValue("vm_type", template.getvm_type()).addValue("hypervisor_type", template.gethypervisor_type()).addValue("operation_mode", template.getoperation_mode()).addValue("nice_level", template.getnice_level()).addValue("default_boot_sequence", template.getdefault_boot_sequence()).addValue("default_display_type", template.getdefault_display_type()).addValue("priority", template.getpriority()).addValue("auto_startup", template.getauto_startup()).addValue("is_stateless", template.getis_stateless()).addValue("iso_path", template.getiso_path()).addValue("origin", template.getorigin()).addValue("initrd_url", template.getinitrd_url()).addValue("kernel_url", template.getkernel_url()).addValue("kernel_params", template.getkernel_params()).addValue("quota_id", template.getQuotaId());
}
#end_block

#method_before
@Override
public void save(VmStatic vm) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("domain", vm.getdomain()).addValue("creation_date", vm.getcreation_date()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("hypervisor_type", vm.gethypervisor_type()).addValue("operation_mode", vm.getoperation_mode()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem());
    getCallsHandler().executeModification("InsertVmStatic", parameterSource);
}
#method_after
@Override
public void save(VmStatic vm) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("domain", vm.getdomain()).addValue("creation_date", vm.getcreation_date()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("hypervisor_type", vm.gethypervisor_type()).addValue("operation_mode", vm.getoperation_mode()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId());
    getCallsHandler().executeModification("InsertVmStatic", parameterSource);
}
#end_block

#method_before
@Override
public void update(VmStatic vm) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("domain", vm.getdomain()).addValue("creation_date", vm.getcreation_date()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("hypervisor_type", vm.gethypervisor_type()).addValue("operation_mode", vm.getoperation_mode()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem());
    getCallsHandler().executeModification("UpdateVmStatic", parameterSource);
}
#method_after
@Override
public void update(VmStatic vm) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("domain", vm.getdomain()).addValue("creation_date", vm.getcreation_date()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("hypervisor_type", vm.gethypervisor_type()).addValue("operation_mode", vm.getoperation_mode()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId());
    getCallsHandler().executeModification("UpdateVmStatic", parameterSource);
}
#end_block

#method_before
@Override
public VmStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmStatic entity = new VmStatic();
    map(rs, entity);
    entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setmem_size_mb(rs.getInt("mem_size_mb"));
    entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setvm_name(rs.getString("vm_name"));
    entity.setvmt_guid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setdomain(rs.getString("domain"));
    entity.setnum_of_monitors(rs.getInt("num_of_monitors"));
    entity.setis_initialized(rs.getBoolean("is_initialized"));
    entity.setdedicated_vm_for_vds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setdefault_display_type(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    return entity;
}
#method_after
@Override
public VmStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmStatic entity = new VmStatic();
    map(rs, entity);
    entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setmem_size_mb(rs.getInt("mem_size_mb"));
    entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setvm_name(rs.getString("vm_name"));
    entity.setvmt_guid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setdomain(rs.getString("domain"));
    entity.setnum_of_monitors(rs.getInt("num_of_monitors"));
    entity.setis_initialized(rs.getBoolean("is_initialized"));
    entity.setdedicated_vm_for_vds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setdefault_display_type(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    return entity;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<VM> vms = DbFacade.getInstance().getVmDAO().getAllVmsRelatedToQuotaId(getParameters().getQuotaId());
    for (VM vm : vms) {
        VmHandler.updateDisksFromDb(vm);
    }
    getQueryReturnValue().setReturnValue(vms);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<VmTemplate> vmTemplates = DbFacade.getInstance().getVmTemplateDAO().getAllTemplatesRelatedToQuotaId(getParameters().getQuotaId());
    for (VmTemplate vmTemplate : vmTemplates) {
        VmTemplateHandler.UpdateDisksFromDb(vmTemplate);
    }
    getQueryReturnValue().setReturnValue(vmTemplates);
}
#end_block

#method_before
@Override
protected boolean validateQuota() {
    // Set default quota id if storage pool enforcement is disabled.
    getParameters().setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getParameters().getQuotaId(), getStoragePool()));
    if (!isInternalExecution()) {
        return QuotaManager.validateMultiStorageQuota(getStoragePool().getQuotaEnforcementType(), getQuotaConsumeMap(), getCommandId(), getReturnValue().getCanDoActionMessages());
    }
    return true;
}
#method_after
@Override
protected boolean validateQuota() {
    // Set default quota id if storage pool enforcement is disabled.
    getParameters().setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getParameters().getQuotaId(), getStoragePool()));
    for (DiskImage diskImage : mImages) {
        diskImage.setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getParameters().getQuotaId(), getStoragePool()));
    }
    if (!isInternalExecution()) {
        return QuotaManager.validateMultiStorageQuota(getStoragePool().getQuotaEnforcementType(), getQuotaConsumeMap(), getCommandId(), getReturnValue().getCanDoActionMessages());
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null || !getVm().getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    for (DiskImage diskImage : getVm().getDiskList()) {
        mImages.add(diskImage);
    }
    if (mImages.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getos(), getParameters().getMasterVm().getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!IsVmPriorityValueLegal(getParameters().getMasterVm().getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Guid srcStorageDomainId = mImages.get(0).getstorage_id().getValue();
    // or populate storage domain id from the vm domain (of the first disk)
    if (getParameters().getDestinationStorageDomainId() != null) {
        setStorageDomainId(getParameters().getDestinationStorageDomainId());
    } else {
        setStorageDomainId(srcStorageDomainId);
    }
    if (!ImagesHandler.PerformImagesChecks(getParameters().getMasterVm().getId(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), srcStorageDomainId, true, true, true, true, true, false, true)) {
        return false;
    }
    VM vm = DbFacade.getInstance().getVmDAO().getById(getParameters().getMasterVm().getId());
    if (vm.getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_DUPLICATE_NAME);
        return false;
    }
    if (getStorageDomainId() != null) {
        storage_domains storage = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(getStorageDomainId().getValue(), getVm().getstorage_pool_id());
        // if source and destination domains are different we need to check destination domain also
        if (!srcStorageDomainId.equals(getStorageDomainId().getValue())) {
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDAO().get(getStorageDomainId().getValue()) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getstatus() == null || storage.getstatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
                return false;
            }
        }
        if (storage.getstorage_domain_type() == StorageDomainType.ImportExport || storage.getstorage_domain_type() == StorageDomainType.ISO) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            return false;
        }
        // update vm snapshots for storage free space check
        for (DiskImage diskImage : getVm().getDiskMap().values()) {
            diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getId(), diskImage.getit_guid()));
        }
        if (!StorageDomainSpaceChecker.hasSpaceForRequest(storage, (int) getVm().getActualDiskWithSnapshotsSize())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
            return false;
        }
    }
    if (!AddVmCommand.CheckCpuSockets(getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null || !getVm().getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    for (DiskImage diskImage : getVm().getDiskList()) {
        mImages.add(diskImage);
    }
    if (mImages.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getos(), getParameters().getMasterVm().getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!IsVmPriorityValueLegal(getParameters().getMasterVm().getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Guid srcStorageDomainId = mImages.get(0).getstorage_ids().get(0);
    // or populate storage domain id from the vm domain (of the first disk)
    if (getParameters().getDestinationStorageDomainId() != null) {
        setStorageDomainId(getParameters().getDestinationStorageDomainId());
    } else {
        setStorageDomainId(srcStorageDomainId);
    }
    if (!validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (!ImagesHandler.PerformImagesChecks(getParameters().getMasterVm().getId(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), srcStorageDomainId, true, true, true, true, true, false, true)) {
        return false;
    }
    VM vm = DbFacade.getInstance().getVmDAO().getById(getParameters().getMasterVm().getId());
    if (vm.getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_DUPLICATE_NAME);
        return false;
    }
    if (getStorageDomainId() != null) {
        storage_domains storage = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(getStorageDomainId().getValue(), getVm().getstorage_pool_id());
        // if source and destination domains are different we need to check destination domain also
        if (!srcStorageDomainId.equals(getStorageDomainId().getValue())) {
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDAO().get(getStorageDomainId().getValue()) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getstatus() == null || storage.getstatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
                return false;
            }
        }
        if (storage.getstorage_domain_type() == StorageDomainType.ImportExport || storage.getstorage_domain_type() == StorageDomainType.ISO) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            return false;
        }
        // update vm snapshots for storage free space check
        for (DiskImage diskImage : getVm().getDiskMap().values()) {
            diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getId(), diskImage.getit_guid()));
        }
        if (!StorageDomainSpaceChecker.hasSpaceForRequest(storage, (int) getVm().getActualDiskWithSnapshotsSize())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
            return false;
        }
    }
    if (!AddVmCommand.CheckCpuSockets(getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected void AddVmTemplateImages() {
    Guid srcStorageDomain = mImages.get(0).getstorage_id().getValue();
    Guid vmSnapshotId = Guid.NewGuid();
    for (DiskImage diskImage : mImages) {
        CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getId(), getVmTemplateId(), getVmTemplateName(), getVmId());
        if (!diskImage.getstorage_id().equals(Guid.Empty)) {
            createParams.setStorageDomainId(diskImage.getstorage_id().getValue());
        } else {
            createParams.setStorageDomainId(srcStorageDomain);
        }
        createParams.setVmSnapshotId(vmSnapshotId);
        createParams.setEntityId(getParameters().getEntityId());
        createParams.setDestinationStorageDomainId(getStorageDomainId().getValue());
        createParams.setParentParemeters(getParameters());
        getParameters().getImagesParameters().add(createParams);
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, createParams, ExecutionHandler.createDefaultContexForTasks(executionContext));
        QuotaManager.reduceCommandStorageSize(createParams.getStorageDomainId(), diskImage.getsize(), getStoragePool().getQuotaEnforcementType(), getCommandId(), getParameters().getQuotaId());
        getReturnValue().getTaskIdList().addAll(retValue.getInternalTaskIdList());
    }
}
#method_after
protected void AddVmTemplateImages() {
    Guid srcStorageDomain = mImages.get(0).getstorage_ids().get(0);
    Guid vmSnapshotId = Guid.NewGuid();
    for (DiskImage diskImage : mImages) {
        CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getId(), getVmTemplateId(), getVmTemplateName(), getVmId());
        if (!Guid.Empty.equals(diskImage.getstorage_ids().get(0))) {
            createParams.setStorageDomainId(diskImage.getstorage_ids().get(0));
        } else {
            createParams.setStorageDomainId(srcStorageDomain);
        }
        createParams.setVmSnapshotId(vmSnapshotId);
        createParams.setEntityId(getParameters().getEntityId());
        createParams.setDestinationStorageDomainId(getStorageDomainId().getValue());
        createParams.setParentParemeters(getParameters());
        getParameters().getImagesParameters().add(createParams);
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, createParams, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        getReturnValue().getTaskIdList().addAll(retValue.getInternalTaskIdList());
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> list = new ArrayList<PermissionSubject>();
    Guid storagePoolId = getVdsGroup() == null || getVdsGroup().getstorage_pool_id() == null ? null : getVdsGroup().getstorage_pool_id().getValue();
    list.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
    QuotaHelper.addQuotaPermissionSubject(list, getStoragePool(), getQuotaId());
    return list;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> list = new ArrayList<PermissionSubject>();
    Guid storagePoolId = getVdsGroup() == null || getVdsGroup().getstorage_pool_id() == null ? null : getVdsGroup().getstorage_pool_id().getValue();
    list.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
    list = QuotaHelper.getInstance().addQuotaPermissionSubject(list, getStoragePool(), getVm().getStaticData().getQuotaId());
    list = setPermissionListForDiskImage(list);
    return list;
}
#end_block

#method_before
@Override
protected boolean validateQuota() {
    // Set default quota id if storage pool enforcement is disabled.
    getParameters().setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getParameters().getQuotaId(), getStoragePool()));
    boolean isQuotaValid = true;
    Double sizeRequestedForSnapshot = 0d;
    for (DiskImage image : getDisksList()) {
        sizeRequestedForSnapshot += image.getactual_size();
    }
    isQuotaValid = QuotaManager.validateStorageQuota(getDisksList().get(0).getstorage_id().getValue(), getParameters().getQuotaId(), getStoragePool().getQuotaEnforcementType(), sizeRequestedForSnapshot, getCommandId(), getReturnValue().getCanDoActionMessages());
    return isQuotaValid;
}
#method_after
@Override
protected boolean validateQuota() {
    // Set default quota id if storage pool enforcement is disabled.
    getParameters().setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getParameters().getQuotaId(), getStoragePool()));
    return QuotaManager.validateMultiStorageQuota(getStoragePool().getQuotaEnforcementType(), QuotaHelper.getInstance().getQuotaConsumeMap(getDisksList()), getCommandId(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Override
protected void removeQuotaCommandLeftOver() {
    if (!isInternalExecution()) {
        QuotaManager.removeStorageDeltaQuotaCommand(getQuotaId(), getDisksList().get(0).getstorage_id().getValue(), getStoragePool().getQuotaEnforcementType(), getCommandId());
    }
}
#method_after
@Override
protected void removeQuotaCommandLeftOver() {
    if (!isInternalExecution()) {
        QuotaManager.removeStorageDeltaQuotaCommand(getQuotaId(), getDisksList().get(0).getstorage_ids().get(0).getValue(), getStoragePool().getQuotaEnforcementType(), getCommandId());
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    if (getDisksList().size() > 0) {
        result = ImagesHandler.PerformImagesChecks(getVmId(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), getDisksList().get(0).getstorage_id().getValue(), true, getParameters().getParentCommand() != VdcActionType.RunVm, true, true, true, getParameters().getParentCommand() != VdcActionType.RunVm, true);
    }
    if (!result) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CREATE);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__SNAPSHOT);
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    if (getDisksList().size() > 0) {
        result = validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())) && ImagesHandler.PerformImagesChecks(getVmId(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), getDisksList().get(0).getstorage_ids().get(0), true, getParameters().getParentCommand() != VdcActionType.RunVm, true, true, true, getParameters().getParentCommand() != VdcActionType.RunVm, true);
    }
    if (!result) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CREATE);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__SNAPSHOT);
    }
    return result;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    permissionList = QuotaHelper.addQuotaPermissionSubject(permissionList, getStoragePool(), getQuotaId());
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    permissionList = QuotaHelper.getInstance().addQuotaPermissionSubject(permissionList, getStoragePool(), getQuotaId());
    return permissionList;
}
#end_block

#method_before
private Guid getDisksStorageDomainId() {
    return getVm().getDiskMap().values().iterator().next().getstorage_id().getValue();
}
#method_after
private Guid getDisksStorageDomainId() {
    return getVm().getDiskMap().values().iterator().next().getstorage_ids().get(0);
}
#end_block

#method_before
@Override
protected boolean validateQuota() {
    return (QuotaManager.validateStorageQuota(getStorageDomainId().getValue(), getParameters().getDiskInfo().getQuotaId(), getStoragePool().getQuotaEnforcementType(), new Double(getRequestDiskSpace()), getCommandId(), getReturnValue().getCanDoActionMessages()));
}
#method_after
@Override
protected boolean validateQuota() {
    // Set default quota id if storage pool enforcement is disabled.
    getParameters().setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getParameters().getDiskInfo().getQuotaId(), getStoragePool()));
    return (QuotaManager.validateStorageQuota(getStorageDomainId().getValue(), getParameters().getQuotaId(), getStoragePool().getQuotaEnforcementType(), new Double(getRequestDiskSpace()), getCommandId(), getReturnValue().getCanDoActionMessages()));
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> listPermissionSubjects = super.getPermissionCheckSubjects();
    listPermissionSubjects = QuotaHelper.addQuotaPermissionSubject(listPermissionSubjects, getStoragePool(), getQuotaId());
    return listPermissionSubjects;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> listPermissionSubjects = super.getPermissionCheckSubjects();
    listPermissionSubjects = QuotaHelper.getInstance().addQuotaPermissionSubject(listPermissionSubjects, getStoragePool(), getQuotaId());
    return listPermissionSubjects;
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    // NOTE: Assuming that we need to lock the vm before adding a disk!
    VmHandler.checkStatusAndLockVm(getVm().getId(), getCompensationContext());
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getVmId(), getParameters().getDiskInfo());
    parameters.setStorageDomainId(getStorageDomainId().getValue());
    parameters.setVmSnapshotId(calculateSnapshotId());
    parameters.setParentCommand(VdcActionType.AddDiskToVm);
    parameters.setEntityId(getParameters().getEntityId());
    getParameters().getImagesParameters().add(parameters);
    getParameters().setVmSnapshotId(parameters.getVmSnapshotId());
    parameters.setParentParemeters(getParameters());
    VdcReturnValueBase tmpRetValue = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, parameters, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    getReturnValue().getTaskIdList().addAll(tmpRetValue.getInternalTaskIdList());
    getReturnValue().setActionReturnValue(tmpRetValue.getActionReturnValue());
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#method_after
@Override
protected void ExecuteVmCommand() {
    // NOTE: Assuming that we need to lock the vm before adding a disk!
    VmHandler.checkStatusAndLockVm(getVm().getId(), getCompensationContext());
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getVmId(), getParameters().getDiskInfo());
    parameters.setQuotaId(getParameters().getQuotaId());
    parameters.setStorageDomainId(getStorageDomainId().getValue());
    parameters.setVmSnapshotId(calculateSnapshotId());
    parameters.setParentCommand(VdcActionType.AddDiskToVm);
    parameters.setEntityId(getParameters().getEntityId());
    getParameters().getImagesParameters().add(parameters);
    getParameters().setVmSnapshotId(parameters.getVmSnapshotId());
    parameters.setParentParemeters(getParameters());
    VdcReturnValueBase tmpRetValue = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, parameters, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    getReturnValue().getTaskIdList().addAll(tmpRetValue.getInternalTaskIdList());
    getReturnValue().setActionReturnValue(tmpRetValue.getActionReturnValue());
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#end_block

#method_before
@Override
protected boolean validateQuota() {
    // Set default quota id if storage pool enforcement is disabled.
    getParameters().setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getParameters().getQuotaId(), getStoragePool()));
    if (!isInternalExecution()) {
        return QuotaManager.validateMultiStorageQuota(getStoragePool().getQuotaEnforcementType(), getQuotaConsumeMap(), getCommandId(), getReturnValue().getCanDoActionMessages());
    }
    return true;
}
#method_after
@Override
protected boolean validateQuota() {
    // Set default quota id if storage pool enforcement is disabled.
    getParameters().setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getParameters().getVmStaticData().getQuotaId(), getStoragePool()));
    for (DiskImage dit : getVmTemplate().getDiskMap().values()) {
        dit.setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getParameters().getVmStaticData().getQuotaId(), getStoragePool()));
    }
    if (!isInternalExecution()) {
        // TODO: Should be changed when multiple storage domain will be implemented and the desired quotas will be transferred.
        return QuotaManager.validateMultiStorageQuota(getStoragePool().getQuotaEnforcementType(), QuotaHelper.getInstance().getQuotaConsumeMap(getVmTemplate().getDiskList()), getCommandId(), getReturnValue().getCanDoActionMessages());
    }
    return true;
}
#end_block

#method_before
protected boolean AddVmImages() {
    if (getVmTemplate().getDiskMap().size() > 0) {
        if (getVm().getstatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(getVmId());
        for (DiskImage dit : getVmTemplate().getDiskMap().values()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getId(), getParameters().getVmStaticData().getId());
            tempVar.setStorageDomainId(getStorageDomainId().getValue());
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityId(getParameters().getEntityId());
            tempVar.setParentParemeters(getParameters());
            VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar);
            reduceQuotaCommand(getStorageDomainId().getValue(), dit.getsize(), getStoragePool().getQuotaEnforcementType(), getCommandId(), getParameters().getQuotaId());
            getParameters().getImagesParameters().add(tempVar);
            /**
             * if couldnt create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            } else {
                getTaskIdList().addAll(result.getInternalTaskIdList());
            }
        }
    }
    return true;
}
#method_after
protected boolean AddVmImages() {
    if (getVmTemplate().getDiskMap().size() > 0) {
        if (getVm().getstatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(getVmId());
        for (DiskImage dit : getVmTemplate().getDiskMap().values()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getId(), getParameters().getVmStaticData().getId());
            tempVar.setStorageDomainId(getStorageDomainId().getValue());
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityId(getParameters().getEntityId());
            tempVar.setParentParemeters(getParameters());
            tempVar.setQuotaId(dit.getQuotaId());
            VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            getParameters().getImagesParameters().add(tempVar);
            /**
             * if couldnt create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            } else {
                getTaskIdList().addAll(result.getInternalTaskIdList());
            }
        }
    }
    return true;
}
#end_block

#method_before
protected void removeQuotaCommandLeftOver() {
    if (!isInternalExecution()) {
        QuotaManager.removeMultiStorageDeltaQuotaCommand(getQuotaConsumeMap(), getStoragePool().getQuotaEnforcementType(), getCommandId());
    }
}
#method_after
protected void removeQuotaCommandLeftOver() {
    if (!isInternalExecution()) {
        QuotaManager.removeMultiStorageDeltaQuotaCommand(QuotaHelper.getInstance().getQuotaConsumeMap(getVmTemplate().getDiskList()), getStoragePool().getQuotaEnforcementType(), getCommandId());
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(getVdsGroupId(), VdcObjectType.VdsGroups, getActionType().getActionGroup()));
    permissionList.add(new PermissionSubject(getVmTemplateId(), VdcObjectType.VmTemplate, getActionType().getActionGroup()));
    permissionList = QuotaHelper.addQuotaPermissionSubject(permissionList, getStoragePool(), getQuotaId());
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(getVdsGroupId(), VdcObjectType.VdsGroups, getActionType().getActionGroup()));
    permissionList.add(new PermissionSubject(getVmTemplateId(), VdcObjectType.VmTemplate, getActionType().getActionGroup()));
    permissionList = QuotaHelper.getInstance().addQuotaPermissionSubject(permissionList, getStoragePool(), getQuotaId());
    return permissionList;
}
#end_block

#method_before
protected CompensationContext getCompensationContext() {
    return compensationContext;
}
#method_after
protected CompensationContext getCompensationContext() {
    return context.getCompensationContext();
}
#end_block

#method_before
public void setCompensationContext(CompensationContext compensationContext) {
    this.compensationContext = compensationContext;
}
#method_after
public void setCompensationContext(CompensationContext compensationContext) {
    context.setCompensationContext(compensationContext);
}
#end_block

#method_before
public VdcReturnValueBase ExecuteAction() {
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    boolean actionAllowed = false;
    Step validatingStep = ExecutionHandler.addStep(executionContext, StepEnum.VALIDATING, null);
    try {
        actionAllowed = acquireLock() && (getReturnValue().getCanDoAction() || InternalCanDoAction());
        ExecutionHandler.endStep(executionContext, validatingStep, actionAllowed);
        if (actionAllowed) {
            getReturnValue().setCanDoAction(true);
            getReturnValue().setIsSyncronious(true);
            getParameters().setTaskStartTime(System.currentTimeMillis());
            Execute();
        } else {
            getReturnValue().setCanDoAction(false);
        }
    } finally {
        freeLock();
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase ExecuteAction() {
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    boolean actionAllowed = false;
    Step validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    try {
        actionAllowed = acquireLock() && (getReturnValue().getCanDoAction() || InternalCanDoAction());
        ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        if (actionAllowed) {
            getReturnValue().setCanDoAction(true);
            getReturnValue().setIsSyncronious(true);
            getParameters().setTaskStartTime(System.currentTimeMillis());
            Execute();
        } else {
            getReturnValue().setCanDoAction(false);
        }
    } finally {
        freeLock();
    }
    return getReturnValue();
}
#end_block

#method_before
public VdcReturnValueBase EndAction() {
    ExecutionHandler.startFinalizingStep(executionContext);
    try {
        SetActionState();
        handleTransactivity();
        TransactionSupport.executeInScope(endActionScope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("EndAction: Transaction was aborted in {0}", this.getClass().getName());
    } finally {
        if (getCommandShouldBeLogged()) {
            LogCommand();
        }
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase EndAction() {
    ExecutionHandler.startFinalizingStep(getExecutionContext());
    try {
        SetActionState();
        handleTransactivity();
        TransactionSupport.executeInScope(endActionScope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("EndAction: Transaction was aborted in {0}", this.getClass().getName());
    } finally {
        if (getCommandShouldBeLogged()) {
            LogCommand();
        }
    }
    return getReturnValue();
}
#end_block

#method_before
private void handleTransactivity() {
    scope = (getParameters() != null) ? getParameters().getTransactionScopeOption() : TransactionScopeOption.Required;
    endActionScope = scope;
    boolean forceCompensation = getForceCompensation();
    // command parameters
    if (!getTransactive()) {
        scope = TransactionScopeOption.Suppress;
        // Set the end action scope to suppress only for non-compensating commands, or the end action for commands
        // will run without transaction but compensation is not supported for end action.
        endActionScope = forceCompensation ? endActionScope : scope;
    }
    if (compensationContext == null) {
        compensationContext = createCompensationContext(scope, forceCompensation);
    }
}
#method_after
private void handleTransactivity() {
    scope = (getParameters() != null) ? getParameters().getTransactionScopeOption() : TransactionScopeOption.Required;
    endActionScope = scope;
    boolean forceCompensation = getForceCompensation();
    // command parameters
    if (!getTransactive()) {
        scope = TransactionScopeOption.Suppress;
        // Set the end action scope to suppress only for non-compensating commands, or the end action for commands
        // will run without transaction but compensation is not supported for end action.
        endActionScope = forceCompensation ? endActionScope : scope;
    }
    if (getCompensationContext() == null) {
        context.setCompensationContext(createCompensationContext(scope, forceCompensation));
    }
}
#end_block

#method_before
protected boolean checkUserAuthorization(final ActionGroup action, final Guid object, final VdcObjectType type) {
    // Grant if there is matching permission in the database:
    final NGuid permId = DbFacade.getInstance().getEntityPermissions(getCurrentUser().getUserId(), action, object, type);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), action, object);
    }
    return false;
}
#method_after
protected boolean checkUserAuthorization(final ActionGroup actionGroup, final Guid object, final VdcObjectType type) {
    // Grant if there is matching permission in the database:
    final NGuid permId = DbFacade.getInstance().getEntityPermissions(getCurrentUser().getUserId(), actionGroup, object, type);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
protected boolean IsUserAutorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check skipped for internal action {0}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!Config.<Boolean>GetValue(ConfigValues.IsMultilevelAdministrationOn)) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check for action {0} skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The set of objects to check is null or empty for action {0}.", getActionType());
        }
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    for (PermissionSubject permSubject : permSubjects) {
        final Guid objectId = permSubject.getObjectId();
        final VdcObjectType objectType = permSubject.getObjectType();
        final ActionGroup objectActionGroup = permSubject.getActionGroup();
        if (objectActionGroup == ActionGroup.CONSUME_QUOTA) {
            if (!isUserAuthorizedToConsumeQuota(objectId, objectType, objectActionGroup)) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_USER_IS_NOT_PERMITTED);
                return false;
            }
            return true;
        }
        // if objectId is null we can't check permission
        if (objectId == null) {
            if (log.isDebugEnabled()) {
                log.debugFormat("The object to check is null for action {0}.", getActionType());
            }
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            return false;
        }
        // Check that an action group is defined for this action;
        if (objectActionGroup == null) {
            if (log.isDebugEnabled()) {
                log.debugFormat("No action group is defined for action {0}.", getActionType());
            }
            return false;
        }
        // Check the authorization:
        if (!checkUserAuthorization(objectActionGroup, objectId, objectType)) {
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            return false;
        }
    }
    // If we are here then we should grant the permission:
    return true;
}
#method_after
protected boolean IsUserAutorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check skipped for internal action {0}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!Config.<Boolean>GetValue(ConfigValues.IsMultilevelAdministrationOn)) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check for action {0} skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The set of objects to check is null or empty for action {0}.", getActionType());
        }
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    for (PermissionSubject permSubject : permSubjects) {
        final Guid objectId = permSubject.getObjectId();
        final VdcObjectType objectType = permSubject.getObjectType();
        final ActionGroup objectActionGroup = permSubject.getActionGroup();
        // if objectId is null we can't check permission
        if (objectId == null) {
            if (log.isDebugEnabled()) {
                log.debugFormat("The object to check is null for action {0}.", getActionType());
            }
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            return false;
        }
        // Check that an action group is defined for this action;
        if (objectActionGroup == null) {
            if (log.isDebugEnabled()) {
                log.debugFormat("No action group is defined for action {0}.", getActionType());
            }
            return false;
        }
        // Check the authorization:
        if (!checkUserAuthorization(objectActionGroup, objectId, objectType)) {
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            return false;
        }
    }
    // If we are here then we should grant the permission:
    return true;
}
#end_block

#method_before
private void Execute() {
    ExecutionHandler.addStep(executionContext, StepEnum.EXECUTING, null);
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            freeLock();
            if (getCommandShouldBeLogged()) {
                LogCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                UpdateTasksWithActionParameters();
                StartPollingAsyncTasks();
            }
        } finally {
            if (getReturnValue().getTaskIdList().isEmpty()) {
                ExecutionHandler.endJob(executionContext, getSucceeded());
            }
        }
    }
}
#method_after
private void Execute() {
    ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            freeLock();
            if (getCommandShouldBeLogged()) {
                LogCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                UpdateTasksWithActionParameters();
                StartPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#end_block

#method_before
protected Guid CreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description) {
    Guid retValue = Guid.Empty;
    Transaction transaction = TransactionSupport.suspend();
    try {
        Step taskStep = ExecutionHandler.addTaskStep(executionContext, StepEnum.getStepNameByTaskType(asyncTaskCreationInfo.getTaskType()), description);
        if (taskStep != null) {
            asyncTaskCreationInfo.setStepId(taskStep.getId());
        }
        retValue = ConcreteCreateTask(asyncTaskCreationInfo, parentCommand);
        ExecutionHandler.updateStepExternalId(taskStep, retValue, ExternalSystemType.VDSM);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during CreateTask for command: {0}. Exception {1}", getClass().getName(), ex);
    } finally {
        TransactionSupport.resume(transaction);
    }
    return retValue;
}
#method_after
protected Guid CreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description) {
    Guid retValue = Guid.Empty;
    Transaction transaction = TransactionSupport.suspend();
    try {
        Step taskStep = ExecutionHandler.addTaskStep(getExecutionContext(), StepEnum.getStepNameByTaskType(asyncTaskCreationInfo.getTaskType()), description);
        if (taskStep != null) {
            asyncTaskCreationInfo.setStepId(taskStep.getId());
        }
        retValue = ConcreteCreateTask(asyncTaskCreationInfo, parentCommand);
        ExecutionHandler.updateStepExternalId(taskStep, retValue, ExternalSystemType.VDSM);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during CreateTask for command: {0}. Exception {1}", getClass().getName(), ex);
    } finally {
        TransactionSupport.resume(transaction);
    }
    return retValue;
}
#end_block

#method_before
private void cancelTasks() {
    if (!getReturnValue().getTaskIdList().isEmpty()) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                String threadName = Thread.currentThread().getName();
                Thread.currentThread().setName("Rollback-" + threadName);
                TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        try {
                            AsyncTaskManager.getInstance().CancelTasks(getReturnValue().getTaskIdList());
                        } catch (Exception e) {
                            log.errorFormat("Failed to cancel tasks for command: {0}.", CommandBase.this.getClass().getName());
                        }
                        return null;
                    }
                });
            }
        });
    }
}
#method_after
private void cancelTasks() {
    if (hasTasks()) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                String threadName = Thread.currentThread().getName();
                Thread.currentThread().setName("Rollback-" + threadName);
                TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        try {
                            AsyncTaskManager.getInstance().CancelTasks(getReturnValue().getTaskIdList());
                        } catch (Exception e) {
                            log.errorFormat("Failed to cancel tasks for command: {0}.", CommandBase.this.getClass().getName());
                        }
                        return null;
                    }
                });
            }
        });
    }
}
#end_block

#method_before
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = new HashMap<String, String>();
        List<PermissionSubject> subjects = getPermissionCheckSubjects();
        if (!subjects.isEmpty()) {
            VdcObjectType entityType;
            Guid entityId;
            String value;
            for (PermissionSubject permSubject : subjects) {
                ActionGroup actionGroup = permSubject.getActionGroup();
                entityType = permSubject.getObjectType();
                entityId = permSubject.getObjectId();
                if (entityType != null && entityId != null && actionGroup != ActionGroup.CONSUME_QUOTA) {
                    value = DbFacade.getInstance().getEntityNameByIdAndType(entityId, entityType);
                    if (value == null) {
                        value = entityId.toString();
                    }
                    jobProperties.put(entityType.name().toLowerCase(), value);
                }
            }
        }
    }
    return jobProperties;
}
#method_after
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = new HashMap<String, String>();
        List<PermissionSubject> subjects = getPermissionCheckSubjects();
        if (!subjects.isEmpty()) {
            VdcObjectType entityType;
            Guid entityId;
            String value;
            for (PermissionSubject permSubject : subjects) {
                entityType = permSubject.getObjectType();
                entityId = permSubject.getObjectId();
                if (entityType != null && entityId != null) {
                    value = DbFacade.getInstance().getEntityNameByIdAndType(entityId, entityType);
                    if (value == null) {
                        value = entityId.toString();
                    }
                    jobProperties.put(entityType.name().toLowerCase(), value);
                }
            }
        }
    }
    return jobProperties;
}
#end_block

#method_before
public void setExecutionContext(ExecutionContext executionContext) {
    if (executionContext != null) {
        this.executionContext = executionContext;
    }
}
#method_after
public void setExecutionContext(ExecutionContext executionContext) {
    context.setExecutionContext(executionContext);
}
#end_block

#method_before
public ExecutionContext getExecutionContext() {
    return executionContext;
}
#method_after
public ExecutionContext getExecutionContext() {
    return context.getExecutionContext();
}
#end_block

#method_before
@Test
public void canRunVmFailNodisk() {
    initMocks(new ArrayList<DiskImage>(), new HashMap<VDSCommandType, Boolean>(), new ArrayList<VmDevice>());
    final VM vm = new VM();
    final ArrayList<String> messages = new ArrayList<String>();
    Assert.assertFalse(RunVmCommand.CanRunVm(vm, messages, new RunVmParams(), new VdsSelector(vm, new NGuid(), true)));
    Assert.assertTrue(messages.contains("VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK"));
}
#method_after
@Test
public void canRunVmFailNodisk() {
    initMocks(new ArrayList<DiskImage>(), new HashMap<VDSCommandType, Boolean>(), new ArrayList<VmDevice>());
    final VM vm = new VM();
    final ArrayList<String> messages = new ArrayList<String>();
    Assert.assertFalse(RunVmCommand.CanRunVm(vm, messages, new RunVmParams(), new VdsSelector(vm, new NGuid(), true), mockSuccessfulSnapshotValidator()));
    Assert.assertTrue(messages.contains("VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK"));
}
#end_block

#method_before
@Test
public void canRunVmFailVmRunning() {
    final ArrayList<DiskImage> disks = new ArrayList<DiskImage>();
    final DiskImage diskImage = new DiskImage();
    diskImage.setstorage_id(new Guid());
    disks.add(diskImage);
    final VmDevice vmDevice = new VmDevice();
    vmDevice.setIsPlugged(true);
    initMocks(disks, new HashMap<VDSCommandType, Boolean>(), Collections.singletonList(vmDevice));
    final VM vm = new VM();
    vm.setstatus(VMStatus.Up);
    final ArrayList<String> messages = new ArrayList<String>();
    Assert.assertFalse(RunVmCommand.CanRunVm(vm, messages, new RunVmParams(), new VdsSelector(vm, new NGuid(), true)));
    Assert.assertTrue(messages.contains("ACTION_TYPE_FAILED_VM_IS_RUNNING"));
}
#method_after
@Test
public void canRunVmFailVmRunning() {
    final ArrayList<DiskImage> disks = new ArrayList<DiskImage>();
    final DiskImage diskImage = new DiskImage();
    diskImage.setstorage_ids(new ArrayList<Guid>(Arrays.asList(new Guid())));
    disks.add(diskImage);
    final VmDevice vmDevice = new VmDevice();
    vmDevice.setIsPlugged(true);
    initMocks(disks, new HashMap<VDSCommandType, Boolean>(), Collections.singletonList(vmDevice));
    final VM vm = new VM();
    vm.setstatus(VMStatus.Up);
    final ArrayList<String> messages = new ArrayList<String>();
    Assert.assertFalse(RunVmCommand.CanRunVm(vm, messages, new RunVmParams(), new VdsSelector(vm, new NGuid(), true), mockSuccessfulSnapshotValidator()));
    Assert.assertTrue(messages.contains("ACTION_TYPE_FAILED_VM_IS_RUNNING"));
}
#end_block

#method_before
private void canRunStatelessVmTest(boolean autoStartUp, boolean isVmStateless, Boolean isStatelessParam, boolean shouldPass) {
    final ArrayList<DiskImage> disks = new ArrayList<DiskImage>();
    final DiskImage diskImage = new DiskImage();
    diskImage.setstorage_id(new Guid());
    disks.add(diskImage);
    final VmDevice vmDevice = new VmDevice();
    vmDevice.setIsPlugged(true);
    final HashMap<VDSCommandType, Boolean> calls = new HashMap<VDSCommandType, Boolean>();
    final VdsSelector vdsSelector = Mockito.mock(VdsSelector.class);
    Mockito.when(vdsSelector.CanFindVdsToRunOn(any(ArrayList.class), anyBoolean())).thenReturn(true);
    calls.put(VDSCommandType.IsVmDuringInitiating, false);
    initMocks(disks, calls, Collections.singletonList(vmDevice));
    final VM vm = new VM();
    // set stateless and HA
    vm.setis_stateless(isVmStateless);
    vm.setauto_startup(autoStartUp);
    final ArrayList<String> messages = new ArrayList<String>();
    final RunVmParams runParams = new RunVmParams();
    runParams.setRunAsStateless(isStatelessParam);
    boolean canRunVm = RunVmCommand.CanRunVm(vm, messages, runParams, vdsSelector);
    if (shouldPass) {
        Assert.assertTrue(canRunVm);
        Assert.assertFalse(messages.contains("VM_CANNOT_RUN_STATELESS_HA"));
    } else {
        Assert.assertFalse(canRunVm);
        Assert.assertTrue(messages.contains("VM_CANNOT_RUN_STATELESS_HA"));
    }
}
#method_after
private void canRunStatelessVmTest(boolean autoStartUp, boolean isVmStateless, Boolean isStatelessParam, boolean shouldPass) {
    final ArrayList<DiskImage> disks = new ArrayList<DiskImage>();
    final DiskImage diskImage = new DiskImage();
    diskImage.setstorage_ids(new ArrayList<Guid>(Arrays.asList((new Guid()))));
    disks.add(diskImage);
    final VmDevice vmDevice = new VmDevice();
    vmDevice.setIsPlugged(true);
    final HashMap<VDSCommandType, Boolean> calls = new HashMap<VDSCommandType, Boolean>();
    final VdsSelector vdsSelector = Mockito.mock(VdsSelector.class);
    Mockito.when(vdsSelector.CanFindVdsToRunOn(any(ArrayList.class), anyBoolean())).thenReturn(true);
    calls.put(VDSCommandType.IsVmDuringInitiating, false);
    initMocks(disks, calls, Collections.singletonList(vmDevice));
    final VM vm = new VM();
    // set stateless and HA
    vm.setis_stateless(isVmStateless);
    vm.setauto_startup(autoStartUp);
    final ArrayList<String> messages = new ArrayList<String>();
    final RunVmParams runParams = new RunVmParams();
    runParams.setRunAsStateless(isStatelessParam);
    boolean canRunVm = RunVmCommand.CanRunVm(vm, messages, runParams, vdsSelector, mockSuccessfulSnapshotValidator());
    if (shouldPass) {
        Assert.assertTrue(canRunVm);
        Assert.assertFalse(messages.contains("VM_CANNOT_RUN_STATELESS_HA"));
    } else {
        Assert.assertFalse(canRunVm);
        Assert.assertTrue(messages.contains("VM_CANNOT_RUN_STATELESS_HA"));
    }
}
#end_block

#method_before
protected boolean InitVm() {
    if (getVm() == null) {
        log.warnFormat("ResourceManager::{0}::No such vm (where id = '{1}' )in database", getClass().getName(), getVmId().toString());
        throw new VdcBLLException(VdcBllErrors.DB_NO_SUCH_VM);
    }
    if ((getVm().getstatus() == VMStatus.ImageIllegal) || (getVm().getstatus() == VMStatus.ImageLocked)) {
        log.warnFormat("ResourceManager::{0}::vm '{1}' has {2}", getClass().getName(), getVmId().toString(), (getVm().getstatus() == VMStatus.ImageLocked ? "a locked image" : "an illegal image"));
        setActionReturnValue(getVm().getstatus());
        return false;
    } else {
        HandleMemoryAdjustments();
        VmHandler.updateDisksFromDb(getVm());
        getVm().setCdPath(_cdImagePath);
        getVm().setFloppyPath(_floppyImagePath);
        getVm().setkvm_enable(getParameters().getKvmEnable());
        getVm().setRunAndPause(getParameters().getRunAndPause());
        getVm().setacpi_enable(getParameters().getAcpiEnable());
        getParameters().setRunAsStateless(shouldVmRunAsStateless(getParameters(), getVm()));
        // once command
        if (getParameters().getUseVnc() != null) {
            getVm().setdisplay_type(getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl);
        } else {
            getVm().setdisplay_type(getVm().getdefault_display_type());
        }
        if (getParameters().getReinitialize()) {
            getVm().setUseSysPrep(true);
        }
        // if we attach floppy we don't need the sysprep
        if (!StringHelper.isNullOrEmpty(getVm().getFloppyPath())) {
            DbFacade.getInstance().getVmStaticDAO().update(getVm().getStaticData());
        }
        // get what cpu flags should be passed to vdsm according to cluster
        // cpu name
        getVm().setvds_group_cpu_flags_data(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getvds_group_cpu_name(), getVm().getvds_group_compatibility_version()));
        return true;
    }
}
#method_after
protected boolean InitVm() {
    if (getVm() == null) {
        log.warnFormat("ResourceManager::{0}::No such vm (where id = '{1}' )in database", getClass().getName(), getVmId().toString());
        throw new VdcBLLException(VdcBllErrors.DB_NO_SUCH_VM);
    }
    if ((getVm().getstatus() == VMStatus.ImageIllegal) || (getVm().getstatus() == VMStatus.ImageLocked)) {
        log.warnFormat("ResourceManager::{0}::vm '{1}' has {2}", getClass().getName(), getVmId().toString(), (getVm().getstatus() == VMStatus.ImageLocked ? "a locked image" : "an illegal image"));
        setActionReturnValue(getVm().getstatus());
        return false;
    } else if (!getSnapshotsValidator().vmNotDuringSnapshot(getVmId()).isValid()) {
        log.warnFormat("ResourceManager::{0}::VM {1} is during snapshot", getClass().getName(), getVmId().toString());
        return false;
    } else {
        HandleMemoryAdjustments();
        VmHandler.updateDisksFromDb(getVm());
        getVm().setCdPath(_cdImagePath);
        getVm().setFloppyPath(_floppyImagePath);
        getVm().setkvm_enable(getParameters().getKvmEnable());
        getVm().setRunAndPause(getParameters().getRunAndPause());
        getVm().setacpi_enable(getParameters().getAcpiEnable());
        getParameters().setRunAsStateless(shouldVmRunAsStateless(getParameters(), getVm()));
        // once command
        if (getParameters().getUseVnc() != null) {
            getVm().setdisplay_type(getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl);
        } else {
            getVm().setdisplay_type(getVm().getdefault_display_type());
        }
        if (getParameters().getReinitialize()) {
            getVm().setUseSysPrep(true);
        }
        // if we attach floppy we don't need the sysprep
        if (!StringHelper.isNullOrEmpty(getVm().getFloppyPath())) {
            DbFacade.getInstance().getVmStaticDAO().update(getVm().getStaticData());
        }
        // get what cpu flags should be passed to vdsm according to cluster
        // cpu name
        getVm().setvds_group_cpu_flags_data(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getvds_group_cpu_name(), getVm().getvds_group_compatibility_version()));
        return true;
    }
}
#end_block

#method_before
public boolean CanRunVm() {
    return CanRunVm(getVm(), getReturnValue().getCanDoActionMessages(), getParameters(), getVdsSelector());
}
#method_after
public boolean CanRunVm() {
    return CanRunVm(getVm(), getReturnValue().getCanDoActionMessages(), getParameters(), getVdsSelector(), getSnapshotsValidator());
}
#end_block

#method_before
public static boolean CanRunVm(VM vm, java.util.ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        if (message != null) {
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
        }
    } else if (!(validationErrors = VmPropertiesUtils.validateVMProperties(vm.getStaticData())).isEmpty()) {
        handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getdefault_boot_sequence();
        Guid storagePoolId = vm.getstorage_pool_id();
        // Block from running a VM with no HDD when its first boot device is
        // HD
        // and no other boot devices are configured
        List<DiskImage> vmImages = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vm.getId());
        if (boot_sequence == BootSequence.C && !checkVmHasPluggedDisk(vm)) {
            String messageStr = !vmImages.isEmpty() ? VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_PLUGGED_DISK.toString() : VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString();
            message.add(messageStr);
            retValue = false;
        } else {
            if (boot_sequence == BootSequence.CD && findActiveISODomain(storagePoolId) == null) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else // custom properties allowed only from cluster 2.3
            if (!StringHelper.isNullOrEmpty(vm.getStaticData().getCustomProperties()) && !Config.<Boolean>GetValue(ConfigValues.SupportCustomProperties, vm.getvds_group_compatibility_version().getValue())) {
                message.add(VdcBllMessages.CUSTOM_VM_PROPERTIES_INVALID_VALUES_NOT_ALLOWED_IN_CURRENT_CLUSTER.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence.toString().indexOf(NETWORK_BOOT_SEQUENCE_CHAR) > -1 && DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else if (vmImages.size() > 0) {
                    Guid storageDomainId = vmImages.get(0).getstorage_id().getValue();
                    // if VM is not HA VM
                    if (!ImagesHandler.PerformImagesChecks(vm.getId(), message, vm.getstorage_pool_id(), storageDomainId, !vm.getauto_startup(), true, false, false, false, false, !vm.getauto_startup() && !storageDomainId.equals(Guid.Empty) || !runParams.getIsInternal() && vm.getauto_startup(), !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup())) {
                        retValue = false;
                    } else // Check if iso and floppy path exists
                    if (!vm.getauto_startup() && !validateIsoPath(findActiveISODomain(vm.getstorage_pool_id()), runParams, message)) {
                        retValue = false;
                    } else {
                        boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
                        if (vm.isStatusUp() || (vm.getstatus() == VMStatus.NotResponding) || isVmDuringInit) {
                            retValue = false;
                            if (message != null) {
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                            }
                        } else if (vm.getstatus() == VMStatus.Paused && vm.getrun_on_vds() != null) {
                            VDS vds = DbFacade.getInstance().getVdsDAO().get(new Guid(vm.getrun_on_vds().toString()));
                            if (vds.getstatus() != VDSStatus.Up) {
                                retValue = false;
                                if (message != null) {
                                    message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                                }
                            }
                        }
                        boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                        if (retValue && isStatelessVm && ImagesHandler.isVmInPreview(vmImages)) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                        }
                        // if the VM itself is stateless or run once as stateless
                        if (retValue && isStatelessVm && vm.getauto_startup()) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                        }
                        retValue = retValue == false ? retValue : vdsSelector.CanFindVdsToRunOn(message, false);
                        /**
                         * only if can do action ok then check with actions matrix that status is valid for this
                         * action
                         */
                        if (retValue && !VdcActionUtils.CanExecute(new java.util.ArrayList<IVdcQueryable>(java.util.Arrays.asList(new IVdcQueryable[] { vm })), VM.class, VdcActionType.RunVm)) {
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                            retValue = false;
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#method_after
public static boolean CanRunVm(VM vm, java.util.ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector, SnapshotsValidator snapshotsValidator) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        if (message != null) {
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
        }
    } else if (!(validationErrors = VmPropertiesUtils.validateVMProperties(vm.getStaticData())).isEmpty()) {
        handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getdefault_boot_sequence();
        Guid storagePoolId = vm.getstorage_pool_id();
        // Block from running a VM with no HDD when its first boot device is
        // HD
        // and no other boot devices are configured
        List<DiskImage> vmImages = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vm.getId());
        if (boot_sequence == BootSequence.C && !checkVmHasPluggedDisk(vm)) {
            String messageStr = !vmImages.isEmpty() ? VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_PLUGGED_DISK.toString() : VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString();
            message.add(messageStr);
            retValue = false;
        } else {
            if (boot_sequence == BootSequence.CD && findActiveISODomain(storagePoolId) == null) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else // custom properties allowed only from cluster 2.3
            if (!StringHelper.isNullOrEmpty(vm.getStaticData().getCustomProperties()) && !Config.<Boolean>GetValue(ConfigValues.SupportCustomProperties, vm.getvds_group_compatibility_version().getValue())) {
                message.add(VdcBllMessages.CUSTOM_VM_PROPERTIES_INVALID_VALUES_NOT_ALLOWED_IN_CURRENT_CLUSTER.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence.toString().indexOf(NETWORK_BOOT_SEQUENCE_CHAR) > -1 && DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else if (vmImages.size() > 0) {
                    Guid storageDomainId = vmImages.get(0).getstorage_ids().get(0);
                    ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vm.getId());
                    if (!vmDuringSnapshotResult.isValid()) {
                        message.add(vmDuringSnapshotResult.getMessage().name());
                        retValue = false;
                    }
                    // if VM is not HA VM
                    if (retValue && !ImagesHandler.PerformImagesChecks(vm.getId(), message, vm.getstorage_pool_id(), storageDomainId, !vm.getauto_startup(), true, false, false, false, false, !vm.getauto_startup() && !storageDomainId.equals(Guid.Empty) || !runParams.getIsInternal() && vm.getauto_startup(), !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup())) {
                        retValue = false;
                    } else // Check if iso and floppy path exists
                    if (!vm.getauto_startup() && !validateIsoPath(findActiveISODomain(vm.getstorage_pool_id()), runParams, message)) {
                        retValue = false;
                    } else {
                        boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
                        if (vm.isStatusUp() || (vm.getstatus() == VMStatus.NotResponding) || isVmDuringInit) {
                            retValue = false;
                            if (message != null) {
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                            }
                        } else if (vm.getstatus() == VMStatus.Paused && vm.getrun_on_vds() != null) {
                            VDS vds = DbFacade.getInstance().getVdsDAO().get(new Guid(vm.getrun_on_vds().toString()));
                            if (vds.getstatus() != VDSStatus.Up) {
                                retValue = false;
                                if (message != null) {
                                    message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                                }
                            }
                        }
                        boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                        if (retValue && isStatelessVm && ImagesHandler.isVmInPreview(vmImages)) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                        }
                        // if the VM itself is stateless or run once as stateless
                        if (retValue && isStatelessVm && vm.getauto_startup()) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                        }
                        retValue = retValue == false ? retValue : vdsSelector.CanFindVdsToRunOn(message, false);
                        /**
                         * only if can do action ok then check with actions matrix that status is valid for this
                         * action
                         */
                        if (retValue && !VdcActionUtils.CanExecute(new java.util.ArrayList<IVdcQueryable>(java.util.Arrays.asList(new IVdcQueryable[] { vm })), VM.class, VdcActionType.RunVm)) {
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                            retValue = false;
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#end_block

#method_before
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ADD);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_DISK);
}
#method_after
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__RUN);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
}
#end_block

#method_before
@Override
protected boolean validateQuota() {
    // Set default quota id if storage pool enforcement is disabled.
    getParameters().setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getParameters().getQuotaId(), getStoragePool()));
    if (!isInternalExecution()) {
        return QuotaManager.validateMultiStorageQuota(getStoragePool().getQuotaEnforcementType(), getQuotaConsumeMap(), getCommandId(), getReturnValue().getCanDoActionMessages());
    }
    return true;
}
#method_after
@Override
protected boolean validateQuota() {
    // Set default quota id if storage pool enforcement is disabled.
    getParameters().setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getParameters().getVmStaticData().getQuotaId(), getStoragePool()));
    for (DiskImage dit : getVmTemplate().getDiskMap().values()) {
        dit.setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getParameters().getVmStaticData().getQuotaId(), getStoragePool()));
    }
    if (!isInternalExecution()) {
        // TODO: Should be changed when multiple storage domain will be implemented and the desired quotas will be transferred.
        return QuotaManager.validateMultiStorageQuota(getStoragePool().getQuotaEnforcementType(), QuotaHelper.getInstance().getQuotaConsumeMap(getVmTemplate().getDiskList()), getCommandId(), getReturnValue().getCanDoActionMessages());
    }
    return true;
}
#end_block

#method_before
protected boolean AddVmImages() {
    if (getVmTemplate().getDiskMap().size() > 0) {
        if (getVm().getstatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(getVmId());
        for (DiskImage dit : getVmTemplate().getDiskMap().values()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getId(), getParameters().getVmStaticData().getId());
            tempVar.setStorageDomainId(getStorageDomainId().getValue());
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityId(getParameters().getEntityId());
            tempVar.setParentParemeters(getParameters());
            VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar);
            reduceQuotaCommand(getStorageDomainId().getValue(), dit.getsize(), getStoragePool().getQuotaEnforcementType(), getCommandId(), getParameters().getQuotaId());
            getParameters().getImagesParameters().add(tempVar);
            /**
             * if couldnt create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            } else {
                getTaskIdList().addAll(result.getInternalTaskIdList());
            }
        }
    }
    return true;
}
#method_after
protected boolean AddVmImages() {
    if (getVmTemplate().getDiskMap().size() > 0) {
        if (getVm().getstatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(getVmId());
        for (DiskImage dit : getVmTemplate().getDiskMap().values()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getId(), getParameters().getVmStaticData().getId());
            tempVar.setStorageDomainId(getStorageDomainId().getValue());
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityId(getParameters().getEntityId());
            tempVar.setParentParemeters(getParameters());
            tempVar.setQuotaId(dit.getQuotaId());
            VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            getParameters().getImagesParameters().add(tempVar);
            /**
             * if couldnt create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            } else {
                getTaskIdList().addAll(result.getInternalTaskIdList());
            }
        }
    }
    return true;
}
#end_block

#method_before
protected void removeQuotaCommandLeftOver() {
    if (!isInternalExecution()) {
        QuotaManager.removeMultiStorageDeltaQuotaCommand(getQuotaConsumeMap(), getStoragePool().getQuotaEnforcementType(), getCommandId());
    }
}
#method_after
protected void removeQuotaCommandLeftOver() {
    if (!isInternalExecution()) {
        QuotaManager.removeMultiStorageDeltaQuotaCommand(QuotaHelper.getInstance().getQuotaConsumeMap(getVmTemplate().getDiskList()), getStoragePool().getQuotaEnforcementType(), getCommandId());
    }
}
#end_block

#method_before
public Map<Pair<Guid, Guid>, Double> getQuotaConsumeMap(List<DiskImage> diskImageList) {
    Map<Pair<Guid, Guid>, Double> quotaForStorageConsumption = new HashMap<Pair<Guid, Guid>, Double>();
    for (DiskImage disk : diskImageList) {
        Pair<Guid, Guid> quotaForStorageKey = new Pair<Guid, Guid>(disk.getQuotaId(), disk.getstorage_id().getValue());
        Double storageRequest = quotaForStorageConsumption.get(quotaForStorageKey);
        if (storageRequest != null) {
            storageRequest += disk.getsize();
        } else {
            storageRequest = new Double(disk.getsize());
        }
        quotaForStorageConsumption.put(quotaForStorageKey, storageRequest);
    }
    return quotaForStorageConsumption;
}
#method_after
public Map<Pair<Guid, Guid>, Double> getQuotaConsumeMap(List<DiskImage> diskImageList) {
    Map<Pair<Guid, Guid>, Double> quotaForStorageConsumption = new HashMap<Pair<Guid, Guid>, Double>();
    for (DiskImage disk : diskImageList) {
        Pair<Guid, Guid> quotaForStorageKey = new Pair<Guid, Guid>(disk.getQuotaId(), disk.getstorage_ids().get(0).getValue());
        Double storageRequest = quotaForStorageConsumption.get(quotaForStorageKey);
        if (storageRequest != null) {
            storageRequest += disk.getsize();
        } else {
            storageRequest = new Double(disk.getsize());
        }
        quotaForStorageConsumption.put(quotaForStorageKey, storageRequest);
    }
    return quotaForStorageConsumption;
}
#end_block

#method_before
public static void reduceCommandVdsGroupSize(Guid vdsGroupId, Integer subtractedCpuSize, QuotaEnforcmentTypeEnum quotaEnforcedType, Double subtractedMemSize, Guid commandId, Guid quotaId) {
    if (!validateReduceQuotaParameters(vdsGroupId, quotaEnforcedType, commandId, quotaId)) {
        return;
    }
    if ((subtractedCpuSize == null || subtractedCpuSize.longValue() == 0) && (subtractedMemSize == null || subtractedMemSize.longValue() == 0)) {
        log.errorFormat("Sutracted size is not valid, quota delta will not be reduced.");
        return;
    }
    getLockForQuotaId(quotaId).lock();
    try {
        Map<Guid, QuotaDeltaValue> quotaDeltaMap = commandDeltaMap.get(vdsGroupId);
        if (quotaDeltaMap == null) {
            log.errorFormat("Quota id {0} for vds group id {1} has no associated command map", quotaId, vdsGroupId);
        } else if (quotaDeltaMap.get(commandId) == null) {
            log.errorFormat("Quota id {0} for vds group id {1} and command id (2) has no associated delta quota", quotaId, vdsGroupId, commandId);
        } else {
            QuotaDeltaValue quotaDeltaValue = quotaDeltaMap.get(commandId);
            Integer cpuDeltaForCommandVal = quotaDeltaValue.getCpuSizeToBeUsed();
            Double memDeltaForCommandVal = quotaDeltaValue.getMemSizeToBeUsed();
            if ((cpuDeltaForCommandVal == null) && (memDeltaForCommandVal == null)) {
                log.errorFormat("Quota id {0} for vds group id {1} and command id (2) does not have cpu and memory delta parameters.", quotaId, vdsGroupId, commandId);
            } else if ((cpuDeltaForCommandVal < subtractedCpuSize) || (memDeltaForCommandVal < subtractedMemSize)) {
                log.errorFormat("Quota id {0} for vds group id {1} and command id (2) has less vds group delta from the size requested to be reduced. The delta value will be set to 0", quotaId, vdsGroupId, commandId);
                quotaDeltaValue.setCpuSizeToBeUsed(0);
                quotaDeltaValue.setMemSizeToBeUsed(0d);
            } else {
                quotaDeltaValue.setMemSizeToBeUsed(quotaDeltaValue.getMemSizeToBeUsed() - subtractedMemSize);
                quotaDeltaValue.setCpuSizeToBeUsed(quotaDeltaValue.getCpuSizeToBeUsed() - subtractedCpuSize);
            }
        }
    } finally {
        getLockForQuotaId(quotaId).unlock();
    }
}
#method_after
public static void reduceCommandVdsGroupSize(Guid vdsGroupId, Integer subtractedCpuSize, QuotaEnforcmentTypeEnum quotaEnforcedType, Double subtractedMemSize, Guid commandId, Guid quotaId) {
    if (!validateReduceQuotaParameters(vdsGroupId, quotaEnforcedType, commandId, quotaId)) {
        return;
    }
    if ((subtractedCpuSize == null || subtractedCpuSize.longValue() == 0) && (subtractedMemSize == null || subtractedMemSize.longValue() == 0)) {
        log.errorFormat("Subtracted size is not valid, quota delta will not be reduced for qutoa Id {0} and vds group Id {1}.", quotaId, vdsGroupId);
        return;
    }
    getLockForQuotaId(quotaId).lock();
    try {
        Map<Guid, QuotaDeltaValue> quotaDeltaMap = commandDeltaMap.get(vdsGroupId);
        if (quotaDeltaMap == null) {
            log.errorFormat("Quota id {0} for vds group id {1} has no associated command map", quotaId, vdsGroupId);
        } else if (quotaDeltaMap.get(commandId) == null) {
            log.errorFormat("Quota id {0} for vds group id {1} and command id (2) has no associated delta quota", quotaId, vdsGroupId, commandId);
        } else {
            QuotaDeltaValue quotaDeltaValue = quotaDeltaMap.get(commandId);
            Integer cpuDeltaForCommandVal = quotaDeltaValue.getCpuSizeToBeUsed();
            Double memDeltaForCommandVal = quotaDeltaValue.getMemSizeToBeUsed();
            if ((cpuDeltaForCommandVal == null) && (memDeltaForCommandVal == null)) {
                log.errorFormat("Quota id {0} for vds group id {1} and command id (2) does not have cpu and memory delta parameters.", quotaId, vdsGroupId, commandId);
            } else if ((cpuDeltaForCommandVal < subtractedCpuSize) || (memDeltaForCommandVal < subtractedMemSize)) {
                log.errorFormat("Quota id {0} for vds group id {1} and command id (2) has less vds group delta from the size requested to be reduced. The delta value will be set to 0", quotaId, vdsGroupId, commandId);
                quotaDeltaValue.setCpuSizeToBeUsed(0);
                quotaDeltaValue.setMemSizeToBeUsed(0d);
            } else {
                quotaDeltaValue.setMemSizeToBeUsed(quotaDeltaValue.getMemSizeToBeUsed() - subtractedMemSize);
                quotaDeltaValue.setCpuSizeToBeUsed(quotaDeltaValue.getCpuSizeToBeUsed() - subtractedCpuSize);
            }
        }
    } finally {
        getLockForQuotaId(quotaId).unlock();
    }
}
#end_block

#method_before
public static void reduceCommandStorageSize(Guid storageDomainId, Long subtractedSize, QuotaEnforcmentTypeEnum quotaEnforcedType, Guid commandId, Guid quotaId) {
    if (!validateReduceQuotaParameters(storageDomainId, quotaEnforcedType, commandId, quotaId)) {
        return;
    }
    if (subtractedSize == null || subtractedSize.longValue() == 0) {
        log.errorFormat("Sutracted size is not valid, quota delta will not be reduced.");
        return;
    }
    QuotaStorage quotaStorage = getQuotaStorageForStorageDomainId(quotaId, storageDomainId);
    getLockForQuotaId(quotaId).lock();
    try {
        Map<Guid, QuotaDeltaValue> quotaDeltaMap = commandDeltaMap.get(quotaStorage.getQuotaStorageId());
        if (quotaDeltaMap == null) {
            log.errorFormat("Quota id {0} for storage domain id {1} has no associated command map", quotaId, storageDomainId);
        } else if (quotaDeltaMap.get(commandId) == null) {
            log.errorFormat("Quota id {0} for storage domain id {1} and command id (2) has no associated delta quota", quotaId, storageDomainId, commandId);
        } else {
            QuotaDeltaValue quotaDeltaValue = quotaDeltaMap.get(commandId);
            Double storageSize = quotaDeltaValue.getStorageSizeToBeUsed();
            if (storageSize == null) {
                log.errorFormat("Quota id {0} for storage domain id {1} and command id (2) does not have storage delta size", quotaId, storageDomainId, commandId);
            } else if (storageSize < subtractedSize) {
                log.errorFormat("Quota id {0} for storage domain id {1} and command id (2) has less storage delta size from the size requested to be reduced. The delta value will be se to 0", quotaId, storageDomainId, commandId);
                quotaDeltaValue.setStorageSizeToBeUsed(0d);
            } else {
                quotaDeltaValue.setStorageSizeToBeUsed(quotaDeltaValue.getStorageSizeToBeUsed() - subtractedSize);
            }
        }
    } finally {
        getLockForQuotaId(quotaId).unlock();
    }
}
#method_after
public static void reduceCommandStorageSize(Guid storageDomainId, Long subtractedSize, QuotaEnforcmentTypeEnum quotaEnforcedType, Guid commandId, Guid quotaId) {
    if (!validateReduceQuotaParameters(storageDomainId, quotaEnforcedType, commandId, quotaId)) {
        return;
    }
    if (subtractedSize == null || subtractedSize.longValue() == 0) {
        log.errorFormat("Subtracted size is not valid, quota delta will not be reduced for qutoa Id {0} and storage domain Id {1}.", quotaId, storageDomainId);
        return;
    }
    QuotaStorage quotaStorage = getQuotaStorageForStorageDomainId(quotaId, storageDomainId);
    getLockForQuotaId(quotaId).lock();
    try {
        Map<Guid, QuotaDeltaValue> quotaDeltaMap = commandDeltaMap.get(quotaStorage.getQuotaStorageId());
        if (quotaDeltaMap == null) {
            log.errorFormat("Quota id {0} for storage domain id {1} has no associated command map", quotaId, storageDomainId);
        } else if (quotaDeltaMap.get(commandId) == null) {
            log.errorFormat("Quota id {0} for storage domain id {1} and command id (2) has no associated delta quota", quotaId, storageDomainId, commandId);
        } else {
            QuotaDeltaValue quotaDeltaValue = quotaDeltaMap.get(commandId);
            Double storageSize = quotaDeltaValue.getStorageSizeToBeUsed();
            if (storageSize == null) {
                log.errorFormat("Quota id {0} for storage domain id {1} and command id (2) does not have storage delta size", quotaId, storageDomainId, commandId);
            } else if (storageSize < subtractedSize) {
                log.errorFormat("Quota id {0} for storage domain id {1} and command id (2) has less storage delta size from the size requested to be reduced. The delta value will be se to 0", quotaId, storageDomainId, commandId);
                quotaDeltaValue.setStorageSizeToBeUsed(0d);
            } else {
                quotaDeltaValue.setStorageSizeToBeUsed(quotaDeltaValue.getStorageSizeToBeUsed() - subtractedSize);
            }
        }
    } finally {
        getLockForQuotaId(quotaId).unlock();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getParameters() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID);
        return false;
    } else if (!QuotaHelper.getInstance().checkQuotaValidationForAddEdit(getParameters().getQuota(), getReturnValue().getCanDoActionMessages())) {
        return false;
    } else if (getParameters().getQuota().getId() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!QuotaHelper.getInstance().checkQuotaValidationForAddEdit(getParameters().getQuota(), getReturnValue().getCanDoActionMessages())) {
        return false;
    } else if (getParameters().getQuota().getId() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID);
        return false;
    } else if (getQuotaDAO().getById(getParameters().getQuota().getId()) == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getParameters() == null || (getParameters().getQuotaId() == null)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
    }
    Quota quota = getQuotaDAO().getById(getParameters().getQuotaId());
    if (quota == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    // Check if there is attempt to delete the default quota while storage pool enforcement type is disabled.
    if (getStoragePool().getQuotaEnforcementType() == QuotaEnforcmentTypeEnum.DISABLED && quota.getIsDefaultQuota()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_CAN_NOT_HAVE_DEFAULT_INDICATION);
    }
    // Check If we try to delete the last quota in the DC.
    List<Quota> quotaList = getQuotaDAO().getQuotaByStoragePoolGuid(getParameters().getStoragePoolId());
    if (quotaList.size() <= 1) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DATA_CENTER_MUST_HAVE_AT_LEAST_ONE_QUOTA);
    }
    // TODO : Add Check if there are no VMs/images that are part of the Quota.
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getParameters() == null || (getParameters().getQuotaId() == null)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
    }
    Quota quota = getQuota();
    if (quota == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    // Check if there is attempt to delete the default quota while storage pool enforcement type is disabled.
    if (getStoragePoolDAO().get(quota.getStoragePoolId()).getQuotaEnforcementType() == QuotaEnforcmentTypeEnum.DISABLED && quota.getIsDefaultQuota()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_CAN_NOT_HAVE_DEFAULT_INDICATION);
    }
    // Check If we try to delete the last quota in the DC.
    List<Quota> quotaList = getQuotaDAO().getQuotaByStoragePoolGuid(getParameters().getStoragePoolId());
    if (quotaList.size() <= 1) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DATA_CENTER_MUST_HAVE_AT_LEAST_ONE_QUOTA);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getQuotaDAO().remove(getParameters().getQuotaId());
    getReturnValue().setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    setQuota(getQuotaDAO().getById(getParameters().getQuotaId()));
    getQuotaDAO().remove(getParameters().getQuotaId());
    getReturnValue().setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getParameters() == null) {
        return false;
    } else if (!QuotaHelper.getInstance().checkQuotaValidationForAddEdit(getParameters().getQuota(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    return (QuotaHelper.getInstance().checkQuotaValidationForAddEdit(getParameters().getQuota(), getReturnValue().getCanDoActionMessages()));
}
#end_block

#method_before
@Override
public Map<Guid, VdcObjectType> getPermissionCheckSubjects() {
    return Collections.singletonMap(getQuotaId() == null ? null : getQuotaId().getValue(), VdcObjectType.Quota);
}
#method_after
@Override
public Map<Guid, VdcObjectType> getPermissionCheckSubjects() {
    return Collections.singletonMap(getStoragePoolId() == null ? null : getStoragePoolId().getValue(), VdcObjectType.StoragePool);
}
#end_block

#method_before
private void setQuotaParameter() {
    Quota quotaParameter = getParameters().getQuota();
    setQuotaId(Guid.NewGuid());
    setQuotaName(quotaParameter.getQuotaName());
    if (quotaParameter.getQuotaStorages() != null) {
        for (QuotaStorage quotaStorage : quotaParameter.getQuotaStorages()) {
            quotaStorage.setQuotaId(getQuotaId());
            quotaStorage.setQuotaStorageId(Guid.NewGuid());
        }
    }
    if (quotaParameter.getQuotaVdsGroups() != null) {
        for (QuotaVdsGroup quotaVdsGroup : quotaParameter.getQuotaVdsGroups()) {
            quotaVdsGroup.setQuotaId(getQuotaId());
            quotaVdsGroup.setQuotaVdsGroupId(Guid.NewGuid());
        }
    }
    setQuota(quotaParameter);
}
#method_after
private void setQuotaParameter() {
    Quota quotaParameter = getParameters().getQuota();
    quotaParameter.setId(Guid.NewGuid());
    setStoragePoolId(quotaParameter.getStoragePoolId());
    setQuotaName(quotaParameter.getQuotaName());
    if (quotaParameter.getQuotaStorages() != null) {
        for (QuotaStorage quotaStorage : quotaParameter.getQuotaStorages()) {
            quotaStorage.setQuotaId(getQuotaId());
            quotaStorage.setQuotaStorageId(Guid.NewGuid());
        }
    }
    if (quotaParameter.getQuotaVdsGroups() != null) {
        for (QuotaVdsGroup quotaVdsGroup : quotaParameter.getQuotaVdsGroups()) {
            quotaVdsGroup.setQuotaId(getQuotaId());
            quotaVdsGroup.setQuotaVdsGroupId(Guid.NewGuid());
        }
    }
    setQuota(quotaParameter);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getParameters() == null || (getParameters().getQuotaId() == null)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
    }
    Quota quota = getQuotaDAO().getById(getParameters().getQuotaId());
    if (quota == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    // Check if there is attempt to delete the default quota while storage pool enforcement type is disabled.
    if (getStoragePool().getQuotaEnforcementType() == QuotaEnforcmentTypeEnum.DISABLED && quota.getIsDefaultQuota()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_CAN_NOT_HAVE_DEFAULT_INDICATION);
    }
    // Check If we try to delete the last quota in the DC.
    List<Quota> quotaList = getQuotaDAO().getQuotaByStoragePoolGuid(getParameters().getStoragePoolId());
    if (quotaList.size() <= 1) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DATA_CENTER_MUST_HAVE_AT_LEAST_ONE_QUOTA);
    }
    // TODO : Add Check if there are no VMs/images that are part of the Quota.
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getParameters() == null || (getParameters().getQuotaId() == null)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
    }
    Quota quota = getQuota();
    if (quota == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    // Check if there is attempt to delete the default quota while storage pool enforcement type is disabled.
    if (getStoragePoolDAO().get(quota.getStoragePoolId()).getQuotaEnforcementType() == QuotaEnforcmentTypeEnum.DISABLED && quota.getIsDefaultQuota()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_CAN_NOT_HAVE_DEFAULT_INDICATION);
    }
    // Check If we try to delete the last quota in the DC.
    List<Quota> quotaList = getQuotaDAO().getQuotaByStoragePoolGuid(getParameters().getStoragePoolId());
    if (quotaList.size() <= 1) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DATA_CENTER_MUST_HAVE_AT_LEAST_ONE_QUOTA);
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getParameters() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID);
        return false;
    } else if (!QuotaHelper.getInstance().checkQuotaValidationForAddEdit(getParameters().getQuota(), getReturnValue().getCanDoActionMessages())) {
        return false;
    } else if (getParameters().getQuota().getId() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!QuotaHelper.getInstance().checkQuotaValidationForAddEdit(getParameters().getQuota(), getReturnValue().getCanDoActionMessages())) {
        return false;
    } else if (getParameters().getQuota().getId() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID);
        return false;
    } else if (getQuotaDAO().getById(getParameters().getQuota().getId()) == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getParameters() == null) {
        return false;
    } else if (!QuotaHelper.getInstance().checkQuotaValidationForAddEdit(getParameters().getQuota(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    return (QuotaHelper.getInstance().checkQuotaValidationForAddEdit(getParameters().getQuota(), getReturnValue().getCanDoActionMessages()));
}
#end_block

#method_before
@Override
public Map<Guid, VdcObjectType> getPermissionCheckSubjects() {
    return Collections.singletonMap(getQuotaId() == null ? null : getQuotaId().getValue(), VdcObjectType.Quota);
}
#method_after
@Override
public Map<Guid, VdcObjectType> getPermissionCheckSubjects() {
    return Collections.singletonMap(getStoragePoolId() == null ? null : getStoragePoolId().getValue(), VdcObjectType.StoragePool);
}
#end_block

#method_before
private void setQuotaParameter() {
    Quota quotaParameter = getParameters().getQuota();
    setQuotaId(Guid.NewGuid());
    setQuotaName(quotaParameter.getQuotaName());
    if (quotaParameter.getQuotaStorages() != null) {
        for (QuotaStorage quotaStorage : quotaParameter.getQuotaStorages()) {
            quotaStorage.setQuotaId(getQuotaId());
            quotaStorage.setQuotaStorageId(Guid.NewGuid());
        }
    }
    if (quotaParameter.getQuotaVdsGroups() != null) {
        for (QuotaVdsGroup quotaVdsGroup : quotaParameter.getQuotaVdsGroups()) {
            quotaVdsGroup.setQuotaId(getQuotaId());
            quotaVdsGroup.setQuotaVdsGroupId(Guid.NewGuid());
        }
    }
    setQuota(quotaParameter);
}
#method_after
private void setQuotaParameter() {
    Quota quotaParameter = getParameters().getQuota();
    quotaParameter.setId(Guid.NewGuid());
    setStoragePoolId(quotaParameter.getStoragePoolId());
    setQuotaName(quotaParameter.getQuotaName());
    if (quotaParameter.getQuotaStorages() != null) {
        for (QuotaStorage quotaStorage : quotaParameter.getQuotaStorages()) {
            quotaStorage.setQuotaId(getQuotaId());
            quotaStorage.setQuotaStorageId(Guid.NewGuid());
        }
    }
    if (quotaParameter.getQuotaVdsGroups() != null) {
        for (QuotaVdsGroup quotaVdsGroup : quotaParameter.getQuotaVdsGroups()) {
            quotaVdsGroup.setQuotaId(getQuotaId());
            quotaVdsGroup.setQuotaVdsGroupId(Guid.NewGuid());
        }
    }
    setQuota(quotaParameter);
}
#end_block

