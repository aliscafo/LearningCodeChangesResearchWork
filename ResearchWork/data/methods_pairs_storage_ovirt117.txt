595
#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = false;
    _oldVds = getVdsDAO().get(getVdsId());
    if (_oldVds != null && getParameters().getVdsStaticData() != null) {
        String compatibilityVersion = _oldVds.getVdsGroupCompatibilityVersion().toString();
        if (VdsHandler.isUpdateValid(getParameters().getVdsStaticData(), _oldVds.getStaticData(), _oldVds.getStatus())) {
            if ("".equals(getParameters().getVdsStaticData().getName())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
            String vdsName = getParameters().getvds().getName();
            String hostName = getParameters().getvds().getHostName();
            int maxVdsNameLength = Config.<Integer>getValue(ConfigValues.MaxVdsNameLength);
            // check that VDS name is not null or empty
            if (vdsName == null || vdsName.isEmpty()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
                returnValue = false;
            // check that VDS name is not too long
            } else if (vdsName.length() > maxVdsNameLength) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
                returnValue = false;
            } else if (_oldVds.getStatus() != VDSStatus.InstallFailed && !_oldVds.getHostName().equals(hostName)) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_HOSTNAME_CANNOT_CHANGE);
                returnValue = false;
            } else // check if a name is updated to an existing vds name
            if (!StringUtils.equalsIgnoreCase(_oldVds.getName(), getParameters().getVdsStaticData().getName()) && getVdsDAO().getByName(vdsName) != null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            } else if (!StringUtils.equalsIgnoreCase(_oldVds.getHostName(), getParameters().getVdsStaticData().getHostName()) && getVdsDAO().getAllForHostname(hostName).size() != 0) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST);
            } else if (getParameters().getInstallVds() && _oldVds.getStatus() != VDSStatus.Maintenance && _oldVds.getStatus() != VDSStatus.NonOperational && _oldVds.getStatus() != VDSStatus.InstallFailed && _oldVds.getStatus() != VDSStatus.InstallingOS) {
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_STATUS_ILLEGAL);
            } else if (getParameters().getInstallVds() && getParameters().getAuthMethod() == AuthenticationMethod.Password && StringUtils.isEmpty(getParameters().getPassword()) && getParameters().getVdsStaticData().getVdsType() == VDSType.VDS) {
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
            } else if (!getParameters().getInstallVds() && _oldVds.getPort() != getParameters().getVdsStaticData().getPort()) {
                addCanDoActionMessage(VdcBllMessages.VDS_PORT_CHANGE_REQUIRE_INSTALL);
            } else if (!_oldVds.getVdsGroupId().equals(getParameters().getVdsStaticData().getVdsGroupId())) {
                // Forbid updating group id - this must be done through
                // ChangeVDSClusterCommand
                // This is due to permission check that must be done both on
                // the VDS and on the VDSGroup
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_UPDATE_CLUSTER);
            } else if (getParameters().getInstallVds() && getParameters().getNetworkProviderId() != null) {
                NetworkProviderValidator validator = new NetworkProviderValidator(getParameters().getNetworkProviderId(), getParameters().getNetworkMappings());
                returnValue = validate(validator.providerExists()) && validate(validator.providerTypeValid()) && validate(validator.networkMappingsIsSet()) && validate(validator.messagingBrokerIsSet());
            } else {
                returnValue = true;
            }
            // if all ok check PM is legal
            returnValue = returnValue && IsPowerManagementLegal(getParameters().getVdsStaticData(), compatibilityVersion);
        } else {
            addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = false;
    _oldVds = getVdsDAO().get(getVdsId());
    if (_oldVds != null && getParameters().getVdsStaticData() != null) {
        String compatibilityVersion = _oldVds.getVdsGroupCompatibilityVersion().toString();
        if (VdsHandler.isUpdateValid(getParameters().getVdsStaticData(), _oldVds.getStaticData(), _oldVds.getStatus())) {
            if ("".equals(getParameters().getVdsStaticData().getName())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
            String vdsName = getParameters().getvds().getName();
            String hostName = getParameters().getvds().getHostName();
            int maxVdsNameLength = Config.<Integer>getValue(ConfigValues.MaxVdsNameLength);
            // check that VDS name is not null or empty
            if (vdsName == null || vdsName.isEmpty()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
                returnValue = false;
            // check that VDS name is not too long
            } else if (vdsName.length() > maxVdsNameLength) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
                returnValue = false;
            } else if (_oldVds.getStatus() != VDSStatus.InstallFailed && !_oldVds.getHostName().equals(hostName)) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_HOSTNAME_CANNOT_CHANGE);
                returnValue = false;
            } else // check if a name is updated to an existing vds name
            if (!StringUtils.equalsIgnoreCase(_oldVds.getName(), getParameters().getVdsStaticData().getName()) && getVdsDAO().getByName(vdsName) != null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            } else if (!StringUtils.equalsIgnoreCase(_oldVds.getHostName(), getParameters().getVdsStaticData().getHostName()) && getVdsDAO().getAllForHostname(hostName).size() != 0) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST);
            } else if (getParameters().getInstallVds() && _oldVds.getStatus() != VDSStatus.Maintenance && _oldVds.getStatus() != VDSStatus.NonOperational && _oldVds.getStatus() != VDSStatus.InstallFailed && _oldVds.getStatus() != VDSStatus.InstallingOS) {
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_STATUS_ILLEGAL);
            } else if (getParameters().getInstallVds() && getParameters().getAuthMethod() == AuthenticationMethod.Password && StringUtils.isEmpty(getParameters().getPassword()) && getParameters().getVdsStaticData().getVdsType() == VDSType.VDS) {
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
            } else if (!getParameters().getInstallVds() && _oldVds.getPort() != getParameters().getVdsStaticData().getPort()) {
                addCanDoActionMessage(VdcBllMessages.VDS_PORT_CHANGE_REQUIRE_INSTALL);
            } else if (!_oldVds.getVdsGroupId().equals(getParameters().getVdsStaticData().getVdsGroupId())) {
                // Forbid updating group id - this must be done through
                // ChangeVDSClusterCommand
                // This is due to permission check that must be done both on
                // the VDS and on the VDSGroup
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_UPDATE_CLUSTER);
            } else if (getParameters().getInstallVds() && getParameters().getNetworkProviderId() != null) {
                returnValue = validateNetworkProviderProperties(getParameters().getNetworkProviderId(), getParameters().getNetworkMappings());
            } else {
                returnValue = true;
            }
            // if all ok check PM is legal
            returnValue = returnValue && IsPowerManagementLegal(getParameters().getVdsStaticData(), compatibilityVersion);
        } else {
            addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    updateVdsData();
    if (NeedToUpdateVdsBroker()) {
        initializeVds();
    }
    if (getParameters().getInstallVds()) {
        InstallVdsParameters tempVar = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        tempVar.setIsReinstallOrUpgrade(getParameters().getIsReinstallOrUpgrade());
        tempVar.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        tempVar.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        tempVar.setNetworkProviderId(getParameters().getNetworkProviderId());
        tempVar.setNetworkMappings(getParameters().getNetworkMappings());
        tempVar.setAuthMethod(getParameters().getAuthMethod());
        ArrayList<VdcReturnValueBase> resultList = runInternalMultipleActions(actionType, new ArrayList<VdcActionParametersBase>(Arrays.asList(tempVar)));
        // status, therefore needed to fail the command to revert the status.
        if (!resultList.isEmpty()) {
            VdcReturnValueBase vdcReturnValueBase = resultList.get(0);
            if (vdcReturnValueBase != null && !vdcReturnValueBase.getCanDoAction()) {
                ArrayList<String> canDoActionMessages = vdcReturnValueBase.getCanDoActionMessages();
                if (!canDoActionMessages.isEmpty()) {
                    // add can do action messages to return value so error messages
                    // are returned back to the client
                    getReturnValue().getCanDoActionMessages().addAll(canDoActionMessages);
                    log.errorFormat("Installation/upgrade of Host {0},{1} failed due to: {2} ", getVdsId(), getVdsName(), StringUtils.join(Backend.getInstance().getErrorsTranslator().TranslateErrorText(canDoActionMessages), ","));
                }
                // set can do action to false so can do action messages are
                // returned back to client
                getReturnValue().setCanDoAction(false);
                setSucceeded(false);
                // add old vds dynamic data to compensation context. This
                // way the status will revert back to what it was before
                // starting installation process
                getCompensationContext().snapshotEntityStatus(_oldVds.getDynamicData());
                getCompensationContext().stateChanged();
                return;
            }
        }
    }
    // set clusters network to be operational (if needed)
    if (_oldVds.getStatus() == VDSStatus.Up) {
        List<NetworkCluster> networkClusters = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(_oldVds.getVdsGroupId());
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(_oldVds.getVdsGroupId());
        for (NetworkCluster item : networkClusters) {
            for (Network net : networks) {
                if (net.getId().equals(item.getNetworkId())) {
                    NetworkClusterHelper.setStatus(_oldVds.getVdsGroupId(), net);
                }
            }
        }
    }
    AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
    TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    updateVdsData();
    if (NeedToUpdateVdsBroker()) {
        initializeVds();
    }
    if (getParameters().getInstallVds()) {
        InstallVdsParameters tempVar = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        tempVar.setIsReinstallOrUpgrade(getParameters().getIsReinstallOrUpgrade());
        tempVar.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        tempVar.setActivateHost(getParameters().getActivateHost());
        tempVar.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        tempVar.setNetworkProviderId(getParameters().getNetworkProviderId());
        tempVar.setNetworkMappings(getParameters().getNetworkMappings());
        tempVar.setAuthMethod(getParameters().getAuthMethod());
        ArrayList<VdcReturnValueBase> resultList = runInternalMultipleActions(actionType, new ArrayList<VdcActionParametersBase>(Arrays.asList(tempVar)));
        // status, therefore needed to fail the command to revert the status.
        if (!resultList.isEmpty()) {
            VdcReturnValueBase vdcReturnValueBase = resultList.get(0);
            if (vdcReturnValueBase != null && !vdcReturnValueBase.getCanDoAction()) {
                ArrayList<String> canDoActionMessages = vdcReturnValueBase.getCanDoActionMessages();
                if (!canDoActionMessages.isEmpty()) {
                    // add can do action messages to return value so error messages
                    // are returned back to the client
                    getReturnValue().getCanDoActionMessages().addAll(canDoActionMessages);
                    log.errorFormat("Installation/upgrade of Host {0},{1} failed due to: {2} ", getVdsId(), getVdsName(), StringUtils.join(Backend.getInstance().getErrorsTranslator().TranslateErrorText(canDoActionMessages), ","));
                }
                // set can do action to false so can do action messages are
                // returned back to client
                getReturnValue().setCanDoAction(false);
                setSucceeded(false);
                // add old vds dynamic data to compensation context. This
                // way the status will revert back to what it was before
                // starting installation process
                getCompensationContext().snapshotEntityStatus(_oldVds.getDynamicData());
                getCompensationContext().stateChanged();
                return;
            }
        }
    }
    // set clusters network to be operational (if needed)
    if (_oldVds.getStatus() == VDSStatus.Up) {
        List<NetworkCluster> networkClusters = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(_oldVds.getVdsGroupId());
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(_oldVds.getVdsGroupId());
        for (NetworkCluster item : networkClusters) {
            for (Network net : networks) {
                if (net.getId().equals(item.getNetworkId())) {
                    NetworkClusterHelper.setStatus(_oldVds.getVdsGroupId(), net);
                }
            }
        }
    }
    AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
    TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.errorFormat("Failed to remove duplicated oVirt entry with id {0}. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getParameters().getAddProvisioned()) {
        HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(getHostProvider()));
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword());
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVds(getParameters().getvds());
        logable.addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        AuditLogDirector.log(logable, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getVdsGroup().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initializeVds(true);
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().getAddPending() && !getParameters().getAddProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        installVdsParameters.setNetworkProviderId(getParameters().getNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                runInternalAction(VdcActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.errorFormat("Failed to remove duplicated oVirt entry with id {0}. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getParameters().getAddProvisioned()) {
        HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(getHostProvider()));
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword());
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVds(getParameters().getvds());
        logable.addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        AuditLogDirector.log(logable, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getVdsGroup().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initializeVds(true);
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().getAddPending() && !getParameters().getAddProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setActivateHost(getParameters().getActivateHost());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        installVdsParameters.setNetworkProviderId(getParameters().getNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                runInternalAction(VdcActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    setVdsGroupId(getParameters().getVdsStaticData().getVdsGroupId());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    boolean returnValue = validateVdsGroup();
    if (returnValue) {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getName();
        String hostName = vds.getHostName();
        int maxVdsNameLength = Config.<Integer>getValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
        } else if (getVdsDAO().getByName(vdsName) != null) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        } else if (getVdsDAO().getAllForHostname(hostName).size() != 0) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST);
        } else if (!ValidationUtils.validatePort(vds.getSshPort())) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_PORT);
        } else if ((StringUtils.isBlank(vds.getSshUsername())) || (vds.getSshUsername().length() > BusinessEntitiesDefinitions.USER_LOGIN_NAME_SIZE)) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_USERNAME);
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !EngineEncryptionUtils.haveKey()) {
                returnValue = failCanDoAction(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
            } else if (!getParameters().getAddPending() && (getParameters().getAuthMethod() == AuthenticationMethod.Password) && StringUtils.isEmpty(getParameters().getPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                returnValue = failCanDoAction(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
            } else if (!isPowerManagementLegal()) {
                returnValue = false;
            } else {
                returnValue = returnValue && canConnect(vds);
            }
        }
    }
    if (returnValue && getParameters().getNetworkProviderId() != null) {
        NetworkProviderValidator validator = new NetworkProviderValidator(getParameters().getNetworkProviderId(), getParameters().getNetworkMappings());
        returnValue = validate(validator.providerExists()) && validate(validator.providerTypeValid()) && validate(validator.networkMappingsIsSet()) && validate(validator.messagingBrokerIsSet());
    }
    if (returnValue && isGlusterSupportEnabled()) {
        if (clusterHasServers()) {
            VDS upServer = getClusterUtils().getUpServer(getVdsGroupId());
            if (upServer == null) {
                returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
            }
        }
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    setVdsGroupId(getParameters().getVdsStaticData().getVdsGroupId());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    boolean returnValue = validateVdsGroup();
    if (returnValue) {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getName();
        String hostName = vds.getHostName();
        int maxVdsNameLength = Config.<Integer>getValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
        } else if (getVdsDAO().getByName(vdsName) != null) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        } else if (getVdsDAO().getAllForHostname(hostName).size() != 0) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST);
        } else if (!ValidationUtils.validatePort(vds.getSshPort())) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_PORT);
        } else if ((StringUtils.isBlank(vds.getSshUsername())) || (vds.getSshUsername().length() > BusinessEntitiesDefinitions.USER_LOGIN_NAME_SIZE)) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_USERNAME);
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !EngineEncryptionUtils.haveKey()) {
                returnValue = failCanDoAction(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
            } else if (!getParameters().getAddPending() && (getParameters().getAuthMethod() == AuthenticationMethod.Password) && StringUtils.isEmpty(getParameters().getPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                returnValue = failCanDoAction(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
            } else if (!isPowerManagementLegal()) {
                returnValue = false;
            } else {
                returnValue = returnValue && canConnect(vds);
            }
        }
    }
    if (returnValue && getParameters().getNetworkProviderId() != null) {
        returnValue = validateNetworkProviderProperties(getParameters().getNetworkProviderId(), getParameters().getNetworkMappings());
    }
    if (returnValue && isGlusterSupportEnabled()) {
        if (clusterHasServers()) {
            VDS upServer = getClusterUtils().getUpServer(getVdsGroupId());
            if (upServer == null) {
                returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
@Test
public void testAllDomainsHaveSpaceForNewDisksFailure() {
    setUpGeneralValidations();
    setUpDiskValidations();
    List disksList = getNonEmptyDiskList();
    doReturn(disksList).when(cmd).getDisksList();
    doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN)).when(multipleStorageDomainsValidator).allDomainsHaveSpaceForNewDisks(disksList);
    assertFalse(cmd.canDoAction());
    verify(multipleStorageDomainsValidator).allDomainsHaveSpaceForNewDisks(disksList);
    assertTrue(cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN.name()));
}
#method_after
@Test
public void testAllDomainsHaveSpaceForNewDisksFailure() {
    setUpGeneralValidations();
    setUpDiskValidations();
    List<DiskImage> disksList = getNonEmptyDiskList();
    doReturn(disksList).when(cmd).getDisksList();
    doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN)).when(multipleStorageDomainsValidator).allDomainsHaveSpaceForNewDisks(disksList);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN);
    verify(multipleStorageDomainsValidator).allDomainsHaveSpaceForNewDisks(disksList);
}
#end_block

#method_before
@Test
public void testAllDomainsHaveSpaceForNewDisksSuccess() {
    setUpGeneralValidations();
    setUpDiskValidations();
    List disksList = getNonEmptyDiskList();
    doReturn(disksList).when(cmd).getDisksList();
    doReturn(ValidationResult.VALID).when(multipleStorageDomainsValidator).allDomainsHaveSpaceForNewDisks(disksList);
    assertTrue(cmd.canDoAction());
    verify(multipleStorageDomainsValidator).allDomainsHaveSpaceForNewDisks(disksList);
}
#method_after
@Test
public void testAllDomainsHaveSpaceForNewDisksSuccess() {
    setUpGeneralValidations();
    setUpDiskValidations();
    List<DiskImage> disksList = getNonEmptyDiskList();
    doReturn(disksList).when(cmd).getDisksList();
    doReturn(ValidationResult.VALID).when(multipleStorageDomainsValidator).allDomainsHaveSpaceForNewDisks(disksList);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(cmd);
    verify(multipleStorageDomainsValidator).allDomainsHaveSpaceForNewDisks(disksList);
}
#end_block

#method_before
private static List<DiskImage> generateDisksList(int size) {
    List<DiskImage> disksList = new ArrayList<>();
    ArrayList<Guid> sdIds = new ArrayList<>();
    sdIds.add(sdId1);
    sdIds.add(sdId2);
    for (int i = 0; i < size; ++i) {
        DiskImage diskImage = new DiskImage();
        diskImage.setImageId(Guid.newGuid());
        diskImage.setStorageIds(sdIds);
        disksList.add(diskImage);
    }
    return disksList;
}
#method_after
private List<DiskImage> generateDisksList(int size) {
    List<DiskImage> disksList = new ArrayList<>();
    ArrayList<Guid> sdIds = new ArrayList<>();
    sdIds.add(sdId1);
    sdIds.add(sdId2);
    for (int i = 0; i < size; ++i) {
        DiskImage diskImage = new DiskImage();
        diskImage.setImageId(Guid.newGuid());
        diskImage.setStorageIds(sdIds);
        disksList.add(diskImage);
    }
    return disksList;
}
#end_block

#method_before
public Map<Guid, List<DiskImage>> getDomainsDisksMap() {
    if (null == domainsDisksMap) {
        return new HashMap<>();
    }
    return domainsDisksMap;
}
#method_after
private Map<Guid, List<DiskImage>> getDomainsDisksMap(List<DiskImage> disksList) {
    Map<Guid, List<DiskImage>> domainsDisksMap = new HashMap<>();
    for (DiskImage disk : disksList) {
        List<Guid> domainIds = disk.getStorageIds();
        for (Guid domainId : domainIds) {
            MultiValueMapUtils.addToMap(domainId, disk, domainsDisksMap);
        }
    }
    return domainsDisksMap;
}
#end_block

#method_before
public ValidationResult allDomainsExistAndActive() {
    return validOrFirstFailure(new ValidatorPredicate() {

        @Override
        public ValidationResult evaluate(StorageDomainValidator validator) {
            return validator.isDomainExistAndActive();
        }
    });
}
#method_after
public ValidationResult allDomainsExistAndActive() {
    return validOrFirstFailure(new ValidatorPredicate() {

        @Override
        public ValidationResult evaluate(Map.Entry<Guid, StorageDomainValidator> entry) {
            return getStorageDomainValidator(entry).isDomainExistAndActive();
        }
    });
}
#end_block

#method_before
public ValidationResult allDomainsWithinThresholds() {
    return validOrFirstFailure(new ValidatorPredicate() {

        @Override
        public ValidationResult evaluate(StorageDomainValidator validator) {
            return validator.isDomainWithinThresholds();
        }
    });
}
#method_after
public ValidationResult allDomainsWithinThresholds() {
    return validOrFirstFailure(new ValidatorPredicate() {

        @Override
        public ValidationResult evaluate(Map.Entry<Guid, StorageDomainValidator> entry) {
            return getStorageDomainValidator(entry).isDomainWithinThresholds();
        }
    });
}
#end_block

#method_before
public ValidationResult allDomainsHaveSpaceForNewDisks(final List<DiskImage> disksList) {
    setDomainsDisksMap(disksList);
    return validOrFirstFailure(new ValidatorPredicate() {

        @Override
        public ValidationResult evaluate(StorageDomainValidator validator) {
            List disksForDomain = getDomainsDisksMap().get(validator.getDomainId());
            return validator.hasSpaceForNewDisks(disksForDomain);
        }
    });
}
#method_after
public ValidationResult allDomainsHaveSpaceForNewDisks(final List<DiskImage> disksList) {
    final Map<Guid, List<DiskImage>> domainsDisksMap = getDomainsDisksMap(disksList);
    return validOrFirstFailure(new ValidatorPredicate() {

        @Override
        public ValidationResult evaluate(Map.Entry<Guid, StorageDomainValidator> entry) {
            Guid sdId = entry.getKey();
            List disksForDomain = domainsDisksMap.get(sdId);
            return getStorageDomainValidator(entry).hasSpaceForNewDisks(disksForDomain);
        }
    });
}
#end_block

#method_before
private ValidationResult validOrFirstFailure(ValidatorPredicate predicate) {
    for (Map.Entry<Guid, StorageDomainValidator> entry : domainValidators.entrySet()) {
        ValidationResult currResult = predicate.evaluate(getStorageDomainValidator(entry));
        if (!currResult.isValid()) {
            return currResult;
        }
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult validOrFirstFailure(ValidatorPredicate predicate) {
    for (Map.Entry<Guid, StorageDomainValidator> entry : domainValidators.entrySet()) {
        ValidationResult currResult = predicate.evaluate(entry);
        if (!currResult.isValid()) {
            return currResult;
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Override
public void edit(final HostInterfaceModel object) {
    driver.edit(object);
    qosWidget.edit(object.getQosModel());
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            HostInterfaceModel model = (HostInterfaceModel) sender;
            String propertyName = ((PropertyChangedEventArgs) args).propertyName;
            if ("BootProtocolsAvailable".equals(propertyName)) {
                // $NON-NLS-1$
                enableDisableBySync(model);
                checkConnectivity.setEnabled(model.getBootProtocolsAvailable());
            }
            if ("NoneBootProtocolAvailable".equals(propertyName)) {
                // $NON-NLS-1$
                bootProtocol.setEnabled(NetworkBootProtocol.NONE, model.getNoneBootProtocolAvailable());
            }
            if ("Message".equals(propertyName)) {
                // $NON-NLS-1$
                message.setText(model.getMessage());
            }
        }
    });
    object.getBondingOptions().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            @SuppressWarnings("unchecked")
            ListModel<Map.Entry<String, EntityModel<String>>> list = (ListModel<Map.Entry<String, EntityModel<String>>>) sender;
            Map.Entry<String, EntityModel<String>> pair = list.getSelectedItem();
            if ("custom".equals(pair.getKey())) {
                // $NON-NLS-1$
                customEditor.setVisible(true);
                String entity = pair.getValue().getEntity();
                // $NON-NLS-1$
                customEditor.asEditor().getSubEditor().setValue(entity == null ? "" : entity);
            } else {
                customEditor.setVisible(false);
            }
        }
    });
    customEditor.asValueBox().addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(ValueChangeEvent<String> event) {
            for (Map.Entry<String, EntityModel<String>> item : object.getBondingOptions().getItems()) {
                if ("custom".equals(item.getKey())) {
                    // $NON-NLS-1$
                    item.getValue().setEntity(event.getValue());
                }
            }
        }
    });
    bondingModeEditor.setVisible(true);
    bondingModeEditor.asWidget().setVisible(true);
    isToSync.setVisible(false);
    isToSyncInfo.setVisible(false);
    displayNetworkChangeWarning.setVisible(false);
}
#method_after
@Override
public void edit(final HostInterfaceModel object) {
    driver.edit(object);
    qosWidget.edit(object.getQosModel());
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            HostInterfaceModel model = (HostInterfaceModel) sender;
            String propertyName = ((PropertyChangedEventArgs) args).propertyName;
            if ("BootProtocolsAvailable".equals(propertyName)) {
                // $NON-NLS-1$
                enableDisableByBootProtocol(model);
                checkConnectivity.setEnabled(model.getBootProtocolsAvailable());
            }
            if ("NoneBootProtocolAvailable".equals(propertyName)) {
                // $NON-NLS-1$
                bootProtocol.setEnabled(NetworkBootProtocol.NONE, model.getNoneBootProtocolAvailable());
            }
            if ("Message".equals(propertyName)) {
                // $NON-NLS-1$
                message.setText(model.getMessage());
            }
        }
    });
    object.getBondingOptions().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            @SuppressWarnings("unchecked")
            ListModel<Map.Entry<String, EntityModel<String>>> list = (ListModel<Map.Entry<String, EntityModel<String>>>) sender;
            Map.Entry<String, EntityModel<String>> pair = list.getSelectedItem();
            if ("custom".equals(pair.getKey())) {
                // $NON-NLS-1$
                customEditor.setVisible(true);
                String entity = pair.getValue().getEntity();
                // $NON-NLS-1$
                customEditor.asEditor().getSubEditor().setValue(entity == null ? "" : entity);
            } else {
                customEditor.setVisible(false);
            }
        }
    });
    customEditor.asValueBox().addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(ValueChangeEvent<String> event) {
            for (Map.Entry<String, EntityModel<String>> item : object.getBondingOptions().getItems()) {
                if ("custom".equals(item.getKey())) {
                    // $NON-NLS-1$
                    item.getValue().setEntity(event.getValue());
                }
            }
        }
    });
    bondingModeEditor.setVisible(true);
    bondingModeEditor.asWidget().setVisible(true);
    isToSync.setVisible(false);
    isToSyncInfo.setVisible(false);
    displayNetworkChangeWarning.setVisible(false);
}
#end_block

#method_before
private boolean updateVmRunTimeInfo(RefObject<VM> vmToUpdate, VmDynamic vmNewDynamicData) {
    boolean returnValue = false;
    if (vmToUpdate.argvalue == null) {
        vmToUpdate.argvalue = getDbFacade().getVmDao().get(vmNewDynamicData.getId());
        // if vm exists in db update info
        if (vmToUpdate.argvalue != null) {
            // TODO: This is done to keep consistency with VmDAO.getById(Guid).
            // It should probably be removed, but some research is required.
            vmToUpdate.argvalue.setInterfaces(getDbFacade().getVmNetworkInterfaceDao().getAllForVm(vmToUpdate.argvalue.getId()));
            _vmDict.put(vmToUpdate.argvalue.getId(), vmToUpdate.argvalue);
            if (vmNewDynamicData.getStatus() == VMStatus.Up) {
                vmToUpdate.argvalue.setMigrationProgressPercent(0);
                addVmStatisticsToList(vmToUpdate.argvalue.getStatisticsData());
                if (!_succededToRunVms.contains(vmToUpdate.argvalue.getId())) {
                    _succededToRunVms.add(vmToUpdate.argvalue.getId());
                }
            }
        }
    }
    if (vmToUpdate.argvalue != null) {
        // check if dynamic data changed - update cache and DB
        List<String> props = ObjectIdentityChecker.GetChangedFields(vmToUpdate.argvalue.getDynamicData(), vmNewDynamicData);
        // remove all fields that should not be checked:
        props.removeAll(UNCHANGEABLE_FIELDS_BY_VDSM);
        if (vmNewDynamicData.getStatus() != VMStatus.Up) {
            props.remove(VmDynamic.APPLICATIONS_LIST_FIELD_NAME);
            vmNewDynamicData.setAppList(vmToUpdate.argvalue.getAppList());
        } else if (props.contains(VmDynamic.STATUS_FIELD_NAME) && vmToUpdate.argvalue.getDynamicData().getStatus() == VMStatus.PreparingForHibernate) {
            vmNewDynamicData.setStatus(VMStatus.PreparingForHibernate);
            props.remove(VmDynamic.STATUS_FIELD_NAME);
        }
        // if anything else changed
        if (!props.isEmpty()) {
            vmToUpdate.argvalue.updateRunTimeDynamicData(vmNewDynamicData, _vds.getId(), _vds.getName());
            returnValue = true;
        }
    } else {
        // line.
        if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
            log.info("VDS::UpdateVmRunTimeInfo Error: found VM on a VDS that is not in the database!");
        }
    }
    return returnValue;
}
#method_after
private boolean updateVmRunTimeInfo(RefObject<VM> vmToUpdate, VmDynamic vmNewDynamicData) {
    boolean returnValue = false;
    if (vmToUpdate.argvalue == null) {
        vmToUpdate.argvalue = getDbFacade().getVmDao().get(vmNewDynamicData.getId());
        // if vm exists in db update info
        if (vmToUpdate.argvalue != null) {
            // TODO: This is done to keep consistency with VmDAO.getById(Guid).
            // It should probably be removed, but some research is required.
            vmToUpdate.argvalue.setInterfaces(getDbFacade().getVmNetworkInterfaceDao().getAllForVm(vmToUpdate.argvalue.getId()));
            _vmDict.put(vmToUpdate.argvalue.getId(), vmToUpdate.argvalue);
            if (vmNewDynamicData.getStatus() == VMStatus.Up) {
                if (!_succededToRunVms.contains(vmToUpdate.argvalue.getId())) {
                    _succededToRunVms.add(vmToUpdate.argvalue.getId());
                }
            }
        }
    }
    if (vmToUpdate.argvalue != null) {
        // check if dynamic data changed - update cache and DB
        List<String> props = ObjectIdentityChecker.GetChangedFields(vmToUpdate.argvalue.getDynamicData(), vmNewDynamicData);
        // remove all fields that should not be checked:
        props.removeAll(UNCHANGEABLE_FIELDS_BY_VDSM);
        if (vmNewDynamicData.getStatus() != VMStatus.Up) {
            props.remove(VmDynamic.APPLICATIONS_LIST_FIELD_NAME);
            vmNewDynamicData.setAppList(vmToUpdate.argvalue.getAppList());
        } else if (props.contains(VmDynamic.STATUS_FIELD_NAME) && vmToUpdate.argvalue.getDynamicData().getStatus() == VMStatus.PreparingForHibernate) {
            vmNewDynamicData.setStatus(VMStatus.PreparingForHibernate);
            props.remove(VmDynamic.STATUS_FIELD_NAME);
        }
        // if anything else changed
        if (!props.isEmpty()) {
            vmToUpdate.argvalue.updateRunTimeDynamicData(vmNewDynamicData, _vds.getId(), _vds.getName());
            returnValue = true;
        }
    } else {
        // line.
        if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
            log.info("VDS::UpdateVmRunTimeInfo Error: found VM on a VDS that is not in the database!");
        }
    }
    return returnValue;
}
#end_block

#method_before
public void makeSortable() {
    makeSortable(new Comparator<T>() {

        SimpleStatusImageComparator imageComparator = new SimpleStatusImageComparator();

        @Override
        public int compare(T o1, T o2) {
            return imageComparator.compare(getImage(o1), getImage(o2));
        }
    });
}
#method_after
public void makeSortable() {
    makeSortable(new Comparator<T>() {

        private final SimpleStatusImageComparator imageComparator = new SimpleStatusImageComparator();

        @Override
        public int compare(T o1, T o2) {
            return imageComparator.compare(getImage(o1), getImage(o2));
        }
    });
}
#end_block

#method_before
public String serialize() {
    StringBuilder builder = new StringBuilder();
    if (getItems() == null) {
        return "";
    }
    for (KeyValueLineModel keyValueLineModel : (List<KeyValueLineModel>) getItems()) {
        String key = keyValueLineModel.getKeys().getSelectedItem();
        if (!isKeyValid(key)) {
            continue;
        }
        builder.append(key);
        builder.append(KEY_VALUE_DELIMETER);
        if (keyValueLineModel.getValue().getIsAvailable()) {
            builder.append(keyValueLineModel.getValue().getEntity());
        } else if (keyValueLineModel.getValues().getIsAvailable()) {
            builder.append(keyValueLineModel.getValues().getSelectedItem());
        }
        builder.append(PROPERTIES_DELIMETER);
    }
    // remove the last delimiter
    return builder.subSequence(0, builder.length() - 1).toString();
}
#method_after
public String serialize() {
    StringBuilder builder = new StringBuilder();
    if (getItems() == null) {
        return "";
    }
    for (KeyValueLineModel keyValueLineModel : (List<KeyValueLineModel>) getItems()) {
        String key = keyValueLineModel.getKeys().getSelectedItem();
        if (!isKeyValid(key)) {
            continue;
        }
        builder.append(key);
        builder.append(KEY_VALUE_DELIMETER);
        if (keyValueLineModel.getValue().getIsAvailable()) {
            builder.append(keyValueLineModel.getValue().getEntity());
        } else if (keyValueLineModel.getValues().getIsAvailable()) {
            builder.append(keyValueLineModel.getValues().getSelectedItem());
        }
        builder.append(PROPERTIES_DELIMETER);
    }
    // remove the last delimiter
    if (builder.toString().endsWith(PROPERTIES_DELIMETER)) {
        return builder.subSequence(0, builder.length() - PROPERTIES_DELIMETER.length()).toString();
    }
    return builder.toString();
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new BrickStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterBrickEntity> serverColumn = new TextColumnWithTooltip<GlusterBrickEntity>() {

        @Override
        public String getValue(GlusterBrickEntity brick) {
            return brick.getServerName();
        }
    };
    serverColumn.makeSortable(new Comparator<GlusterBrickEntity>() {

        @Override
        public int compare(GlusterBrickEntity brick0, GlusterBrickEntity brick1) {
            return brick0.getServerName().compareTo(brick1.getServerName());
        }
    });
    // $NON-NLS-1$
    getTable().addColumn(serverColumn, constants.serverVolumeBrick(), "300px");
    TextColumnWithTooltip<GlusterBrickEntity> directoryColumn = new TextColumnWithTooltip<GlusterBrickEntity>() {

        @Override
        public String getValue(GlusterBrickEntity brick) {
            return brick.getBrickDirectory();
        }
    };
    directoryColumn.makeSortable(new Comparator<GlusterBrickEntity>() {

        @Override
        public int compare(GlusterBrickEntity o1, GlusterBrickEntity o2) {
            return o1.getBrickDirectory().compareTo(o2.getBrickDirectory());
        }
    });
    // $NON-NLS-1$
    getTable().addColumn(directoryColumn, constants.brickDirectoryVolumeBrick(), "400px");
    getTable().addColumn(new PercentColumn<GlusterBrickEntity>() {

        @Override
        protected Integer getProgressValue(GlusterBrickEntity object) {
            if (object.getBrickProperties() == null) {
                return 0;
            }
            BrickProperties brickProperties = object.getBrickProperties();
            return (int) (((brickProperties.getTotalSize() - brickProperties.getFreeSize()) / (brickProperties.getTotalSize())) * 100);
        }
    }, constants.volumeCapacity(), // $NON-NLS-1$
    "60px");
    getTable().addColumn(new VolumeActivityColumn<GlusterBrickEntity>(getActivityCell(constants)), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.addBricksBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getAddBricksCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.removeBricksBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveBricksCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.replaceBrickBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getReplaceBrickCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.advancedDetailsBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getBrickAdvancedDetailsCommand();
        }
    });
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new BrickStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterBrickEntity> serverColumn = new TextColumnWithTooltip<GlusterBrickEntity>() {

        @Override
        public String getValue(GlusterBrickEntity brick) {
            return brick.getServerName();
        }
    };
    serverColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(serverColumn, constants.serverVolumeBrick(), "300px");
    TextColumnWithTooltip<GlusterBrickEntity> directoryColumn = new TextColumnWithTooltip<GlusterBrickEntity>() {

        @Override
        public String getValue(GlusterBrickEntity brick) {
            return brick.getBrickDirectory();
        }
    };
    directoryColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(directoryColumn, constants.brickDirectoryVolumeBrick(), "400px");
    getTable().addColumn(new PercentColumn<GlusterBrickEntity>() {

        @Override
        protected Integer getProgressValue(GlusterBrickEntity object) {
            if (object.getBrickProperties() == null) {
                return 0;
            }
            BrickProperties brickProperties = object.getBrickProperties();
            return (int) (((brickProperties.getTotalSize() - brickProperties.getFreeSize()) / (brickProperties.getTotalSize())) * 100);
        }
    }, constants.volumeCapacity(), // $NON-NLS-1$
    "60px");
    getTable().addColumn(new VolumeActivityColumn<GlusterBrickEntity>(getActivityCell(constants)), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.addBricksBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getAddBricksCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.removeBricksBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveBricksCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.replaceBrickBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getReplaceBrickCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.advancedDetailsBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getBrickAdvancedDetailsCommand();
        }
    });
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<GlusterVolumeOptionEntity> optionKeyColumn = new TextColumnWithTooltip<GlusterVolumeOptionEntity>() {

        @Override
        public String getValue(GlusterVolumeOptionEntity option) {
            return option.getKey();
        }
    };
    optionKeyColumn.makeSortable(new Comparator<GlusterVolumeOptionEntity>() {

        @Override
        public int compare(GlusterVolumeOptionEntity o1, GlusterVolumeOptionEntity o2) {
            return o1.getKey().compareTo(o2.getKey());
        }
    });
    // $NON-NLS-1$
    getTable().addColumn(optionKeyColumn, constants.optionKeyVolumeParameter(), "400px");
    TextColumnWithTooltip<GlusterVolumeOptionEntity> optionValueColumn = new TextColumnWithTooltip<GlusterVolumeOptionEntity>() {

        @Override
        public String getValue(GlusterVolumeOptionEntity option) {
            return option.getValue();
        }
    };
    optionValueColumn.makeSortable(new Comparator<GlusterVolumeOptionEntity>() {

        @Override
        public int compare(GlusterVolumeOptionEntity o1, GlusterVolumeOptionEntity o2) {
            return o1.getValue().compareTo(o2.getValue());
        }
    });
    // $NON-NLS-1$;
    getTable().addColumn(optionValueColumn, constants.optionValueVolumeParameter(), "400px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeOptionEntity>(constants.addVolumeParameter()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getAddParameterCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeOptionEntity>(constants.editVolumeParameter()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditParameterCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeOptionEntity>(constants.resetVolumeParameter()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getResetParameterCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeOptionEntity>(constants.resetAllVolumeParameter()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getResetAllParameterCommand();
        }
    });
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<GlusterVolumeOptionEntity> optionKeyColumn = new TextColumnWithTooltip<GlusterVolumeOptionEntity>() {

        @Override
        public String getValue(GlusterVolumeOptionEntity option) {
            return option.getKey();
        }
    };
    optionKeyColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(optionKeyColumn, constants.optionKeyVolumeParameter(), "400px");
    TextColumnWithTooltip<GlusterVolumeOptionEntity> optionValueColumn = new TextColumnWithTooltip<GlusterVolumeOptionEntity>() {

        @Override
        public String getValue(GlusterVolumeOptionEntity option) {
            return option.getValue();
        }
    };
    optionValueColumn.makeSortable();
    // $NON-NLS-1$;
    getTable().addColumn(optionValueColumn, constants.optionValueVolumeParameter(), "400px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeOptionEntity>(constants.addVolumeParameter()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getAddParameterCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeOptionEntity>(constants.editVolumeParameter()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditParameterCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeOptionEntity>(constants.resetVolumeParameter()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getResetParameterCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeOptionEntity>(constants.resetAllVolumeParameter()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getResetAllParameterCommand();
        }
    });
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new BrickStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterBrickEntity> volNameColumn = new TextColumnWithTooltip<GlusterBrickEntity>() {

        @Override
        public String getValue(GlusterBrickEntity object) {
            return object.getVolumeName();
        }
    };
    volNameColumn.makeSortable(new Comparator<GlusterBrickEntity>() {

        @Override
        public int compare(GlusterBrickEntity o1, GlusterBrickEntity o2) {
            return o1.getVolumeName().compareTo(o2.getVolumeName());
        }
    });
    // $NON-NLS-1$
    getTable().addColumn(volNameColumn, constants.volumeName());
    TextColumnWithTooltip<GlusterBrickEntity> brickDirColumn = new TextColumnWithTooltip<GlusterBrickEntity>() {

        @Override
        public String getValue(GlusterBrickEntity object) {
            return object.getBrickDirectory();
        }
    };
    brickDirColumn.makeSortable(new Comparator<GlusterBrickEntity>() {

        @Override
        public int compare(GlusterBrickEntity o1, GlusterBrickEntity o2) {
            return o1.getBrickDirectory().compareTo(o2.getBrickDirectory());
        }
    });
    // $NON-NLS-1$
    getTable().addColumn(brickDirColumn, constants.brickDirectoryBricks(), "220px");
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new BrickStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterBrickEntity> volNameColumn = new TextColumnWithTooltip<GlusterBrickEntity>() {

        @Override
        public String getValue(GlusterBrickEntity object) {
            return object.getVolumeName();
        }
    };
    volNameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(volNameColumn, constants.volumeName());
    TextColumnWithTooltip<GlusterBrickEntity> brickDirColumn = new TextColumnWithTooltip<GlusterBrickEntity>() {

        @Override
        public String getValue(GlusterBrickEntity object) {
            return object.getBrickDirectory();
        }
    };
    brickDirColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(brickDirColumn, constants.brickDirectoryBricks(), "220px");
}
#end_block

#method_before
private void newVolume() {
    if (getWindow() != null) {
        return;
    }
    VolumeModel volumeModel = new VolumeModel();
    volumeModel.setHelpTag(HelpTag.new_volume);
    // $NON-NLS-1$
    volumeModel.setHashName("new_volume");
    volumeModel.setTitle(ConstantsManager.getInstance().getConstants().newVolumeTitle());
    setWindow(volumeModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VolumeListModel volumeListModel = (VolumeListModel) model;
            VolumeModel innerVolumeModel = (VolumeModel) volumeListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (volumeListModel.getSystemTreeSelectedItem() != null) {
                switch(volumeListModel.getSystemTreeSelectedItem().getType()) {
                    case Volumes:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerVolumeModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerVolumeModel.getCluster().setItems(Arrays.asList(cluster));
                        innerVolumeModel.getCluster().setSelectedItem(cluster);
                        innerVolumeModel.getCluster().setIsChangable(false);
                        innerVolumeModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case Clusters:
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerVolumeModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerVolumeModel.getDataCenter().setItems(dataCenters);
                        innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerVolumeModel.getDataCenter().setItems(dataCenters);
                innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand command = new UICommand("onCreateVolume", volumeListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerVolumeModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", volumeListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerVolumeModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterByClusterServiceList(_asyncQuery, false, true);
}
#method_after
private void newVolume() {
    if (getWindow() != null) {
        return;
    }
    VolumeModel volumeModel = new VolumeModel();
    volumeModel.setHelpTag(HelpTag.new_volume);
    // $NON-NLS-1$
    volumeModel.setHashName("new_volume");
    volumeModel.setTitle(ConstantsManager.getInstance().getConstants().newVolumeTitle());
    setWindow(volumeModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VolumeListModel volumeListModel = (VolumeListModel) model;
            VolumeModel innerVolumeModel = (VolumeModel) volumeListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (volumeListModel.getSystemTreeSelectedItem() != null) {
                switch(volumeListModel.getSystemTreeSelectedItem().getType()) {
                    case Volumes:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerVolumeModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerVolumeModel.getCluster().setItems(Arrays.asList(cluster));
                        innerVolumeModel.getCluster().setSelectedItem(cluster);
                        innerVolumeModel.getCluster().setIsChangable(false);
                        innerVolumeModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case Clusters:
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerVolumeModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerVolumeModel.getDataCenter().setItems(dataCenters);
                        innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerVolumeModel.getDataCenter().setItems(dataCenters);
                innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand command = new UICommand("onCreateVolume", volumeListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerVolumeModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", volumeListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerVolumeModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterByClusterServiceList(_asyncQuery, false, true);
}
#end_block

#method_before
private void showRebalanceStatus() {
    if (getSelectedItem() == null) {
        return;
    }
    final ConfirmationModel cModel = new ConfirmationModel();
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    setConfirmWindow(cModel);
    cModel.setTitle(ConstantsManager.getInstance().getConstants().rebalanceStatusTitle());
    // $NON-NLS-1$
    cModel.startProgress(ConstantsManager.getInstance().getConstants().fetchingDataMessage());
    cModel.setHelpTag(HelpTag.volume_rebalance_status);
    // $NON-NLS-1$
    cModel.setHashName("volume_rebalance_status");
    // $NON-NLS-1$
    final UICommand rebalanceStatusOk = new UICommand("rebalanceNotStarted", VolumeListModel.this);
    rebalanceStatusOk.setTitle(ConstantsManager.getInstance().getConstants().ok());
    rebalanceStatusOk.setIsCancel(true);
    cModel.getCommands().add(rebalanceStatusOk);
    AsyncDataProvider.getGlusterRebalanceStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            cModel.stopProgress();
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            GlusterVolumeTaskStatusEntity rebalanceStatusEntity = vdcValue.getReturnValue();
            if ((rebalanceStatusEntity == null) || !(vdcValue.getSucceeded())) {
                cModel.setMessage(ConstantsManager.getInstance().getMessages().rebalanceStatusFailed(volumeEntity.getName()));
            } else {
                setConfirmWindow(null);
                if (getWindow() == null) {
                    VolumeRebalanceStatusModel rebalanceStatusModel = new VolumeRebalanceStatusModel(volumeEntity);
                    rebalanceStatusModel.setTitle(ConstantsManager.getInstance().getConstants().volumeRebalanceStatusTitle());
                    setWindow(rebalanceStatusModel);
                    rebalanceStatusModel.setHelpTag(HelpTag.volume_rebalance_status);
                    // $NON-NLS-1$
                    rebalanceStatusModel.setHashName("volume_rebalance_status");
                    rebalanceStatusModel.getVolume().setEntity(volumeEntity.getName());
                    rebalanceStatusModel.getCluster().setEntity(volumeEntity.getVdsGroupName());
                    // $NON-NLS-1$
                    UICommand stopRebalanceFromStatus = new UICommand("stop_rebalance_from_status", VolumeListModel.this);
                    stopRebalanceFromStatus.setTitle(ConstantsManager.getInstance().getConstants().stopRebalance());
                    rebalanceStatusModel.getCommands().add(stopRebalanceFromStatus);
                    rebalanceStatusModel.setStopReblanceFromStatus(stopRebalanceFromStatus);
                    // $NON-NLS-1$
                    UICommand cancelRebalance = new UICommand("CancelRebalanceStatus", VolumeListModel.this);
                    cancelRebalance.setTitle(ConstantsManager.getInstance().getConstants().close());
                    cancelRebalance.setIsCancel(true);
                    rebalanceStatusModel.getCommands().add(cancelRebalance);
                    rebalanceStatusModel.showStatus(rebalanceStatusEntity);
                } else {
                    VolumeRebalanceStatusModel statusModel = (VolumeRebalanceStatusModel) getWindow();
                    statusModel.getCommands().get(0).setIsExecutionAllowed(false);
                    statusModel.showStatus(rebalanceStatusEntity);
                }
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId());
}
#method_after
private void showRebalanceStatus() {
    if (getSelectedItem() == null) {
        return;
    }
    final ConfirmationModel cModel = new ConfirmationModel();
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    setConfirmWindow(cModel);
    cModel.setTitle(ConstantsManager.getInstance().getConstants().rebalanceStatusTitle());
    // $NON-NLS-1$
    cModel.startProgress(ConstantsManager.getInstance().getConstants().fetchingDataMessage());
    cModel.setHelpTag(HelpTag.volume_rebalance_status);
    // $NON-NLS-1$
    cModel.setHashName("volume_rebalance_status");
    // $NON-NLS-1$
    final UICommand rebalanceStatusOk = new UICommand("rebalanceNotStarted", VolumeListModel.this);
    rebalanceStatusOk.setTitle(ConstantsManager.getInstance().getConstants().ok());
    rebalanceStatusOk.setIsCancel(true);
    cModel.getCommands().add(rebalanceStatusOk);
    AsyncDataProvider.getInstance().getGlusterRebalanceStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            cModel.stopProgress();
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            GlusterVolumeTaskStatusEntity rebalanceStatusEntity = vdcValue.getReturnValue();
            if ((rebalanceStatusEntity == null) || !(vdcValue.getSucceeded())) {
                cModel.setMessage(ConstantsManager.getInstance().getMessages().rebalanceStatusFailed(volumeEntity.getName()));
            } else {
                setConfirmWindow(null);
                if (getWindow() == null) {
                    VolumeRebalanceStatusModel rebalanceStatusModel = new VolumeRebalanceStatusModel(volumeEntity);
                    rebalanceStatusModel.setTitle(ConstantsManager.getInstance().getConstants().volumeRebalanceStatusTitle());
                    setWindow(rebalanceStatusModel);
                    rebalanceStatusModel.setHelpTag(HelpTag.volume_rebalance_status);
                    // $NON-NLS-1$
                    rebalanceStatusModel.setHashName("volume_rebalance_status");
                    rebalanceStatusModel.getVolume().setEntity(volumeEntity.getName());
                    rebalanceStatusModel.getCluster().setEntity(volumeEntity.getVdsGroupName());
                    // $NON-NLS-1$
                    UICommand stopRebalanceFromStatus = new UICommand("stop_rebalance_from_status", VolumeListModel.this);
                    stopRebalanceFromStatus.setTitle(ConstantsManager.getInstance().getConstants().stopRebalance());
                    rebalanceStatusModel.getCommands().add(stopRebalanceFromStatus);
                    rebalanceStatusModel.setStopReblanceFromStatus(stopRebalanceFromStatus);
                    // $NON-NLS-1$
                    UICommand cancelRebalance = new UICommand("CancelRebalanceStatus", VolumeListModel.this);
                    cancelRebalance.setTitle(ConstantsManager.getInstance().getConstants().close());
                    cancelRebalance.setIsCancel(true);
                    rebalanceStatusModel.getCommands().add(cancelRebalance);
                    rebalanceStatusModel.showStatus(rebalanceStatusEntity);
                } else {
                    VolumeRebalanceStatusModel statusModel = (VolumeRebalanceStatusModel) getWindow();
                    statusModel.getCommands().get(0).setIsExecutionAllowed(false);
                    statusModel.showStatus(rebalanceStatusEntity);
                }
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId());
}
#end_block

#method_before
private void optimizeVolumesForVirtStore(final List<Guid> volumeList) {
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, final Object result) {
            AsyncQuery aQueryInner = new AsyncQuery();
            aQueryInner.setModel(this);
            aQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object modelInner, final Object resultInner) {
                    AsyncQuery aQueryInner1 = new AsyncQuery();
                    aQueryInner1.setModel(this);
                    aQueryInner1.asyncCallback = new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object modelInner1, Object resultInner1) {
                            String optionGroupVirt = (String) result;
                            String optionOwnerUserVirt = (String) resultInner;
                            String optionOwnerGroupVirt = (String) resultInner1;
                            ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
                            for (Guid volumeId : volumeList) {
                                GlusterVolumeOptionEntity optionGroup = new GlusterVolumeOptionEntity();
                                optionGroup.setVolumeId(volumeId);
                                // $NON-NLS-1$
                                optionGroup.setKey("group");
                                optionGroup.setValue(optionGroupVirt);
                                list.add(new GlusterVolumeOptionParameters(optionGroup));
                                GlusterVolumeOptionEntity optionOwnerUser = new GlusterVolumeOptionEntity();
                                optionOwnerUser.setVolumeId(volumeId);
                                // $NON-NLS-1$
                                optionOwnerUser.setKey("storage.owner-uid");
                                optionOwnerUser.setValue(optionOwnerUserVirt);
                                list.add(new GlusterVolumeOptionParameters(optionOwnerUser));
                                GlusterVolumeOptionEntity optionOwnerGroup = new GlusterVolumeOptionEntity();
                                optionOwnerGroup.setVolumeId(volumeId);
                                // $NON-NLS-1$
                                optionOwnerGroup.setKey("storage.owner-gid");
                                optionOwnerGroup.setValue(optionOwnerGroupVirt);
                                list.add(new GlusterVolumeOptionParameters(optionOwnerGroup));
                            }
                            Frontend.getInstance().runMultipleAction(VdcActionType.SetGlusterVolumeOption, list);
                        }
                    };
                    AsyncDataProvider.getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionOwnerGroupVirtValue, AsyncDataProvider.getDefaultConfigurationVersion()), aQueryInner1);
                }
            };
            AsyncDataProvider.getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionOwnerUserVirtValue, AsyncDataProvider.getDefaultConfigurationVersion()), aQueryInner);
        }
    };
    AsyncDataProvider.getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionGroupVirtValue, AsyncDataProvider.getDefaultConfigurationVersion()), aQuery);
}
#method_after
private void optimizeVolumesForVirtStore(final List<Guid> volumeList) {
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, final Object result) {
            AsyncQuery aQueryInner = new AsyncQuery();
            aQueryInner.setModel(this);
            aQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object modelInner, final Object resultInner) {
                    AsyncQuery aQueryInner1 = new AsyncQuery();
                    aQueryInner1.setModel(this);
                    aQueryInner1.asyncCallback = new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object modelInner1, Object resultInner1) {
                            String optionGroupVirt = (String) result;
                            String optionOwnerUserVirt = (String) resultInner;
                            String optionOwnerGroupVirt = (String) resultInner1;
                            ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
                            for (Guid volumeId : volumeList) {
                                GlusterVolumeOptionEntity optionGroup = new GlusterVolumeOptionEntity();
                                optionGroup.setVolumeId(volumeId);
                                // $NON-NLS-1$
                                optionGroup.setKey("group");
                                optionGroup.setValue(optionGroupVirt);
                                list.add(new GlusterVolumeOptionParameters(optionGroup));
                                GlusterVolumeOptionEntity optionOwnerUser = new GlusterVolumeOptionEntity();
                                optionOwnerUser.setVolumeId(volumeId);
                                // $NON-NLS-1$
                                optionOwnerUser.setKey("storage.owner-uid");
                                optionOwnerUser.setValue(optionOwnerUserVirt);
                                list.add(new GlusterVolumeOptionParameters(optionOwnerUser));
                                GlusterVolumeOptionEntity optionOwnerGroup = new GlusterVolumeOptionEntity();
                                optionOwnerGroup.setVolumeId(volumeId);
                                // $NON-NLS-1$
                                optionOwnerGroup.setKey("storage.owner-gid");
                                optionOwnerGroup.setValue(optionOwnerGroupVirt);
                                list.add(new GlusterVolumeOptionParameters(optionOwnerGroup));
                            }
                            Frontend.getInstance().runMultipleAction(VdcActionType.SetGlusterVolumeOption, list);
                        }
                    };
                    AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionOwnerGroupVirtValue, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), aQueryInner1);
                }
            };
            AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionOwnerUserVirtValue, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), aQueryInner);
        }
    };
    AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionGroupVirtValue, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
private void getAttachedTagsToSelectedVMs(TagListModel model) {
    ArrayList<Guid> vmIds = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    attachedTagsToEntities = new HashMap<Guid, Boolean>();
    allAttachedTags = new ArrayList<Tags>();
    selectedItemsCounter = 0;
    for (Guid id : vmIds) {
        AsyncDataProvider.getAttachedTagsToVm(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                VmListModel vmListModel = (VmListModel) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                vmListModel.allAttachedTags.addAll((ArrayList<Tags>) returnValue);
                vmListModel.selectedItemsCounter++;
                if (vmListModel.selectedItemsCounter == vmListModel.getSelectedItems().size()) {
                    postGetAttachedTags(vmListModel, tagListModel);
                }
            }
        }), id);
    }
}
#method_after
private void getAttachedTagsToSelectedVMs(TagListModel model) {
    ArrayList<Guid> vmIds = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    attachedTagsToEntities = new HashMap<Guid, Boolean>();
    allAttachedTags = new ArrayList<Tags>();
    selectedItemsCounter = 0;
    for (Guid id : vmIds) {
        AsyncDataProvider.getInstance().getAttachedTagsToVm(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                VmListModel vmListModel = (VmListModel) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                vmListModel.allAttachedTags.addAll((ArrayList<Tags>) returnValue);
                vmListModel.selectedItemsCounter++;
                if (vmListModel.selectedItemsCounter == vmListModel.getSelectedItems().size()) {
                    postGetAttachedTags(vmListModel, tagListModel);
                }
            }
        }), id);
    }
}
#end_block

#method_before
private void guide() {
    VmGuideModel model = new VmGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVirtualMachineGuideMeTitle());
    model.setHelpTag(HelpTag.new_virtual_machine___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_virtual_machine_-_guide_me");
    if (getGuideContext() == null) {
        VM vm = (VM) getSelectedItem();
        setGuideContext(vm.getId());
    }
    AsyncDataProvider.getVmById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            VmGuideModel model = (VmGuideModel) vmListModel.getWindow();
            model.setEntity(returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", vmListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#method_after
private void guide() {
    VmGuideModel model = new VmGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVirtualMachineGuideMeTitle());
    model.setHelpTag(HelpTag.new_virtual_machine___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_virtual_machine_-_guide_me");
    if (getGuideContext() == null) {
        VM vm = (VM) getSelectedItem();
        setGuideContext(vm.getId());
    }
    AsyncDataProvider.getInstance().getVmById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            VmGuideModel model = (VmGuideModel) vmListModel.getWindow();
            model.setEntity(returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", vmListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#end_block

#method_before
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior());
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setCustomPropertiesKeysList(AsyncDataProvider.getCustomPropertiesList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.initialize(getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior());
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.initialize(getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void edit() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            editedVm = (VM) result;
            vmInitLoaded(editedVm);
        }
    };
    if (vm.isNextRunConfigurationExists()) {
        AsyncDataProvider.getVmNextRunConfiguration(getVmInitQuery, vm.getId());
    } else {
        AsyncDataProvider.getVmById(getVmInitQuery, vm.getId());
    }
}
#method_after
private void edit() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            editedVm = (VM) result;
            vmInitLoaded(editedVm);
        }
    };
    if (vm.isNextRunConfigurationExists()) {
        AsyncDataProvider.getInstance().getVmNextRunConfiguration(getVmInitQuery, vm.getId());
    } else {
        AsyncDataProvider.getInstance().getVmById(getVmInitQuery, vm.getId());
    }
}
#end_block

#method_before
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(AsyncDataProvider.getCustomPropertiesList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("OnSave", this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
}
#method_after
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("OnSave", this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
}
#end_block

#method_before
private void getTemplatesNotPresentOnExportDomain() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((StorageDomain) model.getStorage().getSelectedItem()).getId();
    AsyncDataProvider.getDataCentersByStorageDomain(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            ArrayList<StoragePool> storagePools = (ArrayList<StoragePool>) returnValue;
            StoragePool storagePool = storagePools.size() > 0 ? storagePools.get(0) : null;
            vmListModel.postGetTemplatesNotPresentOnExportDomain(storagePool);
        }
    }), storageDomainId);
}
#method_after
private void getTemplatesNotPresentOnExportDomain() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((StorageDomain) model.getStorage().getSelectedItem()).getId();
    AsyncDataProvider.getInstance().getDataCentersByStorageDomain(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            ArrayList<StoragePool> storagePools = (ArrayList<StoragePool>) returnValue;
            StoragePool storagePool = storagePools.size() > 0 ? storagePools.get(0) : null;
            vmListModel.postGetTemplatesNotPresentOnExportDomain(storagePool);
        }
    }), storageDomainId);
}
#end_block

#method_before
private void postGetTemplatesNotPresentOnExportDomain(StoragePool storagePool) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((StorageDomain) model.getStorage().getSelectedItem()).getId();
    if (storagePool != null) {
        AsyncDataProvider.getAllTemplatesFromExportDomain(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                HashMap<VmTemplate, ArrayList<DiskImage>> templatesDiskSet = (HashMap<VmTemplate, ArrayList<DiskImage>>) returnValue;
                HashMap<String, ArrayList<String>> templateDic = new HashMap<String, ArrayList<String>>();
                // check if relevant templates are already there
                for (Object selectedItem : vmListModel.getSelectedItems()) {
                    VM vm = (VM) selectedItem;
                    boolean hasMatch = false;
                    for (VmTemplate a : templatesDiskSet.keySet()) {
                        if (vm.getVmtGuid().equals(a.getId())) {
                            hasMatch = true;
                            break;
                        }
                    }
                    if (!vm.getVmtGuid().equals(Guid.Empty) && !hasMatch) {
                        if (!templateDic.containsKey(vm.getVmtName())) {
                            templateDic.put(vm.getVmtName(), new ArrayList<String>());
                        }
                        templateDic.get(vm.getVmtName()).add(vm.getName());
                    }
                }
                String tempStr;
                ArrayList<String> tempList;
                ArrayList<String> missingTemplates = new ArrayList<String>();
                for (Map.Entry<String, ArrayList<String>> keyValuePair : templateDic.entrySet()) {
                    tempList = keyValuePair.getValue();
                    // $NON-NLS-1$ //$NON-NLS-2$
                    StringBuilder sb = new StringBuilder("Template " + keyValuePair.getKey() + " (for ");
                    int i;
                    for (i = 0; i < tempList.size() - 1; i++) {
                        sb.append(tempList.get(i));
                        // $NON-NLS-1$
                        sb.append(", ");
                    }
                    sb.append(tempList.get(i));
                    // $NON-NLS-1$
                    sb.append(")");
                    missingTemplates.add(sb.toString());
                }
                vmListModel.postExportGetMissingTemplates(missingTemplates);
            }
        }), storagePool.getId(), storageDomainId);
    }
}
#method_after
private void postGetTemplatesNotPresentOnExportDomain(StoragePool storagePool) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((StorageDomain) model.getStorage().getSelectedItem()).getId();
    if (storagePool != null) {
        AsyncDataProvider.getInstance().getAllTemplatesFromExportDomain(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                HashMap<VmTemplate, ArrayList<DiskImage>> templatesDiskSet = (HashMap<VmTemplate, ArrayList<DiskImage>>) returnValue;
                HashMap<String, ArrayList<String>> templateDic = new HashMap<String, ArrayList<String>>();
                // check if relevant templates are already there
                for (Object selectedItem : vmListModel.getSelectedItems()) {
                    VM vm = (VM) selectedItem;
                    boolean hasMatch = false;
                    for (VmTemplate a : templatesDiskSet.keySet()) {
                        if (vm.getVmtGuid().equals(a.getId())) {
                            hasMatch = true;
                            break;
                        }
                    }
                    if (!vm.getVmtGuid().equals(Guid.Empty) && !hasMatch) {
                        if (!templateDic.containsKey(vm.getVmtName())) {
                            templateDic.put(vm.getVmtName(), new ArrayList<String>());
                        }
                        templateDic.get(vm.getVmtName()).add(vm.getName());
                    }
                }
                String tempStr;
                ArrayList<String> tempList;
                ArrayList<String> missingTemplates = new ArrayList<String>();
                for (Map.Entry<String, ArrayList<String>> keyValuePair : templateDic.entrySet()) {
                    tempList = keyValuePair.getValue();
                    // $NON-NLS-1$ //$NON-NLS-2$
                    StringBuilder sb = new StringBuilder("Template " + keyValuePair.getKey() + " (for ");
                    int i;
                    for (i = 0; i < tempList.size() - 1; i++) {
                        sb.append(tempList.get(i));
                        // $NON-NLS-1$
                        sb.append(", ");
                    }
                    sb.append(tempList.get(i));
                    // $NON-NLS-1$
                    sb.append(")");
                    missingTemplates.add(sb.toString());
                }
                vmListModel.postExportGetMissingTemplates(missingTemplates);
            }
        }), storagePool.getId(), storageDomainId);
    }
}
#end_block

#method_before
@Override
protected void sendWarningForNonExportableDisks(VM entity) {
    // load VM disks and check if there is one which doesn't allow snapshot
    AsyncDataProvider.getVmDiskList(new AsyncQuery(getWindow(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final ExportVmModel model = (ExportVmModel) target;
            @SuppressWarnings("unchecked")
            final ArrayList<Disk> vmDisks = (ArrayList<Disk>) returnValue;
            VmModelHelper.sendWarningForNonExportableDisks(model, vmDisks, VmModelHelper.WarningType.VM_EXPORT);
        }
    }), entity.getId());
}
#method_after
@Override
protected void sendWarningForNonExportableDisks(VM entity) {
    // load VM disks and check if there is one which doesn't allow snapshot
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(getWindow(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final ExportVmModel model = (ExportVmModel) target;
            @SuppressWarnings("unchecked")
            final ArrayList<Disk> vmDisks = (ArrayList<Disk>) returnValue;
            VmModelHelper.sendWarningForNonExportableDisks(model, vmDisks, VmModelHelper.WarningType.VM_EXPORT);
        }
    }), entity.getId());
}
#end_block

#method_before
private void runOnce() {
    VM vm = (VM) getSelectedItem();
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            RunOnceModel runOnceModel = new WebadminRunOnceModel((VM) result, VmListModel.this);
            setWindow(runOnceModel);
            runOnceModel.init();
        }
    };
    AsyncDataProvider.getVmById(getVmInitQuery, vm.getId());
}
#method_after
private void runOnce() {
    VM vm = (VM) getSelectedItem();
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            RunOnceModel runOnceModel = new WebadminRunOnceModel((VM) result, VmListModel.this);
            setWindow(runOnceModel);
            runOnceModel.init();
        }
    };
    AsyncDataProvider.getInstance().getVmById(getVmInitQuery, vm.getId());
}
#end_block

#method_before
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck();
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name);
    }
}
#method_after
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck();
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name);
    }
}
#end_block

#method_before
private void migrate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    MigrateModel model = new MigrateModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().migrateVirtualMachinesTitle());
    model.setHelpTag(HelpTag.migrate_virtual_machine);
    // $NON-NLS-1$
    model.setHashName("migrate_virtual_machine");
    model.setVmsOnSameCluster(true);
    model.setIsAutoSelect(true);
    model.setVmList(Linq.<VM>cast(getSelectedItems()));
    AsyncDataProvider.getUpHostListByCluster(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            vmListModel.postMigrateGetUpHosts((ArrayList<VDS>) returnValue);
        }
    }), vm.getVdsGroupName());
}
#method_after
private void migrate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    MigrateModel model = new MigrateModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().migrateVirtualMachinesTitle());
    model.setHelpTag(HelpTag.migrate_virtual_machine);
    // $NON-NLS-1$
    model.setHashName("migrate_virtual_machine");
    model.setVmsOnSameCluster(true);
    model.setIsAutoSelect(true);
    model.setVmList(Linq.<VM>cast(getSelectedItems()));
    AsyncDataProvider.getInstance().getUpHostListByCluster(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            vmListModel.postMigrateGetUpHosts((ArrayList<VDS>) returnValue);
        }
    }), vm.getVdsGroupName());
}
#end_block

#method_before
private void powerAction(final String actionName, final String title, final String message) {
    Guid clusterId = getClusterIdOfSelectedVms();
    if (clusterId == null) {
        powerAction(actionName, title, message, false);
    } else {
        AsyncDataProvider.getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null) {
                    powerAction(actionName, title, message, cluster.isOptionalReasonRequired());
                }
            }
        }), clusterId);
    }
}
#method_after
private void powerAction(final String actionName, final String title, final String message) {
    Guid clusterId = getClusterIdOfSelectedVms();
    if (clusterId == null) {
        powerAction(actionName, title, message, false);
    } else {
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null) {
                    powerAction(actionName, title, message, cluster.isOptionalReasonRequired());
                }
            }
        }), clusterId);
    }
}
#end_block

#method_before
private void powerAction(String actionName, String title, String message, boolean reasonVisible) {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(title);
    model.setReasonVisible(reasonVisible);
    if (actionName.equals(SHUTDOWN)) {
        model.setHelpTag(HelpTag.shutdown_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("shutdown_virtual_machine");
    } else if (actionName.equals(STOP)) {
        model.setHelpTag(HelpTag.stop_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("stop_virtual_machine");
    } else if (actionName.equals(REBOOT)) {
        model.setHelpTag(HelpTag.reboot_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("reboot_virtual_machine");
    }
    model.setMessage(message);
    ArrayList<String> items = new ArrayList<String>();
    boolean stoppingSingleVM = getSelectedItems().size() == 1 && (actionName.equals(SHUTDOWN) || actionName.equals(STOP));
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        items.add(vm.getName());
        if (stoppingSingleVM && reasonVisible && VMStatus.PoweringDown.equals(vm.getStatus())) {
            model.getReason().setEntity(vm.getStopReason());
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("On" + actionName, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void powerAction(String actionName, String title, String message, boolean reasonVisible) {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(title);
    model.setReasonVisible(reasonVisible);
    if (actionName.equals(SHUTDOWN)) {
        model.setHelpTag(HelpTag.shutdown_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("shutdown_virtual_machine");
    } else if (actionName.equals(STOP)) {
        model.setHelpTag(HelpTag.stop_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("stop_virtual_machine");
    } else if (actionName.equals(REBOOT)) {
        model.setHelpTag(HelpTag.reboot_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("reboot_virtual_machine");
    }
    model.setMessage(message);
    ArrayList<String> items = new ArrayList<String>();
    boolean stoppingSingleVM = getSelectedItems().size() == 1 && (actionName.equals(SHUTDOWN) || actionName.equals(STOP));
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        items.add(vm.getName());
        // is populated with the current reason so the user can edit it.
        if (stoppingSingleVM && reasonVisible && VMStatus.PoweringDown.equals(vm.getStatus())) {
            model.getReason().setEntity(vm.getStopReason());
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("On" + actionName, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void changeCD() {
    final VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrDefault(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    };
    AsyncDataProvider.getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void changeCD() {
    final VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrDefault(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    };
    AsyncDataProvider.getInstance().getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void preSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    final String name = model.getName().getEntity();
    if (model.getIsNew() == false && selectedItem == null) {
        cancel();
        return;
    }
    setcurrentVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem));
    if (!model.validate()) {
        return;
    }
    AsyncDataProvider.isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            if (!(Boolean) returnValue && name.compareToIgnoreCase(getcurrentVm().getName()) != 0) {
                model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                model.getName().setIsValid(false);
                model.setIsGeneralTabValid(false);
            } else {
                model.getName().getInvalidityReasons().clear();
                model.getName().setIsValid(true);
                model.setIsGeneralTabValid(true);
                onSave();
            }
        }
    }), name);
}
#method_after
private void preSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    final String name = model.getName().getEntity();
    if (model.getIsNew() == false && selectedItem == null) {
        cancel();
        return;
    }
    setcurrentVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem));
    if (!model.validate()) {
        return;
    }
    AsyncDataProvider.getInstance().isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            if (!(Boolean) returnValue && name.compareToIgnoreCase(getcurrentVm().getName()) != 0) {
                model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                model.getName().setIsValid(false);
                model.setIsGeneralTabValid(false);
            } else {
                model.getName().getInvalidityReasons().clear();
                model.getName().setIsValid(true);
                model.setIsGeneralTabValid(true);
                onSave();
            }
        }
    }), name);
}
#end_block

#method_before
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, getcurrentVm());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        final VM selectedItem = (VM) getSelectedItem();
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        getcurrentVm().setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.isNextRunConfigurationChanged(editedVm, getcurrentVm(), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    if (((VdcQueryReturnValue) returnValue).<Boolean>getReturnValue()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == getcurrentVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != getcurrentVm().getNumOfSockets());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("CancelConfirmation", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(false);
                    }
                }
            }));
        } else {
            updateExistingVm(false);
        }
    }
}
#method_after
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, getcurrentVm());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        final VM selectedItem = (VM) getSelectedItem();
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        getcurrentVm().setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().isNextRunConfigurationChanged(editedVm, getcurrentVm(), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    if (((VdcQueryReturnValue) returnValue).<Boolean>getReturnValue()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == getcurrentVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != getcurrentVm().getNumOfSockets());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("CancelConfirmation", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(false);
                    }
                }
            }));
        } else {
            updateExistingVm(false);
        }
    }
}
#end_block

#method_before
private void saveNewVm(final UnitVmModel model) {
    if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
        if (model.getProgress() != null) {
            return;
        }
        VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

            @Override
            public void vnicCreated(Guid vmId) {
            // do nothing
            }

            @Override
            public void queryFailed() {
            // do nothing
            }
        });
        model.startProgress(null);
        AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
        parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
        parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
        parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
        parameters.setBalloonEnabled(balloonEnabled(model));
        setVmWatchdogToParams(model, parameters);
        setRngDeviceToParams(model, parameters);
        Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager) {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                getWindow().stopProgress();
                VdcReturnValueBase returnValue = result.getReturnValue();
                if (returnValue != null && returnValue.getSucceeded()) {
                    setWindow(null);
                    setGuideContext(returnValue.getActionReturnValue());
                    updateActionAvailability();
                    getGuideCommand().execute();
                } else {
                    cancel();
                }
                super.executed(result);
            }
        }, this);
    } else {
        if (model.getProgress() != null) {
            return;
        }
        if (model.getProvisioning().getEntity()) {
            model.startProgress(null);
            AsyncQuery _asyncQuery = new AsyncQuery();
            _asyncQuery.setModel(this);
            _asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    VmListModel vmListModel = (VmListModel) model1;
                    UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                    VM vm = vmListModel.getcurrentVm();
                    vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(unitVmModel.getTemplate().getSelectedItem().getTemplateVersionName()));
                    AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vm, unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                    param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                    param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                    param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                    param.setBalloonEnabled(balloonEnabled(model));
                    param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                    setRngDeviceToParams(model, param);
                    Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                }
            };
            AsyncDataProvider.getTemplateDiskList(_asyncQuery, getcurrentVm().getVmtGuid());
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VM vm = getcurrentVm();
            vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
            VmManagementParametersBase params = new VmManagementParametersBase(vm);
            params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
            params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            params.setBalloonEnabled(balloonEnabled(model));
            params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
            ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
            parameters.add(params);
            params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            setVmWatchdogToParams(model, params);
            setRngDeviceToParams(model, params);
            Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
        }
    }
}
#method_after
private void saveNewVm(final UnitVmModel model) {
    if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
        if (model.getProgress() != null) {
            return;
        }
        VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

            @Override
            public void vnicCreated(Guid vmId) {
            // do nothing
            }

            @Override
            public void queryFailed() {
            // do nothing
            }
        });
        model.startProgress(null);
        AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
        parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
        parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
        parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
        parameters.setBalloonEnabled(balloonEnabled(model));
        setVmWatchdogToParams(model, parameters);
        setRngDeviceToParams(model, parameters);
        Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager) {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                getWindow().stopProgress();
                VdcReturnValueBase returnValue = result.getReturnValue();
                if (returnValue != null && returnValue.getSucceeded()) {
                    setWindow(null);
                    setGuideContext(returnValue.getActionReturnValue());
                    updateActionAvailability();
                    getGuideCommand().execute();
                } else {
                    cancel();
                }
                super.executed(result);
            }
        }, this);
    } else {
        if (model.getProgress() != null) {
            return;
        }
        if (model.getProvisioning().getEntity()) {
            model.startProgress(null);
            AsyncQuery _asyncQuery = new AsyncQuery();
            _asyncQuery.setModel(this);
            _asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    VmListModel vmListModel = (VmListModel) model1;
                    UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                    VM vm = vmListModel.getcurrentVm();
                    vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(unitVmModel.getTemplate().getSelectedItem().getTemplateVersionName()));
                    AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vm, unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                    param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                    param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                    param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                    param.setBalloonEnabled(balloonEnabled(model));
                    param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                    setRngDeviceToParams(model, param);
                    Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                }
            };
            AsyncDataProvider.getInstance().getTemplateDiskList(_asyncQuery, getcurrentVm().getVmtGuid());
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VM vm = getcurrentVm();
            vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
            VmManagementParametersBase params = new VmManagementParametersBase(vm);
            params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
            params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            params.setBalloonEnabled(balloonEnabled(model));
            params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
            ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
            parameters.add(params);
            params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            setVmWatchdogToParams(model, params);
            setRngDeviceToParams(model, params);
            Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
        }
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    getCloneVmCommand().setIsExecutionAllowed(items.size() == 1);
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.HibernateVm) && AsyncDataProvider.canVmsBePaused(items));
    getShutdownCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    updateHaMaintenanceAvailability(items);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#method_after
private void updateActionAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    getCloneVmCommand().setIsExecutionAllowed(items.size() == 1);
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.HibernateVm) && AsyncDataProvider.getInstance().canVmsBePaused(items));
    getShutdownCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.getInstance().isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    updateHaMaintenanceAvailability(items);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#end_block

#method_before
public static void sync(List<DbUser> dbUsers) {
    Map<String, Map<String, Set<String>>> authzToNamespaceToUserIds = new HashMap<>();
    Map<DirectoryEntryKey, DbUser> dbUsersMap = new HashMap<>();
    Map<DirectoryEntryKey, DbUser> allUsers = new HashMap<>();
    Map<DirectoryEntryKey, DbUser> activeUsers = new HashMap<>();
    // Initialize the entries based on authz in the map
    for (DbUser dbUser : dbUsers) {
        allUsers.put(new DirectoryEntryKey(dbUser.getDomain(), dbUser.getExternalId()), dbUser);
        if (!authzToNamespaceToUserIds.containsKey(dbUser.getDomain())) {
            authzToNamespaceToUserIds.put(dbUser.getDomain(), new HashMap<String, Set<String>>());
        }
        MultiValueMapUtils.addToMapOfSets(dbUser.getNamespace(), dbUser.getExternalId(), authzToNamespaceToUserIds.get(dbUser.getDomain()));
        dbUsersMap.put(new DirectoryEntryKey(dbUser.getDomain(), dbUser.getExternalId()), dbUser);
    }
    for (String authz : authzToNamespaceToUserIds.keySet()) {
        try {
            ExtensionProxy authzExtension = EngineExtensionsManager.getInstance().getExtensionByName(authz);
            for (Entry<String, Set<String>> userIdsPerNamespace : authzToNamespaceToUserIds.get(authz).entrySet()) {
                Set<String> userIds = userIdsPerNamespace.getValue();
                for (DirectoryUser directoryUser : DirectoryUtils.fetchUsersByIdsRecursively(authzExtension, userIdsPerNamespace.getKey(), new ArrayList<String>(userIds))) {
                    DirectoryUtils.flatGroups(directoryUser);
                    DbUser dbUser = new DbUser(directoryUser);
                    dbUser.setGroupIds(DirectoryUtils.getGroupIdsFromUser(directoryUser));
                    activeUsers.put(new DirectoryEntryKey(directoryUser.getDirectoryName(), directoryUser.getId()), dbUser);
                }
            }
        } catch (ConfigurationException ex) {
            log.error(String.format("The authz extension for %1%s has not been found. Users belonging to this extension will be marked as inactive", authz));
        }
    }
    for (DbUser dbUser : dbUsers) {
        DbUser activeUser = activeUsers.get(new DirectoryEntryKey(dbUser));
        DbUser updatedUser = activeUser;
        boolean updated = false;
        if (activeUser == null) {
            if (dbUser.isActive()) {
                updated = true;
                dbUser.setActive(false);
                log.info(String.format("The user %1$s from authz extension %2$s could not be found, and will be marked as inactive", dbUser.getLoginName(), dbUser.getDomain()));
                updatedUser = dbUser;
            }
        } else {
            updatedUser = activeUser;
            updatedUser.setId(dbUser.getId());
            if (!dbUser.isActive()) {
                updated = true;
                dbUser.setActive(true);
                log.info(String.format("The inactive user %1$s from authz extension %2$s was found, and will be marked as active", dbUser.getLoginName(), dbUser.getDomain()));
            }
            if (!dbUser.equals(activeUser)) {
                updated = true;
            }
        }
        if (updated) {
            DbFacade.getInstance().getDbUserDao().update(updatedUser);
        }
    }
}
#method_after
public static void sync(List<DbUser> dbUsers) {
    Map<String, Map<String, Set<String>>> authzToNamespaceToUserIds = new HashMap<>();
    Map<DirectoryEntryKey, DbUser> originalDbUsersMap = new HashMap<>();
    Map<String, List<DbUser>> dbUsersPerAuthz = new HashMap<>();
    // Initialize the entries based on authz in the map
    for (DbUser dbUser : dbUsers) {
        MultiValueMapUtils.addToMap(dbUser.getDomain(), dbUser, dbUsersPerAuthz);
        if (!authzToNamespaceToUserIds.containsKey(dbUser.getDomain())) {
            authzToNamespaceToUserIds.put(dbUser.getDomain(), new HashMap<String, Set<String>>());
        }
        MultiValueMapUtils.addToMapOfSets(dbUser.getNamespace(), dbUser.getExternalId(), authzToNamespaceToUserIds.get(dbUser.getDomain()));
        originalDbUsersMap.put(new DirectoryEntryKey(dbUser), dbUser);
    }
    for (Entry<String, Map<String, Set<String>>> entry : authzToNamespaceToUserIds.entrySet()) {
        Map<String, DbUser> activeUsers = new HashMap<>();
        String authz = entry.getKey();
        try {
            ExtensionProxy authzExtension = EngineExtensionsManager.getInstance().getExtensionByName(authz);
            for (Entry<String, Set<String>> userIdsPerNamespace : entry.getValue().entrySet()) {
                for (ExtMap principal : AuthzUtils.fetchPrincipalsByIdsRecursively(authzExtension, userIdsPerNamespace.getKey(), new ArrayList<String>(userIdsPerNamespace.getValue()))) {
                    DirectoryUtils.flatGroups(principal);
                    DbUser dbUser = DirectoryUtils.mapPrincipalRecordToDbUser(authz, principal);
                    dbUser.setGroupIds(DirectoryUtils.getGroupIdsFromPrincipal(authz, principal));
                    activeUsers.put(dbUser.getExternalId(), dbUser);
                }
            }
            for (DbUser dbUser : dbUsersPerAuthz.get(authz)) {
                DbUser activeUser = activeUsers.get(dbUser.getExternalId());
                if (activeUser != null) {
                    if (!activeUser.equals(dbUser)) {
                        activeUser.setId(dbUser.getId());
                        log.info(String.format("The user %1$s from authz extension %2$s got updated since last interval", activeUser.getLoginName(), activeUser.getDomain()));
                        DbFacade.getInstance().getDbUserDao().update(activeUser);
                    }
                } else {
                    log.info(String.format("The user %1$s from authz extension %2$s could not be found, and will be marked as inactive", dbUser.getLoginName(), dbUser.getDomain()));
                    dbUser.setActive(false);
                    DbFacade.getInstance().getDbUserDao().update(dbUser);
                }
            }
        } catch (Exception ex) {
            log.error(String.format("Error during user synchronization of extension %1$s. Exception message is %2$s", authz, ex.getMessage()));
            log.debug("", ex);
        }
    }
}
#end_block

#method_before
// get { return SelectedItems == null ? new object[0] : SelectedItems.Cast<storage_pool>().Select(a =>
protected Object[] getSelectedKeys() {
    if (getSelectedItems() == null) {
        return new Object[0];
    } else {
        ArrayList<Object> objL = new ArrayList<Object>();
        for (StoragePool a : Linq.<StoragePool>cast(getSelectedItems())) {
            objL.add(a.getId());
        }
        return objL.toArray(new Object[] {});
    }
}
#method_after
protected Object[] getSelectedKeys() {
    if (getSelectedItems() == null) {
        return new Object[0];
    } else {
        ArrayList<Object> objL = new ArrayList<Object>();
        for (StoragePool a : Linq.<StoragePool>cast(getSelectedItems())) {
            objL.add(a.getId());
        }
        return objL.toArray(new Object[] {});
    }
}
#end_block

#method_before
public void guide() {
    DataCenterGuideModel model = new DataCenterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDataCenterGuideMeTitle());
    model.setHelpTag(HelpTag.new_data_center___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_data_center_-_guide_me");
    if (getGuideContext() == null) {
        StoragePool dataCenter = (StoragePool) getSelectedItem();
        setGuideContext(dataCenter.getId());
    }
    AsyncDataProvider.getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterListModel dataCenterListModel = (DataCenterListModel) target;
            DataCenterGuideModel model = (DataCenterGuideModel) dataCenterListModel.getWindow();
            model.setEntity((StoragePool) returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", dataCenterListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#method_after
public void guide() {
    DataCenterGuideModel model = new DataCenterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDataCenterGuideMeTitle());
    model.setHelpTag(HelpTag.new_data_center___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_data_center_-_guide_me");
    if (getGuideContext() == null) {
        StoragePool dataCenter = (StoragePool) getSelectedItem();
        setGuideContext(dataCenter.getId());
    }
    AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterListModel dataCenterListModel = (DataCenterListModel) target;
            DataCenterGuideModel model = (DataCenterGuideModel) dataCenterListModel.getWindow();
            model.setEntity((StoragePool) returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", dataCenterListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#end_block

#method_before
public void edit() {
    StoragePool dataCenter = (StoragePool) getSelectedItem();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (getWindow() != null) {
        return;
    }
    final DataCenterModel model = new DataCenterModel();
    setWindow(model);
    model.setEntity(dataCenter);
    model.setDataCenterId(dataCenter.getId());
    model.setTitle(constants.editDataCenterTitle());
    model.setHelpTag(HelpTag.edit_data_center);
    // $NON-NLS-1$
    model.setHashName("edit_data_center");
    model.getName().setEntity(dataCenter.getName());
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.DataCenter) {
        model.getName().setIsChangable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    model.getDescription().setEntity(dataCenter.getdescription());
    model.getComment().setEntity(dataCenter.getComment());
    model.setOriginalName(dataCenter.getName());
    AsyncDataProvider.getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            if (storageDomainList.size() != 0) {
                model.getStoragePoolType().setChangeProhibitionReason(constants.cannotChangeRepositoryTypeWithSDAttached());
                model.getStoragePoolType().setIsChangable(false);
            }
        }
    }), dataCenter.getId());
    model.getStoragePoolType().setSelectedItem(dataCenter.isLocal());
    model.getQuotaEnforceTypeListModel().setSelectedItem(dataCenter.getQuotaEnforcementType());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void edit() {
    StoragePool dataCenter = (StoragePool) getSelectedItem();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (getWindow() != null) {
        return;
    }
    final DataCenterModel model = new DataCenterModel();
    setWindow(model);
    model.setEntity(dataCenter);
    model.setDataCenterId(dataCenter.getId());
    model.setTitle(constants.editDataCenterTitle());
    model.setHelpTag(HelpTag.edit_data_center);
    // $NON-NLS-1$
    model.setHashName("edit_data_center");
    model.getName().setEntity(dataCenter.getName());
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.DataCenter) {
        model.getName().setIsChangable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    model.getDescription().setEntity(dataCenter.getdescription());
    model.getComment().setEntity(dataCenter.getComment());
    model.setOriginalName(dataCenter.getName());
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            if (storageDomainList.size() != 0) {
                model.getStoragePoolType().setChangeProhibitionReason(constants.cannotChangeRepositoryTypeWithSDAttached());
                model.getStoragePoolType().setIsChangable(false);
            }
        }
    }), dataCenter.getId());
    model.getStoragePoolType().setSelectedItem(dataCenter.isLocal());
    model.getQuotaEnforceTypeListModel().setSelectedItem(dataCenter.getQuotaEnforcementType());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void recoveryStorage() {
    final ConfirmationModel windowModel = new ConfirmationModel();
    setWindow(windowModel);
    windowModel.setTitle(ConstantsManager.getInstance().getConstants().dataCenterReInitializeTitle());
    windowModel.setHelpTag(HelpTag.data_center_re_initialize);
    // $NON-NLS-1$
    windowModel.setHashName("data_center_re-initialize");
    windowModel.getLatch().setIsAvailable(true);
    windowModel.getLatch().setIsChangable(true);
    windowModel.startProgress(null);
    AsyncDataProvider.getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            windowModel.stopProgress();
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            List<EntityModel> models = new ArrayList<EntityModel>();
            for (StorageDomain a : storageDomainList) {
                if (a.getStorageDomainType() == StorageDomainType.Data && (a.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached)) {
                    EntityModel tempVar = new EntityModel();
                    tempVar.setEntity(a);
                    models.add(tempVar);
                }
            }
            windowModel.setItems(models);
            if (models.size() > 0) {
                EntityModel entityModel = models.size() != 0 ? models.get(0) : null;
                if (entityModel != null) {
                    entityModel.setIsSelected(true);
                }
            }
            if (models.isEmpty()) {
                windowModel.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoCompatibleStorageDomainsAttachThisDcMsg());
                windowModel.getLatch().setIsAvailable(false);
                // $NON-NLS-1$
                UICommand tempVar2 = new UICommand("Cancel", DataCenterListModel.this);
                tempVar2.setTitle(ConstantsManager.getInstance().getConstants().close());
                tempVar2.setIsDefault(true);
                tempVar2.setIsCancel(true);
                windowModel.getCommands().add(tempVar2);
            } else {
                // $NON-NLS-1$
                UICommand tempVar3 = new UICommand("OnRecover", DataCenterListModel.this);
                tempVar3.setTitle(ConstantsManager.getInstance().getConstants().ok());
                tempVar3.setIsDefault(true);
                windowModel.getCommands().add(tempVar3);
                // $NON-NLS-1$
                UICommand tempVar4 = new UICommand("Cancel", DataCenterListModel.this);
                tempVar4.setTitle(ConstantsManager.getInstance().getConstants().cancel());
                tempVar4.setIsCancel(true);
                windowModel.getCommands().add(tempVar4);
            }
        }
    }));
}
#method_after
public void recoveryStorage() {
    final ConfirmationModel windowModel = new ConfirmationModel();
    setWindow(windowModel);
    windowModel.setTitle(ConstantsManager.getInstance().getConstants().dataCenterReInitializeTitle());
    windowModel.setHelpTag(HelpTag.data_center_re_initialize);
    // $NON-NLS-1$
    windowModel.setHashName("data_center_re-initialize");
    windowModel.getLatch().setIsAvailable(true);
    windowModel.getLatch().setIsChangable(true);
    windowModel.startProgress(null);
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            windowModel.stopProgress();
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            List<EntityModel> models = new ArrayList<EntityModel>();
            for (StorageDomain a : storageDomainList) {
                if (a.getStorageDomainType() == StorageDomainType.Data && (a.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached)) {
                    EntityModel tempVar = new EntityModel();
                    tempVar.setEntity(a);
                    models.add(tempVar);
                }
            }
            windowModel.setItems(models);
            if (models.size() > 0) {
                EntityModel entityModel = models.size() != 0 ? models.get(0) : null;
                if (entityModel != null) {
                    entityModel.setIsSelected(true);
                }
            }
            if (models.isEmpty()) {
                windowModel.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoCompatibleStorageDomainsAttachThisDcMsg());
                windowModel.getLatch().setIsAvailable(false);
                // $NON-NLS-1$
                UICommand tempVar2 = new UICommand("Cancel", DataCenterListModel.this);
                tempVar2.setTitle(ConstantsManager.getInstance().getConstants().close());
                tempVar2.setIsDefault(true);
                tempVar2.setIsCancel(true);
                windowModel.getCommands().add(tempVar2);
            } else {
                // $NON-NLS-1$
                UICommand tempVar3 = new UICommand("OnRecover", DataCenterListModel.this);
                tempVar3.setTitle(ConstantsManager.getInstance().getConstants().ok());
                tempVar3.setIsDefault(true);
                windowModel.getCommands().add(tempVar3);
                // $NON-NLS-1$
                UICommand tempVar4 = new UICommand("Cancel", DataCenterListModel.this);
                tempVar4.setTitle(ConstantsManager.getInstance().getConstants().cancel());
                tempVar4.setIsCancel(true);
                windowModel.getCommands().add(tempVar4);
            }
        }
    }));
}
#end_block

#method_before
public void onRecover() {
    final ConfirmationModel windowModel = (ConfirmationModel) getWindow();
    if (!windowModel.validate()) {
        return;
    }
    AsyncDataProvider.getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            for (StorageDomain a : storageDomainList) {
                if (a.getStorageDomainType() == StorageDomainType.Master) {
                    break;
                }
            }
            List<StorageDomain> items = new ArrayList<StorageDomain>();
            for (EntityModel a : Linq.<EntityModel>cast(windowModel.getItems())) {
                if (a.getIsSelected()) {
                    items.add((StorageDomain) a.getEntity());
                }
            }
            if (items.size() > 0) {
                if (windowModel.getProgress() != null) {
                    return;
                }
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                for (StorageDomain a : items) {
                    parameters.add(new RecoveryStoragePoolParameters(((StoragePool) getSelectedItem()).getId(), a.getId()));
                }
                windowModel.startProgress(null);
                Frontend.getInstance().runMultipleAction(VdcActionType.RecoveryStoragePool, parameters, new IFrontendMultipleActionAsyncCallback() {

                    @Override
                    public void executed(FrontendMultipleActionAsyncResult result) {
                        ConfirmationModel localModel = (ConfirmationModel) result.getState();
                        localModel.stopProgress();
                        cancel();
                    }
                }, windowModel);
            } else {
                cancel();
            }
        }
    }), ((StoragePool) getSelectedItem()).getId());
}
#method_after
public void onRecover() {
    final ConfirmationModel windowModel = (ConfirmationModel) getWindow();
    if (!windowModel.validate()) {
        return;
    }
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            for (StorageDomain a : storageDomainList) {
                if (a.getStorageDomainType() == StorageDomainType.Master) {
                    break;
                }
            }
            List<StorageDomain> items = new ArrayList<StorageDomain>();
            for (EntityModel a : Linq.<EntityModel>cast(windowModel.getItems())) {
                if (a.getIsSelected()) {
                    items.add((StorageDomain) a.getEntity());
                }
            }
            if (items.size() > 0) {
                if (windowModel.getProgress() != null) {
                    return;
                }
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                for (StorageDomain a : items) {
                    parameters.add(new RecoveryStoragePoolParameters(((StoragePool) getSelectedItem()).getId(), a.getId()));
                }
                windowModel.startProgress(null);
                Frontend.getInstance().runMultipleAction(VdcActionType.RecoveryStoragePool, parameters, new IFrontendMultipleActionAsyncCallback() {

                    @Override
                    public void executed(FrontendMultipleActionAsyncResult result) {
                        ConfirmationModel localModel = (ConfirmationModel) result.getState();
                        localModel.stopProgress();
                        cancel();
                    }
                }, windowModel);
            } else {
                cancel();
            }
        }
    }), ((StoragePool) getSelectedItem()).getId());
}
#end_block

#method_before
private void updateActionAvailability() {
    ArrayList<StoragePool> items = getSelectedItems() != null ? new ArrayList<StoragePool>(Linq.<StoragePool>cast(getSelectedItems())) : new ArrayList<StoragePool>();
    boolean isAllDown = true;
    for (StoragePool item : items) {
        if (item.getStatus() == StoragePoolStatus.Up || item.getStatus() == StoragePoolStatus.Contend) {
            isAllDown = false;
            break;
        }
    }
    getEditCommand().setIsExecutionAllowed(getSelectedItem() != null && items.size() == 1);
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && isAllDown);
    StoragePool storagePoolItem = (StoragePool) getSelectedItem();
    getForceRemoveCommand().setIsExecutionAllowed(storagePoolItem != null && items.size() == 1 && storagePoolItem.getStatus() != StoragePoolStatus.Up);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getActivateCommand().setIsExecutionAllowed(items.size() > 0);
    if (getActivateCommand().getIsExecutionAllowed()) {
        for (StoragePool a : items) {
            if (a.getStatus() == StoragePoolStatus.Up || a.getStatus() == StoragePoolStatus.Uninitialized) {
                getActivateCommand().setIsExecutionAllowed(false);
                break;
            }
        }
    }
    getRecoveryStorageCommand().setIsExecutionAllowed(storagePoolItem != null && items.size() == 1 && !storagePoolItem.isLocal() && storagePoolItem.getStatus() != StoragePoolStatus.Uninitialized);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.DataCenter);
    getNewCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
    getForceRemoveCommand().setIsAvailable(isAvailable);
}
#method_after
private void updateActionAvailability() {
    ArrayList<StoragePool> items = getSelectedItems() != null ? new ArrayList<StoragePool>(Linq.<StoragePool>cast(getSelectedItems())) : new ArrayList<StoragePool>();
    boolean isAllDown = true;
    for (StoragePool item : items) {
        if (item.getStatus() == StoragePoolStatus.Up || item.getStatus() == StoragePoolStatus.Contend) {
            isAllDown = false;
            break;
        }
    }
    getEditCommand().setIsExecutionAllowed(getSelectedItem() != null && items.size() == 1);
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && isAllDown);
    StoragePool storagePoolItem = (StoragePool) getSelectedItem();
    getForceRemoveCommand().setIsExecutionAllowed(storagePoolItem != null && items.size() == 1 && storagePoolItem.getStatus() != StoragePoolStatus.Up);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getRecoveryStorageCommand().setIsExecutionAllowed(storagePoolItem != null && items.size() == 1 && !storagePoolItem.isLocal() && storagePoolItem.getStatus() != StoragePoolStatus.Uninitialized);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.DataCenter);
    getNewCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
    getForceRemoveCommand().setIsAvailable(isAvailable);
}
#end_block

#method_before
private void updateIscsiBondListAvailability(StoragePool storagePool) {
    boolean iscsiBondSupported = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.IscsiMultipathingSupported, storagePool.getcompatibility_version().getValue());
    if (iscsiBondSupported) {
        AsyncDataProvider.getStorageConnectionsByDataCenterIdAndStorageType(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                boolean hasIscsiStorage = false;
                ArrayList<StorageServerConnections> connections = (ArrayList<StorageServerConnections>) returnValue;
                for (StorageServerConnections connection : connections) {
                    if (connection.getstorage_type() == StorageType.ISCSI) {
                        hasIscsiStorage = true;
                        break;
                    }
                }
                iscsiBondListModel.setIsAvailable(hasIscsiStorage);
            }
        }), storagePool.getId(), StorageType.ISCSI);
    } else {
        iscsiBondListModel.setIsAvailable(false);
    }
}
#method_after
private void updateIscsiBondListAvailability(StoragePool storagePool) {
    boolean iscsiBondSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.IscsiMultipathingSupported, storagePool.getcompatibility_version().getValue());
    if (iscsiBondSupported) {
        AsyncDataProvider.getInstance().getStorageConnectionsByDataCenterIdAndStorageType(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                boolean hasIscsiStorage = false;
                ArrayList<StorageServerConnections> connections = (ArrayList<StorageServerConnections>) returnValue;
                for (StorageServerConnections connection : connections) {
                    if (connection.getstorage_type() == StorageType.ISCSI) {
                        hasIscsiStorage = true;
                        break;
                    }
                }
                iscsiBondListModel.setIsAvailable(hasIscsiStorage);
            }
        }), storagePool.getId(), StorageType.ISCSI);
    } else {
        iscsiBondListModel.setIsAvailable(false);
    }
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getForceRemoveCommand()) {
        forceRemove();
    } else if (command == getActivateCommand()) {
        activate();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRecoveryStorageCommand()) {
        recoveryStorage();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnForceRemove".equals(command.getName())) {
        onForceRemove();
    } else if (// $NON-NLS-1$
    "OnSaveInternal".equals(command.getName())) {
        onSaveInternal();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRecover".equals(command.getName())) {
        onRecover();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getForceRemoveCommand()) {
        forceRemove();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRecoveryStorageCommand()) {
        recoveryStorage();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnForceRemove".equals(command.getName())) {
        onForceRemove();
    } else if (// $NON-NLS-1$
    "OnSaveInternal".equals(command.getName())) {
        onSaveInternal();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRecover".equals(command.getName())) {
        onRecover();
    }
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<Network> nameColumn = new TextColumnWithTooltip<Network>() {

        @Override
        public String getValue(Network object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(new Linq.NetworkComparator());
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameNetwork(), "400px");
    TextColumnWithTooltip<Network> descriptionColumn = new TextColumnWithTooltip<Network>() {

        @Override
        public String getValue(Network object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable(NetworkComparator.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.descriptionNetwork(), "400px");
    getTable().addActionButton(new WebAdminButtonDefinition<Network>(constants.newNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Network>(constants.editNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Network>(constants.removeNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveCommand();
        }
    });
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<Network> nameColumn = new TextColumnWithTooltip<Network>() {

        @Override
        public String getValue(Network object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameNetwork(), "400px");
    TextColumnWithTooltip<Network> descriptionColumn = new TextColumnWithTooltip<Network>() {

        @Override
        public String getValue(Network object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.descriptionNetwork(), "400px");
    getTable().addActionButton(new WebAdminButtonDefinition<Network>(constants.newNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Network>(constants.editNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Network>(constants.removeNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveCommand();
        }
    });
}
#end_block

#method_before
void initTable(final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<NetworkQoS> nameColumn = new TextColumnWithTooltip<NetworkQoS>() {

        @Override
        public String getValue(NetworkQoS object) {
            // $NON-NLS-1$
            return object.getName() == null ? "" : object.getName();
        }
    };
    nameColumn.makeSortable(NetworkQoSComparator.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.networkQoSName(), "200px");
    TextColumnWithTooltip<NetworkQoS> inAverageColumn = new TextColumnWithTooltip<NetworkQoS>() {

        @Override
        public String getValue(NetworkQoS object) {
            return object.getInboundAverage() == null ? constants.UnlimitedNetworkQoS() : object.getInboundAverage().toString();
        }
    };
    inAverageColumn.makeSortable(NetworkQoSComparator.INBOUND_AVG);
    // $NON-NLS-1$
    getTable().addColumn(inAverageColumn, constants.networkQoSInboundAverage(), "100px");
    TextColumnWithTooltip<NetworkQoS> inPeakColumn = new TextColumnWithTooltip<NetworkQoS>() {

        @Override
        public String getValue(NetworkQoS object) {
            return object.getInboundPeak() == null ? constants.UnlimitedNetworkQoS() : object.getInboundPeak().toString();
        }
    };
    inPeakColumn.makeSortable(NetworkQoSComparator.INBOUND_PEAK);
    // $NON-NLS-1$
    getTable().addColumn(inPeakColumn, constants.networkQoSInboundPeak(), "100px");
    TextColumnWithTooltip<NetworkQoS> inBurstColumn = new TextColumnWithTooltip<NetworkQoS>() {

        @Override
        public String getValue(NetworkQoS object) {
            return object.getInboundBurst() == null ? constants.UnlimitedNetworkQoS() : object.getInboundBurst().toString();
        }
    };
    inBurstColumn.makeSortable(NetworkQoSComparator.INBOUND_BURST);
    // $NON-NLS-1$
    getTable().addColumn(inBurstColumn, constants.networkQoSInboundBurst(), "100px");
    TextColumnWithTooltip<NetworkQoS> outAverageColumn = new TextColumnWithTooltip<NetworkQoS>() {

        @Override
        public String getValue(NetworkQoS object) {
            return object.getOutboundAverage() == null ? constants.UnlimitedNetworkQoS() : object.getOutboundAverage().toString();
        }
    };
    outAverageColumn.makeSortable(NetworkQoSComparator.OUTBOUND_AVG);
    // $NON-NLS-1$
    getTable().addColumn(outAverageColumn, constants.networkQoSOutboundAverage(), "100px");
    TextColumnWithTooltip<NetworkQoS> outPeakColumn = new TextColumnWithTooltip<NetworkQoS>() {

        @Override
        public String getValue(NetworkQoS object) {
            return object.getOutboundPeak() == null ? constants.UnlimitedNetworkQoS() : object.getOutboundPeak().toString();
        }
    };
    outPeakColumn.makeSortable(NetworkQoSComparator.OUTBOUND_PEAK);
    // $NON-NLS-1$
    getTable().addColumn(outPeakColumn, constants.networkQoSOutboundPeak(), "100px");
    TextColumnWithTooltip<NetworkQoS> outBurstColumn = new TextColumnWithTooltip<NetworkQoS>() {

        @Override
        public String getValue(NetworkQoS object) {
            return object.getOutboundBurst() == null ? constants.UnlimitedNetworkQoS() : object.getOutboundBurst().toString();
        }
    };
    outBurstColumn.makeSortable(NetworkQoSComparator.OUTBOUND_BURST);
    // $NON-NLS-1$
    getTable().addColumn(outBurstColumn, constants.networkQoSOutboundBurst(), "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkQoS>(constants.newNetworkQoS()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkQoS>(constants.editNetworkQoS()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkQoS>(constants.removeNetworkQoS()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveCommand();
        }
    });
}
#method_after
void initTable(final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<NetworkQoS> nameColumn = new TextColumnWithTooltip<NetworkQoS>() {

        @Override
        public String getValue(NetworkQoS object) {
            // $NON-NLS-1$
            return object.getName() == null ? "" : object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.networkQoSName(), "200px");
    TextColumnWithTooltip<NetworkQoS> inAverageColumn = new TextColumnWithTooltip<NetworkQoS>() {

        @Override
        public String getValue(NetworkQoS object) {
            return object.getInboundAverage() == null ? constants.UnlimitedNetworkQoS() : object.getInboundAverage().toString();
        }
    };
    inAverageColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(inAverageColumn, constants.networkQoSInboundAverage(), "100px");
    TextColumnWithTooltip<NetworkQoS> inPeakColumn = new TextColumnWithTooltip<NetworkQoS>() {

        @Override
        public String getValue(NetworkQoS object) {
            return object.getInboundPeak() == null ? constants.UnlimitedNetworkQoS() : object.getInboundPeak().toString();
        }
    };
    inPeakColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(inPeakColumn, constants.networkQoSInboundPeak(), "100px");
    TextColumnWithTooltip<NetworkQoS> inBurstColumn = new TextColumnWithTooltip<NetworkQoS>() {

        @Override
        public String getValue(NetworkQoS object) {
            return object.getInboundBurst() == null ? constants.UnlimitedNetworkQoS() : object.getInboundBurst().toString();
        }
    };
    inBurstColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(inBurstColumn, constants.networkQoSInboundBurst(), "100px");
    TextColumnWithTooltip<NetworkQoS> outAverageColumn = new TextColumnWithTooltip<NetworkQoS>() {

        @Override
        public String getValue(NetworkQoS object) {
            return object.getOutboundAverage() == null ? constants.UnlimitedNetworkQoS() : object.getOutboundAverage().toString();
        }
    };
    outAverageColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(outAverageColumn, constants.networkQoSOutboundAverage(), "100px");
    TextColumnWithTooltip<NetworkQoS> outPeakColumn = new TextColumnWithTooltip<NetworkQoS>() {

        @Override
        public String getValue(NetworkQoS object) {
            return object.getOutboundPeak() == null ? constants.UnlimitedNetworkQoS() : object.getOutboundPeak().toString();
        }
    };
    outPeakColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(outPeakColumn, constants.networkQoSOutboundPeak(), "100px");
    TextColumnWithTooltip<NetworkQoS> outBurstColumn = new TextColumnWithTooltip<NetworkQoS>() {

        @Override
        public String getValue(NetworkQoS object) {
            return object.getOutboundBurst() == null ? constants.UnlimitedNetworkQoS() : object.getOutboundBurst().toString();
        }
    };
    outBurstColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(outBurstColumn, constants.networkQoSOutboundBurst(), "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkQoS>(constants.newNetworkQoS()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkQoS>(constants.editNetworkQoS()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkQoS>(constants.removeNetworkQoS()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveCommand();
        }
    });
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new StorageDomainStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<StorageDomain> nameColumn = new TextColumnWithTooltip<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            return object.getStorageName();
        }
    };
    nameColumn.makeSortable(new Linq.StorageDomainComparator());
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.domainNameStorage(), "160px");
    TextColumnWithTooltip<StorageDomain> typeColumn = new EnumColumn<StorageDomain, StorageDomainType>() {

        @Override
        public StorageDomainType getRawValue(StorageDomain object) {
            return object.getStorageDomainType();
        }
    };
    typeColumn.makeSortable(StorageDomainComparator.TYPE);
    // $NON-NLS-1$
    getTable().addColumn(typeColumn, constants.domainTypeStorage(), "160px");
    TextColumnWithTooltip<StorageDomain> statusColumn = new EnumColumn<StorageDomain, StorageDomainStatus>() {

        @Override
        public StorageDomainStatus getRawValue(StorageDomain object) {
            return object.getStatus();
        }
    };
    statusColumn.makeSortable(StorageDomainComparator.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusStorage(), "160px");
    DiskSizeColumn<StorageDomain> freeColumn = new DiskSizeColumn<StorageDomain>(SizeConverter.SizeUnit.GB) {

        @Override
        public Long getRawValue(StorageDomain object) {
            long availableDiskSize = object.getAvailableDiskSize() != null ? object.getAvailableDiskSize() : 0;
            return (long) availableDiskSize;
        }
    };
    freeColumn.makeSortable(StorageDomainComparator.AVAILABLE_DISK_SIZE);
    // $NON-NLS-1$
    getTable().addColumn(freeColumn, constants.freeSpaceStorage(), "160px");
    DiskSizeColumn<StorageDomain> usedColumn = new DiskSizeColumn<StorageDomain>(SizeConverter.SizeUnit.GB) {

        @Override
        public Long getRawValue(StorageDomain object) {
            long usedDiskSize = object.getUsedDiskSize() != null ? object.getUsedDiskSize() : 0;
            return (long) usedDiskSize;
        }
    };
    usedColumn.makeSortable(StorageDomainComparator.USED_DISK_SIZE);
    // $NON-NLS-1$
    getTable().addColumn(usedColumn, constants.usedSpaceStorage(), "160px");
    DiskSizeColumn<StorageDomain> totalColumn = new DiskSizeColumn<StorageDomain>(SizeConverter.SizeUnit.GB) {

        @Override
        public Long getRawValue(StorageDomain object) {
            long totalDiskSize = object.getTotalDiskSize() != null ? object.getTotalDiskSize() : 0;
            return (long) totalDiskSize;
        }
    };
    totalColumn.makeSortable(StorageDomainComparator.TOTAL_DISK_SIZE);
    // $NON-NLS-1$
    getTable().addColumn(totalColumn, constants.totalSpaceStorage(), "160px");
    TextColumnWithTooltip<StorageDomain> descriptionColumn = new TextColumnWithTooltip<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable(StorageDomainComparator.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.domainDescriptionStorage(), "160px");
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.attachDataStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getAttachStorageCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.attachIsoStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getAttachISOCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.attachExportStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getAttachBackupCommand();
        }
    });
    // TODO: Separator
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.detachStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getDetachCommand();
        }
    });
    // TODO: Separator
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.activateStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getActivateCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getMaintenanceCommand();
        }
    });
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new StorageDomainStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<StorageDomain> nameColumn = new TextColumnWithTooltip<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            return object.getStorageName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.domainNameStorage(), "160px");
    TextColumnWithTooltip<StorageDomain> typeColumn = new EnumColumn<StorageDomain, StorageDomainType>() {

        @Override
        public StorageDomainType getRawValue(StorageDomain object) {
            return object.getStorageDomainType();
        }
    };
    typeColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(typeColumn, constants.domainTypeStorage(), "160px");
    TextColumnWithTooltip<StorageDomain> statusColumn = new EnumColumn<StorageDomain, StorageDomainStatus>() {

        @Override
        public StorageDomainStatus getRawValue(StorageDomain object) {
            return object.getStatus();
        }
    };
    statusColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusStorage(), "160px");
    DiskSizeColumn<StorageDomain> freeColumn = new DiskSizeColumn<StorageDomain>(SizeConverter.SizeUnit.GB) {

        @Override
        public Long getRawValue(StorageDomain object) {
            long availableDiskSize = object.getAvailableDiskSize() != null ? object.getAvailableDiskSize() : 0;
            return (long) availableDiskSize;
        }
    };
    freeColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(freeColumn, constants.freeSpaceStorage(), "160px");
    DiskSizeColumn<StorageDomain> usedColumn = new DiskSizeColumn<StorageDomain>(SizeConverter.SizeUnit.GB) {

        @Override
        public Long getRawValue(StorageDomain object) {
            long usedDiskSize = object.getUsedDiskSize() != null ? object.getUsedDiskSize() : 0;
            return (long) usedDiskSize;
        }
    };
    usedColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(usedColumn, constants.usedSpaceStorage(), "160px");
    DiskSizeColumn<StorageDomain> totalColumn = new DiskSizeColumn<StorageDomain>(SizeConverter.SizeUnit.GB) {

        @Override
        public Long getRawValue(StorageDomain object) {
            long totalDiskSize = object.getTotalDiskSize() != null ? object.getTotalDiskSize() : 0;
            return (long) totalDiskSize;
        }
    };
    totalColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(totalColumn, constants.totalSpaceStorage(), "160px");
    TextColumnWithTooltip<StorageDomain> descriptionColumn = new TextColumnWithTooltip<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.domainDescriptionStorage(), "160px");
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.attachDataStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getAttachStorageCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.attachIsoStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getAttachISOCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.attachExportStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getAttachBackupCommand();
        }
    });
    // TODO: Separator
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.detachStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getDetachCommand();
        }
    });
    // TODO: Separator
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.activateStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getActivateCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getMaintenanceCommand();
        }
    });
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<VDSGroup> nameColumn = new TextColumnWithTooltip<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(new Linq.VDSGroupComparator());
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameCluster(), "300px");
    TextColumnWithTooltip<VDSGroup> versionColumn = new TextColumnWithTooltip<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            return object.getcompatibility_version().getValue();
        }
    };
    versionColumn.makeSortable(VDSGroupComparator.VERSION);
    // $NON-NLS-1$
    getTable().addColumn(versionColumn, constants.comptVersCluster(), "300px");
    TextColumnWithTooltip<VDSGroup> descColumn = new TextColumnWithTooltip<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            return object.getdescription();
        }
    };
    descColumn.makeSortable(VDSGroupComparator.DESCRIPTION);
    getTable().addColumn(descColumn, constants.descriptionCluster());
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<VDSGroup> nameColumn = new TextColumnWithTooltip<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameCluster(), "300px");
    TextColumnWithTooltip<VDSGroup> versionColumn = new TextColumnWithTooltip<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            return object.getcompatibility_version().getValue();
        }
    };
    versionColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(versionColumn, constants.comptVersCluster(), "300px");
    TextColumnWithTooltip<VDSGroup> descColumn = new TextColumnWithTooltip<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            return object.getdescription();
        }
    };
    descColumn.makeSortable();
    getTable().addColumn(descColumn, constants.descriptionCluster());
}
#end_block

#method_before
public static List<ExtMap> findGroupRecordsByIds(final ExtensionProxy extension, final String namespace, final List<String> ids, final boolean groupsResolving, final boolean groupsResolvingRecursive) {
    List<ExtMap> results = new ArrayList<>();
    for (List<String> batch : SearchQueryParsingUtils.getIdsBatches(extension.getContext(), ids)) {
        results.addAll(queryPrincipalRecords(extension, namespace, SearchQueryParsingUtils.generateQueryMap(batch, Authz.QueryEntity.GROUP), groupsResolving, groupsResolvingRecursive));
    }
    return results;
}
#method_after
public static List<ExtMap> findGroupRecordsByIds(final ExtensionProxy extension, final String namespace, final List<String> ids, final boolean groupsResolving, final boolean groupsResolvingRecursive) {
    List<ExtMap> results = new ArrayList<>();
    for (List<String> batch : SearchQueryParsingUtils.getIdsBatches(extension.getContext(), ids)) {
        results.addAll(queryGroupRecords(extension, namespace, SearchQueryParsingUtils.generateQueryMap(batch, Authz.QueryEntity.GROUP), groupsResolving, groupsResolvingRecursive));
    }
    return results;
}
#end_block

#method_before
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getEntity();
        editPopup = new SetupNetworksEditBondModel(entity, getFreeLabels(), labelToIface);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondDialogModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                Collection<LogicalNetworkModel> potentialNetworks = computeLabelChanges(bondDialogModel.getLabelsModel(), nicMap.get(entity.getName()).getItems());
                if (validateLabelChanges(potentialNetworks)) {
                    setBondOptions(entity, bondDialogModel);
                    commitLabelChanges(bondDialogModel.getLabelsModel(), entity, potentialNetworks);
                    redraw();
                }
            }
        };
    } else if (item instanceof NetworkInterfaceModel) {
        /**
         * ****************
         *  Interface Dialog
         * *****************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getEntity();
        final HostNicModel interfacePopupModel = new HostNicModel(entity, getFreeLabels(), labelToIface);
        editPopup = interfacePopupModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand uiCommand) {
                if (!interfacePopupModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                Collection<LogicalNetworkModel> potentialNetworks = computeLabelChanges(interfacePopupModel.getLabelsModel(), nicMap.get(entity.getName()).getItems());
                if (validateLabelChanges(potentialNetworks)) {
                    commitLabelChanges(interfacePopupModel.getLabelsModel(), entity, potentialNetworks);
                    redraw();
                }
            }
        };
    } else if (item instanceof LogicalNetworkModel) {
        /**
         * **************
         *  Network Dialog
         * ***************
         */
        final LogicalNetworkModel logicalNetwork = (LogicalNetworkModel) item;
        final VdsNetworkInterface entity = logicalNetwork.hasVlan() ? logicalNetwork.getVlanNicModel().getEntity() : logicalNetwork.getAttachedToNic().getEntity();
        final HostInterfaceModel networkDialogModel;
        String version = getEntity().getVdsGroupCompatibilityVersion().getValue();
        if (logicalNetwork.isManagement()) {
            networkDialogModel = new HostManagementNetworkModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            networkDialogModel.setEntity(logicalNetwork.getEntity());
            networkDialogModel.setNoneBootProtocolAvailable(false);
            networkDialogModel.getInterface().setIsAvailable(false);
        } else {
            networkDialogModel = new HostInterfaceModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetwork.getName()));
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangable(false);
            networkDialogModel.getGateway().setIsAvailable((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MultipleGatewaysSupported, version));
        }
        networkDialogModel.getNetwork().setSelectedItem(logicalNetwork.getEntity());
        networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetwork.getName()));
        networkDialogModel.getAddress().setEntity(entity.getAddress());
        networkDialogModel.getSubnet().setEntity(entity.getSubnet());
        networkDialogModel.getGateway().setEntity(entity.getGateway());
        networkDialogModel.setStaticIpChangeAllowed(!getEntity().getHostName().equals(entity.getAddress()));
        networkDialogModel.getBondingOptions().setIsAvailable(false);
        networkDialogModel.setBootProtocol(entity.getBootProtocol());
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.NetworkCustomPropertiesSupported, version)) {
            KeyValueModel customPropertiesModel = networkDialogModel.getCustomPropertiesModel();
            customPropertiesModel.setIsAvailable(true);
            Map<String, String> validProperties = KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.PreDefinedNetworkCustomProperties, version));
            // to backend and frontend (lvernia)
            if (!logicalNetwork.getEntity().isVmNetwork()) {
                // $NON-NLS-1$
                validProperties.remove("bridge_opts");
            }
            validProperties.putAll(KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.UserDefinedNetworkCustomProperties, version)));
            customPropertiesModel.setKeyValueMap(validProperties);
            customPropertiesModel.deserialize(KeyValueModel.convertProperties(entity.getCustomProperties()));
        }
        networkDialogModel.getIsToSync().setIsChangable(!logicalNetwork.isInSync());
        networkDialogModel.getIsToSync().setEntity(networksToSync.contains(logicalNetwork.getName()));
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HostNetworkQosSupported, version)) {
            networkDialogModel.getQosOverridden().setIsAvailable(true);
            networkDialogModel.getQosModel().setIsAvailable(true);
            networkDialogModel.getQosOverridden().setEntity(entity.isQosOverridden());
            networkDialogModel.getQosModel().init(entity.getQos());
        }
        editPopup = networkDialogModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!networkDialogModel.validate()) {
                    return;
                }
                entity.setBootProtocol(networkDialogModel.getBootProtocol());
                if (networkDialogModel.getIsStaticAddress()) {
                    entity.setAddress(networkDialogModel.getAddress().getEntity());
                    entity.setSubnet(networkDialogModel.getSubnet().getEntity());
                    entity.setGateway(networkDialogModel.getGateway().getEntity());
                }
                if (networkDialogModel.getQosModel().getIsAvailable()) {
                    entity.setQosOverridden(networkDialogModel.getQosOverridden().getEntity());
                    entity.setQos(networkDialogModel.getQosModel().flush());
                }
                if (networkDialogModel.getCustomPropertiesModel().getIsAvailable()) {
                    entity.setCustomProperties(KeyValueModel.convertProperties(networkDialogModel.getCustomPropertiesModel().serialize()));
                }
                if (networkDialogModel.getIsToSync().getEntity()) {
                    networksToSync.add(logicalNetwork.getName());
                } else {
                    networksToSync.remove(logicalNetwork.getName());
                }
                sourceListModel.setConfirmWindow(null);
            }
        };
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OK", okTarget);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#method_after
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getEntity();
        editPopup = new SetupNetworksEditBondModel(entity, getFreeLabels(), labelToIface);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondDialogModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                Collection<LogicalNetworkModel> potentialNetworks = computeLabelChanges(bondDialogModel.getLabelsModel(), nicMap.get(entity.getName()).getItems());
                if (validateLabelChanges(potentialNetworks)) {
                    setBondOptions(entity, bondDialogModel);
                    commitLabelChanges(bondDialogModel.getLabelsModel(), entity, potentialNetworks);
                    redraw();
                }
            }
        };
    } else if (item instanceof NetworkInterfaceModel) {
        /**
         * ****************
         *  Interface Dialog
         * *****************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getEntity();
        final HostNicModel interfacePopupModel = new HostNicModel(entity, getFreeLabels(), labelToIface);
        editPopup = interfacePopupModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand uiCommand) {
                if (!interfacePopupModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                Collection<LogicalNetworkModel> potentialNetworks = computeLabelChanges(interfacePopupModel.getLabelsModel(), nicMap.get(entity.getName()).getItems());
                if (validateLabelChanges(potentialNetworks)) {
                    commitLabelChanges(interfacePopupModel.getLabelsModel(), entity, potentialNetworks);
                    redraw();
                }
            }
        };
    } else if (item instanceof LogicalNetworkModel) {
        /**
         * **************
         *  Network Dialog
         * ***************
         */
        final LogicalNetworkModel logicalNetwork = (LogicalNetworkModel) item;
        final VdsNetworkInterface entity = logicalNetwork.hasVlan() ? logicalNetwork.getVlanNicModel().getEntity() : logicalNetwork.getAttachedToNic().getEntity();
        final HostInterfaceModel networkDialogModel;
        String version = getEntity().getVdsGroupCompatibilityVersion().getValue();
        if (logicalNetwork.isManagement()) {
            networkDialogModel = new HostManagementNetworkModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            networkDialogModel.setEntity(logicalNetwork.getEntity());
            networkDialogModel.setNoneBootProtocolAvailable(false);
            networkDialogModel.getInterface().setIsAvailable(false);
        } else {
            networkDialogModel = new HostInterfaceModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetwork.getName()));
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangable(false);
            networkDialogModel.getGateway().setIsAvailable((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MultipleGatewaysSupported, version));
        }
        networkDialogModel.getNetwork().setSelectedItem(logicalNetwork.getEntity());
        networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetwork.getName()));
        networkDialogModel.getAddress().setEntity(entity.getAddress());
        networkDialogModel.getSubnet().setEntity(entity.getSubnet());
        networkDialogModel.getGateway().setEntity(entity.getGateway());
        networkDialogModel.setStaticIpChangeAllowed(!getEntity().getHostName().equals(entity.getAddress()));
        networkDialogModel.getBondingOptions().setIsAvailable(false);
        networkDialogModel.setBootProtocol(entity.getBootProtocol());
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HostNetworkQosSupported, version)) {
            networkDialogModel.getQosOverridden().setIsAvailable(true);
            networkDialogModel.getQosModel().setIsAvailable(true);
            networkDialogModel.getQosOverridden().setEntity(entity.isQosOverridden());
            networkDialogModel.getQosModel().init(entity.getQos());
        }
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.NetworkCustomPropertiesSupported, version)) {
            KeyValueModel customPropertiesModel = networkDialogModel.getCustomPropertiesModel();
            customPropertiesModel.setIsAvailable(true);
            Map<String, String> validProperties = KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.PreDefinedNetworkCustomProperties, version));
            // to backend and frontend (lvernia)
            if (!logicalNetwork.getEntity().isVmNetwork()) {
                // $NON-NLS-1$
                validProperties.remove("bridge_opts");
            }
            validProperties.putAll(KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.UserDefinedNetworkCustomProperties, version)));
            customPropertiesModel.setKeyValueMap(validProperties);
            customPropertiesModel.deserialize(KeyValueModel.convertProperties(entity.getCustomProperties()));
        }
        networkDialogModel.getIsToSync().setIsChangable(!logicalNetwork.isInSync());
        networkDialogModel.getIsToSync().setEntity(networksToSync.contains(logicalNetwork.getName()));
        editPopup = networkDialogModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!networkDialogModel.validate()) {
                    return;
                }
                entity.setBootProtocol(networkDialogModel.getBootProtocol());
                if (networkDialogModel.getIsStaticAddress()) {
                    entity.setAddress(networkDialogModel.getAddress().getEntity());
                    entity.setSubnet(networkDialogModel.getSubnet().getEntity());
                    entity.setGateway(networkDialogModel.getGateway().getEntity());
                }
                if (networkDialogModel.getQosModel().getIsAvailable()) {
                    entity.setQosOverridden(networkDialogModel.getQosOverridden().getEntity());
                    entity.setQos(networkDialogModel.getQosModel().flush());
                }
                if (networkDialogModel.getCustomPropertiesModel().getIsAvailable()) {
                    entity.setCustomProperties(KeyValueModel.convertProperties(networkDialogModel.getCustomPropertiesModel().serialize()));
                }
                if (networkDialogModel.getIsToSync().getEntity()) {
                    networksToSync.add(logicalNetwork.getName());
                } else {
                    networksToSync.remove(logicalNetwork.getName());
                }
                sourceListModel.setConfirmWindow(null);
            }
        };
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OK", okTarget);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#end_block

#method_before
private void updateProperties() {
    VmPool pool = (VmPool) getEntity();
    setName(pool.getName());
    setDescription(pool.getVmPoolDescription());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            // refactor to "switch ... case...".
            if (result != null) {
                setvm((VM) ((VdcQueryReturnValue) result).getReturnValue());
            }
            PoolGeneralModel poolGeneralModel = (PoolGeneralModel) model;
            if (getvm() != null) {
                poolGeneralModel.setTemplate(vmTemplateNameRenderer.render(getvm()));
                poolGeneralModel.setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(getvm().getNumOfCpus(), getvm().getNumOfSockets(), getvm().getCpuPerSocket()));
                poolGeneralModel.setMonitorCount(getvm().getNumOfMonitors());
                poolGeneralModel.setOS(getvm().getVmOsId());
                // $NON-NLS-1$
                poolGeneralModel.setDefinedMemory(getvm().getVmMemSizeMb() + " MB");
                // $NON-NLS-1$
                poolGeneralModel.setMinAllocatedMemory(getvm().getMinAllocatedMem() + " MB");
                Translator translator = EnumTranslator.create(DisplayType.class);
                poolGeneralModel.setDefaultDisplayType(translator.get(getvm().getDefaultDisplayType()));
                translator = EnumTranslator.create(OriginType.class);
                poolGeneralModel.setOrigin(translator.get(getvm().getOrigin()));
                translator = EnumTranslator.create(UsbPolicy.class);
                poolGeneralModel.setUsbPolicy(translator.get(getvm().getUsbPolicy()));
                setHasDomain(AsyncDataProvider.getInstance().isWindowsOsType(getvm().getVmOsId()));
                setHasTimeZone(AsyncDataProvider.getInstance().isWindowsOsType(getvm().getVmOsId()));
                poolGeneralModel.setTimeZone(getvm().getTimeZone());
                poolGeneralModel.setIsStateless(getvm().isStateless());
                poolGeneralModel.setQuotaName(getvm().getQuotaName());
                poolGeneralModel.setHasDefaultHost(getvm().getDedicatedVmForVds() != null);
                if (poolGeneralModel.getHasDefaultHost()) {
                    AsyncQuery _asyncQuery1 = new AsyncQuery();
                    _asyncQuery1.setModel(poolGeneralModel);
                    _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model1, Object ReturnValue1) {
                            PoolGeneralModel poolGeneralModel1 = (PoolGeneralModel) model1;
                            ArrayList<VDS> hosts = (ArrayList<VDS>) ((VdcQueryReturnValue) ReturnValue1).getReturnValue();
                            for (VDS host : hosts) {
                                if (host.getId().equals(poolGeneralModel1.getvm().getDedicatedVmForVds())) {
                                    poolGeneralModel1.setDefaultHost(host.getName());
                                    break;
                                }
                            }
                        }
                    };
                    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(// $NON-NLS-1$
                    "Host: cluster = " + getvm().getVdsGroupName() + " sortby name", SearchType.VDS), // $NON-NLS-1$
                    _asyncQuery1);
                } else {
                    poolGeneralModel.setDefaultHost(ConstantsManager.getInstance().getConstants().anyHostInCluster());
                }
            } else {
                poolGeneralModel.setTemplate(null);
                poolGeneralModel.setCpuCount(0);
                poolGeneralModel.setMonitorCount(0);
                poolGeneralModel.setOS(0);
                poolGeneralModel.setDefinedMemory(null);
                poolGeneralModel.setMinAllocatedMemory(null);
                poolGeneralModel.setDefaultDisplayType(null);
                poolGeneralModel.setHasDomain(false);
                poolGeneralModel.setDomain(null);
                poolGeneralModel.setHasTimeZone(false);
                poolGeneralModel.setTimeZone(null);
                poolGeneralModel.setUsbPolicy(null);
                poolGeneralModel.setDefaultHost(null);
                poolGeneralModel.setIsStateless(false);
                poolGeneralModel.getUpdateCompleteEvent().raise(this, EventArgs.EMPTY);
            }
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmDataByPoolId, new IdQueryParameters(pool.getVmPoolId()), _asyncQuery);
}
#method_after
private void updateProperties() {
    VmPool pool = (VmPool) getEntity();
    setName(pool.getName());
    setDescription(pool.getVmPoolDescription());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            // refactor to "switch ... case...".
            if (result != null) {
                setvm((VM) ((VdcQueryReturnValue) result).getReturnValue());
            }
            PoolGeneralModel poolGeneralModel = (PoolGeneralModel) model;
            if (getvm() != null) {
                poolGeneralModel.setTemplate(vmTemplateNameRenderer.render(getvm()));
                poolGeneralModel.setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(getvm().getNumOfCpus(), getvm().getNumOfSockets(), getvm().getCpuPerSocket()));
                poolGeneralModel.setMonitorCount(getvm().getNumOfMonitors());
                poolGeneralModel.setOS(getvm().getVmOsId());
                // $NON-NLS-1$
                poolGeneralModel.setDefinedMemory(getvm().getVmMemSizeMb() + " MB");
                // $NON-NLS-1$
                poolGeneralModel.setMinAllocatedMemory(getvm().getMinAllocatedMem() + " MB");
                Translator translator = EnumTranslator.getInstance();
                poolGeneralModel.setDefaultDisplayType(translator.get(getvm().getDefaultDisplayType()));
                poolGeneralModel.setOrigin(translator.get(getvm().getOrigin()));
                poolGeneralModel.setUsbPolicy(translator.get(getvm().getUsbPolicy()));
                setHasDomain(AsyncDataProvider.getInstance().isWindowsOsType(getvm().getVmOsId()));
                setHasTimeZone(AsyncDataProvider.getInstance().isWindowsOsType(getvm().getVmOsId()));
                poolGeneralModel.setTimeZone(getvm().getTimeZone());
                poolGeneralModel.setIsStateless(getvm().isStateless());
                poolGeneralModel.setQuotaName(getvm().getQuotaName());
                poolGeneralModel.setHasDefaultHost(getvm().getDedicatedVmForVds() != null);
                if (poolGeneralModel.getHasDefaultHost()) {
                    AsyncQuery _asyncQuery1 = new AsyncQuery();
                    _asyncQuery1.setModel(poolGeneralModel);
                    _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model1, Object ReturnValue1) {
                            PoolGeneralModel poolGeneralModel1 = (PoolGeneralModel) model1;
                            ArrayList<VDS> hosts = ((VdcQueryReturnValue) ReturnValue1).getReturnValue();
                            for (VDS host : hosts) {
                                if (host.getId().equals(poolGeneralModel1.getvm().getDedicatedVmForVds())) {
                                    poolGeneralModel1.setDefaultHost(host.getName());
                                    break;
                                }
                            }
                        }
                    };
                    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(// $NON-NLS-1$
                    "Host: cluster = " + getvm().getVdsGroupName() + " sortby name", SearchType.VDS), // $NON-NLS-1$
                    _asyncQuery1);
                } else {
                    poolGeneralModel.setDefaultHost(ConstantsManager.getInstance().getConstants().anyHostInCluster());
                }
            } else {
                poolGeneralModel.setTemplate(null);
                poolGeneralModel.setCpuCount(0);
                poolGeneralModel.setMonitorCount(0);
                poolGeneralModel.setOS(0);
                poolGeneralModel.setDefinedMemory(null);
                poolGeneralModel.setMinAllocatedMemory(null);
                poolGeneralModel.setDefaultDisplayType(null);
                poolGeneralModel.setHasDomain(false);
                poolGeneralModel.setDomain(null);
                poolGeneralModel.setHasTimeZone(false);
                poolGeneralModel.setTimeZone(null);
                poolGeneralModel.setUsbPolicy(null);
                poolGeneralModel.setDefaultHost(null);
                poolGeneralModel.setIsStateless(false);
                poolGeneralModel.getUpdateCompleteEvent().raise(this, EventArgs.EMPTY);
            }
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmDataByPoolId, new IdQueryParameters(pool.getVmPoolId()), _asyncQuery);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            NetworkProfileListModel.this.setItems((List<VnicProfileView>) returnValue);
        }
    };
    AsyncDataProvider.getInstance().getVnicProfilesByNetworkId(asyncQuery, getEntity().getId());
}
#method_after
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setItems((Collection<VnicProfileView>) returnValue);
        }
    };
    AsyncDataProvider.getInstance().getVnicProfilesByNetworkId(asyncQuery, getEntity().getId());
}
#end_block

#method_before
public void manageEvents() {
    EventNotificationModel model = new EventNotificationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().addEventNotificationTitle());
    model.setHelpTag(HelpTag.add_event_notification);
    // $NON-NLS-1$
    model.setHashName("add_event_notification");
    ArrayList<EventNotificationEntity> eventTypes = ApplicationModeHelper.getModeSpecificEventNotificationTypeList();
    Map<EventNotificationEntity, HashSet<AuditLogType>> availableEvents = AsyncDataProvider.getInstance().getAvailableNotificationEvents();
    Translator eventNotificationEntityTranslator = EnumTranslator.create(EventNotificationEntity.class);
    Translator auditLogTypeTranslator = EnumTranslator.create(AuditLogType.class);
    ArrayList<SelectionTreeNodeModel> list = new ArrayList<SelectionTreeNodeModel>();
    ArrayList<event_subscriber> items = getItems() == null ? new ArrayList<event_subscriber>() : Linq.<event_subscriber>cast(getItems());
    for (EventNotificationEntity eventType : eventTypes) {
        SelectionTreeNodeModel stnm = new SelectionTreeNodeModel();
        stnm.setTitle(eventType.toString());
        stnm.setDescription(eventNotificationEntityTranslator.containsKey(eventType) ? eventNotificationEntityTranslator.get(eventType) : eventType.toString());
        list.add(stnm);
        for (AuditLogType logtype : availableEvents.get(eventType)) {
            SelectionTreeNodeModel eventGrp = new SelectionTreeNodeModel();
            String description;
            try {
                description = auditLogTypeTranslator.get(logtype);
            } catch (MissingResourceException e) {
                description = logtype.toString();
            }
            eventGrp.setTitle(logtype.toString());
            eventGrp.setDescription(description);
            eventGrp.setParent(list.get(list.size() - 1));
            eventGrp.setIsSelectedNotificationPrevent(true);
            eventGrp.setIsSelectedNullable(false);
            for (event_subscriber es : items) {
                if (es.getevent_up_name().equals(logtype.toString())) {
                    eventGrp.setIsSelectedNullable(true);
                    break;
                }
            }
            list.get(list.size() - 1).getChildren().add(eventGrp);
            eventGrp.setIsSelectedNotificationPrevent(false);
        }
        if (list.get(list.size() - 1).getChildren().size() > 0) {
            list.get(list.size() - 1).getChildren().get(0).updateParentSelection();
        }
    }
    model.setEventGroupModels(list);
    if (!StringHelper.isNullOrEmpty(getEntity().getEmail())) {
        model.getEmail().setEntity(getEntity().getEmail());
    } else if (items.size() > 0) {
        model.getEmail().setEntity(items.get(0).getmethod_address());
    }
    model.setOldEmail((String) model.getEmail().getEntity());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void manageEvents() {
    EventNotificationModel model = new EventNotificationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().addEventNotificationTitle());
    model.setHelpTag(HelpTag.add_event_notification);
    // $NON-NLS-1$
    model.setHashName("add_event_notification");
    ArrayList<EventNotificationEntity> eventTypes = ApplicationModeHelper.getModeSpecificEventNotificationTypeList();
    Map<EventNotificationEntity, HashSet<AuditLogType>> availableEvents = AsyncDataProvider.getInstance().getAvailableNotificationEvents();
    Translator translator = EnumTranslator.getInstance();
    ArrayList<SelectionTreeNodeModel> list = new ArrayList<SelectionTreeNodeModel>();
    ArrayList<event_subscriber> items = getItems() == null ? new ArrayList<event_subscriber>() : Linq.<event_subscriber>cast(getItems());
    for (EventNotificationEntity eventType : eventTypes) {
        SelectionTreeNodeModel stnm = new SelectionTreeNodeModel();
        stnm.setTitle(eventType.toString());
        stnm.setDescription(translator.get(eventType));
        list.add(stnm);
        for (AuditLogType logtype : availableEvents.get(eventType)) {
            SelectionTreeNodeModel eventGrp = new SelectionTreeNodeModel();
            String description;
            try {
                description = translator.get(logtype);
            } catch (MissingResourceException e) {
                description = logtype.toString();
            }
            eventGrp.setTitle(logtype.toString());
            eventGrp.setDescription(description);
            eventGrp.setParent(list.get(list.size() - 1));
            eventGrp.setIsSelectedNotificationPrevent(true);
            eventGrp.setIsSelectedNullable(false);
            for (event_subscriber es : items) {
                if (es.getevent_up_name().equals(logtype.toString())) {
                    eventGrp.setIsSelectedNullable(true);
                    break;
                }
            }
            list.get(list.size() - 1).getChildren().add(eventGrp);
            eventGrp.setIsSelectedNotificationPrevent(false);
        }
        if (list.get(list.size() - 1).getChildren().size() > 0) {
            list.get(list.size() - 1).getChildren().get(0).updateParentSelection();
        }
    }
    model.setEventGroupModels(list);
    if (!StringHelper.isNullOrEmpty(getEntity().getEmail())) {
        model.getEmail().setEntity(getEntity().getEmail());
    } else if (items.size() > 0) {
        model.getEmail().setEntity(items.get(0).getmethod_address());
    }
    model.setOldEmail((String) model.getEmail().getEntity());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getBaseTemplate().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getInstanceTypes().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getSerialNumberPolicy().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangable(false);
        getRngPeriod().setIsChangable(false);
        getRngBytes().setIsChangable(false);
        getRngSourceRandom().setIsChangable(false);
        getRngSourceHwrng().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#method_after
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getBaseTemplate().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getInstanceTypes().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getSerialNumberPolicy().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangable(false);
        getRngPeriod().setIsChangable(false);
        getRngBytes().setIsChangable(false);
        getRngSourceRandom().setIsChangable(false);
        getRngSourceHwrng().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        getCustomPropertySheet().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#end_block

#method_before
public void updateWatchdogItems(Set<VmWatchdogType> vmWatchdogTypes) {
    List<String> watchDogModels = new ArrayList<String>();
    for (VmWatchdogType vmWatchdogType : vmWatchdogTypes) {
        watchDogModels.add(EnumTranslator.createAndTranslate(vmWatchdogType));
    }
    watchDogModels.add(0, null);
    String oldWatchdogSelected = (String) getWatchdogModel().getSelectedItem();
    getWatchdogModel().setItems(watchDogModels);
    if (watchDogModels.contains(oldWatchdogSelected)) {
        getWatchdogModel().setSelectedItem(oldWatchdogSelected);
    }
}
#method_after
public void updateWatchdogItems(Set<VmWatchdogType> vmWatchdogTypes) {
    List<String> watchDogModels = new ArrayList<String>();
    for (VmWatchdogType vmWatchdogType : vmWatchdogTypes) {
        watchDogModels.add(EnumTranslator.getInstance().get(vmWatchdogType));
    }
    watchDogModels.add(0, null);
    String oldWatchdogSelected = (String) getWatchdogModel().getSelectedItem();
    getWatchdogModel().setItems(watchDogModels);
    if (watchDogModels.contains(oldWatchdogSelected)) {
        getWatchdogModel().setSelectedItem(oldWatchdogSelected);
    }
}
#end_block

#method_before
public TimeZoneType getTimeZoneType() {
    // can be null as a consequence of setItems on ListModel
    Integer vmOsType = getModel().getOSType().getSelectedItem();
    return AsyncDataProvider.getInstance().getInstance().isWindowsOsType(vmOsType) ? TimeZoneType.WINDOWS_TIMEZONE : TimeZoneType.GENERAL_TIMEZONE;
}
#method_after
public TimeZoneType getTimeZoneType() {
    // can be null as a consequence of setItems on ListModel
    Integer vmOsType = getModel().getOSType().getSelectedItem();
    return AsyncDataProvider.getInstance().isWindowsOsType(vmOsType) ? TimeZoneType.WINDOWS_TIMEZONE : TimeZoneType.GENERAL_TIMEZONE;
}
#end_block

#method_before
public void updataMaxVmsInPool() {
    AsyncDataProvider.getInstance().getInstance().getMaxVmsInPool(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
            behavior.setMaxVmsInPool((Integer) returnValue);
            behavior.updateMaxNumOfVmCpus();
        }
    }));
}
#method_after
public void updataMaxVmsInPool() {
    AsyncDataProvider.getInstance().getMaxVmsInPool(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
            behavior.setMaxVmsInPool((Integer) returnValue);
            behavior.updateMaxNumOfVmCpus();
        }
    }));
}
#end_block

#method_before
public void initDisks() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    AsyncDataProvider.getInstance().getTemplateDiskList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            ArrayList<DiskImage> disks = (ArrayList<DiskImage>) returnValue;
            Collections.sort(disks, new Linq.DiskByAliasComparer());
            ArrayList<DiskModel> list = new ArrayList<DiskModel>();
            for (Disk disk : disks) {
                DiskModel diskModel = new DiskModel();
                diskModel.getAlias().setEntity(disk.getDiskAlias());
                if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                    DiskImage diskImage = (DiskImage) disk;
                    EntityModel tempVar = new EntityModel();
                    tempVar.setEntity(diskImage.getSizeInGigabytes());
                    diskModel.setSize(tempVar);
                    ListModel tempVar2 = new ListModel();
                    tempVar2.setItems((diskImage.getVolumeType() == VolumeType.Preallocated ? new ArrayList<VolumeType>(Arrays.asList(new VolumeType[] { VolumeType.Preallocated })) : AsyncDataProvider.getInstance().getInstance().getVolumeTypeList()));
                    tempVar2.setSelectedItem(diskImage.getVolumeType());
                    diskModel.setVolumeType(tempVar2);
                    diskModel.getVolumeType().setIsAvailable(false);
                }
                diskModel.setDisk(disk);
                list.add(diskModel);
            }
            model.setDisks(list);
            updateIsDisksAvailable();
            initStorageDomains();
        }
    }, getModel().getHash()), template.getId());
}
#method_after
public void initDisks() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    AsyncDataProvider.getInstance().getTemplateDiskList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            ArrayList<DiskImage> disks = (ArrayList<DiskImage>) returnValue;
            Collections.sort(disks, new Linq.DiskByAliasComparer());
            ArrayList<DiskModel> list = new ArrayList<DiskModel>();
            for (Disk disk : disks) {
                DiskModel diskModel = new DiskModel();
                diskModel.getAlias().setEntity(disk.getDiskAlias());
                if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                    DiskImage diskImage = (DiskImage) disk;
                    EntityModel tempVar = new EntityModel();
                    tempVar.setEntity(diskImage.getSizeInGigabytes());
                    diskModel.setSize(tempVar);
                    ListModel tempVar2 = new ListModel();
                    tempVar2.setItems((diskImage.getVolumeType() == VolumeType.Preallocated ? new ArrayList<VolumeType>(Arrays.asList(new VolumeType[] { VolumeType.Preallocated })) : AsyncDataProvider.getInstance().getVolumeTypeList()));
                    tempVar2.setSelectedItem(diskImage.getVolumeType());
                    diskModel.setVolumeType(tempVar2);
                    diskModel.getVolumeType().setIsAvailable(false);
                }
                diskModel.setDisk(disk);
                list.add(diskModel);
            }
            model.setDisks(list);
            updateIsDisksAvailable();
            initStorageDomains();
        }
    }, getModel().getHash()), template.getId());
}
#end_block

#method_before
protected void updateCpuPinningVisibility() {
    if (getModel().getSelectedCluster() != null) {
        VDSGroup cluster = getModel().getSelectedCluster();
        String compatibilityVersion = cluster.getcompatibility_version().toString();
        boolean isLocalSD = getModel().getSelectedDataCenter() != null && getModel().getSelectedDataCenter().isLocal();
        // cpu pinning is available on Local SD with no consideration for auto assign value
        boolean hasCpuPinning = Boolean.FALSE.equals(getModel().getIsAutoAssign().getEntity()) || isLocalSD;
        if (Boolean.FALSE.equals(AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.CpuPinningEnabled, compatibilityVersion))) {
            hasCpuPinning = false;
        } else if (Boolean.FALSE.equals(AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.CpuPinMigrationEnabled, AsyncDataProvider.getInstance().getInstance().getDefaultConfigurationVersion())) && isVmMigratable() && !isLocalSD) {
            hasCpuPinning = false;
        }
        if (!hasCpuPinning) {
            if (isLocalSD) {
                getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailableLocalStorage());
            } else {
                getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailable());
            }
            getModel().getCpuPinning().setEntity("");
        }
        getModel().getCpuPinning().setIsChangable(hasCpuPinning);
    }
}
#method_after
protected void updateCpuPinningVisibility() {
    if (getModel().getSelectedCluster() != null) {
        VDSGroup cluster = getModel().getSelectedCluster();
        String compatibilityVersion = cluster.getcompatibility_version().toString();
        boolean isLocalSD = getModel().getSelectedDataCenter() != null && getModel().getSelectedDataCenter().isLocal();
        // cpu pinning is available on Local SD with no consideration for auto assign value
        boolean hasCpuPinning = Boolean.FALSE.equals(getModel().getIsAutoAssign().getEntity()) || isLocalSD;
        if (Boolean.FALSE.equals(AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.CpuPinningEnabled, compatibilityVersion))) {
            hasCpuPinning = false;
        } else if (Boolean.FALSE.equals(AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.CpuPinMigrationEnabled, AsyncDataProvider.getInstance().getDefaultConfigurationVersion())) && isVmMigratable() && !isLocalSD) {
            hasCpuPinning = false;
        }
        if (!hasCpuPinning) {
            if (isLocalSD) {
                getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailableLocalStorage());
            } else {
                getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailable());
            }
            getModel().getCpuPinning().setEntity("");
        }
        getModel().getCpuPinning().setIsChangable(hasCpuPinning);
    }
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<NetworkView> nameColumn = new TextColumnWithTooltip<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameNetwork(), "200px");
    CommentColumn<NetworkView> commentColumn = new CommentColumn<NetworkView>();
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(commentColumn, commentColumn.getHeaderHtml(), "30px");
    TextColumnWithTooltip<NetworkView> dcColumn = new TextColumnWithTooltip<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getDataCenterName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(dcColumn, constants.dcNetwork(), "200px");
    TextColumnWithTooltip<NetworkView> descriptionColumn = new TextColumnWithTooltip<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getDescription();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.descriptionNetwork(), "300px");
    SafeHtmlWithSafeHtmlTooltipColumn<NetworkView> roleColumn = new SafeHtmlWithSafeHtmlTooltipColumn<NetworkView>() {

        @Override
        public SafeHtml getValue(NetworkView networkView) {
            List<SafeHtml> images = new LinkedList<SafeHtml>();
            if (ENGINE_NETWORK_NAME.equals(networkView.getName())) {
                images.add(mgmtImage);
            } else {
                images.add(emptyImage);
            }
            if (networkView.isVmNetwork()) {
                images.add(vmImage);
            } else {
                images.add(emptyImage);
            }
            return NetworkRoleColumnHelper.getValue(images);
        }

        @Override
        public SafeHtml getTooltip(NetworkView networkView) {
            Map<SafeHtml, String> imagesToText = new LinkedHashMap<SafeHtml, String>();
            if (ENGINE_NETWORK_NAME.equals(networkView.getName())) {
                imagesToText.put(mgmtImage, constants.managementItemInfo());
            }
            if (networkView.isVmNetwork()) {
                imagesToText.put(vmImage, constants.vmItemInfo());
            }
            return NetworkRoleColumnHelper.getTooltip(imagesToText);
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(roleColumn, constants.roleNetwork(), "60px");
    TextColumnWithTooltip<NetworkView> vlanColumn = new TextColumnWithTooltip<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getVlanId() == null ? "-" : object.getVlanId().toString();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(vlanColumn, constants.vlanNetwork(), "200px");
    TextColumnWithTooltip<NetworkView> labelColumn = new TextColumnWithTooltip<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getLabel() == null ? "-" : object.getLabel();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(labelColumn, constants.networkLabelNetworksTab(), "200px");
    providerColumn = new LinkColumnWithTooltip<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getProvidedBy() == null ? "" : object.getProviderName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(providerColumn, constants.providerNetwork(), "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.newNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.importNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getImportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.editNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.removeNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<NetworkView> nameColumn = new TextColumnWithTooltip<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(NetworkConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameNetwork(), "200px");
    CommentColumn<NetworkView> commentColumn = new CommentColumn<NetworkView>();
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(commentColumn, commentColumn.getHeaderHtml(), "30px");
    TextColumnWithTooltip<NetworkView> dcColumn = new TextColumnWithTooltip<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getDataCenterName();
        }
    };
    dcColumn.makeSortable(NetworkConditionFieldAutoCompleter.DATA_CENTER);
    // $NON-NLS-1$
    getTable().addColumn(dcColumn, constants.dcNetwork(), "200px");
    TextColumnWithTooltip<NetworkView> descriptionColumn = new TextColumnWithTooltip<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable(NetworkConditionFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.descriptionNetwork(), "300px");
    SafeHtmlWithSafeHtmlTooltipColumn<NetworkView> roleColumn = new SafeHtmlWithSafeHtmlTooltipColumn<NetworkView>() {

        @Override
        public SafeHtml getValue(NetworkView networkView) {
            List<SafeHtml> images = new LinkedList<SafeHtml>();
            if (ENGINE_NETWORK_NAME.equals(networkView.getName())) {
                images.add(mgmtImage);
            } else {
                images.add(emptyImage);
            }
            if (networkView.isVmNetwork()) {
                images.add(vmImage);
            } else {
                images.add(emptyImage);
            }
            return NetworkRoleColumnHelper.getValue(images);
        }

        @Override
        public SafeHtml getTooltip(NetworkView networkView) {
            Map<SafeHtml, String> imagesToText = new LinkedHashMap<SafeHtml, String>();
            if (ENGINE_NETWORK_NAME.equals(networkView.getName())) {
                imagesToText.put(mgmtImage, constants.managementItemInfo());
            }
            if (networkView.isVmNetwork()) {
                imagesToText.put(vmImage, constants.vmItemInfo());
            }
            return NetworkRoleColumnHelper.getTooltip(imagesToText);
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(roleColumn, constants.roleNetwork(), "60px");
    TextColumnWithTooltip<NetworkView> vlanColumn = new TextColumnWithTooltip<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getVlanId() == null ? "-" : object.getVlanId().toString();
        }
    };
    vlanColumn.makeSortable(NetworkConditionFieldAutoCompleter.VLAN_ID);
    // $NON-NLS-1$
    getTable().addColumn(vlanColumn, constants.vlanNetwork(), "200px");
    TextColumnWithTooltip<NetworkView> labelColumn = new TextColumnWithTooltip<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getLabel() == null ? "-" : object.getLabel();
        }
    };
    labelColumn.makeSortable(NetworkConditionFieldAutoCompleter.LABEL);
    // $NON-NLS-1$
    getTable().addColumn(labelColumn, constants.networkLabelNetworksTab(), "200px");
    providerColumn = new LinkColumnWithTooltip<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getProvidedBy() == null ? "" : object.getProviderName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(providerColumn, constants.providerNetwork(), "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.newNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.importNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getImportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.editNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.removeNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
}
#end_block

#method_before
private void updateDisksWarningByImageStatus(List<DiskModel> disks, ImageStatus imageStatus) {
    ArrayList<String> disksAliases = getDisksAliasesByImageStatus(disks, imageStatus);
    if (!disksAliases.isEmpty()) {
        generalWarningMessage.setText(messages.disksStatusWarning(EnumTranslator.createAndTranslate(imageStatus), // $NON-NLS-1$
        (StringUtils.join(disksAliases, ", "))));
    }
}
#method_after
private void updateDisksWarningByImageStatus(List<DiskModel> disks, ImageStatus imageStatus) {
    ArrayList<String> disksAliases = getDisksAliasesByImageStatus(disks, imageStatus);
    if (!disksAliases.isEmpty()) {
        generalWarningMessage.setText(messages.disksStatusWarning(EnumTranslator.getInstance().get(imageStatus), // $NON-NLS-1$
        (StringUtils.join(disksAliases, ", "))));
    }
}
#end_block

#method_before
private void updateProperties() {
    VDS vds = getEntity();
    setOS(vds.getHostOs());
    setKernelVersion(vds.getKernelVersion());
    setKvmVersion(vds.getKvmVersion());
    setLibvirtVersion(vds.getLibvirtVersion());
    setVdsmVersion(vds.getVersion());
    setSpiceVersion(vds.getSpiceVersion());
    setGlusterVersion(vds.getGlusterVersion());
    setIScsiInitiatorName(vds.getIScsiInitiatorName());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setActiveVms(vds.getVmActive());
    setPhysicalMemory(vds.getPhysicalMemMb());
    setSwapTotal(vds.getSwapTotal());
    setSwapFree(vds.getSwapFree());
    setSharedMemory(vds.getMemSharedPercent());
    setMemoryPageSharing(vds.getKsmState());
    setAutomaticLargePage(vds.getTransparentHugePagesState());
    setBootTime(vds.getBootTime());
    setKdumpStatus(EnumTranslator.create(KdumpStatus.class).get(vds.getKdumpStatus()));
    setSelinuxEnforceMode(EnumTranslator.create(SELinuxMode.class).get(vds.getSELinuxEnforceMode()));
    setLiveSnapshotSupport(vds.getLiveSnapshotSupport());
    if (!vds.getHighlyAvailableIsConfigured()) {
        setHostedEngineHaIsConfigured(false);
        setHostedEngineHa(constants.bracketedNotAvailableLabel());
    } else {
        setHostedEngineHaIsConfigured(true);
        if (!vds.getHighlyAvailableIsActive()) {
            setHostedEngineHa(constants.haNotActive());
        } else if (vds.getHighlyAvailableGlobalMaintenance()) {
            setHostedEngineHa(constants.haGlobalMaintenance());
        } else if (vds.getHighlyAvailableLocalMaintenance()) {
            setHostedEngineHa(constants.haLocalMaintenance());
        } else {
            setHostedEngineHa(messages.haActive(vds.getHighlyAvailableScore()));
        }
    }
    if (vds.getVdsGroupCompatibilityVersion() != null && Version.v3_2.compareTo(vds.getVdsGroupCompatibilityVersion()) > 0) {
        setLogicalCores(vds.getCpuCores());
    } else {
        setLogicalCores(vds.getCpuThreads());
    }
}
#method_after
private void updateProperties() {
    VDS vds = getEntity();
    setOS(vds.getHostOs());
    setKernelVersion(vds.getKernelVersion());
    setKvmVersion(vds.getKvmVersion());
    setLibvirtVersion(vds.getLibvirtVersion());
    setVdsmVersion(vds.getVersion());
    setSpiceVersion(vds.getSpiceVersion());
    setGlusterVersion(vds.getGlusterVersion());
    setIScsiInitiatorName(vds.getIScsiInitiatorName());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setActiveVms(vds.getVmActive());
    setPhysicalMemory(vds.getPhysicalMemMb());
    setSwapTotal(vds.getSwapTotal());
    setSwapFree(vds.getSwapFree());
    setSharedMemory(vds.getMemSharedPercent());
    setMemoryPageSharing(vds.getKsmState());
    setAutomaticLargePage(vds.getTransparentHugePagesState());
    setBootTime(vds.getBootTime());
    setKdumpStatus(EnumTranslator.getInstance().get(vds.getKdumpStatus()));
    setSelinuxEnforceMode(EnumTranslator.getInstance().get(vds.getSELinuxEnforceMode()));
    setLiveSnapshotSupport(vds.getLiveSnapshotSupport());
    if (!vds.getHighlyAvailableIsConfigured()) {
        setHostedEngineHaIsConfigured(false);
        setHostedEngineHa(constants.bracketedNotAvailableLabel());
    } else {
        setHostedEngineHaIsConfigured(true);
        if (!vds.getHighlyAvailableIsActive()) {
            setHostedEngineHa(constants.haNotActive());
        } else if (vds.getHighlyAvailableGlobalMaintenance()) {
            setHostedEngineHa(constants.haGlobalMaintenance());
        } else if (vds.getHighlyAvailableLocalMaintenance()) {
            setHostedEngineHa(constants.haLocalMaintenance());
        } else {
            setHostedEngineHa(messages.haActive(vds.getHighlyAvailableScore()));
        }
    }
    if (vds.getVdsGroupCompatibilityVersion() != null && Version.v3_2.compareTo(vds.getVdsGroupCompatibilityVersion()) > 0) {
        setLogicalCores(vds.getCpuCores());
    } else {
        setLogicalCores(vds.getCpuThreads());
    }
}
#end_block

#method_before
private void initNetworkList(final VnicProfileModel profileModel) {
    SystemTreeItemModel treeSelectedItem = (SystemTreeItemModel) CommonModel.getInstance().getSystemTree().getSelectedItem();
    SystemTreeItemModel treeSelectedNetwork = treeSelectedItem.getType() == SystemTreeItemType.Network ? treeSelectedItem : null;
    if (treeSelectedNetwork != null) {
        Network network = (Network) treeSelectedNetwork.getEntity();
        profileModel.getNetwork().setItems(Arrays.asList(network));
        profileModel.getNetwork().setSelectedItem(network);
        profileModel.getNetwork().setIsChangable(false);
        return;
    }
    SystemTreeItemModel treeSelectedDc = treeSelectedItem.getType() == SystemTreeItemType.DataCenter ? treeSelectedItem : null;
    if (treeSelectedDc != null) {
        profileModel.startProgress(null);
        StoragePool dc = (StoragePool) treeSelectedDc.getEntity();
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object ReturnValue) {
                ArrayList<Network> networks = (ArrayList<Network>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
                profileModel.getNetwork().setItems(networks);
                if (profileModel instanceof EditVnicProfileModel) {
                    Network currentNetwork = findNetwork(profileModel.getProfile().getNetworkId(), networks);
                    profileModel.getNetwork().setSelectedItem(currentNetwork);
                    profileModel.getNetwork().setIsChangable(false);
                } else {
                    profileModel.getNetwork().setSelectedItem(Linq.firstOrDefault(networks));
                }
                profileModel.stopProgress();
            }
        };
        IdQueryParameters queryParams = new IdQueryParameters(dc.getId());
        Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworks, queryParams, _asyncQuery);
    }
}
#method_after
private void initNetworkList(final VnicProfileModel profileModel) {
    SystemTreeItemModel treeSelectedItem = (SystemTreeItemModel) CommonModel.getInstance().getSystemTree().getSelectedItem();
    SystemTreeItemModel treeSelectedNetwork = treeSelectedItem.getType() == SystemTreeItemType.Network ? treeSelectedItem : null;
    if (treeSelectedNetwork != null) {
        Network network = (Network) treeSelectedNetwork.getEntity();
        profileModel.getNetwork().setItems(Arrays.asList(network));
        profileModel.getNetwork().setSelectedItem(network);
        profileModel.getNetwork().setIsChangable(false);
        return;
    }
    SystemTreeItemModel treeSelectedDc = treeSelectedItem.getType() == SystemTreeItemType.DataCenter ? treeSelectedItem : null;
    if (treeSelectedDc != null) {
        profileModel.startProgress(null);
        StoragePool dc = (StoragePool) treeSelectedDc.getEntity();
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object ReturnValue) {
                Collection<Network> networks = (Collection<Network>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
                profileModel.getNetwork().setItems(networks);
                if (profileModel instanceof EditVnicProfileModel) {
                    Network currentNetwork = findNetwork(profileModel.getProfile().getNetworkId(), networks);
                    profileModel.getNetwork().setSelectedItem(currentNetwork);
                    profileModel.getNetwork().setIsChangable(false);
                } else {
                    profileModel.getNetwork().setSelectedItem(Linq.firstOrDefault(networks));
                }
                profileModel.stopProgress();
            }
        };
        IdQueryParameters queryParams = new IdQueryParameters(dc.getId());
        Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworks, queryParams, _asyncQuery);
    }
}
#end_block

#method_before
private Network findNetwork(Guid networkId, List<Network> networks) {
    for (Network network : networks) {
        if (networkId.equals(network.getId())) {
            return network;
        }
    }
    return null;
}
#method_after
private Network findNetwork(Guid networkId, Iterable<Network> networks) {
    for (Network network : networks) {
        if (networkId.equals(network.getId())) {
            return network;
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected void syncSearch() {
    // TODO - fix
    // SearchParameters tempVar = new SearchParameters(getSearchString(), SearchType.Profile, isCaseSensitiveSearch());
    // tempVar.setMaxCount(getSearchPageSize());
    // super.syncSearch(VdcQueryType.Search, tempVar);
    SystemTreeItemModel treeSelectedItem = (SystemTreeItemModel) CommonModel.getInstance().getSystemTree().getSelectedItem();
    if (treeSelectedItem == null) {
        return;
    }
    SystemTreeItemModel treeSelectedNetwork = treeSelectedItem.getType() == SystemTreeItemType.Network ? treeSelectedItem : null;
    if (treeSelectedNetwork != null) {
        Network network = (Network) treeSelectedNetwork.getEntity();
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                setItems((List<VnicProfileView>) returnValue);
            }
        };
        AsyncDataProvider.getInstance().getVnicProfilesByNetworkId(asyncQuery, network.getId());
        return;
    }
    SystemTreeItemModel treeSelectedDc = treeSelectedItem.getType() == SystemTreeItemType.DataCenter ? treeSelectedItem : null;
    if (treeSelectedDc != null) {
        StoragePool dc = (StoragePool) treeSelectedDc.getEntity();
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                setItems((List<VnicProfileView>) returnValue);
            }
        };
        AsyncDataProvider.getInstance().getVnicProfilesByDcId(asyncQuery, dc.getId());
    }
}
#method_after
@Override
protected void syncSearch() {
    // TODO - fix
    // SearchParameters tempVar = new SearchParameters(getSearchString(), SearchType.Profile, isCaseSensitiveSearch());
    // tempVar.setMaxCount(getSearchPageSize());
    // super.syncSearch(VdcQueryType.Search, tempVar);
    SystemTreeItemModel treeSelectedItem = (SystemTreeItemModel) CommonModel.getInstance().getSystemTree().getSelectedItem();
    if (treeSelectedItem == null) {
        return;
    }
    SystemTreeItemModel treeSelectedNetwork = treeSelectedItem.getType() == SystemTreeItemType.Network ? treeSelectedItem : null;
    if (treeSelectedNetwork != null) {
        Network network = (Network) treeSelectedNetwork.getEntity();
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                setItems((Collection<VnicProfileView>) returnValue);
            }
        };
        AsyncDataProvider.getInstance().getVnicProfilesByNetworkId(asyncQuery, network.getId());
        return;
    }
    SystemTreeItemModel treeSelectedDc = treeSelectedItem.getType() == SystemTreeItemType.DataCenter ? treeSelectedItem : null;
    if (treeSelectedDc != null) {
        StoragePool dc = (StoragePool) treeSelectedDc.getEntity();
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                setItems((Collection<VnicProfileView>) returnValue);
            }
        };
        AsyncDataProvider.getInstance().getVnicProfilesByDcId(asyncQuery, dc.getId());
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    List tempVar = getSelectedItems();
    ArrayList selectedItems = (ArrayList) ((tempVar != null) ? tempVar : new ArrayList());
    getEditCommand().setIsExecutionAllowed(selectedItems.size() == 1);
    getRemoveCommand().setIsExecutionAllowed(selectedItems.size() > 0);
}
#method_after
private void updateActionAvailability() {
    Collection<VnicProfileView> tempVar = getSelectedItems();
    Collection<VnicProfileView> selectedItems = ((tempVar != null) ? tempVar : new ArrayList());
    getEditCommand().setIsExecutionAllowed(selectedItems.size() == 1);
    getRemoveCommand().setIsExecutionAllowed(selectedItems.size() > 0);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(getSearchString(), SearchType.Network, isCaseSensitiveSearch());
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#method_after
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(applySortOptions(getSearchString()), SearchType.Network, isCaseSensitiveSearch());
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#end_block

#method_before
public static AsyncDataProvider getInstance() {
    return instance;
}
#method_after
public static AsyncDataProvider getInstance() {
    if (instance == null) {
        instance = new AsyncDataProvider();
    }
    return instance;
}
#end_block

#method_before
private void updateProperties() {
    VM vm = (VM) getEntity();
    setName(vm.getName());
    setDescription(vm.getVmDescription());
    // $NON-NLS-1$
    setQuotaName(vm.getQuotaName() != null ? vm.getQuotaName() : "");
    setQuotaAvailable(vm.getQuotaEnforcementType() != null && !vm.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED));
    setTemplate(vmTemplateNameRenderer.render(vm));
    // $NON-NLS-1$
    setDefinedMemory(vm.getVmMemSizeMb() + " MB");
    // $NON-NLS-1$
    setMinAllocatedMemory(vm.getMinAllocatedMem() + " MB");
    setOS(AsyncDataProvider.getInstance().getOsName(vm.getVmOsId()));
    Translator translator = EnumTranslator.create(DisplayType.class);
    setDefaultDisplayType(translator.get(vm.getDefaultDisplayType()));
    translator = EnumTranslator.create(OriginType.class);
    setOrigin(translator.get(vm.getOrigin()));
    setIsHighlyAvailable(vm.isAutoStartup());
    setPriority(AsyncDataProvider.getInstance().priorityToString(vm.getPriority()));
    setMonitorCount(vm.getNumOfMonitors());
    translator = EnumTranslator.create(UsbPolicy.class);
    setUsbPolicy(translator.get(vm.getUsbPolicy()));
    setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(vm.getNumOfCpus(), vm.getNumOfSockets(), vm.getCpuPerSocket()));
    setGuestCpuCount(vm.getGuestCpuCount());
    setHasDomain(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    if (vm.getVmInit() != null) {
        setDomain(vm.getVmInit().getDomain());
    }
    setHasTimeZone(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    setTimeZone(vm.getTimeZone());
    setHasCustomProperties(!StringHelper.isNullOrEmpty(vm.getCustomProperties()));
    // $NON-NLS-1$ //$NON-NLS-2$
    setCustomProperties(getHasCustomProperties() ? "Configured" : "Not-Configured");
    setCompatibilityVersion(vm.getVdsGroupCompatibilityVersion() != null ? vm.getVdsGroupCompatibilityVersion().toString() : // $NON-NLS-1$
    "");
    setVmId(vm.getId().toString());
    setFqdn(vm.getVmFQDN());
    setHasAlert(vm.getVmPauseStatus() != VmPauseStatus.NONE && vm.getVmPauseStatus() != VmPauseStatus.NOERR);
    if (getHasAlert()) {
        translator = EnumTranslator.create(VmPauseStatus.class);
        setAlert(translator.get(vm.getVmPauseStatus()));
    } else {
        setAlert(null);
    }
    setHasDefaultHost(vm.getDedicatedVmForVds() != null);
    if (getHasDefaultHost()) {
        Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(// $NON-NLS-1$
        "Host: cluster = " + vm.getVdsGroupName() + " sortby name", SearchType.VDS), new // $NON-NLS-1$
        AsyncQuery(// $NON-NLS-1$
        this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmGeneralModel model = (VmGeneralModel) target;
                VM localVm = (VM) model.getEntity();
                if (localVm == null) {
                    return;
                }
                ArrayList<VDS> hosts = (ArrayList<VDS>) ((VdcQueryReturnValue) returnValue).getReturnValue();
                for (VDS host : hosts) {
                    if (localVm.getDedicatedVmForVds() != null && host.getId().equals(localVm.getDedicatedVmForVds())) {
                        model.setDefaultHost(host.getName());
                        break;
                    }
                }
            }
        }));
    } else {
        setDefaultHost(ConstantsManager.getInstance().getConstants().anyHostInCluster());
    }
}
#method_after
private void updateProperties() {
    VM vm = (VM) getEntity();
    setName(vm.getName());
    setDescription(vm.getVmDescription());
    // $NON-NLS-1$
    setQuotaName(vm.getQuotaName() != null ? vm.getQuotaName() : "");
    setQuotaAvailable(vm.getQuotaEnforcementType() != null && !vm.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED));
    setTemplate(vmTemplateNameRenderer.render(vm));
    // $NON-NLS-1$
    setDefinedMemory(vm.getVmMemSizeMb() + " MB");
    // $NON-NLS-1$
    setMinAllocatedMemory(vm.getMinAllocatedMem() + " MB");
    setOS(AsyncDataProvider.getInstance().getOsName(vm.getVmOsId()));
    Translator translator = EnumTranslator.getInstance();
    setDefaultDisplayType(translator.get(vm.getDefaultDisplayType()));
    setOrigin(translator.get(vm.getOrigin()));
    setIsHighlyAvailable(vm.isAutoStartup());
    setPriority(AsyncDataProvider.getInstance().priorityToString(vm.getPriority()));
    setMonitorCount(vm.getNumOfMonitors());
    setUsbPolicy(translator.get(vm.getUsbPolicy()));
    setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(vm.getNumOfCpus(), vm.getNumOfSockets(), vm.getCpuPerSocket()));
    setGuestCpuCount(vm.getGuestCpuCount());
    setHasDomain(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    if (vm.getVmInit() != null) {
        setDomain(vm.getVmInit().getDomain());
    }
    setHasTimeZone(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    setTimeZone(vm.getTimeZone());
    setHasCustomProperties(!StringHelper.isNullOrEmpty(vm.getCustomProperties()));
    // $NON-NLS-1$ //$NON-NLS-2$
    setCustomProperties(getHasCustomProperties() ? "Configured" : "Not-Configured");
    setCompatibilityVersion(vm.getVdsGroupCompatibilityVersion() != null ? vm.getVdsGroupCompatibilityVersion().toString() : // $NON-NLS-1$
    "");
    setVmId(vm.getId().toString());
    setFqdn(vm.getVmFQDN());
    setHasAlert(vm.getVmPauseStatus() != VmPauseStatus.NONE && vm.getVmPauseStatus() != VmPauseStatus.NOERR);
    if (getHasAlert()) {
        setAlert(translator.get(vm.getVmPauseStatus()));
    } else {
        setAlert(null);
    }
    setHasDefaultHost(vm.getDedicatedVmForVds() != null);
    if (getHasDefaultHost()) {
        Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(// $NON-NLS-1$
        "Host: cluster = " + vm.getVdsGroupName() + " sortby name", SearchType.VDS), new // $NON-NLS-1$
        AsyncQuery(// $NON-NLS-1$
        this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmGeneralModel model = (VmGeneralModel) target;
                VM localVm = (VM) model.getEntity();
                if (localVm == null) {
                    return;
                }
                ArrayList<VDS> hosts = (ArrayList<VDS>) ((VdcQueryReturnValue) returnValue).getReturnValue();
                for (VDS host : hosts) {
                    if (localVm.getDedicatedVmForVds() != null && host.getId().equals(localVm.getDedicatedVmForVds())) {
                        model.setDefaultHost(host.getName());
                        break;
                    }
                }
            }
        }));
    } else {
        setDefaultHost(ConstantsManager.getInstance().getConstants().anyHostInCluster());
    }
}
#end_block

#method_before
private void updateProperties() {
    VmTemplate template = getEntity();
    setName(template.getName());
    setDescription(template.getDescription());
    // $NON-NLS-1$
    setQuotaName(template.getQuotaName() != null ? template.getQuotaName() : "");
    setQuotaAvailable(template.getQuotaEnforcementType() != null && !template.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED));
    setHostCluster(template.getVdsGroupName());
    // $NON-NLS-1$
    setDefinedMemory(template.getMemSizeMb() + " MB");
    setIsHighlyAvailable(template.isAutoStartup());
    setPriority(AsyncDataProvider.getInstance().priorityToString(template.getPriority()));
    setMonitorCount(template.getNumOfMonitors());
    setAllowConsoleReconnect(template.isAllowConsoleReconnect());
    setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(template.getNumOfCpus(), template.getNumOfSockets(), template.getCpuPerSocket()));
    setOS(AsyncDataProvider.getInstance().getOsName(template.getOsId()));
    Translator translator = EnumTranslator.create(DisplayType.class);
    setDefaultDisplayType(translator.get(template.getDefaultDisplayType()));
    translator = EnumTranslator.create(OriginType.class);
    setOrigin(translator.get(template.getOrigin()));
    setHasDomain(AsyncDataProvider.getInstance().isWindowsOsType(template.getOsId()));
    if (template.getVmInit() != null) {
        setDomain(template.getVmInit().getDomain());
    }
    setHasTimeZone(AsyncDataProvider.getInstance().isWindowsOsType(template.getOsId()));
    setTimeZone(template.getTimeZone());
    setHasUsbPolicy(true);
    translator = EnumTranslator.create(UsbPolicy.class);
    setUsbPolicy(translator.get(template.getUsbPolicy()));
    setIsStateless(template.isStateless());
}
#method_after
private void updateProperties() {
    VmTemplate template = getEntity();
    setName(template.getName());
    setDescription(template.getDescription());
    // $NON-NLS-1$
    setQuotaName(template.getQuotaName() != null ? template.getQuotaName() : "");
    setQuotaAvailable(template.getQuotaEnforcementType() != null && !template.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED));
    setHostCluster(template.getVdsGroupName());
    // $NON-NLS-1$
    setDefinedMemory(template.getMemSizeMb() + " MB");
    setIsHighlyAvailable(template.isAutoStartup());
    setPriority(AsyncDataProvider.getInstance().priorityToString(template.getPriority()));
    setMonitorCount(template.getNumOfMonitors());
    setAllowConsoleReconnect(template.isAllowConsoleReconnect());
    setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(template.getNumOfCpus(), template.getNumOfSockets(), template.getCpuPerSocket()));
    setOS(AsyncDataProvider.getInstance().getOsName(template.getOsId()));
    Translator translator = EnumTranslator.getInstance();
    setDefaultDisplayType(translator.get(template.getDefaultDisplayType()));
    setOrigin(translator.get(template.getOrigin()));
    setHasDomain(AsyncDataProvider.getInstance().isWindowsOsType(template.getOsId()));
    if (template.getVmInit() != null) {
        setDomain(template.getVmInit().getDomain());
    }
    setHasTimeZone(AsyncDataProvider.getInstance().isWindowsOsType(template.getOsId()));
    setTimeZone(template.getTimeZone());
    setHasUsbPolicy(true);
    setUsbPolicy(translator.get(template.getUsbPolicy()));
    setIsStateless(template.isStateless());
}
#end_block

#method_before
@Override
public int compare(ProviderType type1, ProviderType type2) {
    return LexoNumericComparator.comp(EnumTranslator.createAndTranslate(type1), EnumTranslator.createAndTranslate(type2));
}
#method_after
@Override
public int compare(ProviderType type1, ProviderType type2) {
    final EnumTranslator enumTranslator = EnumTranslator.getInstance();
    return LexoNumericComparator.comp(enumTranslator.get(type1), enumTranslator.get(type2));
}
#end_block

#method_before
@Override
protected void toggleGhost(KeyValueLineModel value, KeyValueLineWidget widget, boolean becomingGhost) {
    widget.setEnabled(!becomingGhost);
    widget.keyField.setEnabled(true);
}
#method_after
@Override
protected void toggleGhost(KeyValueLineModel value, KeyValueLineWidget widget, boolean becomingGhost) {
    if (!widget.isEnabled()) {
        return;
    }
    super.toggleGhost(value, widget, becomingGhost);
    widget.valueField.setEnabled(!becomingGhost);
    widget.valuesField.setEnabled(!becomingGhost);
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            vmTypeChanged();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayProtocol();
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayProtocol();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            vmTypeChanged();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayProtocol();
            updateMemoryBalloonDevice();
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayProtocol();
            updateMemoryBalloonDevice();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        }
    }
}
#end_block

#method_before
private void handleQxlClusterLevel() {
    // Enable Single PCI only on cluster 3.3 and high and on Linux OS
    boolean isLinux = getIsLinuxOS();
    boolean isQxl = getDisplayType() == DisplayType.qxl;
    boolean clusterSupportsSinglePci = getSelectedCluster() != null && Version.v3_3.compareTo(getSelectedCluster().getcompatibility_version()) <= 0;
    getBehavior().enableSinglePCI(isLinux && isQxl && clusterSupportsSinglePci);
    if (getSelectedCluster() != null) {
        boolean spiceFileTransferToggle = isQxl && AsyncDataProvider.isSpiceFileTransferToggleSupported(getSelectedCluster().getcompatibility_version().toString());
        if (!spiceFileTransferToggle) {
            handleQxlChangeProhibitionReason(getSpiceFileTransferEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
        }
        getSpiceFileTransferEnabled().setIsChangable(spiceFileTransferToggle);
        boolean spiceCopyPasteToggle = isQxl && AsyncDataProvider.isSpiceCopyPasteToggleSupported(getSelectedCluster().getcompatibility_version().toString());
        if (!spiceCopyPasteToggle) {
            handleQxlChangeProhibitionReason(getSpiceCopyPasteEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
        }
        getSpiceCopyPasteEnabled().setIsChangable(spiceCopyPasteToggle);
    }
}
#method_after
private void handleQxlClusterLevel() {
    getBehavior().enableSinglePCI(getIsQxlSupported());
    if (getSelectedCluster() != null) {
        boolean isQxl = getDisplayType() == DisplayType.qxl;
        boolean spiceFileTransferToggle = isQxl && AsyncDataProvider.isSpiceFileTransferToggleSupported(getSelectedCluster().getcompatibility_version().toString());
        if (!spiceFileTransferToggle) {
            handleQxlChangeProhibitionReason(getSpiceFileTransferEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
        }
        getSpiceFileTransferEnabled().setIsChangable(spiceFileTransferToggle);
        boolean spiceCopyPasteToggle = isQxl && AsyncDataProvider.isSpiceCopyPasteToggleSupported(getSelectedCluster().getcompatibility_version().toString());
        if (!spiceCopyPasteToggle) {
            handleQxlChangeProhibitionReason(getSpiceCopyPasteEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
        }
        getSpiceCopyPasteEnabled().setIsChangable(spiceCopyPasteToggle);
    }
}
#end_block

#method_before
public void updateWatchdogItems(Set<VmWatchdogType> vmWatchdogTypes) {
    List<String> watchDogModels = new ArrayList<String>();
    for (VmWatchdogType vmWatchdogType : vmWatchdogTypes) {
        watchDogModels.add(EnumTranslator.createAndTranslate(vmWatchdogType));
    }
    watchDogModels.add(0, null);
    String oldWatchdogSelected = (String) getWatchdogModel().getSelectedItem();
    getWatchdogModel().setItems(watchDogModels);
    if (watchDogModels.contains(oldWatchdogSelected)) {
        getWatchdogModel().setSelectedItem(oldWatchdogSelected);
    }
}
#method_after
public void updateWatchdogItems(Set<VmWatchdogType> vmWatchdogTypes) {
    List<String> watchDogModels = new ArrayList<String>();
    for (VmWatchdogType vmWatchdogType : vmWatchdogTypes) {
        watchDogModels.add(EnumTranslator.getInstance().get(vmWatchdogType));
    }
    watchDogModels.add(0, null);
    String oldWatchdogSelected = (String) getWatchdogModel().getSelectedItem();
    getWatchdogModel().setItems(watchDogModels);
    if (watchDogModels.contains(oldWatchdogSelected)) {
        getWatchdogModel().setSelectedItem(oldWatchdogSelected);
    }
}
#end_block

#method_before
private DisplayType getDisplayType() {
    EntityModel<DisplayType> entityModel = getDisplayProtocol().getSelectedItem();
    if (entityModel == null) {
        return null;
    }
    return entityModel.getEntity();
}
#method_after
public DisplayType getDisplayType() {
    EntityModel<DisplayType> entityModel = getDisplayProtocol().getSelectedItem();
    if (entityModel == null) {
        return null;
    }
    return entityModel.getEntity();
}
#end_block

#method_before
private void updateEnabled() {
    for (Pair<T, V> item : items) {
        toggleEnabled(item.getSecond(), enabled);
    }
}
#method_after
private void updateEnabled() {
    for (Pair<T, V> item : items) {
        toggleEnabled(item.getFirst(), item.getSecond());
    }
}
#end_block

#method_before
private V addEntry(T value, boolean lastItem) {
    final V widget = createWidget(value);
    Pair<T, V> item = new Pair<T, V>(value, widget);
    items.add(item);
    PushButton removeButton = createButton(item, false);
    AddRemoveRowPanel entry = lastItem ? new AddRemoveRowPanel(widget, removeButton, createButton(item, true)) : new AddRemoveRowPanel(widget, removeButton);
    contentPanel.add(entry);
    final boolean ghost = isGhost(value);
    setButtonsEnabled(widget, !ghost);
    toggleGhost(value, widget, ghost);
    toggleEnabled(widget, enabled);
    widget.addValueChangeHandler(new ValueChangeHandler<T>() {

        private boolean wasGhost = ghost;

        @Override
        public void onValueChange(ValueChangeEvent<T> event) {
            T value = event.getValue();
            boolean becomingGhost = isGhost(value);
            if (becomingGhost != wasGhost) {
                setButtonsEnabled(widget, !becomingGhost);
                toggleGhost(value, widget, becomingGhost);
                wasGhost = becomingGhost;
            }
        }
    });
    return widget;
}
#method_after
private V addEntry(final T value, boolean lastItem) {
    final V widget = createWidget(value);
    Pair<T, V> item = new Pair<T, V>(value, widget);
    items.add(item);
    PushButton removeButton = createButton(item, false);
    AddRemoveRowPanel entry = lastItem ? new AddRemoveRowPanel(widget, removeButton, createButton(item, true)) : new AddRemoveRowPanel(widget, removeButton);
    contentPanel.add(entry);
    toggleEnabled(value, widget);
    widget.addValueChangeHandler(new ValueChangeHandler<T>() {

        private boolean wasGhost = isGhost(value);

        @Override
        public void onValueChange(ValueChangeEvent<T> event) {
            T value = event.getValue();
            boolean becomingGhost = isGhost(value);
            if (becomingGhost != wasGhost) {
                wasGhost = becomingGhost;
                if (enabled) {
                    toggleGhost(value, widget, becomingGhost);
                }
            }
        }
    });
    return widget;
}
#end_block

#method_before
protected void toggleEnabled(V widget, boolean enabled) {
    getEntry(widget).setButtonsEnabled(enabled);
}
#method_after
private void toggleEnabled(T value, V widget) {
    setButtonsEnabled(widget, enabled);
    if (widget instanceof HasEnabled) {
        ((HasEnabled) widget).setEnabled(enabled);
    }
    if (enabled && isGhost(value)) {
        // if entry is enabled, it still might need to be rendered as a ghost entry
        toggleGhost(value, widget, true);
    }
}
#end_block

#method_before
private PushButton createButton(final Pair<T, V> item, boolean plusButton) {
    final T value = item.getFirst();
    final V widget = item.getSecond();
    final PushButton button = new PushButton(new Image(plusButton ? resources.increaseIcon() : resources.decreaseIcon()));
    button.addStyleName(style.buttonStyle());
    // $NON-NLS-1$
    button.addStyleName("buttonStyle_pfly_fix");
    button.setEnabled(!isGhost(value));
    button.addClickHandler(plusButton ? new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getEntry(widget).removeLastButton();
            Pair<T, V> item = addGhostEntry();
            onAdd(item.getFirst(), item.getSecond());
        }
    } : new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            ListIterator<Pair<T, V>> last = items.listIterator(items.size());
            if (!last.hasPrevious()) {
                // just a precaution; if there's no item, there should be no button
                return;
            }
            if (item == last.previous() && last.hasPrevious()) {
                // add plus button to previous item
                Pair<T, V> previousItem = last.previous();
                getEntry(previousItem.getSecond()).appendButton(createButton(previousItem, true));
            }
            removeEntry(item);
            onRemove(value, widget);
            if (items.isEmpty()) {
                Pair<T, V> item = addGhostEntry();
                onAdd(item.getFirst(), item.getSecond());
            }
        }
    });
    return button;
}
#method_after
private PushButton createButton(final Pair<T, V> item, boolean plusButton) {
    final T value = item.getFirst();
    final V widget = item.getSecond();
    final PushButton button = new PushButton(new Image(plusButton ? resources.increaseIcon() : resources.decreaseIcon()));
    button.addStyleName(style.buttonStyle());
    // $NON-NLS-1$
    button.addStyleName("buttonStyle_pfly_fix");
    button.addClickHandler(plusButton ? new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getEntry(widget).removeLastButton();
            Pair<T, V> item = addGhostEntry();
            onAdd(item.getFirst(), item.getSecond());
        }
    } : new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            ListIterator<Pair<T, V>> last = items.listIterator(items.size());
            if (!last.hasPrevious()) {
                // just a precaution; if there's no item, there should be no button
                return;
            }
            if (item == last.previous() && last.hasPrevious()) {
                // add plus button to previous item
                Pair<T, V> previousItem = last.previous();
                getEntry(previousItem.getSecond()).appendButton(createButton(previousItem, true));
            }
            removeEntry(item);
            onRemove(value, widget);
            if (items.isEmpty()) {
                Pair<T, V> item = addGhostEntry();
                onAdd(item.getFirst(), item.getSecond());
            }
        }
    });
    return button;
}
#end_block

#method_before
protected void onAdd(T value, V widget) {
    modelItems.add(value);
}
#method_after
protected void onAdd(T value, V widget) {
    modelItems.add(value);
    if (widget instanceof Focusable) {
        ((Focusable) widget).setFocus(true);
    }
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new UserStatusColumn(), constants.empty(), "30px");
    getTable().addColumn(new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            return object.getFirstName();
        }
    }, constants.firstnameUser(), // $NON-NLS-1$
    "150px");
    getTable().addColumn(new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            return object.getLastName();
        }
    }, constants.lastNameUser(), // $NON-NLS-1$
    "150px");
    getTable().addColumn(new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            return FormatUtils.getFullLoginName(object);
        }
    }, constants.userNameUser(), // $NON-NLS-1$
    "150px");
    getTable().addColumn(new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            StringBuilder builder = new StringBuilder();
            int counter = 0;
            for (String name : object.getGroupNames()) {
                builder.append(name);
                if (counter < object.getGroupNames().size() - 1) {
                    builder.append(",");
                }
            }
            return builder.toString();
        }
    }, constants.groupUser(), // $NON-NLS-1$
    "150px");
    getTable().addColumn(new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            return object.getEmail();
        }
    }, constants.emailUser(), // $NON-NLS-1$
    "150px");
    getTable().addActionButton(new WebAdminButtonDefinition<DbUser>(constants.addUser()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAddCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<DbUser>(constants.removeUser()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<DbUser>(constants.assignTagsUser()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new UserStatusColumn(), constants.empty(), "30px");
    getTable().addColumn(new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            return object.getFirstName();
        }
    }, constants.firstnameUser(), // $NON-NLS-1$
    "150px");
    getTable().addColumn(new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            return object.getLastName();
        }
    }, constants.lastNameUser(), // $NON-NLS-1$
    "150px");
    getTable().addColumn(new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            return FormatUtils.getFullLoginName(object);
        }
    }, constants.userNameUser(), // $NON-NLS-1$
    "150px");
    getTable().addColumn(new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            StringBuilder builder = new StringBuilder();
            int counter = 0;
            for (String name : object.getGroupNames()) {
                builder.append(name);
                if (counter < object.getGroupNames().size() - 1) {
                    // $NON-NLS-1$
                    builder.append(",");
                }
            }
            return builder.toString();
        }
    }, constants.groupUser(), // $NON-NLS-1$
    "150px");
    getTable().addColumn(new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            return object.getEmail();
        }
    }, constants.emailUser(), // $NON-NLS-1$
    "150px");
    getTable().addActionButton(new WebAdminButtonDefinition<DbUser>(constants.addUser()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAddCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<DbUser>(constants.removeUser()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<DbUser>(constants.assignTagsUser()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
}
#end_block

#method_before
private void initTable(final ApplicationResources resources, final ApplicationConstants constants, ApplicationMessages messages) {
    policyUnitTable = new ListModelObjectCellTable<PolicyUnit, ListModel>();
    policyUnitTable.enableColumnResizing();
    policyUnitTableContainer.add(policyUnitTable);
    policyUnitTable.addColumn(new WebAdminImageResourceColumn<PolicyUnit>() {

        @Override
        public ImageResource getValue(PolicyUnit object) {
            if (object.isInternal()) {
                setTitle(constants.internalPolicyUnit());
                return resources.lockImage();
            }
            setTitle(constants.externalPolicyUnit());
            return resources.exteranlPolicyUnitImage();
        }
    }, constants.empty(), // $NON-NLS-1$
    "20px");
    policyUnitTable.addColumn(new TextColumnWithTooltip<PolicyUnit>() {

        @Override
        public String getValue(PolicyUnit object) {
            return object.getName();
        }
    }, constants.policyUnitName(), // $NON-NLS-1$
    "180px");
    policyUnitTable.addColumn(new TextColumnWithTooltip<PolicyUnit>() {

        @Override
        public String getValue(PolicyUnit object) {
            return new EnumTranslator().get(object.getPolicyUnitType());
        }
    }, constants.policyUnitType(), // $NON-NLS-1$
    "100px");
    policyUnitTable.addColumn(new TextColumnWithTooltip<PolicyUnit>() {

        @Override
        public String getValue(PolicyUnit object) {
            if (!object.isEnabled()) {
                return constants.disabledPolicyUnit();
            }
            return constants.empty();
        }
    }, constants.empty(), // $NON-NLS-1$
    "75px");
    Column<PolicyUnit, String> removeButtonColumn = new Column<PolicyUnit, String>(new NullableButtonCell()) {

        @Override
        public String getValue(PolicyUnit object) {
            if (!object.isEnabled()) {
                return constants.removePolicyUnit();
            }
            return null;
        }
    };
    // $NON-NLS-1$
    policyUnitTable.addColumn(removeButtonColumn, constants.empty(), "80px");
    removeButtonColumn.setFieldUpdater(new FieldUpdater<PolicyUnit, String>() {

        @Override
        public void update(int index, PolicyUnit object, String value) {
            model.remove(object);
        }
    });
}
#method_after
private void initTable(final ApplicationResources resources, final ApplicationConstants constants, ApplicationMessages messages) {
    policyUnitTable = new ListModelObjectCellTable<PolicyUnit, ListModel>();
    policyUnitTable.enableColumnResizing();
    policyUnitTableContainer.add(policyUnitTable);
    policyUnitTable.addColumn(new WebAdminImageResourceColumn<PolicyUnit>() {

        @Override
        public ImageResource getValue(PolicyUnit object) {
            if (object.isInternal()) {
                setTitle(constants.internalPolicyUnit());
                return resources.lockImage();
            }
            setTitle(constants.externalPolicyUnit());
            return resources.exteranlPolicyUnitImage();
        }
    }, constants.empty(), // $NON-NLS-1$
    "20px");
    policyUnitTable.addColumn(new TextColumnWithTooltip<PolicyUnit>() {

        @Override
        public String getValue(PolicyUnit object) {
            return object.getName();
        }
    }, constants.policyUnitName(), // $NON-NLS-1$
    "180px");
    policyUnitTable.addColumn(new TextColumnWithTooltip<PolicyUnit>() {

        @Override
        public String getValue(PolicyUnit object) {
            return EnumTranslator.getInstance().get(object.getPolicyUnitType());
        }
    }, constants.policyUnitType(), // $NON-NLS-1$
    "100px");
    policyUnitTable.addColumn(new TextColumnWithTooltip<PolicyUnit>() {

        @Override
        public String getValue(PolicyUnit object) {
            if (!object.isEnabled()) {
                return constants.disabledPolicyUnit();
            }
            return constants.empty();
        }
    }, constants.empty(), // $NON-NLS-1$
    "75px");
    Column<PolicyUnit, String> removeButtonColumn = new Column<PolicyUnit, String>(new NullableButtonCell()) {

        @Override
        public String getValue(PolicyUnit object) {
            if (!object.isEnabled()) {
                return constants.removePolicyUnit();
            }
            return null;
        }
    };
    // $NON-NLS-1$
    policyUnitTable.addColumn(removeButtonColumn, constants.empty(), "80px");
    removeButtonColumn.setFieldUpdater(new FieldUpdater<PolicyUnit, String>() {

        @Override
        public void update(int index, PolicyUnit object, String value) {
            model.remove(object);
        }
    });
}
#end_block

#method_before
private void updateProperties() {
    VmTemplate template = getEntity();
    setName(template.getName());
    setDescription(template.getDescription());
    // $NON-NLS-1$
    setQuotaName(template.getQuotaName() != null ? template.getQuotaName() : "");
    setQuotaAvailable(template.getQuotaEnforcementType() != null && !template.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED));
    setHostCluster(template.getVdsGroupName());
    // $NON-NLS-1$
    setDefinedMemory(template.getMemSizeMb() + " MB");
    setIsHighlyAvailable(template.isAutoStartup());
    setPriority(AsyncDataProvider.priorityToString(template.getPriority()));
    setMonitorCount(template.getNumOfMonitors());
    setAllowConsoleReconnect(template.isAllowConsoleReconnect());
    setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(template.getNumOfCpus(), template.getNumOfSockets(), template.getCpuPerSocket()));
    setOS(AsyncDataProvider.getOsName(template.getOsId()));
    Translator translator = new EnumTranslator();
    setDefaultDisplayType(translator.get(template.getDefaultDisplayType()));
    setOrigin(translator.get(template.getOrigin()));
    setHasDomain(AsyncDataProvider.isWindowsOsType(template.getOsId()));
    if (template.getVmInit() != null) {
        setDomain(template.getVmInit().getDomain());
    }
    setHasTimeZone(AsyncDataProvider.isWindowsOsType(template.getOsId()));
    setTimeZone(template.getTimeZone());
    setHasUsbPolicy(true);
    setUsbPolicy(translator.get(template.getUsbPolicy()));
    setIsStateless(template.isStateless());
}
#method_after
private void updateProperties() {
    VmTemplate template = getEntity();
    setName(template.getName());
    setDescription(template.getDescription());
    // $NON-NLS-1$
    setQuotaName(template.getQuotaName() != null ? template.getQuotaName() : "");
    setQuotaAvailable(template.getQuotaEnforcementType() != null && !template.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED));
    setHostCluster(template.getVdsGroupName());
    // $NON-NLS-1$
    setDefinedMemory(template.getMemSizeMb() + " MB");
    setIsHighlyAvailable(template.isAutoStartup());
    setPriority(AsyncDataProvider.priorityToString(template.getPriority()));
    setMonitorCount(template.getNumOfMonitors());
    setAllowConsoleReconnect(template.isAllowConsoleReconnect());
    setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(template.getNumOfCpus(), template.getNumOfSockets(), template.getCpuPerSocket()));
    setOS(AsyncDataProvider.getOsName(template.getOsId()));
    Translator translator = EnumTranslator.getInstance();
    setDefaultDisplayType(translator.get(template.getDefaultDisplayType()));
    setOrigin(translator.get(template.getOrigin()));
    setHasDomain(AsyncDataProvider.isWindowsOsType(template.getOsId()));
    if (template.getVmInit() != null) {
        setDomain(template.getVmInit().getDomain());
    }
    setHasTimeZone(AsyncDataProvider.isWindowsOsType(template.getOsId()));
    setTimeZone(template.getTimeZone());
    setHasUsbPolicy(true);
    setUsbPolicy(translator.get(template.getUsbPolicy()));
    setIsStateless(template.isStateless());
}
#end_block

#method_before
@Override
public String get(Enum<?> key) {
    try {
        // FIXME: hack: due to java restriction for method names with chars that are not letters, digits, and underscores, replace . with 0
        if (key == null) {
            return null;
        // return constants.notAvailableLabel();     //TODO MM: NULL or this?
        }
        String enumName = key.getDeclaringClass().toString();
        // $NON-NLS-1$
        enumName = enumName.substring(enumName.lastIndexOf(".") + 1, enumName.length());
        // $NON-NLS-1$
        String translatedEnum = enums.getString(enumName + "___" + key.toString());
        return translatedEnum;
    } catch (MissingResourceException e) {
        // Silently ignore missing resource
        // $NON-NLS-1$
        logger.info("Missing Enum resource: " + e.getLocalizedMessage());
        return key.name();
    }
}
#method_after
@Override
public String get(Enum<?> key) {
    if (key == null) {
        return constants.notAvailableLabel();
    }
    try {
        // FIXME: hack: due to java restriction for method names with chars that are not letters, digits, and underscores, replace . with 0
        String enumName = key.getDeclaringClass().toString();
        // $NON-NLS-1$
        enumName = enumName.substring(enumName.lastIndexOf(".") + 1, enumName.length());
        // $NON-NLS-1$
        String translatedEnum = enums.getString(enumName + "___" + key.toString());
        return translatedEnum;
    } catch (MissingResourceException e) {
        // Silently ignore missing resource
        // $NON-NLS-1$
        logger.info("Missing Enum resource: " + e.getLocalizedMessage());
        return key.name();
    }
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new StorageDomainSharedStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<StorageDomain> nameColumn = new TextColumnWithTooltip<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            return object.getStorageName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.domainNameStorage(), "150px");
    CommentColumn<StorageDomain> commentColumn = new CommentColumn<StorageDomain>();
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(commentColumn, commentColumn.getHeaderHtml(), "30px");
    TextColumnWithTooltip<StorageDomain> domainTypeColumn = new EnumColumn<StorageDomain, StorageDomainType>() {

        @Override
        protected StorageDomainType getRawValue(StorageDomain object) {
            return object.getStorageDomainType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(domainTypeColumn, constants.domainTypeStorage(), "150px");
    TextColumnWithTooltip<StorageDomain> storageTypeColumn = new EnumColumn<StorageDomain, StorageType>() {

        @Override
        protected StorageType getRawValue(StorageDomain object) {
            return object.getStorageType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(storageTypeColumn, constants.storageTypeStorage(), "150px");
    TextColumnWithTooltip<StorageDomain> formatColumn = new EnumColumn<StorageDomain, StorageFormatType>() {

        @Override
        protected StorageFormatType getRawValue(StorageDomain object) {
            return object.getStorageFormat();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(formatColumn, constants.formatStorage(), "140px");
    TextColumnWithTooltip<StorageDomain> crossDataCenterStatusColumn = new TextColumnWithTooltip<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            if (object.getStorageDomainType() == StorageDomainType.ISO) {
                return new EnumTranslator().get(object.getStorageDomainSharedStatus());
            } else {
                return new EnumTranslator().get(object.getStatus());
            }
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(crossDataCenterStatusColumn, constants.crossDcStatusStorage(), "210px");
    StorageSizeColumn<StorageDomain> totalSpaceColumn = new StorageSizeColumn<StorageDomain>() {

        @Override
        public Long getRawValue(StorageDomain object) {
            long totalSpace = object.getTotalDiskSize() != null ? object.getTotalDiskSize() : 0;
            return totalSpace;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(totalSpaceColumn, constants.totalSpaceStorage(), "130px");
    StorageSizeColumn<StorageDomain> freeSpaceColumn = new StorageSizeColumn<StorageDomain>() {

        @Override
        public Long getRawValue(StorageDomain object) {
            long availableDiskSize = object.getAvailableDiskSize() != null ? object.getAvailableDiskSize() : 0;
            return availableDiskSize;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(freeSpaceColumn, constants.freeSpaceStorage(), "130px");
    TextColumnWithTooltip<StorageDomain> descriptionColumn = new TextColumnWithTooltip<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            return object.getDescription();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.domainDescriptionStorage(), "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.newDomainStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewDomainCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.importDomainStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getImportDomainCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.editStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.removeStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.destroyStorage(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getDestroyCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<StorageDomain>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("Storage", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<StorageDomain>(constants.showReportStorage(), resourceSubActions));
        }
    }
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new StorageDomainSharedStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<StorageDomain> nameColumn = new TextColumnWithTooltip<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            return object.getStorageName();
        }
    };
    nameColumn.makeSortable(StorageDomainFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.domainNameStorage(), "150px");
    CommentColumn<StorageDomain> commentColumn = new CommentColumn<StorageDomain>();
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(commentColumn, commentColumn.getHeaderHtml(), "30px");
    TextColumnWithTooltip<StorageDomain> domainTypeColumn = new EnumColumn<StorageDomain, StorageDomainType>() {

        @Override
        protected StorageDomainType getRawValue(StorageDomain object) {
            return object.getStorageDomainType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(domainTypeColumn, constants.domainTypeStorage(), "150px");
    TextColumnWithTooltip<StorageDomain> storageTypeColumn = new EnumColumn<StorageDomain, StorageType>() {

        @Override
        protected StorageType getRawValue(StorageDomain object) {
            return object.getStorageType();
        }
    };
    storageTypeColumn.makeSortable(StorageDomainFieldAutoCompleter.TYPE);
    // $NON-NLS-1$
    getTable().addColumn(storageTypeColumn, constants.storageTypeStorage(), "150px");
    TextColumnWithTooltip<StorageDomain> formatColumn = new EnumColumn<StorageDomain, StorageFormatType>() {

        @Override
        protected StorageFormatType getRawValue(StorageDomain object) {
            return object.getStorageFormat();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(formatColumn, constants.formatStorage(), "140px");
    TextColumnWithTooltip<StorageDomain> crossDataCenterStatusColumn = new TextColumnWithTooltip<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            if (object.getStorageDomainType() == StorageDomainType.ISO) {
                return EnumTranslator.getInstance().get(object.getStorageDomainSharedStatus());
            } else {
                return EnumTranslator.getInstance().get(object.getStatus());
            }
        }
    };
    crossDataCenterStatusColumn.makeSortable(StorageDomainFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(crossDataCenterStatusColumn, constants.crossDcStatusStorage(), "210px");
    StorageSizeColumn<StorageDomain> totalSpaceColumn = new StorageSizeColumn<StorageDomain>() {

        @Override
        public Long getRawValue(StorageDomain object) {
            long totalSpace = object.getTotalDiskSize() != null ? object.getTotalDiskSize() : 0;
            return (long) totalSpace;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(totalSpaceColumn, constants.totalSpaceStorage(), "130px");
    StorageSizeColumn<StorageDomain> freeSpaceColumn = new StorageSizeColumn<StorageDomain>() {

        @Override
        public Long getRawValue(StorageDomain object) {
            long availableDiskSize = object.getAvailableDiskSize() != null ? object.getAvailableDiskSize() : 0;
            return (long) availableDiskSize;
        }
    };
    freeSpaceColumn.makeSortable(StorageDomainFieldAutoCompleter.SIZE);
    // $NON-NLS-1$
    getTable().addColumn(freeSpaceColumn, constants.freeSpaceStorage(), "130px");
    TextColumnWithTooltip<StorageDomain> descriptionColumn = new TextColumnWithTooltip<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable(StorageDomainFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.domainDescriptionStorage(), "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.newDomainStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewDomainCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.importDomainStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getImportDomainCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.editStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.removeStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.destroyStorage(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getDestroyCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<StorageDomain>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("Storage", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<StorageDomain>(constants.showReportStorage(), resourceSubActions));
        }
    }
}
#end_block

#method_before
@Override
public String render(E object) {
    return new EnumTranslator().get(object);
}
#method_after
@Override
public String render(E object) {
    return EnumTranslator.getInstance().get(object);
}
#end_block

#method_before
private void updateProperties() {
    VM vm = (VM) getEntity();
    setName(vm.getName());
    setDescription(vm.getVmDescription());
    // $NON-NLS-1$
    setQuotaName(vm.getQuotaName() != null ? vm.getQuotaName() : "");
    setQuotaAvailable(vm.getQuotaEnforcementType() != null && !vm.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED));
    setTemplate(vmTemplateNameRenderer.render(vm));
    // $NON-NLS-1$
    setDefinedMemory(vm.getVmMemSizeMb() + " MB");
    // $NON-NLS-1$
    setMinAllocatedMemory(vm.getMinAllocatedMem() + " MB");
    setOS(AsyncDataProvider.getOsName(vm.getVmOsId()));
    Translator translator = new EnumTranslator();
    setDefaultDisplayType(translator.get(vm.getDefaultDisplayType()));
    setOrigin(translator.get(vm.getOrigin()));
    setIsHighlyAvailable(vm.isAutoStartup());
    setPriority(AsyncDataProvider.priorityToString(vm.getPriority()));
    setMonitorCount(vm.getNumOfMonitors());
    setUsbPolicy(translator.get(vm.getUsbPolicy()));
    setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(vm.getNumOfCpus(), vm.getNumOfSockets(), vm.getCpuPerSocket()));
    setHasDomain(AsyncDataProvider.isWindowsOsType(vm.getVmOsId()));
    if (vm.getVmInit() != null) {
        setDomain(vm.getVmInit().getDomain());
    }
    setHasTimeZone(AsyncDataProvider.isWindowsOsType(vm.getVmOsId()));
    setTimeZone(vm.getTimeZone());
    setHasCustomProperties(!StringHelper.isNullOrEmpty(vm.getCustomProperties()));
    // $NON-NLS-1$ //$NON-NLS-2$
    setCustomProperties(getHasCustomProperties() ? "Configured" : "Not-Configured");
    setCompatibilityVersion(vm.getVdsGroupCompatibilityVersion() != null ? vm.getVdsGroupCompatibilityVersion().toString() : // $NON-NLS-1$
    "");
    setVmId(vm.getId().toString());
    setFqdn(vm.getVmFQDN());
    setHasAlert(vm.getVmPauseStatus() != VmPauseStatus.NONE && vm.getVmPauseStatus() != VmPauseStatus.NOERR);
    if (getHasAlert()) {
        setAlert(translator.get(vm.getVmPauseStatus()));
    } else {
        setAlert(null);
    }
    setHasDefaultHost(vm.getDedicatedVmForVds() != null);
    if (getHasDefaultHost()) {
        Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(// $NON-NLS-1$
        "Host: cluster = " + vm.getVdsGroupName() + " sortby name", SearchType.VDS), new // $NON-NLS-1$
        AsyncQuery(// $NON-NLS-1$
        this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmGeneralModel model = (VmGeneralModel) target;
                VM localVm = (VM) model.getEntity();
                if (localVm == null) {
                    return;
                }
                ArrayList<VDS> hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
                for (VDS host : hosts) {
                    if (localVm.getDedicatedVmForVds() != null && host.getId().equals(localVm.getDedicatedVmForVds())) {
                        model.setDefaultHost(host.getName());
                        break;
                    }
                }
            }
        }));
    } else {
        setDefaultHost(ConstantsManager.getInstance().getConstants().anyHostInCluster());
    }
}
#method_after
private void updateProperties() {
    VM vm = (VM) getEntity();
    setName(vm.getName());
    setDescription(vm.getVmDescription());
    // $NON-NLS-1$
    setQuotaName(vm.getQuotaName() != null ? vm.getQuotaName() : "");
    setQuotaAvailable(vm.getQuotaEnforcementType() != null && !vm.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED));
    setTemplate(vmTemplateNameRenderer.render(vm));
    // $NON-NLS-1$
    setDefinedMemory(vm.getVmMemSizeMb() + " MB");
    // $NON-NLS-1$
    setMinAllocatedMemory(vm.getMinAllocatedMem() + " MB");
    setOS(AsyncDataProvider.getOsName(vm.getVmOsId()));
    Translator translator = EnumTranslator.getInstance();
    setDefaultDisplayType(translator.get(vm.getDefaultDisplayType()));
    setOrigin(translator.get(vm.getOrigin()));
    setIsHighlyAvailable(vm.isAutoStartup());
    setPriority(AsyncDataProvider.priorityToString(vm.getPriority()));
    setMonitorCount(vm.getNumOfMonitors());
    setUsbPolicy(translator.get(vm.getUsbPolicy()));
    setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(vm.getNumOfCpus(), vm.getNumOfSockets(), vm.getCpuPerSocket()));
    setGuestCpuCount(vm.getGuestCpuCount());
    setHasDomain(AsyncDataProvider.isWindowsOsType(vm.getVmOsId()));
    if (vm.getVmInit() != null) {
        setDomain(vm.getVmInit().getDomain());
    }
    setHasTimeZone(AsyncDataProvider.isWindowsOsType(vm.getVmOsId()));
    setTimeZone(vm.getTimeZone());
    setHasCustomProperties(!StringHelper.isNullOrEmpty(vm.getCustomProperties()));
    // $NON-NLS-1$ //$NON-NLS-2$
    setCustomProperties(getHasCustomProperties() ? "Configured" : "Not-Configured");
    setCompatibilityVersion(vm.getVdsGroupCompatibilityVersion() != null ? vm.getVdsGroupCompatibilityVersion().toString() : // $NON-NLS-1$
    "");
    setVmId(vm.getId().toString());
    setFqdn(vm.getVmFQDN());
    setHasAlert(vm.getVmPauseStatus() != VmPauseStatus.NONE && vm.getVmPauseStatus() != VmPauseStatus.NOERR);
    if (getHasAlert()) {
        setAlert(translator.get(vm.getVmPauseStatus()));
    } else {
        setAlert(null);
    }
    setHasDefaultHost(vm.getDedicatedVmForVds() != null);
    if (getHasDefaultHost()) {
        Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(// $NON-NLS-1$
        "Host: cluster = " + vm.getVdsGroupName() + " sortby name", SearchType.VDS), new // $NON-NLS-1$
        AsyncQuery(// $NON-NLS-1$
        this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmGeneralModel model = (VmGeneralModel) target;
                VM localVm = (VM) model.getEntity();
                if (localVm == null) {
                    return;
                }
                ArrayList<VDS> hosts = (ArrayList<VDS>) ((VdcQueryReturnValue) returnValue).getReturnValue();
                for (VDS host : hosts) {
                    if (localVm.getDedicatedVmForVds() != null && host.getId().equals(localVm.getDedicatedVmForVds())) {
                        model.setDefaultHost(host.getName());
                        break;
                    }
                }
            }
        }));
    } else {
        setDefaultHost(ConstantsManager.getInstance().getConstants().anyHostInCluster());
    }
}
#end_block

#method_before
@Override
public String getValue(Disk object) {
    // $NON-NLS-1$
    getCell().setTitle(StringUtils.join(object.getVmNames(), ", "));
    if (object.getNumberOfVms() == 0) {
        // $NON-NLS-1$
        return "";
    }
    String entityType = new EnumTranslator().get(object.getVmEntityType());
    if (object.getNumberOfVms() == 1) {
        String entityName = object.getVmNames().get(0);
        return entityName;
    } else {
        // $NON-NLS-1$ //$NON-NLS-2$
        return object.getNumberOfVms() + " " + entityType + "s";
    }
}
#method_after
@Override
public String getValue(Disk object) {
    // $NON-NLS-1$
    getCell().setTitle(StringUtils.join(object.getVmNames(), ", "));
    if (object.getNumberOfVms() == 0) {
        // $NON-NLS-1$
        return "";
    }
    String entityType = EnumTranslator.getInstance().get(object.getVmEntityType());
    if (object.getNumberOfVms() == 1) {
        String entityName = object.getVmNames().get(0);
        return entityName;
    } else {
        // $NON-NLS-1$ //$NON-NLS-2$
        return object.getNumberOfVms() + " " + entityType + "s";
    }
}
#end_block

#method_before
protected void initSpiceProxy() {
    EntityModelLabel label = new EntityModelLabel();
    label.setText(constants.defineSpiceProxyEnable());
    spiceProxyOverrideEnabledEditor = new EntityModelCheckBoxOnlyEditor();
    spiceProxyEnabledCheckboxWithInfoIcon = new EntityModelWidgetWithInfo(label, spiceProxyOverrideEnabledEditor);
}
#method_after
protected void initSpiceProxy() {
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.defineSpiceProxyEnable());
    spiceProxyOverrideEnabledEditor = new EntityModelCheckBoxOnlyEditor();
    spiceProxyEnabledCheckboxWithInfoIcon = new EntityModelWidgetWithInfo<String>(label, spiceProxyOverrideEnabledEditor);
}
#end_block

#method_before
private void initTotalVcpus() {
    EntityModelLabel label = new EntityModelLabel();
    label.setText(constants.numOfVCPUs());
    totalvCPUsEditor = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    totalvCPUsEditorWithInfoIcon = new EntityModelWidgetWithInfo(label, totalvCPUsEditor);
    totalvCPUsEditorWithInfoIcon.setExplanation(applicationTemplates.italicText(messages.hotPlugUnplugCpuWarning()));
}
#method_after
private void initTotalVcpus() {
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.numOfVCPUs());
    // $NON-NLS-1$
    label.addStyleName("numCPUs_pfly_fix");
    totalvCPUsEditor = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    totalvCPUsEditorWithInfoIcon = new EntityModelDetachableWidgetWithInfo<String>(label, totalvCPUsEditor);
    totalvCPUsEditorWithInfoIcon.setExplanation(applicationTemplates.italicText(messages.hotPlugUnplugCpuWarning()));
}
#end_block

#method_before
private void initTextBoxEditors() {
    descriptionEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    commentEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    numOfVmsEditor = new IntegerEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    cpuPinning = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    kernel_pathEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    initrd_pathEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    kernel_parametersEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    nameEditor = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    prestartedVmsEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    editPrestartedVmsEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    maxAssignedVmsPerUserEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    editMaxAssignedVmsPerUserEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
}
#method_after
private void initTextBoxEditors() {
    templateVersionNameEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    descriptionEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    commentEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    numOfVmsEditor = new IntegerEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    cpuPinning = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    kernel_pathEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    initrd_pathEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    kernel_parametersEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    nameEditor = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    prestartedVmsEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    editPrestartedVmsEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    maxAssignedVmsPerUserEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    editMaxAssignedVmsPerUserEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new ListModelTypeAheadListBoxEditor<DataCenterWithCluster>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<DataCenterWithCluster>() {

        @Override
        public String getReplacementStringNullSafe(DataCenterWithCluster data) {
            return // $NON-NLS-1$
            data.getCluster().getName() + "/" + data.getDataCenter().getName();
        }

        @Override
        public String getDisplayStringNullSafe(DataCenterWithCluster data) {
            String dcDescription = data.getDataCenter().getdescription();
            return typeAheadNameDescriptionTemplateNullSafe(data.getCluster().getName(), !StringHelper.isNullOrEmpty(dcDescription) ? dcDescription : data.getDataCenter().getName());
        }
    }, new ModeSwitchingVisibilityRenderer());
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return getDisplayableTemplateVersionName(data);
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(getDisplayableTemplateVersionName(data), data.getDescription());
        }

        private String getDisplayableTemplateVersionName(VmTemplate template) {
            String versionName = template.getTemplateVersionName();
            if (ConstantsManager.getInstance().getConstants().latestTemplateVersionName().equals(versionName)) {
                return constants.latest();
            }
            versionName = template.getId().equals(template.getBaseTemplateId()) ? constants.baseTemplate() : template.getTemplateVersionName();
            return // $NON-NLS-1$
            (versionName == null ? "" : versionName) + // $NON-NLS-1$
            StringFormat.format(" (%d)", template.getTemplateVersionNumber());
        }
    }, new ModeSwitchingVisibilityRenderer());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Windows Sysprep
    domainEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<EntityModel<DisplayType>>(new NullSafeRenderer<EntityModel<DisplayType>>() {

        @Override
        public String renderNullSafe(EntityModel<DisplayType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(messages));
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS object) {
            return object.getName();
        }
    }, new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new ListModelTypeAheadListBoxEditor<DataCenterWithCluster>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<DataCenterWithCluster>() {

        @Override
        public String getReplacementStringNullSafe(DataCenterWithCluster data) {
            return // $NON-NLS-1$
            data.getCluster().getName() + "/" + data.getDataCenter().getName();
        }

        @Override
        public String getDisplayStringNullSafe(DataCenterWithCluster data) {
            String dcDescription = data.getDataCenter().getdescription();
            return typeAheadNameDescriptionTemplateNullSafe(data.getCluster().getName(), !StringHelper.isNullOrEmpty(dcDescription) ? dcDescription : data.getDataCenter().getName());
        }
    }, new ModeSwitchingVisibilityRenderer());
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return getDisplayableTemplateVersionName(data);
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(getDisplayableTemplateVersionName(data), data.getDescription());
        }

        private String getDisplayableTemplateVersionName(VmTemplate template) {
            String versionName = template.getTemplateVersionName();
            if (ConstantsManager.getInstance().getConstants().latestTemplateVersionName().equals(versionName)) {
                return constants.latest();
            }
            versionName = template.getId().equals(template.getBaseTemplateId()) ? constants.baseTemplate() : template.getTemplateVersionName();
            return // $NON-NLS-1$
            (versionName == null ? "" : versionName) + // $NON-NLS-1$
            StringFormat.format(" (%d)", template.getTemplateVersionNumber());
        }
    }, new ModeSwitchingVisibilityRenderer());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    instanceTypesEditor = new ListModelTypeAheadListBoxEditor<InstanceType>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<InstanceType>() {

        @Override
        public String getReplacementStringNullSafe(InstanceType data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(InstanceType data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(numOfSocketsEditor);
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(corePerSocketEditor);
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxOnlyEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.tzVmPopup());
    timeZoneEditorWithInfo = new EntityModelWidgetWithInfo<String>(label, timeZoneEditor);
    timeZoneEditorWithInfo.setExplanation(applicationTemplates.italicText(constants.timeZoneInfo()));
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<EntityModel<DisplayType>>(new NullSafeRenderer<EntityModel<DisplayType>>() {

        @Override
        public String renderNullSafe(EntityModel<DisplayType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(messages), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS object) {
            return object.getName();
        }
    }, new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
}
#end_block

#method_before
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    baseTemplateEditor.setLabel(constants.basedOnTemplateVmPopup());
    templateEditor.setLabel(constants.templateSubVersion());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    isVirtioScsiEnabled.setLabel(constants.isVirtioScsiEnabled());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    domainEditor.setLabel(constants.domainVmPopup());
    timeZoneEditor.setLabel(constants.tzVmPopup());
    vmInitEnabledEditor.setLabel(constants.cloudInitOrSysprep());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
    ssoMethodNone.setLabel(constants.none());
    ssoMethodGuestAgent.setLabel(constants.guestAgent());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.useHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    corePerSocketEditor.setLabel(constants.coresPerSocket());
    numOfSocketsEditor.setLabel(constants.numOfSockets());
}
#method_after
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    templateVersionNameEditor.setLabel(constants.templateVersionName());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    baseTemplateEditor.setLabel(constants.basedOnTemplateVmPopup());
    templateEditor.setLabel(constants.templateSubVersion());
    instanceTypesEditor.setLabel(constants.instanceType());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    isVirtioScsiEnabled.setLabel(constants.isVirtioScsiEnabled());
    // Rng device tab
    rngDeviceTab.setLabel(constants.rngDeviceTab());
    isRngEnabledEditor.setLabel(constants.rngDevEnabled());
    rngPeriodEditor.setLabel(constants.rngPeriod());
    rngBytesEditor.setLabel(constants.rngBytes());
    rngSourceRandom.setLabel(constants.rngSourceRandom());
    rngSourceHwrng.setLabel(constants.rngSourceHwrng());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    vmInitEnabledEditor.setLabel(constants.cloudInitOrSysprep());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
    ssoMethodNone.setLabel(constants.none());
    ssoMethodGuestAgent.setLabel(constants.guestAgent());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    spiceFileTransferEnabledEditor.setLabel(constants.spiceFileTransferEnabled());
    spiceCopyPasteEnabledEditor.setLabel(constants.spiceCopyPasteEnabled());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.useHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    detachableMemSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditorWithDetachable.setLabel(constants.coresPerSocket());
    numOfSocketsEditorWithDetachable.setLabel(constants.numOfSockets());
}
#end_block

#method_before
@Override
public void edit(UnitVmModel model) {
    super.edit(model);
    unitVmModel = model;
    priorityEditor.setRowData(new ArrayList<EntityModel>());
    priorityEditor.asEditor().edit(model.getPriority());
    driver.edit(model);
    profilesInstanceTypeEditor.edit(model.getNicsWithLogicalNetworks());
    customPropertiesSheetEditor.edit(model.getCustomPropertySheet());
    vmInitEditor.edit(model.getVmInitModel());
    initTabAvailabilityListeners(model);
    initListeners(model);
    hideAlwaysHiddenFields();
}
#method_after
@Override
public void edit(UnitVmModel model) {
    super.edit(model);
    unitVmModel = model;
    priorityEditor.setRowData(new ArrayList<EntityModel>());
    priorityEditor.asEditor().edit(model.getPriority());
    driver.edit(model);
    profilesInstanceTypeEditor.edit(model.getNicsWithLogicalNetworks());
    customPropertiesSheetEditor.edit(model.getCustomPropertySheet());
    vmInitEditor.edit(model.getVmInitModel());
    serialNumberPolicyEditor.edit(model.getSerialNumberPolicy());
    initTabAvailabilityListeners(model);
    initListeners(model);
    hideAlwaysHiddenFields();
    decorateDetachableFields();
}
#end_block

#method_before
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsHostTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsHostTabValid()) {
                    hostTab.markAsValid();
                } else {
                    hostTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "SelectedItem") {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                boolean sysprepEnabled = object.getSysprepEnabled().getEntity();
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
                domainEditor.setVisible(sysprepEnabled);
            }
        }
    });
}
#method_after
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsHostTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsHostTabValid()) {
                    hostTab.markAsValid();
                } else {
                    hostTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "SelectedItem") {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            VDSGroup vdsGroup = object.getSelectedCluster();
            if (vdsGroup != null && vdsGroup.getcompatibility_version() != null) {
                boolean enabled = AsyncDataProvider.isSerialNumberPolicySupported(vdsGroup.getcompatibility_version().getValue());
                changeApplicationLevelVisibility(serialNumberPolicyEditor, enabled);
            }
        }
    });
    object.getIsRngEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            rngPanel.setVisible((Boolean) object.getIsRngEnabled().getEntity());
        }
    });
}
#end_block

#method_before
protected void updateUsbNativeMessageVisibility(final UnitVmModel object) {
    VDSGroup vdsGroup = object.getSelectedCluster();
    changeApplicationLevelVisibility(nativeUsbWarningMessage, object.getUsbPolicy().getSelectedItem() == UsbPolicy.ENABLED_NATIVE && vdsGroup != null && vdsGroup.getcompatibility_version() != null && !(Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MigrationSupportForNativeUsb, vdsGroup.getcompatibility_version().getValue()));
}
#method_after
protected void updateUsbNativeMessageVisibility(final UnitVmModel object) {
    Version vdsGroupVersion = clusterVersionOrNull(object);
    changeApplicationLevelVisibility(nativeUsbWarningMessage, object.getUsbPolicy().getSelectedItem() == UsbPolicy.ENABLED_NATIVE && vdsGroupVersion != null && !(Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MigrationSupportForNativeUsb, vdsGroupVersion.getValue()));
}
#end_block

#method_before
private void initTabAvailabilityListeners(final UnitVmModel vm) {
    // TODO should be handled by the core framework
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsWindowsOS".equals(propName)) {
                // $NON-NLS-1$
                domainEditor.setEnabled(vm.getIsWindowsOS());
            } else if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsDisplayTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsDisplayTabValid()) {
                    consoleTab.markAsValid();
                } else {
                    consoleTab.markAsInvalid(null);
                }
            } else if ("IsAllocationTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsAllocationTabValid()) {
                    resourceAllocationTab.markAsValid();
                } else {
                    resourceAllocationTab.markAsInvalid(null);
                }
            } else if ("IsHighlyAvailable".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(highAvailabilityTab, vm.getIsHighlyAvailable().getEntity());
            } else if ("IsBootSequenceTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsHighlyAvailable().getEntity()) {
                    bootOptionsTab.markAsValid();
                } else {
                    bootOptionsTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsCustomPropertiesTabValid()) {
                    customPropertiesTab.markAsValid();
                } else {
                    customPropertiesTab.markAsInvalid(null);
                }
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                boolean isDisksAvailable = vm.getIsDisksAvailable();
                changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
                boolean isProvisioningAvailable = vm.getProvisioning().getIsAvailable();
                changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable || vm.getIsVirtioScsiEnabled().getIsAvailable());
                if (isDisksAvailable) {
                    // Update warning message by disks status
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.ILLEGAL);
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.LOCKED);
                } else {
                    // Clear warning message
                    // $NON-NLS-1$
                    generalWarningMessage.setText("");
                }
            }
        }
    });
    // TODO: Move to a more appropriate method
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsLinuxOS".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(linuxBootOptionsPanel, vm.getIsLinuxOS());
            }
        }
    });
    defaultHostEditor.setEnabled(false);
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    // TODO: This is a hack and should be handled cleanly via model property availability
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    vm.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    ssoMethodGuestAgent.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodNone.asRadioButton(), false);
            }
        }
    });
    ssoMethodNone.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodGuestAgent.asRadioButton(), false);
            }
        }
    });
}
#method_after
private void initTabAvailabilityListeners(final UnitVmModel vm) {
    // TODO should be handled by the core framework
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsSystemTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsSystemTabValid()) {
                    systemTab.markAsValid();
                } else {
                    systemTab.markAsInvalid(null);
                }
            } else if ("IsDisplayTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsDisplayTabValid()) {
                    consoleTab.markAsValid();
                } else {
                    consoleTab.markAsInvalid(null);
                }
            } else if ("IsAllocationTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsAllocationTabValid()) {
                    resourceAllocationTab.markAsValid();
                } else {
                    resourceAllocationTab.markAsInvalid(null);
                }
            } else if ("IsHighlyAvailable".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(highAvailabilityTab, vm.getIsHighlyAvailable().getEntity());
            } else if ("IsBootSequenceTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsHighlyAvailable().getEntity()) {
                    bootOptionsTab.markAsValid();
                } else {
                    bootOptionsTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsCustomPropertiesTabValid()) {
                    customPropertiesTab.markAsValid();
                } else {
                    customPropertiesTab.markAsInvalid(null);
                }
            } else if ("IsRngTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.isRngTabValid()) {
                    rngDeviceTab.markAsValid();
                } else {
                    rngDeviceTab.markAsInvalid(null);
                }
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                boolean isDisksAvailable = vm.getIsDisksAvailable();
                changeApplicationLevelVisibility(disksPanel, isDisksAvailable);
                boolean isProvisioningAvailable = vm.getProvisioning().getIsAvailable();
                changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
                changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || vm.getIsVirtioScsiEnabled().getIsAvailable());
                if (isDisksAvailable) {
                    // Update warning message by disks status
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.ILLEGAL);
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.LOCKED);
                } else {
                    // Clear warning message
                    // $NON-NLS-1$
                    generalWarningMessage.setText("");
                }
            }
        }
    });
    // TODO: Move to a more appropriate method
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsLinuxOS".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(linuxBootOptionsPanel, vm.getIsLinuxOS());
            }
        }
    });
    defaultHostEditor.setEnabled(false);
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    rngSourceRandom.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> booleanValueChangeEvent) {
            vm.getRngSourceRandom().setEntity(true);
            vm.getRngSourceHwrng().setEntity(false);
        }
    });
    rngSourceHwrng.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> booleanValueChangeEvent) {
            vm.getRngSourceHwrng().setEntity(true);
            vm.getRngSourceRandom().setEntity(false);
        }
    });
    // TODO: This is a hack and should be handled cleanly via model property availability
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    vm.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    ssoMethodGuestAgent.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodNone.asRadioButton(), false);
            }
        }
    });
    ssoMethodNone.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodGuestAgent.asRadioButton(), false);
            }
        }
    });
}
#end_block

#method_before
private void updateDisksWarningByImageStatus(List<DiskModel> disks, ImageStatus imageStatus) {
    ArrayList<String> disksAliases = getDisksAliasesByImageStatus(disks, imageStatus);
    if (!disksAliases.isEmpty()) {
        generalWarningMessage.setText(messages.disksStatusWarning(new EnumTranslator().get(imageStatus), // $NON-NLS-1$
        (StringUtils.join(disksAliases, ", "))));
    }
}
#method_after
private void updateDisksWarningByImageStatus(List<DiskModel> disks, ImageStatus imageStatus) {
    ArrayList<String> disksAliases = getDisksAliasesByImageStatus(disks, imageStatus);
    if (!disksAliases.isEmpty()) {
        generalWarningMessage.setText(messages.disksStatusWarning(EnumTranslator.getInstance().get(imageStatus), // $NON-NLS-1$
        (StringUtils.join(disksAliases, ", "))));
    }
}
#end_block

#method_before
@Override
public UnitVmModel flush() {
    priorityEditor.flush();
    profilesInstanceTypeEditor.flush();
    vmInitEditor.flush();
    return driver.flush();
}
#method_after
@Override
public UnitVmModel flush() {
    priorityEditor.flush();
    profilesInstanceTypeEditor.flush();
    vmInitEditor.flush();
    serialNumberPolicyEditor.flush();
    return driver.flush();
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    domainEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    spiceFileTransferEnabledEditor.setTabIndex(nextTabIndex++);
    spiceCopyPasteEnabledEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Rng Tab==
    nextTabIndex = rngDeviceTab.setTabIndexes(nextTabIndex);
    isRngEnabledEditor.setTabIndex(nextTabIndex++);
    rngPeriodEditor.setTabIndex(nextTabIndex++);
    rngBytesEditor.setTabIndex(nextTabIndex++);
    rngSourceRandom.setTabIndex(nextTabIndex++);
    rngSourceHwrng.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().putAll(allTabs(), simpleField().visibleInAdvancedModeOnly()).putAll(adancedFieldsFromGeneralTab(), simpleField().visibleInAdvancedModeOnly()).putAll(consoleTabWidgets(), simpleField().visibleInAdvancedModeOnly()).update(consoleTab, simpleField()).update(numOfMonitorsEditor, simpleField()).update(isSingleQxlEnabledEditor, simpleField()).putOne(isSoundcardEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(isConsoleDeviceEnabledEditor, simpleField().visibleInAdvancedModeOnly());
}
#method_after
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().putAll(allTabs(), simpleField().visibleInAdvancedModeOnly()).putAll(adancedFieldsFromGeneralTab(), simpleField().visibleInAdvancedModeOnly()).putAll(consoleTabWidgets(), simpleField().visibleInAdvancedModeOnly()).update(consoleTab, simpleField()).update(numOfMonitorsEditor, simpleField()).update(isSingleQxlEnabledEditor, simpleField()).putOne(isSoundcardEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(isConsoleDeviceEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(spiceFileTransferEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(spiceCopyPasteEnabledEditor, simpleField().visibleInAdvancedModeOnly());
}
#end_block

#method_before
protected List<Widget> allTabs() {
    return Arrays.<Widget>asList(initialRunTab, consoleTab, hostTab, resourceAllocationTab, bootOptionsTab, customPropertiesTab, highAvailabilityTab, poolTab, systemTab);
}
#method_after
protected List<Widget> allTabs() {
    return Arrays.<Widget>asList(initialRunTab, consoleTab, hostTab, resourceAllocationTab, bootOptionsTab, customPropertiesTab, rngDeviceTab, highAvailabilityTab, poolTab, systemTab);
}
#end_block

#method_before
protected void disableAllTabs() {
    generalTab.disableContent();
    poolTab.disableContent();
    initialRunTab.disableContent();
    consoleTab.disableContent();
    hostTab.disableContent();
    highAvailabilityTab.disableContent();
    resourceAllocationTab.disableContent();
    bootOptionsTab.disableContent();
    customPropertiesTab.disableContent();
    systemTab.disableContent();
    oSTypeEditor.setEnabled(false);
    quotaEditor.setEnabled(false);
    dataCenterWithClusterEditor.setEnabled(false);
    templateEditor.setEnabled(false);
    baseTemplateEditor.setEnabled(false);
    vmTypeEditor.setEnabled(false);
}
#method_after
protected void disableAllTabs() {
    generalTab.disableContent();
    poolTab.disableContent();
    initialRunTab.disableContent();
    consoleTab.disableContent();
    hostTab.disableContent();
    highAvailabilityTab.disableContent();
    resourceAllocationTab.disableContent();
    bootOptionsTab.disableContent();
    customPropertiesTab.disableContent();
    systemTab.disableContent();
    rngDeviceTab.disableContent();
    oSTypeEditor.setEnabled(false);
    quotaEditor.setEnabled(false);
    dataCenterWithClusterEditor.setEnabled(false);
    templateEditor.setEnabled(false);
    baseTemplateEditor.setEnabled(false);
    vmTypeEditor.setEnabled(false);
    instanceTypesEditor.setEnabled(false);
}
#end_block

#method_before
public void setEnumTitle(Enum<?> enumObj) {
    setTitle(new EnumTranslator().get(enumObj));
}
#method_after
public void setEnumTitle(Enum<?> enumObj) {
    setTitle(EnumTranslator.getInstance().get(enumObj));
}
#end_block

#method_before
public static <T> ArrayList<EntityModel> toEntityModelList(ArrayList<T> list) {
    ArrayList<EntityModel> entityModelList = new ArrayList<EntityModel>();
    if (list != null) {
        for (Object item : list) {
            EntityModel model = new EntityModel();
            model.setEntity(item);
            entityModelList.add(model);
        }
    }
    return entityModelList;
}
#method_after
public static <T> ArrayList<EntityModel<T>> toEntityModelList(ArrayList<T> list) {
    ArrayList<EntityModel<T>> entityModelList = new ArrayList<EntityModel<T>>();
    if (list != null) {
        for (T item : list) {
            EntityModel<T> model = new EntityModel<T>();
            model.setEntity(item);
            entityModelList.add(model);
        }
    }
    return entityModelList;
}
#end_block

#method_before
@Override
public int compare(ProviderType type1, ProviderType type2) {
    final EnumTranslator enumTranslator = new EnumTranslator();
    return LexoNumericComparator.comp(enumTranslator.get(type1), enumTranslator.get(type2));
}
#method_after
@Override
public int compare(ProviderType type1, ProviderType type2) {
    final EnumTranslator enumTranslator = EnumTranslator.getInstance();
    return LexoNumericComparator.comp(enumTranslator.get(type1), enumTranslator.get(type2));
}
#end_block

#method_before
@Override
public int compare(PolicyUnit pu1, PolicyUnit pu2) {
    if (pu1.isInternal() != pu2.isInternal()) {
        return !pu1.isInternal() ? -1 : 1;
    }
    if (pu1.isEnabled() != pu2.isEnabled()) {
        return !pu1.isEnabled() ? -1 : 1;
    }
    if (pu1.getPolicyUnitType() != pu2.getPolicyUnitType()) {
        if (pu1.getPolicyUnitType().equals(PolicyUnitType.Filter) || pu2.getPolicyUnitType().equals(PolicyUnitType.LoadBalancing)) {
            return -1;
        }
        if (pu2.getPolicyUnitType().equals(PolicyUnitType.Filter) || pu1.getPolicyUnitType().equals(PolicyUnitType.LoadBalancing)) {
            return 1;
        }
    }
    return lexoNumeric.compare(pu1.getName(), pu2.getName());
}
#method_after
@Override
public int compare(PolicyUnit pu1, PolicyUnit pu2) {
    if (pu1.isInternal() != pu2.isInternal()) {
        return !pu1.isInternal() ? -1 : 1;
    }
    if (pu1.isEnabled() != pu2.isEnabled()) {
        return !pu1.isEnabled() ? -1 : 1;
    }
    if (pu1.getPolicyUnitType() != pu2.getPolicyUnitType()) {
        if (pu1.getPolicyUnitType().equals(PolicyUnitType.FILTER) || pu2.getPolicyUnitType().equals(PolicyUnitType.LOAD_BALANCING)) {
            return -1;
        }
        if (pu2.getPolicyUnitType().equals(PolicyUnitType.FILTER) || pu1.getPolicyUnitType().equals(PolicyUnitType.LOAD_BALANCING)) {
            return 1;
        }
    }
    return lexoNumeric.compare(pu1.getName(), pu2.getName());
}
#end_block

#method_before
@Override
public String render(Set<TransportType> transportTypes) {
    Translator transportTypeTranslator = new EnumTranslator();
    StringBuilder transportTypesBuilder = new StringBuilder();
    Iterator<TransportType> iterator = transportTypes.iterator();
    while (iterator.hasNext()) {
        TransportType transportType = iterator.next();
        if (transportTypeTranslator.containsKey(transportType)) {
            transportTypesBuilder.append(transportTypeTranslator.get(transportType));
        } else {
            transportTypesBuilder.append(transportType.toString());
        }
        if (iterator.hasNext()) {
            // $NON-NLS-1$
            transportTypesBuilder.append(", ");
        }
    }
    return (new String(transportTypesBuilder.toString()));
}
#method_after
@Override
public String render(Set<TransportType> transportTypes) {
    Translator transportTypeTranslator = EnumTranslator.getInstance();
    StringBuilder transportTypesBuilder = new StringBuilder();
    Iterator<TransportType> iterator = transportTypes.iterator();
    while (iterator.hasNext()) {
        TransportType transportType = iterator.next();
        transportTypesBuilder.append(transportTypeTranslator.get(transportType));
        if (iterator.hasNext()) {
            // $NON-NLS-1$
            transportTypesBuilder.append(", ");
        }
    }
    return transportTypesBuilder.toString();
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeBrickStatusColumn(), constants.bricksStatusVolume(), "150px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    List<HasCell<GlusterTaskSupport, ?>> compositeList = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeTaskWaitingCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivityCompositeCell<GlusterTaskSupport>(list)) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new Column<GlusterVolumeEntity, GlusterVolumeEntity>(new VolumeCapacityCell()) {

        @Override
        public GlusterVolumeEntity getValue(GlusterVolumeEntity object) {
            return object;
        }
    }, constants.volumeCapacity(), // $NON-NLS-1$
    "60px");
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(new VolumeActivityCompositeCell<GlusterTaskSupport>(compositeList) {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return !(value == null || value.getAsyncTask() == null);
        }
    }), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeBrickStatusColumn(), constants.bricksStatusVolume(), "150px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    List<HasCell<GlusterTaskSupport, ?>> compositeList = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeTaskWaitingCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivityCompositeCell<GlusterTaskSupport>(list)) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new Column<GlusterVolumeEntity, GlusterVolumeEntity>(new VolumeCapacityCell()) {

        @Override
        public GlusterVolumeEntity getValue(GlusterVolumeEntity object) {
            return object;
        }
    }, constants.volumeCapacity(), // $NON-NLS-1$
    "60px");
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(new VolumeActivityCompositeCell<GlusterTaskSupport>(compositeList) {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return !(value == null || value.getAsyncTask() == null);
        }
    }), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
    List<ActionButtonDefinition<GlusterVolumeEntity>> volumeProfilingActions = new LinkedList<ActionButtonDefinition<GlusterVolumeEntity>>();
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolumeProfiling()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartVolumeProfilingCommand();
        }
    });
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.volumeProfileDetails()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShowVolumeProfileDetailsCommand();
        }
    });
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolumeProfiling()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopVolumeProfilingCommand();
        }
    });
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.volumeProfilingAction(), volumeProfilingActions, CommandLocation.ContextAndToolBar));
}
#end_block

#method_before
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getBaseTemplate().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        getDomain().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#method_after
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getBaseTemplate().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getInstanceTypes().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getSerialNumberPolicy().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangable(false);
        getRngPeriod().setIsChangable(false);
        getRngBytes().setIsChangable(false);
        getRngSourceRandom().setIsChangable(false);
        getRngSourceHwrng().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#end_block

#method_before
public HashMap<Version, ArrayList<String>> getCustomPropertiesKeysList() {
    return privateCustomPropertiesKeysList;
}
#method_after
public Map<Version, Map<String, String>> getCustomPropertiesKeysList() {
    return privateCustomPropertiesKeysList;
}
#end_block

#method_before
public void setCustomPropertiesKeysList(HashMap<Version, ArrayList<String>> value) {
    privateCustomPropertiesKeysList = value;
}
#method_after
public void setCustomPropertiesKeysList(Map<Version, Map<String, String>> value) {
    privateCustomPropertiesKeysList = value;
}
#end_block

#method_before
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMinimalVmMemSize();
    initMaximalVmMemSize32OS();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#method_after
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    isRngEnabled.setEntity(false);
    rngSourceRandom.setEntity(true);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayProtocol();
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayProtocol();
            initUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            vmTypeChanged();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayProtocol();
            updateMemoryBalloonDevice();
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayProtocol();
            updateMemoryBalloonDevice();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        }
    }
}
#end_block

#method_before
private void initUsbPolicy() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    DisplayType displayType = (getDisplayProtocol().getSelectedItem() != null ? getDisplayProtocol().getSelectedItem().getEntity() : null);
    if (osType == null || cluster == null || displayType == null) {
        return;
    }
    getUsbPolicy().setIsChangable(true);
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) > 0) {
        if (AsyncDataProvider.isWindowsOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED));
            getUsbPolicy().setSelectedItem(UsbPolicy.DISABLED);
            getUsbPolicy().setIsChangable(false);
        }
    }
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) <= 0) {
        if (AsyncDataProvider.isLinuxOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_NATIVE));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY, UsbPolicy.ENABLED_NATIVE));
        }
    }
    if (displayType != DisplayType.qxl) {
        getUsbPolicy().setIsChangable(false);
    }
    getUsbPolicy().setSelectedItem(UsbPolicy.DISABLED);
}
#method_after
private void initUsbPolicy() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    DisplayType displayType = (getDisplayProtocol().getSelectedItem() != null ? getDisplayProtocol().getSelectedItem().getEntity() : null);
    if (osType == null || cluster == null || displayType == null) {
        return;
    }
    getUsbPolicy().setIsChangable(true);
    UsbPolicy prevSelectedUsbPolicy = getUsbPolicy().getSelectedItem();
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) > 0) {
        if (AsyncDataProvider.isWindowsOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED));
            getUsbPolicy().setIsChangable(false);
        }
    }
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) <= 0) {
        if (AsyncDataProvider.isLinuxOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_NATIVE));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY, UsbPolicy.ENABLED_NATIVE));
        }
    }
    if (displayType != DisplayType.qxl) {
        getUsbPolicy().setIsChangable(false);
    }
    Collection<UsbPolicy> policies = getUsbPolicy().getItems();
    if (policies.contains(prevSelectedUsbPolicy)) {
        getUsbPolicy().setSelectedItem(prevSelectedUsbPolicy);
    } else if (policies.size() > 0) {
        getUsbPolicy().setSelectedItem(policies.iterator().next());
    }
}
#end_block

#method_before
private void updateDisplayProtocol() {
    DisplayType oldDisplayProtocolOption = null;
    if (getDisplayProtocol().getSelectedItem() != null) {
        oldDisplayProtocolOption = getDisplayProtocol().getSelectedItem().getEntity();
    }
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    if (cluster == null || osType == null) {
        return;
    }
    List<EntityModel<DisplayType>> displayProtocolOptions = new ArrayList<EntityModel<DisplayType>>();
    List<DisplayType> displayTypes = AsyncDataProvider.getDisplayTypes(osType, cluster.getcompatibility_version());
    if (displayTypes.contains(DisplayType.vnc)) {
        EntityModel<DisplayType> vncProtocol = new EntityModel<DisplayType>();
        vncProtocol.setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
        vncProtocol.setEntity(DisplayType.vnc);
        displayProtocolOptions.add(vncProtocol);
    }
    if (displayTypes.contains(DisplayType.qxl)) {
        EntityModel<DisplayType> spiceProtocol = new EntityModel<DisplayType>();
        spiceProtocol.setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
        spiceProtocol.setEntity(DisplayType.qxl);
        displayProtocolOptions.add(spiceProtocol);
    }
    getDisplayProtocol().setItems(displayProtocolOptions);
    behavior.postDisplayTypeItemChanged(oldDisplayProtocolOption);
}
#method_after
private void updateDisplayProtocol() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    if (cluster == null || osType == null) {
        return;
    }
    List<DisplayType> displayTypes = AsyncDataProvider.getDisplayTypes(osType, cluster.getcompatibility_version());
    initDisplayProtocolWithTypes(displayTypes);
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMaximalVmMemSize();
    handleQxlClusterLevel();
    updateWatchdogModels();
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
}
#end_block

#method_before
private void handleQxlClusterLevel() {
    // Enable Single PCI only on cluster 3.3 and high and on Linux OS
    boolean isLinux = getIsLinuxOS();
    boolean isQxl = getDisplayType() == DisplayType.qxl;
    boolean clusterSupportsSinglePci = getSelectedCluster() != null && Version.v3_3.compareTo(getSelectedCluster().getcompatibility_version()) <= 0;
    getBehavior().enableSinglePCI(isLinux && isQxl && clusterSupportsSinglePci);
}
#method_after
private void handleQxlClusterLevel() {
    getBehavior().enableSinglePCI(getIsQxlSupported());
    if (getSelectedCluster() != null) {
        boolean isQxl = getDisplayType() == DisplayType.qxl;
        boolean spiceFileTransferToggle = isQxl && AsyncDataProvider.isSpiceFileTransferToggleSupported(getSelectedCluster().getcompatibility_version().toString());
        if (!spiceFileTransferToggle) {
            handleQxlChangeProhibitionReason(getSpiceFileTransferEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
        }
        getSpiceFileTransferEnabled().setIsChangable(spiceFileTransferToggle);
        boolean spiceCopyPasteToggle = isQxl && AsyncDataProvider.isSpiceCopyPasteToggleSupported(getSelectedCluster().getcompatibility_version().toString());
        if (!spiceCopyPasteToggle) {
            handleQxlChangeProhibitionReason(getSpiceCopyPasteEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
        }
        getSpiceCopyPasteEnabled().setIsChangable(spiceCopyPasteToggle);
    }
}
#end_block

#method_before
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateDefaultTimeZone();
    handleQxlClusterLevel();
    updateWatchdogModels(osType);
    vmInitEnabledChanged();
}
#method_after
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getBehavior().updateDefaultTimeZone();
    handleQxlClusterLevel();
    updateWatchdogModels(osType);
    vmInitEnabledChanged();
}
#end_block

#method_before
private void updateWatchdogModels(Integer osType) {
    VDSGroup cluster = getSelectedCluster();
    if (osType != null && cluster != null && getWatchdogModel() != null) {
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                updateWatchdogItems((HashSet<VmWatchdogType>) ((VdcQueryReturnValue) returnValue).getReturnValue());
            }
        };
        AsyncDataProvider.getVmWatchdogTypes(osType, cluster.getcompatibility_version(), asyncQuery);
    }
}
#method_after
private void updateWatchdogModels(Integer osType) {
    VDSGroup cluster = getSelectedCluster();
    if (osType != null && cluster != null && getWatchdogModel() != null) {
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                getBehavior().deactivateInstanceTypeManager();
                updateWatchdogItems((HashSet<VmWatchdogType>) ((VdcQueryReturnValue) returnValue).getReturnValue());
                getBehavior().activateInstanceTypeManager();
            }
        };
        AsyncDataProvider.getVmWatchdogTypes(osType, cluster.getcompatibility_version(), asyncQuery);
    }
}
#end_block

#method_before
private void updateWatchdogItems(Set<VmWatchdogType> vmWatchdogTypes) {
    List<String> watchDogModels = new ArrayList<String>();
    for (VmWatchdogType vmWatchdogType : vmWatchdogTypes) {
        watchDogModels.add(new EnumTranslator().get(vmWatchdogType));
    }
    watchDogModels.add(0, null);
    String oldWatchdogSelected = getWatchdogModel().getSelectedItem();
    getWatchdogModel().setItems(watchDogModels);
    if (watchDogModels.contains(oldWatchdogSelected)) {
        getWatchdogModel().setSelectedItem(oldWatchdogSelected);
    }
}
#method_after
public void updateWatchdogItems(Set<VmWatchdogType> vmWatchdogTypes) {
    List<String> watchDogModels = new ArrayList<String>();
    for (VmWatchdogType vmWatchdogType : vmWatchdogTypes) {
        watchDogModels.add(EnumTranslator.getInstance().get(vmWatchdogType));
    }
    watchDogModels.add(0, null);
    String oldWatchdogSelected = (String) getWatchdogModel().getSelectedItem();
    getWatchdogModel().setItems(watchDogModels);
    if (watchDogModels.contains(oldWatchdogSelected)) {
        getWatchdogModel().setSelectedItem(oldWatchdogSelected);
    }
}
#end_block

#method_before
private void firstBootDevice_SelectedItemChanged(Object sender, EventArgs args) {
    EntityModel<BootSequence> entityModel = getFirstBootDevice().getSelectedItem();
    BootSequence firstDevice = entityModel.getEntity();
    List<EntityModel<BootSequence>> list = new ArrayList<EntityModel<BootSequence>>();
    for (EntityModel<BootSequence> item : getFirstBootDevice().getItems()) {
        if (item.getEntity() != firstDevice) {
            list.add(item);
        }
    }
    EntityModel<BootSequence> tempVar = new EntityModel<BootSequence>();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().noneTitle());
    EntityModel<BootSequence> noneOption = tempVar;
    list.add(0, noneOption);
    getSecondBootDevice().setItems(list);
    getSecondBootDevice().setSelectedItem(noneOption);
}
#method_after
private void firstBootDevice_SelectedItemChanged(Object sender, EventArgs args) {
    EntityModel<BootSequence> entityModel = getFirstBootDevice().getSelectedItem();
    BootSequence firstDevice = entityModel.getEntity();
    EntityModel<BootSequence> prevItem = null;
    List<EntityModel<BootSequence>> list = new ArrayList<EntityModel<BootSequence>>();
    for (EntityModel<BootSequence> item : getFirstBootDevice().getItems()) {
        if (item.getEntity() != firstDevice) {
            list.add(item);
            if (getSecondBootDevice().getSelectedItem() != null && item.getEntity() == getSecondBootDevice().getSelectedItem().getEntity()) {
                prevItem = item;
            }
        }
    }
    EntityModel<BootSequence> tempVar = new EntityModel<BootSequence>();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().noneTitle());
    EntityModel<BootSequence> noneOption = tempVar;
    list.add(0, noneOption);
    getSecondBootDevice().setItems(list);
    if (prevItem != null) {
        getSecondBootDevice().setSelectedItem(prevItem);
    } else {
        getSecondBootDevice().setSelectedItem(noneOption);
    }
}
#end_block

#method_before
private DisplayType getDisplayType() {
    EntityModel<DisplayType> entityModel = getDisplayProtocol().getSelectedItem();
    if (entityModel == null) {
        return null;
    }
    return entityModel.getEntity();
}
#method_after
public DisplayType getDisplayType() {
    EntityModel<DisplayType> entityModel = getDisplayProtocol().getSelectedItem();
    if (entityModel == null) {
        return null;
    }
    return entityModel.getEntity();
}
#end_block

#method_before
private void displayProtocol_SelectedItemChanged(Object sender, EventArgs args) {
    if (getDisplayType() == null) {
        return;
    }
    DisplayType type = getDisplayType();
    if (type == DisplayType.vnc) {
        getUsbPolicy().setSelectedItem(org.ovirt.engine.core.common.businessentities.UsbPolicy.DISABLED);
        getIsSmartcardEnabled().setEntity(false);
    }
    handleQxlClusterLevel();
    getUsbPolicy().setIsChangable(type == DisplayType.qxl);
    getIsSmartcardEnabled().setIsChangable(type == DisplayType.qxl);
    getVncKeyboardLayout().setIsAvailable(type == DisplayType.vnc);
    updateNumOfMonitors();
}
#method_after
private void displayProtocol_SelectedItemChanged(Object sender, EventArgs args) {
    if (getDisplayType() == null) {
        getBehavior().activateInstanceTypeManager();
        return;
    }
    DisplayType type = getDisplayType();
    if (type == DisplayType.vnc) {
        getUsbPolicy().setSelectedItem(org.ovirt.engine.core.common.businessentities.UsbPolicy.DISABLED);
        getIsSmartcardEnabled().setEntity(false);
    }
    handleQxlClusterLevel();
    getUsbPolicy().setIsChangable(type == DisplayType.qxl);
    getIsSmartcardEnabled().setIsChangable(type == DisplayType.qxl);
    getVncKeyboardLayout().setIsAvailable(type == DisplayType.vnc);
    updateNumOfMonitors();
}
#end_block

#method_before
protected void setupDataCenterWithClustersFromSystemTree(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    StoragePool dataCenter = getDataCenterAccordingSystemTree(model, dataCenters);
    // the dataCenters are the entities just downloaded from server while the dataCenter can be a cached one from the system tree
    dataCenter = dataCenter == null ? null : findDataCenterById(dataCenters, dataCenter.getId());
    List<VDSGroup> possibleClusters = getClusterAccordingSystemTree(model, clusters);
    if (dataCenter == null || possibleClusters == null) {
        getDataCenterWithClustersList().setIsChangable(false);
        return;
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (VDSGroup cluster : possibleClusters) {
        if (cluster.getStoragePoolId() != null && cluster.getStoragePoolId().equals(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#method_after
protected void setupDataCenterWithClustersFromSystemTree(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    StoragePool dataCenter = getDataCenterAccordingSystemTree(model, dataCenters);
    // the dataCenters are the entities just downloaded from server while the dataCenter can be a cached one from the system tree
    dataCenter = dataCenter == null ? null : findDataCenterById(dataCenters, dataCenter.getId());
    List<VDSGroup> possibleClusters = getClusterAccordingSystemTree(model, clusters);
    if (dataCenter == null || possibleClusters == null) {
        getDataCenterWithClustersList().setIsChangable(false);
        return;
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (VDSGroup cluster : possibleClusters) {
        if (cluster.getStoragePoolId() != null && cluster.getStoragePoolId().equals(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    selectDataCenterWithCluster(selectedCluster, dataCentersWithClusters);
}
#end_block

#method_before
protected void setupDataCenterWithClusters(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    Map<Guid, List<VDSGroup>> dataCenterToCluster = new HashMap<Guid, List<VDSGroup>>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getStoragePoolId() == null) {
            continue;
        }
        if (!dataCenterToCluster.containsKey(cluster.getStoragePoolId())) {
            dataCenterToCluster.put(cluster.getStoragePoolId(), new ArrayList<VDSGroup>());
        }
        dataCenterToCluster.get(cluster.getStoragePoolId()).add(cluster);
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (StoragePool dataCenter : dataCenters) {
        if (dataCenterToCluster.containsKey(dataCenter.getId())) {
            for (VDSGroup cluster : dataCenterToCluster.get(dataCenter.getId())) {
                dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
            }
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#method_after
protected void setupDataCenterWithClusters(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    Map<Guid, List<VDSGroup>> dataCenterToCluster = new HashMap<Guid, List<VDSGroup>>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getStoragePoolId() == null) {
            continue;
        }
        if (!dataCenterToCluster.containsKey(cluster.getStoragePoolId())) {
            dataCenterToCluster.put(cluster.getStoragePoolId(), new ArrayList<VDSGroup>());
        }
        dataCenterToCluster.get(cluster.getStoragePoolId()).add(cluster);
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (StoragePool dataCenter : dataCenters) {
        if (dataCenterToCluster.containsKey(dataCenter.getId())) {
            for (VDSGroup cluster : dataCenterToCluster.get(dataCenter.getId())) {
                dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
            }
        }
    }
    selectDataCenterWithCluster(selectedCluster, dataCentersWithClusters);
}
#end_block

#method_before
protected void selectDataCenterWithCluster(UnitVmModel model, Guid selectedCluster, List<DataCenterWithCluster> dataCentersWithClusters) {
    if (selectedCluster == null) {
        getDataCenterWithClustersList().setSelectedItem(Linq.firstOrDefault(dataCentersWithClusters));
    } else {
        model.getDataCenterWithClustersList().setSelectedItem(Linq.firstOrDefault(dataCentersWithClusters, new Linq.DataCenterWithClusterAccordingClusterPredicate(selectedCluster)));
    }
}
#method_after
protected void selectDataCenterWithCluster(Guid selectedCluster, List<DataCenterWithCluster> dataCentersWithClusters) {
    DataCenterWithCluster selectedDataCenterWithCluster = (selectedCluster == null) ? Linq.firstOrDefault(dataCentersWithClusters) : Linq.firstOrDefault(dataCentersWithClusters, new Linq.DataCenterWithClusterAccordingClusterPredicate(selectedCluster));
    getDataCenterWithClustersList().setItems(dataCentersWithClusters, selectedDataCenterWithCluster);
}
#end_block

#method_before
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.setModel(this);
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                validateMemorySize(getMemSize(), (Integer) ((VdcQueryReturnValue) returnValue).getReturnValue(), _minMemSize);
                if (!(((UnitVmModel) model).getBehavior() instanceof TemplateVmModelBehavior)) {
                    // Minimum 'Physical Memory Guaranteed' is 1MB
                    validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
                }
            }
        };
        if (getSelectedCluster() != null) {
            AsyncDataProvider.getOsMaxRam(osType, getSelectedCluster().getcompatibility_version(), asyncQuery);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && behaviorValid && customPropertySheetValid && getQuota().getIsValid() && getMigrationDowntime().getIsValid();
}
#method_after
public boolean validate() {
    boolean hwPartValid = validateHwPart();
    getInstanceTypes().setIsValid(true);
    getInstanceTypes().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    setIsSystemTabValid(true);
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    setIsGeneralTabValid(getIsGeneralTabValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid());
    setIsFirstRunTabValid(getTimeZone().getIsValid());
    setIsHostTabValid(getIsHostTabValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getIsAllocationTabValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    return hwPartValid && vmInitIsValid && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && getQuota().getIsValid();
}
#end_block

#method_before
private void validateMemorySize(EntityModel model, int maxMemSize, int minMemSize) {
    boolean isValid = false;
    int memSize = (Integer) model.getEntity();
    if (memSize == 0) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().memSizeBetween(minMemSize, maxMemSize));
    } else if (memSize > maxMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().maxMemSizeIs(maxMemSize));
    } else if (memSize < minMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().minMemSizeIs(minMemSize));
    } else {
        isValid = true;
    }
    model.setIsValid(isValid);
}
#method_after
private void validateMemorySize(EntityModel<Integer> model, int maxMemSize, int minMemSize) {
    boolean isValid = false;
    int memSize = model.getEntity();
    if (memSize == 0) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().memSizeBetween(minMemSize, maxMemSize));
    } else if (memSize > maxMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().maxMemSizeIs(maxMemSize));
    } else if (memSize < minMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().minMemSizeIs(minMemSize));
    } else {
        isValid = true;
    }
    model.setIsValid(isValid);
}
#end_block

#method_before
private void updateProperties() {
    VmPool pool = (VmPool) getEntity();
    setName(pool.getName());
    setDescription(pool.getVmPoolDescription());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            // refactor to "switch ... case...".
            if (result != null) {
                setvm((VM) ((VdcQueryReturnValue) result).getReturnValue());
            }
            PoolGeneralModel poolGeneralModel = (PoolGeneralModel) model;
            if (getvm() != null) {
                poolGeneralModel.setTemplate(vmTemplateNameRenderer.render(getvm()));
                poolGeneralModel.setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(getvm().getNumOfCpus(), getvm().getNumOfSockets(), getvm().getCpuPerSocket()));
                poolGeneralModel.setMonitorCount(getvm().getNumOfMonitors());
                poolGeneralModel.setOS(getvm().getVmOsId());
                // $NON-NLS-1$
                poolGeneralModel.setDefinedMemory(getvm().getVmMemSizeMb() + " MB");
                // $NON-NLS-1$
                poolGeneralModel.setMinAllocatedMemory(getvm().getMinAllocatedMem() + " MB");
                Translator translator = new EnumTranslator();
                poolGeneralModel.setDefaultDisplayType(translator.get(getvm().getDefaultDisplayType()));
                poolGeneralModel.setOrigin(translator.get(getvm().getOrigin()));
                poolGeneralModel.setUsbPolicy(translator.get(getvm().getUsbPolicy()));
                setHasDomain(AsyncDataProvider.isWindowsOsType(getvm().getVmOsId()));
                setHasTimeZone(AsyncDataProvider.isWindowsOsType(getvm().getVmOsId()));
                poolGeneralModel.setTimeZone(getvm().getTimeZone());
                poolGeneralModel.setIsStateless(getvm().isStateless());
                poolGeneralModel.setQuotaName(getvm().getQuotaName());
                poolGeneralModel.setHasDefaultHost(getvm().getDedicatedVmForVds() != null);
                if (poolGeneralModel.getHasDefaultHost()) {
                    AsyncQuery _asyncQuery1 = new AsyncQuery();
                    _asyncQuery1.setModel(poolGeneralModel);
                    _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model1, Object ReturnValue1) {
                            PoolGeneralModel poolGeneralModel1 = (PoolGeneralModel) model1;
                            ArrayList<VDS> hosts = ((VdcQueryReturnValue) ReturnValue1).getReturnValue();
                            for (VDS host : hosts) {
                                if (host.getId().equals(poolGeneralModel1.getvm().getDedicatedVmForVds())) {
                                    poolGeneralModel1.setDefaultHost(host.getName());
                                    break;
                                }
                            }
                        }
                    };
                    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(// $NON-NLS-1$
                    "Host: cluster = " + getvm().getVdsGroupName() + " sortby name", SearchType.VDS), // $NON-NLS-1$
                    _asyncQuery1);
                } else {
                    poolGeneralModel.setDefaultHost(ConstantsManager.getInstance().getConstants().anyHostInCluster());
                }
            } else {
                poolGeneralModel.setTemplate(null);
                poolGeneralModel.setCpuCount(0);
                poolGeneralModel.setMonitorCount(0);
                poolGeneralModel.setOS(0);
                poolGeneralModel.setDefinedMemory(null);
                poolGeneralModel.setMinAllocatedMemory(null);
                poolGeneralModel.setDefaultDisplayType(null);
                poolGeneralModel.setHasDomain(false);
                poolGeneralModel.setDomain(null);
                poolGeneralModel.setHasTimeZone(false);
                poolGeneralModel.setTimeZone(null);
                poolGeneralModel.setUsbPolicy(null);
                poolGeneralModel.setDefaultHost(null);
                poolGeneralModel.setIsStateless(false);
                poolGeneralModel.getUpdateCompleteEvent().raise(this, EventArgs.EMPTY);
            }
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmDataByPoolId, new IdQueryParameters(pool.getVmPoolId()), _asyncQuery);
}
#method_after
private void updateProperties() {
    VmPool pool = (VmPool) getEntity();
    setName(pool.getName());
    setDescription(pool.getVmPoolDescription());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            // refactor to "switch ... case...".
            if (result != null) {
                setvm((VM) ((VdcQueryReturnValue) result).getReturnValue());
            }
            PoolGeneralModel poolGeneralModel = (PoolGeneralModel) model;
            if (getvm() != null) {
                poolGeneralModel.setTemplate(vmTemplateNameRenderer.render(getvm()));
                poolGeneralModel.setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(getvm().getNumOfCpus(), getvm().getNumOfSockets(), getvm().getCpuPerSocket()));
                poolGeneralModel.setMonitorCount(getvm().getNumOfMonitors());
                poolGeneralModel.setOS(getvm().getVmOsId());
                // $NON-NLS-1$
                poolGeneralModel.setDefinedMemory(getvm().getVmMemSizeMb() + " MB");
                // $NON-NLS-1$
                poolGeneralModel.setMinAllocatedMemory(getvm().getMinAllocatedMem() + " MB");
                Translator translator = EnumTranslator.getInstance();
                poolGeneralModel.setDefaultDisplayType(translator.get(getvm().getDefaultDisplayType()));
                poolGeneralModel.setOrigin(translator.get(getvm().getOrigin()));
                poolGeneralModel.setUsbPolicy(translator.get(getvm().getUsbPolicy()));
                setHasDomain(AsyncDataProvider.isWindowsOsType(getvm().getVmOsId()));
                setHasTimeZone(AsyncDataProvider.isWindowsOsType(getvm().getVmOsId()));
                poolGeneralModel.setTimeZone(getvm().getTimeZone());
                poolGeneralModel.setIsStateless(getvm().isStateless());
                poolGeneralModel.setQuotaName(getvm().getQuotaName());
                poolGeneralModel.setHasDefaultHost(getvm().getDedicatedVmForVds() != null);
                if (poolGeneralModel.getHasDefaultHost()) {
                    AsyncQuery _asyncQuery1 = new AsyncQuery();
                    _asyncQuery1.setModel(poolGeneralModel);
                    _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model1, Object ReturnValue1) {
                            PoolGeneralModel poolGeneralModel1 = (PoolGeneralModel) model1;
                            ArrayList<VDS> hosts = ((VdcQueryReturnValue) ReturnValue1).getReturnValue();
                            for (VDS host : hosts) {
                                if (host.getId().equals(poolGeneralModel1.getvm().getDedicatedVmForVds())) {
                                    poolGeneralModel1.setDefaultHost(host.getName());
                                    break;
                                }
                            }
                        }
                    };
                    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(// $NON-NLS-1$
                    "Host: cluster = " + getvm().getVdsGroupName() + " sortby name", SearchType.VDS), // $NON-NLS-1$
                    _asyncQuery1);
                } else {
                    poolGeneralModel.setDefaultHost(ConstantsManager.getInstance().getConstants().anyHostInCluster());
                }
            } else {
                poolGeneralModel.setTemplate(null);
                poolGeneralModel.setCpuCount(0);
                poolGeneralModel.setMonitorCount(0);
                poolGeneralModel.setOS(0);
                poolGeneralModel.setDefinedMemory(null);
                poolGeneralModel.setMinAllocatedMemory(null);
                poolGeneralModel.setDefaultDisplayType(null);
                poolGeneralModel.setHasDomain(false);
                poolGeneralModel.setDomain(null);
                poolGeneralModel.setHasTimeZone(false);
                poolGeneralModel.setTimeZone(null);
                poolGeneralModel.setUsbPolicy(null);
                poolGeneralModel.setDefaultHost(null);
                poolGeneralModel.setIsStateless(false);
                poolGeneralModel.getUpdateCompleteEvent().raise(this, EventArgs.EMPTY);
            }
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmDataByPoolId, new IdQueryParameters(pool.getVmPoolId()), _asyncQuery);
}
#end_block

#method_before
@Override
public void runActionExecutionFailed(VdcActionType action, VdcFault fault) {
    if (isRaiseErrorModalPanel(action, fault)) {
        errorPopupManager.show(messages.uiCommonRunActionExecutionFailed(new EnumTranslator().get(action), fault.getMessage()));
    }
}
#method_after
@Override
public void runActionExecutionFailed(VdcActionType action, VdcFault fault) {
    if (isRaiseErrorModalPanel(action, fault)) {
        errorPopupManager.show(messages.uiCommonRunActionExecutionFailed(EnumTranslator.getInstance().get(action), fault.getMessage()));
    }
}
#end_block

#method_before
@Override
public void runMultipleActionFailed(VdcActionType action, List<VdcReturnValueBase> returnValues) {
    List<Message> errors = new ArrayList<Message>();
    int actionNum = 0;
    for (VdcReturnValueBase v : returnValues) {
        ++actionNum;
        if (isRaiseErrorModalPanel(action, v.getFault())) {
            for (String canDo : v.getCanDoActionMessages()) {
                String description = // $NON-NLS-1$ //$NON-NLS-2$
                (v.getDescription() != null && !"".equals(v.getDescription().trim())) || returnValues.size() == 1 ? v.getDescription() : ConstantsManager.getInstance().getConstants().action() + " " + actionNum;
                Message msg = new Message(description, canDo);
                errors.add(msg);
            }
        }
    }
    errorPopupManager.show(messages.uiCommonRunActionFailed(ErrorMessageFormatter.formatMessages(errors)));
}
#method_after
@Override
public void runMultipleActionFailed(VdcActionType action, List<VdcReturnValueBase> returnValues) {
    List<VdcActionType> actions = new ArrayList<VdcActionType>();
    for (int i = 0; i < returnValues.size(); i++) {
        actions.add(action);
    }
    runMultipleActionsFailed(actions, returnValues);
}
#end_block

#method_before
public static String getDisplayStringForPluginName(String pluginName) {
    try {
        return new EnumTranslator().get(OpenstackNetworkPluginType.valueOf(pluginName));
    } catch (Exception e) {
        // $NON-NLS-1$
        return pluginName == null ? "" : pluginName;
    }
}
#method_after
public static String getDisplayStringForPluginName(String pluginName) {
    try {
        return EnumTranslator.getInstance().get(OpenstackNetworkPluginType.valueOf(pluginName));
    } catch (Exception e) {
        // $NON-NLS-1$
        return pluginName == null ? "" : pluginName;
    }
}
#end_block

#method_before
public void manageEvents() {
    EventNotificationModel model = new EventNotificationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().addEventNotificationTitle());
    model.setHelpTag(HelpTag.add_event_notification);
    // $NON-NLS-1$
    model.setHashName("add_event_notification");
    ArrayList<EventNotificationEntity> eventTypes = ApplicationModeHelper.getModeSpecificEventNotificationTypeList();
    Map<EventNotificationEntity, HashSet<AuditLogType>> availableEvents = AsyncDataProvider.getAvailableNotificationEvents();
    Translator translator = new EnumTranslator();
    ArrayList<SelectionTreeNodeModel> list = new ArrayList<SelectionTreeNodeModel>();
    ArrayList<event_subscriber> items = getItems() == null ? new ArrayList<event_subscriber>() : Linq.<event_subscriber>cast(getItems());
    for (EventNotificationEntity eventType : eventTypes) {
        SelectionTreeNodeModel stnm = new SelectionTreeNodeModel();
        stnm.setTitle(eventType.toString());
        stnm.setDescription(translator.containsKey(eventType) ? translator.get(eventType) : eventType.toString());
        list.add(stnm);
        for (AuditLogType logtype : availableEvents.get(eventType)) {
            SelectionTreeNodeModel eventGrp = new SelectionTreeNodeModel();
            String description;
            try {
                description = translator.get(logtype);
            } catch (MissingResourceException e) {
                description = logtype.toString();
            }
            eventGrp.setTitle(logtype.toString());
            eventGrp.setDescription(description);
            eventGrp.setParent(list.get(list.size() - 1));
            eventGrp.setIsSelectedNotificationPrevent(true);
            eventGrp.setIsSelectedNullable(false);
            for (event_subscriber es : items) {
                if (es.getevent_up_name().equals(logtype.toString())) {
                    eventGrp.setIsSelectedNullable(true);
                    break;
                }
            }
            list.get(list.size() - 1).getChildren().add(eventGrp);
            eventGrp.setIsSelectedNotificationPrevent(false);
        }
        if (list.get(list.size() - 1).getChildren().size() > 0) {
            list.get(list.size() - 1).getChildren().get(0).updateParentSelection();
        }
    }
    model.setEventGroupModels(list);
    if (!StringHelper.isNullOrEmpty(getEntity().getEmail())) {
        model.getEmail().setEntity(getEntity().getEmail());
    } else if (items.size() > 0) {
        model.getEmail().setEntity(items.get(0).getmethod_address());
    }
    model.setOldEmail((String) model.getEmail().getEntity());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void manageEvents() {
    EventNotificationModel model = new EventNotificationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().addEventNotificationTitle());
    model.setHelpTag(HelpTag.add_event_notification);
    // $NON-NLS-1$
    model.setHashName("add_event_notification");
    ArrayList<EventNotificationEntity> eventTypes = ApplicationModeHelper.getModeSpecificEventNotificationTypeList();
    Map<EventNotificationEntity, HashSet<AuditLogType>> availableEvents = AsyncDataProvider.getAvailableNotificationEvents();
    Translator translator = EnumTranslator.getInstance();
    ArrayList<SelectionTreeNodeModel> list = new ArrayList<SelectionTreeNodeModel>();
    ArrayList<event_subscriber> items = getItems() == null ? new ArrayList<event_subscriber>() : Linq.<event_subscriber>cast(getItems());
    for (EventNotificationEntity eventType : eventTypes) {
        SelectionTreeNodeModel stnm = new SelectionTreeNodeModel();
        stnm.setTitle(eventType.toString());
        stnm.setDescription(translator.get(eventType));
        list.add(stnm);
        for (AuditLogType logtype : availableEvents.get(eventType)) {
            SelectionTreeNodeModel eventGrp = new SelectionTreeNodeModel();
            String description;
            try {
                description = translator.get(logtype);
            } catch (MissingResourceException e) {
                description = logtype.toString();
            }
            eventGrp.setTitle(logtype.toString());
            eventGrp.setDescription(description);
            eventGrp.setParent(list.get(list.size() - 1));
            eventGrp.setIsSelectedNotificationPrevent(true);
            eventGrp.setIsSelectedNullable(false);
            for (event_subscriber es : items) {
                if (es.getevent_up_name().equals(logtype.toString())) {
                    eventGrp.setIsSelectedNullable(true);
                    break;
                }
            }
            list.get(list.size() - 1).getChildren().add(eventGrp);
            eventGrp.setIsSelectedNotificationPrevent(false);
        }
        if (list.get(list.size() - 1).getChildren().size() > 0) {
            list.get(list.size() - 1).getChildren().get(0).updateParentSelection();
        }
    }
    model.setEventGroupModels(list);
    if (!StringHelper.isNullOrEmpty(getEntity().getEmail())) {
        model.getEmail().setEntity(getEntity().getEmail());
    } else if (items.size() > 0) {
        model.getEmail().setEntity(items.get(0).getmethod_address());
    }
    model.setOldEmail((String) model.getEmail().getEntity());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void updateAlerts(final ViewDef view, final HostGeneralModel model) {
    // Clear all the alerts:
    view.clearAlerts();
    // Review the alerts and add those that are active:
    if (model.getHasUpgradeAlert()) {
        addTextAlert(view, messages.hostHasUpgradeAlert());
    }
    if (model.getHasReinstallAlertNonResponsive()) {
        addTextAlert(view, messages.hostHasReinstallAlertNonResponsive());
    }
    if (model.getHasReinstallAlertInstallFailed()) {
        addTextAndLinkAlert(view, messages.hostHasReinstallAlertInstallFailed(), model.getInstallCommand());
    }
    if (model.getHasReinstallAlertMaintenance()) {
        addTextAndLinkAlert(view, messages.hostHasReinstallAlertMaintenance(), model.getInstallCommand());
    }
    if (model.getHasNICsAlert()) {
        addTextAndLinkAlert(view, messages.hostHasNICsAlert(), model.getSaveNICsConfigCommand());
    }
    if (model.getHasManualFenceAlert()) {
        addTextAlert(view, messages.hostHasManualFenceAlert());
    }
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && model.getHasNoPowerManagementAlert()) {
        addTextAndLinkAlert(view, messages.hostHasNoPowerManagementAlert(), model.getEditHostCommand());
    }
    if (model.getNonOperationalReasonEntity() != null) {
        addTextAlert(view, new EnumTranslator().get(model.getNonOperationalReasonEntity()));
    }
}
#method_after
private void updateAlerts(final ViewDef view, final HostGeneralModel model) {
    // Clear all the alerts:
    view.clearAlerts();
    // Review the alerts and add those that are active:
    if (model.getHasUpgradeAlert()) {
        addTextAlert(view, messages.hostHasUpgradeAlert());
    }
    if (model.getHasReinstallAlertNonResponsive()) {
        addTextAlert(view, messages.hostHasReinstallAlertNonResponsive());
    }
    if (model.getHasNICsAlert()) {
        addTextAndLinkAlert(view, messages.hostHasNICsAlert(), model.getSaveNICsConfigCommand());
    }
    if (model.getHasManualFenceAlert()) {
        addTextAlert(view, messages.hostHasManualFenceAlert());
    }
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && model.getHasNoPowerManagementAlert()) {
        addTextAndLinkAlert(view, messages.hostHasNoPowerManagementAlert(), model.getEditHostCommand());
    }
    if (model.getNonOperationalReasonEntity() != null) {
        addTextAlert(view, EnumTranslator.getInstance().get(model.getNonOperationalReasonEntity()));
    }
}
#end_block

#method_before
SafeHtml getResourceImage(VM vm) {
    if (vm.getVmPauseStatus() != VmPauseStatus.NONE || vm.getVmPauseStatus() != VmPauseStatus.NOERR) {
        return null;
    } else {
        // Create Image from the alert resource
        ImageResource alertImageResource = resources.alertImage();
        // Get the image html
        AbstractImagePrototype imagePrototype = AbstractImagePrototype.create(alertImageResource);
        String html = imagePrototype.getHTML();
        // Append tooltip
        Translator translator = new EnumTranslator();
        String toolTip = translator.get(vm.getVmPauseStatus());
        // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
        html = html.replaceFirst("img", "img " + "title='" + toolTip + "' ");
        return SafeHtmlUtils.fromTrustedString(html);
    }
}
#method_after
SafeHtml getResourceImage(VM vm) {
    if (vm.getVmPauseStatus() != VmPauseStatus.NONE || vm.getVmPauseStatus() != VmPauseStatus.NOERR) {
        return null;
    } else {
        // Create Image from the alert resource
        ImageResource alertImageResource = resources.alertImage();
        // Get the image html
        AbstractImagePrototype imagePrototype = AbstractImagePrototype.create(alertImageResource);
        String html = imagePrototype.getHTML();
        // Append tooltip
        Translator translator = EnumTranslator.getInstance();
        String toolTip = translator.get(vm.getVmPauseStatus());
        // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
        html = html.replaceFirst("img", "img " + "title='" + toolTip + "' ");
        return SafeHtmlUtils.fromTrustedString(html);
    }
}
#end_block

#method_before
RequestBuilder createRequest() {
    RequestBuilder requestBuilder = new RequestBuilder(RequestBuilder.GET, restApiBaseUrl);
    // $NON-NLS-1$ //$NON-NLS-2$
    requestBuilder.setHeader("Prefer", "persistent-auth, csrf-protection");
    // $NON-NLS-1$
    requestBuilder.setHeader("Session-TTL", getSessionTimeout());
    if (restApiSessionId != null) {
        requestBuilder.setHeader(SESSION_ID_HEADER, restApiSessionId);
    }
    return requestBuilder;
}
#method_after
RequestBuilder createRequest() {
    RequestBuilder requestBuilder = new RequestBuilder(RequestBuilder.GET, restApiBaseUrl);
    // $NON-NLS-1$ //$NON-NLS-2$
    requestBuilder.setHeader("Prefer", "persistent-auth, csrf-protection");
    // $NON-NLS-1$
    requestBuilder.setHeader("Session-TTL", getSessionTimeout());
    String sessionId = getSessionId();
    if (sessionId != null) {
        requestBuilder.setHeader(SESSION_ID_HEADER, sessionId);
    }
    return requestBuilder;
}
#end_block

#method_before
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getBaseTemplate().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        getDomain().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#method_after
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getBaseTemplate().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getInstanceTypes().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getSerialNumberPolicy().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangable(false);
        getRngPeriod().setIsChangable(false);
        getRngBytes().setIsChangable(false);
        getRngSourceRandom().setIsChangable(false);
        getRngSourceHwrng().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#end_block

#method_before
public HashMap<Version, ArrayList<String>> getCustomPropertiesKeysList() {
    return privateCustomPropertiesKeysList;
}
#method_after
public Map<Version, Map<String, String>> getCustomPropertiesKeysList() {
    return privateCustomPropertiesKeysList;
}
#end_block

#method_before
public void setCustomPropertiesKeysList(HashMap<Version, ArrayList<String>> value) {
    privateCustomPropertiesKeysList = value;
}
#method_after
public void setCustomPropertiesKeysList(Map<Version, Map<String, String>> value) {
    privateCustomPropertiesKeysList = value;
}
#end_block

#method_before
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMinimalVmMemSize();
    initMaximalVmMemSize32OS();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#method_after
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    isRngEnabled.setEntity(false);
    rngSourceRandom.setEntity(true);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayProtocol();
            updateMemoryBalloonDevice();
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayProtocol();
            updateMemoryBalloonDevice();
            initUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            vmTypeChanged();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayProtocol();
            updateMemoryBalloonDevice();
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayProtocol();
            updateMemoryBalloonDevice();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        }
    }
}
#end_block

#method_before
private void initUsbPolicy() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    DisplayType displayType = (getDisplayProtocol().getSelectedItem() != null ? getDisplayProtocol().getSelectedItem().getEntity() : null);
    if (osType == null || cluster == null || displayType == null) {
        return;
    }
    getUsbPolicy().setIsChangable(true);
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) > 0) {
        if (AsyncDataProvider.isWindowsOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED));
            getUsbPolicy().setSelectedItem(UsbPolicy.DISABLED);
            getUsbPolicy().setIsChangable(false);
        }
    }
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) <= 0) {
        if (AsyncDataProvider.isLinuxOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_NATIVE));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY, UsbPolicy.ENABLED_NATIVE));
        }
    }
    if (displayType != DisplayType.qxl) {
        getUsbPolicy().setIsChangable(false);
    }
    getUsbPolicy().setSelectedItem(UsbPolicy.DISABLED);
}
#method_after
private void initUsbPolicy() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    DisplayType displayType = (getDisplayProtocol().getSelectedItem() != null ? getDisplayProtocol().getSelectedItem().getEntity() : null);
    if (osType == null || cluster == null || displayType == null) {
        return;
    }
    getUsbPolicy().setIsChangable(true);
    UsbPolicy prevSelectedUsbPolicy = getUsbPolicy().getSelectedItem();
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) > 0) {
        if (AsyncDataProvider.isWindowsOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED));
            getUsbPolicy().setIsChangable(false);
        }
    }
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) <= 0) {
        if (AsyncDataProvider.isLinuxOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_NATIVE));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY, UsbPolicy.ENABLED_NATIVE));
        }
    }
    if (displayType != DisplayType.qxl) {
        getUsbPolicy().setIsChangable(false);
    }
    Collection<UsbPolicy> policies = getUsbPolicy().getItems();
    if (policies.contains(prevSelectedUsbPolicy)) {
        getUsbPolicy().setSelectedItem(prevSelectedUsbPolicy);
    } else if (policies.size() > 0) {
        getUsbPolicy().setSelectedItem(policies.iterator().next());
    }
}
#end_block

#method_before
private void updateDisplayProtocol() {
    DisplayType oldDisplayProtocolOption = null;
    if (getDisplayProtocol().getSelectedItem() != null) {
        oldDisplayProtocolOption = getDisplayProtocol().getSelectedItem().getEntity();
    }
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    if (cluster == null || osType == null) {
        return;
    }
    List<EntityModel<DisplayType>> displayProtocolOptions = new ArrayList<EntityModel<DisplayType>>();
    List<DisplayType> displayTypes = AsyncDataProvider.getDisplayTypes(osType, cluster.getcompatibility_version());
    if (displayTypes.contains(DisplayType.vnc)) {
        EntityModel<DisplayType> vncProtocol = new EntityModel<DisplayType>();
        vncProtocol.setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
        vncProtocol.setEntity(DisplayType.vnc);
        displayProtocolOptions.add(vncProtocol);
    }
    if (displayTypes.contains(DisplayType.qxl)) {
        EntityModel<DisplayType> spiceProtocol = new EntityModel<DisplayType>();
        spiceProtocol.setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
        spiceProtocol.setEntity(DisplayType.qxl);
        displayProtocolOptions.add(spiceProtocol);
    }
    getDisplayProtocol().setItems(displayProtocolOptions);
    behavior.postDisplayTypeItemChanged(oldDisplayProtocolOption);
}
#method_after
private void updateDisplayProtocol() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    if (cluster == null || osType == null) {
        return;
    }
    List<DisplayType> displayTypes = AsyncDataProvider.getDisplayTypes(osType, cluster.getcompatibility_version());
    initDisplayProtocolWithTypes(displayTypes);
}
#end_block

#method_before
private void updateMemoryBalloonDevice() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    if (cluster == null || osType == null) {
        return;
    }
    boolean isBalloonEnabled = AsyncDataProvider.isBalloonEnabled(osType, cluster.getcompatibility_version());
    getMemoryBalloonDeviceEnabled().setEntity(isBalloonEnabled);
}
#method_after
private void updateMemoryBalloonDevice() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    if (cluster == null || osType == null) {
        return;
    }
    boolean isBalloonEnabled = AsyncDataProvider.isBalloonEnabled(osType, cluster.getcompatibility_version());
    getMemoryBalloonDeviceEnabled().setIsChangable(isBalloonEnabled);
    getMemoryBalloonDeviceEnabled().setEntity(isBalloonEnabled);
    if (!isBalloonEnabled) {
        getBehavior().deactivateInstanceTypeManager();
        getMemoryBalloonDeviceEnabled().setEntity(isBalloonEnabled);
        getBehavior().activateInstanceTypeManager();
    }
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMaximalVmMemSize();
    handleQxlClusterLevel();
    updateWatchdogModels();
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
}
#end_block

#method_before
private void handleQxlClusterLevel() {
    // Enable Single PCI only on cluster 3.3 and high and on Linux OS
    boolean isLinux = getIsLinuxOS();
    boolean isQxl = getDisplayType() == DisplayType.qxl;
    boolean clusterSupportsSinglePci = getSelectedCluster() != null && Version.v3_3.compareTo(getSelectedCluster().getcompatibility_version()) <= 0;
    getBehavior().enableSinglePCI(isLinux && isQxl && clusterSupportsSinglePci);
}
#method_after
private void handleQxlClusterLevel() {
    getBehavior().enableSinglePCI(getIsQxlSupported());
    if (getSelectedCluster() != null) {
        boolean isQxl = getDisplayType() == DisplayType.qxl;
        boolean spiceFileTransferToggle = isQxl && AsyncDataProvider.isSpiceFileTransferToggleSupported(getSelectedCluster().getcompatibility_version().toString());
        if (!spiceFileTransferToggle) {
            handleQxlChangeProhibitionReason(getSpiceFileTransferEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
        }
        getSpiceFileTransferEnabled().setIsChangable(spiceFileTransferToggle);
        boolean spiceCopyPasteToggle = isQxl && AsyncDataProvider.isSpiceCopyPasteToggleSupported(getSelectedCluster().getcompatibility_version().toString());
        if (!spiceCopyPasteToggle) {
            handleQxlChangeProhibitionReason(getSpiceCopyPasteEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
        }
        getSpiceCopyPasteEnabled().setIsChangable(spiceCopyPasteToggle);
    }
}
#end_block

#method_before
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateDefaultTimeZone();
    handleQxlClusterLevel();
    updateWatchdogModels(osType);
    vmInitEnabledChanged();
}
#method_after
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getBehavior().updateDefaultTimeZone();
    handleQxlClusterLevel();
    updateWatchdogModels(osType);
    vmInitEnabledChanged();
}
#end_block

#method_before
private void updateWatchdogModels(Integer osType) {
    VDSGroup cluster = getSelectedCluster();
    if (osType != null && cluster != null && getWatchdogModel() != null) {
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                updateWatchdogItems((HashSet<VmWatchdogType>) ((VdcQueryReturnValue) returnValue).getReturnValue());
            }
        };
        AsyncDataProvider.getVmWatchdogTypes(osType, cluster.getcompatibility_version(), asyncQuery);
    }
}
#method_after
private void updateWatchdogModels(Integer osType) {
    VDSGroup cluster = getSelectedCluster();
    if (osType != null && cluster != null && getWatchdogModel() != null) {
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                getBehavior().deactivateInstanceTypeManager();
                updateWatchdogItems((HashSet<VmWatchdogType>) ((VdcQueryReturnValue) returnValue).getReturnValue());
                getBehavior().activateInstanceTypeManager();
            }
        };
        AsyncDataProvider.getVmWatchdogTypes(osType, cluster.getcompatibility_version(), asyncQuery);
    }
}
#end_block

#method_before
private void updateWatchdogItems(Set<VmWatchdogType> vmWatchdogTypes) {
    List<String> watchDogModels = new ArrayList<String>();
    for (VmWatchdogType vmWatchdogType : vmWatchdogTypes) {
        watchDogModels.add(EnumTranslator.createAndTranslate(vmWatchdogType));
    }
    watchDogModels.add(0, null);
    String oldWatchdogSelected = (String) getWatchdogModel().getSelectedItem();
    getWatchdogModel().setItems(watchDogModels);
    if (watchDogModels.contains(oldWatchdogSelected)) {
        getWatchdogModel().setSelectedItem(oldWatchdogSelected);
    }
}
#method_after
public void updateWatchdogItems(Set<VmWatchdogType> vmWatchdogTypes) {
    List<String> watchDogModels = new ArrayList<String>();
    for (VmWatchdogType vmWatchdogType : vmWatchdogTypes) {
        watchDogModels.add(EnumTranslator.createAndTranslate(vmWatchdogType));
    }
    watchDogModels.add(0, null);
    String oldWatchdogSelected = (String) getWatchdogModel().getSelectedItem();
    getWatchdogModel().setItems(watchDogModels);
    if (watchDogModels.contains(oldWatchdogSelected)) {
        getWatchdogModel().setSelectedItem(oldWatchdogSelected);
    }
}
#end_block

#method_before
private void firstBootDevice_SelectedItemChanged(Object sender, EventArgs args) {
    EntityModel<BootSequence> entityModel = getFirstBootDevice().getSelectedItem();
    BootSequence firstDevice = entityModel.getEntity();
    List<EntityModel<BootSequence>> list = new ArrayList<EntityModel<BootSequence>>();
    for (EntityModel<BootSequence> item : getFirstBootDevice().getItems()) {
        if (item.getEntity() != firstDevice) {
            list.add(item);
        }
    }
    EntityModel<BootSequence> tempVar = new EntityModel<BootSequence>();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().noneTitle());
    EntityModel<BootSequence> noneOption = tempVar;
    list.add(0, noneOption);
    getSecondBootDevice().setItems(list);
    getSecondBootDevice().setSelectedItem(noneOption);
}
#method_after
private void firstBootDevice_SelectedItemChanged(Object sender, EventArgs args) {
    EntityModel<BootSequence> entityModel = getFirstBootDevice().getSelectedItem();
    BootSequence firstDevice = entityModel.getEntity();
    EntityModel<BootSequence> prevItem = null;
    List<EntityModel<BootSequence>> list = new ArrayList<EntityModel<BootSequence>>();
    for (EntityModel<BootSequence> item : getFirstBootDevice().getItems()) {
        if (item.getEntity() != firstDevice) {
            list.add(item);
            if (getSecondBootDevice().getSelectedItem() != null && item.getEntity() == getSecondBootDevice().getSelectedItem().getEntity()) {
                prevItem = item;
            }
        }
    }
    EntityModel<BootSequence> tempVar = new EntityModel<BootSequence>();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().noneTitle());
    EntityModel<BootSequence> noneOption = tempVar;
    list.add(0, noneOption);
    getSecondBootDevice().setItems(list);
    if (prevItem != null) {
        getSecondBootDevice().setSelectedItem(prevItem);
    } else {
        getSecondBootDevice().setSelectedItem(noneOption);
    }
}
#end_block

#method_before
private DisplayType getDisplayType() {
    EntityModel<DisplayType> entityModel = getDisplayProtocol().getSelectedItem();
    if (entityModel == null) {
        return null;
    }
    return entityModel.getEntity();
}
#method_after
public DisplayType getDisplayType() {
    EntityModel<DisplayType> entityModel = getDisplayProtocol().getSelectedItem();
    if (entityModel == null) {
        return null;
    }
    return entityModel.getEntity();
}
#end_block

#method_before
private void displayProtocol_SelectedItemChanged(Object sender, EventArgs args) {
    if (getDisplayType() == null) {
        return;
    }
    DisplayType type = getDisplayType();
    if (type == DisplayType.vnc) {
        getUsbPolicy().setSelectedItem(org.ovirt.engine.core.common.businessentities.UsbPolicy.DISABLED);
        getIsSmartcardEnabled().setEntity(false);
    }
    handleQxlClusterLevel();
    getUsbPolicy().setIsChangable(type == DisplayType.qxl);
    getIsSmartcardEnabled().setIsChangable(type == DisplayType.qxl);
    getVncKeyboardLayout().setIsAvailable(type == DisplayType.vnc);
    updateNumOfMonitors();
}
#method_after
private void displayProtocol_SelectedItemChanged(Object sender, EventArgs args) {
    if (getDisplayType() == null) {
        getBehavior().activateInstanceTypeManager();
        return;
    }
    DisplayType type = getDisplayType();
    if (type == DisplayType.vnc) {
        getUsbPolicy().setSelectedItem(org.ovirt.engine.core.common.businessentities.UsbPolicy.DISABLED);
        getIsSmartcardEnabled().setEntity(false);
    }
    handleQxlClusterLevel();
    getUsbPolicy().setIsChangable(type == DisplayType.qxl);
    getIsSmartcardEnabled().setIsChangable(type == DisplayType.qxl);
    getVncKeyboardLayout().setIsAvailable(type == DisplayType.vnc);
    updateNumOfMonitors();
}
#end_block

#method_before
protected void setupDataCenterWithClustersFromSystemTree(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    StoragePool dataCenter = getDataCenterAccordingSystemTree(model, dataCenters);
    // the dataCenters are the entities just downloaded from server while the dataCenter can be a cached one from the system tree
    dataCenter = dataCenter == null ? null : findDataCenterById(dataCenters, dataCenter.getId());
    List<VDSGroup> possibleClusters = getClusterAccordingSystemTree(model, clusters);
    if (dataCenter == null || possibleClusters == null) {
        getDataCenterWithClustersList().setIsChangable(false);
        return;
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (VDSGroup cluster : possibleClusters) {
        if (cluster.getStoragePoolId() != null && cluster.getStoragePoolId().equals(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#method_after
protected void setupDataCenterWithClustersFromSystemTree(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    StoragePool dataCenter = getDataCenterAccordingSystemTree(model, dataCenters);
    // the dataCenters are the entities just downloaded from server while the dataCenter can be a cached one from the system tree
    dataCenter = dataCenter == null ? null : findDataCenterById(dataCenters, dataCenter.getId());
    List<VDSGroup> possibleClusters = getClusterAccordingSystemTree(model, clusters);
    if (dataCenter == null || possibleClusters == null) {
        getDataCenterWithClustersList().setIsChangable(false);
        return;
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (VDSGroup cluster : possibleClusters) {
        if (cluster.getStoragePoolId() != null && cluster.getStoragePoolId().equals(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    selectDataCenterWithCluster(selectedCluster, dataCentersWithClusters);
}
#end_block

#method_before
protected void setupDataCenterWithClusters(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    Map<Guid, List<VDSGroup>> dataCenterToCluster = new HashMap<Guid, List<VDSGroup>>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getStoragePoolId() == null) {
            continue;
        }
        if (!dataCenterToCluster.containsKey(cluster.getStoragePoolId())) {
            dataCenterToCluster.put(cluster.getStoragePoolId(), new ArrayList<VDSGroup>());
        }
        dataCenterToCluster.get(cluster.getStoragePoolId()).add(cluster);
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (StoragePool dataCenter : dataCenters) {
        if (dataCenterToCluster.containsKey(dataCenter.getId())) {
            for (VDSGroup cluster : dataCenterToCluster.get(dataCenter.getId())) {
                dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
            }
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#method_after
protected void setupDataCenterWithClusters(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    Map<Guid, List<VDSGroup>> dataCenterToCluster = new HashMap<Guid, List<VDSGroup>>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getStoragePoolId() == null) {
            continue;
        }
        if (!dataCenterToCluster.containsKey(cluster.getStoragePoolId())) {
            dataCenterToCluster.put(cluster.getStoragePoolId(), new ArrayList<VDSGroup>());
        }
        dataCenterToCluster.get(cluster.getStoragePoolId()).add(cluster);
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (StoragePool dataCenter : dataCenters) {
        if (dataCenterToCluster.containsKey(dataCenter.getId())) {
            for (VDSGroup cluster : dataCenterToCluster.get(dataCenter.getId())) {
                dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
            }
        }
    }
    selectDataCenterWithCluster(selectedCluster, dataCentersWithClusters);
}
#end_block

#method_before
protected void selectDataCenterWithCluster(UnitVmModel model, Guid selectedCluster, List<DataCenterWithCluster> dataCentersWithClusters) {
    if (selectedCluster == null) {
        getDataCenterWithClustersList().setSelectedItem(Linq.firstOrDefault(dataCentersWithClusters));
    } else {
        model.getDataCenterWithClustersList().setSelectedItem(Linq.firstOrDefault(dataCentersWithClusters, new Linq.DataCenterWithClusterAccordingClusterPredicate(selectedCluster)));
    }
}
#method_after
protected void selectDataCenterWithCluster(Guid selectedCluster, List<DataCenterWithCluster> dataCentersWithClusters) {
    DataCenterWithCluster selectedDataCenterWithCluster = (selectedCluster == null) ? Linq.firstOrDefault(dataCentersWithClusters) : Linq.firstOrDefault(dataCentersWithClusters, new Linq.DataCenterWithClusterAccordingClusterPredicate(selectedCluster));
    getDataCenterWithClustersList().setItems(dataCentersWithClusters, selectedDataCenterWithCluster);
}
#end_block

#method_before
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.setModel(this);
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                validateMemorySize(getMemSize(), (Integer) ((VdcQueryReturnValue) returnValue).getReturnValue(), _minMemSize);
                if (!(((UnitVmModel) model).getBehavior() instanceof TemplateVmModelBehavior)) {
                    // Minimum 'Physical Memory Guaranteed' is 1MB
                    validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
                }
            }
        };
        if (getSelectedCluster() != null) {
            AsyncDataProvider.getOsMaxRam(osType, getSelectedCluster().getcompatibility_version(), asyncQuery);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && behaviorValid && customPropertySheetValid && getQuota().getIsValid() && getMigrationDowntime().getIsValid();
}
#method_after
public boolean validate() {
    boolean hwPartValid = validateHwPart();
    getInstanceTypes().setIsValid(true);
    getInstanceTypes().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    setIsSystemTabValid(true);
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    setIsGeneralTabValid(getIsGeneralTabValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid());
    setIsFirstRunTabValid(getTimeZone().getIsValid());
    setIsHostTabValid(getIsHostTabValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getIsAllocationTabValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    return hwPartValid && vmInitIsValid && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && getQuota().getIsValid();
}
#end_block

#method_before
private void validateMemorySize(EntityModel model, int maxMemSize, int minMemSize) {
    boolean isValid = false;
    int memSize = (Integer) model.getEntity();
    if (memSize == 0) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().memSizeBetween(minMemSize, maxMemSize));
    } else if (memSize > maxMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().maxMemSizeIs(maxMemSize));
    } else if (memSize < minMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().minMemSizeIs(minMemSize));
    } else {
        isValid = true;
    }
    model.setIsValid(isValid);
}
#method_after
private void validateMemorySize(EntityModel<Integer> model, int maxMemSize, int minMemSize) {
    boolean isValid = false;
    int memSize = model.getEntity();
    if (memSize == 0) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().memSizeBetween(minMemSize, maxMemSize));
    } else if (memSize > maxMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().maxMemSizeIs(maxMemSize));
    } else if (memSize < minMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().minMemSizeIs(minMemSize));
    } else {
        isValid = true;
    }
    model.setIsValid(isValid);
}
#end_block

#method_before
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = (String) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#method_after
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initCustomPropertiesList();
}
#end_block

#method_before
public static void initDefaultOSes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            defaultOSes = (HashMap<ArchitectureType, Integer>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDefaultOSes), callback);
}
#method_after
public static void initDefaultOSes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            defaultOSes = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDefaultOSes), callback);
}
#end_block

#method_before
public static void initNicHotplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            nicHotplugSupportMap = (Map<Pair<Integer, Version>, Boolean>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), callback);
}
#method_after
public static void initNicHotplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            nicHotplugSupportMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), callback);
}
#end_block

#method_before
public static void initDiskHotpluggableInterfacesMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            diskHotpluggableInterfacesMap = (Map<Pair<Integer, Version>, Set<String>>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), callback);
}
#method_after
public static void initDiskHotpluggableInterfacesMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            diskHotpluggableInterfacesMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), callback);
}
#end_block

#method_before
public static void isSoundcardEnabled(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return ((List<String>) source).size() > 0;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetSoundDevices, new IdQueryParameters(vmId), aQuery);
}
#method_after
public static void isSoundcardEnabled(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetSoundDevices, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void isVirtioScsiEnabledForVm(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return ((List<VmDevice>) source).size() > 0;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVirtioScsiControllers, new IdQueryParameters(vmId), aQuery);
}
#method_after
public static void isVirtioScsiEnabledForVm(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVirtioScsiControllers, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public static void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public static void isAnyHostUpInCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null && ((List) source).size() > 0) {
                return true;
            }
            return false;
        }
    };
    getUpHostListByCluster(aQuery, clusterName, 1);
}
#method_after
public static void isAnyHostUpInCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null && !((List<?>) source).isEmpty()) {
                return true;
            }
            return false;
        }
    };
    getUpHostListByCluster(aQuery, clusterName, 1);
}
#end_block

#method_before
public static void getCustomPropertiesList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            Map<Version, String> map = source != null ? (HashMap<Version, String>) source : new HashMap<Version, String>();
            Map<Version, ArrayList<String>> retMap = new HashMap<Version, ArrayList<String>>();
            for (Map.Entry<Version, String> keyValuePair : map.entrySet()) {
                // $NON-NLS-1$
                String[] split = keyValuePair.getValue().split("[;]", -1);
                if (split.length == 1 && (split[0] == null || split[0].isEmpty())) {
                    retMap.put(keyValuePair.getKey(), null);
                } else {
                    retMap.put(keyValuePair.getKey(), new ArrayList<String>());
                    for (String s : split) {
                        retMap.get(keyValuePair.getKey()).add(s);
                    }
                }
            }
            return retMap;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, new VdcQueryParametersBase(), aQuery);
}
#method_after
public static Map<Version, Map<String, String>> getCustomPropertiesList() {
    return customPropertiesList;
}
#end_block

#method_before
public static void getPmTypeList(AsyncQuery aQuery, Version version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<String> list = new ArrayList<String>();
            if (source != null) {
                // $NON-NLS-1$
                String[] array = ((String) source).split("[,]", -1);
                for (String item : array) {
                    list.add(item);
                }
            }
            return list;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.VdsFenceType);
    tempVar.setVersion(version != null ? version.toString() : getDefaultConfigurationVersion());
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public static void getPmTypeList(AsyncQuery aQuery, Version version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<String> list = new ArrayList<String>();
            if (source != null) {
                // $NON-NLS-1$
                String[] array = ((String) source).split("[,]", -1);
                for (String item : array) {
                    list.add(item);
                }
            }
            return list;
        }
    };
    GetConfigurationValueParameters param = new GetConfigurationValueParameters(ConfigurationValues.VdsFenceType);
    param.setVersion(version != null ? version.toString() : getDefaultConfigurationVersion());
    Frontend.getInstance().runQuery(VdcQueryType.GetFenceConfigurationValue, param, aQuery);
}
#end_block

#method_before
public static void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId), aQuery);
}
#method_after
public static void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public static void isCommandCompatible(AsyncQuery aQuery, final VdcActionType vdcActionType, final Version cluster, final Version dc) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            cachedCommandsCompatibilityVersions = (HashMap<VdcActionType, CommandVersionsInfo>) source;
            return isCommandCompatible(vdcActionType, cluster, dc);
        }
    };
    if (cachedCommandsCompatibilityVersions != null) {
        aQuery.asyncCallback.onSuccess(aQuery.getModel(), isCommandCompatible(vdcActionType, cluster, dc));
    } else {
        Frontend.getInstance().runQuery(VdcQueryType.GetCommandsCompatibilityVersions, new VdcQueryParametersBase(), aQuery);
    }
}
#method_after
public static void isCommandCompatible(AsyncQuery aQuery, final VdcActionType vdcActionType, final Version cluster, final Version dc) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            cachedCommandsCompatibilityVersions = (HashMap<VdcActionType, CommandVersionsInfo>) source;
            return isCommandCompatible(vdcActionType, cluster, dc);
        }
    };
    if (cachedCommandsCompatibilityVersions != null) {
        aQuery.asyncCallback.onSuccess(aQuery.getModel(), isCommandCompatible(vdcActionType, cluster, dc));
    } else {
        Frontend.getInstance().runQuery(VdcQueryType.GetCommandsCompatibilityVersions, new VdcQueryParametersBase().withoutRefresh(), aQuery);
    }
}
#end_block

#method_before
public static void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = (ArrayList<VdsNetworkInterface>) (returnValue.getReturnValue());
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (ObjectUtils.objectsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (ObjectUtils.objectsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#method_after
public static void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = returnValue.getReturnValue();
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (ObjectUtils.objectsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (ObjectUtils.objectsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#end_block

#method_before
private static void interfaceHasSiblingVlanInterfaces(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VdsNetworkInterface> siblingVlanInterfaces = (ArrayList<VdsNetworkInterface>) source;
            if (siblingVlanInterfaces.size() > 0) {
                return true;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllSiblingVlanInterfaces, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#method_after
private static void interfaceHasSiblingVlanInterfaces(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VdsNetworkInterface> siblingVlanInterfaces = (ArrayList<VdsNetworkInterface>) source;
            return !siblingVlanInterfaces.isEmpty();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllSiblingVlanInterfaces, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#end_block

#method_before
public static void getNicTypeList(final int osId, Version version, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> nics = (ArrayList<String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<VmInterfaceType> interfaceTypes = new ArrayList<VmInterfaceType>();
            for (String nic : nics) {
                try {
                    interfaceTypes.add(VmInterfaceType.valueOf(nic));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNetworkDevices, osId, version), asyncQuery);
}
#method_after
public static void getNicTypeList(final int osId, Version version, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> nics = ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<VmInterfaceType> interfaceTypes = new ArrayList<VmInterfaceType>();
            for (String nic : nics) {
                try {
                    interfaceTypes.add(VmInterfaceType.valueOf(nic));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNetworkDevices, osId, version), asyncQuery);
}
#end_block

#method_before
public static VmInterfaceType getDefaultNicType() {
    return VmInterfaceType.pv;
}
#method_after
public static VmInterfaceType getDefaultNicType(Collection<VmInterfaceType> items) {
    if (items == null || items.isEmpty()) {
        return null;
    } else if (items.contains(VmInterfaceType.pv)) {
        return VmInterfaceType.pv;
    } else {
        return items.iterator().next();
    }
}
#end_block

#method_before
public static void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = (ArrayList<String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#method_after
public static void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#end_block

#method_before
public static String getNewNicName(List<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#method_after
public static String getNewNicName(Collection<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#end_block

#method_before
public static void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = (HashMap<Integer, String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependecyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#method_after
public static void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependecyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#end_block

#method_before
public static void initOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osNames = (HashMap<Integer, String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            initOsIds();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), callback);
}
#method_after
public static void initOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            initOsIds();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), callback);
}
#end_block

#method_before
public static void initOsArchitecture() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osArchitectures = (HashMap<Integer, ArchitectureType>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsArchitectures), callback);
}
#method_after
public static void initOsArchitecture() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osArchitectures = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsArchitectures), callback);
}
#end_block

#method_before
public static ArrayList<Map.Entry<String, EntityModel>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel>> list = new ArrayList<Map.Entry<String, EntityModel>>();
    EntityModel entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=2 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel>("mode=4 miimon=100", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=5 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("custom", entityModel));
    return list;
}
#method_after
public static ArrayList<Map.Entry<String, EntityModel<String>>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel<String>>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel<String>>> list = new ArrayList<Map.Entry<String, EntityModel<String>>>();
    EntityModel<String> entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=2 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel<String>>("mode=4 miimon=100", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=5 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("custom", entityModel));
    return list;
}
#end_block

#method_before
public static List<IStorageModel> getDataStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    NfsStorageModel nfsDataModel = new NfsStorageModel();
    models.add(nfsDataModel);
    PosixStorageModel posixDataModel = new PosixStorageModel();
    models.add(posixDataModel);
    GlusterStorageModel GlusterDataModel = new GlusterStorageModel();
    models.add(GlusterDataModel);
    IscsiStorageModel iscsiDataModel = new IscsiStorageModel();
    iscsiDataModel.setIsGrouppedByTarget(true);
    models.add(iscsiDataModel);
    FcpStorageModel fcpDataModel = new FcpStorageModel();
    models.add(fcpDataModel);
    LocalStorageModel localDataModel = new LocalStorageModel();
    models.add(localDataModel);
    for (IStorageModel model : models) {
        model.setRole(StorageDomainType.Data);
    }
    return models;
}
#method_after
public static List<IStorageModel> getDataStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    models.addAll(getFileDataStorageModels());
    models.addAll(getBlockDataStorageModels());
    return models;
}
#end_block

#method_before
public static List<IStorageModel> getIsoStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    LocalStorageModel localIsoModel = new LocalStorageModel();
    models.add(localIsoModel);
    PosixStorageModel posixIsoModel = new PosixStorageModel();
    models.add(posixIsoModel);
    NfsStorageModel nfsIsoModel = new NfsStorageModel();
    models.add(nfsIsoModel);
    for (IStorageModel model : models) {
        model.setRole(StorageDomainType.ISO);
    }
    return models;
}
#method_after
public static List<IStorageModel> getIsoStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    NfsStorageModel nfsIsoModel = new NfsStorageModel();
    models.add(nfsIsoModel);
    PosixStorageModel posixIsoModel = new PosixStorageModel();
    models.add(posixIsoModel);
    LocalStorageModel localIsoModel = new LocalStorageModel();
    models.add(localIsoModel);
    addTypeToStorageModels(StorageDomainType.ISO, models);
    return models;
}
#end_block

#method_before
protected void updateDefaultDisplayRelatedFields(VmBase vmBase) {
    // Update display protocol selected item
    if (model.getDisplayProtocol().getItems() == null) {
        return;
    }
    EntityModel<DisplayType> displayProtocol = null;
    boolean isFirst = true;
    for (EntityModel<DisplayType> item : model.getDisplayProtocol().getItems()) {
        if (isFirst) {
            displayProtocol = item;
            isFirst = false;
        }
        DisplayType dt = item.getEntity();
        if (dt == vmBase.getDefaultDisplayType()) {
            displayProtocol = item;
            break;
        }
    }
    maybeSetSelectedItem(model.getDisplayProtocol(), displayProtocol);
    maybeSetSelectedItem(model.getNumOfMonitors(), vmBase.getNumOfMonitors());
    maybeSetSelectedItem(model.getUsbPolicy(), vmBase.getUsbPolicy());
    maybeSetEntity(model.getIsSmartcardEnabled(), vmBase.isSmartcardEnabled());
    maybeSetEntity(model.getIsSingleQxlEnabled(), vmBase.getSingleQxlPci());
}
#method_after
protected void updateDefaultDisplayRelatedFields(VmBase vmBase) {
    // Update display protocol selected item
    if (model.getDisplayProtocol().getItems() == null) {
        return;
    }
    EntityModel<DisplayType> displayProtocol = null;
    boolean isFirst = true;
    for (EntityModel<DisplayType> item : model.getDisplayProtocol().getItems()) {
        if (isFirst) {
            displayProtocol = item;
            isFirst = false;
        }
        DisplayType dt = item.getEntity();
        if (dt == vmBase.getDefaultDisplayType()) {
            displayProtocol = item;
            break;
        }
    }
    maybeSetSelectedItem(model.getDisplayProtocol(), displayProtocol);
    maybeSetSelectedItem(model.getNumOfMonitors(), vmBase.getNumOfMonitors());
    maybeSetSelectedItem(model.getUsbPolicy(), vmBase.getUsbPolicy());
    maybeSetEntity(model.getIsSmartcardEnabled(), vmBase.isSmartcardEnabled());
    maybeSetSingleQxlPci(vmBase);
}
#end_block

#method_before
protected <T> void maybeSetSelectedItem(ListModel<T> listModel, T value) {
    if (listModel != null && listModel.getIsChangable() && listModel.getIsAvailable()) {
        listModel.setSelectedItem(value);
    }
}
#method_after
protected <T> void maybeSetSelectedItem(ListModel<T> entityModel, T value) {
    if (alwaysEnabledFieldUpdate || (entityModel != null && entityModel.getIsChangable() && entityModel.getIsAvailable())) {
        entityModel.setSelectedItem(value);
    }
}
#end_block

#method_before
protected <T> void maybeSetEntity(EntityModel<T> listModel, T value) {
    if (listModel != null && listModel.getIsChangable() && listModel.getIsAvailable()) {
        listModel.setEntity(value);
    }
}
#method_after
protected <T> void maybeSetEntity(EntityModel<T> listModel, T value) {
    if (alwaysEnabledFieldUpdate || (listModel != null && listModel.getIsChangable() && listModel.getIsAvailable())) {
        listModel.setEntity(value);
    }
}
#end_block

#method_before
private void handleQxlClusterLevel() {
    boolean isQxl = getDisplayType() == DisplayType.qxl;
    getBehavior().enableSinglePCI(getDefalutQxlValue());
    if (getSelectedCluster() != null) {
        boolean spiceFileTransferToggle = isQxl && AsyncDataProvider.isSpiceFileTransferToggleSupported(getSelectedCluster().getcompatibility_version().toString());
        if (!spiceFileTransferToggle) {
            handleQxlChangeProhibitionReason(getSpiceFileTransferEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
        }
        getSpiceFileTransferEnabled().setIsChangable(spiceFileTransferToggle);
        boolean spiceCopyPasteToggle = isQxl && AsyncDataProvider.isSpiceCopyPasteToggleSupported(getSelectedCluster().getcompatibility_version().toString());
        if (!spiceCopyPasteToggle) {
            handleQxlChangeProhibitionReason(getSpiceCopyPasteEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
        }
        getSpiceCopyPasteEnabled().setIsChangable(spiceCopyPasteToggle);
    }
}
#method_after
private void handleQxlClusterLevel() {
    getBehavior().enableSinglePCI(getIsQxlSupported());
    if (getSelectedCluster() != null) {
        boolean isQxl = getDisplayType() == DisplayType.qxl;
        boolean spiceFileTransferToggle = isQxl && AsyncDataProvider.isSpiceFileTransferToggleSupported(getSelectedCluster().getcompatibility_version().toString());
        if (!spiceFileTransferToggle) {
            handleQxlChangeProhibitionReason(getSpiceFileTransferEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
        }
        getSpiceFileTransferEnabled().setIsChangable(spiceFileTransferToggle);
        boolean spiceCopyPasteToggle = isQxl && AsyncDataProvider.isSpiceCopyPasteToggleSupported(getSelectedCluster().getcompatibility_version().toString());
        if (!spiceCopyPasteToggle) {
            handleQxlChangeProhibitionReason(getSpiceCopyPasteEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
        }
        getSpiceCopyPasteEnabled().setIsChangable(spiceCopyPasteToggle);
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("invokeCallbackMethods")
public synchronized void invokeCallbackMethods() {
    initCommandExecutor();
    for (Iterator<Entry<Guid, CommandCallBack>> iterator = cmdCallBackMap.entrySet().iterator(); iterator.hasNext(); ) {
        Entry<Guid, CommandCallBack> entry = iterator.next();
        Guid cmdId = entry.getKey();
        CommandCallBack callBack = entry.getValue();
        CommandStatus status = coco.getCommandStatus(cmdId);
        switch(status) {
            case FAILED:
                callBack.onFailed(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case SUCCEEDED:
                callBack.onSucceeded(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case ACTIVE_SYNC:
                coco.retrieveCommand(cmdId).setCommandStatus(CommandStatus.FAILED_RESTARTED);
                break;
            case ACTIVE:
            case ACTIVE_ASYNC:
                callBack.doPolling(cmdId, coco.getChildCommandIds(cmdId));
                break;
            default:
                break;
        }
    }
}
#method_after
@OnTimerMethodAnnotation("invokeCallbackMethods")
public void invokeCallbackMethods() {
    initCommandExecutor();
    for (Iterator<Entry<Guid, CommandCallBack>> iterator = cmdCallBackMap.entrySet().iterator(); iterator.hasNext(); ) {
        Entry<Guid, CommandCallBack> entry = iterator.next();
        Guid cmdId = entry.getKey();
        CommandCallBack callBack = entry.getValue();
        CommandStatus status = coco.getCommandStatus(cmdId);
        switch(status) {
            case FAILED:
                callBack.onFailed(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case SUCCEEDED:
                callBack.onSucceeded(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case ACTIVE_SYNC:
                coco.retrieveCommand(cmdId).setCommandStatus(CommandStatus.FAILED_RESTARTED);
                break;
            case ACTIVE:
            case ACTIVE_ASYNC:
                callBack.doPolling(cmdId, coco.getChildCommandIds(cmdId));
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
private void initCommandExecutor() {
    if (!cmdExecutorInitialized) {
        synchronized (LOCK) {
            if (!cmdExecutorInitialized) {
                for (CommandEntity cmdEntity : coco.getCommandsWithCallBackEnabled()) {
                    if (!cmdEntity.isCallBackNotified()) {
                        addToCallBackMap(cmdEntity);
                    }
                }
                cmdExecutorInitialized = true;
            }
        }
    }
}
#method_after
private void initCommandExecutor() {
    if (!cmdExecutorInitialized) {
        for (CommandEntity cmdEntity : coco.getCommandsWithCallBackEnabled()) {
            if (!cmdEntity.isCallBackNotified()) {
                addToCallBackMap(cmdEntity);
            }
        }
        cmdExecutorInitialized = true;
    }
}
#end_block

#method_before
public void proceedCommandExecution() {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE);
        getParameters().setChildCommands(new HashMap<RemoveSnapshotSingleDiskLiveStep, Guid>());
    }
    List<Guid> childCommandIds = TaskManagerUtil.getChildCommandIds(getCommandId());
    if (childCommandIds.size() != getParameters().getChildCommands().size()) {
        // Upon recovery or after invoking a new child command, our map may be missing an entry
        for (Guid id : childCommandIds) {
            if (!getParameters().getChildCommands().containsValue(id)) {
                getParameters().getChildCommands().put(getParameters().getCommandStep(), id);
                break;
            }
        }
    }
    Guid currentChildId = getParameters().getChildCommands().get(getParameters().getCommandStep());
    VdcReturnValueBase vdcReturnValue = null;
    if (currentChildId != null) {
        switch(TaskManagerUtil.getCommandStatus(currentChildId)) {
            case ACTIVE:
            case ACTIVE_ASYNC:
            case ACTIVE_SYNC:
            case NOT_STARTED:
                log.infoFormat("Waiting on Live Merge command step {0} to complete", getParameters().getCommandStep());
                return;
            case SUCCEEDED:
                vdcReturnValue = TaskManagerUtil.getCommandReturnValue(currentChildId);
                if (vdcReturnValue != null && vdcReturnValue.getSucceeded()) {
                    getParameters().setCommandStep(getParameters().getNextCommandStep());
                    break;
                } else {
                    log.errorFormat("Failed to merge, child command {0} failed: {1}", getParameters().getCommandStep(), (vdcReturnValue != null ? vdcReturnValue.getExecuteFailedMessages() : "null return value"));
                    setCommandStatus(CommandStatus.FAILED);
                    return;
                }
            case FAILED:
            case FAILED_RESTARTED:
                log.errorFormat("Failed to merge: failed child command status for step {0}", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
            case UNKNOWN:
                log.errorFormat("Failed to merge: unknown child command status for step {0}", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
        }
    }
    log.infoFormat("Executing Live Merge command step {0}", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<>(VdcActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            getParameters().setMergeStatusReturnValue((MergeStatusReturnValue) vdcReturnValue.getActionReturnValue());
            nextCommand = new Pair<>(VdcActionType.DestroyImage, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        TaskManagerUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), getContext());
    }
}
#method_after
public void proceedCommandExecution() {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE);
        getParameters().setChildCommands(new HashMap<RemoveSnapshotSingleDiskLiveStep, Guid>());
    }
    List<Guid> childCommandIds = TaskManagerUtil.getChildCommandIds(getCommandId());
    if (childCommandIds.size() != getParameters().getChildCommands().size()) {
        // Upon recovery or after invoking a new child command, our map may be missing an entry
        for (Guid id : childCommandIds) {
            if (!getParameters().getChildCommands().containsValue(id)) {
                getParameters().getChildCommands().put(getParameters().getCommandStep(), id);
                break;
            }
        }
    }
    Guid currentChildId = getParameters().getChildCommands().get(getParameters().getCommandStep());
    VdcReturnValueBase vdcReturnValue = null;
    if (currentChildId != null) {
        switch(TaskManagerUtil.getCommandStatus(currentChildId)) {
            case ACTIVE:
            case ACTIVE_ASYNC:
            case ACTIVE_SYNC:
            case NOT_STARTED:
                log.infoFormat("Waiting on Live Merge command step {0} to complete", getParameters().getCommandStep());
                return;
            case SUCCEEDED:
                vdcReturnValue = TaskManagerUtil.getCommandReturnValue(currentChildId);
                if (vdcReturnValue != null && vdcReturnValue.getSucceeded()) {
                    getParameters().setCommandStep(getParameters().getNextCommandStep());
                    break;
                } else {
                    log.errorFormat("Failed to merge, child command {0} failed: {1}", getParameters().getCommandStep(), (vdcReturnValue != null ? vdcReturnValue.getExecuteFailedMessages() : "null return value"));
                    setCommandStatus(CommandStatus.FAILED);
                    return;
                }
            case FAILED:
            case FAILED_RESTARTED:
                log.errorFormat("Failed to merge: failed child command status for step {0}", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
            case UNKNOWN:
                log.errorFormat("Failed to merge: unknown child command status for step {0}", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
        }
    }
    log.infoFormat("Executing Live Merge command step {0}", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<>(VdcActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            getParameters().setMergeStatusReturnValue((MergeStatusReturnValue) vdcReturnValue.getActionReturnValue());
            nextCommand = new Pair<>(VdcActionType.DestroyImage, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        TaskManagerUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
    }
}
#end_block

#method_before
private void removeImages() {
    for (final DiskImage source : getSourceImages()) {
        // The following line is ok because we have tested in the candoaction that the vm
        // is not a template and the vm is not in preview mode and that
        // this is not the active snapshot.
        DiskImage dest = getDiskImageDao().getAllSnapshotsForParent(source.getImageId()).get(0);
        if (getSnapshotActionType() == VdcActionType.RemoveSnapshotSingleDisk) {
            VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(getSnapshotActionType(), buildRemoveSnapshotSingleDiskParameters(source, dest));
            if (vdcReturnValue != null && vdcReturnValue.getInternalVdsmTaskIdList() != null) {
                getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
            }
        } else {
            TaskManagerUtil.executeAsyncCommand(getSnapshotActionType(), buildRemoveSnapshotSingleDiskParameters(source, dest), getContext());
        }
        List<Guid> quotasToRemoveFromCache = new ArrayList<Guid>();
        quotasToRemoveFromCache.add(source.getQuotaId());
        quotasToRemoveFromCache.add(dest.getQuotaId());
        QuotaManager.getInstance().removeQuotaFromCache(getStoragePoolId(), quotasToRemoveFromCache);
    }
}
#method_after
private void removeImages() {
    for (final DiskImage source : getSourceImages()) {
        // The following line is ok because we have tested in the candoaction that the vm
        // is not a template and the vm is not in preview mode and that
        // this is not the active snapshot.
        DiskImage dest = getDiskImageDao().getAllSnapshotsForParent(source.getImageId()).get(0);
        if (getSnapshotActionType() == VdcActionType.RemoveSnapshotSingleDisk) {
            VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(getSnapshotActionType(), buildRemoveSnapshotSingleDiskParameters(source, dest));
            if (vdcReturnValue != null && vdcReturnValue.getInternalVdsmTaskIdList() != null) {
                getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
            }
        } else {
            TaskManagerUtil.executeAsyncCommand(getSnapshotActionType(), buildRemoveSnapshotSingleDiskParameters(source, dest), cloneContextAndDetachFromParent());
        }
        List<Guid> quotasToRemoveFromCache = new ArrayList<Guid>();
        quotasToRemoveFromCache.add(source.getQuotaId());
        quotasToRemoveFromCache.add(dest.getQuotaId());
        QuotaManager.getInstance().removeQuotaFromCache(getStoragePoolId(), quotasToRemoveFromCache);
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("invokeCallbackMethods")
public synchronized void invokeCallbackMethods() {
    initCommandExecutor();
    for (Iterator<Entry<Guid, CommandCallBack>> iterator = cmdCallBackMap.entrySet().iterator(); iterator.hasNext(); ) {
        Entry<Guid, CommandCallBack> entry = iterator.next();
        Guid cmdId = entry.getKey();
        CommandCallBack callBack = entry.getValue();
        CommandStatus status = coco.getCommandStatus(cmdId);
        switch(status) {
            case FAILED:
                callBack.onFailed(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case SUCCEEDED:
                callBack.onSucceeded(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case ACTIVE_SYNC:
                coco.retrieveCommand(cmdId).setCommandStatus(CommandStatus.FAILED_RESTARTED);
                break;
            case ACTIVE:
            case ACTIVE_ASYNC:
                callBack.doPolling(cmdId, coco.getChildCommandIds(cmdId));
                break;
            default:
                break;
        }
    }
}
#method_after
@OnTimerMethodAnnotation("invokeCallbackMethods")
public void invokeCallbackMethods() {
    initCommandExecutor();
    for (Iterator<Entry<Guid, CommandCallBack>> iterator = cmdCallBackMap.entrySet().iterator(); iterator.hasNext(); ) {
        Entry<Guid, CommandCallBack> entry = iterator.next();
        Guid cmdId = entry.getKey();
        CommandCallBack callBack = entry.getValue();
        CommandStatus status = coco.getCommandStatus(cmdId);
        switch(status) {
            case FAILED:
                callBack.onFailed(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case SUCCEEDED:
                callBack.onSucceeded(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case ACTIVE_SYNC:
                coco.retrieveCommand(cmdId).setCommandStatus(CommandStatus.FAILED_RESTARTED);
                break;
            case ACTIVE:
            case ACTIVE_ASYNC:
                callBack.doPolling(cmdId, coco.getChildCommandIds(cmdId));
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
private void initCommandExecutor() {
    if (!cmdExecutorInitialized) {
        synchronized (LOCK) {
            if (!cmdExecutorInitialized) {
                for (CommandEntity cmdEntity : coco.getCommandsWithCallBackEnabled()) {
                    if (!cmdEntity.isCallBackNotified()) {
                        addToCallBackMap(cmdEntity);
                    }
                }
                cmdExecutorInitialized = true;
            }
        }
    }
}
#method_after
private void initCommandExecutor() {
    if (!cmdExecutorInitialized) {
        for (CommandEntity cmdEntity : coco.getCommandsWithCallBackEnabled()) {
            if (!cmdEntity.isCallBackNotified()) {
                addToCallBackMap(cmdEntity);
            }
        }
        cmdExecutorInitialized = true;
    }
}
#end_block

#method_before
public Future<VdcReturnValueBase> executeAsyncCommand(final VdcActionType actionType, final VdcActionParametersBase parameters, final CommandContext cmdContext) {
    final CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters, cmdContext);
    coco.persistCommandContext(command.getCommandId(), cmdContext);
    return executor.submit(new Callable<VdcReturnValueBase>() {

        @Override
        public VdcReturnValueBase call() throws Exception {
            return executeCommand(command, cmdContext);
        }
    });
}
#method_after
public Future<VdcReturnValueBase> executeAsyncCommand(final VdcActionType actionType, final VdcActionParametersBase parameters, final CommandContext cmdContext) {
    final CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters, cmdContext);
    coco.saveCommandContext(command.getCommandId(), cmdContext);
    return executor.submit(new Callable<VdcReturnValueBase>() {

        @Override
        public VdcReturnValueBase call() throws Exception {
            return executeCommand(command, cmdContext);
        }
    });
}
#end_block

#method_before
@Override
public void persistCommand(CommandEntity cmdEntity, CommandContext cmdContext) {
    persistCommand(cmdEntity);
    persistCommandContext(cmdEntity.getId(), cmdContext);
}
#method_after
@Override
public void persistCommand(CommandEntity cmdEntity, CommandContext cmdContext) {
    persistCommand(cmdEntity);
    saveCommandContext(cmdEntity.getId(), cmdContext);
}
#end_block

#method_before
public void removeCommand(final Guid commandId) {
    commandsCache.remove(commandId);
    updateCmdHierarchy(commandId);
}
#method_after
public void removeCommand(final Guid commandId) {
    commandsCache.remove(commandId);
    contextsCache.remove(commandId);
    updateCmdHierarchy(commandId);
}
#end_block

#method_before
public void engineInitialize() {
    createInternalAAAConfigurations();
    createKerberosLdapAAAConfigurations();
    for (File directory : EngineLocalConfig.getInstance().getExtensionsDirectories()) {
        if (!directory.exists()) {
            log.warn("The directory '{}' cotaning configuration files does not exist.", directory.getAbsolutePath());
        } else {
            // The order of the files inside the directory is relevant, as the objects are created in
            // the same order
            // that
            // the files are processed, so it is better to sort them so that objects will always be
            // created in the
            // same
            // order regardless of how the filesystem decides to store the entries of the directory:
            File[] files = directory.listFiles();
            if (files != null) {
                sort(files);
                for (File file : files) {
                    if (file.getName().endsWith(".properties")) {
                        try {
                            load(file);
                        } catch (Exception ex) {
                            log.error("Could not load extension based on configuration file '{}'. Please check the configuration file is valid.", file.getAbsolutePath());
                        }
                    }
                }
            }
        }
    }
    for (ExtensionProxy extension : getLoadedExtensions()) {
        if (EngineLocalConfig.getInstance().getBoolean((ENGINE_EXTENSION_ENABLED + extension.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME)), Boolean.parseBoolean(extension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(Base.ConfigKeys.ENABLED, "true")))) {
            initialize(extension.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME));
        }
    }
    dump();
}
#method_after
public void engineInitialize() {
    createInternalAAAConfigurations();
    createKerberosLdapAAAConfigurations();
    for (File directory : EngineLocalConfig.getInstance().getExtensionsDirectories()) {
        if (!directory.exists()) {
            log.warn("The directory '{}' cotaning configuration files does not exist.", directory.getAbsolutePath());
        } else {
            // The order of the files inside the directory is relevant, as the objects are created in
            // the same order
            // that
            // the files are processed, so it is better to sort them so that objects will always be
            // created in the
            // same
            // order regardless of how the filesystem decides to store the entries of the directory:
            File[] files = directory.listFiles();
            if (files != null) {
                sort(files);
                for (File file : files) {
                    if (file.getName().endsWith(".properties")) {
                        try {
                            load(file);
                        } catch (Exception ex) {
                            log.error("Could not load extension based on configuration file '{}'. Please check the configuration file is valid. Exception message is: {}", file.getAbsolutePath(), ex.getMessage());
                            log.debug("", ex);
                        }
                    }
                }
            }
        }
    }
    for (ExtensionProxy extension : getLoadedExtensions()) {
        if (EngineLocalConfig.getInstance().getBoolean((ENGINE_EXTENSION_ENABLED + extension.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME)), Boolean.parseBoolean(extension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(Base.ConfigKeys.ENABLED, "true")))) {
            initialize(extension.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME));
        }
    }
    dump();
}
#end_block

#method_before
public EntityModel<Integer> getMtu() {
    return privateMtu;
}
#method_after
public EntityModel<Integer> getMtu() {
    return mtu;
}
#end_block

#method_before
private void setMtu(EntityModel<Integer> value) {
    privateMtu = value;
}
#method_after
private void setMtu(EntityModel<Integer> value) {
    mtu = value;
}
#end_block

#method_before
public void setMTUOverrideSupported(boolean mtuOverrideSupported) {
    if (!mtuOverrideSupported) {
        getHasMtu().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().mtuOverrideNotSupported(getSelectedDc().getcompatibility_version().toString()));
        getHasMtu().setIsChangable(false);
        getHasMtu().setEntity(false);
    } else {
        if (this.mtuOverrideSupported != mtuOverrideSupported) {
            initMtu();
        }
        getHasMtu().setIsChangable(true);
    }
    this.mtuOverrideSupported = mtuOverrideSupported;
}
#method_after
public void setMTUOverrideSupported(boolean mtuOverrideSupported) {
    this.mtuOverrideSupported = mtuOverrideSupported;
    updateMtuSelectorsChangeability();
}
#end_block

#method_before
public boolean validate() {
    RegexValidation tempVar = new RegexValidation();
    // $NON-NLS-1$
    tempVar.setExpression("^[A-Za-z0-9_]{1,15}$");
    tempVar.setMessage(ConstantsManager.getInstance().getConstants().nameMustContainAlphanumericMaxLenMsg());
    RegexValidation tempVar2 = new RegexValidation();
    tempVar2.setIsNegate(true);
    // $NON-NLS-1$
    tempVar2.setExpression("^(bond)");
    tempVar2.setMessage(ConstantsManager.getInstance().getConstants().networkNameStartMsg());
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar, tempVar2 });
    LengthValidation tempVar3 = new LengthValidation();
    tempVar3.setMaxLength(40);
    getDescription().validateEntity(new IValidation[] { tempVar3 });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getVLanTag().setIsValid(true);
    if (getHasVLanTag().getEntity()) {
        IntegerValidation tempVar4 = new IntegerValidation();
        tempVar4.setMinimum(0);
        tempVar4.setMaximum(4094);
        getVLanTag().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar4 });
    }
    getMtu().setIsValid(true);
    if (getHasMtu().getEntity()) {
        IntegerValidation tempVar5 = new IntegerValidation();
        tempVar5.setMinimum(68);
        getMtu().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar5 });
    }
    getExternalProviders().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    boolean subnetValid = true;
    if ((Boolean) getExport().getEntity() && (Boolean) getCreateSubnet().getEntity()) {
        subnetValid = getSubnetModel().validate();
    }
    boolean profilesValid = true;
    Iterable<VnicProfileModel> profiles = getProfiles().getItems();
    for (VnicProfileModel profileModel : profiles) {
        if (!profileModel.validate()) {
            profilesValid = false;
        }
    }
    getNetworkLabel().validateSelectedItem(new IValidation[] { new AsciiNameValidation() });
    return getName().getIsValid() && getVLanTag().getIsValid() && getDescription().getIsValid() && getMtu().getIsValid() && getExternalProviders().getIsValid() && getComment().getIsValid() && subnetValid && profilesValid && getNetworkLabel().getIsValid();
}
#method_after
public boolean validate() {
    RegexValidation tempVar = new RegexValidation();
    // $NON-NLS-1$
    tempVar.setExpression("^[A-Za-z0-9_]{1,15}$");
    tempVar.setMessage(ConstantsManager.getInstance().getConstants().nameMustContainAlphanumericMaxLenMsg());
    RegexValidation tempVar2 = new RegexValidation();
    tempVar2.setIsNegate(true);
    // $NON-NLS-1$
    tempVar2.setExpression("^(bond)");
    tempVar2.setMessage(ConstantsManager.getInstance().getConstants().networkNameStartMsg());
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar, tempVar2 });
    LengthValidation tempVar3 = new LengthValidation();
    tempVar3.setMaxLength(40);
    getDescription().validateEntity(new IValidation[] { tempVar3 });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getVLanTag().setIsValid(true);
    if (getHasVLanTag().getEntity()) {
        IntegerValidation tempVar4 = new IntegerValidation();
        tempVar4.setMinimum(0);
        tempVar4.setMaximum(4094);
        getVLanTag().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar4 });
    }
    IntegerValidation tempVar5 = new IntegerValidation();
    tempVar5.setMinimum(68);
    getMtu().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar5 });
    getExternalProviders().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    boolean subnetValid = true;
    if ((Boolean) getExport().getEntity() && (Boolean) getCreateSubnet().getEntity()) {
        subnetValid = getSubnetModel().validate();
    }
    boolean profilesValid = true;
    Iterable<VnicProfileModel> profiles = getProfiles().getItems();
    for (VnicProfileModel profileModel : profiles) {
        if (!profileModel.validate()) {
            profilesValid = false;
        }
    }
    getNetworkLabel().validateSelectedItem(new IValidation[] { new AsciiNameValidation() });
    return getName().getIsValid() && getVLanTag().getIsValid() && getDescription().getIsValid() && getMtu().getIsValid() && getExternalProviders().getIsValid() && getComment().getIsValid() && subnetValid && profilesValid && getNetworkLabel().getIsValid();
}
#end_block

#method_before
public void flush() {
    network.setDataCenterId(getSelectedDc().getId());
    network.setName(getName().getEntity());
    network.setStp(getIsStpEnabled().getEntity());
    network.setDescription(getDescription().getEntity());
    network.setComment(getComment().getEntity());
    network.setVmNetwork(getIsVmNetwork().getEntity());
    String label = getNetworkLabel().getSelectedItem();
    network.setLabel(label == null || !label.isEmpty() ? label : null);
    network.setMtu(0);
    if (getHasMtu().getEntity()) {
        network.setMtu(Integer.parseInt(getMtu().getEntity().toString()));
    }
    network.setVlanId(null);
    if (getHasVLanTag().getEntity()) {
        network.setVlanId(Integer.parseInt(getVLanTag().getEntity().toString()));
    }
    for (VnicProfileModel profileModel : getProfiles().getItems()) {
        profileModel.flush();
    }
    if (getQos().getIsChangable()) {
        NetworkQoS qos = getQos().getSelectedItem();
        network.setQosId(qos == NetworkQoSModel.EMPTY_QOS ? null : qos.getId());
    }
}
#method_after
public void flush() {
    network.setDataCenterId(getSelectedDc().getId());
    network.setName(getName().getEntity());
    network.setStp(getIsStpEnabled().getEntity());
    network.setDescription(getDescription().getEntity());
    network.setComment(getComment().getEntity());
    network.setVmNetwork(getIsVmNetwork().getEntity());
    String label = getNetworkLabel().getSelectedItem();
    network.setLabel(label == null || !label.isEmpty() ? label : null);
    network.setMtu(0);
    if (getMtu().getIsChangable()) {
        network.setMtu(Integer.parseInt(getMtu().getEntity().toString()));
    }
    network.setVlanId(null);
    if (getHasVLanTag().getEntity()) {
        network.setVlanId(Integer.parseInt(getVLanTag().getEntity().toString()));
    }
    for (VnicProfileModel profileModel : getProfiles().getItems()) {
        profileModel.flush();
    }
    if (getQos().getIsChangable()) {
        NetworkQoS qos = getQos().getSelectedItem();
        network.setQosId(qos == NetworkQoSModel.EMPTY_QOS ? null : qos.getId());
    }
}
#end_block

#method_before
protected void onExportChanged() {
    boolean externalNetwork = getExport().getEntity();
    getQos().setIsChangable(!externalNetwork);
    getAddQosCommand().setIsExecutionAllowed(!externalNetwork);
    String label = getNetworkLabel().getSelectedItem();
    getNetworkLabel().setItems(externalNetwork ? new HashSet<String>() : dcLabels);
    getNetworkLabel().setSelectedItem(label);
}
#method_after
protected void onExportChanged() {
    boolean externalNetwork = getExport().getEntity();
    getQos().setIsChangable(!externalNetwork);
    getAddQosCommand().setIsExecutionAllowed(!externalNetwork);
    String label = getNetworkLabel().getSelectedItem();
    getNetworkLabel().setItems(externalNetwork ? new HashSet<String>() : dcLabels);
    getNetworkLabel().setSelectedItem(label);
    updateMtuSelectorsChangeability();
}
#end_block

#method_before
private void init() {
    setTitle(ConstantsManager.getInstance().getConstants().editLogicalNetworkTitle());
    setHelpTag(HelpTag.edit_logical_network);
    // $NON-NLS-1$
    setHashName("edit_logical_network");
    getName().setEntity(getNetwork().getName());
    if (isManagemet()) {
        getName().setIsChangable(false);
    }
    getDescription().setEntity(getNetwork().getDescription());
    getComment().setEntity(getNetwork().getComment());
    getIsStpEnabled().setEntity(getNetwork().getStp());
    getHasVLanTag().setEntity(getNetwork().getVlanId() != null);
    getVLanTag().setEntity((getNetwork().getVlanId() == null ? Integer.valueOf(0) : getNetwork().getVlanId()));
    initIsVm();
    getExport().setEntity(getNetwork().isExternal());
    getExport().setIsChangable(false);
    initMtu();
    getExternalProviders().setIsChangable(false);
    getNetworkLabel().setSelectedItem(getNetwork().getLabel());
    toggleProfilesAvailability();
}
#method_after
private void init() {
    setTitle(ConstantsManager.getInstance().getConstants().editLogicalNetworkTitle());
    setHelpTag(HelpTag.edit_logical_network);
    // $NON-NLS-1$
    setHashName("edit_logical_network");
    getName().setEntity(getNetwork().getName());
    if (isManagemet()) {
        getName().setIsChangable(false);
    }
    getDescription().setEntity(getNetwork().getDescription());
    getComment().setEntity(getNetwork().getComment());
    getIsStpEnabled().setEntity(getNetwork().getStp());
    getHasVLanTag().setEntity(getNetwork().getVlanId() != null);
    getVLanTag().setEntity((getNetwork().getVlanId() == null ? Integer.valueOf(0) : getNetwork().getVlanId()));
    initMtu();
    initIsVm();
    getExport().setEntity(getNetwork().isExternal());
    getExport().setIsChangable(false);
    getExternalProviders().setIsChangable(false);
    getNetworkLabel().setSelectedItem(getNetwork().getLabel());
    toggleProfilesAvailability();
}
#end_block

#method_before
@Override
protected void initMtu() {
    getHasMtu().setEntity(getNetwork().getMtu() != 0);
    if (getHasMtu().getEntity()) {
        getMtu().setEntity(getNetwork().getMtu());
    }
}
#method_after
@Override
protected void initMtu() {
    boolean isCustomMtu = getNetwork().getMtu() != 0;
    getMtuSelector().setSelectedItem(isCustomMtu ? MtuSelector.customMtu : MtuSelector.defaultMtu);
    getMtu().setEntity(isCustomMtu() ? getNetwork().getMtu() : null);
}
#end_block

#method_before
@Override
protected void onExportChanged() {
    if (getExport().getEntity()) {
        getHasVLanTag().setIsChangable(false);
        getVLanTag().setIsChangable(false);
        getIsVmNetwork().setIsChangable(false);
        getHasMtu().setIsChangable(false);
        getMtu().setIsChangable(false);
        getNetworkLabel().setIsChangable(false);
    }
    super.onExportChanged();
}
#method_after
@Override
protected void onExportChanged() {
    if (getExport().getEntity()) {
        getHasVLanTag().setIsChangable(false);
        getVLanTag().setIsChangable(false);
        getIsVmNetwork().setIsChangable(false);
        getNetworkLabel().setIsChangable(false);
    }
    super.onExportChanged();
}
#end_block

#method_before
private void init() {
    setTitle(ConstantsManager.getInstance().getConstants().newLogicalNetworkTitle());
    setHelpTag(HelpTag.new_logical_network);
    // $NON-NLS-1$
    setHashName("new_logical_network");
}
#method_after
private void init() {
    setTitle(ConstantsManager.getInstance().getConstants().newLogicalNetworkTitle());
    setHelpTag(HelpTag.new_logical_network);
    // $NON-NLS-1$
    setHashName("new_logical_network");
    initMtu();
}
#end_block

#method_before
@Override
protected void initMtu() {
    getHasMtu().setEntity(false);
}
#method_after
@Override
protected void initMtu() {
    getMtuSelector().setSelectedItem(MtuSelector.defaultMtu);
    getMtu().setEntity(null);
}
#end_block

#method_before
@Override
protected void onExportChanged() {
    boolean externalNetwork = (Boolean) getExport().getEntity();
    getExternalProviders().setIsChangable(externalNetwork);
    getIsVmNetwork().setIsChangable(!externalNetwork && isSupportBridgesReportByVDSM());
    getHasMtu().setIsChangable(!externalNetwork && isMTUOverrideSupported());
    if (externalNetwork) {
        getIsVmNetwork().setEntity(true);
        getHasMtu().setEntity(false);
    }
    Iterable<NetworkClusterModel> networkClusters = getNetworkClusterList().getItems();
    if (networkClusters != null) {
        for (NetworkClusterModel networkCluster : networkClusters) {
            if (!(Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.SupportCustomDeviceProperties, networkCluster.getEntity().getcompatibility_version().getValue())) {
                networkCluster.setIsChangable(!externalNetwork);
                networkCluster.setAttached(!externalNetwork);
            }
            networkCluster.setRequired(!externalNetwork);
        }
    }
    super.onExportChanged();
}
#method_after
@Override
protected void onExportChanged() {
    boolean externalNetwork = (Boolean) getExport().getEntity();
    getExternalProviders().setIsChangable(externalNetwork);
    getIsVmNetwork().setIsChangable(!externalNetwork && isSupportBridgesReportByVDSM());
    if (externalNetwork) {
        getIsVmNetwork().setEntity(true);
    }
    Iterable<NetworkClusterModel> networkClusters = getNetworkClusterList().getItems();
    if (networkClusters != null) {
        for (NetworkClusterModel networkCluster : networkClusters) {
            if (!(Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.SupportCustomDeviceProperties, networkCluster.getEntity().getcompatibility_version().getValue())) {
                networkCluster.setIsChangable(!externalNetwork);
                networkCluster.setAttached(!externalNetwork);
            }
            networkCluster.setRequired(!externalNetwork);
        }
    }
    super.onExportChanged();
}
#end_block

#method_before
@Override
public String render(Integer mtu) {
    return mtu == null || mtu == 0 ? messages.defaultMtu(defaultMtu) : mtu.toString();
}
#method_after
@Override
public String render(Integer mtu) {
    return mtu == 0 ? messages.defaultMtu(defaultMtu) : mtu.toString();
}
#end_block

#method_before
@Override
protected Map<VmTemplate, List<DiskImage>> buildFromOVFs(List<String> ovfList) {
    OvfManager ovfManager = new OvfManager();
    Map<VmTemplate, List<DiskImage>> templates = new HashMap<>();
    OvfHelper ovfHelper = new OvfHelper();
    for (String ovf : ovfList) {
        try {
            if (ovfManager.IsOvfTemplate(ovf)) {
                VmTemplate vmTemplate = ovfHelper.readVmTemplateFromOvf(ovf);
                List templateDisks = new ArrayList(vmTemplate.getDiskTemplateMap().values());
                templates.put(vmTemplate, templateDisks);
            }
        } catch (OvfReaderException ex) {
            auditLogOvfLoadError(ex.getName());
        }
    }
    return templates;
}
#method_after
@Override
protected Map<VmTemplate, List<DiskImage>> buildFromOVFs(List<String> ovfList) {
    OvfManager ovfManager = new OvfManager();
    Map<VmTemplate, List<DiskImage>> templateDisksMap = new HashMap<>();
    OvfHelper ovfHelper = new OvfHelper();
    for (String ovf : ovfList) {
        try {
            if (ovfManager.IsOvfTemplate(ovf)) {
                VmTemplate vmTemplate = ovfHelper.readVmTemplateFromOvf(ovf);
                List<DiskImage> templateDisks = new ArrayList<>(vmTemplate.getDiskTemplateMap().values());
                templateDisksMap.put(vmTemplate, templateDisks);
            }
        } catch (OvfReaderException ex) {
            auditLogOvfLoadError(ex.getName());
        }
    }
    return templateDisksMap;
}
#end_block

#method_before
void initSortHandler() {
    // Allow sorting by one column at a time
    tableHeader.getColumnSortList().setLimit(1);
    table.getColumnSortList().setLimit(1);
    // Attach column sort handler
    ActionCellTable<T> tableWithHeader = isTableHeaderVisible() ? tableHeader : table;
    tableWithHeader.addColumnSortHandler(new ColumnSortEvent.Handler() {

        @SuppressWarnings("unchecked")
        @Override
        public void onColumnSort(ColumnSortEvent event) {
            Object model = getDataProvider().getModel();
            Column<?, ?> column = event.getColumn();
            if (model instanceof SearchableListModel && column instanceof SortableColumn) {
                SearchableListModel<T> searchableModel = (SearchableListModel<T>) model;
                SortableColumn<T, ?> sortedColumn = (SortableColumn<T, ?>) column;
                boolean sortSuccessful = false;
                // Apply server-side sorting, if supported by the model
                if (searchableModel.supportsServerSideSorting()) {
                    sortSuccessful = searchableModel.updateSortOptions(sortedColumn.getSortBy(), event.isSortAscending());
                } else // Otherwise, fall back to client-side sorting
                {
                    Comparator<? super T> comparator = sortedColumn.getComparator();
                    if (comparator != null) {
                        searchableModel.setComparator(comparator, event.isSortAscending());
                        sortSuccessful = true;
                    }
                }
                // Update column sort status, redrawing table headers if necessary
                ColumnSortInfo columnSortInfo = event.getColumnSortList().get(0);
                if (sortSuccessful) {
                    tableHeader.getColumnSortList().push(columnSortInfo);
                    table.getColumnSortList().push(columnSortInfo);
                } else {
                    tableHeader.getColumnSortList().remove(columnSortInfo);
                    table.getColumnSortList().remove(columnSortInfo);
                }
            }
        }
    });
}
#method_after
void initSortHandler() {
    // Allow sorting by one column at a time
    tableHeader.getColumnSortList().setLimit(1);
    table.getColumnSortList().setLimit(1);
    // Attach column sort handler
    ActionCellTable<T> tableWithHeader = isTableHeaderVisible() ? tableHeader : table;
    tableWithHeader.addColumnSortHandler(new ColumnSortEvent.Handler() {

        @SuppressWarnings("unchecked")
        @Override
        public void onColumnSort(ColumnSortEvent event) {
            SearchableListModel<?> model = getDataProvider().getModel();
            Column<?, ?> column = event.getColumn();
            if (column instanceof SortableColumn) {
                SortableColumn<T, ?> sortedColumn = (SortableColumn<T, ?>) column;
                boolean sortApplied = false;
                // Apply server-side sorting, if supported by the model
                if (model.supportsServerSideSorting()) {
                    if (model.isSearchValidForServerSideSorting()) {
                        model.updateSortOptions(sortedColumn.getSortBy(), event.isSortAscending());
                        sortApplied = true;
                    } else {
                        model.clearSortOptions();
                    }
                } else // Otherwise, fall back to client-side sorting
                {
                    Comparator<? super T> comparator = sortedColumn.getComparator();
                    if (comparator != null) {
                        ((SearchableListModel<T>) model).setComparator(comparator, event.isSortAscending());
                        sortApplied = true;
                    }
                }
                // Update column sort status, redrawing table headers if necessary
                ColumnSortInfo columnSortInfo = event.getColumnSortList().get(0);
                if (sortApplied) {
                    pushColumnSort(columnSortInfo);
                } else {
                    clearColumnSort();
                }
            }
        }
    });
}
#end_block

#method_before
private String generateFromStatement(SyntaxContainer syntax, boolean useTags) {
    LinkedList<String> innerJoins = new LinkedList<String>();
    ArrayList<String> refObjList = syntax.getCrossRefObjList();
    String searchObjStr = syntax.getSearchObjectStr();
    if (refObjList.size() > 0) {
        if (SearchObjects.TEMPLATE_OBJ_NAME.equals(searchObjStr)) {
            innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.TEMPLATE_OBJ_NAME, SearchObjects.VM_OBJ_NAME));
            if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                refObjList.remove(SearchObjects.VM_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.VDC_USER_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.VDC_USER_OBJ_NAME));
                refObjList.remove(SearchObjects.VDC_USER_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.VDS_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.VDS_OBJ_NAME));
                refObjList.remove(SearchObjects.VDS_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.AUDIT_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.AUDIT_OBJ_NAME));
                refObjList.remove(SearchObjects.AUDIT_OBJ_NAME);
            }
        } else if (SearchObjects.VDS_OBJ_NAME.equals(searchObjStr)) {
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.VDS_OBJ_NAME, SearchObjects.VM_OBJ_NAME));
                if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                    refObjList.remove(SearchObjects.VM_OBJ_NAME);
                }
            }
            if (refObjList.contains(SearchObjects.VDC_USER_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VDS_OBJ_NAME, SearchObjects.VDC_USER_OBJ_NAME));
                refObjList.remove(SearchObjects.VDC_USER_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.TEMPLATE_OBJ_NAME));
                refObjList.remove(SearchObjects.TEMPLATE_OBJ_NAME);
            }
        } else if (SearchObjects.VDC_USER_OBJ_NAME.equals(searchObjStr)) {
            if ((refObjList.contains(SearchObjects.VDS_OBJ_NAME))) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.VDC_USER_OBJ_NAME, SearchObjects.VM_OBJ_NAME));
                if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                    refObjList.remove(SearchObjects.VM_OBJ_NAME);
                }
            }
            if (refObjList.contains(SearchObjects.VDS_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.VDS_OBJ_NAME));
                refObjList.remove(SearchObjects.VDS_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VDC_USER_OBJ_NAME, SearchObjects.TEMPLATE_OBJ_NAME));
                refObjList.remove(SearchObjects.TEMPLATE_OBJ_NAME);
            }
        } else if (SearchObjects.AUDIT_OBJ_NAME.equals(searchObjStr)) {
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.AUDIT_OBJ_NAME, SearchObjects.VM_OBJ_NAME));
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.TEMPLATE_OBJ_NAME));
                refObjList.remove(SearchObjects.TEMPLATE_OBJ_NAME);
                if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                    refObjList.remove(SearchObjects.VM_OBJ_NAME);
                }
            }
        } else if (SearchObjects.DISK_OBJ_NAME.equals(searchObjStr)) {
            if (refObjList.contains(SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.DISK_OBJ_NAME, SearchObjects.VDC_STORAGE_DOMAIN_IMAGE_OBJ_NAME));
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VDC_STORAGE_DOMAIN_IMAGE_OBJ_NAME, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME));
                refObjList.remove(SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME);
            }
        }
    }
    for (String cro : refObjList) {
        innerJoins.addLast(mSearchObjectAC.getInnerJoin(searchObjStr, cro));
    }
    if (useTags) {
        innerJoins.addFirst(mSearchObjectAC.getRelatedTableName(searchObjStr));
    } else {
        innerJoins.addFirst(mSearchObjectAC.getRelatedTableNameWithOutTags(searchObjStr));
    }
    StringBuilder sb = new StringBuilder();
    for (String part : innerJoins) {
        sb.append(" ");
        sb.append(part);
        sb.append(" ");
    }
    return sb.toString();
}
#method_after
private String generateFromStatement(SyntaxContainer syntax, boolean useTags) {
    LinkedList<String> innerJoins = new LinkedList<String>();
    ArrayList<String> refObjList = syntax.getCrossRefObjList();
    String searchObjStr = syntax.getSearchObjectStr();
    if (refObjList.size() > 0) {
        if (SearchObjects.TEMPLATE_OBJ_NAME.equals(searchObjStr)) {
            innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.TEMPLATE_OBJ_NAME, SearchObjects.VM_OBJ_NAME, useTags));
            if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                refObjList.remove(SearchObjects.VM_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.VDC_USER_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.VDC_USER_OBJ_NAME, useTags));
                refObjList.remove(SearchObjects.VDC_USER_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.VDS_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.VDS_OBJ_NAME, true));
                refObjList.remove(SearchObjects.VDS_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.AUDIT_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.AUDIT_OBJ_NAME, useTags));
                refObjList.remove(SearchObjects.AUDIT_OBJ_NAME);
            }
        } else if (SearchObjects.VDS_OBJ_NAME.equals(searchObjStr)) {
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.VDS_OBJ_NAME, SearchObjects.VM_OBJ_NAME, useTags));
                if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                    refObjList.remove(SearchObjects.VM_OBJ_NAME);
                }
            }
            if (refObjList.contains(SearchObjects.VDC_USER_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VDS_OBJ_NAME, SearchObjects.VDC_USER_OBJ_NAME, useTags));
                refObjList.remove(SearchObjects.VDC_USER_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.TEMPLATE_OBJ_NAME, useTags));
                refObjList.remove(SearchObjects.TEMPLATE_OBJ_NAME);
            }
        } else if (SearchObjects.VDC_USER_OBJ_NAME.equals(searchObjStr)) {
            if ((refObjList.contains(SearchObjects.VDS_OBJ_NAME))) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.VDC_USER_OBJ_NAME, SearchObjects.VM_OBJ_NAME, useTags));
                if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                    refObjList.remove(SearchObjects.VM_OBJ_NAME);
                }
            }
            if (refObjList.contains(SearchObjects.VDS_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.VDS_OBJ_NAME, useTags));
                refObjList.remove(SearchObjects.VDS_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VDC_USER_OBJ_NAME, SearchObjects.TEMPLATE_OBJ_NAME, useTags));
                refObjList.remove(SearchObjects.TEMPLATE_OBJ_NAME);
            }
        } else if (SearchObjects.AUDIT_OBJ_NAME.equals(searchObjStr)) {
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.AUDIT_OBJ_NAME, SearchObjects.VM_OBJ_NAME, useTags));
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.TEMPLATE_OBJ_NAME, useTags));
                refObjList.remove(SearchObjects.TEMPLATE_OBJ_NAME);
                if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                    refObjList.remove(SearchObjects.VM_OBJ_NAME);
                }
            }
        } else if (SearchObjects.DISK_OBJ_NAME.equals(searchObjStr)) {
            if (refObjList.contains(SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.DISK_OBJ_NAME, SearchObjects.VDC_STORAGE_DOMAIN_IMAGE_OBJ_NAME, useTags));
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VDC_STORAGE_DOMAIN_IMAGE_OBJ_NAME, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME, useTags));
                refObjList.remove(SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME);
            }
        }
    }
    for (String cro : refObjList) {
        innerJoins.addLast(mSearchObjectAC.getInnerJoin(searchObjStr, cro, useTags));
    }
    innerJoins.addFirst(mSearchObjectAC.getRelatedTableName(searchObjStr, useTags));
    StringBuilder sb = new StringBuilder();
    for (String part : innerJoins) {
        sb.append(" ");
        sb.append(part);
        sb.append(" ");
    }
    return sb.toString();
}
#end_block

#method_before
private String generateSqlFromSyntaxContainer(SyntaxContainer syntax, boolean isSafe) {
    String retval = "";
    if (syntax.getvalid()) {
        ListIterator<SyntaxObject> objIter = syntax.listIterator(0);
        IConditionFieldAutoCompleter conditionFieldAC;
        LinkedList<String> whereBuilder = new LinkedList<String>();
        String searchObjStr = syntax.getSearchObjectStr();
        String sortByPhrase = "";
        String fromStatement = "";
        String pageNumber = "";
        while (objIter.hasNext()) {
            SyntaxObject obj = objIter.next();
            switch(obj.getType()) {
                case SEARCH_OBJECT:
                    fromStatement = generateFromStatement(syntax);
                    break;
                case OR:
                case AND:
                    whereBuilder.addLast(obj.getBody());
                    break;
                case CONDITION_VALUE:
                    whereBuilder.addLast(generateConditionStatment(obj, syntax.listIterator(objIter.previousIndex()), searchObjStr, syntax.getCaseSensitive(), isSafe));
                    break;
                case SORTBY:
                    break;
                case PAGE_VALUE:
                    pageNumber = obj.getBody();
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                    sortByPhrase = StringFormat.format(" ORDER BY %1$s", conditionFieldAC.getSortableDbField(obj.getBody()));
                    break;
                case SORT_DIRECTION:
                    // Forcing any sorting using DESC to show NULL values last (NULLS FIRST is the default)
                    String direction = (obj.getBody().equalsIgnoreCase("desc")) ? "DESC NULLS LAST" : obj.getBody();
                    sortByPhrase = StringFormat.format("%1$s %2$s", sortByPhrase, direction);
                    break;
                default:
                    break;
            }
        }
        // implying precedence rules
        String[] lookFor = { "AND", "OR" };
        for (int idx = 0; idx < lookFor.length; idx++) {
            boolean found = true;
            while (found) {
                found = false;
                ListIterator<String> iter = whereBuilder.listIterator(0);
                while (iter.hasNext()) {
                    String queryPart = iter.next();
                    if (lookFor[idx].equals(queryPart)) {
                        iter.remove();
                        String nextPart = iter.next();
                        iter.remove();
                        String prevPart = iter.previous();
                        iter.set(StringFormat.format("( %1$s %2$s %3$s )", prevPart, queryPart, nextPart));
                        found = true;
                        break;
                    }
                }
            }
        }
        // adding WHERE if required and All implicit AND
        StringBuilder wherePhrase = new StringBuilder();
        if (whereBuilder.size() > 0) {
            wherePhrase.append(" WHERE ");
            ListIterator<String> iter = whereBuilder.listIterator(0);
            while (iter.hasNext()) {
                String queryPart = iter.next();
                wherePhrase.append(queryPart);
                if (iter.hasNext()) {
                    wherePhrase.append(" AND ");
                }
            }
        }
        // adding the sorting part if required
        if ("".equals(sortByPhrase)) {
            sortByPhrase = " ORDER BY " + mSearchObjectAC.getDefaultSort(searchObjStr);
        }
        // adding the paging phrase
        String pagePhrase = getPagePhrase(syntax, pageNumber);
        String primeryKey = mSearchObjectAC.getPrimeryKeyName(searchObjStr);
        String tableName = mSearchObjectAC.getRelatedTableName(searchObjStr);
        String tableNameWithOutTags = mSearchObjectAC.getRelatedTableNameWithOutTags(searchObjStr);
        boolean generalQuery = false;
        String innerQuery;
        if (!wherePhrase.toString().contains(TAG_COLUMN_NAME_IN_CRITERIA) && !wherePhrase.toString().contains(".") && (searchObjStr.equals(SearchObjects.VDS_OBJ_NAME) || searchObjStr.equals(SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME))) {
            innerQuery = getInnerQuery(tableNameWithOutTags, "*", generateFromStatement(syntax, false), wherePhrase);
            generalQuery = true;
        } else {
            innerQuery = getInnerQuery(tableName, primeryKey, fromStatement, wherePhrase);
        }
        // adding a secondary default sort by entity name
        StringBuilder sortExpr = new StringBuilder();
        sortExpr.append(sortByPhrase);
        if (sortByPhrase.indexOf(mSearchObjectAC.getDefaultSort(searchObjStr)) < 0) {
            sortExpr.append(",");
            sortExpr.append(mSearchObjectAC.getDefaultSort(searchObjStr));
        }
        // TODO: The database configuration PostgresSearchTemplate has an extra closing braces. Hence our
        // queries in this code have an extra opening one. Fix it in a future patch.
        // only audit log search supports the SearchFrom which enables getting records starting from a certain
        // audit_log_id, this is done to make search queries from the client more efficient and eliminate the client
        // from registering to such queries and comparing last data with previous.
        String inQuery = "";
        if (primeryKey.equals("audit_log_id")) {
            if (wherePhrase.length() == 0) {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom());
            } else if (whereBuilder.size() == 1 && wherePhrase.toString().contains("severity")) {
                inQuery = StringFormat.format("SELECT %1$s.* FROM %2$s %3$s and (not deleted", tableName, fromStatement, wherePhrase);
            } else {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and %2$s IN (%4$s) and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom(), innerQuery);
            }
        } else if ((primeryKey.equals("vmt_guid") || primeryKey.equals("vm_pool_id")) && wherePhrase.length() == 0) {
            inQuery = StringFormat.format("(SELECT * FROM %1$s ", tableNameWithOutTags);
        } else if (primeryKey.equals("vmt_guid") && wherePhrase.length() > 0 && wherePhrase.toString().contains("storage_pool_name") && whereBuilder.size() == 1) {
            inQuery = StringFormat.format("(SELECT * FROM %1$s %2$s", tableNameWithOutTags, wherePhrase.toString().replace(tableName, tableNameWithOutTags));
        } else if (generalQuery) {
            inQuery = "(" + innerQuery;
        } else if (searchObjStr.equals(SearchObjects.VDS_OBJ_NAME) && primeryKey.equals("vds_id") && wherePhrase.toString().contains("storage_domains_with_hosts_view.storage_name") && !wherePhrase.toString().contains("AND") && !wherePhrase.toString().contains("OR")) {
            ListIterator<SyntaxObject> syntaxObjects = syntax.listIterator(0);
            boolean notFoundValue = true;
            String value = null;
            while (syntaxObjects.hasNext() && notFoundValue) {
                SyntaxObject obj = syntaxObjects.next();
                if (obj.getType() == SyntaxObjectType.CONDITION_VALUE) {
                    value = obj.getBody();
                    notFoundValue = false;
                }
            }
            inQuery = "SELECT * FROM vds WHERE ( storage_pool_id IN (SELECT storage_pool_id FROM storage_domains WHERE  storage_domains.storage_name LIKE '" + value + "')";
        } else {
            inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s IN (%3$s)", tableNameWithOutTags, primeryKey, innerQuery);
        }
        retval = StringFormat.format(Config.<String>getValue(ConfigValues.DBSearchTemplate), sortExpr.toString(), inQuery, pagePhrase);
        // Check for sql injection if query is not safe
        if (!isSafe) {
            if (sqlInjectionChecker.hasSqlInjection(retval)) {
                throw new SqlInjectionException();
            }
        }
        log.trace("Search: " + retval);
    }
    return retval;
}
#method_after
private String generateSqlFromSyntaxContainer(SyntaxContainer syntax, boolean isSafe) {
    String retval = "";
    if (syntax.getvalid()) {
        ListIterator<SyntaxObject> objIter = syntax.listIterator(0);
        IConditionFieldAutoCompleter conditionFieldAC;
        LinkedList<String> whereBuilder = new LinkedList<String>();
        String searchObjStr = syntax.getSearchObjectStr();
        String sortByPhrase = "";
        String fromStatement = "";
        String pageNumber = "";
        boolean useTags = syntax.isSearchUsingTags();
        while (objIter.hasNext()) {
            SyntaxObject obj = objIter.next();
            switch(obj.getType()) {
                case SEARCH_OBJECT:
                    fromStatement = generateFromStatement(syntax, useTags);
                    break;
                case OR:
                case AND:
                    whereBuilder.addLast(obj.getBody());
                    break;
                case CONDITION_VALUE:
                    ConditionData conditionData = generateConditionStatment(obj, syntax.listIterator(objIter.previousIndex()), searchObjStr, syntax.getCaseSensitive(), isSafe, useTags);
                    whereBuilder.addLast(conditionData.getConditionText());
                    if (conditionData.isFullTableRequired() && !useTags) {
                        useTags = true;
                        fromStatement = generateFromStatement(syntax, useTags);
                    }
                    break;
                case SORTBY:
                    break;
                case PAGE_VALUE:
                    pageNumber = obj.getBody();
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                    sortByPhrase = StringFormat.format(" ORDER BY %1$s", conditionFieldAC.getSortableDbField(obj.getBody()));
                    break;
                case SORT_DIRECTION:
                    // Forcing any sorting using DESC to show NULL values last (NULLS FIRST is the default)
                    String direction = (obj.getBody().equalsIgnoreCase("desc")) ? "DESC NULLS LAST" : obj.getBody();
                    sortByPhrase = StringFormat.format("%1$s %2$s", sortByPhrase, direction);
                    break;
                default:
                    break;
            }
        }
        // implying precedence rules
        String[] lookFor = { "AND", "OR" };
        for (int idx = 0; idx < lookFor.length; idx++) {
            boolean found = true;
            while (found) {
                found = false;
                ListIterator<String> iter = whereBuilder.listIterator(0);
                while (iter.hasNext()) {
                    String queryPart = iter.next();
                    if (lookFor[idx].equals(queryPart)) {
                        iter.remove();
                        String nextPart = iter.next();
                        iter.remove();
                        String prevPart = iter.previous();
                        iter.set(StringFormat.format("( %1$s %2$s %3$s )", prevPart, queryPart, nextPart));
                        found = true;
                        break;
                    }
                }
            }
        }
        // for not deleted events, add this to the where clause
        if (searchObjStr.equalsIgnoreCase("EVENT")) {
            whereBuilder.add("not deleted");
        }
        // adding WHERE if required and All implicit AND
        StringBuilder wherePhrase = new StringBuilder();
        if (whereBuilder.size() > 0) {
            wherePhrase.append(" WHERE ");
            ListIterator<String> iter = whereBuilder.listIterator(0);
            while (iter.hasNext()) {
                String queryPart = iter.next();
                wherePhrase.append(queryPart);
                if (iter.hasNext()) {
                    wherePhrase.append(" AND ");
                }
            }
        }
        // adding the sorting part if required
        if ("".equals(sortByPhrase)) {
            sortByPhrase = " ORDER BY " + mSearchObjectAC.getDefaultSort(searchObjStr);
        }
        // adding the paging phrase
        String pagePhrase = getPagePhrase(syntax, pageNumber);
        String primeryKey = mSearchObjectAC.getPrimeryKeyName(searchObjStr);
        String tableName = mSearchObjectAC.getRelatedTableName(searchObjStr, useTags);
        // adding a secondary default sort by entity name
        StringBuilder sortExpr = new StringBuilder();
        sortExpr.append(sortByPhrase);
        if (sortByPhrase.indexOf(mSearchObjectAC.getDefaultSort(searchObjStr)) < 0) {
            sortExpr.append(",");
            sortExpr.append(mSearchObjectAC.getDefaultSort(searchObjStr));
        }
        // TODO: The database configuration PostgresSearchTemplate has an extra closing braces. Hence our
        // queries in this code have an extra opening one. Fix it in a future patch.
        String inQuery = "";
        if (useTags) {
            inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s IN (%3$s)", mSearchObjectAC.getRelatedTableName(searchObjStr, false), primeryKey, getInnerQuery(tableName, primeryKey, fromStatement, wherePhrase));
        } else {
            inQuery = "(" + getInnerQuery(tableName, "*", fromStatement, wherePhrase);
        }
        retval = StringFormat.format(Config.<String>getValue(ConfigValues.DBSearchTemplate), sortExpr.toString(), inQuery, pagePhrase);
        // Check for sql injection if query is not safe
        if (!isSafe) {
            if (sqlInjectionChecker.hasSqlInjection(retval)) {
                throw new SqlInjectionException();
            }
        }
        log.trace("Search: " + retval);
    }
    return retval;
}
#end_block

#method_before
private String generateConditionStatment(SyntaxObject obj, ListIterator<SyntaxObject> objIter, final String searchObjStr, final boolean caseSensitive, final boolean issafe) {
    final String safeValue = issafe ? obj.getBody() : SqlInjectionChecker.enforceEscapeCharacters(obj.getBody());
    return generateSafeConditionStatement(obj, objIter, searchObjStr, caseSensitive, safeValue);
}
#method_after
private ConditionData generateConditionStatment(SyntaxObject obj, ListIterator<SyntaxObject> objIter, final String searchObjStr, final boolean caseSensitive, final boolean issafe, final boolean useTags) {
    final String safeValue = issafe ? obj.getBody() : SqlInjectionChecker.enforceEscapeCharacters(obj.getBody());
    return generateSafeConditionStatement(obj, objIter, searchObjStr, caseSensitive, safeValue, useTags);
}
#end_block

#method_before
private String generateSafeConditionStatement(final SyntaxObject obj, ListIterator<SyntaxObject> objIter, final String searchObjStr, final boolean caseSensitive, final String safeValue) {
    IConditionFieldAutoCompleter conditionFieldAC;
    IConditionValueAutoCompleter conditionValueAC = null;
    // check for sql injection
    String fieldName = "";
    String objName;
    ConditionType conditionType;
    SyntaxObject previous = objIter.previous();
    SyntaxObject prev = previous;
    SyntaxObjectType prevType = prev.getType();
    if (prevType != SyntaxObjectType.CONDITION_RELATION) {
        // free text of default search object
        objName = searchObjStr;
        conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
        conditionType = ConditionType.FreeText;
    } else {
        prev = objIter.previous();
        if (prev.getType() == SyntaxObjectType.CROSS_REF_OBJ) {
            // free text
            // search
            // for some
            // object
            objName = prev.getBody();
            conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(objName);
            conditionType = ConditionType.FreeTextSpecificObj;
        } else {
            // if (prev.getType() == SyntaxObjectType.CONDITION_FIELD)
            fieldName = prev.getBody();
            prev = objIter.previous();
            if (prev.getType() != SyntaxObjectType.DOT) {
                // standard condition with default AC (search obj)
                objName = searchObjStr;
                conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                conditionType = ConditionType.ConditionWithDefaultObj;
            } else {
                // standard condition with specific AC
                prev = objIter.previous();
                objName = prev.getBody();
                conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(objName);
                conditionType = ConditionType.ConditionwithSpesificObj;
            }
        }
        conditionValueAC = conditionFieldAC.getFieldValueAutoCompleter(fieldName);
    }
    final BaseConditionFieldAutoCompleter conditionAsBase = (BaseConditionFieldAutoCompleter) ((conditionFieldAC instanceof BaseConditionFieldAutoCompleter) ? conditionFieldAC : null);
    final Class<?> curType = conditionAsBase != null ? conditionAsBase.getTypeDictionary().get(fieldName) : null;
    final String customizedValue = buildCustomizedValue(obj, conditionFieldAC, conditionValueAC, safeValue, fieldName, curType);
    final String customizedRelation = buildCustomizedRelation(caseSensitive, conditionFieldAC, conditionValueAC, fieldName, previous, prevType);
    return buildCondition(caseSensitive, conditionFieldAC, customizedValue, customizedRelation, fieldName, objName, conditionType);
}
#method_after
private ConditionData generateSafeConditionStatement(final SyntaxObject obj, ListIterator<SyntaxObject> objIter, final String searchObjStr, final boolean caseSensitive, final String safeValue, final boolean useTags) {
    IConditionFieldAutoCompleter conditionFieldAC;
    IConditionValueAutoCompleter conditionValueAC = null;
    // check for sql injection
    String fieldName = "";
    String objName;
    ConditionType conditionType;
    SyntaxObject previous = objIter.previous();
    SyntaxObject prev = previous;
    SyntaxObjectType prevType = prev.getType();
    if (prevType != SyntaxObjectType.CONDITION_RELATION) {
        // free text of default search object
        objName = searchObjStr;
        conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
        conditionType = ConditionType.FreeText;
    } else {
        prev = objIter.previous();
        if (prev.getType() == SyntaxObjectType.CROSS_REF_OBJ) {
            // free text
            // search
            // for some
            // object
            objName = prev.getBody();
            conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(objName);
            conditionType = ConditionType.FreeTextSpecificObj;
        } else {
            // if (prev.getType() == SyntaxObjectType.CONDITION_FIELD)
            fieldName = prev.getBody();
            prev = objIter.previous();
            if (prev.getType() != SyntaxObjectType.DOT) {
                // standard condition with default AC (search obj)
                objName = searchObjStr;
                conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                conditionType = ConditionType.ConditionWithDefaultObj;
            } else {
                // standard condition with specific AC
                prev = objIter.previous();
                objName = prev.getBody();
                conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(objName);
                conditionType = ConditionType.ConditionwithSpesificObj;
            }
        }
        conditionValueAC = conditionFieldAC.getFieldValueAutoCompleter(fieldName);
    }
    final BaseConditionFieldAutoCompleter conditionAsBase = (BaseConditionFieldAutoCompleter) ((conditionFieldAC instanceof BaseConditionFieldAutoCompleter) ? conditionFieldAC : null);
    final Class<?> curType = conditionAsBase != null ? conditionAsBase.getTypeDictionary().get(fieldName) : null;
    final String customizedValue = buildCustomizedValue(obj, conditionFieldAC, conditionValueAC, safeValue, fieldName, curType);
    final String customizedRelation = buildCustomizedRelation(caseSensitive, conditionFieldAC, conditionValueAC, fieldName, previous, prevType);
    return buildCondition(caseSensitive, conditionFieldAC, customizedValue, customizedRelation, fieldName, objName, conditionType);
}
#end_block

#method_before
final String buildCondition(boolean caseSensitive, IConditionFieldAutoCompleter conditionFieldAC, String customizedValue, String customizedRelation, String fieldName, String objName, ConditionType conditionType) {
    final String tableName = mSearchObjectAC.getRelatedTableName(objName);
    if (customizedRelation.equalsIgnoreCase("LIKE") || customizedRelation.equalsIgnoreCase("ILIKE")) {
        // Since '_' is treated in Postgres as '?' when using like, (i.e. match any single character)
        // we have to escape this character in the value to make it treated as a regular character.
        // Due to changes between PG8.x and PG9.x on ESCAPE representation in a string, we should
        // figure out what PG Release is running in order to escape the special character(_) correctly
        // This is done in a IF block and not with Method Factory pattern since this is the only change
        // right now, if we encounter other changes, this will be refactored to use the Method Factory pattern.
        String replaceWith = "_";
        int pgMajorRelease = Config.<Integer>getValue(ConfigValues.PgMajorRelease);
        if (pgMajorRelease == PgMajorRelease.PG8.getValue()) {
            replaceWith = "\\\\_";
        } else if (pgMajorRelease == PgMajorRelease.PG9.getValue()) {
            replaceWith = "\\_";
        }
        customizedValue = customizedValue.replace("_", replaceWith);
    }
    switch(conditionType) {
        case FreeText:
        case FreeTextSpecificObj:
            return conditionFieldAC.buildFreeTextConditionSql(tableName, customizedRelation, customizedValue, caseSensitive);
        case ConditionWithDefaultObj:
        case ConditionwithSpesificObj:
            return conditionFieldAC.buildConditionSql(fieldName, customizedValue, customizedRelation, tableName, caseSensitive);
        default:
            return "";
    }
}
#method_after
final ConditionData buildCondition(boolean caseSensitive, IConditionFieldAutoCompleter conditionFieldAC, String customizedValue, String customizedRelation, String fieldName, String objName, ConditionType conditionType) {
    String tableName;
    // TODO: Optimize this
    if (conditionType == ConditionType.ConditionwithSpesificObj) {
        tableName = mSearchObjectAC.getRelatedTableName(objName, true);
    } else {
        tableName = mSearchObjectAC.getRelatedTableName(objName, fieldName);
    }
    if (customizedRelation.equalsIgnoreCase("LIKE") || customizedRelation.equalsIgnoreCase("ILIKE")) {
        // Since '_' is treated in Postgres as '?' when using like, (i.e. match any single character)
        // we have to escape this character in the value to make it treated as a regular character.
        // Due to changes between PG8.x and PG9.x on ESCAPE representation in a string, we should
        // figure out what PG Release is running in order to escape the special character(_) correctly
        // This is done in a IF block and not with Method Factory pattern since this is the only change
        // right now, if we encounter other changes, this will be refactored to use the Method Factory pattern.
        String replaceWith = "_";
        int pgMajorRelease = Config.<Integer>getValue(ConfigValues.PgMajorRelease);
        if (pgMajorRelease == PgMajorRelease.PG8.getValue()) {
            replaceWith = "\\\\_";
        } else if (pgMajorRelease == PgMajorRelease.PG9.getValue()) {
            replaceWith = "\\_";
        }
        customizedValue = customizedValue.replace("_", replaceWith);
    }
    ConditionData conditionData = new ConditionData();
    switch(conditionType) {
        case FreeText:
        case FreeTextSpecificObj:
            conditionData.setConditionText(conditionFieldAC.buildFreeTextConditionSql(tableName, customizedRelation, customizedValue, caseSensitive));
            conditionData.setFullTableRequired(true);
            break;
        case ConditionWithDefaultObj:
        case ConditionwithSpesificObj:
            conditionData.setConditionText(conditionFieldAC.buildConditionSql(fieldName, customizedValue, customizedRelation, tableName, caseSensitive));
            conditionData.setFullTableRequired(false);
            break;
        default:
            conditionData.setConditionText("");
            conditionData.setFullTableRequired(false);
    }
    return conditionData;
}
#end_block

#method_before
public void search() {
    // Defer search if there max result limit was not yet retrieved.
    if (getSearchPageSize() == UnknownInteger) {
        asyncCallback.requestSearch();
    } else {
        stopRefresh();
        if (getIsQueryFirstTime()) {
            setSelectedItem(null);
            setSelectedItems(null);
        }
        if (getIsTimerDisabled() == false) {
            setIsQueryFirstTime(true);
            onPropertyChanged(new PropertyChangedEventArgs(PropertyChangedEventArgs.Args.PROGRESS.toString()));
            syncSearch();
            setIsQueryFirstTime(false);
            if (getTimer() != null) {
                // Timer can be null if the event bus hasn't been set yet (model hasn't been fully initialized)
                startRefresh();
            } else {
                // Defer the start of the timer until after the event bus has been added to this model. Then we
                // can pass the event bus to the timer and the timer can become active.
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        startRefresh();
                    }
                });
            }
        } else {
            syncSearch();
        }
    }
}
#method_after
public void search() {
    // Defer search if there max result limit was not yet retrieved.
    if (getSearchPageSize() == UnknownInteger) {
        asyncCallback.requestSearch();
    } else {
        stopRefresh();
        if (getIsQueryFirstTime()) {
            setSelectedItem(null);
            setSelectedItems(null);
        }
        if (getIsTimerDisabled() == false) {
            setIsQueryFirstTime(true);
            onPropertyChanged(new PropertyChangedEventArgs(PropertyChangedEventArgs.PROGRESS));
            syncSearch();
            setIsQueryFirstTime(false);
            if (getTimer() != null) {
                // Timer can be null if the event bus hasn't been set yet (model hasn't been fully initialized)
                startRefresh();
            } else {
                // Defer the start of the timer until after the event bus has been added to this model. Then we
                // can pass the event bus to the timer and the timer can become active.
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        startRefresh();
                    }
                });
            }
        } else {
            syncSearch();
        }
    }
}
#end_block

#method_before
public boolean updateSortOptions(String sortBy, boolean sortAscending) {
    String searchQuery = getSearchString();
    if (!isSearchComplete(searchQuery) || searchContainsSortByPart(searchQuery)) {
        return false;
    }
    boolean shouldRefresh = !ObjectUtils.objectsEqual(this.sortBy, sortBy) || this.sortAscending != sortAscending;
    this.sortBy = sortBy;
    this.sortAscending = sortAscending;
    if (shouldRefresh) {
        refresh();
    }
    return true;
}
#method_after
public void updateSortOptions(String sortBy, boolean sortAscending) {
    boolean shouldRefresh = !ObjectUtils.objectsEqual(this.sortBy, sortBy) || this.sortAscending != sortAscending;
    this.sortBy = sortBy;
    this.sortAscending = sortAscending;
    if (shouldRefresh) {
        refresh();
    }
}
#end_block

#method_before
protected String applySortOptions(String searchQuery) {
    String result = searchQuery;
    if (sortBy != null && isSearchComplete(searchQuery) && !searchContainsSortByPart(searchQuery)) {
        result += // $NON-NLS-1$ //$NON-NLS-2$
        " " + SyntaxChecker.SORTBY + " " + sortBy + " " + // $NON-NLS-1$
        (sortAscending ? SyntaxChecker.SORTDIR_ASC : SyntaxChecker.SORTDIR_DESC);
    }
    return result;
}
#method_after
protected String applySortOptions(String searchString) {
    String result = searchString;
    if (sortBy != null) {
        result += // $NON-NLS-1$ //$NON-NLS-2$
        " " + SyntaxChecker.SORTBY + " " + sortBy + " " + // $NON-NLS-1$
        (sortAscending ? SyntaxChecker.SORTDIR_ASC : SyntaxChecker.SORTDIR_DESC);
    }
    return result;
}
#end_block

#method_before
public void updateOptionsAsync(String search) {
    getItems().clear();
    SyntaxContainer syntax = syntaxChecker.getCompletion(search);
    int lastHandledIndex = syntax.getLastHandledIndex();
    String pf = search.substring(0, lastHandledIndex);
    String notHandled = search.substring(lastHandledIndex);
    String[] suggestedItems = syntax.getCompletionArray();
    // Ensure that filtered search objects will invalidate the whole search query
    if (getSearchObjectFilter() != null && syntax.getState() != SyntaxObjectType.BEGIN) {
        for (String value : getSearchObjectFilter()) {
            if (pf.toLowerCase().equals(value.toLowerCase()) || pf.toLowerCase().startsWith(value.toLowerCase() + ":")) {
                // $NON-NLS-1$
                // $NON-NLS-1$
                addSuggestItem("", SuggestItemPartType.Valid, search, SuggestItemPartType.Erroneous);
                return;
            }
        }
    }
    if (syntax.getError() == SyntaxError.NO_ERROR) {
        List<String> actualItems = new ArrayList<String>(Arrays.asList(suggestedItems));
        // Filter search object suggestions
        if (getSearchObjectFilter() != null && syntax.getState() == SyntaxObjectType.BEGIN) {
            for (String value : getSearchObjectFilter()) {
                for (String item : suggestedItems) {
                    if (item.toLowerCase().equals(value.toLowerCase())) {
                        actualItems.remove(item);
                    }
                }
            }
            // Ensure that empty search suggestion list invalidates the search query
            if (actualItems.isEmpty()) {
                // $NON-NLS-1$
                addSuggestItem("", SuggestItemPartType.Valid, search, SuggestItemPartType.Erroneous);
                return;
            }
        }
        for (String item : actualItems) {
            // Apply filter
            if (getFilter() != null) {
                boolean skipItem = false;
                for (String value : getFilter()) {
                    if (ObjectUtils.objectsEqual(value.toLowerCase(), item.toLowerCase())) {
                        skipItem = true;
                        break;
                    }
                }
                if (skipItem) {
                    continue;
                }
            }
            // $NON-NLS-1$
            String space = "";
            if (// $NON-NLS-1$
            (pf.length() > 0) && (!pf.substring(pf.length() - 1, pf.length() - 1 + 1).equals(".")) && // $NON-NLS-1$
            (!".".equals(item))) {
                // $NON-NLS-1$
                space = " ";
            }
            // Patch: monitor-desktop
            if (// $NON-NLS-1$
            !item.trim().toLowerCase().startsWith("monitor-desktop")) {
                addSuggestItem(StringHelper.trimEnd(pf), SuggestItemPartType.Valid, space + item.trim(), SuggestItemPartType.New);
            }
        }
    } else {
        addSuggestItem(pf, SuggestItemPartType.Valid, notHandled, SuggestItemPartType.Erroneous);
    }
}
#method_after
public void updateOptionsAsync(String search) {
    getItems().clear();
    SyntaxContainer syntax = getSyntaxChecker().getCompletion(search);
    int lastHandledIndex = syntax.getLastHandledIndex();
    String pf = search.substring(0, lastHandledIndex);
    String notHandled = search.substring(lastHandledIndex);
    String[] suggestedItems = syntax.getCompletionArray();
    // Ensure that filtered search objects will invalidate the whole search query
    if (getSearchObjectFilter() != null && syntax.getState() != SyntaxObjectType.BEGIN) {
        for (String value : getSearchObjectFilter()) {
            if (pf.toLowerCase().equals(value.toLowerCase()) || pf.toLowerCase().startsWith(value.toLowerCase() + ":")) {
                // $NON-NLS-1$
                // $NON-NLS-1$
                addSuggestItem("", SuggestItemPartType.Valid, search, SuggestItemPartType.Erroneous);
                return;
            }
        }
    }
    if (syntax.getError() == SyntaxError.NO_ERROR) {
        List<String> actualItems = new ArrayList<String>(Arrays.asList(suggestedItems));
        // Filter search object suggestions
        if (getSearchObjectFilter() != null && syntax.getState() == SyntaxObjectType.BEGIN) {
            for (String value : getSearchObjectFilter()) {
                for (String item : suggestedItems) {
                    if (item.toLowerCase().equals(value.toLowerCase())) {
                        actualItems.remove(item);
                    }
                }
            }
            // Ensure that empty search suggestion list invalidates the search query
            if (actualItems.isEmpty()) {
                // $NON-NLS-1$
                addSuggestItem("", SuggestItemPartType.Valid, search, SuggestItemPartType.Erroneous);
                return;
            }
        }
        for (String item : actualItems) {
            // Apply filter
            if (getFilter() != null) {
                boolean skipItem = false;
                for (String value : getFilter()) {
                    if (ObjectUtils.objectsEqual(value.toLowerCase(), item.toLowerCase())) {
                        skipItem = true;
                        break;
                    }
                }
                if (skipItem) {
                    continue;
                }
            }
            // $NON-NLS-1$
            String space = "";
            if (// $NON-NLS-1$
            (pf.length() > 0) && (!pf.substring(pf.length() - 1, pf.length() - 1 + 1).equals(".")) && // $NON-NLS-1$
            (!".".equals(item))) {
                // $NON-NLS-1$
                space = " ";
            }
            // Patch: monitor-desktop
            if (// $NON-NLS-1$
            !item.trim().toLowerCase().startsWith("monitor-desktop")) {
                addSuggestItem(StringHelper.trimEnd(pf), SuggestItemPartType.Valid, space + item.trim(), SuggestItemPartType.New);
            }
        }
    } else {
        addSuggestItem(pf, SuggestItemPartType.Valid, notHandled, SuggestItemPartType.Erroneous);
    }
}
#end_block

#method_before
@Override
public Map<String, String> allocate(Network network, VnicProfile vnicProfile, VmNic nic, String hostId) {
    try {
        Port port = locatePort(nic);
        List<String> securityGroups = getSecurityGroups(vnicProfile);
        if (port == null) {
            com.woorea.openstack.quantum.model.Network externalNetwork = getExternalNetwork(network.getProvidedBy());
            Port portForCreate = new Port();
            portForCreate.setAdminStateUp(true);
            portForCreate.setName(nic.getName());
            portForCreate.setTenantId(externalNetwork.getTenantId());
            portForCreate.setMacAddress(nic.getMacAddress());
            portForCreate.setNetworkId(externalNetwork.getId());
            portForCreate.setDeviceOwner(DEVICE_OWNER);
            portForCreate.setDeviceId(nic.getId().toString());
            portForCreate.setSecurityGroups(securityGroups);
            portForCreate.setBinding(new Binding());
            portForCreate.getBinding().setHostId(hostId);
            port = getClient().ports().create(portForCreate).execute();
        } else if (securityGroupsChanged(port.getSecurityGroups(), securityGroups) || hostChanged(port, hostId)) {
            Port portForUpdate = new PortForUpdate();
            portForUpdate.setId(port.getId());
            portForUpdate.setSecurityGroups(securityGroups);
            portForUpdate.setBinding(new Binding());
            portForUpdate.getBinding().setHostId(hostId);
            port = getClient().ports().update(portForUpdate).execute();
        }
        Map<String, String> runtimeProperties = new HashMap<>();
        runtimeProperties.put("vnic_id", port.getId());
        runtimeProperties.put("provider_type", provider.getType().name());
        runtimeProperties.put("plugin_type", provider.getAdditionalProperties().getPluginType());
        if (port.getSecurityGroups() != null && !port.getSecurityGroups().isEmpty()) {
            runtimeProperties.put("security_groups", StringUtils.join(port.getSecurityGroups(), ','));
        }
        return runtimeProperties;
    } catch (RuntimeException e) {
        throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE, e);
    }
}
#method_after
@Override
public Map<String, String> allocate(Network network, VnicProfile vnicProfile, VmNic nic, VDS host) {
    try {
        Port port = locatePort(nic);
        List<String> securityGroups = getSecurityGroups(vnicProfile);
        String hostId = NetworkUtils.getUniqueHostName(host);
        if (port == null) {
            com.woorea.openstack.quantum.model.Network externalNetwork = getExternalNetwork(network.getProvidedBy());
            Port portForCreate = new Port();
            portForCreate.setAdminStateUp(true);
            portForCreate.setName(nic.getName());
            portForCreate.setTenantId(externalNetwork.getTenantId());
            portForCreate.setMacAddress(nic.getMacAddress());
            portForCreate.setNetworkId(externalNetwork.getId());
            portForCreate.setDeviceOwner(DEVICE_OWNER);
            portForCreate.setDeviceId(nic.getId().toString());
            portForCreate.setSecurityGroups(securityGroups);
            portForCreate.setBinding(new Binding());
            portForCreate.getBinding().setHostId(hostId);
            port = getClient().ports().create(portForCreate).execute();
        } else {
            boolean securityGroupsChanged = securityGroupsChanged(port.getSecurityGroups(), securityGroups);
            boolean hostChanged = hostChanged(port, hostId);
            if (securityGroupsChanged || hostChanged) {
                Port portForUpdate = new PortForUpdate();
                portForUpdate.setId(port.getId());
                portForUpdate.setSecurityGroups(securityGroupsChanged ? securityGroups : port.getSecurityGroups());
                if (hostChanged) {
                    portForUpdate.setBinding(new Binding());
                    portForUpdate.getBinding().setHostId(hostId);
                }
                port = getClient().ports().update(portForUpdate).execute();
            }
        }
        Map<String, String> runtimeProperties = new HashMap<>();
        runtimeProperties.put("vnic_id", port.getId());
        runtimeProperties.put("provider_type", provider.getType().name());
        runtimeProperties.put("plugin_type", provider.getAdditionalProperties().getPluginType());
        if (port.getSecurityGroups() != null && !port.getSecurityGroups().isEmpty()) {
            runtimeProperties.put("security_groups", StringUtils.join(port.getSecurityGroups(), ','));
        }
        return runtimeProperties;
    } catch (RuntimeException e) {
        throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE, e);
    }
}
#end_block

#method_before
private void plugToExternalNetwork() {
    Map<String, String> runtimeProperties = getProviderProxy().allocate(getNetwork(), vnicProfile, getParameters().getNic(), getVds().getHostName());
    if (runtimeProperties != null) {
        getVm().getRuntimeDeviceCustomProperties().put(vmDevice.getId(), runtimeProperties);
    }
}
#method_after
private void plugToExternalNetwork() {
    Map<String, String> runtimeProperties = getProviderProxy().allocate(getNetwork(), vnicProfile, getParameters().getNic(), getVds());
    if (runtimeProperties != null) {
        getVm().getRuntimeDeviceCustomProperties().put(vmDevice.getId(), runtimeProperties);
    }
}
#end_block

#method_before
private void resumeVm() {
    setVdsId(getVm().getRunOnVds());
    if (getVds() != null) {
        initParametersForExternalNetworks();
        try {
            VDSReturnValue result = getBackend().getResourceManager().RunAsyncVdsCommand(VDSCommandType.Resume, new ResumeVDSCommandParameters(getVdsId(), getVm().getId()), this);
            setActionReturnValue(result.getReturnValue());
            setSucceeded(result.getSucceeded());
            ExecutionHandler.setAsyncJob(getExecutionContext(), true);
        } finally {
            freeLock();
        }
    } else {
        setActionReturnValue(getVm().getStatus());
    }
}
#method_after
private void resumeVm() {
    setVdsId(getVm().getRunOnVds());
    if (getVds() != null) {
        try {
            VDSReturnValue result = getBackend().getResourceManager().RunAsyncVdsCommand(VDSCommandType.Resume, new ResumeVDSCommandParameters(getVdsId(), getVm().getId()), this);
            setActionReturnValue(result.getReturnValue());
            setSucceeded(result.getSucceeded());
            ExecutionHandler.setAsyncJob(getExecutionContext(), true);
        } finally {
            freeLock();
        }
    } else {
        setActionReturnValue(getVm().getStatus());
    }
}
#end_block

#method_before
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                    throw e;
                default:
                    log.warnFormat("Failed to run VM {0}: {1}", getVmName(), e.getMessage());
            }
        } finally {
            freeLock();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
            getVm().setStopReason(null);
            getVmDynamicDao().clearStopReason(this.getVm().getId());
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.infoFormat("Trying to rerun VM {0}", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        runningFailed();
    }
}
#method_after
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                    throw e;
                default:
                    log.warnFormat("Failed to run VM {0}: {1}", getVmName(), e.getMessage());
            }
        } finally {
            freeLock();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.infoFormat("Trying to rerun VM {0}", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        runningFailed();
    }
}
#end_block

#method_before
private void statelessVmTreatment() {
    warnIfNotAllDisksPermitSnapshots();
    if (isStatelessSnapshotExistsForVm()) {
        log.errorFormat("VM {0} ({1}) already contains stateless snapshot, removing it", getVm().getName(), getVm().getId());
        removeVmStatlessImages();
    } else {
        log.infoFormat("Creating stateless snapshot for VM {0} ({1})", getVm().getName(), getVm().getId());
        CreateAllSnapshotsFromVmParameters createAllSnapshotsFromVmParameters = buildCreateSnapshotParameters();
        VdcReturnValueBase vdcReturnValue = getBackend().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, createAllSnapshotsFromVmParameters, createContextForStatelessSnapshotCreation());
        // setting lock to null in order not to release lock twice
        setLock(null);
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        } else {
            if (areDisksLocked(vdcReturnValue)) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            }
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.errorFormat("Failed to create stateless snapshot for VM {0} ({1})", getVm().getName(), getVm().getId());
        }
    }
}
#method_after
private void statelessVmTreatment() {
    warnIfNotAllDisksPermitSnapshots();
    if (isStatelessSnapshotExistsForVm()) {
        log.errorFormat("VM {0} ({1}) already contains stateless snapshot, removing it", getVm().getName(), getVm().getId());
        removeVmStatlessImages();
    } else {
        log.infoFormat("Creating stateless snapshot for VM {0} ({1})", getVm().getName(), getVm().getId());
        CreateAllSnapshotsFromVmParameters createAllSnapshotsFromVmParameters = buildCreateSnapshotParameters();
        VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, createAllSnapshotsFromVmParameters, createContextForStatelessSnapshotCreation());
        // setting lock to null in order not to release lock twice
        setLock(null);
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        } else {
            if (areDisksLocked(vdcReturnValue)) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            }
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.errorFormat("Failed to create stateless snapshot for VM {0} ({1})", getVm().getName(), getVm().getId());
        }
    }
}
#end_block

#method_before
private CommandContext createContextForStatelessSnapshotCreation() {
    Map<String, String> values = getVmValuesForMsgResolving();
    // Creating snapshots as sub step of run stateless
    Step createSnapshotsStep = addSubStep(StepEnum.EXECUTING, StepEnum.CREATING_SNAPSHOTS, values);
    // Add the step as the first step of the new context
    ExecutionContext createSnapshotsCtx = new ExecutionContext();
    createSnapshotsCtx.setMonitored(true);
    createSnapshotsCtx.setStep(createSnapshotsStep);
    return new CommandContext(createSnapshotsCtx, getCompensationContext(), getLock());
}
#method_after
private CommandContext createContextForStatelessSnapshotCreation() {
    Map<String, String> values = getVmValuesForMsgResolving();
    // Creating snapshots as sub step of run stateless
    Step createSnapshotsStep = addSubStep(StepEnum.EXECUTING, StepEnum.CREATING_SNAPSHOTS, values);
    // Add the step as the first step of the new context
    ExecutionContext createSnapshotsCtx = new ExecutionContext();
    createSnapshotsCtx.setMonitored(true);
    createSnapshotsCtx.setStep(createSnapshotsStep);
    return cloneContext().withExecutionContext(createSnapshotsCtx);
}
#end_block

#method_before
private void removeVmStatlessImages() {
    Backend.getInstance().runInternalAction(VdcActionType.ProcessDownVm, new IdParameters(getVm().getId()), ExecutionHandler.createDefaultContexForTasks(getExecutionContext(), getLock()));
    // setting lock to null in order not to release lock twice
    setLock(null);
    setSucceeded(true);
}
#method_after
private void removeVmStatlessImages() {
    runInternalAction(VdcActionType.ProcessDownVm, new IdParameters(getVm().getId()), ExecutionHandler.createDefaultContextForTasks(getContext(), getLock()));
    // setting lock to null in order not to release lock twice
    setLock(null);
    setSucceeded(true);
}
#end_block

#method_before
protected void initParametersForExternalNetworks() {
    if (getVm().getInterfaces().isEmpty()) {
        return;
    }
    Map<VmDeviceId, VmDevice> nicDevices = Entities.businessEntitiesById(getDbFacade().getVmDeviceDao().getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.INTERFACE));
    for (VmNic iface : getVm().getInterfaces()) {
        VnicProfile vnicProfile = getDbFacade().getVnicProfileDao().get(iface.getVnicProfileId());
        Network network = NetworkHelper.getNetworkByVnicProfile(vnicProfile);
        VmDevice vmDevice = nicDevices.get(new VmDeviceId(iface.getId(), getVmId()));
        if (network != null && network.isExternal() && vmDevice.getIsPlugged()) {
            Provider<?> provider = getDbFacade().getProviderDao().get(network.getProvidedBy().getProviderId());
            NetworkProviderProxy providerProxy = ProviderProxyFactory.getInstance().create(provider);
            Map<String, String> deviceProperties = providerProxy.allocate(network, vnicProfile, iface, getVds().getHostName());
            getVm().getRuntimeDeviceCustomProperties().put(vmDevice.getId(), deviceProperties);
        }
    }
}
#method_after
protected void initParametersForExternalNetworks() {
    if (getVm().getInterfaces().isEmpty()) {
        return;
    }
    Map<VmDeviceId, VmDevice> nicDevices = Entities.businessEntitiesById(getDbFacade().getVmDeviceDao().getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.INTERFACE));
    for (VmNic iface : getVm().getInterfaces()) {
        VnicProfile vnicProfile = getDbFacade().getVnicProfileDao().get(iface.getVnicProfileId());
        Network network = NetworkHelper.getNetworkByVnicProfile(vnicProfile);
        VmDevice vmDevice = nicDevices.get(new VmDeviceId(iface.getId(), getVmId()));
        if (network != null && network.isExternal() && vmDevice.getIsPlugged()) {
            Provider<?> provider = getDbFacade().getProviderDao().get(network.getProvidedBy().getProviderId());
            NetworkProviderProxy providerProxy = ProviderProxyFactory.getInstance().create(provider);
            Map<String, String> deviceProperties = providerProxy.allocate(network, vnicProfile, iface, getVds());
            getVm().getRuntimeDeviceCustomProperties().put(vmDevice.getId(), deviceProperties);
        }
    }
}
#end_block

#method_before
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    VmDeviceUtils.updateVmDevices(getVm().getStaticData());
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    if (getParameters().getBootMenuEnabled() != null) {
        getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled());
    }
    if (getParameters().getSpiceFileTransferEnabled() != null) {
        getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled());
    }
    if (getParameters().getSpiceCopyPasteEnabled() != null) {
        getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled());
    }
    // Clear the first user:
    getVm().setConsoleUserId(null);
    getVm().setDisplayType(getParameters().getUseVnc() == null ? getVm().getDefaultDisplayType() : // the VM can run with display type which is different from its default display type
    (getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl));
    if (getParameters().getInitializationType() == null) {
        // if vm not initialized, use sysprep/cloud-init
        if (!getVm().isInitialized()) {
            VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                getVm().setInitializationType(InitializationType.Sysprep);
            } else if (getVm().getVmInit() != null) {
                getVm().setInitializationType(InitializationType.CloudInit);
            } else {
                getVm().setInitializationType(InitializationType.None);
            }
        }
    } else {
        getVm().setInitializationType(getParameters().getInitializationType());
    }
    // if we attach floppy we don't need the sysprep
    if (!getVm().isRunOnce() && !StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVmStaticDAO().update(getVm().getStaticData());
    }
    // get what cpu flags should be passed to vdsm according to cluster
    // cpu name
    getVm().setVdsGroupCpuFlagsData(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
    VmHandler.updateVmGuestAgentVersion(getVm());
    getVm().setCpuName(getVdsGroup().getcpu_name());
    if (getFlow() != RunVmFlow.RESUME_HIBERNATE) {
        getVm().setHibernationVolHandle(getMemoryFromSnapshot());
    }
}
#method_after
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    VmDeviceUtils.updateVmDevices(getVm().getStaticData());
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    if (getParameters().getBootMenuEnabled() != null) {
        getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled());
    }
    if (getParameters().getSpiceFileTransferEnabled() != null) {
        getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled());
    }
    if (getParameters().getSpiceCopyPasteEnabled() != null) {
        getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled());
    }
    // Clear the first user:
    getVm().setConsoleUserId(null);
    getVm().setDisplayType(getParameters().getUseVnc() == null ? getVm().getDefaultDisplayType() : // the VM can run with display type which is different from its default display type
    (getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl));
    if (getParameters().getInitializationType() == null) {
        // if vm not initialized, use sysprep/cloud-init
        if (!getVm().isInitialized()) {
            VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                getVm().setInitializationType(InitializationType.Sysprep);
            } else if (getVm().getVmInit() != null) {
                getVm().setInitializationType(InitializationType.CloudInit);
            } else {
                getVm().setInitializationType(InitializationType.None);
            }
        }
    } else {
        getVm().setInitializationType(getParameters().getInitializationType());
    }
    // get what cpu flags should be passed to vdsm according to cluster
    // cpu name
    getVm().setVdsGroupCpuFlagsData(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
    VmHandler.updateVmGuestAgentVersion(getVm());
    getVm().setCpuName(getVdsGroup().getcpu_name());
    if (getFlow() != RunVmFlow.RESUME_HIBERNATE) {
        getVm().setHibernationVolHandle(getMemoryFromSnapshot());
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getCanDoActionMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), getVdsGroup())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getCanDoActionMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), getVdsGroup())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    if (!checkRngDeviceClusterCompatibility()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    return true;
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (isStatelessSnapshotExistsForVm()) {
        getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, buildCreateSnapshotParametersForEndAction());
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), createContextForRunStatelessVm()).getSucceeded());
        if (!getSucceeded()) {
            getParameters().setShouldBeLogged(true);
            log.errorFormat("Could not run VM {0} ({1}) in stateless mode", getVm().getName(), getVm().getId());
            // could not run the vm don't try to run the end action again
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#method_after
@Override
protected void endSuccessfully() {
    if (isStatelessSnapshotExistsForVm()) {
        getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, buildCreateSnapshotParametersForEndAction(), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), createContextForRunStatelessVm()).getSucceeded());
        if (!getSucceeded()) {
            getParameters().setShouldBeLogged(true);
            log.errorFormat("Could not run VM {0} ({1}) in stateless mode", getVm().getName(), getVm().getId());
            // could not run the vm don't try to run the end action again
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#end_block

#method_before
private CommandContext createContextForRunStatelessVm() {
    Step step = getExecutionContext().getStep();
    // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
    // at this is a new instance of the command is used
    // (comparing with the execution state) so all information on the job and steps should be retrieved.
    Job job = JobRepositoryFactory.getJobRepository().getJobWithSteps(step.getJobId());
    Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
    // We would like to to set the run stateless step as substep of executing step
    setInternalExecution(true);
    ExecutionContext runStatelessVmCtx = new ExecutionContext();
    // The internal command should be monitored for tasks
    runStatelessVmCtx.setMonitored(true);
    Step runStatelessStep = ExecutionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
    // This is needed in order to end the job upon execution of the steps of the child command
    runStatelessVmCtx.setShouldEndJob(true);
    runStatelessVmCtx.setJob(job);
    // Since run stateless step involves invocation of command, we should set the run stateless vm step as
    // the "beginning step" of the child command.
    runStatelessVmCtx.setStep(runStatelessStep);
    return new CommandContext(runStatelessVmCtx);
}
#method_after
private CommandContext createContextForRunStatelessVm() {
    Step step = getExecutionContext().getStep();
    // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
    // at this is a new instance of the command is used
    // (comparing with the execution state) so all information on the job and steps should be retrieved.
    Job job = JobRepositoryFactory.getJobRepository().getJobWithSteps(step.getJobId());
    Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
    // We would like to to set the run stateless step as substep of executing step
    setInternalExecution(true);
    ExecutionContext runStatelessVmCtx = new ExecutionContext();
    // The internal command should be monitored for tasks
    runStatelessVmCtx.setMonitored(true);
    Step runStatelessStep = ExecutionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
    // This is needed in order to end the job upon execution of the steps of the child command
    runStatelessVmCtx.setShouldEndJob(true);
    runStatelessVmCtx.setJob(job);
    // Since run stateless step involves invocation of command, we should set the run stateless vm step as
    // the "beginning step" of the child command.
    runStatelessVmCtx.setStep(runStatelessStep);
    return cloneContextAndDetachFromParent().withExecutionContext(runStatelessVmCtx);
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    if (isStatelessSnapshotExistsForVm()) {
        VdcReturnValueBase vdcReturnValue = getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, buildCreateSnapshotParametersForEndAction(), new CommandContext(getCompensationContext()));
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snapshot.
    } else {
        super.endWithFailure();
    }
}
#method_after
@Override
protected void endWithFailure() {
    if (isStatelessSnapshotExistsForVm()) {
        VdcReturnValueBase vdcReturnValue = getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, buildCreateSnapshotParametersForEndAction(), cloneContext().withoutExecutionContext().withoutLock());
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snapshot.
    } else {
        super.endWithFailure();
    }
}
#end_block

#method_before
private List<ExternalComputeResource> mapComputeResource(List<ForemanComputerResource> foremanCrs) {
    ArrayList<ExternalComputeResource> crs = new ArrayList<ExternalComputeResource>(foremanCrs.size());
    for (ForemanComputerResource cr : foremanCrs) {
        ExternalComputeResource computeResource = new ExternalComputeResource();
        computeResource.setName(cr.getName());
        computeResource.setUrl(cr.getUrl());
        computeResource.setId(cr.getId());
        crs.add(computeResource);
    }
    return crs;
}
#method_after
private List<ExternalComputeResource> mapComputeResource(List<ForemanComputerResource> foremanCrs) {
    ArrayList<ExternalComputeResource> crs = new ArrayList<ExternalComputeResource>(foremanCrs.size());
    for (ForemanComputerResource cr : foremanCrs) {
        ExternalComputeResource computeResource = new ExternalComputeResource();
        computeResource.setName(cr.getName());
        computeResource.setUrl(cr.getUrl());
        computeResource.setId(cr.getId());
        computeResource.setProvider(cr.getProvider());
        computeResource.setUser(cr.getUser());
        crs.add(computeResource);
    }
    return crs;
}
#end_block

#method_before
private List<ExternalDiscoveredHost> mapDiscoveredHosts(List<ForemanDiscoveredHost> foremanHosts) {
    ArrayList<ExternalDiscoveredHost> hosts = new ArrayList<ExternalDiscoveredHost>(foremanHosts.size());
    for (ForemanDiscoveredHost host : foremanHosts) {
        ExternalDiscoveredHost dhost = new ExternalDiscoveredHost();
        dhost.setName(host.getName());
        dhost.setIp(host.getIp());
        dhost.setMac(host.getMac());
        hosts.add(dhost);
    }
    return hosts;
}
#method_after
private List<ExternalDiscoveredHost> mapDiscoveredHosts(List<ForemanDiscoveredHost> foremanHosts) {
    ArrayList<ExternalDiscoveredHost> hosts = new ArrayList<ExternalDiscoveredHost>(foremanHosts.size());
    for (ForemanDiscoveredHost host : foremanHosts) {
        ExternalDiscoveredHost dhost = new ExternalDiscoveredHost();
        dhost.setName(host.getName());
        dhost.setIp(host.getIp());
        dhost.setMac(host.getMac());
        dhost.setLastReport(host.getLast_report());
        dhost.setSubnetName(host.getSubnet_name());
        hosts.add(dhost);
    }
    return hosts;
}
#end_block

#method_before
private List<ExternalHostGroup> mapHostGroups(List<ForemanHostGroup> foremanHostGroups) {
    ArrayList<ExternalHostGroup> hostGroups = new ArrayList<ExternalHostGroup>(foremanHostGroups.size());
    for (ForemanHostGroup hostGroup : foremanHostGroups) {
        ExternalHostGroup hostgroup = new ExternalHostGroup();
        hostgroup.setHostgroupId(hostGroup.getId());
        hostgroup.setName(hostGroup.getName());
        hostgroup.setOsId(hostGroup.getOperatingsystem_id());
        hostgroup.setEnvironmentId(hostGroup.getEnvironment_id());
        hostgroup.setDomainId(hostGroup.getDomain_id());
        hostgroup.setSubnetId(hostGroup.getSubnet_id());
        hostgroup.setParameters(hostGroup.getParameters());
        hostgroup.setMediumId(hostGroup.getMedium_id());
        hostgroup.setArchitectureId(hostGroup.getArchitecture_id());
        hostgroup.setPtableId(hostGroup.getPtable_id());
        hostGroups.add(hostgroup);
    }
    return hostGroups;
}
#method_after
private List<ExternalHostGroup> mapHostGroups(List<ForemanHostGroup> foremanHostGroups) {
    ArrayList<ExternalHostGroup> hostGroups = new ArrayList<ExternalHostGroup>(foremanHostGroups.size());
    for (ForemanHostGroup hostGroup : foremanHostGroups) {
        ExternalHostGroup hostgroup = new ExternalHostGroup();
        hostgroup.setHostgroupId(hostGroup.getId());
        hostgroup.setName(hostGroup.getName());
        hostgroup.setOsId(hostGroup.getOperatingsystem_id());
        hostgroup.setEnvironmentId(hostGroup.getEnvironment_id());
        hostgroup.setDomainId(hostGroup.getDomain_id());
        hostgroup.setSubnetId(hostGroup.getSubnet_id());
        hostgroup.setParameters(hostGroup.getParameters());
        hostgroup.setMediumId(hostGroup.getMedium_id());
        hostgroup.setArchitectureId(hostGroup.getArchitecture_id());
        hostgroup.setPtableId(hostGroup.getPtable_id());
        hostgroup.setOperatingsystemName(hostGroup.getOperatingsystem_name());
        hostgroup.setDomainName(hostGroup.getDomain_name());
        hostgroup.setSubnetName(hostGroup.getSubnet_name());
        hostgroup.setArchitectureName(hostGroup.getArchitecture_name());
        hostGroups.add(hostgroup);
    }
    return hostGroups;
}
#end_block

#method_before
@Override
public void provisionHost(VDS vds, ExternalHostGroup hg, ExternalComputeResource computeResource, String mac, String discoverName, String rootPassword) {
    final String entityBody = "{\n" + "    \"discovered_host\": {\n" + "        \"name\": \"" + vds.getName() + "\",\n" + "        \"hostgroup_id\": \"" + hg.getHostgroupId() + "\",\n" + "        \"environment_id\": \"" + hg.getEnvironmentId() + "\",\n" + "        \"mac\": \"" + mac + "\",\n" + "        \"domain_id\": \"" + hg.getDomainId() + "\",\n" + "        \"subnet_id\": \"" + hg.getSubnetId() + "\",\n" + "        \"ip\": \"" + vds.getHostName() + "\",\n" + "        \"architecture_id\": \"" + hg.getArchitectureId() + "\",\n" + "        \"operatingsystem_id\": \"" + hg.getOsId() + "\",\n" + "        \"medium_id\": \"" + hg.getMediumId() + "\",\n" + "        \"ptable_id\": \"" + hg.getPtableId() + "\",\n" + "        \"root_pass\": \"" + rootPassword + "\",\n" + "        \"host_parameters_attributes\": [\n" + "           {\n" + "                \"name\": \"host_ovirt_id\",\n" + "                \"value\": \"" + vds.getStaticData().getId() + "\",\n" + "                \"_destroy\": \"false\",\n" + "                \"nested\": \"\"\n" + "            },\n" + "           {\n" + "                \"name\": \"compute_resource_id\",\n" + "                \"value\": \"" + computeResource.getId() + "\",\n" + "                \"_destroy\": \"false\",\n" + "                \"nested\": \"\"\n" + "            },\n" + "           {\n" + "                \"name\": \"pass\",\n" + // todo: current set pass hardcore to "321321321", waits for alonbl for md5 util and will use also rootPassword field
    "                \"value\": \"" + "$1$s/abrbU5$qSMGyWzwtBAQXLQN0VlQg0" + "\",\n" + "                \"_destroy\": \"false\",\n" + "                \"nested\": \"\"\n" + "            },\n" + "           {\n" + "                \"name\": \"management\",\n" + "                \"value\": \"" + computeResource.getUrl().replaceAll("(http://|/api)", "") + "\",\n" + "                \"_destroy\": \"false\",\n" + "                \"nested\": \"\"\n" + "            }\n" + "        ]\n" + "    }\n" + "}";
    PutMethod httpMethod = new PutMethod(DISCOVERED_HOSTS_ENTRY_POINT + "/" + discoverName);
    RequestEntity entity = new RequestEntity() {

        @Override
        public boolean isRepeatable() {
            return false;
        }

        @Override
        @SuppressWarnings("unchecked")
        public void writeRequest(OutputStream outputStream) throws IOException {
            PrintWriter pr = new PrintWriter(outputStream);
            pr.println(entityBody);
            pr.flush();
        }

        @Override
        @SuppressWarnings("unchecked")
        public long getContentLength() {
            return entityBody.getBytes().length;
        }

        @Override
        public String getContentType() {
            return "application/json";
        }
    };
    httpMethod.setRequestEntity(entity);
    runHttpMethod(httpClient, httpMethod);
}
#method_after
@Override
public void provisionHost(VDS vds, ExternalHostGroup hg, ExternalComputeResource computeResource, String mac, String discoverName, String rootPassword) {
    final String entityBody = "{\n" + "    \"discovered_host\": {\n" + "        \"name\": \"" + vds.getName() + "\",\n" + "        \"hostgroup_id\": \"" + hg.getHostgroupId() + "\",\n" + "        \"environment_id\": \"" + hg.getEnvironmentId() + "\",\n" + "        \"mac\": \"" + mac + "\",\n" + "        \"domain_id\": \"" + hg.getDomainId() + "\",\n" + "        \"subnet_id\": \"" + hg.getSubnetId() + "\",\n" + "        \"ip\": \"" + vds.getHostName() + "\",\n" + "        \"architecture_id\": \"" + hg.getArchitectureId() + "\",\n" + "        \"operatingsystem_id\": \"" + hg.getOsId() + "\",\n" + "        \"medium_id\": \"" + hg.getMediumId() + "\",\n" + "        \"ptable_id\": \"" + hg.getPtableId() + "\",\n" + "        \"root_pass\": \"" + rootPassword + "\",\n" + "        \"host_parameters_attributes\": [\n" + "           {\n" + "                \"name\": \"host_ovirt_id\",\n" + "                \"value\": \"" + vds.getStaticData().getId() + "\",\n" + "                \"_destroy\": \"false\",\n" + "                \"nested\": \"\"\n" + "            },\n" + "           {\n" + "                \"name\": \"compute_resource_id\",\n" + "                \"value\": \"" + computeResource.getId() + "\",\n" + "                \"_destroy\": \"false\",\n" + "                \"nested\": \"\"\n" + "            },\n" + "           {\n" + "                \"name\": \"pass\",\n" + "                \"value\": \"" + CryptMD5.crypt(rootPassword) + "\",\n" + "                \"_destroy\": \"false\",\n" + "                \"nested\": \"\"\n" + "            },\n" + "           {\n" + "                \"name\": \"management\",\n" + "                \"value\": \"" + computeResource.getUrl().replaceAll("(http://|/api)", "") + "\",\n" + "                \"_destroy\": \"false\",\n" + "                \"nested\": \"\"\n" + "            }\n" + "        ]\n" + "    }\n" + "}";
    PutMethod httpMethod = new PutMethod(DISCOVERED_HOSTS_ENTRY_POINT + "/" + discoverName);
    RequestEntity entity = new RequestEntity() {

        @Override
        public boolean isRepeatable() {
            return false;
        }

        @Override
        public void writeRequest(OutputStream outputStream) throws IOException {
            PrintWriter pr = new PrintWriter(new OutputStreamWriter(outputStream, StandardCharsets.UTF_8));
            pr.println(entityBody);
            pr.flush();
        }

        @Override
        public long getContentLength() {
            return entityBody.getBytes(StandardCharsets.UTF_8).length;
        }

        @Override
        public String getContentType() {
            return "application/json";
        }
    };
    httpMethod.setRequestEntity(entity);
    runHttpMethod(httpClient, httpMethod);
}
#end_block

#method_before
public static Map<String, String> buildStoragePoolDomainsMap(List<StoragePoolIsoMap> storagePoolIsoMaps) {
    Map<String, String> storageDomains = new HashMap<String, String>();
    for (StoragePoolIsoMap domain : storagePoolIsoMaps) {
        if (domain.getStatus() == StorageDomainStatus.Maintenance || domain.getStatus() == StorageDomainStatus.PreparingForMaintenance) {
            storageDomains.put(domain.getstorage_id().toString(), "attached");
        } else {
            storageDomains.put(domain.getstorage_id().toString(), StorageDomainStatus.Active.toString().toLowerCase());
        }
    }
    return storageDomains;
}
#method_after
public static Map<String, String> buildStoragePoolDomainsMap(List<StoragePoolIsoMap> storagePoolIsoMaps) {
    Map<String, String> storageDomains = new HashMap<String, String>();
    for (StoragePoolIsoMap domain : storagePoolIsoMaps) {
        if (domain.getStatus() == StorageDomainStatus.Detaching) {
            continue;
        }
        if (domain.getStatus() == StorageDomainStatus.Maintenance || domain.getStatus() == StorageDomainStatus.PreparingForMaintenance || domain.getStatus() == StorageDomainStatus.Activating) {
            storageDomains.put(domain.getstorage_id().toString(), "attached");
        } else {
            storageDomains.put(domain.getstorage_id().toString(), StorageDomainStatus.Active.toString().toLowerCase());
        }
    }
    return storageDomains;
}
#end_block

#method_before
public static boolean refreshHostPoolMetadata(VDS vds, StoragePool storagePool, Guid masterDomainId) {
    try {
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), storagePool.getId(), masterDomainId, storagePool.getmaster_domain_version()));
    } catch (VdcBLLException ex) {
        VDSError error = ex.getVdsError();
        if (error.getCode() != VdcBllErrors.StoragePoolUnknown) {
            log.infoFormat("Failed to refresh host {0} pool {1} metadata with error {2} (message: {3})", vds.getName(), storagePool.getId(), error.getCode(), error.getMessage());
            return false;
        }
        error = null;
        try {
            VDSReturnValue vdsReturnValue = ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), storagePool.getId(), vds.getVdsSpmId(), masterDomainId, storagePool.getmaster_domain_version()));
            if (!vdsReturnValue.getSucceeded()) {
                error = vdsReturnValue.getVdsError();
            }
        } catch (VdcBLLException e) {
            error = e.getVdsError();
        }
        if (error != null) {
            log.infoFormat("Failed to connect host {0} to pool {1} with error {2} (message: {3})", vds.getName(), storagePool.getId(), error.getCode(), error.getMessage());
            return false;
        }
    }
    return true;
}
#method_after
public static boolean refreshHostPoolMetadata(VDS vds, StoragePool storagePool, Guid masterDomainId, List<StoragePoolIsoMap> storagePoolIsoMaps) {
    try {
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, storagePool, masterDomainId, storagePoolIsoMaps, true));
    } catch (VdcBLLException ex) {
        VDSError error = ex.getVdsError();
        if (error.getCode() != VdcBllErrors.StoragePoolUnknown) {
            log.infoFormat("Failed to refresh host {0} pool {1} metadata with error {2} (message: {3})", vds.getName(), storagePool.getId(), error.getCode(), error.getMessage());
            return false;
        }
        error = null;
        try {
            VDSReturnValue vdsReturnValue = ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, storagePool, masterDomainId, storagePoolIsoMaps, false));
            if (!vdsReturnValue.getSucceeded()) {
                error = vdsReturnValue.getVdsError();
            }
        } catch (VdcBLLException e) {
            error = e.getVdsError();
        }
        if (error != null) {
            log.infoFormat("Failed to connect host {0} to pool {1} with error {2} (message: {3})", vds.getName(), storagePool.getId(), error.getCode(), error.getMessage());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public void vdsMovedToMaintenance(VDS vds) {
    try {
        MaintenanceVdsCommand.processStorageOnVdsInactive(vds);
    } finally {
        ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, true);
    }
}
#method_after
@Override
public void vdsMovedToMaintenance(VDS vds) {
    try {
        processStorageOnVdsInactive(vds);
    } finally {
        ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, true);
    }
}
#end_block

#method_before
@Override
public void processOnVmStop(Guid vmId) {
    VmPoolHandler.processVmPoolOnStopVm(vmId, null);
}
#method_after
@Override
public void processOnVmStop(final Collection<Guid> vmIds) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            for (Guid vmId : vmIds) {
                Backend.getInstance().runInternalAction(VdcActionType.ProcessDownVm, new IdParameters(vmId));
            }
        }
    });
}
#end_block

#method_before
@Override
public boolean vdsUpEvent(final VDS vds) {
    HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds);
    boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded();
    if (isSucceeded) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                try {
                    // migrate vms that its their default vds and failback
                    // is on
                    List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId());
                    if (!vmsToMigrate.isEmpty()) {
                        ExecutionContext executionContext = new ExecutionContext();
                        executionContext.setMonitored(true);
                        Backend.getInstance().runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), executionContext);
                    }
                } catch (RuntimeException e) {
                    log.errorFormat("Failed to initialize Vds on up. Error: {0}", e);
                }
            }
        });
    }
    return isSucceeded;
}
#method_after
@Override
public boolean vdsUpEvent(final VDS vds) {
    HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds);
    boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded();
    if (isSucceeded) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                try {
                    // migrate vms that its their default vds and failback
                    // is on
                    List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId());
                    if (!vmsToMigrate.isEmpty()) {
                        CommandContext ctx = new CommandContext(new EngineContext());
                        ctx.getExecutionContext().setMonitored(true);
                        Backend.getInstance().runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx);
                    }
                } catch (RuntimeException e) {
                    log.errorFormat("Failed to initialize Vds on up. Error: {0}", e);
                }
            }
        });
    }
    return isSucceeded;
}
#end_block

#method_before
@Override
public void storagePoolUpEvent(StoragePool storagePool) {
    AsyncTaskManager.getInstance().addStoragePoolExistingTasks(storagePool);
}
#method_after
@Override
public void storagePoolUpEvent(StoragePool storagePool) {
    TaskManagerUtil.addStoragePoolExistingTasks(storagePool);
}
#end_block

#method_before
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    List<OvfEntityData> ovfEntitiesFromTar = Collections.emptyList();
    // Get all unregistered disks.
    List<Disk> unregisteredDisks = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisks, new GetUnregisteredDisksQueryParameters(getParameters().getStorageDomainId(), getVds().getStoragePoolId())).getReturnValue();
    if (!unregisteredDisks.isEmpty()) {
        Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(unregisteredDisks);
        DiskImage ovfDisk = ovfDiskAndSize.getFirst();
        if (ovfDisk != null) {
            try {
                VDSReturnValue retrievedByteData = runVdsCommand(VDSCommandType.RetrieveImageData, new ImageHttpAccessVDSCommandParameters(getVdsId(), getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()));
                if (retrievedByteData.getSucceeded()) {
                    ovfEntitiesFromTar = OvfUtils.getOvfEntities((byte[]) retrievedByteData.getReturnValue(), getParameters().getStorageDomainId());
                }
            } catch (VdcBLLException e) {
                log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}", ovfDisk.getId(), getParameters().getStorageDomainId());
            }
        }
    }
    return ovfEntitiesFromTar;
}
#method_after
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    List<OvfEntityData> ovfEntitiesFromTar = Collections.emptyList();
    boolean isOvfDataRetrieved = false;
    // Get all unregistered disks.
    List<Disk> unregisteredDisks = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisks, new GetUnregisteredDisksQueryParameters(getParameters().getStorageDomainId(), getVds().getStoragePoolId())).getReturnValue();
    if (!unregisteredDisks.isEmpty()) {
        Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(unregisteredDisks);
        DiskImage ovfDisk = ovfDiskAndSize.getFirst();
        if (ovfDisk != null) {
            try {
                VDSReturnValue retrievedByteData = runVdsCommand(VDSCommandType.RetrieveImageData, new ImageHttpAccessVDSCommandParameters(getVdsId(), getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()));
                if (retrievedByteData.getSucceeded()) {
                    ovfEntitiesFromTar = OvfUtils.getOvfEntities((byte[]) retrievedByteData.getReturnValue(), getParameters().getStorageDomainId());
                    isOvfDataRetrieved = true;
                }
            } catch (RuntimeException e) {
                // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                // a RuntimeException if there is a problem to untar the file.
                log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}. Error: {2}", ovfDisk.getId(), getParameters().getStorageDomainId(), e);
            }
        }
    }
    if (!isOvfDataRetrieved) {
        AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
    }
    return ovfEntitiesFromTar;
}
#end_block

#method_before
private boolean isDiskNotShareable(Guid imageId) {
    DiskImage diskImage = getDiskImageByImageId(imageId);
    if (diskImage.isShareable()) {
        addCanDoActionMessage(String.format("$%1$s %2$s", "diskAliases", diskImage.getDiskAlias()));
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SHAREABLE_DISK_NOT_SUPPORTED);
    }
    return true;
}
#method_after
private boolean isDiskNotShareable(Guid imageId) {
    DiskImage diskImage = getDiskImageByImageId(imageId);
    if (diskImage.isShareable()) {
        addCanDoActionMessageVariable("diskAliases", diskImage.getDiskAlias());
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SHAREABLE_DISK_NOT_SUPPORTED);
    }
    return true;
}
#end_block

#method_before
protected boolean validateDestDomainsSpaceRequirements() {
    Map<Guid, List<DiskImage>> storageDomainsImagesMap = new HashMap<Guid, List<DiskImage>>();
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        MultiValueMapUtils.addToMap(parameters.getStorageDomainId(), getDiskImageByImageId(parameters.getImageId()), storageDomainsImagesMap);
    }
    for (Map.Entry<Guid, List<DiskImage>> entry : storageDomainsImagesMap.entrySet()) {
        Guid destDomainId = entry.getKey();
        List<DiskImage> disksList = entry.getValue();
        Guid storagePoolId = disksList.get(0).getStoragePoolId();
        StorageDomain destDomain = getStorageDomainById(destDomainId, storagePoolId);
        if (!isStorageDomainWithinThresholds(destDomain)) {
            return false;
        }
        for (DiskImage diskImage : disksList) {
            Guid templateId = diskImage.getImageTemplateId();
            List<DiskImage> allImageSnapshots = ImagesHandler.getAllImageSnapshots(diskImage.getImageId(), templateId);
            diskImage.getSnapshots().addAll(allImageSnapshots);
        }
        if (!doesStorageDomainHasSpaceForRequest(destDomain, disksList)) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean validateDestDomainsSpaceRequirements() {
    Map<Guid, List<DiskImage>> storageDomainsImagesMap = new HashMap<Guid, List<DiskImage>>();
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        MultiValueMapUtils.addToMap(parameters.getStorageDomainId(), getDiskImageByImageId(parameters.getImageId()), storageDomainsImagesMap);
    }
    for (Map.Entry<Guid, List<DiskImage>> entry : storageDomainsImagesMap.entrySet()) {
        Guid destDomainId = entry.getKey();
        List<DiskImage> disksList = entry.getValue();
        Guid storagePoolId = disksList.get(0).getStoragePoolId();
        StorageDomain destDomain = getStorageDomainById(destDomainId, storagePoolId);
        if (!isStorageDomainWithinThresholds(destDomain)) {
            return false;
        }
        for (DiskImage diskImage : disksList) {
            Guid templateId = diskImage.getImageTemplateId();
            List<DiskImage> allImageSnapshots = ImagesHandler.getAllImageSnapshots(diskImage.getImageId(), templateId);
            diskImage.getSnapshots().addAll(allImageSnapshots);
        }
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator(destDomain);
        if (!validate(storageDomainValidator.hasSpaceForClonedDisks(disksList))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected boolean validateSourceDomainsSpaceRequirements() {
    Map<Guid, List<DiskImage>> storageDomainsActiveImagesMap = new HashMap<>();
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        DiskImage diskImage = getDiskImageByImageId(parameters.getImageId());
        if (diskImage.getActive()) {
            diskImage.getSnapshots().add(diskImage);
            MultiValueMapUtils.addToMap(parameters.getSourceStorageDomainId(), diskImage, storageDomainsActiveImagesMap);
        }
    }
    for (Map.Entry<Guid, List<DiskImage>> entry : storageDomainsActiveImagesMap.entrySet()) {
        Guid sourceDomainId = entry.getKey();
        List<DiskImage> disksList = entry.getValue();
        Guid storagePoolId = disksList.get(0).getStoragePoolId();
        StorageDomain sourceDomain = getStorageDomainById(sourceDomainId, storagePoolId);
        if (!doesStorageDomainHasSpaceForRequest(sourceDomain, disksList)) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean validateSourceDomainsSpaceRequirements() {
    Map<Guid, List<DiskImage>> storageDomainsActiveImagesMap = new HashMap<>();
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        DiskImage diskImage = getDiskImageByImageId(parameters.getImageId());
        MultiValueMapUtils.addToMap(parameters.getSourceStorageDomainId(), diskImage, storageDomainsActiveImagesMap);
    }
    for (Map.Entry<Guid, List<DiskImage>> entry : storageDomainsActiveImagesMap.entrySet()) {
        Guid sourceDomainId = entry.getKey();
        List<DiskImage> disksList = entry.getValue();
        Guid storagePoolId = disksList.get(0).getStoragePoolId();
        StorageDomain sourceDomain = getStorageDomainById(sourceDomainId, storagePoolId);
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator(sourceDomain);
        if (!validate(storageDomainValidator.hasSpaceForNewDisks(disksList))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private SafeHtml createLabelToolTip(Set<String> labels) {
    // $NON-NLS-1$
    SafeHtmlBuilder tooltip = new SafeHtmlBuilder();
    boolean isFirst = true;
    if (labels == null) {
        return null;
    }
    for (String label : labels) {
        if (isFirst) {
            isFirst = false;
        } else {
            // $NON-NLS-1$
            tooltip = tooltip.appendHtmlConstant("<BR>");
        }
        tooltip = tooltip.appendEscaped(label);
    }
    return tooltip.toSafeHtml();
}
#method_after
private SafeHtml createLabelToolTip(Set<String> labels) {
    // $NON-NLS-1$
    SafeHtmlBuilder tooltip = new SafeHtmlBuilder();
    boolean isFirst = true;
    if (labels == null) {
        return null;
    }
    String[] sortedLabels = labels.toArray(new String[] {});
    Arrays.sort(sortedLabels);
    for (String label : sortedLabels) {
        if (isFirst) {
            isFirst = false;
        } else {
            // $NON-NLS-1$
            tooltip = tooltip.appendHtmlConstant("<BR>");
        }
        tooltip = tooltip.appendEscaped(label);
    }
    return tooltip.toSafeHtml();
}
#end_block

#method_before
private boolean isDiskNotShareable(Guid imageId) {
    DiskImage diskImage = getDiskImageByImageId(imageId);
    if (diskImage.isShareable()) {
        addCanDoActionMessage(String.format("$%1$s %2$s", "diskAliases", diskImage.getDiskAlias()));
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SHAREABLE_DISK_NOT_SUPPORTED);
    }
    return true;
}
#method_after
private boolean isDiskNotShareable(Guid imageId) {
    DiskImage diskImage = getDiskImageByImageId(imageId);
    if (diskImage.isShareable()) {
        addCanDoActionMessageVariable("diskAliases", diskImage.getDiskAlias());
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SHAREABLE_DISK_NOT_SUPPORTED);
    }
    return true;
}
#end_block

#method_before
protected boolean isValidSpaceRequirements() {
    Map<Guid, List<DiskImage>> storageDomainsImagesMap = new HashMap<Guid, List<DiskImage>>();
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        MultiValueMapUtils.addToMap(parameters.getStorageDomainId(), getDiskImageByImageId(parameters.getImageId()), storageDomainsImagesMap);
    }
    for (Map.Entry<Guid, List<DiskImage>> entry : storageDomainsImagesMap.entrySet()) {
        Guid destDomainId = entry.getKey();
        List<DiskImage> disksList = entry.getValue();
        Guid storagePoolId = disksList.get(0).getStoragePoolId();
        StorageDomain destDomain = getStorageDomainById(destDomainId, storagePoolId);
        if (!isStorageDomainWithinThresholds(destDomain)) {
            return false;
        }
        for (DiskImage diskImage : disksList) {
            Guid templateId = diskImage.getImageTemplateId();
            List<DiskImage> allImageSnapshots = ImagesHandler.getAllImageSnapshots(diskImage.getImageId(), templateId);
            diskImage.getSnapshots().addAll(allImageSnapshots);
        }
        if (!doesStorageDomainHasSpaceForRequest(destDomain, disksList)) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean isValidSpaceRequirements() {
    Map<Guid, List<DiskImage>> storageDomainsImagesMap = new HashMap<Guid, List<DiskImage>>();
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        MultiValueMapUtils.addToMap(parameters.getStorageDomainId(), getDiskImageByImageId(parameters.getImageId()), storageDomainsImagesMap);
    }
    for (Map.Entry<Guid, List<DiskImage>> entry : storageDomainsImagesMap.entrySet()) {
        Guid destDomainId = entry.getKey();
        List<DiskImage> disksList = entry.getValue();
        Guid storagePoolId = disksList.get(0).getStoragePoolId();
        StorageDomain destDomain = getStorageDomainById(destDomainId, storagePoolId);
        if (!isStorageDomainWithinThresholds(destDomain)) {
            return false;
        }
        for (DiskImage diskImage : disksList) {
            Guid templateId = diskImage.getImageTemplateId();
            List<DiskImage> allImageSnapshots = ImagesHandler.getAllImageSnapshots(diskImage.getImageId(), templateId);
            diskImage.getSnapshots().addAll(allImageSnapshots);
        }
        if (!doesStorageDomainHaveSpaceForRequest(destDomain, disksList)) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    ClusterModel clusterModel = new ClusterModel();
    clusterModel.init(false);
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().newClusterTitle());
    clusterModel.setHelpTag(HelpTag.new_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("new_cluster");
    clusterModel.setIsNew(true);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterListModel clModel = (ClusterListModel) model;
            ClusterModel cModel = (ClusterModel) clModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            cModel.getDataCenter().setItems(dataCenters);
            // Strict data center as neccessary.
            if (clModel.getSystemTreeSelectedItem() != null && clModel.getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
                StoragePool selectDataCenter = (StoragePool) clModel.getSystemTreeSelectedItem().getEntity();
                cModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(selectDataCenter.getId())));
                cModel.getDataCenter().setIsChangable(false);
            } else {
                cModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    ClusterModel clusterModel = new ClusterModel();
    clusterModel.init(false);
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().newClusterTitle());
    clusterModel.setHelpTag(HelpTag.new_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("new_cluster");
    clusterModel.setIsNew(true);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterListModel clModel = (ClusterListModel) model;
            ClusterModel cModel = (ClusterModel) clModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            cModel.getDataCenter().setItems(dataCenters);
            // Strict data center as neccessary.
            if (clModel.getSystemTreeSelectedItem() != null && clModel.getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
                SystemTreeItemModel treeSelectedItem = clModel.getSystemTreeSelectedItem();
                SystemTreeItemModel treeSelectedDc = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, treeSelectedItem);
                StoragePool selectDataCenter = (StoragePool) treeSelectedDc.getEntity();
                cModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(selectDataCenter.getId())));
                cModel.getDataCenter().setIsChangable(false);
            } else {
                cModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnSave", clModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            cModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("Cancel", clModel);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            cModel.getCommands().add(tempVar2);
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#end_block

#method_before
private String typeAheadNameDescriptionTemplateNullSafe(String name, String description) {
    return applicationTemplates.typeAheadNameDescription(name != null ? name : "", description != null ? description : "").asString();
}
#method_after
private String typeAheadNameDescriptionTemplateNullSafe(String name, String description) {
    return applicationTemplates.typeAheadNameDescription(name != null ? name : constants.empty(), description != null ? description : constants.empty()).asString();
}
#end_block

#method_before
@Override
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    // TODO should be handled in a more generic way
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsPowerManagementTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsPowerManagementTabValid()) {
                    powerManagementTab.markAsValid();
                } else {
                    powerManagementTab.markAsInvalid(null);
                }
            }
        }
    });
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            fetchResult.setText((String) object.getFetchResult().getEntity());
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    object.getProviders().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            object.updateHosts();
        }
    });
    object.getExternalHostProviderEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean showForemanProviders = object.getExternalHostProviderEnabled().getEntity();
            providersEditor.setVisible(showForemanProviders);
            provisionedHostSection.setVisible(showForemanProviders);
            discoveredHostSection.setVisible(showForemanProviders);
            if (showForemanProviders) {
                object.updateHosts();
            } else {
                object.cleanHostParametersFields();
                hideProviderWidgets(object);
            }
        }
    });
    object.getIsDiscorveredHosts().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getIsDiscorveredHosts().getEntity() == true) {
                rbDiscoveredHost.setValue(true);
                showDiscoveredHostsWidgets(true);
            } else {
                rbProvisionedHost.setValue(true);
                showProvisionedHostsWidgets(true);
            }
        }
    });
    rbPassword.setValue(true);
    rbPassword.setFocus(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List<String> items = (List<String>) object.getPmProxyPreferencesList().getItems();
            String selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener spmListener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
}
#method_after
@Override
@SuppressWarnings("unchecked")
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    // TODO should be handled in a more generic way
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsPowerManagementTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsPowerManagementTabValid()) {
                    powerManagementTab.markAsValid();
                } else {
                    powerManagementTab.markAsInvalid(null);
                }
            }
        }
    });
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            fetchResult.setText((String) object.getFetchResult().getEntity());
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    object.getProviders().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            object.updateHosts();
        }
    });
    object.getExternalHostProviderEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean showForemanProviders = object.getExternalHostProviderEnabled().getEntity();
            providersEditor.setVisible(showForemanProviders);
            provisionedHostSection.setVisible(showForemanProviders);
            discoveredHostSection.setVisible(showForemanProviders);
            if (showForemanProviders) {
                object.updateHosts();
            } else {
                object.cleanHostParametersFields();
                hideProviderWidgets(object);
            }
        }
    });
    object.getIsDiscorveredHosts().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getIsDiscorveredHosts().getEntity() == true) {
                rbDiscoveredHost.setValue(true);
                showDiscoveredHostsWidgets(true);
            } else {
                rbProvisionedHost.setValue(true);
                showProvisionedHostsWidgets(true);
            }
        }
    });
    rbPassword.setValue(true);
    rbPassword.setFocus(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List<String> items = (List<String>) object.getPmProxyPreferencesList().getItems();
            String selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener spmListener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final VDS vds = getVds();
    try (EngineLock monitoringLock = acquireMonitorLock()) {
        ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, false);
        runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Unassigned));
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.ActivateVds, new ActivateVdsVDSCommandParameters(getVdsId()));
        setSucceeded(returnValue.getSucceeded());
        if (getSucceeded()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    // set network to operational / non-operational
                    List<Network> networks = getNetworkDAO().getAllForCluster(vds.getVdsGroupId());
                    for (Network net : networks) {
                        NetworkClusterHelper.setStatus(vds.getVdsGroupId(), net);
                    }
                    return null;
                }
            });
            if (vds.getHighlyAvailableIsConfigured()) {
                SetHaMaintenanceModeVDSCommandParameters param = new SetHaMaintenanceModeVDSCommandParameters(vds, HaMaintenanceMode.LOCAL, false);
                if (!runVdsCommand(VDSCommandType.SetHaMaintenanceMode, param).getSucceeded()) {
                    haMaintenanceFailed = true;
                }
            }
        }
    }
    logMonitorLockReleased("Activate");
}
#method_after
@Override
protected void executeCommand() {
    final VDS vds = getVds();
    try (EngineLock monitoringLock = acquireMonitorLock()) {
        ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, false);
        setSucceeded(runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Unassigned)).getSucceeded());
        if (getSucceeded()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    // set network to operational / non-operational
                    List<Network> networks = getNetworkDAO().getAllForCluster(vds.getVdsGroupId());
                    for (Network net : networks) {
                        NetworkClusterHelper.setStatus(vds.getVdsGroupId(), net);
                    }
                    return null;
                }
            });
            if (vds.getHighlyAvailableIsConfigured()) {
                SetHaMaintenanceModeVDSCommandParameters param = new SetHaMaintenanceModeVDSCommandParameters(vds, HaMaintenanceMode.LOCAL, false);
                if (!runVdsCommand(VDSCommandType.SetHaMaintenanceMode, param).getSucceeded()) {
                    haMaintenanceFailed = true;
                }
            }
        }
    }
    logMonitorLockReleased("Activate");
}
#end_block

#method_before
protected VdcReturnValueBase executeChildCommand(Guid idInCommandsMap) {
    CommandBase<?> command = childCommandsMap.get(idInCommandsMap);
    return getBackendCommandObjectsHandler().runAction(command, getExecutionContext());
}
#method_after
protected VdcReturnValueBase executeChildCommand(Guid idInCommandsMap) {
    CommandBase<?> command = childCommandsMap.get(idInCommandsMap);
    return BackendUtils.getBackendCommandObjectsHandler(log).runAction(command, getExecutionContext());
}
#end_block

#method_before
protected VdcReturnValueBase attemptRollback(VdcActionType commandType, VdcActionParametersBase params, CommandContext rollbackContext) {
    if (canPerformRollbackUsingCommand(commandType, params)) {
        params.setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        params.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        return getBackend().runInternalAction(commandType, params, rollbackContext);
    }
    return new VdcReturnValueBase();
}
#method_after
protected VdcReturnValueBase attemptRollback(VdcActionType commandType, VdcActionParametersBase params) {
    if (canPerformRollbackUsingCommand(commandType, params)) {
        params.setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        params.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        return getBackend().runInternalAction(commandType, params, context.clone());
    }
    return new VdcReturnValueBase();
}
#end_block

#method_before
protected VdcReturnValueBase checkAndPerformRollbackUsingCommand(VdcActionType commandType, VdcActionParametersBase params) {
    return attemptRollback(commandType, params, null);
}
#method_after
protected VdcReturnValueBase checkAndPerformRollbackUsingCommand(VdcActionType commandType, VdcActionParametersBase params) {
    return attemptRollback(commandType, params);
}
#end_block

#method_before
public void setCompensationContext(CompensationContext compensationContext) {
    context.setCompensationContext(compensationContext);
}
#method_after
public void setCompensationContext(CompensationContext compensationContext) {
    context.withCompensationContext(compensationContext);
}
#end_block

#method_before
public VdcReturnValueBase executeAction() {
    determineExecutionReason();
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed = false;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        actionAllowed = getReturnValue().getCanDoAction() || internalCanDoAction();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setCanDoAction(false);
        }
    } finally {
        freeLockExecute();
        if (!getReturnValue().getSucceeded()) {
            clearAsyncTasksWithOutVdsmId();
        }
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase executeAction() {
    determineExecutionReason();
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed = false;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        actionAllowed = getReturnValue().getCanDoAction() || internalCanDoAction();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setCanDoAction(false);
        }
    } finally {
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#end_block

#method_before
private void clearAsyncTasksWithOutVdsmId() {
    if (!getReturnValue().getTaskPlaceHolderIdList().isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (Guid asyncTaskId : getReturnValue().getTaskPlaceHolderIdList()) {
                    AsyncTasks task = getAsyncTaskDao().get(asyncTaskId);
                    if (task != null && Guid.isNullOrEmpty(task.getVdsmTaskId())) {
                        AsyncTaskManager.removeTaskFromDbByTaskId(task.getTaskId());
                    }
                }
                return null;
            }
        });
    }
}
#method_after
private void clearAsyncTasksWithOutVdsmId() {
    if (!getReturnValue().getTaskPlaceHolderIdList().isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (Guid asyncTaskId : getReturnValue().getTaskPlaceHolderIdList()) {
                    AsyncTasks task = TaskManagerUtil.getAsyncTaskFromDb(asyncTaskId);
                    if (task != null && Guid.isNullOrEmpty(task.getVdsmTaskId())) {
                        TaskManagerUtil.removeTaskFromDbByTaskId(task.getTaskId());
                    }
                }
                return null;
            }
        });
    }
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.CHANGED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case CHANGED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case DELETED_OR_UPDATED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case UPDATED_ONLY_ENTITY:
                        daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#end_block

#method_before
private void initiateLockEndAction() {
    if (commandLock == null) {
        LockProperties lockProperties = getLockProperties();
        if (lockProperties != null && !lockProperties.isReleaseAtEndOfExecute()) {
            commandLock = buildLock();
        }
    }
}
#method_after
private void initiateLockEndAction() {
    if (context.getLock() == null) {
        LockProperties lockProperties = getLockProperties();
        if (Scope.Command.equals(lockProperties.getScope())) {
            context.withLock(buildLock());
        }
    }
}
#end_block

#method_before
private void handleTransactivity() {
    scope = (getParameters() != null) ? getParameters().getTransactionScopeOption() : TransactionScopeOption.Required;
    endActionScope = scope;
    boolean forceCompensation = getForceCompensation();
    // command parameters
    if (!getTransactive()) {
        scope = TransactionScopeOption.Suppress;
        // Set the end action scope to suppress only for non-compensating commands, or the end action for commands
        // will run without transaction but compensation is not supported for end action.
        endActionScope = forceCompensation ? endActionScope : scope;
    }
    if (getCompensationContext() == null) {
        context.setCompensationContext(createCompensationContext(scope, forceCompensation));
    }
}
#method_after
private void handleTransactivity() {
    scope = (getParameters() != null) ? getParameters().getTransactionScopeOption() : TransactionScopeOption.Required;
    endActionScope = scope;
    boolean forceCompensation = getForceCompensation();
    // command parameters
    if (!getTransactive()) {
        scope = TransactionScopeOption.Suppress;
        // Set the end action scope to suppress only for non-compensating commands, or the end action for commands
        // will run without transaction but compensation is not supported for end action.
        endActionScope = forceCompensation ? endActionScope : scope;
    }
    if (getCompensationContext() == null) {
        context.withCompensationContext(createCompensationContext(scope, forceCompensation));
    }
}
#end_block

#method_before
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            internalEndSuccessfully();
        } else {
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#method_after
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            setCommandStatus(CommandStatus.SUCCEEDED);
            internalEndSuccessfully();
        } else {
            setCommandStatus(CommandStatus.FAILED);
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#end_block

#method_before
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = new AuditLogableBase();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#method_after
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = new AuditLogableBase();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            logable.addCustomValue("UserName", getCurrentUser().getLoginName());
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#end_block

#method_before
private boolean internalValidateAndSetQuota() {
    // Quota accounting is done only in the most external Command.
    if (isInternalExecution() || !isQuotaDependant()) {
        return true;
    }
    QuotaConsumptionParametersWrapper quotaConsumptionParametersWrapper = new QuotaConsumptionParametersWrapper(this, getReturnValue().getCanDoActionMessages());
    quotaConsumptionParametersWrapper.setParameters(getQuotaConsumptionParameters());
    List<QuotaConsumptionParameter> quotaParams = quotaConsumptionParametersWrapper.getParameters();
    if (quotaParams == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". No Quota parameters available.");
    }
    // scenarios like this must set its QuotaConsumptionParameter to an empty list.
    if (quotaParams.isEmpty()) {
        return true;
    }
    if (getStoragePool() == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". Storage pool is not available for quota calculation. ");
    }
    boolean result = getQuotaManager().consume(quotaConsumptionParametersWrapper);
    setQuotaChanged(result);
    return result;
}
#method_after
private boolean internalValidateAndSetQuota() {
    // Quota accounting is done only in the most external Command.
    if (!isQuotaDependant()) {
        return true;
    }
    QuotaConsumptionParametersWrapper quotaConsumptionParametersWrapper = new QuotaConsumptionParametersWrapper(this, getReturnValue().getCanDoActionMessages());
    quotaConsumptionParametersWrapper.setParameters(getQuotaConsumptionParameters());
    List<QuotaConsumptionParameter> quotaParams = quotaConsumptionParametersWrapper.getParameters();
    if (quotaParams == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". No Quota parameters available.");
    }
    // scenarios like this must set its QuotaConsumptionParameter to an empty list.
    if (quotaParams.isEmpty()) {
        return true;
    }
    if (getStoragePool() == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". Storage pool is not available for quota calculation. ");
    }
    boolean result = getQuotaManager().consume(quotaConsumptionParametersWrapper);
    setQuotaChanged(result);
    return result;
}
#end_block

#method_before
private boolean isQuotaDependant() {
    return getActionType().getQuotaDependency() != VdcActionType.QuotaDependency.NONE;
}
#method_after
protected boolean isQuotaDependant() {
    boolean result;
    if (getActionType().getQuotaDependency() == VdcActionType.QuotaDependency.NONE)
        result = false;
    else if (!isInternalExecution())
        result = true;
    else if (getActionType().isQuotaDependentAsInternalCommand())
        result = true;
    else
        result = false;
    return result;
}
#end_block

#method_before
protected boolean checkUserAndGroupsAuthorization(Guid userId, String groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, groupIds, actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#method_after
protected boolean checkUserAndGroupsAuthorization(Guid userId, HashSet<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    // if quota enforcement is not in HARD_ENFORCEMENT the quota may be null.
    if (!isInternalExecution() && getStoragePool() != null && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT) {
        List<QuotaConsumptionParameter> consumptionParameters = getQuotaConsumptionParameters();
        if (consumptionParameters != null) {
            for (QuotaConsumptionParameter parameter : getQuotaConsumptionParameters()) {
                if (parameter.getQuotaGuid() != null && !Guid.Empty.equals(parameter.getQuotaGuid()) && !QuotaConsumptionParameter.QuotaAction.RELEASE.equals(parameter.getQuotaAction())) {
                    quotaPermissionList.add(new PermissionSubject(parameter.getQuotaGuid(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA, VdcBllMessages.USER_NOT_AUTHORIZED_TO_CONSUME_QUOTA));
                }
            }
        }
    }
}
#method_after
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    // if quota enforcement is not in HARD_ENFORCEMENT the quota may be null.
    if (!isInternalExecution() && getStoragePool() != null && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT) {
        List<QuotaConsumptionParameter> consumptionParameters = getQuotaConsumptionParameters();
        if (consumptionParameters != null) {
            for (QuotaConsumptionParameter parameter : consumptionParameters) {
                if (parameter.getQuotaGuid() != null && !Guid.Empty.equals(parameter.getQuotaGuid()) && !QuotaConsumptionParameter.QuotaAction.RELEASE.equals(parameter.getQuotaAction())) {
                    quotaPermissionList.add(new PermissionSubject(parameter.getQuotaGuid(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA, VdcBllMessages.USER_NOT_AUTHORIZED_TO_CONSUME_QUOTA));
                }
            }
        }
    }
}
#end_block

#method_before
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            compensate();
        } else {
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#method_after
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setSucceeded(false);
            compensate();
        } else {
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#end_block

#method_before
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#method_after
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (log.isDebugEnabled()) {
        logInfo.append(getParameters() != null ? "(" + getCommandParamatersString(getParameters()) + ")" : StringUtils.EMPTY);
    }
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#end_block

#method_before
protected final void execute() {
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logRenamedEntity();
                logCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#method_after
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logRenamedEntity();
                logCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#end_block

#method_before
private boolean hasTasks() {
    return !getReturnValue().getVdsmTaskIdList().isEmpty();
}
#method_after
public boolean hasTasks() {
    return !getReturnValue().getVdsmTaskIdList().isEmpty();
}
#end_block

#method_before
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = getBackendCommandObjectsHandler().createAction(entry.getValue().getFirst(), entry.getValue().getSecond());
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#method_after
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = BackendUtils.getBackendCommandObjectsHandler(log).createAction(entry.getValue().getFirst(), entry.getValue().getSecond(), context);
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#end_block

#method_before
private void saveTaskAndPutInMap(String taskKey, AsyncTasks task) {
    getAsyncTaskDao().save(task);
    taskKeyToTaskIdMap.put(taskKey, task.getTaskId());
}
#method_after
private void saveTaskAndPutInMap(String taskKey, AsyncTasks task) {
    TaskManagerUtil.saveAsyncTaskToDb(task);
    taskKeyToTaskIdMap.put(taskKey, task.getTaskId());
}
#end_block

#method_before
public void deleteAsyncTaskPlaceHolder(String taskKey) {
    Guid taskId = taskKeyToTaskIdMap.remove(taskKey);
    if (!Guid.isNullOrEmpty(taskId)) {
        AsyncTaskManager.removeTaskFromDbByTaskId(taskId);
    }
}
#method_after
public void deleteAsyncTaskPlaceHolder(String taskKey) {
    Guid taskId = taskKeyToTaskIdMap.remove(taskKey);
    if (!Guid.isNullOrEmpty(taskId)) {
        TaskManagerUtil.removeTaskFromDbByTaskId(taskId);
    }
}
#end_block

#method_before
private Guid createTaskImpl(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    Step taskStep = ExecutionHandler.addTaskStep(getExecutionContext(), StepEnum.getStepNameByTaskType(asyncTaskCreationInfo.getTaskType()), description);
    if (taskStep != null) {
        asyncTaskCreationInfo.setStepId(taskStep.getId());
    }
    SPMAsyncTask task = concreteCreateTask(taskId, asyncTaskCreationInfo, parentCommand);
    task.setEntitiesMap(entitiesMap);
    AsyncTaskUtils.addOrUpdateTaskInDB(task);
    getAsyncTaskManager().lockAndAddTaskToManager(task);
    Guid vdsmTaskId = task.getVdsmTaskId();
    ExecutionHandler.updateStepExternalId(taskStep, vdsmTaskId, ExternalSystemType.VDSM);
    return vdsmTaskId;
}
#method_after
private Guid createTaskImpl(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    return TaskManagerUtil.createTask(taskId, this, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
}
#end_block

#method_before
public SPMAsyncTask concreteCreateTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, getAsyncTask(taskId, asyncTaskCreationInfo, parentCommand));
    p.setEntityInfo(getParameters().getEntityInfo());
    return createTask(internalGetTaskType(), p);
}
#method_after
public SPMTask concreteCreateTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return TaskManagerUtil.concreteCreateTask(taskId, this, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
private VdcActionParametersBase getParentParameters(VdcActionType parentCommand) {
    VdcActionParametersBase parentParameters = getParametersForTask(parentCommand, getParameters());
    if (parentParameters.getParametersCurrentUser() == null && getCurrentUser() != null) {
        parentParameters.setParametersCurrentUser(getCurrentUser());
    }
    return parentParameters;
}
#method_after
public VdcActionParametersBase getParentParameters(VdcActionType parentCommand) {
    VdcActionParametersBase parentParameters = getParametersForTask(parentCommand, getParameters());
    if (parentParameters.getParametersCurrentUser() == null && getCurrentUser() != null) {
        parentParameters.setParametersCurrentUser(getCurrentUser());
    }
    return parentParameters;
}
#end_block

#method_before
private AsyncTasks createAsyncTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    VdcActionParametersBase parentParameters = getParentParameters(parentCommand);
    return new AsyncTasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getVdsmTaskId(), parentParameters, getParameters(), asyncTaskCreationInfo.getStepId(), getCommandId(), parentParameters.getCommandId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType());
}
#method_after
private AsyncTasks createAsyncTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return TaskManagerUtil.createAsyncTask(this, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
protected AsyncTaskType getTaskType() {
    throw new UnsupportedOperationException();
}
#method_after
protected AsyncTaskType getTaskType() {
    return AsyncTaskType.notSupported;
}
#end_block

#method_before
protected void startPollingAsyncTasks(Collection<Guid> taskIds) {
    for (Guid taskID : taskIds) {
        getAsyncTaskManager().startPollingTask(taskID);
    }
}
#method_after
protected void startPollingAsyncTasks(Collection<Guid> taskIds) {
    for (Guid taskID : taskIds) {
        TaskManagerUtil.startPollingTask(taskID);
    }
}
#end_block

#method_before
private void cancelTasks() {
    if (hasTasks()) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                log.infoFormat("Rollback for command: {0}.", CommandBase.this.getClass().getName());
                try {
                    getAsyncTaskManager().cancelTasks(getReturnValue().getVdsmTaskIdList());
                } catch (Exception e) {
                    log.errorFormat("Failed to cancel tasks for command: {0}.", CommandBase.this.getClass().getName());
                }
            }
        });
    }
}
#method_after
private void cancelTasks() {
    TaskManagerUtil.cancelTasks(this);
}
#end_block

#method_before
protected void revertTasks() {
    if (getParameters().getVdsmTaskIds() != null) {
        // list to send to the pollTasks method
        ArrayList<Guid> taskIdAsList = new ArrayList<Guid>();
        for (Guid taskId : getParameters().getVdsmTaskIds()) {
            taskIdAsList.add(taskId);
            ArrayList<AsyncTaskStatus> tasksStatuses = getAsyncTaskManager().pollTasks(taskIdAsList);
            // call revert task only if ended successfully
            if (tasksStatuses.get(0).getTaskEndedSuccessfully()) {
                getBackend().getResourceManager().RunVdsCommand(VDSCommandType.SPMRevertTask, new SPMTaskGuidBaseVDSCommandParameters(getStoragePool().getId(), taskId));
            }
            taskIdAsList.clear();
        }
    }
}
#method_after
protected void revertTasks() {
    TaskManagerUtil.revertTasks(this);
}
#end_block

#method_before
protected EngineLock getLock() {
    return commandLock;
}
#method_after
protected EngineLock getLock() {
    return context.getLock();
}
#end_block

#method_before
protected void setLock(EngineLock lock) {
    commandLock = lock;
}
#method_after
protected void setLock(EngineLock lock) {
    context.withLock(lock);
}
#end_block

#method_before
protected LockProperties getLockProperties() {
    return LockProperties.build(getClass().getAnnotation(LockIdNameAttribute.class));
}
#method_after
protected LockProperties getLockProperties() {
    LockProperties lockProperties = _parameters.getLockProperties();
    if (lockProperties == null) {
        lockProperties = applyLockProperties(getLockingPropertiesSettings());
        _parameters.setLockProperties(lockProperties);
    }
    return lockProperties;
}
#end_block

#method_before
protected boolean acquireLock() {
    LockProperties lockProperties = getLockProperties();
    boolean returnValue = true;
    if (lockProperties != null) {
        releaseLocksAtEndOfExecute = lockProperties.isReleaseAtEndOfExecute();
        if (!lockProperties.isWait()) {
            returnValue = acquireLockInternal();
        } else {
            acquireLockAndWait();
        }
    }
    return returnValue;
}
#method_after
protected boolean acquireLock() {
    LockProperties lockProperties = getLockProperties();
    boolean returnValue = true;
    if (!Scope.None.equals(lockProperties.getScope())) {
        releaseLocksAtEndOfExecute = Scope.Execution.equals(lockProperties.getScope());
        if (!lockProperties.isWait()) {
            returnValue = acquireLockInternal();
        } else {
            acquireLockAndWait();
        }
    }
    return returnValue;
}
#end_block

#method_before
public final boolean acquireLockAsyncTask() {
    LockProperties lockProperties = getLockProperties();
    boolean returnValue = true;
    if (lockProperties != null) {
        releaseLocksAtEndOfExecute = lockProperties.isReleaseAtEndOfExecute();
        if (!releaseLocksAtEndOfExecute) {
            returnValue = acquireLockInternal();
        }
    }
    return returnValue;
}
#method_after
public final boolean acquireLockAsyncTask() {
    LockProperties lockProperties = getLockProperties();
    boolean returnValue = true;
    if (!Scope.None.equals(lockProperties.getScope())) {
        releaseLocksAtEndOfExecute = Scope.Execution.equals(lockProperties.getScope());
        if (!releaseLocksAtEndOfExecute) {
            returnValue = acquireLockInternal();
        }
    }
    return returnValue;
}
#end_block

#method_before
protected boolean acquireLockInternal() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (commandLock == null) {
        EngineLock lock = buildLock();
        if (lock != null) {
            Pair<Boolean, Set<String>> lockAcquireResult = getLockManager().acquireLock(lock);
            if (lockAcquireResult.getFirst()) {
                log.infoFormat("Lock Acquired to object {0}", lock);
                commandLock = lock;
            } else {
                log.infoFormat("Failed to Acquire Lock to object {0}", lock);
                getReturnValue().getCanDoActionMessages().addAll(extractVariableDeclarations(lockAcquireResult.getSecond()));
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean acquireLockInternal() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        EngineLock lock = buildLock();
        if (lock != null) {
            Pair<Boolean, Set<String>> lockAcquireResult = getLockManager().acquireLock(lock);
            if (lockAcquireResult.getFirst()) {
                log.infoFormat("Lock Acquired to object {0}", lock);
                context.withLock(lock);
            } else {
                log.infoFormat("Failed to Acquire Lock to object {0}", lock);
                getReturnValue().getCanDoActionMessages().addAll(extractVariableDeclarations(lockAcquireResult.getSecond()));
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
private void acquireLockAndWait() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (commandLock == null) {
        Map<String, Pair<String, String>> exclusiveLocks = getExclusiveLocks();
        if (exclusiveLocks != null) {
            EngineLock lock = new EngineLock(exclusiveLocks, null);
            getLockManager().acquireLockWait(lock);
            commandLock = lock;
        }
    }
}
#method_after
private void acquireLockAndWait() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        Map<String, Pair<String, String>> exclusiveLocks = getExclusiveLocks();
        if (exclusiveLocks != null) {
            EngineLock lock = new EngineLock(exclusiveLocks, null);
            getLockManager().acquireLockWait(lock);
            context.withLock(lock);
        }
    }
}
#end_block

#method_before
protected void freeLock() {
    if (commandLock != null) {
        getLockManager().releaseLock(commandLock);
        log.infoFormat("Lock freed to object {0}", commandLock);
        commandLock = null;
    }
}
#method_after
protected void freeLock() {
    if (context.getLock() != null) {
        getLockManager().releaseLock(context.getLock());
        log.infoFormat("Lock freed to object {0}", context.getLock());
        context.withLock(null);
    }
}
#end_block

#method_before
public void setExecutionContext(ExecutionContext executionContext) {
    context.setExecutionContext(executionContext);
}
#method_after
public void setExecutionContext(ExecutionContext executionContext) {
    context.withExecutionContext(executionContext);
}
#end_block

#method_before
protected boolean hasTaskHandlers() {
    return getTaskHandlers() != null;
}
#method_after
public boolean hasTaskHandlers() {
    return getTaskHandlers() != null;
}
#end_block

#method_before
protected SPMAsyncTaskHandler getCurrentTaskHandler() {
    return getTaskHandlers().get(getExecutionIndex());
}
#method_after
public SPMAsyncTaskHandler getCurrentTaskHandler() {
    return getTaskHandlers().get(getExecutionIndex());
}
#end_block

#method_before
@Mapping(from = CloudInit.class, to = VmInit.class)
public static VmInit map(CloudInit model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    if (model.isSetHost() && model.getHost().isSetAddress()) {
        entity.setHostname(model.getHost().getAddress());
    }
    if (model.isSetAuthorizedKeys() && model.getAuthorizedKeys().isSetAuthorizedKeys() && !model.getAuthorizedKeys().getAuthorizedKeys().isEmpty()) {
        StringBuilder keys = new StringBuilder();
        for (AuthorizedKey authKey : model.getAuthorizedKeys().getAuthorizedKeys()) {
            if (keys.length() > 0) {
                keys.append("\n");
            }
            keys.append(authKey.getKey());
        }
        entity.setAuthorizedKeys(keys.toString());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetNetworkConfiguration()) {
        if (model.getNetworkConfiguration().isSetNics()) {
            List<VmInitNetwork> interfaces = new ArrayList<VmInitNetwork>();
            for (NIC iface : model.getNetworkConfiguration().getNics().getNics()) {
                VmInitNetwork vmInitInterface = new VmInitNetwork();
                interfaces.add(vmInitInterface);
                if (iface.isSetBootProtocol()) {
                    NetworkBootProtocol protocol = BootProtocolMapper.map(BootProtocol.fromValue(iface.getBootProtocol()), vmInitInterface.getBootProtocol());
                    vmInitInterface.setBootProtocol(protocol);
                    if (protocol != NetworkBootProtocol.DHCP && iface.isSetNetwork() && iface.getNetwork().isSetIp()) {
                        if (iface.getNetwork().getIp().isSetAddress()) {
                            vmInitInterface.setIp(iface.getNetwork().getIp().getAddress());
                        }
                        if (iface.getNetwork().getIp().isSetNetmask()) {
                            vmInitInterface.setNetmask(iface.getNetwork().getIp().getNetmask());
                        }
                        if (iface.getNetwork().getIp().isSetGateway()) {
                            vmInitInterface.setGateway(iface.getNetwork().getIp().getGateway());
                        }
                    }
                    if (iface.isSetOnBoot() && iface.isOnBoot()) {
                        vmInitInterface.setStartOnBoot(true);
                    }
                }
            }
            entity.setNetworks(interfaces);
        }
        if (model.getNetworkConfiguration().isSetDns()) {
            if (model.getNetworkConfiguration().getDns().isSetServers() && model.getNetworkConfiguration().getDns().getServers().isSetHosts() && !model.getNetworkConfiguration().getDns().getServers().getHosts().isEmpty()) {
                StringBuilder dnsServers = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getServers().getHosts()) {
                    if (host.isSetAddress()) {
                        dnsServers.append(host.getAddress());
                    }
                }
                entity.setDnsServers(dnsServers.toString());
            }
            if (model.getNetworkConfiguration().getDns().isSetSearchDomains() && model.getNetworkConfiguration().getDns().getSearchDomains().isSetHosts() && !model.getNetworkConfiguration().getDns().getSearchDomains().getHosts().isEmpty()) {
                StringBuilder searchDomains = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getSearchDomains().getHosts()) {
                    if (host.isSetAddress()) {
                        searchDomains.append(host.getAddress());
                    }
                }
                entity.setDnsSearch(searchDomains.toString());
            }
        }
    }
    if (model.isSetTimezone() && model.getTimezone() != null) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetUsers()) {
        for (User user : model.getUsers().getUsers()) {
            entity.setRootPassword(user.getPassword());
        }
    }
    // for RunOnce backward compatibility.
    if (model.isSetFiles() && model.getFiles().isSetFiles() && !model.getFiles().getFiles().isEmpty()) {
        File file = model.getFiles().getFiles().get(0);
        entity.setCustomScript(file.getContent());
    }
    return entity;
}
#method_after
@Mapping(from = CloudInit.class, to = VmInit.class)
public static VmInit map(CloudInit model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    if (model.isSetHost() && model.getHost().isSetAddress()) {
        entity.setHostname(model.getHost().getAddress());
    }
    if (model.isSetAuthorizedKeys() && model.getAuthorizedKeys().isSetAuthorizedKeys() && !model.getAuthorizedKeys().getAuthorizedKeys().isEmpty()) {
        StringBuilder keys = new StringBuilder();
        for (AuthorizedKey authKey : model.getAuthorizedKeys().getAuthorizedKeys()) {
            if (keys.length() > 0) {
                keys.append("\n");
            }
            keys.append(authKey.getKey());
        }
        entity.setAuthorizedKeys(keys.toString());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetNetworkConfiguration()) {
        if (model.getNetworkConfiguration().isSetNics()) {
            List<VmInitNetwork> interfaces = new ArrayList<VmInitNetwork>();
            for (NIC iface : model.getNetworkConfiguration().getNics().getNics()) {
                VmInitNetwork vmInitInterface = new VmInitNetwork();
                if (iface.isSetName()) {
                    vmInitInterface.setName(iface.getName());
                }
                interfaces.add(vmInitInterface);
                if (iface.isSetBootProtocol()) {
                    NetworkBootProtocol protocol = BootProtocolMapper.map(BootProtocol.fromValue(iface.getBootProtocol()), vmInitInterface.getBootProtocol());
                    vmInitInterface.setBootProtocol(protocol);
                    if (protocol != NetworkBootProtocol.DHCP && iface.isSetNetwork() && iface.getNetwork().isSetIp()) {
                        if (iface.getNetwork().getIp().isSetAddress()) {
                            vmInitInterface.setIp(iface.getNetwork().getIp().getAddress());
                        }
                        if (iface.getNetwork().getIp().isSetNetmask()) {
                            vmInitInterface.setNetmask(iface.getNetwork().getIp().getNetmask());
                        }
                        if (iface.getNetwork().getIp().isSetGateway()) {
                            vmInitInterface.setGateway(iface.getNetwork().getIp().getGateway());
                        }
                    }
                    if (iface.isSetOnBoot() && iface.isOnBoot()) {
                        vmInitInterface.setStartOnBoot(true);
                    }
                }
            }
            entity.setNetworks(interfaces);
        }
        if (model.getNetworkConfiguration().isSetDns()) {
            if (model.getNetworkConfiguration().getDns().isSetServers() && model.getNetworkConfiguration().getDns().getServers().isSetHosts() && !model.getNetworkConfiguration().getDns().getServers().getHosts().isEmpty()) {
                StringBuilder dnsServers = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getServers().getHosts()) {
                    if (host.isSetAddress()) {
                        dnsServers.append(host.getAddress());
                    }
                }
                entity.setDnsServers(dnsServers.toString());
            }
            if (model.getNetworkConfiguration().getDns().isSetSearchDomains() && model.getNetworkConfiguration().getDns().getSearchDomains().isSetHosts() && !model.getNetworkConfiguration().getDns().getSearchDomains().getHosts().isEmpty()) {
                StringBuilder searchDomains = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getSearchDomains().getHosts()) {
                    if (host.isSetAddress()) {
                        searchDomains.append(host.getAddress());
                    }
                }
                entity.setDnsSearch(searchDomains.toString());
            }
        }
    }
    if (model.isSetTimezone() && model.getTimezone() != null) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetUsers()) {
        for (User user : model.getUsers().getUsers()) {
            entity.setRootPassword(user.getPassword());
        }
    }
    // for RunOnce backward compatibility.
    if (model.isSetFiles() && model.getFiles().isSetFiles() && !model.getFiles().getFiles().isEmpty()) {
        File file = model.getFiles().getFiles().get(0);
        entity.setCustomScript(file.getContent());
    }
    return entity;
}
#end_block

#method_before
private void addLinksIncludingUser(Session session) {
    String domainName = session.getUser().getDomain().getName();
    addLinks(session, org.ovirt.engine.api.model.VM.class);
    session.getUser().setDomain(new Domain());
    session.getUser().getDomain().setName(domainName);
    setSessionUser(session);
// setSessionUserDomain(session);
}
#method_after
private void addLinksIncludingUser(Session session) {
    String domainName = session.getUser().getDomain().getName();
    addLinks(session, org.ovirt.engine.api.model.VM.class);
    session.getUser().setDomain(new Domain());
    session.getUser().getDomain().setName(domainName);
    setSessionUser(session);
}
#end_block

#method_before
private void setSessionUser(Session session) {
    User user = getUserResource().getUserByNameAndDomain(session.getUser().getUserName(), session.getUser().getDomain().getName());
    session.getUser().setId(user.getId());
    session.getUser().setHref(user.getHref());
    session.getUser().getDomain().setId(user.getDomain().getId());
    session.getUser().getDomain().setHref(user.getDomain().getHref());
}
#method_after
private void setSessionUser(Session session) {
    User user = getUserResource().getUserByNameAndDomain(session.getUser().getUserName(), session.getUser().getDomain().getName());
    if (user != null) {
        session.getUser().setId(user.getId());
        session.getUser().setHref(user.getHref());
        session.getUser().getDomain().setId(user.getDomain().getId());
        session.getUser().getDomain().setHref(user.getDomain().getHref());
    }
}
#end_block

#method_before
protected VdcReturnValueBase attemptRollback(VdcActionType commandType, VdcActionParametersBase params, CommandContext rollbackContext) {
    if (canPerformRollbackUsingCommand(commandType, params)) {
        params.setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        params.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        return getBackend().runInternalAction(commandType, params, rollbackContext);
    }
    return new VdcReturnValueBase();
}
#method_after
protected VdcReturnValueBase attemptRollback(VdcActionType commandType, VdcActionParametersBase params) {
    if (canPerformRollbackUsingCommand(commandType, params)) {
        params.setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        params.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        return getBackend().runInternalAction(commandType, params, context.clone());
    }
    return new VdcReturnValueBase();
}
#end_block

#method_before
protected VdcReturnValueBase checkAndPerformRollbackUsingCommand(VdcActionType commandType, VdcActionParametersBase params) {
    return attemptRollback(commandType, params, null);
}
#method_after
protected VdcReturnValueBase checkAndPerformRollbackUsingCommand(VdcActionType commandType, VdcActionParametersBase params) {
    return attemptRollback(commandType, params);
}
#end_block

#method_before
public void setCompensationContext(CompensationContext compensationContext) {
    context.setCompensationContext(compensationContext);
}
#method_after
public void setCompensationContext(CompensationContext compensationContext) {
    context.withCompensationContext(compensationContext);
}
#end_block

#method_before
private void initiateLockEndAction() {
    if (commandLock == null) {
        LockIdNameAttribute annotation = getClass().getAnnotation(LockIdNameAttribute.class);
        if (annotation != null && !annotation.isReleaseAtEndOfExecute()) {
            commandLock = buildLock();
        }
    }
}
#method_after
private void initiateLockEndAction() {
    if (context.getLock() == null) {
        LockIdNameAttribute annotation = getClass().getAnnotation(LockIdNameAttribute.class);
        if (annotation != null && !annotation.isReleaseAtEndOfExecute()) {
            context.withLock(buildLock());
        }
    }
}
#end_block

#method_before
private void handleTransactivity() {
    scope = (getParameters() != null) ? getParameters().getTransactionScopeOption() : TransactionScopeOption.Required;
    endActionScope = scope;
    boolean forceCompensation = getForceCompensation();
    // command parameters
    if (!getTransactive()) {
        scope = TransactionScopeOption.Suppress;
        // Set the end action scope to suppress only for non-compensating commands, or the end action for commands
        // will run without transaction but compensation is not supported for end action.
        endActionScope = forceCompensation ? endActionScope : scope;
    }
    if (getCompensationContext() == null) {
        context.setCompensationContext(createCompensationContext(scope, forceCompensation));
    }
}
#method_after
private void handleTransactivity() {
    scope = (getParameters() != null) ? getParameters().getTransactionScopeOption() : TransactionScopeOption.Required;
    endActionScope = scope;
    boolean forceCompensation = getForceCompensation();
    // command parameters
    if (!getTransactive()) {
        scope = TransactionScopeOption.Suppress;
        // Set the end action scope to suppress only for non-compensating commands, or the end action for commands
        // will run without transaction but compensation is not supported for end action.
        endActionScope = forceCompensation ? endActionScope : scope;
    }
    if (getCompensationContext() == null) {
        context.withCompensationContext(createCompensationContext(scope, forceCompensation));
    }
}
#end_block

#method_before
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    // if quota enforcement is not in HARD_ENFORCEMENT the quota may be null.
    if (!isInternalExecution() && getStoragePool() != null && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT) {
        List<QuotaConsumptionParameter> consumptionParameters = getQuotaConsumptionParameters();
        if (consumptionParameters != null) {
            for (QuotaConsumptionParameter parameter : getQuotaConsumptionParameters()) {
                if (parameter.getQuotaGuid() != null && !Guid.Empty.equals(parameter.getQuotaGuid()) && !QuotaConsumptionParameter.QuotaAction.RELEASE.equals(parameter.getQuotaAction())) {
                    quotaPermissionList.add(new PermissionSubject(parameter.getQuotaGuid(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA, VdcBllMessages.USER_NOT_AUTHORIZED_TO_CONSUME_QUOTA));
                }
            }
        }
    }
}
#method_after
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    // if quota enforcement is not in HARD_ENFORCEMENT the quota may be null.
    if (!isInternalExecution() && getStoragePool() != null && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT) {
        List<QuotaConsumptionParameter> consumptionParameters = getQuotaConsumptionParameters();
        if (consumptionParameters != null) {
            for (QuotaConsumptionParameter parameter : consumptionParameters) {
                if (parameter.getQuotaGuid() != null && !Guid.Empty.equals(parameter.getQuotaGuid()) && !QuotaConsumptionParameter.QuotaAction.RELEASE.equals(parameter.getQuotaAction())) {
                    quotaPermissionList.add(new PermissionSubject(parameter.getQuotaGuid(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA, VdcBllMessages.USER_NOT_AUTHORIZED_TO_CONSUME_QUOTA));
                }
            }
        }
    }
}
#end_block

#method_before
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            compensate();
        } else {
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#method_after
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setSucceeded(false);
            compensate();
        } else {
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#end_block

#method_before
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = BackendUtils.getBackendCommandObjectsHandler(log).createAction(entry.getValue().getFirst(), entry.getValue().getSecond());
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#method_after
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = BackendUtils.getBackendCommandObjectsHandler(log).createAction(entry.getValue().getFirst(), entry.getValue().getSecond(), context);
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#end_block

#method_before
protected EngineLock getLock() {
    return commandLock;
}
#method_after
protected EngineLock getLock() {
    return context.getLock();
}
#end_block

#method_before
protected void setLock(EngineLock lock) {
    commandLock = lock;
}
#method_after
protected void setLock(EngineLock lock) {
    context.withLock(lock);
}
#end_block

#method_before
protected boolean acquireLockInternal() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (commandLock == null) {
        EngineLock lock = buildLock();
        if (lock != null) {
            Pair<Boolean, Set<String>> lockAcquireResult = getLockManager().acquireLock(lock);
            if (lockAcquireResult.getFirst()) {
                log.infoFormat("Lock Acquired to object {0}", lock);
                commandLock = lock;
            } else {
                log.infoFormat("Failed to Acquire Lock to object {0}", lock);
                getReturnValue().getCanDoActionMessages().addAll(extractVariableDeclarations(lockAcquireResult.getSecond()));
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean acquireLockInternal() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        EngineLock lock = buildLock();
        if (lock != null) {
            Pair<Boolean, Set<String>> lockAcquireResult = getLockManager().acquireLock(lock);
            if (lockAcquireResult.getFirst()) {
                log.infoFormat("Lock Acquired to object {0}", lock);
                context.withLock(lock);
            } else {
                log.infoFormat("Failed to Acquire Lock to object {0}", lock);
                getReturnValue().getCanDoActionMessages().addAll(extractVariableDeclarations(lockAcquireResult.getSecond()));
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
private void acquireLockAndWait() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (commandLock == null) {
        Map<String, Pair<String, String>> exclusiveLocks = getExclusiveLocks();
        if (exclusiveLocks != null) {
            EngineLock lock = new EngineLock(exclusiveLocks, null);
            getLockManager().acquireLockWait(lock);
            commandLock = lock;
        }
    }
}
#method_after
private void acquireLockAndWait() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        Map<String, Pair<String, String>> exclusiveLocks = getExclusiveLocks();
        if (exclusiveLocks != null) {
            EngineLock lock = new EngineLock(exclusiveLocks, null);
            getLockManager().acquireLockWait(lock);
            context.withLock(lock);
        }
    }
}
#end_block

#method_before
protected void freeLock() {
    if (commandLock != null) {
        getLockManager().releaseLock(commandLock);
        log.infoFormat("Lock freed to object {0}", commandLock);
        commandLock = null;
    }
}
#method_after
protected void freeLock() {
    if (context.getLock() != null) {
        getLockManager().releaseLock(context.getLock());
        log.infoFormat("Lock freed to object {0}", context.getLock());
        context.withLock(null);
    }
}
#end_block

#method_before
public void setExecutionContext(ExecutionContext executionContext) {
    context.setExecutionContext(executionContext);
}
#method_after
public void setExecutionContext(ExecutionContext executionContext) {
    context.withExecutionContext(executionContext);
}
#end_block

#method_before
protected VdcReturnValueBase runInternalAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return Backend.getInstance().runInternalAction(actionType, parameters);
}
#method_after
protected VdcReturnValueBase runInternalAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return getBackend().runInternalAction(actionType, parameters, context.clone());
}
#end_block

#method_before
protected VdcReturnValueBase runInternalAction(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext context) {
    return Backend.getInstance().runInternalAction(actionType, parameters, context);
}
#method_after
protected VdcReturnValueBase runInternalAction(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext internalCommandContext) {
    return getBackend().runInternalAction(actionType, parameters, internalCommandContext);
}
#end_block

#method_before
protected ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters) {
    return Backend.getInstance().runInternalMultipleActions(actionType, parameters);
}
#method_after
protected ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters) {
    return getBackend().runInternalMultipleActions(actionType, parameters, context.clone());
}
#end_block

#method_before
protected ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, ExecutionContext executionContext) {
    return Backend.getInstance().runInternalMultipleActions(actionType, parameters, executionContext);
}
#method_after
protected ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, ExecutionContext executionContext) {
    return getBackend().runInternalMultipleActions(actionType, parameters, context.clone().withExecutionContext(executionContext));
}
#end_block

#method_before
private String _getIpTables() {
    VDSGroup vdsGroup = DbFacade.getInstance().getVdsGroupDao().get(_vds.getVdsGroupId());
    String ipTablesConfig = Config.<String>getValue(ConfigValues.IPTablesConfig);
    String serviceIPTablesConfig = "";
    if (vdsGroup.supportsVirtService()) {
        serviceIPTablesConfig += Config.<String>getValue(ConfigValues.IPTablesConfigForVirt);
    }
    if (vdsGroup.supportsGlusterService()) {
        serviceIPTablesConfig += Config.<String>getValue(ConfigValues.IPTablesConfigForGluster);
    }
    ipTablesConfig = ipTablesConfig.replace(IPTABLES_CUSTOM_RULES_PLACE_HOLDER, serviceIPTablesConfig).replace(IPTABLES_SSH_PORT_PLACE_HOLDER, Integer.toString(_vds.getSshPort())).replace(IPTABLES_VDSM_PORT_PLACE_HOLDER, Integer.toString(_vds.getPort()));
    return ipTablesConfig;
}
#method_after
private String _getIpTables() {
    VDSGroup vdsGroup = DbFacade.getInstance().getVdsGroupDao().get(_vds.getVdsGroupId());
    String ipTablesConfig = Config.<String>getValue(ConfigValues.IPTablesConfig);
    String serviceIPTablesConfig = "";
    if (vdsGroup.supportsVirtService()) {
        serviceIPTablesConfig += Config.<String>getValue(ConfigValues.IPTablesConfigForVirt);
    }
    if (vdsGroup.supportsGlusterService()) {
        serviceIPTablesConfig += Config.<String>getValue(ConfigValues.IPTablesConfigForGluster);
    }
    serviceIPTablesConfig += Config.<String>getValue(ConfigValues.IPTablesConfigSiteCustom);
    ipTablesConfig = ipTablesConfig.replace(IPTABLES_CUSTOM_RULES_PLACE_HOLDER, serviceIPTablesConfig).replace(IPTABLES_SSH_PORT_PLACE_HOLDER, Integer.toString(_vds.getSshPort())).replace(IPTABLES_VDSM_PORT_PLACE_HOLDER, Integer.toString(_vds.getPort()));
    return ipTablesConfig;
}
#end_block

#method_before
private String _getIpTables() {
    VDSGroup vdsGroup = DbFacade.getInstance().getVdsGroupDao().get(_vds.getVdsGroupId());
    String ipTablesConfig = Config.<String>getValue(ConfigValues.IPTablesConfig);
    String serviceIPTablesConfig = "";
    if (vdsGroup.supportsVirtService()) {
        serviceIPTablesConfig += Config.<String>getValue(ConfigValues.IPTablesConfigForVirt);
    }
    if (vdsGroup.supportsGlusterService()) {
        serviceIPTablesConfig += Config.<String>getValue(ConfigValues.IPTablesConfigForGluster);
    }
    ipTablesConfig = ipTablesConfig.replace(IPTABLES_CUSTOM_RULES_PLACE_HOLDER, serviceIPTablesConfig).replace(IPTABLES_SSH_PORT_PLACE_HOLDER, Integer.toString(_vds.getSshPort())).replace(IPTABLES_VDSM_PORT_PLACE_HOLDER, Integer.toString(_vds.getPort()));
    return ipTablesConfig;
}
#method_after
private String _getIpTables() {
    VDSGroup vdsGroup = DbFacade.getInstance().getVdsGroupDao().get(_vds.getVdsGroupId());
    String ipTablesConfig = Config.<String>getValue(ConfigValues.IPTablesConfig);
    String serviceIPTablesConfig = "";
    if (vdsGroup.supportsVirtService()) {
        serviceIPTablesConfig += Config.<String>getValue(ConfigValues.IPTablesConfigForVirt);
    }
    if (vdsGroup.supportsGlusterService()) {
        serviceIPTablesConfig += Config.<String>getValue(ConfigValues.IPTablesConfigForGluster);
    }
    serviceIPTablesConfig += Config.<String>getValue(ConfigValues.IPTablesConfigSiteCustom);
    ipTablesConfig = ipTablesConfig.replace(IPTABLES_CUSTOM_RULES_PLACE_HOLDER, serviceIPTablesConfig).replace(IPTABLES_SSH_PORT_PLACE_HOLDER, Integer.toString(_vds.getSshPort())).replace(IPTABLES_VDSM_PORT_PLACE_HOLDER, Integer.toString(_vds.getPort()));
    return ipTablesConfig;
}
#end_block

#method_before
private AuditLogType attemptToAttachDisksToImportedVm(Collection<Disk> disks) {
    List<String> failedDisks = new LinkedList<>();
    for (Disk disk : disks) {
        AttachDetachVmDiskParameters params = new AttachDetachVmDiskParameters(getVm().getId(), disk.getId(), disk.getPlugged(), disk.getReadOnly());
        VdcReturnValueBase returnVal = runInternalAction(VdcActionType.AttachDiskToVm, params, cloneOnlyEngineContext());
        if (!returnVal.getSucceeded()) {
            failedDisks.add(disk.getDiskAlias());
        }
    }
    if (!failedDisks.isEmpty()) {
        this.addCustomValue("DiskAliases", StringUtils.join(failedDisks, ","));
        return AuditLogType.VM_IMPORT_FROM_CONFIGURATION_ATTACH_DISKS_FAILED;
    }
    return AuditLogType.VM_IMPORT_FROM_CONFIGURATION_EXECUTED_SUCCESSFULLY;
}
#method_after
private AuditLogType attemptToAttachDisksToImportedVm(Collection<Disk> disks) {
    List<String> failedDisks = new LinkedList<>();
    for (Disk disk : disks) {
        AttachDetachVmDiskParameters params = new AttachDetachVmDiskParameters(getVm().getId(), disk.getId(), disk.getPlugged(), disk.getReadOnly());
        VdcReturnValueBase returnVal = runInternalAction(VdcActionType.AttachDiskToVm, params, cloneContextAndDetachFromParent());
        if (!returnVal.getSucceeded()) {
            failedDisks.add(disk.getDiskAlias());
        }
    }
    if (!failedDisks.isEmpty()) {
        this.addCustomValue("DiskAliases", StringUtils.join(failedDisks, ","));
        return AuditLogType.VM_IMPORT_FROM_CONFIGURATION_ATTACH_DISKS_FAILED;
    }
    return AuditLogType.VM_IMPORT_FROM_CONFIGURATION_EXECUTED_SUCCESSFULLY;
}
#end_block

#method_before
private boolean updateRngDevice() {
    // do not update if this flag is not set
    if (getParameters().isUpdateRngDevice()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
        @SuppressWarnings("unchecked")
        List<VmRngDevice> rngDevs = query.getReturnValue();
        VdcReturnValueBase rngCommandResult = null;
        if (rngDevs.isEmpty()) {
            if (getParameters().getRngDevice() != null) {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
                rngCommandResult = runInternalAction(VdcActionType.AddRngDevice, params, cloneOnlyEngineContext());
            }
        } else {
            if (getParameters().getRngDevice() == null) {
                RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
                rngCommandResult = runInternalAction(VdcActionType.RemoveRngDevice, params, cloneOnlyEngineContext());
            } else {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
                params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
                rngCommandResult = runInternalAction(VdcActionType.UpdateRngDevice, params, cloneOnlyEngineContext());
            }
        }
        if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean updateRngDevice() {
    // do not update if this flag is not set
    if (getParameters().isUpdateRngDevice()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
        @SuppressWarnings("unchecked")
        List<VmRngDevice> rngDevs = query.getReturnValue();
        VdcReturnValueBase rngCommandResult = null;
        if (rngDevs.isEmpty()) {
            if (getParameters().getRngDevice() != null) {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
                rngCommandResult = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
            }
        } else {
            if (getParameters().getRngDevice() == null) {
                RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
                rngCommandResult = runInternalAction(VdcActionType.RemoveRngDevice, params, cloneContextAndDetachFromParent());
            } else {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
                params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
                rngCommandResult = runInternalAction(VdcActionType.UpdateRngDevice, params, cloneContextAndDetachFromParent());
            }
        }
        if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void hotSetCpus(int cpuPerSocket) {
    int currentSockets = getVm().getNumOfSockets();
    int newSockets = newVmStatic.getNumOfSockets();
    int currentCpuPerSocket = getVm().getCpuPerSocket();
    // try hotplug only if topology (cpuPerSocket) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && currentSockets != newSockets && currentCpuPerSocket == cpuPerSocket) {
        HotSetNumerOfCpusParameters params = new HotSetNumerOfCpusParameters(newVmStatic, currentSockets < newSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneOnlyEngineContext());
        newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newSockets : currentSockets);
        auditLogHotSetCpusCandos(params);
    }
}
#method_after
private void hotSetCpus(int cpuPerSocket) {
    int currentSockets = getVm().getNumOfSockets();
    int newSockets = newVmStatic.getNumOfSockets();
    int currentCpuPerSocket = getVm().getCpuPerSocket();
    // try hotplug only if topology (cpuPerSocket) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && currentSockets != newSockets && currentCpuPerSocket == cpuPerSocket) {
        HotSetNumerOfCpusParameters params = new HotSetNumerOfCpusParameters(newVmStatic, currentSockets < newSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newSockets : currentSockets);
        auditLogHotSetCpusCandos(params);
    }
}
#end_block

#method_before
private void updateWatchdog() {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getParameters().getVmId()));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty()) {
            if (getParameters().getWatchdog() == null) {
            // nothing to do, no watchdog and no watchdog to create
            } else {
                WatchdogParameters parameters = new WatchdogParameters();
                parameters.setId(getParameters().getVmId());
                parameters.setAction(getParameters().getWatchdog().getAction());
                parameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.AddWatchdog, parameters, cloneOnlyEngineContext());
            }
        } else {
            WatchdogParameters watchdogParameters = new WatchdogParameters();
            watchdogParameters.setId(getParameters().getVmId());
            if (getParameters().getWatchdog() == null) {
                // there is a watchdog in the vm, there should not be any, so let's delete
                runInternalAction(VdcActionType.RemoveWatchdog, watchdogParameters, cloneOnlyEngineContext());
            } else {
                // there is a watchdog in the vm, we have to update.
                watchdogParameters.setAction(getParameters().getWatchdog().getAction());
                watchdogParameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.UpdateWatchdog, watchdogParameters, cloneOnlyEngineContext());
            }
        }
    }
}
#method_after
private void updateWatchdog() {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getParameters().getVmId()));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty()) {
            if (getParameters().getWatchdog() == null) {
            // nothing to do, no watchdog and no watchdog to create
            } else {
                WatchdogParameters parameters = new WatchdogParameters();
                parameters.setId(getParameters().getVmId());
                parameters.setAction(getParameters().getWatchdog().getAction());
                parameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
            }
        } else {
            WatchdogParameters watchdogParameters = new WatchdogParameters();
            watchdogParameters.setId(getParameters().getVmId());
            if (getParameters().getWatchdog() == null) {
                // there is a watchdog in the vm, there should not be any, so let's delete
                runInternalAction(VdcActionType.RemoveWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            } else {
                // there is a watchdog in the vm, we have to update.
                watchdogParameters.setAction(getParameters().getWatchdog().getAction());
                watchdogParameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.UpdateWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            }
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device console");
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device sound");
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName(), getParameters().isVirtioScsiEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device VirtIO-SCSI");
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device console");
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device sound");
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName(), getParameters().isVirtioScsiEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device VirtIO-SCSI");
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#end_block

#method_before
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), getParameters().isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
private CommandContext createCommandContext(GlusterVolumeEntity volume, GlusterVolumeOptionEntity option) {
    // Add sub-step for setting given option
    Step setOptionStep = addSubStep(StepEnum.EXECUTING, StepEnum.SETTING_GLUSTER_OPTION, getOptionValues(volume, option));
    // Create execution context for setting option
    ExecutionContext setOptionCtx = new ExecutionContext();
    setOptionCtx.setMonitored(true);
    setOptionCtx.setStep(setOptionStep);
    return dupContext().withExecutionContext(setOptionCtx).withoutLock();
}
#method_after
private CommandContext createCommandContext(GlusterVolumeEntity volume, GlusterVolumeOptionEntity option) {
    // Add sub-step for setting given option
    Step setOptionStep = addSubStep(StepEnum.EXECUTING, StepEnum.SETTING_GLUSTER_OPTION, getOptionValues(volume, option));
    // Create execution context for setting option
    ExecutionContext setOptionCtx = new ExecutionContext();
    setOptionCtx.setMonitored(true);
    setOptionCtx.setStep(setOptionStep);
    return cloneContext().withExecutionContext(setOptionCtx).withoutLock();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    updateOvfStoreContent();
    int missingDiskCount = Config.<Integer>getValue(ConfigValues.StorageDomainOvfStoreCount) - ovfDiskCount;
    if (missingDiskCount > 0) {
        runInternalAction(VdcActionType.CreateOvfStoresForStorageDomain, new CreateOvfStoresForStorageDomainCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), missingDiskCount), cloneOnlyEngineContext());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    updateOvfStoreContent();
    int missingDiskCount = Config.<Integer>getValue(ConfigValues.StorageDomainOvfStoreCount) - ovfDiskCount;
    if (missingDiskCount > 0) {
        runInternalAction(VdcActionType.CreateOvfStoresForStorageDomain, new CreateOvfStoresForStorageDomainCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), missingDiskCount), cloneContextAndDetachFromParent());
    }
    setSucceeded(true);
}
#end_block

#method_before
private void removeMemoryVolumesOfSnapshot(Snapshot snapshot) {
    VdcReturnValueBase retVal = runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(snapshot.getMemoryVolume(), getVmId()), cloneOnlyEngineContext());
    if (!retVal.getSucceeded()) {
        log.errorFormat("Failed to remove memory volumes of snapshot {0} ({1})", snapshot.getDescription(), snapshot.getId());
    }
}
#method_after
private void removeMemoryVolumesOfSnapshot(Snapshot snapshot) {
    VdcReturnValueBase retVal = runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(snapshot.getMemoryVolume(), getVmId()), cloneContextAndDetachFromParent());
    if (!retVal.getSucceeded()) {
        log.errorFormat("Failed to remove memory volumes of snapshot {0} ({1})", snapshot.getDescription(), snapshot.getId());
    }
}
#end_block

#method_before
protected void updateWatchdog(Guid templateId) {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(templateId));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty()) {
            if (getParameters().getWatchdog() != null) {
                WatchdogParameters parameters = new WatchdogParameters();
                parameters.setVm(false);
                parameters.setInstanceType(getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE);
                parameters.setId(templateId);
                parameters.setAction(getParameters().getWatchdog().getAction());
                parameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.AddWatchdog, parameters, cloneOnlyEngineContext());
            }
        } else {
            WatchdogParameters watchdogParameters = new WatchdogParameters();
            watchdogParameters.setVm(false);
            watchdogParameters.setInstanceType(getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE);
            watchdogParameters.setId(templateId);
            if (getParameters().getWatchdog() == null) {
                // there is a watchdog in the vm, there should not be any, so let's delete
                runInternalAction(VdcActionType.RemoveWatchdog, watchdogParameters, cloneOnlyEngineContext());
            } else {
                // there is a watchdog in the vm, we have to update.
                watchdogParameters.setAction(getParameters().getWatchdog().getAction());
                watchdogParameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.UpdateWatchdog, watchdogParameters, cloneOnlyEngineContext());
            }
        }
    }
}
#method_after
protected void updateWatchdog(Guid templateId) {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(templateId));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty()) {
            if (getParameters().getWatchdog() != null) {
                WatchdogParameters parameters = new WatchdogParameters();
                parameters.setVm(false);
                parameters.setInstanceType(getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE);
                parameters.setId(templateId);
                parameters.setAction(getParameters().getWatchdog().getAction());
                parameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
            }
        } else {
            WatchdogParameters watchdogParameters = new WatchdogParameters();
            watchdogParameters.setVm(false);
            watchdogParameters.setInstanceType(getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE);
            watchdogParameters.setId(templateId);
            if (getParameters().getWatchdog() == null) {
                // there is a watchdog in the vm, there should not be any, so let's delete
                runInternalAction(VdcActionType.RemoveWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            } else {
                // there is a watchdog in the vm, we have to update.
                watchdogParameters.setAction(getParameters().getWatchdog().getAction());
                watchdogParameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.UpdateWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            }
        }
    }
}
#end_block

#method_before
protected void updateRngDevice(Guid templateId) {
    // do not update if this flag is not set
    if (getParameters().isUpdateRngDevice()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(templateId));
        List<VmRngDevice> rngDevs = query.getReturnValue();
        if (getParameters().getRngDevice() != null) {
            getParameters().getRngDevice().setVmId(templateId);
        }
        VdcReturnValueBase rngCommandResult = null;
        if (rngDevs.isEmpty()) {
            if (getParameters().getRngDevice() != null) {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), false);
                rngCommandResult = runInternalAction(VdcActionType.AddRngDevice, params, cloneOnlyEngineContext());
            }
        } else {
            if (getParameters().getRngDevice() == null) {
                RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), false);
                rngCommandResult = runInternalAction(VdcActionType.RemoveRngDevice, params, cloneOnlyEngineContext());
            } else {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), false);
                params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
                rngCommandResult = runInternalAction(VdcActionType.UpdateRngDevice, params, cloneOnlyEngineContext());
            }
        }
        if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
            getReturnValue().setSucceeded(false);
        }
    }
}
#method_after
protected void updateRngDevice(Guid templateId) {
    // do not update if this flag is not set
    if (getParameters().isUpdateRngDevice()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(templateId));
        List<VmRngDevice> rngDevs = query.getReturnValue();
        if (getParameters().getRngDevice() != null) {
            getParameters().getRngDevice().setVmId(templateId);
        }
        VdcReturnValueBase rngCommandResult = null;
        if (rngDevs.isEmpty()) {
            if (getParameters().getRngDevice() != null) {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), false);
                rngCommandResult = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
            }
        } else {
            if (getParameters().getRngDevice() == null) {
                RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), false);
                rngCommandResult = runInternalAction(VdcActionType.RemoveRngDevice, params, cloneContextAndDetachFromParent());
            } else {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), false);
                params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
                rngCommandResult = runInternalAction(VdcActionType.UpdateRngDevice, params, cloneContextAndDetachFromParent());
            }
        }
        if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
            getReturnValue().setSucceeded(false);
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getParameters().getShouldBeLogged()) {
        AuditLogDirector.log(this, AuditLogType.PERSIST_NETWORK_ON_HOST);
    }
    VdcReturnValueBase returnValue = runInternalAction(VdcActionType.SetupNetworks, getParameters(), getContext().clone().withoutCompensationContext().withoutExecutionContext());
    if (returnValue.getSucceeded() && SETUP_NETWORKS_RESOLUTION.NO_CHANGES_DETECTED != returnValue.getActionReturnValue()) {
        VdsActionParameters parameters = new VdsActionParameters(getParameters().getVdsId());
        parameters.setShouldBeLogged(false);
        parameters.setCorrelationId(getCorrelationId());
        returnValue = runInternalAction(VdcActionType.CommitNetworkChanges, parameters, getContext().clone().withoutCompensationContext().withoutExecutionContext());
    }
    if (!returnValue.getSucceeded()) {
        propagateFailure(returnValue);
    }
    setSucceeded(returnValue.getSucceeded());
}
#method_after
@Override
protected void executeCommand() {
    if (getParameters().getShouldBeLogged()) {
        AuditLogDirector.log(this, AuditLogType.PERSIST_NETWORK_ON_HOST);
    }
    VdcReturnValueBase returnValue = runInternalAction(VdcActionType.SetupNetworks, getParameters(), cloneContextAndDetachFromParent());
    if (returnValue.getSucceeded() && SETUP_NETWORKS_RESOLUTION.NO_CHANGES_DETECTED != returnValue.getActionReturnValue()) {
        VdsActionParameters parameters = new VdsActionParameters(getParameters().getVdsId());
        parameters.setShouldBeLogged(false);
        parameters.setCorrelationId(getCorrelationId());
        returnValue = runInternalAction(VdcActionType.CommitNetworkChanges, parameters, cloneContextAndDetachFromParent());
    }
    if (!returnValue.getSucceeded()) {
        propagateFailure(returnValue);
    }
    setSucceeded(returnValue.getSucceeded());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setVdsGroupId(targetClusterId);
            DbFacade.getInstance().getVdsStaticDao().update(staticData);
            getCompensationContext().stateChanged();
            // remove the server from resource manager and add it back
            initializeVds();
            return null;
        }
    });
    if (targetStoragePool != null && (getSourceCluster().getStoragePoolId() == null || !targetStoragePool.getId().equals(getSourceCluster().getStoragePoolId()))) {
        VdsActionParameters addVdsSpmIdParams = new VdsActionParameters(getVdsIdRef());
        addVdsSpmIdParams.setSessionId(getParameters().getSessionId());
        addVdsSpmIdParams.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, addVdsSpmIdParams, dupContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (getSourceCluster().supportsGlusterService() && getClusterUtils().hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && getClusterUtils().hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getSourceCluster().getStoragePoolId() != null && (targetStoragePool == null || !getSourceCluster().getStoragePoolId().equals(targetStoragePool.getId()))) {
        getVdsSpmIdMapDAO().removeByVdsAndStoragePool(getVds().getId(), getSourceCluster().getStoragePoolId());
    }
    if (targetClusterSupportsSetupNetworks()) {
        configureNetworks();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setVdsGroupId(targetClusterId);
            DbFacade.getInstance().getVdsStaticDao().update(staticData);
            getCompensationContext().stateChanged();
            // remove the server from resource manager and add it back
            initializeVds();
            return null;
        }
    });
    if (targetStoragePool != null && (getSourceCluster().getStoragePoolId() == null || !targetStoragePool.getId().equals(getSourceCluster().getStoragePoolId()))) {
        VdsActionParameters addVdsSpmIdParams = new VdsActionParameters(getVdsIdRef());
        addVdsSpmIdParams.setSessionId(getParameters().getSessionId());
        addVdsSpmIdParams.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, addVdsSpmIdParams, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (getSourceCluster().supportsGlusterService() && getClusterUtils().hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && getClusterUtils().hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getSourceCluster().getStoragePoolId() != null && (targetStoragePool == null || !getSourceCluster().getStoragePoolId().equals(targetStoragePool.getId()))) {
        getVdsSpmIdMapDAO().removeByVdsAndStoragePool(getVds().getId(), getSourceCluster().getStoragePoolId());
    }
    if (targetClusterSupportsSetupNetworks()) {
        configureNetworks();
    }
    setSucceeded(true);
}
#end_block

#method_before
private void configureNetworks() {
    ChangeClusterParametersBuilder builder = new ChangeClusterParametersBuilder(getContext());
    final PersistentSetupNetworksParameters params;
    try {
        params = builder.buildParameters(getVdsId(), getSourceCluster().getId(), getTargetCluster().getId());
    } catch (VdcBLLException e) {
        AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED);
        return;
    }
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            runInternalAction(VdcActionType.PersistentSetupNetworks, params, cloneOnlyEngineContext());
        }
    });
}
#method_after
private void configureNetworks() {
    ChangeClusterParametersBuilder builder = new ChangeClusterParametersBuilder(getContext());
    final PersistentSetupNetworksParameters params;
    try {
        params = builder.buildParameters(getVdsId(), getSourceCluster().getId(), getTargetCluster().getId());
    } catch (VdcBLLException e) {
        AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED);
        return;
    }
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            runInternalAction(VdcActionType.PersistentSetupNetworks, params, cloneContextAndDetachFromParent());
        }
    });
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#end_block

#method_before
protected void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        WatchdogParameters parameters = new WatchdogParameters();
        parameters.setId(getParameters().getVmId());
        parameters.setAction(vmWatchdog.getAction());
        parameters.setModel(vmWatchdog.getModel());
        runInternalAction(VdcActionType.AddWatchdog, parameters, cloneOnlyEngineContext());
    }
}
#method_after
protected void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        WatchdogParameters parameters = new WatchdogParameters();
        parameters.setId(getParameters().getVmId());
        parameters.setAction(vmWatchdog.getAction());
        parameters.setModel(vmWatchdog.getModel());
        runInternalAction(VdcActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
    }
}
#end_block

#method_before
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        VdcReturnValueBase result = runInternalAction(VdcActionType.AddRngDevice, params, cloneOnlyEngineContext());
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#method_after
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        VdcReturnValueBase result = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#end_block

#method_before
private boolean activateOrDeactivateNic(VmNic nic, PlugAction plugAction, boolean newNic) {
    ActivateDeactivateVmNicParameters parameters = new ActivateDeactivateVmNicParameters(nic, plugAction, newNic);
    parameters.setVmId(getParameters().getVmId());
    VdcReturnValueBase returnValue = runInternalAction(VdcActionType.ActivateDeactivateVmNic, parameters, getContext().clone().withoutCompensationContext().withoutExecutionContext());
    if (!returnValue.getSucceeded()) {
        propagateFailure(returnValue);
    }
    return returnValue.getSucceeded();
}
#method_after
private boolean activateOrDeactivateNic(VmNic nic, PlugAction plugAction, boolean newNic) {
    ActivateDeactivateVmNicParameters parameters = new ActivateDeactivateVmNicParameters(nic, plugAction, newNic);
    parameters.setVmId(getParameters().getVmId());
    VdcReturnValueBase returnValue = runInternalAction(VdcActionType.ActivateDeactivateVmNic, parameters, cloneContextAndDetachFromParent());
    if (!returnValue.getSucceeded()) {
        propagateFailure(returnValue);
    }
    return returnValue.getSucceeded();
}
#end_block

#method_before
private void configureManagementNetwork(SetupNetworksParameters parameters) {
    VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.SetupNetworks, parameters, cloneOnlyEngineContext());
    if (retVal.getSucceeded()) {
        retVal = getBackend().runInternalAction(VdcActionType.CommitNetworkChanges, new VdsActionParameters(parameters.getVdsId()), cloneOnlyEngineContext());
        if (!retVal.getSucceeded()) {
            AuditLogDirector.log(createEvent(), AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, NETWORK_CONFIG_LOG_ERR);
            throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
        }
    } else {
        AuditLogDirector.log(createEvent(), AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, NETWORK_CONFIG_LOG_ERR);
        throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
    }
}
#method_after
private void configureManagementNetwork(SetupNetworksParameters parameters) {
    VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.SetupNetworks, parameters, cloneContextAndDetachFromParent());
    if (retVal.getSucceeded()) {
        retVal = getBackend().runInternalAction(VdcActionType.CommitNetworkChanges, new VdsActionParameters(parameters.getVdsId()), cloneContextAndDetachFromParent());
        if (!retVal.getSucceeded()) {
            AuditLogDirector.log(createEvent(), AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, NETWORK_CONFIG_LOG_ERR);
            throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
        }
    } else {
        AuditLogDirector.log(createEvent(), AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, NETWORK_CONFIG_LOG_ERR);
        throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
    }
}
#end_block

#method_before
private void removeMemoryVolumes(String memoryVolume, Guid vmId) {
    VdcReturnValueBase retVal = runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(memoryVolume, vmId), cloneOnlyEngineContext());
    if (!retVal.getSucceeded()) {
        log.errorFormat("Failed to remove memory volumes: {0}", memoryVolume);
    }
}
#method_after
private void removeMemoryVolumes(String memoryVolume, Guid vmId) {
    VdcReturnValueBase retVal = runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(memoryVolume, vmId), cloneContextAndDetachFromParent());
    if (!retVal.getSucceeded()) {
        log.errorFormat("Failed to remove memory volumes: {0}", memoryVolume);
    }
}
#end_block

#method_before
private DbUser addUser(Guid id, String directory, String externalId, String namespace) {
    // Try to add the user with the external id:
    if (directory != null && externalId != null) {
        DirectoryIdParameters parameters = new DirectoryIdParameters();
        parameters.setDirectory(directory);
        parameters.setId(externalId);
        parameters.setNamespace(namespace);
        VdcReturnValueBase result = runInternalAction(VdcActionType.AddUser, parameters, cloneOnlyEngineContext());
        if (result.getCanDoAction()) {
            id = (Guid) result.getActionReturnValue();
            if (id != null) {
                return getDbUserDAO().get(id);
            }
            return null;
        }
    }
    // There is no such user in the directory:
    return null;
}
#method_after
private DbUser addUser(Guid id, String directory, String externalId, String namespace) {
    // Try to add the user with the external id:
    if (directory != null && externalId != null) {
        DirectoryIdParameters parameters = new DirectoryIdParameters();
        parameters.setDirectory(directory);
        parameters.setId(externalId);
        parameters.setNamespace(namespace);
        VdcReturnValueBase result = runInternalAction(VdcActionType.AddUser, parameters, cloneContextAndDetachFromParent());
        if (result.getCanDoAction()) {
            id = (Guid) result.getActionReturnValue();
            if (id != null) {
                return getDbUserDAO().get(id);
            }
            return null;
        }
    }
    // There is no such user in the directory:
    return null;
}
#end_block

#method_before
private DbGroup addGroup(Guid id, String directory, String externalId, String namespace) {
    // Try to add the user with the external id:
    if (directory != null && externalId != null) {
        DirectoryIdParameters parameters = new DirectoryIdParameters();
        parameters.setDirectory(directory);
        parameters.setId(externalId);
        parameters.setNamespace(namespace);
        VdcReturnValueBase result = runInternalAction(VdcActionType.AddGroup, parameters, cloneOnlyEngineContext());
        if (result.getCanDoAction()) {
            id = (Guid) result.getActionReturnValue();
            if (id != null) {
                return getAdGroupDAO().get(id);
            }
            return null;
        }
    }
    // There is no such group in the directory:
    return null;
}
#method_after
private DbGroup addGroup(Guid id, String directory, String externalId, String namespace) {
    // Try to add the user with the external id:
    if (directory != null && externalId != null) {
        DirectoryIdParameters parameters = new DirectoryIdParameters();
        parameters.setDirectory(directory);
        parameters.setId(externalId);
        parameters.setNamespace(namespace);
        VdcReturnValueBase result = runInternalAction(VdcActionType.AddGroup, parameters, cloneContextAndDetachFromParent());
        if (result.getCanDoAction()) {
            id = (Guid) result.getActionReturnValue();
            if (id != null) {
                return getAdGroupDAO().get(id);
            }
            return null;
        }
    }
    // There is no such group in the directory:
    return null;
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    isVmInDb = getVm() != null;
    getVmStaticDAO().incrementDbGeneration(getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p, dupContext().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    isVmInDb = getVm() != null;
    getVmStaticDAO().incrementDbGeneration(getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p, cloneContextAndDetachFromParent());
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
@OnTimerMethodAnnotation("updateVmVersion")
public void updateVmVersion() {
    for (Guid vmId : getVmDAO().getVmIdsForVersionUpdate(getParameters().getBaseTemplateId())) {
        // if the job was removed, stop executing, we probably have new version creation going on
        if (!updateVmsJobIdMap.containsKey(getParameters().getBaseTemplateId())) {
            break;
        }
        UpdateVmVersionParameters params = new UpdateVmVersionParameters(vmId);
        params.setSessionId(getParameters().getSessionId());
        getBackend().runInternalAction(VdcActionType.UpdateVmVersion, params, cloneOnlyEngineContext());
    }
    updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
}
#method_after
@OnTimerMethodAnnotation("updateVmVersion")
public void updateVmVersion() {
    for (Guid vmId : getVmDAO().getVmIdsForVersionUpdate(getParameters().getBaseTemplateId())) {
        // if the job was removed, stop executing, we probably have new version creation going on
        if (!updateVmsJobIdMap.containsKey(getParameters().getBaseTemplateId())) {
            break;
        }
        UpdateVmVersionParameters params = new UpdateVmVersionParameters(vmId);
        params.setSessionId(getParameters().getSessionId());
        getBackend().runInternalAction(VdcActionType.UpdateVmVersion, params, cloneContextAndDetachFromParent());
    }
    updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p, dupContext().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        removeNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p, cloneContextAndDetachFromParent());
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        removeNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public void execute() {
    if (!enclosingCommand.getReturnValue().getSucceeded()) {
        throw new VdcBLLException(VdcBllErrors.imageErr, "Auto-generated live snapshot for VM " + enclosingCommand.getParameters().getVmId() + " failed");
    }
    TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (LiveMigrateDiskParameters parameters : enclosingCommand.getParameters().getParametersList()) {
                CommandContext commandContext = ExecutionHandler.createInternalJobContext(enclosingCommand.getContext());
                ExecutionHandler.setAsyncJob(commandContext.getExecutionContext(), true);
                parameters.setSessionId(enclosingCommand.getParameters().getSessionId());
                VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.LiveMigrateDisk, parameters, commandContext);
                if (!vdcReturnValue.getSucceeded()) {
                    ImagesHandler.updateAllDiskImageSnapshotsStatus(parameters.getImageGroupID(), ImageStatus.OK);
                }
                enclosingCommand.getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                if (!parameters.getTaskGroupSuccess()) {
                    ExecutionHandler.endTaskJob(commandContext.getExecutionContext(), false);
                    log.errorFormat("Failed LiveMigrateDisk (Disk {0} , VM {1})", parameters.getImageGroupID(), parameters.getVmId());
                }
            }
            enclosingCommand.getReturnValue().setSucceeded(true);
            return null;
        }
    });
}
#method_after
@Override
public void execute() {
    if (!enclosingCommand.getReturnValue().getSucceeded()) {
        throw new VdcBLLException(VdcBllErrors.imageErr, "Auto-generated live snapshot for VM " + enclosingCommand.getParameters().getVmId() + " failed");
    }
    TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (LiveMigrateDiskParameters parameters : enclosingCommand.getParameters().getParametersList()) {
                CommandContext commandContext = ExecutionHandler.createInternalJobContext(enclosingCommand.cloneContextAndDetachFromParent());
                ExecutionHandler.setAsyncJob(commandContext.getExecutionContext(), true);
                parameters.setSessionId(enclosingCommand.getParameters().getSessionId());
                VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.LiveMigrateDisk, parameters, commandContext);
                if (!vdcReturnValue.getSucceeded()) {
                    ImagesHandler.updateAllDiskImageSnapshotsStatus(parameters.getImageGroupID(), ImageStatus.OK);
                }
                enclosingCommand.getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                if (!parameters.getTaskGroupSuccess()) {
                    ExecutionHandler.endTaskJob(commandContext.getExecutionContext(), false);
                    log.errorFormat("Failed LiveMigrateDisk (Disk {0} , VM {1})", parameters.getImageGroupID(), parameters.getVmId());
                }
            }
            enclosingCommand.getReturnValue().setSucceeded(true);
            return null;
        }
    });
}
#end_block

#method_before
public static CommandContext createInternalJobContext(EngineLock lock) {
    return modifyContextForIntenrakJob(lock, new CommandContext(new EngineContext()));
}
#method_after
public static CommandContext createInternalJobContext(EngineLock lock) {
    return modifyContextForIntenralJob(new CommandContext(new EngineContext()), lock);
}
#end_block

#method_before
public static CommandContext createInternalJobContext(CommandContext commandContext, EngineLock lock) {
    return modifyContextForIntenrakJob(lock, commandContext.clone());
}
#method_after
public static CommandContext createInternalJobContext(CommandContext commandContext, EngineLock lock) {
    return modifyContextForIntenralJob(commandContext.clone(), lock);
}
#end_block

#method_before
public static CommandContext createDefaultContextForTasks(CommandContext commandContext, EngineLock lock) {
    return commandContext.clone().withLock(lock).withoutCompensationContext();
}
#method_after
public static CommandContext createDefaultContextForTasks(CommandContext commandContext, EngineLock lock) {
    CommandContext result = commandContext.clone().withLock(lock).withoutCompensationContext();
    return result.withExecutionContext(createDefaultContextForTasksImpl(result.getExecutionContext()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VdcReturnValueBase result = runInternalAction(VdcActionType.PersistentSetupNetworks, new AddNetworksByLabelParametersBuilder(getContext()).buildParameters(getNic(), getLabel(), getClusterNetworksByLabel()), getContext().clone().withoutCompensationContext().withoutExecutionContext());
    if (result.getSucceeded()) {
        getReturnValue().setActionReturnValue(getLabel());
    } else {
        propagateFailure(result);
    }
    setSucceeded(result.getSucceeded());
}
#method_after
@Override
protected void executeCommand() {
    VdcReturnValueBase result = runInternalAction(VdcActionType.PersistentSetupNetworks, new AddNetworksByLabelParametersBuilder(getContext()).buildParameters(getNic(), getLabel(), getClusterNetworksByLabel()), cloneContextAndDetachFromParent());
    if (result.getSucceeded()) {
        getReturnValue().setActionReturnValue(getLabel());
    } else {
        propagateFailure(result);
    }
    setSucceeded(result.getSucceeded());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VdcReturnValueBase result = runInternalAction(VdcActionType.PersistentSetupNetworks, new RemoveNetworksByLabelParametersBuilder(getContext()).buildParameters(getNic(), getLabel(), getVds().getVdsGroupId()), getContext().clone().withoutCompensationContext().withoutExecutionContext());
    if (!result.getSucceeded()) {
        propagateFailure(result);
    }
    setSucceeded(result.getSucceeded());
}
#method_after
@Override
protected void executeCommand() {
    VdcReturnValueBase result = runInternalAction(VdcActionType.PersistentSetupNetworks, new RemoveNetworksByLabelParametersBuilder(getContext()).buildParameters(getNic(), getLabel(), getVds().getVdsGroupId()), cloneContextAndDetachFromParent());
    if (!result.getSucceeded()) {
        propagateFailure(result);
    }
    setSucceeded(result.getSucceeded());
}
#end_block

#method_before
private void removeMemoryVolumes() {
    for (String memoryState : memoryStates) {
        VdcReturnValueBase retVal = runInternalAction(VdcActionType.RemoveMemoryVolumes, buildRemoveMemoryVolumesParameters(memoryState, getVmId()), cloneOnlyEngineContext());
        if (!retVal.getSucceeded()) {
            log.errorFormat("Failed to remove memory volumes whie removing vm {0} (volumes: {1})", getVmId(), memoryState);
        }
    }
}
#method_after
private void removeMemoryVolumes() {
    for (String memoryState : memoryStates) {
        VdcReturnValueBase retVal = runInternalAction(VdcActionType.RemoveMemoryVolumes, buildRemoveMemoryVolumesParameters(memoryState, getVmId()), cloneContextAndDetachFromParent());
        if (!retVal.getSucceeded()) {
            log.errorFormat("Failed to remove memory volumes whie removing vm {0} (volumes: {1})", getVmId(), memoryState);
        }
    }
}
#end_block

#method_before
protected void setLock(EngineLock lock) {
    context.withLock(null);
}
#method_after
protected void setLock(EngineLock lock) {
    context.withLock(lock);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getVdsGroup().setArchitecture(getArchitecture());
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldGroup.getcompatibility_version(), getParameters().getVdsGroup().getcompatibility_version())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed the canDo.
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = ListUtils.firstMatch(Config.<List<String>>getValue(ConfigValues.ClusterEmulatedMachines, getParameters().getVdsGroup().getcompatibility_version().getValue()), vds.getSupportedEmulatedMachines().split(","));
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        } else {
            getParameters().getVdsGroup().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldGroup.getArchitecture() != getVdsGroup().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        getParameters().getVdsGroup().setEmulatedMachine(null);
    }
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    if (oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null) {
        for (VDS vds : allForVdsGroup) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, parameters, cloneOnlyEngineContext());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        // when moving the cluster back into a DC, need to add its management network
        Network managementNetwork = getNetworkDAO().getByNameAndDataCenter(NetworkUtils.getEngineNetwork(), getVdsGroup().getStoragePoolId());
        getNetworkClusterDAO().save(new NetworkCluster(getVdsGroup().getId(), managementNetwork.getId(), NetworkStatus.OPERATIONAL, true, true, true));
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getVdsGroup().setArchitecture(getArchitecture());
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldGroup.getcompatibility_version(), getParameters().getVdsGroup().getcompatibility_version())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed the canDo.
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = ListUtils.firstMatch(Config.<List<String>>getValue(ConfigValues.ClusterEmulatedMachines, getParameters().getVdsGroup().getcompatibility_version().getValue()), vds.getSupportedEmulatedMachines().split(","));
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        } else {
            getParameters().getVdsGroup().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldGroup.getArchitecture() != getVdsGroup().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        getParameters().getVdsGroup().setEmulatedMachine(null);
    }
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    if (oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null) {
        for (VDS vds : allForVdsGroup) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        // when moving the cluster back into a DC, need to add its management network
        Network managementNetwork = getNetworkDAO().getByNameAndDataCenter(NetworkUtils.getEngineNetwork(), getVdsGroup().getStoragePoolId());
        getNetworkClusterDAO().save(new NetworkCluster(getVdsGroup().getId(), managementNetwork.getId(), NetworkStatus.OPERATIONAL, true, true, true));
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        if (!isVdsGroupUnique(getVdsGroup().getName())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getVdsGroup().getcompatibility_version().compareTo(oldGroup.getcompatibility_version()) < 0) {
        if (!allForVdsGroup.isEmpty()) {
            result = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            StoragePool storagePool = getStoragePoolDAO().get(oldGroup.getStoragePoolId());
            if (storagePool != null && getVdsGroup().getcompatibility_version().compareTo(storagePool.getcompatibility_version()) < 0) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForVdsGroup);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getcpu_name() != null || getVdsGroup().getcpu_name() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getcpu_name()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDAO().getAllForVdsGroup(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForVdsGroup.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getVdsGroup().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getcpu_name(), getVdsGroup().getcpu_name());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getcpu_name());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<VDS>();
        boolean isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getcompatibility_version(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        AuditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDAO().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID).equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().getcompatibility_version() != null && Version.v3_3.compareTo(getVdsGroup().getcompatibility_version()) > 0 && getVdsGroup().isEnableBallooning()) {
        // Members of pre-3.3 clusters don't support ballooning; here we act like a 3.2 engine
        addCanDoActionMessage(VdcBllMessages.QOS_BALLOON_NOT_SUPPORTED);
        result = false;
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VdcBllMessages.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessageVariable("compatibilityVersion", getVdsGroup().getcompatibility_version().getValue());
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getVdsGroup().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result) {
        result = validateClusterPolicy();
    }
    // non-empty required sources list and rng-unsupported cluster version
    if (result && !getVdsGroup().getRequiredRngSources().isEmpty() && !FeatureSupported.virtIoRngSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
        result = false;
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        if (!isVdsGroupUnique(getVdsGroup().getName())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getVdsGroup().getcompatibility_version().compareTo(oldGroup.getcompatibility_version()) < 0) {
        if (!allForVdsGroup.isEmpty()) {
            result = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            StoragePool storagePool = getStoragePoolDAO().get(oldGroup.getStoragePoolId());
            if (storagePool != null && getVdsGroup().getcompatibility_version().compareTo(storagePool.getcompatibility_version()) < 0) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForVdsGroup);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getcpu_name() != null || getVdsGroup().getcpu_name() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getcpu_name()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDAO().getAllForVdsGroup(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForVdsGroup.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getVdsGroup().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getcpu_name(), getVdsGroup().getcpu_name());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getcpu_name());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<VDS>();
        boolean isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getcompatibility_version(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        AuditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDAO().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID).equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().getcompatibility_version() != null && Version.v3_3.compareTo(getVdsGroup().getcompatibility_version()) > 0 && getVdsGroup().isEnableBallooning()) {
        // Members of pre-3.3 clusters don't support ballooning; here we act like a 3.2 engine
        addCanDoActionMessage(VdcBllMessages.QOS_BALLOON_NOT_SUPPORTED);
        result = false;
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VdcBllMessages.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessageVariable("compatibilityVersion", getVdsGroup().getcompatibility_version().getValue());
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getVdsGroup().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getVdsGroup().getcompatibility_version()) && getVdsGroup().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failCanDoAction(VdcBllMessages.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy();
    }
    // non-empty required sources list and rng-unsupported cluster version
    if (result && !getVdsGroup().getRequiredRngSources().isEmpty() && !FeatureSupported.virtIoRngSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
        result = false;
    }
    return result;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (StorageHelperDirector.getInstance().getItem(getNewMaster(false).getStorageType()).connectStorageToDomainByVdsId(getNewMaster(false), getVds().getId())) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getParameters().getStoragePoolId(), _newMasterStorageDomainId, null, EventType.RECOVERY, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                getParameters().setStorageDomainId(getMasterDomainIdFromDb());
                StoragePoolIsoMap domainPoolMap = new StoragePoolIsoMap(getParameters().getNewMasterDomainId(), getParameters().getStoragePoolId(), StorageDomainStatus.Active);
                DbFacade.getInstance().getStoragePoolIsoMapDao().save(domainPoolMap);
                getParameters().setVdsId(getVds().getId());
                VdcReturnValueBase returnVal = runInternalAction(VdcActionType.ReconstructMasterDomain, getParameters(), cloneOnlyEngineContext());
                boolean reconstructVerbExecuted = (returnVal.getActionReturnValue() != null) ? (Boolean) returnVal.getActionReturnValue() : false;
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), StoragePoolStatus.NonResponsive);
                if (!reconstructVerbExecuted) {
                    getStoragePoolIsoMapDAO().remove(domainPoolMap.getId());
                }
                if (returnVal.getSucceeded()) {
                    updateStorageDomainFormat(loadTargetedMasterDomain());
                }
                setSucceeded(returnVal.getSucceeded());
                return new EventResult(reconstructVerbExecuted, EventType.RECONSTRUCT);
            }
        });
    } else {
        getReturnValue().setFault(new VdcFault(new VdcBLLException(VdcBllErrors.StorageServerConnectionError, "Failed to connect storage"), VdcBllErrors.StorageServerConnectionError));
    }
}
#method_after
@Override
protected void executeCommand() {
    if (StorageHelperDirector.getInstance().getItem(getNewMaster(false).getStorageType()).connectStorageToDomainByVdsId(getNewMaster(false), getVds().getId())) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getParameters().getStoragePoolId(), _newMasterStorageDomainId, null, EventType.RECOVERY, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                getParameters().setStorageDomainId(getMasterDomainIdFromDb());
                StoragePoolIsoMap domainPoolMap = new StoragePoolIsoMap(getParameters().getNewMasterDomainId(), getParameters().getStoragePoolId(), StorageDomainStatus.Active);
                DbFacade.getInstance().getStoragePoolIsoMapDao().save(domainPoolMap);
                getParameters().setVdsId(getVds().getId());
                VdcReturnValueBase returnVal = runInternalAction(VdcActionType.ReconstructMasterDomain, getParameters(), cloneContextAndDetachFromParent());
                boolean reconstructVerbExecuted = (returnVal.getActionReturnValue() != null) ? (Boolean) returnVal.getActionReturnValue() : false;
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), StoragePoolStatus.NonResponsive);
                if (!reconstructVerbExecuted) {
                    getStoragePoolIsoMapDAO().remove(domainPoolMap.getId());
                }
                if (returnVal.getSucceeded()) {
                    updateStorageDomainFormat(loadTargetedMasterDomain());
                }
                setSucceeded(returnVal.getSucceeded());
                return new EventResult(reconstructVerbExecuted, EventType.RECONSTRUCT);
            }
        });
    } else {
        getReturnValue().setFault(new VdcFault(new VdcBLLException(VdcBllErrors.StorageServerConnectionError, "Failed to connect storage"), VdcBllErrors.StorageServerConnectionError));
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean success = true;
    // If not, just save the connection to the database
    if (!Guid.isNullOrEmpty(getParameters().getVdsId())) {
        Pair<Boolean, Integer> result = connectHostToStorage();
        boolean isValidConnection = result.getFirst();
        // Process failure
        if (!isValidConnection) {
            throw new VdcBLLException(VdcBllErrors.forValue(result.getSecond()));
        }
    }
    if (success) {
        StorageServerConnections connection = getConnection();
        connection.setid(Guid.newGuid().toString());
        saveConnection(connection);
        getReturnValue().setActionReturnValue(connection.getid());
    }
    setSucceeded(success);
}
#method_after
@Override
protected void executeCommand() {
    // If not, just save the connection to the database
    if (!Guid.isNullOrEmpty(getParameters().getVdsId())) {
        Pair<Boolean, Integer> result = connectHostToStorage();
        boolean isValidConnection = result.getFirst();
        // Process failure
        if (!isValidConnection) {
            throw new VdcBLLException(VdcBllErrors.forValue(result.getSecond()));
        }
    }
    StorageServerConnections connection = getConnection();
    connection.setid(Guid.newGuid().toString());
    saveConnection(connection);
    getReturnValue().setActionReturnValue(connection.getid());
    setSucceeded(true);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + salt;
    result = prime * result + value;
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + value;
    result = prime * result + salt;
    return result;
}
#end_block

#method_before
@Before
public void setUp() {
    this.model = new SortedListModel<TestItem>() {

        @Override
        protected Configurator lookupConfigurator() {
            return null;
        }

        @Override
        protected ILogger lookupLogger() {
            return null;
        }
    };
    model.comparator = makeValueAscComparator();
}
#method_after
@Before
public void setUp() {
    testedModel = new SortedListModel<TestItem>() {

        @Override
        protected Configurator lookupConfigurator() {
            return null;
        }

        @Override
        protected ILogger lookupLogger() {
            return null;
        }
    };
}
#end_block

#method_before
@Test
public void testSortItems_nullComparator() {
    model.comparator = null;
    List<TestItem> initial = Arrays.asList(ITEM_1_2, ITEM_1_1);
    Collection<TestItem> sorted = model.sortItems(initial);
    assertEquals(sorted, initial);
}
#method_after
@Test
public void testSortItems_nullComparator() {
    List<TestItem> initial = Arrays.asList(ITEM_1_2, ITEM_1_1);
    testedModel.setComparator(null);
    Collection<TestItem> sorted = testedModel.sortItems(initial);
    assertEquals(sorted, initial);
}
#end_block

#method_before
@Test
public void testSortItems_nullItems() {
    Collection<TestItem> sorted = model.sortItems(null);
    assertNull(sorted);
}
#method_after
@Test
public void testSortItems_nullItems() {
    testedModel.setComparator(makeValueComparator());
    Collection<TestItem> sorted = testedModel.sortItems(null);
    assertNull(sorted);
}
#end_block

#method_before
@Test
public void testSortItems_retainOrder() {
    List<TestItem> initial = Arrays.asList(ITEM_2_1, ITEM_2_2, ITEM_1_2, ITEM_1_1);
    List<TestItem> expected = Arrays.asList(ITEM_1_2, ITEM_1_1, ITEM_2_1, ITEM_2_2);
    Collection<TestItem> sorted = model.sortItems(initial);
    assertArrayEquals(sorted.toArray(), expected.toArray());
    sorted.remove(ITEM_1_2);
    sorted.add(ITEM_1_2);
    expected = Arrays.asList(ITEM_1_1, ITEM_1_2, ITEM_2_1, ITEM_2_2);
    assertArrayEquals(sorted.toArray(), expected.toArray());
    sorted.removeAll(Arrays.asList(ITEM_1_2, ITEM_2_2));
    sorted.addAll(Arrays.asList(ITEM_2_2, ITEM_1_2));
    assertArrayEquals(sorted.toArray(), expected.toArray());
}
#method_after
@Test
public void testSortItems_retainOrder() {
    List<TestItem> initial = Arrays.asList(ITEM_2_1, ITEM_2_2, ITEM_1_2, ITEM_1_1);
    List<TestItem> expected = Arrays.asList(ITEM_1_2, ITEM_1_1, ITEM_2_1, ITEM_2_2);
    testedModel.setComparator(makeValueComparator());
    Collection<TestItem> sorted = testedModel.sortItems(initial);
    assertArrayEquals(sorted.toArray(), expected.toArray());
}
#end_block

#method_before
@Override
public int compare(T a, T b) {
    int ret = comparator.compare(a, b);
    if (ret == 0 && positionCallback != null) {
        ret = positionCallback.getPosition(a) - positionCallback.getPosition(b);
    }
    if (ret == 0) {
        ret = a.hashCode() - b.hashCode();
    }
    ret = Integer.signum(ret);
    return sortAscending ? ret : -ret;
}
#method_after
@Override
public int compare(T a, T b) {
    return sortAscending ? comparator.compare(a, b) : comparator.compare(b, a);
}
#end_block

#method_before
protected final Collection<T> sortItems(Collection<T> items) {
    if (items == null || comparator == null) {
        return items;
    }
    return new SortedCollection<T>(comparator, items);
}
#method_after
protected final Collection<T> sortItems(Collection<T> items) {
    if (items == null || comparator == null) {
        return items;
    }
    List<T> sortedList = new ArrayList<T>(items);
    Collections.sort(sortedList, comparator);
    return sortedList;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__STOP);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_VOLUME);
    addCanDoActionMessage(String.format("$volumeName %1$s", getGlusterVolumeName()));
    addCanDoActionMessage(String.format("$vdsGroup %1$s", getVdsGroupName()));
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__STOP);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_VOLUME);
    addCanDoActionMessageVariable("volumeName", getGlusterVolumeName());
    addCanDoActionMessageVariable("vdsGroup", getVdsGroupName());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (!volume.isOnline()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_ALREADY_STOPPED);
        addCanDoActionMessage(String.format("$volumeName %1$s", volume.getName()));
        return false;
    }
    if (getGlusterTaskUtils().isTaskOfType(volume, GlusterTaskType.REBALANCE) && getGlusterTaskUtils().isTaskStatus(volume, JobExecutionStatus.STARTED)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_CANNOT_STOP_REBALANCE_IN_PROGRESS);
    }
    if (getGlusterTaskUtils().isTaskOfType(volume, GlusterTaskType.REMOVE_BRICK) && getGlusterTaskUtils().isTaskStatus(volume, JobExecutionStatus.STARTED)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_CANNOT_STOP_REMOVE_BRICK_IN_PROGRESS);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (!volume.isOnline()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_ALREADY_STOPPED);
        addCanDoActionMessageVariable("volumeName", volume.getName());
        return false;
    }
    if (getGlusterTaskUtils().isTaskOfType(volume, GlusterTaskType.REBALANCE) && getGlusterTaskUtils().isTaskStatus(volume, JobExecutionStatus.STARTED)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_CANNOT_STOP_REBALANCE_IN_PROGRESS);
    }
    if (getGlusterTaskUtils().isTaskOfType(volume, GlusterTaskType.REMOVE_BRICK) && getGlusterTaskUtils().isTaskStatus(volume, JobExecutionStatus.STARTED)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_CANNOT_STOP_REMOVE_BRICK_IN_PROGRESS);
    }
    return true;
}
#end_block

#method_before
private void addDomainInProblemData(Guid domainId, Guid vdsId, String vdsName) {
    _domainsInProblem.put(domainId, new HashSet<Guid>(Arrays.asList(vdsId)));
    log.warnFormat("domain {0} in problem. vds: {1}", getDomainIdTuple(domainId), vdsName);
    Class[] inputType = new Class[] { Guid.class };
    Object[] inputParams = new Object[] { domainId };
    String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "onTimer", inputType, inputParams, Config.<Integer>getValue(ConfigValues.StorageDomainFalureTimeoutInMinutes), TimeUnit.MINUTES);
    clearTimer(domainId);
    _timers.put(domainId, jobId);
}
#method_after
private void addDomainInProblemData(Guid domainId, Guid vdsId, String vdsName) {
    _domainsInProblem.put(domainId, new HashSet<Guid>(Arrays.asList(vdsId)));
    log.warnFormat("domain {0} in problem. vds: {1}", getDomainIdTuple(domainId), vdsName);
    Class[] inputType = new Class[] { Guid.class };
    Object[] inputParams = new Object[] { domainId };
    String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "onTimer", inputType, inputParams, Config.<Integer>getValue(ConfigValues.StorageDomainFailureTimeoutInMinutes), TimeUnit.MINUTES);
    clearTimer(domainId);
    _timers.put(domainId, jobId);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private List<LUNs> getLUNsFromVgInfo(String vgId) {
    VDSReturnValue returnValue;
    try {
        returnValue = getVdsBroker().RunVdsCommand(VDSCommandType.GetVGInfo, new GetVGInfoVDSCommandParameters(getParameters().getVdsId(), vgId));
    } catch (RuntimeException e) {
        log.errorFormat("Could not get info for VG ID: {0}. Error message: {1}", vgId, e.getMessage());
        return null;
    }
    return (ArrayList<LUNs>) returnValue.getReturnValue();
}
#method_after
private List<LUNs> getLUNsFromVgInfo(String vgId) {
    List<LUNs> luns = new ArrayList<>();
    VDSReturnValue returnValue;
    try {
        returnValue = runVdsCommand(VDSCommandType.GetVGInfo, new GetVGInfoVDSCommandParameters(getParameters().getVdsId(), vgId));
    } catch (RuntimeException e) {
        log.errorFormat("Could not get info for VG ID: {0}. Error message: {1}", vgId, e.getMessage());
        return luns;
    }
    luns.addAll((ArrayList<LUNs>) returnValue.getReturnValue());
    return luns;
}
#end_block

#method_before
private static Pair<StorageDomainStatic, Guid> BuildStorageStaticFromXmlRpcStruct(Map<String, Object> xmlRpcStruct) {
    Pair<StorageDomainStatic, Guid> returnValue = new Pair<StorageDomainStatic, Guid>();
    StorageDomainStatic sdStatic = new StorageDomainStatic();
    if (xmlRpcStruct.containsKey("name")) {
        sdStatic.setStorageName(xmlRpcStruct.get("name").toString());
    }
    if (xmlRpcStruct.containsKey("type")) {
        sdStatic.setStorageType(EnumUtils.valueOf(StorageType.class, xmlRpcStruct.get("type").toString(), true));
    }
    if (xmlRpcStruct.containsKey("class")) {
        String domainType = xmlRpcStruct.get("class").toString();
        if ("backup".equalsIgnoreCase(domainType)) {
            sdStatic.setStorageDomainType(StorageDomainType.ImportExport);
        } else {
            sdStatic.setStorageDomainType(EnumUtils.valueOf(StorageDomainType.class, domainType, true));
        }
    }
    if (xmlRpcStruct.containsKey("version")) {
        sdStatic.setStorageFormat(StorageFormatType.forValue(xmlRpcStruct.get("version").toString()));
    }
    if (sdStatic.getStorageType() != StorageType.UNKNOWN) {
        if (sdStatic.getStorageType().isFileDomain() && xmlRpcStruct.containsKey("remotePath")) {
            String path = xmlRpcStruct.get("remotePath").toString();
            List<StorageServerConnections> connections = DbFacade.getInstance().getStorageServerConnectionDao().getAllForStorage(path);
            if (connections.isEmpty()) {
                sdStatic.setConnection(new StorageServerConnections());
                sdStatic.getConnection().setconnection(path);
                sdStatic.getConnection().setstorage_type(sdStatic.getStorageType());
            } else {
                sdStatic.setStorage(connections.get(0).getid());
                sdStatic.setConnection(connections.get(0));
            }
        } else if (sdStatic.getStorageType() != StorageType.NFS && (xmlRpcStruct.containsKey("vguuid"))) {
            sdStatic.setStorage(xmlRpcStruct.get("vguuid").toString());
        }
    }
    if (xmlRpcStruct.containsKey("state")) {
        sdStatic.setSanState(EnumUtils.valueOf(SANState.class, xmlRpcStruct.get("state").toString().toUpperCase(), false));
    }
    returnValue.setFirst(sdStatic);
    returnValue.setSecond(Guid.createGuidFromString(((String[]) xmlRpcStruct.get("pool"))[0]));
    return returnValue;
}
#method_after
private static Pair<StorageDomainStatic, Guid> BuildStorageStaticFromXmlRpcStruct(Map<String, Object> xmlRpcStruct) {
    Pair<StorageDomainStatic, Guid> returnValue = new Pair<StorageDomainStatic, Guid>();
    StorageDomainStatic sdStatic = new StorageDomainStatic();
    if (xmlRpcStruct.containsKey("name")) {
        sdStatic.setStorageName(xmlRpcStruct.get("name").toString());
    }
    if (xmlRpcStruct.containsKey("type")) {
        sdStatic.setStorageType(EnumUtils.valueOf(StorageType.class, xmlRpcStruct.get("type").toString(), true));
    }
    if (xmlRpcStruct.containsKey("class")) {
        String domainType = xmlRpcStruct.get("class").toString();
        if ("backup".equalsIgnoreCase(domainType)) {
            sdStatic.setStorageDomainType(StorageDomainType.ImportExport);
        } else {
            sdStatic.setStorageDomainType(EnumUtils.valueOf(StorageDomainType.class, domainType, true));
        }
    }
    if (xmlRpcStruct.containsKey("version")) {
        sdStatic.setStorageFormat(StorageFormatType.forValue(xmlRpcStruct.get("version").toString()));
    }
    if (sdStatic.getStorageType() != StorageType.UNKNOWN) {
        if (sdStatic.getStorageType().isFileDomain() && xmlRpcStruct.containsKey("remotePath")) {
            String path = xmlRpcStruct.get("remotePath").toString();
            List<StorageServerConnections> connections = DbFacade.getInstance().getStorageServerConnectionDao().getAllForStorage(path);
            if (connections.isEmpty()) {
                sdStatic.setConnection(new StorageServerConnections());
                sdStatic.getConnection().setconnection(path);
                sdStatic.getConnection().setstorage_type(sdStatic.getStorageType());
            } else {
                sdStatic.setStorage(connections.get(0).getid());
                sdStatic.setConnection(connections.get(0));
            }
        } else if (sdStatic.getStorageType() != StorageType.NFS && (xmlRpcStruct.containsKey("vguuid"))) {
            sdStatic.setStorage(xmlRpcStruct.get("vguuid").toString());
        }
    }
    if (xmlRpcStruct.containsKey("state")) {
        sdStatic.setSanState(EnumUtils.valueOf(SANState.class, xmlRpcStruct.get("state").toString().toUpperCase(), false));
    }
    returnValue.setFirst(sdStatic);
    Object[] poolUUIDs = (Object[]) xmlRpcStruct.get("pool");
    if (poolUUIDs.length != 0) {
        returnValue.setSecond(Guid.createGuidFromString(poolUUIDs[0].toString()));
    }
    return returnValue;
}
#end_block

#method_before
protected boolean checkExistingStorageDomain() {
    // Prevent importing DATA domain if cluster version is not supported.
    if (getParameters().getStorageDomain().getStorageDomainType() == StorageDomainType.Data && !FeatureSupported.importDataStorageDomain(getVds().getVdsGroupCompatibilityVersion())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_DATA_DOMAIN_IS_NOT_SUPPORTED);
    }
    if (DbFacade.getInstance().getStorageDomainStaticDao().get(getStorageDomain().getId()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
    }
    List<Guid> storageIds = (ArrayList<Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainsList, new HSMGetStorageDomainsListVDSCommandParameters(getVdsId(), Guid.Empty, getStorageDomain().getStorageType(), getStorageDomain().getStorageDomainType(), "")).getReturnValue();
    if (!storageIds.contains(getStorageDomain().getId())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_EXIST);
    }
    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getStorageDomain().getId())).getReturnValue();
    if (domainFromIrs.getFirst().getStorageDomainType() != getStorageDomain().getStorageDomainType()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_CHANGE_STORAGE_DOMAIN_TYPE);
    }
    return concreteCheckExistingStorageDomain(domainFromIrs);
}
#method_after
protected boolean checkExistingStorageDomain() {
    // prevent importing DATA domain
    if (getParameters().getStorageDomain().getStorageDomainType() == StorageDomainType.Data) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_DATA_DOMAIN_PROHIBITED);
    }
    if (DbFacade.getInstance().getStorageDomainStaticDao().get(getStorageDomain().getId()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
    }
    List<Guid> storageIds = (ArrayList<Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainsList, new HSMGetStorageDomainsListVDSCommandParameters(getVdsId(), Guid.Empty, getStorageDomain().getStorageType(), getStorageDomain().getStorageDomainType(), "")).getReturnValue();
    if (!storageIds.contains(getStorageDomain().getId())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_EXIST);
    }
    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getStorageDomain().getId())).getReturnValue();
    if (domainFromIrs.getFirst().getStorageDomainType() != getStorageDomain().getStorageDomainType()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_CHANGE_STORAGE_DOMAIN_TYPE);
    }
    return concreteCheckExistingStorageDomain(domainFromIrs);
}
#end_block

#method_before
private static String getEntityName(String ovfData) {
    int beginIndexOfEntityName = ovfData.indexOf(ENTITY_NAME) + ENTITY_NAME.length();
    int endIndexOfEntityName = ovfData.indexOf(END_ENTITY_NAME);
    String entityName = ovfData.substring(beginIndexOfEntityName, endIndexOfEntityName);
    return entityName;
}
#method_after
private static String getEntityName(String ovfData) {
    int beginIndexOfEntityName = ovfData.indexOf(ENTITY_NAME) + ENTITY_NAME.length();
    int endIndexOfEntityName = ovfData.indexOf(END_ENTITY_NAME, beginIndexOfEntityName);
    String entityName = ovfData.substring(beginIndexOfEntityName, endIndexOfEntityName);
    return entityName;
}
#end_block

#method_before
private static Guid getEntityId(String fileName) {
    return Guid.createGuidFromString(fileName.substring(0, fileName.indexOf(".ovf")));
}
#method_after
private static Guid getEntityId(String fileName) {
    return Guid.createGuidFromString(fileName.substring(0, fileName.length() - OVF_FILE_EXT.length()));
}
#end_block

#method_before
public static List<OvfEntityData> getOvfEntities(byte[] tarByte, Guid storageDomainId) {
    List<OvfEntityData> ovfEntityDataFromTar = new ArrayList<>();
    InputStream is = new ByteArrayInputStream(tarByte);
    Map<String, String> filesFromTar;
    try (OutMemoryTar memoryTar = new OutMemoryTar(is)) {
        filesFromTar = memoryTar.unTar();
    } catch (IOException e) {
        throw new RuntimeException(String.format("Exception while getting OVFs files from tar file for domain %s", storageDomainId), e);
    }
    for (String fileName : filesFromTar.keySet()) {
        if (fileName.contains(OVF_FILE_EXT)) {
            String ovfData = filesFromTar.get(fileName);
            // Creates an OVF entity data.
            OvfEntityData ovfEntityData = createOvfEntityData(storageDomainId, ovfData, getVmEntityType(ovfData), getEntityName(ovfData), storageDomainId);
            ovfEntityDataFromTar.add(ovfEntityData);
        }
    }
    return ovfEntityDataFromTar;
}
#method_after
public static List<OvfEntityData> getOvfEntities(byte[] tar, Guid storageDomainId) {
    List<OvfEntityData> ovfEntityDataFromTar = new ArrayList<>();
    InputStream is = new ByteArrayInputStream(tar);
    Map<String, ByteBuffer> filesFromTar;
    try (TarInMemoryExport memoryTar = new TarInMemoryExport(is)) {
        filesFromTar = memoryTar.unTar();
    } catch (IOException e) {
        throw new RuntimeException(String.format("Exception while getting OVFs files from tar file for domain %s", storageDomainId), e);
    }
    for (Entry<String, ByteBuffer> fileEntry : filesFromTar.entrySet()) {
        if (fileEntry.getKey().endsWith(OVF_FILE_EXT)) {
            String ovfData = new String(fileEntry.getValue().array());
            // Creates an OVF entity data.
            OvfEntityData ovfEntityData = createOvfEntityData(storageDomainId, ovfData, getVmEntityType(ovfData), getEntityName(ovfData), getEntityId(fileEntry.getKey()));
            ovfEntityDataFromTar.add(ovfEntityData);
        }
    }
    return ovfEntityDataFromTar;
}
#end_block

#method_before
public static boolean setupManagementNetwork(Version version) {
    return supportedInConfig(ConfigValues.NormalizedMgmgNetworkEnabled, version);
}
#method_after
public static boolean setupManagementNetwork(Version version) {
    return supportedInConfig(ConfigValues.NormalizedMgmtNetworkEnabled, version);
}
#end_block

#method_before
protected boolean checkExistingStorageDomain() {
    // Prevent importing DATA domain if cluster version is not supported.
    if (getParameters().getStorageDomain().getStorageDomainType() == StorageDomainType.Data && !FeatureSupported.importDataStorageDomain(getVds().getVdsGroupCompatibilityVersion())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_DATA_DOMAIN_IS_NOT_SUPPORTED);
    }
    if (DbFacade.getInstance().getStorageDomainStaticDao().get(getStorageDomain().getId()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
    }
    List<Guid> storageIds = (ArrayList<Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainsList, new HSMGetStorageDomainsListVDSCommandParameters(getVdsId(), Guid.Empty, getStorageDomain().getStorageType(), getStorageDomain().getStorageDomainType(), "")).getReturnValue();
    if (!storageIds.contains(getStorageDomain().getId())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_EXIST);
    }
    Pair<StorageDomainStatic, SANState> domainFromIrs = (Pair<StorageDomainStatic, SANState>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getStorageDomain().getId())).getReturnValue();
    if (domainFromIrs.getFirst().getStorageDomainType() != getStorageDomain().getStorageDomainType()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_CHANGE_STORAGE_DOMAIN_TYPE);
    }
    return concreteCheckExistingStorageDomain(domainFromIrs);
}
#method_after
protected boolean checkExistingStorageDomain() {
    if (DbFacade.getInstance().getStorageDomainStaticDao().get(getStorageDomain().getId()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
    }
    List<Guid> storageIds = (ArrayList<Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainsList, new HSMGetStorageDomainsListVDSCommandParameters(getVdsId(), Guid.Empty, getStorageDomain().getStorageType(), getStorageDomain().getStorageDomainType(), "")).getReturnValue();
    if (!storageIds.contains(getStorageDomain().getId())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_EXIST);
    }
    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getStorageDomain().getId())).getReturnValue();
    if (domainFromIrs.getFirst().getStorageDomainType() != getStorageDomain().getStorageDomainType()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_CHANGE_STORAGE_DOMAIN_TYPE);
    }
    return concreteCheckExistingStorageDomain(domainFromIrs);
}
#end_block

#method_before
protected boolean concreteCheckExistingStorageDomain(Pair<StorageDomainStatic, SANState> domain) {
    boolean returnValue = false;
    StorageDomainStatic domainFromIrs = domain.getFirst();
    if (StringUtils.isEmpty(getStorageDomain().getStorageStaticData().getStorage()) && StringUtils.isEmpty(domainFromIrs.getStorage()) && domainFromIrs.getConnection() != null && getStorageDomain().getStorageStaticData().getConnection() != null) {
        returnValue = (StringUtils.equals(domainFromIrs.getConnection().getconnection(), getStorageDomain().getStorageStaticData().getConnection().getconnection()));
    } else if (!StringUtils.isEmpty(getStorageDomain().getStorageStaticData().getStorage()) && !StringUtils.isEmpty(domainFromIrs.getStorage())) {
        returnValue = (StringUtils.equals(domainFromIrs.getStorage(), getStorageDomain().getStorageStaticData().getStorage()));
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_ADD_EXISTING_STORAGE_DOMAIN_CONNECTION_DATA_ILLEGAL);
    }
    return returnValue;
}
#method_after
protected boolean concreteCheckExistingStorageDomain(Pair<StorageDomainStatic, Guid> domain) {
    boolean returnValue = false;
    StorageDomainStatic domainFromIrs = domain.getFirst();
    if (StringUtils.isEmpty(getStorageDomain().getStorageStaticData().getStorage()) && StringUtils.isEmpty(domainFromIrs.getStorage()) && domainFromIrs.getConnection() != null && getStorageDomain().getStorageStaticData().getConnection() != null) {
        returnValue = (StringUtils.equals(domainFromIrs.getConnection().getconnection(), getStorageDomain().getStorageStaticData().getConnection().getconnection()));
    } else if (!StringUtils.isEmpty(getStorageDomain().getStorageStaticData().getStorage()) && !StringUtils.isEmpty(domainFromIrs.getStorage())) {
        returnValue = (StringUtils.equals(domainFromIrs.getStorage(), getStorageDomain().getStorageStaticData().getStorage()));
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_ADD_EXISTING_STORAGE_DOMAIN_CONNECTION_DATA_ILLEGAL);
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Arrays.asList(getStorageDomain().getId()), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            VdcReturnValueBase returnValue = getBackend().runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters, new CommandContext(getCompensationContext()));
            setSucceeded(returnValue.getSucceeded());
            if (!returnValue.getSucceeded()) {
                getReturnValue().setFault(returnValue.getFault());
            }
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                connectAllHostsToPool();
                runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = getEntitiesFromStorageOvfDisk();
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                        map.setStatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
                            updateStorageDomainFormat(getStorageDomain());
                        }
                        // Update unregistered entities
                        for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                            getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                            getUnregisteredOVFDataDao().saveOVFData(ovf);
                            log.infoFormat("Adding OVF data of entity id {0} and entity name {1}", ovf.getEntityId(), ovf.getEntityName());
                        }
                        return null;
                    }
                });
                if (getParameters().getActivate()) {
                    attemptToActivateDomain();
                }
                setSucceeded(true);
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Arrays.asList(getStorageDomain().getId()), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters);
            setSucceeded(returnValue.getSucceeded());
            if (!returnValue.getSucceeded()) {
                getReturnValue().setFault(returnValue.getFault());
            }
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                connectAllHostsToPool();
                // Forcibly detach only data storage domains.
                if (getStorageDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
                    @SuppressWarnings("unchecked")
                    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getParameters().getStorageDomainId())).getReturnValue();
                    // If the storage domain is already related to another Storage Pool, detach it by force.
                    Guid storagePoolId = domainFromIrs.getSecond();
                    if (storagePoolId != null) {
                        // Master domain version is not relevant since force remove at
                        // DetachStorageDomainVdsCommand
                        // does not use it.
                        // Storage pool id can be empty
                        DetachStorageDomainVDSCommandParameters detachParams = new DetachStorageDomainVDSCommandParameters(getVds().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, 0);
                        detachParams.setForce(true);
                        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, detachParams);
                        if (!returnValue.getSucceeded()) {
                            log.warnFormat("Detaching Storage Domain {0} from it's previous storage pool {1} has failed. " + "The meta data of the Storage Domain might still indicate that it is attached to a different Storage Pool.", getParameters().getStorageDomainId(), storagePoolId);
                            throw new VdcBLLException(returnValue.getVdsError() != null ? returnValue.getVdsError().getCode() : VdcBllErrors.ENGINE, returnValue.getExceptionString());
                        }
                    }
                }
                runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = getEntitiesFromStorageOvfDisk();
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                        map.setStatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
                            updateStorageDomainFormat(getStorageDomain());
                        }
                        // Update unregistered entities
                        for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                            getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                            getUnregisteredOVFDataDao().saveOVFData(ovf);
                            log.infoFormat("Adding OVF data of entity id {0} and entity name {1}", ovf.getEntityId(), ovf.getEntityName());
                        }
                        return null;
                    }
                });
                if (getParameters().getActivate()) {
                    attemptToActivateDomain();
                }
                setSucceeded(true);
            }
        }
    }
}
#end_block

#method_before
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    List<OvfEntityData> ovfEntitiesFromTar = new ArrayList<>();
    // Get all unregistered disks.
    List<Disk> unregisteredDisks = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisks, new GetUnregisteredDisksQueryParameters(getParameters().getStorageDomainId(), getVds().getStoragePoolId())).getReturnValue();
    Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(unregisteredDisks);
    DiskImage ovfDisk = ovfDiskAndSize.getFirst();
    if (ovfDisk != null) {
        VDSReturnValue retrievedByteData = runVdsCommand(VDSCommandType.RetrieveImageData, new ImageHttpAccessVDSCommandParameters(getVdsId(), getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()));
        if (retrievedByteData.getSucceeded()) {
            ovfEntitiesFromTar = OutMemoryTar.unTar((byte[]) retrievedByteData.getReturnValue(), getParameters().getStorageDomainId());
        }
    }
    return ovfEntitiesFromTar;
}
#method_after
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    List<OvfEntityData> ovfEntitiesFromTar = Collections.emptyList();
    // Get all unregistered disks.
    List<Disk> unregisteredDisks = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisks, new GetUnregisteredDisksQueryParameters(getParameters().getStorageDomainId(), getVds().getStoragePoolId())).getReturnValue();
    if (!unregisteredDisks.isEmpty()) {
        Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(unregisteredDisks);
        DiskImage ovfDisk = ovfDiskAndSize.getFirst();
        if (ovfDisk != null) {
            VDSReturnValue retrievedByteData = runVdsCommand(VDSCommandType.RetrieveImageData, new ImageHttpAccessVDSCommandParameters(getVdsId(), getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()));
            if (retrievedByteData.getSucceeded()) {
                ovfEntitiesFromTar = OvfUtils.getOvfEntities((byte[]) retrievedByteData.getReturnValue(), getParameters().getStorageDomainId());
            }
        }
    }
    return ovfEntitiesFromTar;
}
#end_block

#method_before
private Pair<DiskImage, Long> getLatestOVFDisk(List<Disk> disks) {
    Date lastUpdate = new Date();
    boolean lastIsUpdated = false;
    Long size = 0L;
    Disk diskToGetOVF = null;
    for (Disk disk : disks) {
        boolean isDiskLastUpdated = false;
        // Check which disks are of OVF_STORE
        String diskDecription = ((DiskImage) disk).getDescription();
        if (diskDecription.contains(OvfInfoFileConstants.OvfStoreDescriptionLabel)) {
            Map<String, Object> diskDescriptionMap = buildJson(diskDecription);
            if (!isDomainExistsInDiskDescription(diskDescriptionMap, getParameters().getStorageDomainId())) {
                break;
            }
            boolean isUpdated = Boolean.valueOf(diskDescriptionMap.get(OvfInfoFileConstants.IsUpdated).toString());
            Date date = getDateFromDiskDescription(diskDescriptionMap);
            // about to update from.
            if (!lastIsUpdated && isUpdated) {
                isDiskLastUpdated = true;
            // If also the current disk was not updated, then check which disk has the latest update date.
            } else if (!isUpdated && date.after(lastUpdate)) {
                isDiskLastUpdated = true;
            // If also the current disk was updated, then check which disk has the latest update date.
            } else if (lastIsUpdated && isUpdated && date.after(lastUpdate)) {
                isDiskLastUpdated = true;
            }
            if (isDiskLastUpdated) {
                lastIsUpdated = isUpdated;
                lastUpdate = date;
                diskToGetOVF = disk;
                size = new Long(diskDescriptionMap.get(OvfInfoFileConstants.Size).toString());
            }
        }
    }
    return new Pair<>((DiskImage) diskToGetOVF, size);
}
#method_after
private Pair<DiskImage, Long> getLatestOVFDisk(List<Disk> disks) {
    Date foundOvfDiskUpdateDate = new Date();
    boolean isFoundOvfDiskUpdated = false;
    Long size = 0L;
    Disk ovfDisk = null;
    for (Disk disk : disks) {
        boolean isBetterOvfDiskFound = false;
        // Check which disks are of OVF_STORE
        String diskDecription = ((DiskImage) disk).getDescription();
        if (diskDecription.contains(OvfInfoFileConstants.OvfStoreDescriptionLabel)) {
            Map<String, Object> diskDescriptionMap;
            try {
                diskDescriptionMap = JsonHelper.jsonToMap(diskDecription);
            } catch (IOException e) {
                log.warnFormat("Exception while generating json containing ovf store info. Exception: {0}", e);
                continue;
            }
            // The purpose of this check is to verify that it's an OVF store with data related to the Storage Domain.
            if (!isDomainExistsInDiskDescription(diskDescriptionMap, getParameters().getStorageDomainId())) {
                log.warnFormat("The disk description does not contain the storage domain id {0}", getParameters().getStorageDomainId());
                continue;
            }
            boolean isUpdated = Boolean.valueOf(diskDescriptionMap.get(OvfInfoFileConstants.IsUpdated).toString());
            Date date = getDateFromDiskDescription(diskDescriptionMap);
            if (isFoundOvfDiskUpdated && !isUpdated) {
                continue;
            }
            if ((isUpdated && !isFoundOvfDiskUpdated) || date.after(foundOvfDiskUpdateDate)) {
                isBetterOvfDiskFound = true;
            }
            if (isBetterOvfDiskFound) {
                isFoundOvfDiskUpdated = isUpdated;
                foundOvfDiskUpdateDate = date;
                ovfDisk = disk;
                size = new Long(diskDescriptionMap.get(OvfInfoFileConstants.Size).toString());
            }
        }
    }
    return new Pair<>((DiskImage) ovfDisk, size);
}
#end_block

#method_before
private Date getDateFromDiskDescription(Map<String, Object> map) {
    try {
        return new SimpleDateFormat(OvfParser.formatStrFromDiskDescription).parse(map.get(OvfInfoFileConstants.LastUpdated).toString());
    } catch (java.text.ParseException e) {
        log.errorFormat("LastUpdate Date could not be parsed from disk desscription");
        e.printStackTrace();
        return null;
    }
}
#method_after
private Date getDateFromDiskDescription(Map<String, Object> map) {
    try {
        return new SimpleDateFormat(OvfParser.formatStrFromDiskDescription).parse(map.get(OvfInfoFileConstants.LastUpdated).toString());
    } catch (java.text.ParseException e) {
        log.errorFormat("LastUpdate Date could not be parsed from disk desscription. Exception: {0}", e);
        return null;
    }
}
#end_block

#method_before
@Test
public void statusSetInMap() {
    AttachStorageDomainToPoolParameters params = new AttachStorageDomainToPoolParameters(Guid.newGuid(), Guid.newGuid());
    AttachStorageDomainToPoolCommand<AttachStorageDomainToPoolParameters> cmd = spy(new AttachStorageDomainToPoolCommand<AttachStorageDomainToPoolParameters>(params));
    doReturn(dbFacade).when(cmd).getDbFacade();
    doNothing().when(cmd).attemptToActivateDomain();
    when(dbFacade.getStoragePoolIsoMapDao()).thenReturn(isoMapDAO);
    when(dbFacade.getStoragePoolDao()).thenReturn(storagePoolDAO);
    when(dbFacade.getVdsDao()).thenReturn(vdsDAO);
    when(dbFacade.getStorageDomainDao()).thenReturn(storageDomainDAO);
    when(dbFacade.getStorageDomainStaticDao()).thenReturn(storageDomainStaticDAO);
    StoragePool pool = new StoragePool();
    pool.setStatus(StoragePoolStatus.Up);
    when(storagePoolDAO.get(any(Guid.class))).thenReturn(pool);
    when(isoMapDAO.get(any(StoragePoolIsoMapId.class))).thenReturn(map);
    when(storageDomainDAO.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(new StorageDomain());
    when(storageDomainStaticDAO.get(any(Guid.class))).thenReturn(new StorageDomainStatic());
    doReturn(backendInternal).when(cmd).getBackend();
    when(vdsDAO.getAllForStoragePoolAndStatus(any(Guid.class), any(VDSStatus.class))).thenReturn(new ArrayList<VDS>());
    when(backendInternal.getResourceManager()).thenReturn(vdsBrokerFrontend);
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    VdcReturnValueBase vdcReturnValue = new VdcReturnValueBase();
    vdcReturnValue.setSucceeded(true);
    when(backendInternal.runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class), any(CommandContext.class))).thenReturn(vdcReturnValue);
    when(vdsBrokerFrontend.RunVdsCommand(any(VDSCommandType.class), any(VDSParametersBase.class))).thenReturn(returnValue);
    when(vdsDAO.get(any(Guid.class))).thenReturn(vds);
    doReturn(getUnregisteredList()).when(cmd).getEntitiesFromStorageOvfDisk();
    doAnswer(new Answer<Object>() {

        @Override
        public Object answer(InvocationOnMock invocation) throws Throwable {
            map = (StoragePoolIsoMap) invocation.getArguments()[0];
            return null;
        }
    }).when(isoMapDAO).save(any(StoragePoolIsoMap.class));
    cmd.setCompensationContext(mock(CompensationContext.class));
    cmd.executeCommand();
    assertNotNull(map);
    assertEquals(StorageDomainStatus.Maintenance, map.getStatus());
}
#method_after
@Test
public void statusSetInMap() {
    AttachStorageDomainToPoolParameters params = new AttachStorageDomainToPoolParameters(Guid.newGuid(), Guid.newGuid());
    AttachStorageDomainToPoolCommand<AttachStorageDomainToPoolParameters> cmd = spy(new AttachStorageDomainToPoolCommand<AttachStorageDomainToPoolParameters>(params));
    doReturn(dbFacade).when(cmd).getDbFacade();
    doNothing().when(cmd).attemptToActivateDomain();
    when(dbFacade.getStoragePoolIsoMapDao()).thenReturn(isoMapDAO);
    when(dbFacade.getStoragePoolDao()).thenReturn(storagePoolDAO);
    when(dbFacade.getVdsDao()).thenReturn(vdsDAO);
    when(dbFacade.getStorageDomainDao()).thenReturn(storageDomainDAO);
    when(dbFacade.getStorageDomainStaticDao()).thenReturn(storageDomainStaticDAO);
    StoragePool pool = new StoragePool();
    pool.setStatus(StoragePoolStatus.Up);
    when(storagePoolDAO.get(any(Guid.class))).thenReturn(pool);
    when(isoMapDAO.get(any(StoragePoolIsoMapId.class))).thenReturn(map);
    when(storageDomainDAO.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(new StorageDomain());
    when(storageDomainStaticDAO.get(any(Guid.class))).thenReturn(new StorageDomainStatic());
    doReturn(backendInternal).when(cmd).getBackend();
    when(vdsDAO.getAllForStoragePoolAndStatus(any(Guid.class), any(VDSStatus.class))).thenReturn(new ArrayList<VDS>());
    when(backendInternal.getResourceManager()).thenReturn(vdsBrokerFrontend);
    VdcReturnValueBase vdcReturnValue = new VdcReturnValueBase();
    vdcReturnValue.setSucceeded(true);
    when(backendInternal.runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class), any(CommandContext.class))).thenReturn(vdcReturnValue);
    StorageDomainStatic storageDomain = new StorageDomainStatic();
    storageDomain.setId(Guid.newGuid());
    storageDomain.setStorageDomainType(StorageDomainType.ImportExport);
    mockGetStorageDomainInfoVdsCommand(storageDomain);
    mockAttachStorageDomainVdsCommand();
    when(vdsDAO.get(any(Guid.class))).thenReturn(vds);
    doReturn(getUnregisteredList()).when(cmd).getEntitiesFromStorageOvfDisk();
    doAnswer(new Answer<Object>() {

        @Override
        public Object answer(InvocationOnMock invocation) throws Throwable {
            map = (StoragePoolIsoMap) invocation.getArguments()[0];
            return null;
        }
    }).when(isoMapDAO).save(any(StoragePoolIsoMap.class));
    cmd.setCompensationContext(mock(CompensationContext.class));
    cmd.executeCommand();
    assertNotNull(map);
    assertEquals(StorageDomainStatus.Maintenance, map.getStatus());
}
#end_block

#method_before
public static Map<String, Object> jsonToMap(String jsonString) throws JsonParseException, JsonMappingException, IOException {
    final ObjectMapper mapper = new ObjectMapper();
    final MapType type = mapper.getTypeFactory().constructMapType(Map.class, String.class, Object.class);
    final Map<String, Object> data = mapper.readValue(jsonString, type);
    return data;
}
#method_after
public static Map<String, Object> jsonToMap(String jsonString) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    MapType type = mapper.getTypeFactory().constructMapType(Map.class, String.class, Object.class);
    Map<String, Object> data = mapper.readValue(jsonString, type);
    return data;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + (autoRecoverable ? 0 : 1);
    result = prime * result + (containsUnregisteredEntities ? 0 : 1);
    result = prime * result + ((connection == null) ? 0 : connection.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((storage == null) ? 0 : storage.hashCode());
    result = prime * result + ((storageFormat == null) ? 0 : storageFormat.hashCode());
    result = prime * result + ((storagePoolType == null) ? 0 : storagePoolType.hashCode());
    result = prime * result + ((storageType == null) ? 0 : storageType.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + (autoRecoverable ? 0 : 1);
    result = prime * result + (containsUnregisteredEntities ? 0 : 1);
    result = prime * result + ((connection == null) ? 0 : connection.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((storage == null) ? 0 : storage.hashCode());
    result = prime * result + ((storageFormat == null) ? 0 : storageFormat.hashCode());
    result = prime * result + ((storagePoolType == null) ? 0 : storagePoolType.hashCode());
    result = prime * result + ((storageType == null) ? 0 : storageType.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((sanState == null) ? 0 : sanState.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    StorageDomainStatic other = (StorageDomainStatic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && autoRecoverable == other.autoRecoverable && containsUnregisteredEntities == other.containsUnregisteredEntities && ObjectUtils.objectsEqual(connection, other.connection) && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(storage, other.storage) && storageFormat == other.storageFormat && storagePoolType == other.storagePoolType && storageType == other.storageType && ObjectUtils.objectsEqual(description, other.description));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    StorageDomainStatic other = (StorageDomainStatic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && autoRecoverable == other.autoRecoverable && containsUnregisteredEntities == other.containsUnregisteredEntities && ObjectUtils.objectsEqual(connection, other.connection) && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(storage, other.storage) && storageFormat == other.storageFormat && storagePoolType == other.storagePoolType && storageType == other.storageType && sanState == other.sanState && ObjectUtils.objectsEqual(description, other.description));
}
#end_block

#method_before
protected boolean ValidateNotificationMethod(EventNotificationMethod eventNotificationMethod, event_subscriber event_subscriber, DbUser user) {
    boolean retValue = true;
    EventNotificationMethod notificationMethod = eventNotificationMethod;
    switch(notificationMethod) {
        case SMTP:
            String mailAdress = (StringUtils.isEmpty(event_subscriber.getmethod_address())) ? user.getEmail() : event_subscriber.getmethod_address();
            if (StringUtils.isEmpty(mailAdress) || !ValidatMailAddress(mailAdress)) {
                addCanDoActionMessage(VdcBllMessages.USER_DOES_NOT_HAVE_A_VALID_EMAIL);
                retValue = false;
            }
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.EN_UNKNOWN_NOTIFICATION_METHOD);
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
protected boolean ValidateNotificationMethod(EventNotificationMethod eventNotificationMethod, event_subscriber event_subscriber, DbUser user) {
    boolean retValue = true;
    EventNotificationMethod notificationMethod = eventNotificationMethod;
    switch(notificationMethod) {
        case SMTP:
            String mailAddress = (StringUtils.isEmpty(event_subscriber.getmethod_address())) ? user.getEmail() : event_subscriber.getmethod_address();
            if (!isEmailValid(mailAddress)) {
                addCanDoActionMessage(VdcBllMessages.USER_DOES_NOT_HAVE_A_VALID_EMAIL);
                retValue = false;
            }
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.EN_UNKNOWN_NOTIFICATION_METHOD);
            retValue = false;
            break;
    }
    return retValue;
}
#end_block

#method_before
@Parameters
public static List<Object[]> data() {
    List<Object[]> params = new ArrayList<>();
    for (int i = 2; i < 10; ++i) {
        params.add(new Object[] { i, String.valueOf(RandomUtils.instance().nextInt()) });
    }
    return params;
}
#method_after
@Parameters
public static List<Object[]> data() {
    List<Object[]> params = new ArrayList<>();
    // <tag><innerTag>value</innerTag><tag>
    for (int i = 2; i < 10; ++i) {
        params.add(new Object[] { i, String.valueOf(RandomUtils.instance().nextInt()) });
    }
    return params;
}
#end_block

#method_before
protected void addInvalidSDStatusMessage(StorageDomainStatus status) {
    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2);
    addCanDoActionMessage(String.format("$status %1$s", status));
}
#method_after
protected void addInvalidSDStatusMessage(StorageDomainStatus status) {
    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2);
    addCanDoActionMessageVariable("status", status);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = canRemoveVds(getVdsId(), getReturnValue().getCanDoActionMessages());
    StoragePool storagePool = getStoragePoolDAO().getForVds(getParameters().getVdsId());
    if (returnValue && storagePool != null && storagePool.isLocal()) {
        if (!getStorageDomainDAO().getAllForStoragePool(storagePool.getId()).isEmpty()) {
            returnValue = failCanDoAction(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_WITH_LOCAL_STORAGE);
        }
    }
    // Perform volume bricks on server and up server null check
    if (returnValue && isGlusterEnabled()) {
        upServer = getClusterUtils().getUpServer(getVdsGroupId());
        if (!getParameters().isForceAction()) {
            // fail if host has bricks on a volume
            if (hasVolumeBricksOnServer()) {
                returnValue = failCanDoAction(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            } else if (upServer == null && clusterHasMultipleHosts()) {
                // fail if there is no up server in cluster, and if host being removed is not
                // the last server in cluster
                addCanDoActionMessage(String.format("$clusterName %1$s", getVdsGroup().getName()));
                returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_UP_SERVER_FOUND);
            }
        } else {
            // if force, cannot remove only if there are bricks on server and there is an up server.
            if (hasVolumeBricksOnServer() && upServer != null) {
                returnValue = failCanDoAction(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            }
        }
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = canRemoveVds(getVdsId(), getReturnValue().getCanDoActionMessages());
    StoragePool storagePool = getStoragePoolDAO().getForVds(getParameters().getVdsId());
    if (returnValue && storagePool != null && storagePool.isLocal()) {
        if (!getStorageDomainDAO().getAllForStoragePool(storagePool.getId()).isEmpty()) {
            returnValue = failCanDoAction(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_WITH_LOCAL_STORAGE);
        }
    }
    // Perform volume bricks on server and up server null check
    if (returnValue && isGlusterEnabled()) {
        upServer = getClusterUtils().getUpServer(getVdsGroupId());
        if (!getParameters().isForceAction()) {
            // fail if host has bricks on a volume
            if (hasVolumeBricksOnServer()) {
                returnValue = failCanDoAction(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            } else if (upServer == null && clusterHasMultipleHosts()) {
                // fail if there is no up server in cluster, and if host being removed is not
                // the last server in cluster
                addCanDoActionMessageVariable("clusterName", getVdsGroup().getName());
                returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_UP_SERVER_FOUND);
            }
        } else {
            // if force, cannot remove only if there are bricks on server and there is an up server.
            if (hasVolumeBricksOnServer() && upServer != null) {
                returnValue = failCanDoAction(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVds() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_APPROVE_VDS_NOT_FOUND);
        returnValue = false;
    } else if (getVds().getStatus() != VDSStatus.PendingApproval && getVds().getStatus() != VDSStatus.InstallFailed && getVds().getStatus() != VDSStatus.InstallingOS) {
        addCanDoActionMessage(VdcBllMessages.VDS_APPROVE_VDS_IN_WRONG_STATUS.toString());
        returnValue = false;
    }
    return returnValue ? super.canDoAction() : false;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVds() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_APPROVE_VDS_NOT_FOUND);
        returnValue = false;
    } else if (getVds().getStatus() != VDSStatus.PendingApproval && getVds().getStatus() != VDSStatus.InstallFailed && getVds().getStatus() != VDSStatus.InstallingOS) {
        addCanDoActionMessage(VdcBllMessages.VDS_APPROVE_VDS_IN_WRONG_STATUS);
        returnValue = false;
    }
    return returnValue ? super.canDoAction() : false;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = false;
    String event;
    if (getVds() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
        return false;
    }
    // versa.
    if (getParameters().getAction() == FenceActionType.Start) {
        event = AuditLogType.USER_VDS_STOP.name();
    } else {
        event = AuditLogType.USER_VDS_START.name();
    }
    if (getVds().getpm_enabled() && IsPowerManagementLegal(getVds().getStaticData(), getVdsGroup().getcompatibility_version().toString())) {
        // check if we are in the interval of X seconds from startup
        // if yes , system is still initializing , ignore fence operations
        Date waitTo = Backend.getInstance().getStartedAt().addSeconds((Integer) Config.getValue(ConfigValues.DisableFenceAtStartupInSec));
        Date now = new Date();
        if (waitTo.before(now) || waitTo.equals(now)) {
            // Check Quiet time between PM operations, this is done only if command is not internal and parent command is not <Restart>
            int secondsLeftToNextPmOp = (isInternalExecution() || (getParameters().getParentCommand() == VdcActionType.RestartVds)) ? 0 : DbFacade.getInstance().getAuditLogDao().getTimeToWaitForNextPmOp(getVds().getName(), event);
            if (secondsLeftToNextPmOp <= 0) {
                // Check for proxy
                executor = createExecutorForProxyCheck();
                if (executor.findProxyHost()) {
                    retValue = true;
                } else {
                    addCanDoActionMessage(VdcBllMessages.VDS_NO_VDS_PROXY_FOUND);
                }
            } else {
                addCanDoActionMessage(VdcBllMessages.VDS_FENCE_DISABLED_AT_QUIET_TIME);
                addCanDoActionMessage(String.format("$seconds %1$s", secondsLeftToNextPmOp));
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.VDS_FENCE_DISABLED_AT_SYSTEM_STARTUP_INTERVAL);
        }
        // retry operation only when fence is enabled on Host.
        if (!retValue) {
            handleError();
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.VDS_FENCE_DISABLED);
        handleError();
    }
    getReturnValue().setSucceeded(retValue);
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = false;
    String event;
    if (getVds() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
        return false;
    }
    // versa.
    if (getParameters().getAction() == FenceActionType.Start) {
        event = AuditLogType.USER_VDS_STOP.name();
    } else {
        event = AuditLogType.USER_VDS_START.name();
    }
    if (getVds().getpm_enabled() && IsPowerManagementLegal(getVds().getStaticData(), getVdsGroup().getcompatibility_version().toString())) {
        // check if we are in the interval of X seconds from startup
        // if yes , system is still initializing , ignore fence operations
        Date waitTo = Backend.getInstance().getStartedAt().addSeconds((Integer) Config.getValue(ConfigValues.DisableFenceAtStartupInSec));
        Date now = new Date();
        if (waitTo.before(now) || waitTo.equals(now)) {
            // Check Quiet time between PM operations, this is done only if command is not internal and parent command is not <Restart>
            int secondsLeftToNextPmOp = (isInternalExecution() || (getParameters().getParentCommand() == VdcActionType.RestartVds)) ? 0 : DbFacade.getInstance().getAuditLogDao().getTimeToWaitForNextPmOp(getVds().getName(), event);
            if (secondsLeftToNextPmOp <= 0) {
                // Check for proxy
                executor = createExecutorForProxyCheck();
                if (executor.findProxyHost()) {
                    retValue = true;
                } else {
                    addCanDoActionMessage(VdcBllMessages.VDS_NO_VDS_PROXY_FOUND);
                }
            } else {
                addCanDoActionMessage(VdcBllMessages.VDS_FENCE_DISABLED_AT_QUIET_TIME);
                addCanDoActionMessageVariable("seconds", secondsLeftToNextPmOp);
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.VDS_FENCE_DISABLED_AT_SYSTEM_STARTUP_INTERVAL);
        }
        // retry operation only when fence is enabled on Host.
        if (!retValue) {
            handleError();
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.VDS_FENCE_DISABLED);
        handleError();
    }
    getReturnValue().setSucceeded(retValue);
    return retValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    StorageServerConnections newConnectionDetails = getConnection();
    StorageType storageType = newConnectionDetails.getstorage_type();
    if ((!storageType.isFileDomain() && !storageType.equals(StorageType.ISCSI)) || storageType.equals(StorageType.GLUSTERFS)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_STORAGE_TYPE);
    }
    // Check if the NFS path has a valid format
    if (newConnectionDetails.getstorage_type() == StorageType.NFS && !new NfsMountPointConstraint().isValid(newConnectionDetails.getconnection(), null)) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_INVALID);
    }
    if (newConnectionDetails.getstorage_type() == StorageType.POSIXFS && (StringUtils.isEmpty(newConnectionDetails.getVfsType()))) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_EMPTY_VFSTYPE);
    }
    if (newConnectionDetails.getstorage_type() == StorageType.ISCSI && StringUtils.isEmpty(newConnectionDetails.getiqn())) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_EMPTY_IQN);
    }
    if (newConnectionDetails.getstorage_type() == StorageType.ISCSI && !isValidStorageConnectionPort(newConnectionDetails.getport())) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_INVALID_PORT);
    }
    if (checkIsConnectionFieldEmpty(newConnectionDetails)) {
        return false;
    }
    // Check if connection exists by id, otherwise there's nothing to update
    String connectionId = newConnectionDetails.getid();
    StorageServerConnections oldConnection = getStorageConnDao().get(connectionId);
    if (oldConnection == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_NOT_EXIST);
    }
    if (!newConnectionDetails.getstorage_type().equals(oldConnection.getstorage_type())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_CHANGE_STORAGE_TYPE);
    }
    Guid storagePoolId = getStoragePoolIdByFileConnectionId(oldConnection.getid());
    if (isConnWithSameDetailsExists(newConnectionDetails, storagePoolId)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ALREADY_EXISTS);
    }
    if (doDomainsUseConnection(newConnectionDetails) || doLunsUseConnection()) {
        if (storageType.isFileDomain() && domains.size() > 1) {
            String domainNames = createDomainNamesList(domains);
            addCanDoActionMessage(String.format("$domainNames %1$s", domainNames));
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_BELONGS_TO_SEVERAL_STORAGE_DOMAINS);
        }
        // Check that the storage domain is in proper state to be edited
        if (!isConnectionEditable(newConnectionDetails)) {
            return false;
        }
    }
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    StorageServerConnections newConnectionDetails = getConnection();
    StorageType storageType = newConnectionDetails.getstorage_type();
    if ((!storageType.isFileDomain() && !storageType.equals(StorageType.ISCSI)) || storageType.equals(StorageType.GLUSTERFS)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_STORAGE_TYPE);
    }
    // Check if the NFS path has a valid format
    if (newConnectionDetails.getstorage_type() == StorageType.NFS && !new NfsMountPointConstraint().isValid(newConnectionDetails.getconnection(), null)) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_INVALID);
    }
    if (newConnectionDetails.getstorage_type() == StorageType.POSIXFS && (StringUtils.isEmpty(newConnectionDetails.getVfsType()))) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_EMPTY_VFSTYPE);
    }
    if (newConnectionDetails.getstorage_type() == StorageType.ISCSI && StringUtils.isEmpty(newConnectionDetails.getiqn())) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_EMPTY_IQN);
    }
    if (newConnectionDetails.getstorage_type() == StorageType.ISCSI && !isValidStorageConnectionPort(newConnectionDetails.getport())) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_INVALID_PORT);
    }
    if (checkIsConnectionFieldEmpty(newConnectionDetails)) {
        return false;
    }
    // Check if connection exists by id, otherwise there's nothing to update
    String connectionId = newConnectionDetails.getid();
    StorageServerConnections oldConnection = getStorageConnDao().get(connectionId);
    if (oldConnection == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_NOT_EXIST);
    }
    if (!newConnectionDetails.getstorage_type().equals(oldConnection.getstorage_type())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_CHANGE_STORAGE_TYPE);
    }
    Guid storagePoolId = getStoragePoolIdByFileConnectionId(oldConnection.getid());
    if (isConnWithSameDetailsExists(newConnectionDetails, storagePoolId)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ALREADY_EXISTS);
    }
    if (doDomainsUseConnection(newConnectionDetails) || doLunsUseConnection()) {
        if (storageType.isFileDomain() && domains.size() > 1) {
            String domainNames = createDomainNamesList(domains);
            addCanDoActionMessageVariable("domainNames", domainNames);
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_BELONGS_TO_SEVERAL_STORAGE_DOMAINS);
        }
        // Check that the storage domain is in proper state to be edited
        if (!isConnectionEditable(newConnectionDetails)) {
            return false;
        }
    }
    return super.canDoAction();
}
#end_block

#method_before
protected boolean isConnectionEditable(StorageServerConnections connection) {
    if (connection.getstorage_type().isFileDomain()) {
        boolean isConnectionEditable = isDomainInEditState(domains.get(0));
        if (!isConnectionEditable) {
            addCanDoActionMessage(String.format("$domainNames %1$s", domains.get(0).getStorageName()));
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_DOMAINS_STATUS);
        }
        return isConnectionEditable;
    }
    if (!getLuns().isEmpty()) {
        List<String> problematicVMNames = new ArrayList<>();
        List<String> problematicDomainNames = new ArrayList<>();
        for (LUNs lun : getLuns()) {
            Guid diskId = lun.getDiskId();
            if (diskId != null) {
                Map<Boolean, List<VM>> vmsMap = getVmDAO().getForDisk(diskId, true);
                List<VM> pluggedVms = vmsMap.get(Boolean.TRUE);
                if (pluggedVms != null && !pluggedVms.isEmpty()) {
                    for (VM vm : pluggedVms) {
                        if (!vm.getStatus().equals(VMStatus.Down)) {
                            problematicVMNames.add(vm.getName());
                        }
                    }
                }
            }
            Guid storageDomainId = lun.getStorageDomainId();
            if (storageDomainId != null) {
                StorageDomain domain = getStorageDomainDao().get(storageDomainId);
                if (!domain.getStorageDomainSharedStatus().equals(StorageDomainSharedStatus.Unattached)) {
                    for (StoragePoolIsoMap map : getStoragePoolIsoMap(domain)) {
                        if (!map.getStatus().equals(StorageDomainStatus.Maintenance)) {
                            String domainName = domain.getStorageName();
                            problematicDomainNames.add(domainName);
                        } else {
                            domains.add(domain);
                        }
                    }
                } else {
                    // unattached domain, edit allowed
                    domains.add(domain);
                }
            }
        }
        if (!problematicVMNames.isEmpty()) {
            if (problematicDomainNames.isEmpty()) {
                addCanDoActionMessage(String.format("$vmNames %1$s", prepareEntityNamesForMessage(problematicVMNames)));
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS);
            } else {
                addCanDoActionMessage(String.format("$vmNames %1$s", prepareEntityNamesForMessage(problematicVMNames)));
                addCanDoActionMessage(String.format("$domainNames %1$s", prepareEntityNamesForMessage(problematicDomainNames)));
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS_AND_DOMAINS_STATUS);
            }
            return false;
        }
        if (!problematicDomainNames.isEmpty()) {
            addCanDoActionMessage(String.format("$domainNames %1$s", prepareEntityNamesForMessage(problematicDomainNames)));
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_DOMAINS_STATUS);
            return false;
        }
    }
    return true;
}
#method_after
protected boolean isConnectionEditable(StorageServerConnections connection) {
    if (connection.getstorage_type().isFileDomain()) {
        boolean isConnectionEditable = isDomainInEditState(domains.get(0));
        if (!isConnectionEditable) {
            addCanDoActionMessageVariable("domainNames", domains.get(0).getStorageName());
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_DOMAINS_STATUS);
        }
        return isConnectionEditable;
    }
    if (!getLuns().isEmpty()) {
        List<String> problematicVMNames = new ArrayList<>();
        List<String> problematicDomainNames = new ArrayList<>();
        for (LUNs lun : getLuns()) {
            Guid diskId = lun.getDiskId();
            if (diskId != null) {
                Map<Boolean, List<VM>> vmsMap = getVmDAO().getForDisk(diskId, true);
                List<VM> pluggedVms = vmsMap.get(Boolean.TRUE);
                if (pluggedVms != null && !pluggedVms.isEmpty()) {
                    for (VM vm : pluggedVms) {
                        if (!vm.getStatus().equals(VMStatus.Down)) {
                            problematicVMNames.add(vm.getName());
                        }
                    }
                }
            }
            Guid storageDomainId = lun.getStorageDomainId();
            if (storageDomainId != null) {
                StorageDomain domain = getStorageDomainDao().get(storageDomainId);
                if (!domain.getStorageDomainSharedStatus().equals(StorageDomainSharedStatus.Unattached)) {
                    for (StoragePoolIsoMap map : getStoragePoolIsoMap(domain)) {
                        if (!map.getStatus().equals(StorageDomainStatus.Maintenance)) {
                            String domainName = domain.getStorageName();
                            problematicDomainNames.add(domainName);
                        } else {
                            domains.add(domain);
                        }
                    }
                } else {
                    // unattached domain, edit allowed
                    domains.add(domain);
                }
            }
        }
        if (!problematicVMNames.isEmpty()) {
            if (problematicDomainNames.isEmpty()) {
                addCanDoActionMessageVariable("vmNames", prepareEntityNamesForMessage(problematicVMNames));
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS);
            } else {
                addCanDoActionMessageVariable("vmNames", prepareEntityNamesForMessage(problematicVMNames));
                addCanDoActionMessageVariable("domainNames", prepareEntityNamesForMessage(problematicDomainNames));
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS_AND_DOMAINS_STATUS);
            }
            return false;
        }
        if (!problematicDomainNames.isEmpty()) {
            addCanDoActionMessageVariable("domainNames", prepareEntityNamesForMessage(problematicDomainNames));
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_DOMAINS_STATUS);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<VdsNetworkInterface> interfaces = getDbFacade().getInterfaceDao().getAllInterfacesForVds(getParameters().getVdsId());
    iface = LinqUtils.firstOrNull(interfaces, new Predicate<VdsNetworkInterface>() {

        @Override
        public boolean eval(VdsNetworkInterface i) {
            return i.getName().equals(getParameters().getInterface().getName());
        }
    });
    if (iface == null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_NOT_EXISTS);
        return false;
    }
    if (StringUtils.isEmpty(getParameters().getInterface().getNetworkName())) {
        getParameters().getInterface().setNetworkName(iface.getNetworkName());
    }
    // set the network object if we don't got in the parameters
    if (getParameters().getNetwork() == null || getParameters().getNetwork().getCluster() == null) {
        List<Network> networks = getDbFacade().getNetworkDao().getAllForCluster(getVdsGroupId());
        for (Network n : networks) {
            if (n.getName().equals(iface.getNetworkName())) {
                getParameters().setNetwork(n);
                break;
            }
        }
    }
    if (StringUtils.isEmpty(iface.getNetworkName())) {
        if (iface.getBonded() != null && iface.getBonded() == true) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_BOND_NOT_ATTACH_TO_NETWORK);
        } else {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_NOT_ATTACH_TO_NETWORK);
        }
        return false;
    } else if (!StringUtils.equals(getParameters().getInterface().getNetworkName(), getParameters().getNetwork().getName())) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_NOT_ATTACH_TO_NETWORK);
        return false;
    }
    VDS vds = getVdsDAO().get(getParameters().getVdsId());
    // check if network in cluster and vds active
    if ((vds.getStatus() == VDSStatus.Up || vds.getStatus() == VDSStatus.Installing) && getParameters().getNetwork().getCluster() != null && getParameters().getNetwork().getCluster().getStatus() == NetworkStatus.OPERATIONAL) {
        List<Network> networks = getDbFacade().getNetworkDao().getAllForCluster(vds.getVdsGroupId());
        if (null != LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network network) {
                return network.getName().equals(getParameters().getNetwork().getName());
            }
        })) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_HOST_IS_BUSY);
            return false;
        }
    }
    List<String> vmNames = new VmInterfaceManager().findActiveVmsUsingNetworks(vds.getId(), Collections.singletonList(getParameters().getNetwork().getName()));
    if (!vmNames.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS);
        addCanDoActionMessage(String.format("$%s_LIST %s", VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS.name(), StringUtils.join(vmNames, ",")));
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    List<VdsNetworkInterface> interfaces = getDbFacade().getInterfaceDao().getAllInterfacesForVds(getParameters().getVdsId());
    iface = LinqUtils.firstOrNull(interfaces, new Predicate<VdsNetworkInterface>() {

        @Override
        public boolean eval(VdsNetworkInterface i) {
            return i.getName().equals(getParameters().getInterface().getName());
        }
    });
    if (iface == null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_NOT_EXISTS);
        return false;
    }
    if (StringUtils.isEmpty(getParameters().getInterface().getNetworkName())) {
        getParameters().getInterface().setNetworkName(iface.getNetworkName());
    }
    // set the network object if we don't got in the parameters
    if (getParameters().getNetwork() == null || getParameters().getNetwork().getCluster() == null) {
        List<Network> networks = getDbFacade().getNetworkDao().getAllForCluster(getVdsGroupId());
        for (Network n : networks) {
            if (n.getName().equals(iface.getNetworkName())) {
                getParameters().setNetwork(n);
                break;
            }
        }
    }
    if (StringUtils.isEmpty(iface.getNetworkName())) {
        if (iface.getBonded() != null && iface.getBonded() == true) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_BOND_NOT_ATTACH_TO_NETWORK);
        } else {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_NOT_ATTACH_TO_NETWORK);
        }
        return false;
    } else if (!StringUtils.equals(getParameters().getInterface().getNetworkName(), getParameters().getNetwork().getName())) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_NOT_ATTACH_TO_NETWORK);
        return false;
    }
    VDS vds = getVdsDAO().get(getParameters().getVdsId());
    // check if network in cluster and vds active
    if ((vds.getStatus() == VDSStatus.Up || vds.getStatus() == VDSStatus.Installing) && getParameters().getNetwork().getCluster() != null && getParameters().getNetwork().getCluster().getStatus() == NetworkStatus.OPERATIONAL) {
        List<Network> networks = getDbFacade().getNetworkDao().getAllForCluster(vds.getVdsGroupId());
        if (null != LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network network) {
                return network.getName().equals(getParameters().getNetwork().getName());
            }
        })) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_HOST_IS_BUSY);
            return false;
        }
    }
    List<String> vmNames = new VmInterfaceManager().findActiveVmsUsingNetworks(vds.getId(), Collections.singletonList(getParameters().getNetwork().getName()));
    if (!vmNames.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS);
        addCanDoActionMessageVariable(String.format("$%s_LIST", VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS.name()), StringUtils.join(vmNames, ","));
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!FeatureSupported.isSuspendSupportedByArchitecture(getVm().getClusterArch(), getVm().getVdsGroupCompatibilityVersion())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SUSPEND_NOT_SUPPORTED);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VMStatus vmStatus = getVm().getStatus();
    if (vmStatus == VMStatus.WaitForLaunch || vmStatus == VMStatus.NotResponding) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vmStatus));
    }
    if (vmStatus != VMStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_UP);
    }
    if (TaskManagerUtil.entityHasTasks(getVmId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_SUSPENDE_HAS_RUNNING_TASKS);
    }
    // (then isStateless is false)
    if (getVm().isStateless() || DbFacade.getInstance().getSnapshotDao().exists(getVmId(), SnapshotType.STATELESS)) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_SUSPEND_STATELESS_VM);
    }
    if (DbFacade.getInstance().getVmPoolDao().getVmPoolMapByVmGuid(getVmId()) != null) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_SUSPEND_VM_FROM_POOL);
    }
    if (getStorageDomainId().equals(Guid.Empty)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!FeatureSupported.isSuspendSupportedByArchitecture(getVm().getClusterArch(), getVm().getVdsGroupCompatibilityVersion())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SUSPEND_NOT_SUPPORTED);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VMStatus vmStatus = getVm().getStatus();
    if (vmStatus == VMStatus.WaitForLaunch || vmStatus == VMStatus.NotResponding) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vmStatus));
    }
    if (vmStatus != VMStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_UP);
    }
    if (TaskManagerUtil.entityHasTasks(getVmId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_SUSPENDE_HAS_RUNNING_TASKS);
    }
    if (getVm().getVmPoolId() != null) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_SUSPEND_VM_FROM_POOL);
    }
    // (then isStateless is false)
    if (getVm().isStateless() || DbFacade.getInstance().getSnapshotDao().exists(getVmId(), SnapshotType.STATELESS)) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_SUSPEND_STATELESS_VM);
    }
    if (getStorageDomainId().equals(Guid.Empty)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    return true;
}
#end_block

#method_before
private void endSuccessfullyImpl() {
    if (getVm() != null) {
        if (getVm().getStatus() != VMStatus.PreparingForHibernate) {
            // If the Vm is not PreparingForHibernate, we shouldn't perform Hibernate on it,
            // since if the Vm is in another status, something might have happened to it
            // that might prevent it from being hibernated.
            // NOTE: We don't remove the 2 volumes because we don't want to
            // start here another tasks.
            log.warnFormat("HibernateVmCommand::EndSuccessfully: Vm '{0}' is not in 'PreparingForHibernate' status, but in '{1}' status - not performing Hibernate.", getVm().getName(), getVm().getStatus());
            getReturnValue().setEndActionTryAgain(false);
        } else if (getVm().getRunOnVds() == null) {
            log.warnFormat("HibernateVmCommand::EndSuccessfully: Vm '{0}' doesn't have 'run_on_vds' value - cannot Hibernate.", getVm().getName());
            getReturnValue().setEndActionTryAgain(false);
        } else {
            String hiberVol = getVm().getHibernationVolHandle();
            if (hiberVol != null) {
                try {
                    runVdsCommand(VDSCommandType.Hibernate, new HibernateVDSCommandParameters(new Guid(getVm().getRunOnVds().toString()), getVmId(), getVm().getHibernationVolHandle()));
                } catch (VdcBLLException e) {
                    isHibernateVdsProblematic = true;
                    throw e;
                }
                setSucceeded(true);
            } else {
                log.errorFormat("hibernation volume of VM '{0}', is not initialized.", getVm().getName());
                endWithFailure();
            }
        }
    } else {
        log.warn("HibernateVmCommand::EndSuccessfully: Vm is null - not performing full endAction.");
        setSucceeded(true);
    }
}
#method_after
private void endSuccessfullyImpl() {
    if (getVm() != null) {
        if (getVm().getStatus() != VMStatus.PreparingForHibernate) {
            // If the Vm is not PreparingForHibernate, we shouldn't perform Hibernate on it,
            // since if the Vm is in another status, something might have happened to it
            // that might prevent it from being hibernated.
            // NOTE: We don't remove the 2 volumes because we don't want to
            // start here another tasks.
            log.warnFormat("VM '{0}' is not in 'PreparingForHibernate' status, but in '{1}' status - not performing Hibernate.", getVm().getName(), getVm().getStatus());
            getReturnValue().setEndActionTryAgain(false);
        } else if (getVm().getRunOnVds() == null) {
            log.warnFormat("VM '{0}' doesn't have 'run_on_vds' value - cannot Hibernate.", getVm().getName());
            getReturnValue().setEndActionTryAgain(false);
        } else {
            String hiberVol = getVm().getHibernationVolHandle();
            if (hiberVol != null) {
                try {
                    runVdsCommand(VDSCommandType.Hibernate, new HibernateVDSCommandParameters(new Guid(getVm().getRunOnVds().toString()), getVmId(), getVm().getHibernationVolHandle()));
                } catch (VdcBLLException e) {
                    isHibernateVdsProblematic = true;
                    throw e;
                }
                setSucceeded(true);
            } else {
                log.errorFormat("hibernation volume of VM '{0}', is not initialized.", getVm().getName());
                endWithFailure();
            }
        }
    } else {
        log.warn("VM is null - not performing full endAction.");
        setSucceeded(true);
    }
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    if (getVm() != null) {
        revertTasks();
        if (getVm().getRunOnVds() != null) {
            getVm().setHibernationVolHandle(null);
            getVm().setStatus(VMStatus.Up);
            runVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(new Guid(getVm().getRunOnVds().toString()), getVm().getDynamicData()));
            setSucceeded(true);
        } else {
            log.warnFormat("HibernateVmCommand::endWithFailure: Vm '{0}' doesn't have 'run_on_vds' value - not clearing 'hibernation_vol_handle' info.", getVm().getName());
            getReturnValue().setEndActionTryAgain(false);
        }
    } else {
        setCommandShouldBeLogged(false);
        log.warn("HibernateVmCommand::endWithFailure: Vm is null - not performing full endAction.");
        setSucceeded(true);
    }
}
#method_after
@Override
protected void endWithFailure() {
    if (getVm() != null) {
        revertTasks();
        if (getVm().getRunOnVds() != null) {
            getVm().setHibernationVolHandle(null);
            getVm().setStatus(VMStatus.Up);
            runVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(new Guid(getVm().getRunOnVds().toString()), getVm().getDynamicData()));
            setSucceeded(true);
        } else {
            log.warnFormat("VM '{0}' doesn't have 'run_on_vds' value - not clearing 'hibernation_vol_handle' info.", getVm().getName());
            getReturnValue().setEndActionTryAgain(false);
        }
    } else {
        setCommandShouldBeLogged(false);
        log.warn("VM is null - not performing full endAction.");
        setSucceeded(true);
    }
}
#end_block

#method_before
private void executeFenceVdsManuallyAction() {
    FenceVdsManualyParameters fenceVdsManuallyParams = new FenceVdsManualyParameters(false);
    fenceVdsManuallyParams.setStoragePoolId(getVds().getStoragePoolId());
    fenceVdsManuallyParams.setVdsId(getVdsId());
    fenceVdsManuallyParams.setSessionId(getParameters().getSessionId());
    fenceVdsManuallyParams.setParentCommand(VdcActionType.RestartVds);
    // if fencing succeeded, call to reset irs in order to try select new spm
    runInternalAction(VdcActionType.FenceVdsManualy, fenceVdsManuallyParams, dupContext().resetCompensationContext().setLock(new EngineLock(getExclusiveLocks(), null)));
}
#method_after
private void executeFenceVdsManuallyAction() {
    FenceVdsManualyParameters fenceVdsManuallyParams = new FenceVdsManualyParameters(false);
    fenceVdsManuallyParams.setStoragePoolId(getVds().getStoragePoolId());
    fenceVdsManuallyParams.setVdsId(getVdsId());
    fenceVdsManuallyParams.setSessionId(getParameters().getSessionId());
    fenceVdsManuallyParams.setParentCommand(VdcActionType.RestartVds);
    // if fencing succeeded, call to reset irs in order to try select new spm
    runInternalAction(VdcActionType.FenceVdsManualy, fenceVdsManuallyParams, dupContext().withoutCompensationContext().withLock(new EngineLock(getExclusiveLocks(), null)));
}
#end_block

#method_before
private boolean isTemplateExistsOnExportDomain() {
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getParameters().getVm().getVmtGuid())) {
        return true;
    }
    VdcQueryReturnValue qRetVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()), createQueryContext());
    if (qRetVal.getSucceeded()) {
        Map<VmTemplate, ?> templates = qRetVal.getReturnValue();
        for (VmTemplate template : templates.keySet()) {
            if (getParameters().getVm().getVmtGuid().equals(template.getId())) {
                return true;
            }
        }
    }
    return false;
}
#method_after
private boolean isTemplateExistsOnExportDomain() {
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getParameters().getVm().getVmtGuid())) {
        return true;
    }
    VdcQueryReturnValue qRetVal = runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    if (qRetVal.getSucceeded()) {
        Map<VmTemplate, ?> templates = qRetVal.getReturnValue();
        for (VmTemplate template : templates.keySet()) {
            if (getParameters().getVm().getVmtGuid().equals(template.getId())) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
@Override
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(getImagesActionType(), p, getContext().duplicate().resetCompensationContext().resetExecutionContext().resetLock());
    }
}
#method_after
@Override
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(getImagesActionType(), p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    setDescription(getVmName());
    setStoragePoolId(getVm().getStoragePoolId());
    // check that target domain exists
    StorageDomainValidator targetstorageDomainValidator = new StorageDomainValidator(getStorageDomain());
    if (!validate(targetstorageDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    // load the disks of vm from database
    VmHandler.updateDisksFromDb(getVm());
    List<DiskImage> disksForExport = getDisksBasedOnImage();
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(disksForExport);
    if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
        return false;
    }
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    // check that the target and source domain are in the same storage_pool
    if (getDbFacade().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getStoragePoolId())) == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        return false;
    }
    // check if template exists only if asked for
    if (getParameters().getTemplateMustExists()) {
        if (!checkTemplateInStorageDomain(getVm().getStoragePoolId(), getParameters().getStorageDomainId(), getVm().getVmtGuid())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_EXPORT_DOMAIN, String.format("$TemplateName %1$s", getVm().getVmtName()));
        }
    }
    // check that the images requested format are valid (COW+Sparse)
    if (!ImagesHandler.checkImagesConfiguration(getParameters().getStorageDomainId(), disksForExport, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Map<Guid, ? extends Disk> images = getVm().getDiskMap();
    if (getParameters().getCopyCollapse()) {
        for (DiskImage img : disksForExport) {
            if (images.containsKey(img.getId())) {
                // check that no RAW format exists (we are in collapse mode)
                if (((DiskImage) images.get(img.getId())).getVolumeFormat() == VolumeFormat.RAW && img.getVolumeFormat() != VolumeFormat.RAW) {
                    addCanDoActionMessage(VdcBllMessages.VM_CANNOT_EXPORT_RAW_FORMAT);
                    return false;
                }
            }
        }
    }
    // check destination storage is Export domain
    if (getStorageDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN, String.format("$storageDomainName %1$s", getStorageDomainName()));
    }
    // get the snapshot that are going to be exported and have memory
    snapshotsWithMemory = getSnapshotsToBeExportedWithMemory();
    // check destination storage have free space
    int sizeInGB = (int) ImagesHandler.sumImagesTotalSizeWithSnapshotSize(disksForExport) + getTotalMemoryStatesSizeGb();
    if (!doesStorageDomainhaveSpaceForRequest(getStorageDomain(), sizeInGB)) {
        return false;
    }
    SnapshotsValidator snapshotValidator = new SnapshotsValidator();
    if (!(checkVmInStorageDomain() && validate(new StoragePoolValidator(getStoragePool()).isUp()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(new VmValidator(getVm()).vmDown()) && validate(new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), ImagesHandler.getAllStorageIdsForImageIds(disksForExport)).allDomainsExistAndActive()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    setDescription(getVmName());
    setStoragePoolId(getVm().getStoragePoolId());
    // check that target domain exists
    StorageDomainValidator targetstorageDomainValidator = new StorageDomainValidator(getStorageDomain());
    if (!validate(targetstorageDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    // load the disks of vm from database
    VmHandler.updateDisksFromDb(getVm());
    List<DiskImage> disksForExport = getDisksBasedOnImage();
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(disksForExport);
    if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
        return false;
    }
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    // check that the target and source domain are in the same storage_pool
    if (getDbFacade().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getStoragePoolId())) == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        return false;
    }
    // check if template exists only if asked for
    if (getParameters().getTemplateMustExists()) {
        if (!checkTemplateInStorageDomain(getVm().getStoragePoolId(), getParameters().getStorageDomainId(), getVm().getVmtGuid(), getContext().getEngineContext())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_EXPORT_DOMAIN, String.format("$TemplateName %1$s", getVm().getVmtName()));
        }
    }
    // check that the images requested format are valid (COW+Sparse)
    if (!ImagesHandler.checkImagesConfiguration(getParameters().getStorageDomainId(), disksForExport, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Map<Guid, ? extends Disk> images = getVm().getDiskMap();
    if (getParameters().getCopyCollapse()) {
        for (DiskImage img : disksForExport) {
            if (images.containsKey(img.getId())) {
                // check that no RAW format exists (we are in collapse mode)
                if (((DiskImage) images.get(img.getId())).getVolumeFormat() == VolumeFormat.RAW && img.getVolumeFormat() != VolumeFormat.RAW) {
                    addCanDoActionMessage(VdcBllMessages.VM_CANNOT_EXPORT_RAW_FORMAT);
                    return false;
                }
            }
        }
    }
    // check destination storage is Export domain
    if (getStorageDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN, String.format("$storageDomainName %1$s", getStorageDomainName()));
    }
    // get the snapshot that are going to be exported and have memory
    snapshotsWithMemory = getSnapshotsToBeExportedWithMemory();
    // check destination storage have free space
    int sizeInGB = (int) ImagesHandler.sumImagesTotalSizeWithSnapshotSize(disksForExport) + getTotalMemoryStatesSizeGb();
    if (!doesStorageDomainhaveSpaceForRequest(getStorageDomain(), sizeInGB)) {
        return false;
    }
    SnapshotsValidator snapshotValidator = new SnapshotsValidator();
    if (!(checkVmInStorageDomain() && validate(new StoragePoolValidator(getStoragePool()).isUp()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(new VmValidator(getVm()).vmDown()) && validate(new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), ImagesHandler.getAllStorageIdsForImageIds(disksForExport)).allDomainsExistAndActive()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
public static boolean checkTemplateInStorageDomain(Guid storagePoolId, Guid storageDomainId, final Guid tmplId) {
    boolean retVal = false;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
    if (qretVal.getSucceeded()) {
        if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(tmplId)) {
            Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
            VmTemplate tmpl = LinqUtils.firstOrNull(templates.keySet(), new Predicate<VmTemplate>() {

                @Override
                public boolean eval(VmTemplate vmTemplate) {
                    return vmTemplate.getId().equals(tmplId);
                }
            });
            retVal = tmpl != null;
        } else {
            retVal = true;
        }
    }
    return retVal;
}
#method_after
public static boolean checkTemplateInStorageDomain(Guid storagePoolId, Guid storageDomainId, final Guid tmplId, EngineContext engineContext) {
    boolean retVal = false;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar, engineContext);
    if (qretVal.getSucceeded()) {
        if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(tmplId)) {
            Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
            VmTemplate tmpl = LinqUtils.firstOrNull(templates.keySet(), new Predicate<VmTemplate>() {

                @Override
                public boolean eval(VmTemplate vmTemplate) {
                    return vmTemplate.getId().equals(tmplId);
                }
            });
            retVal = tmpl != null;
        } else {
            retVal = true;
        }
    }
    return retVal;
}
#end_block

#method_before
protected boolean removeDomainFromPool(StorageDomain storageDomain, VDS vds) {
    if (storageDomain.getStorageType() != StorageType.LOCALFS || storageDomain.getStorageDomainType() == StorageDomainType.ISO) {
        DetachStorageDomainFromPoolParameters tempVar = new DetachStorageDomainFromPoolParameters(storageDomain.getId(), getStoragePool().getId());
        tempVar.setRemoveLast(true);
        tempVar.setDestroyingPool(true);
        // in detach of one of storage domains
        if (!Backend.getInstance().runInternalAction(VdcActionType.DetachStorageDomainFromPool, tempVar).getSucceeded()) {
            return false;
        }
    } else {
        RemoveStorageDomainParameters tempVar = new RemoveStorageDomainParameters(storageDomain.getId());
        tempVar.setDestroyingPool(true);
        tempVar.setDoFormat(true);
        tempVar.setVdsId(vds.getId());
        if (!runInternalAction(VdcActionType.RemoveStorageDomain, tempVar, dupContext().resetLock().resetExecutionContext()).getSucceeded()) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean removeDomainFromPool(StorageDomain storageDomain, VDS vds) {
    if (storageDomain.getStorageType() != StorageType.LOCALFS || storageDomain.getStorageDomainType() == StorageDomainType.ISO) {
        DetachStorageDomainFromPoolParameters tempVar = new DetachStorageDomainFromPoolParameters(storageDomain.getId(), getStoragePool().getId());
        tempVar.setRemoveLast(true);
        tempVar.setDestroyingPool(true);
        // in detach of one of storage domains
        if (!Backend.getInstance().runInternalAction(VdcActionType.DetachStorageDomainFromPool, tempVar).getSucceeded()) {
            return false;
        }
    } else {
        RemoveStorageDomainParameters tempVar = new RemoveStorageDomainParameters(storageDomain.getId());
        tempVar.setDestroyingPool(true);
        tempVar.setDoFormat(true);
        tempVar.setVdsId(vds.getId());
        if (!runInternalAction(VdcActionType.RemoveStorageDomain, tempVar, dupContext().withoutLock().withoutExecutionContext()).getSucceeded()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected CommandContext createMigrateVmContext(ExecutionContext parentContext, VM vm) {
    ExecutionContext ctx = new ExecutionContext();
    try {
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VM.name().toLowerCase(), vm.getName());
        values.put(VdcObjectType.VDS.name().toLowerCase(), vm.getRunOnVdsName());
        Step step = ExecutionHandler.addSubStep(getExecutionContext(), parentContext.getJob().getStep(StepEnum.EXECUTING), StepEnum.MIGRATE_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.MIGRATE_VM, values));
        ctx.setJob(parentContext.getJob());
        ctx.setStep(step);
        ctx.setMonitored(true);
    } catch (RuntimeException e) {
        log.error("Failed to create ExecutionContext for MigrateVmCommand", e);
    }
    return dupContext().setExecutionContext(ctx).resetCompensationContext().resetLock();
}
#method_after
protected CommandContext createMigrateVmContext(ExecutionContext parentContext, VM vm) {
    ExecutionContext ctx = new ExecutionContext();
    try {
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VM.name().toLowerCase(), vm.getName());
        values.put(VdcObjectType.VDS.name().toLowerCase(), vm.getRunOnVdsName());
        Step step = ExecutionHandler.addSubStep(getExecutionContext(), parentContext.getJob().getStep(StepEnum.EXECUTING), StepEnum.MIGRATE_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.MIGRATE_VM, values));
        ctx.setJob(parentContext.getJob());
        ctx.setStep(step);
        ctx.setMonitored(true);
    } catch (RuntimeException e) {
        log.error("Failed to create ExecutionContext for MigrateVmCommand", e);
    }
    return dupContext().withExecutionContext(ctx).withoutCompensationContext().withoutLock();
}
#end_block

#method_before
public ArrayList<VdcReturnValueBase> execute() {
    // sanity - don't do anything if no parameters passed
    if (parameters == null || parameters.isEmpty()) {
        log.infoFormat("{0} of type {1} invoked with no actions", this.getClass().getSimpleName(), actionType);
        return new ArrayList<VdcReturnValueBase>();
    }
    ArrayList<VdcReturnValueBase> returnValues = new ArrayList<VdcReturnValueBase>();
    try {
        VdcReturnValueBase returnValue;
        for (VdcActionParametersBase parameter : getParameters()) {
            parameter.setMultipleAction(true);
            returnValue = ExecutionHandler.evaluateCorrelationId(parameter);
            if (returnValue == null) {
                CommandBase<?> command = CommandsFactory.createCommand(actionType, parameter);
                command.setInternalExecution(isInternal);
                getCommands().add(command);
            } else {
                returnValues.add(returnValue);
            }
        }
        if (getCommands().size() == 1) {
            ThreadLocalParamsContainer.setCorrelationId(getCommands().get(0).getCorrelationId());
            returnValues.add(getCommands().get(0).canDoActionOnly());
        } else {
            checkCanDoActionsAsynchronously(returnValues);
        }
        boolean canRunActions = true;
        if (isRunOnlyIfAllCanDoPass) {
            for (VdcReturnValueBase value : returnValues) {
                if (!value.getCanDoAction()) {
                    canRunActions = false;
                    break;
                }
            }
        }
        if (canRunActions) {
            if (isWaitForResult) {
                invokeSyncCommands();
            } else {
                invokeCommands();
            }
        }
    } catch (RuntimeException e) {
        log.error("Failed to execute multiple actions of type: " + actionType, e);
    }
    return returnValues;
}
#method_after
public ArrayList<VdcReturnValueBase> execute() {
    // sanity - don't do anything if no parameters passed
    if (parameters == null || parameters.isEmpty()) {
        log.infoFormat("{0} of type {1} invoked with no actions", this.getClass().getSimpleName(), actionType);
        return new ArrayList<VdcReturnValueBase>();
    }
    ArrayList<VdcReturnValueBase> returnValues = new ArrayList<VdcReturnValueBase>();
    try {
        VdcReturnValueBase returnValue;
        for (VdcActionParametersBase parameter : getParameters()) {
            parameter.setMultipleAction(true);
            returnValue = ExecutionHandler.evaluateCorrelationId(parameter);
            if (returnValue == null) {
                CommandBase<?> command = isInternal ? CommandsFactory.createCommand(actionType, parameter, commandContext.clone().withoutCompensationContext()) : CommandsFactory.createCommand(actionType, parameter);
                command.setInternalExecution(isInternal);
                getCommands().add(command);
            } else {
                returnValues.add(returnValue);
            }
        }
        if (getCommands().size() == 1) {
            ThreadLocalParamsContainer.setCorrelationId(getCommands().get(0).getCorrelationId());
            returnValues.add(getCommands().get(0).canDoActionOnly());
        } else {
            checkCanDoActionsAsynchronously(returnValues);
        }
        boolean canRunActions = true;
        if (isRunOnlyIfAllCanDoPass) {
            for (VdcReturnValueBase value : returnValues) {
                if (!value.getCanDoAction()) {
                    canRunActions = false;
                    break;
                }
            }
        }
        if (canRunActions) {
            if (isWaitForResult) {
                invokeSyncCommands();
            } else {
                invokeCommands();
            }
        }
    } catch (RuntimeException e) {
        log.error("Failed to execute multiple actions of type: " + actionType, e);
    }
    return returnValues;
}
#end_block

#method_before
/**
 * Executes commands which passed validation and creates monitoring objects.
 *
 * @param command
 *            The command to execute
 */
protected void executeValidatedCommand(CommandBase<?> command) {
    if (commandContext == null || commandContext.getExecutionContext() == null || commandContext.getExecutionContext().isMonitored()) {
        ExecutionHandler.prepareCommandForMonitoring(command, command.getActionType(), command.isInternalExecution());
    }
    ThreadLocalParamsContainer.setCorrelationId(command.getCorrelationId());
    command.insertAsyncTaskPlaceHolders();
    command.inheritContext(commandContext);
    command.executeAction();
}
#method_after
/**
 * Executes commands which passed validation and creates monitoring objects.
 *
 * @param command
 *            The command to execute
 */
protected void executeValidatedCommand(CommandBase<?> command) {
    if (commandContext == null || commandContext.getExecutionContext() == null || commandContext.getExecutionContext().isMonitored()) {
        ExecutionHandler.prepareCommandForMonitoring(command, command.getActionType(), command.isInternalExecution());
    }
    ThreadLocalParamsContainer.setCorrelationId(command.getCorrelationId());
    command.insertAsyncTaskPlaceHolders();
    command.executeAction();
}
#end_block

#method_before
private VdcReturnValueBase runActionImpl(VdcActionType actionType, VdcActionParametersBase parameters, boolean runAsInternal, CommandContext context) {
    VdcReturnValueBase result;
    // If non-monitored command is invoked with JobId or ActionId as parameters, reject this command on can do action.
    if (!actionType.isActionMonitored() && !isActionExternal(actionType) && (parameters.getJobId() != null || parameters.getStepId() != null)) {
        result = new VdcReturnValueBase();
        result.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_NON_MONITORED.toString());
        result.setCanDoAction(false);
        result.setSucceeded(false);
    } else {
        CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters);
        result = runAction(command, runAsInternal, context);
    }
    return result;
}
#method_after
private VdcReturnValueBase runActionImpl(VdcActionType actionType, VdcActionParametersBase parameters, boolean runAsInternal, CommandContext context) {
    VdcReturnValueBase result;
    // If non-monitored command is invoked with JobId or ActionId as parameters, reject this command on can do action.
    if (!actionType.isActionMonitored() && !isActionExternal(actionType) && (parameters.getJobId() != null || parameters.getStepId() != null)) {
        result = new VdcReturnValueBase();
        result.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_NON_MONITORED.toString());
        result.setCanDoAction(false);
        result.setSucceeded(false);
    } else {
        CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters, context);
        result = runAction(command, runAsInternal);
    }
    return result;
}
#end_block

#method_before
@Override
public VdcReturnValueBase runAction(CommandBase<?> action, ExecutionContext executionContext) {
    return runAction(action, true, ExecutionHandler.createDefaultContexForTasks(executionContext));
}
#method_after
protected VdcReturnValueBase runAction(CommandBase<?> command, boolean runAsInternal) {
    VdcReturnValueBase returnValue = evaluateCorrelationId(command);
    if (returnValue != null) {
        return returnValue;
    }
    command.setInternalExecution(runAsInternal);
    ExecutionHandler.prepareCommandForMonitoring(command, command.getActionType(), runAsInternal);
    command.insertAsyncTaskPlaceHolders();
    returnValue = command.executeAction();
    returnValue.setCorrelationId(command.getParameters().getCorrelationId());
    returnValue.setJobId(command.getJobId());
    return returnValue;
}
#end_block

#method_before
@Override
public VdcReturnValueBase endAction(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext context) {
    CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters);
    command.setContext(context);
    return command.endAction();
}
#method_after
@Override
public VdcReturnValueBase endAction(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext context) {
    return CommandsFactory.createCommand(actionType, parameters, context).endAction();
}
#end_block

#method_before
@Override
@ExcludeClassInterceptors
public VdcQueryReturnValue runInternalQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, false);
}
#method_after
@Override
@ExcludeClassInterceptors
public VdcQueryReturnValue runInternalQuery(VdcQueryType actionType, VdcQueryParametersBase parameters, EngineContext engineContext) {
    return runQueryImpl(actionType, parameters, false, engineContext);
}
#end_block

#method_before
@Override
public VdcQueryReturnValue runQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, true);
}
#method_after
@Override
public VdcQueryReturnValue runQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, true, null);
}
#end_block

#method_before
protected VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    if (isPerformUserCheck) {
        String sessionId = parameters.getSessionId();
        if (StringUtils.isEmpty(sessionId) || SessionDataContainer.getInstance().getUser(sessionId, parameters.getRefresh()) == null) {
            return getErrorQueryReturnValue(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        }
    }
    Class<CommandBase<? extends VdcActionParametersBase>> clazz = CommandsFactory.getQueryClass(actionType.name());
    if (clazz.isAnnotationPresent(DisableInMaintenanceMode.class)) {
        String mode = (DbFacade.getInstance().getVdcOptionDao().getByNameAndVersion(ConfigValues.EngineMode.name(), ConfigCommon.defaultConfigurationVersion)).getoption_value();
        if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
            return getErrorQueryReturnValue(VdcBllMessages.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
        }
    }
    QueriesCommandBase<?> command = createQueryCommand(actionType, parameters);
    command.setInternalExecution(!isPerformUserCheck);
    command.execute();
    return command.getQueryReturnValue();
}
#method_after
protected VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck, EngineContext engineContext) {
    if (isPerformUserCheck) {
        String sessionId = parameters.getSessionId();
        if (StringUtils.isEmpty(sessionId) || SessionDataContainer.getInstance().getUser(sessionId, parameters.getRefresh()) == null) {
            return getErrorQueryReturnValue(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        }
    }
    Class<CommandBase<? extends VdcActionParametersBase>> clazz = CommandsFactory.getQueryClass(actionType.name());
    if (clazz.isAnnotationPresent(DisableInMaintenanceMode.class)) {
        String mode = (DbFacade.getInstance().getVdcOptionDao().getByNameAndVersion(ConfigValues.EngineMode.name(), ConfigCommon.defaultConfigurationVersion)).getoption_value();
        if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
            return getErrorQueryReturnValue(VdcBllMessages.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
        }
    }
    QueriesCommandBase<?> command = createQueryCommand(actionType, parameters, engineContext);
    command.setInternalExecution(!isPerformUserCheck);
    command.execute();
    return command.getQueryReturnValue();
}
#end_block

#method_before
protected VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    if (isPerformUserCheck) {
        String sessionId = parameters.getSessionId();
        if (StringUtils.isEmpty(sessionId) || SessionDataContainer.getInstance().getUser(sessionId, parameters.getRefresh()) == null) {
            return getErrorQueryReturnValue(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        }
    }
    Class<CommandBase<? extends VdcActionParametersBase>> clazz = CommandsFactory.getQueryClass(actionType.name());
    if (clazz.isAnnotationPresent(DisableInMaintenanceMode.class)) {
        String mode = (DbFacade.getInstance().getVdcOptionDao().getByNameAndVersion(ConfigValues.EngineMode.name(), ConfigCommon.defaultConfigurationVersion)).getoption_value();
        if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
            return getErrorQueryReturnValue(VdcBllMessages.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
        }
    }
    QueriesCommandBase<?> command = createQueryCommand(actionType, parameters);
    command.setInternalExecution(!isPerformUserCheck);
    command.execute();
    return command.getQueryReturnValue();
}
#method_after
protected VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    return runQueryImpl(actionType, parameters, isPerformUserCheck, null);
}
#end_block

#method_before
private ArrayList<VdcReturnValueBase> runMultipleActionsImpl(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isInternal, boolean isRunOnlyIfAllCanDoPass, boolean isWaitForResult, CommandContext commandContext) {
    MultipleActionsRunner runner = MultipleActionsRunnersFactory.createMultipleActionsRunner(actionType, parameters, isInternal);
    runner.setCommandContext(commandContext);
    runner.setIsRunOnlyIfAllCanDoPass(isRunOnlyIfAllCanDoPass);
    runner.setIsWaitForResult(isWaitForResult);
    return runner.execute();
}
#method_after
private ArrayList<VdcReturnValueBase> runMultipleActionsImpl(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isInternal, boolean isRunOnlyIfAllCanDoPass, boolean isWaitForResult, CommandContext commandContext) {
    MultipleActionsRunner runner = MultipleActionsRunnersFactory.createMultipleActionsRunner(actionType, parameters, isInternal, commandContext);
    runner.setIsRunOnlyIfAllCanDoPass(isRunOnlyIfAllCanDoPass);
    runner.setIsWaitForResult(isWaitForResult);
    return runner.execute();
}
#end_block

#method_before
protected QueriesCommandBase<?> createQueryCommand(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return CommandsFactory.createQueryCommand(actionType, parameters);
}
#method_after
protected QueriesCommandBase<?> createQueryCommand(VdcQueryType actionType, VdcQueryParametersBase parameters, EngineContext engineContext) {
    return CommandsFactory.createQueryCommand(actionType, parameters, engineContext);
}
#end_block

#method_before
@Override
public CommandBase<?> createAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return CommandsFactory.createCommand(actionType, parameters);
}
#method_after
@Override
public CommandBase<?> createAction(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext context) {
    return CommandsFactory.createCommand(actionType, parameters, context);
}
#end_block

#method_before
@Override
public VdcReturnValueBase runAction(CommandBase<?> action, ExecutionContext executionContext) {
    return runAction(action, true, ExecutionHandler.createDefaultContexForTasks(executionContext));
}
#method_after
@Override
public VdcReturnValueBase runAction(CommandBase<?> action, ExecutionContext executionContext) {
    ExecutionHandler.setExecutionContextForTasks(action.getContext(), executionContext, null);
    return runAction(action, true);
}
#end_block

#method_before
@Override
@ExcludeClassInterceptors
public VdcQueryReturnValue runInternalQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, false);
}
#method_after
@Override
public VdcQueryReturnValue runInternalQuery(VdcQueryType queryType, VdcQueryParametersBase queryParameters) {
    return runInternalQuery(queryType, queryParameters, null);
}
#end_block

#method_before
protected VdcReturnValueBase attemptRollback(VdcActionType commandType, VdcActionParametersBase params, CommandContext rollbackContext) {
    if (canPerformRollbackUsingCommand(commandType, params)) {
        params.setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        params.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        entailContext(rollbackContext);
        return getBackend().runInternalAction(commandType, params, rollbackContext);
    }
    return new VdcReturnValueBase();
}
#method_after
protected VdcReturnValueBase attemptRollback(VdcActionType commandType, VdcActionParametersBase params) {
    if (canPerformRollbackUsingCommand(commandType, params)) {
        params.setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        params.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        return getBackend().runInternalAction(commandType, params, context.clone());
    }
    return new VdcReturnValueBase();
}
#end_block

#method_before
protected VdcReturnValueBase checkAndPerformRollbackUsingCommand(VdcActionType commandType, VdcActionParametersBase params) {
    return attemptRollback(commandType, params, null);
}
#method_after
protected VdcReturnValueBase checkAndPerformRollbackUsingCommand(VdcActionType commandType, VdcActionParametersBase params) {
    return attemptRollback(commandType, params);
}
#end_block

#method_before
public void setCompensationContext(CompensationContext compensationContext) {
    context.setCompensationContext(compensationContext);
}
#method_after
public void setCompensationContext(CompensationContext compensationContext) {
    context.withCompensationContext(compensationContext);
}
#end_block

#method_before
private void initiateLockEndAction() {
    if (commandLock == null) {
        LockIdNameAttribute annotation = getClass().getAnnotation(LockIdNameAttribute.class);
        if (annotation != null && !annotation.isReleaseAtEndOfExecute()) {
            commandLock = buildLock();
        }
    }
}
#method_after
private void initiateLockEndAction() {
    if (context.getLock() == null) {
        LockIdNameAttribute annotation = getClass().getAnnotation(LockIdNameAttribute.class);
        if (annotation != null && !annotation.isReleaseAtEndOfExecute()) {
            context.withLock(buildLock());
        }
    }
}
#end_block

#method_before
private void handleTransactivity() {
    scope = (getParameters() != null) ? getParameters().getTransactionScopeOption() : TransactionScopeOption.Required;
    endActionScope = scope;
    boolean forceCompensation = getForceCompensation();
    // command parameters
    if (!getTransactive()) {
        scope = TransactionScopeOption.Suppress;
        // Set the end action scope to suppress only for non-compensating commands, or the end action for commands
        // will run without transaction but compensation is not supported for end action.
        endActionScope = forceCompensation ? endActionScope : scope;
    }
    if (getCompensationContext() == null) {
        context.setCompensationContext(createCompensationContext(scope, forceCompensation));
    }
}
#method_after
private void handleTransactivity() {
    scope = (getParameters() != null) ? getParameters().getTransactionScopeOption() : TransactionScopeOption.Required;
    endActionScope = scope;
    boolean forceCompensation = getForceCompensation();
    // command parameters
    if (!getTransactive()) {
        scope = TransactionScopeOption.Suppress;
        // Set the end action scope to suppress only for non-compensating commands, or the end action for commands
        // will run without transaction but compensation is not supported for end action.
        endActionScope = forceCompensation ? endActionScope : scope;
    }
    if (getCompensationContext() == null) {
        context.withCompensationContext(createCompensationContext(scope, forceCompensation));
    }
}
#end_block

#method_before
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            compensate();
        } else {
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#method_after
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setSucceeded(false);
            compensate();
        } else {
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#end_block

#method_before
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = BackendUtils.getBackendCommandObjectsHandler(log).createAction(entry.getValue().getFirst(), entry.getValue().getSecond());
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#method_after
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = BackendUtils.getBackendCommandObjectsHandler(log).createAction(entry.getValue().getFirst(), entry.getValue().getSecond(), context);
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#end_block

#method_before
protected EngineLock getLock() {
    return commandLock;
}
#method_after
protected EngineLock getLock() {
    return context.getLock();
}
#end_block

#method_before
protected void setLock(EngineLock lock) {
    commandLock = lock;
}
#method_after
protected void setLock(EngineLock lock) {
    context.withLock(null);
}
#end_block

#method_before
protected boolean acquireLockInternal() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (commandLock == null) {
        EngineLock lock = buildLock();
        if (lock != null) {
            Pair<Boolean, Set<String>> lockAcquireResult = getLockManager().acquireLock(lock);
            if (lockAcquireResult.getFirst()) {
                log.infoFormat("Lock Acquired to object {0}", lock);
                commandLock = lock;
            } else {
                log.infoFormat("Failed to Acquire Lock to object {0}", lock);
                getReturnValue().getCanDoActionMessages().addAll(extractVariableDeclarations(lockAcquireResult.getSecond()));
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean acquireLockInternal() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        EngineLock lock = buildLock();
        if (lock != null) {
            Pair<Boolean, Set<String>> lockAcquireResult = getLockManager().acquireLock(lock);
            if (lockAcquireResult.getFirst()) {
                log.infoFormat("Lock Acquired to object {0}", lock);
                context.withLock(lock);
            } else {
                log.infoFormat("Failed to Acquire Lock to object {0}", lock);
                getReturnValue().getCanDoActionMessages().addAll(extractVariableDeclarations(lockAcquireResult.getSecond()));
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
private void acquireLockAndWait() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (commandLock == null) {
        Map<String, Pair<String, String>> exclusiveLocks = getExclusiveLocks();
        if (exclusiveLocks != null) {
            EngineLock lock = new EngineLock(exclusiveLocks, null);
            getLockManager().acquireLockWait(lock);
            commandLock = lock;
        }
    }
}
#method_after
private void acquireLockAndWait() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        Map<String, Pair<String, String>> exclusiveLocks = getExclusiveLocks();
        if (exclusiveLocks != null) {
            EngineLock lock = new EngineLock(exclusiveLocks, null);
            getLockManager().acquireLockWait(lock);
            context.withLock(lock);
        }
    }
}
#end_block

#method_before
protected void freeLock() {
    if (commandLock != null) {
        getLockManager().releaseLock(commandLock);
        log.infoFormat("Lock freed to object {0}", commandLock);
        commandLock = null;
    }
}
#method_after
protected void freeLock() {
    if (context.getLock() != null) {
        getLockManager().releaseLock(context.getLock());
        log.infoFormat("Lock freed to object {0}", context.getLock());
        context.withLock(null);
    }
}
#end_block

#method_before
public void setExecutionContext(ExecutionContext executionContext) {
    context.setExecutionContext(executionContext);
}
#method_after
public void setExecutionContext(ExecutionContext executionContext) {
    context.withExecutionContext(executionContext);
}
#end_block

#method_before
protected VdcReturnValueBase runInternalAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return Backend.getInstance().runInternalAction(actionType, parameters, createInheritingContext());
}
#method_after
protected VdcReturnValueBase runInternalAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return getBackend().runInternalAction(actionType, parameters, context.clone());
}
#end_block

#method_before
protected VdcReturnValueBase runInternalAction(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext inheritingContext) {
    entailContext(inheritingContext);
    return Backend.getInstance().runInternalAction(actionType, parameters, inheritingContext);
}
#method_after
protected VdcReturnValueBase runInternalAction(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext internalCommandContext) {
    return getBackend().runInternalAction(actionType, parameters, internalCommandContext);
}
#end_block

#method_before
protected ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters) {
    return Backend.getInstance().runInternalMultipleActions(actionType, parameters, createInheritingContext());
}
#method_after
protected ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters) {
    return getBackend().runInternalMultipleActions(actionType, parameters, context.clone());
}
#end_block

#method_before
protected ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, ExecutionContext executionContext) {
    return Backend.getInstance().runInternalMultipleActions(actionType, parameters, createInheritingContext(executionContext));
}
#method_after
protected ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, ExecutionContext executionContext) {
    return getBackend().runInternalMultipleActions(actionType, parameters, context.clone().withExecutionContext(executionContext));
}
#end_block

#method_before
@Override
public void processOnVmStop(Guid vmId) {
    Backend.getInstance().runInternalAction(VdcActionType.ProcessDownVm, new IdParameters(vmId));
}
#method_after
@Override
public void processOnVmStop(final Collection<Guid> vmIds) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            for (Guid vmId : vmIds) {
                Backend.getInstance().runInternalAction(VdcActionType.ProcessDownVm, new IdParameters(vmId));
            }
        }
    });
}
#end_block

#method_before
@Override
public boolean vdsUpEvent(final VDS vds) {
    HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds);
    boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded();
    if (isSucceeded) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                try {
                    // migrate vms that its their default vds and failback
                    // is on
                    List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId());
                    if (!vmsToMigrate.isEmpty()) {
                        ExecutionContext executionContext = new ExecutionContext();
                        executionContext.setMonitored(true);
                        Backend.getInstance().runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), new CommandContext(executionContext));
                    }
                } catch (RuntimeException e) {
                    log.errorFormat("Failed to initialize Vds on up. Error: {0}", e);
                }
            }
        });
    }
    return isSucceeded;
}
#method_after
@Override
public boolean vdsUpEvent(final VDS vds) {
    HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds);
    boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded();
    if (isSucceeded) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                try {
                    // migrate vms that its their default vds and failback
                    // is on
                    List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId());
                    if (!vmsToMigrate.isEmpty()) {
                        CommandContext ctx = new CommandContext(new EngineContext());
                        ctx.getExecutionContext().setMonitored(true);
                        Backend.getInstance().runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx);
                    }
                } catch (RuntimeException e) {
                    log.errorFormat("Failed to initialize Vds on up. Error: {0}", e);
                }
            }
        });
    }
    return isSucceeded;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    // Fetch all the Iso files of a given type for storage pool with active storage domain of this domain Id.
    try {
        getQueryReturnValue().setReturnValue(getUserRequestForStorageDomainRepoFileList());
    } catch (VdcBLLException e) {
        getQueryReturnValue().setSucceeded(false);
        getQueryReturnValue().setExceptionString(e.getErrorCode().toString());
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    // Fetch all the Iso files of a given type for storage pool with active storage domain of this domain Id.
    getQueryReturnValue().setReturnValue(getUserRequestForStorageDomainRepoFileList());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVds() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_APPROVE_VDS_NOT_FOUND);
        returnValue = false;
    } else if (getVds().getStatus() != VDSStatus.PendingApproval && getVds().getStatus() != VDSStatus.InstallFailed) {
        addCanDoActionMessage(VdcBllMessages.VDS_APPROVE_VDS_IN_WRONG_STATUS);
        returnValue = false;
    }
    return returnValue ? super.canDoAction() : false;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVds() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_APPROVE_VDS_NOT_FOUND);
        returnValue = false;
    } else if (getVds().getStatus() != VDSStatus.PendingApproval && getVds().getStatus() != VDSStatus.InstallFailed && getVds().getStatus() != VDSStatus.InstallingOS) {
        addCanDoActionMessage(VdcBllMessages.VDS_APPROVE_VDS_IN_WRONG_STATUS);
        returnValue = false;
    }
    return returnValue ? super.canDoAction() : false;
}
#end_block

#method_before
private void MigrateAllVdss() {
    for (Guid vdsId : vdssToMaintenance.keySet()) {
        // ParametersCurrentUser = CurrentUser
        MaintenanceVdsParameters tempVar = new MaintenanceVdsParameters(vdsId, getParameters().getIsInternal());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCorrelationId(getParameters().getCorrelationId());
        VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.MaintenanceVds, tempVar, ExecutionHandler.createInternalJobContext());
        if (!result.getCanDoAction()) {
            getReturnValue().getCanDoActionMessages().addAll(result.getCanDoActionMessages());
            getReturnValue().setCanDoAction(false);
        }
    }
}
#method_after
private void MigrateAllVdss() {
    for (Guid vdsId : vdssToMaintenance.keySet()) {
        // ParametersCurrentUser = CurrentUser
        MaintenanceVdsParameters tempVar = new MaintenanceVdsParameters(vdsId, getParameters().getIsInternal());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCorrelationId(getParameters().getCorrelationId());
        VdcReturnValueBase result = runInternalAction(VdcActionType.MaintenanceVds, tempVar, ExecutionHandler.createInternalJobContext());
        if (!result.getCanDoAction()) {
            getReturnValue().getCanDoActionMessages().addAll(result.getCanDoActionMessages());
            getReturnValue().setCanDoAction(false);
        }
    }
}
#end_block

#method_before
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
private boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!getVm().getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = new MultipleStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        // update vm snapshots for storage free space check
        ImagesHandler.fillImagesBySnapshots(getVm());
        Map<StorageDomain, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false, true), storageDomains, diskInfoDestinationMap);
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    return true;
}
#method_after
private boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = new MultipleStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        // update vm snapshots for storage free space check
        ImagesHandler.fillImagesBySnapshots(getVm());
        Map<StorageDomain, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false, true), storageDomains, diskInfoDestinationMap);
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
private void endDefaultOperations() {
    endUnlockOps();
    // in case of new version of a template, update vms marked to use latest
    if (isTemplateVersion()) {
        String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "onTimerHandleVdsRecovering", new Class[0], new Object[0], 0, TimeUnit.SECONDS);
        updateVmsJobIdMap.put(getParameters().getBaseTemplateId(), jobId);
    }
}
#method_after
private void endDefaultOperations() {
    endUnlockOps();
    // in case of new version of a template, update vms marked to use latest
    if (isTemplateVersion()) {
        String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "updateVmVersion", new Class[0], new Object[0], 0, TimeUnit.SECONDS);
        updateVmsJobIdMap.put(getParameters().getBaseTemplateId(), jobId);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = false;
    _oldVds = getVdsDAO().get(getVdsId());
    if (_oldVds != null && getParameters().getVdsStaticData() != null) {
        String compatibilityVersion = _oldVds.getVdsGroupCompatibilityVersion().toString();
        if (VdsHandler.isUpdateValid(getParameters().getVdsStaticData(), _oldVds.getStaticData(), _oldVds.getStatus())) {
            if ("".equals(getParameters().getVdsStaticData().getName())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
            String vdsName = getParameters().getvds().getName();
            String hostName = getParameters().getvds().getHostName();
            int maxVdsNameLength = Config.<Integer>getValue(ConfigValues.MaxVdsNameLength);
            // check that VDS name is not null or empty
            if (vdsName == null || vdsName.isEmpty()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
                returnValue = false;
            // check that VDS name is not too long
            } else if (vdsName.length() > maxVdsNameLength) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
                returnValue = false;
            } else if (_oldVds.getStatus() != VDSStatus.InstallFailed && !_oldVds.getHostName().equals(hostName)) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_HOSTNAME_CANNOT_CHANGE);
                returnValue = false;
            } else // check if a name is updated to an existing vds name
            if (!StringUtils.equalsIgnoreCase(_oldVds.getName(), getParameters().getVdsStaticData().getName()) && getVdsDAO().getByName(vdsName) != null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            } else if (!StringUtils.equalsIgnoreCase(_oldVds.getHostName(), getParameters().getVdsStaticData().getHostName()) && getVdsDAO().getAllForHostname(hostName).size() != 0) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST);
            } else if (getParameters().getInstallVds() && _oldVds.getStatus() != VDSStatus.Maintenance && _oldVds.getStatus() != VDSStatus.NonOperational && _oldVds.getStatus() != VDSStatus.InstallFailed) {
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_STATUS_ILLEGAL);
            } else if (getParameters().getInstallVds() && getParameters().getAuthMethod() == AuthenticationMethod.Password && StringUtils.isEmpty(getParameters().getPassword()) && getParameters().getVdsStaticData().getVdsType() == VDSType.VDS) {
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
            } else if (!getParameters().getInstallVds() && _oldVds.getPort() != getParameters().getVdsStaticData().getPort()) {
                addCanDoActionMessage(VdcBllMessages.VDS_PORT_CHANGE_REQUIRE_INSTALL);
            } else if (!_oldVds.getVdsGroupId().equals(getParameters().getVdsStaticData().getVdsGroupId())) {
                // Forbid updating group id - this must be done through
                // ChangeVDSClusterCommand
                // This is due to permission check that must be done both on
                // the VDS and on the VDSGroup
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_UPDATE_CLUSTER);
            } else {
                returnValue = true;
            }
            // if all ok check PM is legal
            returnValue = returnValue && IsPowerManagementLegal(getParameters().getVdsStaticData(), compatibilityVersion);
        } else {
            addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = false;
    _oldVds = getVdsDAO().get(getVdsId());
    if (_oldVds != null && getParameters().getVdsStaticData() != null) {
        String compatibilityVersion = _oldVds.getVdsGroupCompatibilityVersion().toString();
        if (VdsHandler.isUpdateValid(getParameters().getVdsStaticData(), _oldVds.getStaticData(), _oldVds.getStatus())) {
            if ("".equals(getParameters().getVdsStaticData().getName())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
            String vdsName = getParameters().getvds().getName();
            String hostName = getParameters().getvds().getHostName();
            int maxVdsNameLength = Config.<Integer>getValue(ConfigValues.MaxVdsNameLength);
            // check that VDS name is not null or empty
            if (vdsName == null || vdsName.isEmpty()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
                returnValue = false;
            // check that VDS name is not too long
            } else if (vdsName.length() > maxVdsNameLength) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
                returnValue = false;
            } else if (_oldVds.getStatus() != VDSStatus.InstallFailed && !_oldVds.getHostName().equals(hostName)) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_HOSTNAME_CANNOT_CHANGE);
                returnValue = false;
            } else // check if a name is updated to an existing vds name
            if (!StringUtils.equalsIgnoreCase(_oldVds.getName(), getParameters().getVdsStaticData().getName()) && getVdsDAO().getByName(vdsName) != null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            } else if (!StringUtils.equalsIgnoreCase(_oldVds.getHostName(), getParameters().getVdsStaticData().getHostName()) && getVdsDAO().getAllForHostname(hostName).size() != 0) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST);
            } else if (getParameters().getInstallVds() && _oldVds.getStatus() != VDSStatus.Maintenance && _oldVds.getStatus() != VDSStatus.NonOperational && _oldVds.getStatus() != VDSStatus.InstallFailed && _oldVds.getStatus() != VDSStatus.InstallingOS) {
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_STATUS_ILLEGAL);
            } else if (getParameters().getInstallVds() && getParameters().getAuthMethod() == AuthenticationMethod.Password && StringUtils.isEmpty(getParameters().getPassword()) && getParameters().getVdsStaticData().getVdsType() == VDSType.VDS) {
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
            } else if (!getParameters().getInstallVds() && _oldVds.getPort() != getParameters().getVdsStaticData().getPort()) {
                addCanDoActionMessage(VdcBllMessages.VDS_PORT_CHANGE_REQUIRE_INSTALL);
            } else if (!_oldVds.getVdsGroupId().equals(getParameters().getVdsStaticData().getVdsGroupId())) {
                // Forbid updating group id - this must be done through
                // ChangeVDSClusterCommand
                // This is due to permission check that must be done both on
                // the VDS and on the VDSGroup
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_UPDATE_CLUSTER);
            } else {
                returnValue = true;
            }
            // if all ok check PM is legal
            returnValue = returnValue && IsPowerManagementLegal(getParameters().getVdsStaticData(), compatibilityVersion);
        } else {
            addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    updateVdsData();
    if (NeedToUpdateVdsBroker()) {
        initializeVds();
    }
    if (getParameters().getInstallVds()) {
        InstallVdsParameters tempVar = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        tempVar.setIsReinstallOrUpgrade(getParameters().getIsReinstallOrUpgrade());
        tempVar.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        tempVar.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        tempVar.setProviderId(getParameters().getProviderId());
        tempVar.setNetworkMappings(getParameters().getNetworkMappings());
        tempVar.setAuthMethod(getParameters().getAuthMethod());
        ArrayList<VdcReturnValueBase> resultList = Backend.getInstance().runInternalMultipleActions(actionType, new ArrayList<VdcActionParametersBase>(Arrays.asList(tempVar)));
        // status, therefore needed to fail the command to revert the status.
        if (!resultList.isEmpty()) {
            VdcReturnValueBase vdcReturnValueBase = resultList.get(0);
            if (vdcReturnValueBase != null && !vdcReturnValueBase.getCanDoAction()) {
                ArrayList<String> canDoActionMessages = vdcReturnValueBase.getCanDoActionMessages();
                if (!canDoActionMessages.isEmpty()) {
                    // add can do action messages to return value so error messages
                    // are returned back to the client
                    getReturnValue().getCanDoActionMessages().addAll(canDoActionMessages);
                    log.errorFormat("Installation/upgrade of Host {0},{1} failed due to: {2} ", getVdsId(), getVdsName(), StringUtils.join(Backend.getInstance().getErrorsTranslator().TranslateErrorText(canDoActionMessages), ","));
                }
                // set can do action to false so can do action messages are
                // returned back to client
                getReturnValue().setCanDoAction(false);
                setSucceeded(false);
                // add old vds dynamic data to compensation context. This
                // way the status will revert back to what it was before
                // starting installation process
                getCompensationContext().snapshotEntityStatus(_oldVds.getDynamicData());
                getCompensationContext().stateChanged();
                return;
            }
        }
    }
    // set clusters network to be operational (if needed)
    if (_oldVds.getStatus() == VDSStatus.Up) {
        List<NetworkCluster> networkClusters = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(_oldVds.getVdsGroupId());
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(_oldVds.getVdsGroupId());
        for (NetworkCluster item : networkClusters) {
            for (Network net : networks) {
                if (net.getId().equals(item.getNetworkId())) {
                    NetworkClusterHelper.setStatus(_oldVds.getVdsGroupId(), net);
                }
            }
        }
    }
    AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
    TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    updateVdsData();
    if (NeedToUpdateVdsBroker()) {
        initializeVds();
    }
    if (getParameters().getInstallVds()) {
        InstallVdsParameters tempVar = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        tempVar.setIsReinstallOrUpgrade(getParameters().getIsReinstallOrUpgrade());
        tempVar.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        tempVar.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        tempVar.setProviderId(getParameters().getProviderId());
        tempVar.setNetworkMappings(getParameters().getNetworkMappings());
        tempVar.setAuthMethod(getParameters().getAuthMethod());
        ArrayList<VdcReturnValueBase> resultList = runInternalMultipleActions(actionType, new ArrayList<VdcActionParametersBase>(Arrays.asList(tempVar)));
        // status, therefore needed to fail the command to revert the status.
        if (!resultList.isEmpty()) {
            VdcReturnValueBase vdcReturnValueBase = resultList.get(0);
            if (vdcReturnValueBase != null && !vdcReturnValueBase.getCanDoAction()) {
                ArrayList<String> canDoActionMessages = vdcReturnValueBase.getCanDoActionMessages();
                if (!canDoActionMessages.isEmpty()) {
                    // add can do action messages to return value so error messages
                    // are returned back to the client
                    getReturnValue().getCanDoActionMessages().addAll(canDoActionMessages);
                    log.errorFormat("Installation/upgrade of Host {0},{1} failed due to: {2} ", getVdsId(), getVdsName(), StringUtils.join(Backend.getInstance().getErrorsTranslator().TranslateErrorText(canDoActionMessages), ","));
                }
                // set can do action to false so can do action messages are
                // returned back to client
                getReturnValue().setCanDoAction(false);
                setSucceeded(false);
                // add old vds dynamic data to compensation context. This
                // way the status will revert back to what it was before
                // starting installation process
                getCompensationContext().snapshotEntityStatus(_oldVds.getDynamicData());
                getCompensationContext().stateChanged();
                return;
            }
        }
    }
    // set clusters network to be operational (if needed)
    if (_oldVds.getStatus() == VDSStatus.Up) {
        List<NetworkCluster> networkClusters = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(_oldVds.getVdsGroupId());
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(_oldVds.getVdsGroupId());
        for (NetworkCluster item : networkClusters) {
            for (Network net : networks) {
                if (net.getId().equals(item.getNetworkId())) {
                    NetworkClusterHelper.setStatus(_oldVds.getVdsGroupId(), net);
                }
            }
        }
    }
    AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
    TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
    setSucceeded(true);
}
#end_block

#method_before
protected VdcReturnValueBase executeChildCommand(Guid idInCommandsMap) {
    CommandBase<?> command = childCommandsMap.get(idInCommandsMap);
    return getBackendCommandObjectsHandler().runAction(command, getExecutionContext());
}
#method_after
protected VdcReturnValueBase executeChildCommand(Guid idInCommandsMap) {
    CommandBase<?> command = childCommandsMap.get(idInCommandsMap);
    return BackendUtils.getBackendCommandObjectsHandler(log).runAction(command, getExecutionContext());
}
#end_block

#method_before
private void clearAsyncTasksWithOutVdsmId() {
    if (!getReturnValue().getTaskPlaceHolderIdList().isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (Guid asyncTaskId : getReturnValue().getTaskPlaceHolderIdList()) {
                    AsyncTasks task = getAsyncTaskDao().get(asyncTaskId);
                    if (task != null && Guid.isNullOrEmpty(task.getVdsmTaskId())) {
                        TaskManagerUtil.removeTaskFromDbByTaskId(task.getTaskId());
                    }
                }
                return null;
            }
        });
    }
}
#method_after
private void clearAsyncTasksWithOutVdsmId() {
    if (!getReturnValue().getTaskPlaceHolderIdList().isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (Guid asyncTaskId : getReturnValue().getTaskPlaceHolderIdList()) {
                    AsyncTasks task = TaskManagerUtil.getAsyncTaskFromDb(asyncTaskId);
                    if (task != null && Guid.isNullOrEmpty(task.getVdsmTaskId())) {
                        TaskManagerUtil.removeTaskFromDbByTaskId(task.getTaskId());
                    }
                }
                return null;
            }
        });
    }
}
#end_block

#method_before
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            internalEndSuccessfully();
        } else {
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#method_after
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            setCommandStatus(CommandStatus.SUCCEEDED);
            internalEndSuccessfully();
        } else {
            setCommandStatus(CommandStatus.FAILED);
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#end_block

#method_before
protected boolean checkUserAndGroupsAuthorization(Guid userId, String groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, groupIds, actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#method_after
protected boolean checkUserAndGroupsAuthorization(Guid userId, HashSet<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            compensate();
        } else {
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#method_after
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setSucceeded(false);
            compensate();
        } else {
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#end_block

#method_before
protected final void execute() {
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logRenamedEntity();
                logCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#method_after
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logRenamedEntity();
                logCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#end_block

#method_before
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = getBackendCommandObjectsHandler().createAction(entry.getValue().getFirst(), entry.getValue().getSecond());
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#method_after
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = BackendUtils.getBackendCommandObjectsHandler(log).createAction(entry.getValue().getFirst(), entry.getValue().getSecond());
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#end_block

#method_before
private void saveTaskAndPutInMap(String taskKey, AsyncTasks task) {
    getAsyncTaskDao().save(task);
    taskKeyToTaskIdMap.put(taskKey, task.getTaskId());
}
#method_after
private void saveTaskAndPutInMap(String taskKey, AsyncTasks task) {
    TaskManagerUtil.saveAsyncTaskToDb(task);
    taskKeyToTaskIdMap.put(taskKey, task.getTaskId());
}
#end_block

#method_before
public SPMAsyncTask concreteCreateTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return TaskManagerUtil.concreteCreateTask(taskId, this, asyncTaskCreationInfo, parentCommand);
}
#method_after
public SPMTask concreteCreateTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return TaskManagerUtil.concreteCreateTask(taskId, this, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
protected AsyncTaskType getTaskType() {
    throw new UnsupportedOperationException();
}
#method_after
protected AsyncTaskType getTaskType() {
    return AsyncTaskType.notSupported;
}
#end_block

#method_before
protected void addCanDoActionMessageVariable(String varName, Object varValue) {
    String message = String.format("$%s %s", varName, varValue);
    getReturnValue().getCanDoActionMessages().add(message);
}
#method_after
protected void addCanDoActionMessageVariable(String varName, Object varValue) {
    getReturnValue().getCanDoActionMessages().add(String.format("$%s %s", varName, varValue));
}
#end_block

#method_before
protected boolean hasTaskHandlers() {
    return getTaskHandlers() != null;
}
#method_after
public boolean hasTaskHandlers() {
    return getTaskHandlers() != null;
}
#end_block

#method_before
protected SPMAsyncTaskHandler getCurrentTaskHandler() {
    return getTaskHandlers().get(getExecutionIndex());
}
#method_after
public SPMAsyncTaskHandler getCurrentTaskHandler() {
    return getTaskHandlers().get(getExecutionIndex());
}
#end_block

#method_before
private boolean initVirtResources() {
    if (InitializeStorage()) {
        processFence();
        processStoragePoolStatus();
        runUpdateMomPolicy(getVdsGroup(), getVds());
    } else {
        Map<String, String> customLogValues = new HashMap<>();
        customLogValues.put("StoragePoolName", getStoragePoolName());
        if (problematicDomains != null) {
            StringBuilder domainNames = new StringBuilder();
            for (StorageDomainStatic domain : problematicDomains) {
                if (domainNames.length() > 0) {
                    domainNames.append(", ");
                }
                domainNames.append(domain.getStorageName());
            }
            customLogValues.put("StorageDomainNames", domainNames.toString());
        }
        setNonOperational(NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, customLogValues);
        return false;
    }
    return true;
}
#method_after
private boolean initVirtResources() {
    if (InitializeStorage()) {
        processFence();
        processStoragePoolStatus();
        runUpdateMomPolicy(getVdsGroup(), getVds());
    } else {
        Map<String, String> customLogValues = new HashMap<>();
        customLogValues.put("StoragePoolName", getStoragePoolName());
        if (problematicDomains != null && !problematicDomains.isEmpty()) {
            customLogValues.put("StorageDomainNames", StringUtils.join(Entities.objectNames(problematicDomains), ", "));
        }
        setNonOperational(NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, customLogValues);
        return false;
    }
    return true;
}
#end_block

#method_before
private void setNonOperational(NonOperationalReason reason, Map<String, String> customLogValues) {
    SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(getVds().getId(), reason, customLogValues);
    Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar, ExecutionHandler.createInternalJobContext());
}
#method_after
private void setNonOperational(NonOperationalReason reason, Map<String, String> customLogValues) {
    SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(getVds().getId(), reason, customLogValues);
    runInternalAction(VdcActionType.SetNonOperationalVds, tempVar, ExecutionHandler.createInternalJobContext());
}
#end_block

#method_before
private boolean InitializeStorage() {
    boolean returnValue = false;
    // connect any storage
    if (getStoragePool() == null || StoragePoolStatus.Uninitialized == getStoragePool().getStatus() || StoragePoolStatus.Maintenance == getStoragePool().getStatus()) {
        returnValue = true;
        connectPoolSucceeded = true;
    } else {
        ConnectHostToStoragePoolServersParameters params = new ConnectHostToStoragePoolServersParameters(getStoragePool(), getVds());
        Backend.getInstance().runInternalAction(VdcActionType.ConnectHostToStoragePoolServers, params);
        EventResult connectResult = connectHostToPool();
        returnValue = connectResult == null ? false : connectResult.isSuccess();
        connectPoolSucceeded = returnValue;
        if (!returnValue) {
            problematicDomains = (List<StorageDomainStatic>) connectResult.getResultData();
        }
    }
    return returnValue;
}
#method_after
private boolean InitializeStorage() {
    boolean returnValue = false;
    // connect any storage
    if (getStoragePool() == null || StoragePoolStatus.Uninitialized == getStoragePool().getStatus() || StoragePoolStatus.Maintenance == getStoragePool().getStatus()) {
        returnValue = true;
        connectPoolSucceeded = true;
    } else {
        ConnectHostToStoragePoolServersParameters params = new ConnectHostToStoragePoolServersParameters(getStoragePool(), getVds());
        runInternalAction(VdcActionType.ConnectHostToStoragePoolServers, params);
        EventResult connectResult = connectHostToPool();
        if (connectResult != null) {
            returnValue = connectResult.isSuccess();
            problematicDomains = (List<StorageDomainStatic>) connectResult.getResultData();
        }
        connectPoolSucceeded = returnValue;
    }
    return returnValue;
}
#end_block

#method_before
private EventResult processDomainRecovery(final Guid domainId) {
    EventResult result = null;
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<Guid>();
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAllForStoragePool(_storagePoolId);
    Map<Guid, VDS> vdsMap = new HashMap<Guid, VDS>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getStatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<Guid>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    final StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    List<Guid> nonOpVdss = new ArrayList<Guid>();
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.ImportExport && storageDomain.getStorageDomainType() != StorageDomainType.ISO) {
            // operational.
            for (final Guid vdsId : _domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warnFormat("vds {0} reported domain {1} - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getStatus() == VDSStatus.Up) {
                    log.warnFormat("vds {0} reported domain {1} as in problem, attempting to move the vds to status NonOperational", vds.getName(), domainIdTuple);
                    ThreadPoolUtil.execute(new Runnable() {

                        @Override
                        public void run() {
                            ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, domainId, Collections.singletonMap("storageDomainNames", storageDomain.getStorageName()));
                        }
                    });
                    nonOpVdss.add(vdsId);
                } else {
                    log.warnFormat("vds {0} reported domain {1} as in problem, vds is in status {3}, no need to move to nonoperational", vds.getName(), domainIdTuple, vds.getStatus());
                }
            }
        } else {
            log.warnFormat("Storage domain {0} is not visible to one or more hosts. " + "Since the domain's type is {1}, hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getStorageDomainType());
        }
        result = new EventResult(true, EventType.VDSSTOARGEPROBLEMS);
    } else {
        // Domain.
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            log.errorFormat("Domain {0} was reported by all hosts in status UP as problematic. Moving the domain to NonOperational.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
        } else {
            log.warnFormat("Domain {0} was reported by all hosts in status UP as problematic. Not moving the domain to NonOperational because it is being reconstructed now.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().masterDomainNotOperational(domainId, _storagePoolId, false, false);
        }
    }
    // clear from cache of _domainsInProblem
    clearDomainFromCache(domainId, nonOpVdss);
    return result;
}
#method_after
private EventResult processDomainRecovery(final Guid domainId) {
    EventResult result = null;
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<Guid>();
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAllForStoragePool(_storagePoolId);
    Map<Guid, VDS> vdsMap = new HashMap<Guid, VDS>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getStatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<Guid>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    final StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    List<Guid> nonOpVdss = new ArrayList<Guid>();
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.ImportExport && storageDomain.getStorageDomainType() != StorageDomainType.ISO) {
            // operational.
            for (final Guid vdsId : _domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warnFormat("vds {0} reported domain {1} - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getStatus() == VDSStatus.Up) {
                    log.warnFormat("vds {0} reported domain {1} as in problem, attempting to move the vds to status NonOperational", vds.getName(), domainIdTuple);
                    ThreadPoolUtil.execute(new Runnable() {

                        @Override
                        public void run() {
                            ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, domainId, Collections.singletonMap("StorageDomainNames", storageDomain.getStorageName()));
                        }
                    });
                    nonOpVdss.add(vdsId);
                } else {
                    log.warnFormat("vds {0} reported domain {1} as in problem, vds is in status {3}, no need to move to nonoperational", vds.getName(), domainIdTuple, vds.getStatus());
                }
            }
        } else {
            log.warnFormat("Storage domain {0} is not visible to one or more hosts. " + "Since the domain's type is {1}, hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getStorageDomainType());
        }
        result = new EventResult(true, EventType.VDSSTOARGEPROBLEMS);
    } else {
        // Domain.
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            log.errorFormat("Domain {0} was reported by all hosts in status UP as problematic. Moving the domain to NonOperational.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
        } else {
            log.warnFormat("Domain {0} was reported by all hosts in status UP as problematic. Not moving the domain to NonOperational because it is being reconstructed now.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().masterDomainNotOperational(domainId, _storagePoolId, false, false);
        }
    }
    // clear from cache of _domainsInProblem
    clearDomainFromCache(domainId, nonOpVdss);
    return result;
}
#end_block

#method_before
protected void endStepJobCommitted() {
    endStepJob(JobExecutionStatus.FINISHED, getStepMessageMap(JobExecutionStatus.FINISHED, " "), true);
}
#method_after
protected void endStepJobCommitted() {
    endStepJob(JobExecutionStatus.FINISHED, getStepMessageMap(JobExecutionStatus.FINISHED, null), true);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc connectStoragePool(String spUUID, int hostSpmId, String SCSIKey, String masterdomainId, int masterVersion) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.connectStoragePool(spUUID, hostSpmId, SCSIKey, masterdomainId, masterVersion);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc connectStoragePool(String spUUID, int hostSpmId, String SCSIKey, String masterdomainId, int masterVersion, Map<String, String> storageDomains) {
    try {
        Map<String, Object> xmlRpcReturnValue;
        if (storageDomains == null) {
            xmlRpcReturnValue = vdsServer.connectStoragePool(spUUID, hostSpmId, SCSIKey, masterdomainId, masterVersion);
        } else {
            xmlRpcReturnValue = vdsServer.connectStoragePool(spUUID, hostSpmId, SCSIKey, masterdomainId, masterVersion, storageDomains);
        }
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public GlusterVolumeProfileInfoReturnForXmlRpc glusterVolumeProfileInfo(Guid clusterId, String volumeName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeProfileInfo(volumeName);
        GlusterVolumeProfileInfoReturnForXmlRpc wrapper = new GlusterVolumeProfileInfoReturnForXmlRpc(clusterId, xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterVolumeProfileInfoReturnForXmlRpc glusterVolumeProfileInfo(Guid clusterId, String volumeName, boolean nfs) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeProfileInfo(volumeName, nfs);
        GlusterVolumeProfileInfoReturnForXmlRpc wrapper = new GlusterVolumeProfileInfoReturnForXmlRpc(clusterId, xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
protected void startSubStep() {
    asyncTaskStep = ExecutionHandler.addSubStep(this.getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), getStepType(), ExecutionMessageDirector.resolveStepMessage(getStepType(), getStepMessageMap(JobExecutionStatus.STARTED, " ")));
}
#method_after
protected void startSubStep() {
    asyncTaskStep = ExecutionHandler.addSubStep(this.getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), getStepType(), ExecutionMessageDirector.resolveStepMessage(getStepType(), getStepMessageMap(JobExecutionStatus.STARTED, null)));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnaValue = runVdsCommand(VDSCommandType.StopRebalanceGlusterVolume, new GlusterVolumeVDSParameters(upServer.getId(), getGlusterVolumeName()));
    if (!vdsReturnaValue.getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, vdsReturnaValue.getVdsError().getMessage());
        setSucceeded(false);
        return;
    }
    GlusterVolumeTaskStatusEntity rebalanceStatusEntity = (GlusterVolumeTaskStatusEntity) vdsReturnaValue.getReturnValue();
    JobExecutionStatus stepStatus = rebalanceStatusEntity.getStatusSummary().getStatus();
    if (stepStatus != null) {
        endStepJob(stepStatus, getStepMessageMap(stepStatus, GlusterTaskUtils.getInstance().getSummaryMessage(rebalanceStatusEntity.getStatusSummary())), GlusterTaskUtils.getInstance().isTaskSuccess(stepStatus));
    } else {
        endStepJob(JobExecutionStatus.ABORTED, getStepMessageMap(JobExecutionStatus.ABORTED, " "), false);
    }
    releaseVolumeLock();
    setSucceeded(vdsReturnaValue.getSucceeded());
    getReturnValue().setActionReturnValue(rebalanceStatusEntity);
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnaValue = runVdsCommand(VDSCommandType.StopRebalanceGlusterVolume, new GlusterVolumeVDSParameters(upServer.getId(), getGlusterVolumeName()));
    if (!vdsReturnaValue.getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, vdsReturnaValue.getVdsError().getMessage());
        setSucceeded(false);
        return;
    }
    GlusterVolumeTaskStatusEntity rebalanceStatusEntity = (GlusterVolumeTaskStatusEntity) vdsReturnaValue.getReturnValue();
    JobExecutionStatus stepStatus = rebalanceStatusEntity.getStatusSummary().getStatus();
    if (stepStatus != null) {
        endStepJob(stepStatus, getStepMessageMap(stepStatus, GlusterTaskUtils.getInstance().getSummaryMessage(rebalanceStatusEntity.getStatusSummary())), GlusterTaskUtils.getInstance().isTaskSuccess(stepStatus));
    } else {
        endStepJob(JobExecutionStatus.ABORTED, getStepMessageMap(JobExecutionStatus.ABORTED, null), false);
    }
    releaseVolumeLock();
    setSucceeded(vdsReturnaValue.getSucceeded());
    getReturnValue().setActionReturnValue(rebalanceStatusEntity);
}
#end_block

#method_before
@Override
public StorageDomain mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final StorageDomain entity = new StorageDomain();
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setStorage(rs.getString("storage"));
    entity.setStorageName(rs.getString("storage_name"));
    entity.setDescription(rs.getString("storage_description"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setComment(rs.getString("storage_comment"));
    entity.setStorageType(StorageType.forValue(rs.getInt("storage_type")));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setStorageDomainType(StorageDomainType.forValue(rs.getInt("storage_domain_type")));
    entity.setStorageFormat(StorageFormatType.forValue(rs.getString("storage_domain_format_type")));
    entity.setAvailableDiskSize((Integer) rs.getObject("available_disk_size"));
    entity.setUsedDiskSize((Integer) rs.getObject("used_disk_size"));
    entity.setActualImagesSize(rs.getInt("actual_images_size"));
    entity.setCommittedDiskSize(rs.getInt("commited_disk_size"));
    entity.setStatus(StorageDomainStatus.forValue(rs.getInt("status")));
    entity.setStorageDomainSharedStatus(StorageDomainSharedStatus.forValue(rs.getInt("storage_domain_shared_status")));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setLastTimeUsedAsMaster(rs.getLong("last_time_used_as_master"));
    return entity;
}
#method_after
@Override
public StorageDomain mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final StorageDomain entity = new StorageDomain();
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setStorage(rs.getString("storage"));
    entity.setStorageName(rs.getString("storage_name"));
    entity.setDescription(rs.getString("storage_description"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setComment(rs.getString("storage_comment"));
    entity.setStorageType(StorageType.forValue(rs.getInt("storage_type")));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setStorageDomainType(StorageDomainType.forValue(rs.getInt("storage_domain_type")));
    entity.setStorageFormat(StorageFormatType.forValue(rs.getString("storage_domain_format_type")));
    entity.setAvailableDiskSize((Integer) rs.getObject("available_disk_size"));
    entity.setUsedDiskSize((Integer) rs.getObject("used_disk_size"));
    entity.setActualImagesSize(rs.getInt("actual_images_size"));
    entity.setCommittedDiskSize(rs.getInt("commited_disk_size"));
    entity.setStatus(StorageDomainStatus.forValue(rs.getInt("status")));
    entity.setStorageDomainSharedStatus(StorageDomainSharedStatus.forValue(rs.getInt("storage_domain_shared_status")));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setContainsUnregisteredEntities(rs.getBoolean("contains_unregistered_entities"));
    entity.setLastTimeUsedAsMaster(rs.getLong("last_time_used_as_master"));
    return entity;
}
#end_block

#method_before
@Override
public long getNumberOfImagesInStorageDomain(Guid storageDomainId) {
    MapSqlParameterSource params = getCustomMapSqlParameterSource().addValue("storage_domain_id", storageDomainId);
    return getCallsHandler().executeRead("GetNumberOfImagesInStorageDomain", getLongMapper(), params);
}
#method_after
@Override
public long getNumberOfImagesInStorageDomain(Guid storageDomainId) {
    return getCallsHandler().executeRead("GetNumberOfImagesInStorageDomain", getLongMapper(), getCustomMapSqlParameterSource().addValue("storage_domain_id", storageDomainId));
}
#end_block

#method_before
public static void checkNumberOfLVsForBlockDomain(Guid storageDomainId) {
    StorageDomainStatic domain = DbFacade.getInstance().getStorageDomainStaticDao().get(storageDomainId);
    if (domain.getStorageType().isBlockDomain()) {
        long numOfLVs = DbFacade.getInstance().getStorageDomainDao().getNumberOfImagesInStorageDomain(storageDomainId);
        Integer maxNumOfLVs = Config.getValue(ConfigValues.AlertOnNumberOfLVs);
        if (numOfLVs >= maxNumOfLVs) {
            AuditLogableBase logable = new AuditLogableBase();
            logable.setStorageDomainId(storageDomainId);
            logable.addCustomValue("maxNumOfLVs", maxNumOfLVs.toString());
            AuditLogDirector.log(logable, AuditLogType.NUNBER_OF_LVS_ON_STORAGE_DOMAIN_EXCEEDED_THRESHOLD);
        }
    }
}
#method_after
public static void checkNumberOfLVsForBlockDomain(Guid storageDomainId) {
    StorageDomainStatic domain = DbFacade.getInstance().getStorageDomainStaticDao().get(storageDomainId);
    if (domain.getStorageType().isBlockDomain()) {
        long numOfLVs = DbFacade.getInstance().getStorageDomainDao().getNumberOfImagesInStorageDomain(storageDomainId);
        Integer maxNumOfLVs = Config.getValue(ConfigValues.AlertOnNumberOfLVs);
        if (numOfLVs >= maxNumOfLVs) {
            AuditLogableBase logable = new AuditLogableBase();
            logable.addCustomValue("storageDomainName", domain.getStorageName());
            logable.addCustomValue("maxNumOfLVs", maxNumOfLVs.toString());
            AuditLogDirector.log(logable, AuditLogType.NUNBER_OF_LVS_ON_STORAGE_DOMAIN_EXCEEDED_THRESHOLD);
        }
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("invokeCallbackMethods")
public synchronized void invokeCallbackMethods() {
    initCommandExecutor();
    for (Iterator<Guid> iterator = cmdCallBackMap.keySet().iterator(); iterator.hasNext(); ) {
        Guid cmdId = iterator.next();
        CommandCallBack callBack = cmdCallBackMap.get(cmdId);
        CommandStatus status = coco.getCommandStatus(cmdId);
        switch(status) {
            case FAILED:
                callBack.onFailed(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case SUCCEEDED:
                callBack.onSucceeded(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case ACTIVE_SYNC:
                coco.retrieveCommand(cmdId).setCommandStatus(CommandStatus.FAILED_RESTARTED);
                break;
            case ACTIVE:
            case ACTIVE_ASYNC:
                callBack.doPolling(cmdId, coco.getChildCommandIds(cmdId));
                break;
            default:
                break;
        }
    }
}
#method_after
@OnTimerMethodAnnotation("invokeCallbackMethods")
public synchronized void invokeCallbackMethods() {
    initCommandExecutor();
    for (Iterator<Entry<Guid, CommandCallBack>> iterator = cmdCallBackMap.entrySet().iterator(); iterator.hasNext(); ) {
        Entry<Guid, CommandCallBack> entry = iterator.next();
        Guid cmdId = entry.getKey();
        CommandCallBack callBack = entry.getValue();
        CommandStatus status = coco.getCommandStatus(cmdId);
        switch(status) {
            case FAILED:
                callBack.onFailed(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case SUCCEEDED:
                callBack.onSucceeded(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case ACTIVE_SYNC:
                coco.retrieveCommand(cmdId).setCommandStatus(CommandStatus.FAILED_RESTARTED);
                break;
            case ACTIVE:
            case ACTIVE_ASYNC:
                callBack.doPolling(cmdId, coco.getChildCommandIds(cmdId));
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
public void proceedCommandExecution() {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE);
        getParameters().setChildCommands(new HashMap<RemoveSnapshotSingleDiskLiveStep, Guid>());
    }
    List<Guid> childCommandIds = TaskManagerUtil.getChildCommandIds(getCommandId());
    if (childCommandIds.size() != getParameters().getChildCommands().size()) {
        // Upon recovery or after invoking a new child command, our map may be missing an entry
        for (Guid id : childCommandIds) {
            if (!getParameters().getChildCommands().containsValue(id)) {
                getParameters().getChildCommands().put(getParameters().getCommandStep(), id);
                break;
            }
        }
    }
    Guid currentChildId = getParameters().getChildCommands().get(getParameters().getCommandStep());
    VdcReturnValueBase vdcReturnValue = null;
    if (currentChildId != null) {
        switch(TaskManagerUtil.getCommandStatus(currentChildId)) {
            case ACTIVE:
            case ACTIVE_ASYNC:
            case ACTIVE_SYNC:
            case NOT_STARTED:
                log.infoFormat("Waiting on Live Merge command step {0} to complete", getParameters().getCommandStep());
                return;
            case SUCCEEDED:
                vdcReturnValue = TaskManagerUtil.getCommandReturnValue(currentChildId);
                if (vdcReturnValue != null && vdcReturnValue.getSucceeded()) {
                    getParameters().setCommandStep(getParameters().getNextCommandStep());
                    break;
                } else {
                    log.errorFormat("Failed to merge, child command {0} failed: {1}", getParameters().getCommandStep(), (vdcReturnValue != null ? vdcReturnValue.getExecuteFailedMessages() : "null return value"));
                    setCommandStatus(CommandStatus.FAILED);
                    return;
                }
            case FAILED:
            case FAILED_RESTARTED:
                log.errorFormat("Failed to merge: failed child command status for step {0}", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
            case UNKNOWN:
                log.errorFormat("Failed to merge: unknown child command status for step {0}", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
        }
    }
    log.infoFormat("Executing Live Merge command step {0}", getParameters().getCommandStep());
    Pair<VdcActionType, VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case MERGE:
            nextCommand = new Pair<VdcActionType, VdcActionParametersBase>(VdcActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<VdcActionType, VdcActionParametersBase>(VdcActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            getParameters().setMergeStatusReturnValue((MergeStatusReturnValue) vdcReturnValue.getActionReturnValue());
            nextCommand = new Pair<VdcActionType, VdcActionParametersBase>(VdcActionType.DestroyImage, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        TaskManagerUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond());
    }
}
#method_after
public void proceedCommandExecution() {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE);
        getParameters().setChildCommands(new HashMap<RemoveSnapshotSingleDiskLiveStep, Guid>());
    }
    List<Guid> childCommandIds = TaskManagerUtil.getChildCommandIds(getCommandId());
    if (childCommandIds.size() != getParameters().getChildCommands().size()) {
        // Upon recovery or after invoking a new child command, our map may be missing an entry
        for (Guid id : childCommandIds) {
            if (!getParameters().getChildCommands().containsValue(id)) {
                getParameters().getChildCommands().put(getParameters().getCommandStep(), id);
                break;
            }
        }
    }
    Guid currentChildId = getParameters().getChildCommands().get(getParameters().getCommandStep());
    VdcReturnValueBase vdcReturnValue = null;
    if (currentChildId != null) {
        switch(TaskManagerUtil.getCommandStatus(currentChildId)) {
            case ACTIVE:
            case ACTIVE_ASYNC:
            case ACTIVE_SYNC:
            case NOT_STARTED:
                log.infoFormat("Waiting on Live Merge command step {0} to complete", getParameters().getCommandStep());
                return;
            case SUCCEEDED:
                vdcReturnValue = TaskManagerUtil.getCommandReturnValue(currentChildId);
                if (vdcReturnValue != null && vdcReturnValue.getSucceeded()) {
                    getParameters().setCommandStep(getParameters().getNextCommandStep());
                    break;
                } else {
                    log.errorFormat("Failed to merge, child command {0} failed: {1}", getParameters().getCommandStep(), (vdcReturnValue != null ? vdcReturnValue.getExecuteFailedMessages() : "null return value"));
                    setCommandStatus(CommandStatus.FAILED);
                    return;
                }
            case FAILED:
            case FAILED_RESTARTED:
                log.errorFormat("Failed to merge: failed child command status for step {0}", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
            case UNKNOWN:
                log.errorFormat("Failed to merge: unknown child command status for step {0}", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
        }
    }
    log.infoFormat("Executing Live Merge command step {0}", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<>(VdcActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            getParameters().setMergeStatusReturnValue((MergeStatusReturnValue) vdcReturnValue.getActionReturnValue());
            nextCommand = new Pair<>(VdcActionType.DestroyImage, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        TaskManagerUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond());
    }
}
#end_block

#method_before
private void startHostsWithPMInReboot(List<VDS> hosts) {
    final List<VDS> hostsWithPMInReboot = LinqUtils.filter(hosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS host) {
            return (host.getpm_enabled() && host.getStatus() == VDSStatus.Reboot);
        }
    });
    if (hostsWithPMInReboot.size() > 0) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                // wait the quiet time from engine start in which we skip fencing operations
                int mSecToWait = Config.<Integer>getValue(ConfigValues.DisableFenceAtStartupInSec) * 1000;
                ThreadUtils.sleep(mSecToWait);
                startHosts(hostsWithPMInReboot);
            }
        });
    }
}
#method_after
private void startHostsWithPMInReboot(List<VDS> hosts) {
    final List<VDS> hostsWithPMInReboot = LinqUtils.filter(hosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS host) {
            return (host.getpm_enabled() && host.getStatus() == VDSStatus.Reboot);
        }
    });
    if (hostsWithPMInReboot.size() > 0) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                waitUntilFencingAllowed();
                startHosts(hostsWithPMInReboot);
            }
        });
    }
}
#end_block

#method_before
private void recoverKdumpingHosts(List<VDS> hosts) {
    final List<VDS> kdumpingHosts = new ArrayList<>();
    for (VDS host : hosts) {
        if (host.getStatus() == VDSStatus.Kdumping) {
            kdumpingHosts.add(host);
        }
    }
    if (!kdumpingHosts.isEmpty()) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                // wait the quiet time from engine start in which we skip fencing operations
                int mSecToWait = Config.<Integer>getValue(ConfigValues.DisableFenceAtStartupInSec) * 1000;
                ThreadUtils.sleep(mSecToWait);
                executeNotRespondingTreatment(kdumpingHosts);
            }
        });
    }
}
#method_after
private void recoverKdumpingHosts(List<VDS> hosts) {
    final List<VDS> kdumpingHosts = new ArrayList<>();
    for (VDS host : hosts) {
        if (host.getStatus() == VDSStatus.Kdumping) {
            kdumpingHosts.add(host);
        }
    }
    if (!kdumpingHosts.isEmpty()) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                waitUntilFencingAllowed();
                executeNotRespondingTreatment(kdumpingHosts);
            }
        });
    }
}
#end_block

#method_before
private void registerHandlers() {
    addMouseOverHandler(new MouseOverHandler() {

        @Override
        public void onMouseOver(MouseOverEvent event) {
            if (!"".equals(title)) {
                // $NON-NLS-1$
                tooltip.setHTML(title);
                tooltipPanel.showRelativeTo(LabelWithToolTip.this);
            }
        }
    });
    addMouseOutHandler(new MouseOutHandler() {

        @Override
        public void onMouseOut(MouseOutEvent event) {
            tooltipPanel.hide(true);
        }
    });
}
#method_after
private void registerHandlers() {
    addMouseOverHandler(new MouseOverHandler() {

        @Override
        public void onMouseOver(MouseOverEvent event) {
            if (StringUtils.isEmpty(title)) {
                tooltip.setHTML(title);
                tooltipPanel.showRelativeTo(LabelWithToolTip.this);
            }
        }
    });
    addMouseOutHandler(new MouseOutHandler() {

        @Override
        public void onMouseOut(MouseOutEvent event) {
            tooltipPanel.hide(true);
        }
    });
}
#end_block

#method_before
public void setTitle(SafeHtml text) {
    // If text is null, then don't do anything.
    if (text != null) {
        setText(text.asString());
    }
}
#method_after
public void setTitle(SafeHtml text) {
    setTitle(text == null ? (String) null : text.asString());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setVdsGroupId(targetClusterId);
            DbFacade.getInstance().getVdsStaticDao().update(staticData);
            getCompensationContext().stateChanged();
            // remove the server from resource manager and add it back
            initializeVds();
            return null;
        }
    });
    if (targetStoragePool != null && (getSourceCluster().getStoragePoolId() == null || !targetStoragePool.getId().equals(getSourceCluster().getStoragePoolId()))) {
        VdsActionParameters addVdsSpmIdParams = new VdsActionParameters(getVdsIdRef());
        addVdsSpmIdParams.setSessionId(getParameters().getSessionId());
        addVdsSpmIdParams.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, addVdsSpmIdParams, new CommandContext(getCompensationContext()));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (getSourceCluster().supportsGlusterService() && getClusterUtils().hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && getClusterUtils().hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getSourceCluster().getStoragePoolId() != null && (targetStoragePool == null || !getSourceCluster().getStoragePoolId().equals(targetStoragePool.getId()))) {
        getVdsSpmIdMapDAO().removeByVdsAndStoragePool(getVds().getId(), getSourceCluster().getStoragePoolId());
    }
    if (targetClusterSupportsSetupNetworks()) {
        configureNetworks();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setVdsGroupId(targetClusterId);
            DbFacade.getInstance().getVdsStaticDao().update(staticData);
            getCompensationContext().stateChanged();
            // remove the server from resource manager and add it back
            initializeVds();
            return null;
        }
    });
    if (targetStoragePool != null && (getSourceCluster().getStoragePoolId() == null || !targetStoragePool.getId().equals(getSourceCluster().getStoragePoolId()))) {
        VdsActionParameters addVdsSpmIdParams = new VdsActionParameters(getVdsIdRef());
        addVdsSpmIdParams.setSessionId(getParameters().getSessionId());
        addVdsSpmIdParams.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, addVdsSpmIdParams, new CommandContext(getCompensationContext()));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (getSourceCluster().supportsGlusterService() && getClusterUtils().hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && getClusterUtils().hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getSourceCluster().getStoragePoolId() != null && (targetStoragePool == null || !getSourceCluster().getStoragePoolId().equals(targetStoragePool.getId()))) {
        getVdsSpmIdMapDAO().removeByVdsAndStoragePool(getVds().getId(), getSourceCluster().getStoragePoolId());
    }
    if (targetClusterSupportsSetupNetworks()) {
        configureNetworks();
    }
    setSucceeded(true);
}
#end_block

#method_before
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getVm().getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
private void endDefaultOperations() {
    endUnlockOps();
    // in case of new version of a template, update vms marked to use latest
    if (isTemplateVersion()) {
        String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "onTimerHandleVdsRecovering", new Class[0], new Object[0], 0, TimeUnit.SECONDS);
        updateVmsJobIdMap.put(getParameters().getBaseTemplateId(), jobId);
    }
}
#method_after
private void endDefaultOperations() {
    endUnlockOps();
    // in case of new version of a template, update vms marked to use latest
    if (isTemplateVersion()) {
        String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "updateVmVersion", new Class[0], new Object[0], 0, TimeUnit.SECONDS);
        updateVmsJobIdMap.put(getParameters().getBaseTemplateId(), jobId);
    }
}
#end_block

#method_before
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.getSupportedRngSources().clear();
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.calculateFreeVirtualMemory();
    return entity;
}
#method_after
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.calculateFreeVirtualMemory();
    entity.setBootTime((Long) rs.getObject("boot_time"));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    return entity;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getVdsGroup().setArchitecture(getArchitecture());
    checkMaxMemoryOverCommitValue();
    getVdsGroup().setDetectEmulatedMachine(true);
    DbFacade.getInstance().getVdsGroupDao().save(getVdsGroup());
    // add default network
    if (getParameters().getVdsGroup().getStoragePoolId() != null) {
        final String networkName = NetworkUtils.getEngineNetwork();
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForDataCenter(getParameters().getVdsGroup().getStoragePoolId());
        Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network network) {
                return network.getName().equals(networkName);
            }
        });
        if (net != null) {
            DbFacade.getInstance().getNetworkClusterDao().save(new NetworkCluster(getParameters().getVdsGroup().getId(), net.getId(), NetworkStatus.OPERATIONAL, false, true, false));
        }
    }
    setActionReturnValue(getVdsGroup().getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getVdsGroup().setArchitecture(getArchitecture());
    checkMaxMemoryOverCommitValue();
    getVdsGroup().setDetectEmulatedMachine(true);
    DbFacade.getInstance().getVdsGroupDao().save(getVdsGroup());
    // add default network
    if (getParameters().getVdsGroup().getStoragePoolId() != null) {
        final String networkName = NetworkUtils.getEngineNetwork();
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForDataCenter(getParameters().getVdsGroup().getStoragePoolId());
        Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network network) {
                return network.getName().equals(networkName);
            }
        });
        if (net != null) {
            DbFacade.getInstance().getNetworkClusterDao().save(new NetworkCluster(getParameters().getVdsGroup().getId(), net.getId(), NetworkStatus.OPERATIONAL, true, true, true));
        }
    }
    setActionReturnValue(getVdsGroup().getId());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getRngDevices().isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_NOT_FOUND);
    }
    if (!isRngSourceCompatibleWithCluster()) {
        VmRngDevice device = getParameters().getRngDevice();
        log.infoFormat("RNG Device id: %s of VM id: %s  is no more compatible with cluster. Removing the device.", device.getId(), device.getVmId());
        Backend.getInstance().runAction(VdcActionType.RemoveRngDevice, getParameters());
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (!isRngSupportedByCluster()) {
        return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (getRngDevices().isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_NOT_FOUND);
    }
    return true;
}
#end_block

#method_before
public static String migrationMethodtoString(MigrationMethod method) {
    if (method == MigrationMethod.OFFLINE) {
        return offline;
    } else if (method == MigrationMethod.ONLINE) {
        return online;
    } else {
        return "";
    }
}
#method_after
public static String migrationMethodtoString(MigrationMethod method) {
    switch(method) {
        case OFFLINE:
            return offline;
        case ONLINE:
            return online;
        default:
            return "";
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getVdsGroup().setArchitecture(getArchitecture());
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldGroup.getcompatibility_version(), getParameters().getVdsGroup().getcompatibility_version())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed the canDo.
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = ListUtils.firstMatch(Config.<List<String>>getValue(ConfigValues.ClusterEmulatedMachines, getParameters().getVdsGroup().getcompatibility_version().getValue()), vds.getSupportedEmulatedMachines().split(","));
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        } else {
            getParameters().getVdsGroup().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldGroup.getArchitecture() != getVdsGroup().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        getParameters().getVdsGroup().setEmulatedMachine(null);
    }
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    if ((oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) || (oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null)) {
        for (VDS vds : allForVdsGroup) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = getBackend().runInternalAction(VdcActionType.AddVdsSpmId, parameters);
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        if (oldGroup.getStoragePoolId() != null) {
            for (VDS vds : allForVdsGroup) {
                getVdsSpmIdMapDAO().removeByVdsAndStoragePool(vds.getId(), oldGroup.getStoragePoolId());
            }
        }
    }
    // when changing data center we check that default networks exists in
    // cluster
    List<Network> networks = getNetworkDAO().getAllForCluster(getVdsGroup().getId());
    boolean exists = false;
    String managementNetwork = NetworkUtils.getEngineNetwork();
    for (Network net : networks) {
        if (StringUtils.equals(net.getName(), managementNetwork)) {
            exists = true;
        }
    }
    if (!exists) {
        if (getVdsGroup().getStoragePoolId() != null) {
            List<Network> storagePoolNets = getNetworkDAO().getAllForDataCenter(getVdsGroup().getStoragePoolId());
            for (Network net : storagePoolNets) {
                if (StringUtils.equals(net.getName(), managementNetwork)) {
                    getNetworkClusterDAO().save(new NetworkCluster(getVdsGroup().getId(), net.getId(), NetworkStatus.OPERATIONAL, true, true, false));
                }
            }
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getVdsGroup().setArchitecture(getArchitecture());
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldGroup.getcompatibility_version(), getParameters().getVdsGroup().getcompatibility_version())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed the canDo.
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = ListUtils.firstMatch(Config.<List<String>>getValue(ConfigValues.ClusterEmulatedMachines, getParameters().getVdsGroup().getcompatibility_version().getValue()), vds.getSupportedEmulatedMachines().split(","));
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        } else {
            getParameters().getVdsGroup().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldGroup.getArchitecture() != getVdsGroup().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        getParameters().getVdsGroup().setEmulatedMachine(null);
    }
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    if ((oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) || (oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null)) {
        for (VDS vds : allForVdsGroup) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = getBackend().runInternalAction(VdcActionType.AddVdsSpmId, parameters);
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        if (oldGroup.getStoragePoolId() != null) {
            for (VDS vds : allForVdsGroup) {
                getVdsSpmIdMapDAO().removeByVdsAndStoragePool(vds.getId(), oldGroup.getStoragePoolId());
            }
        }
    }
    // when changing data center we check that default networks exists in
    // cluster
    List<Network> networks = getNetworkDAO().getAllForCluster(getVdsGroup().getId());
    boolean exists = false;
    String managementNetwork = NetworkUtils.getEngineNetwork();
    for (Network net : networks) {
        if (StringUtils.equals(net.getName(), managementNetwork)) {
            exists = true;
        }
    }
    if (!exists) {
        if (getVdsGroup().getStoragePoolId() != null) {
            List<Network> storagePoolNets = getNetworkDAO().getAllForDataCenter(getVdsGroup().getStoragePoolId());
            for (Network net : storagePoolNets) {
                if (StringUtils.equals(net.getName(), managementNetwork)) {
                    getNetworkClusterDAO().save(new NetworkCluster(getVdsGroup().getId(), net.getId(), NetworkStatus.OPERATIONAL, true, true, true));
                }
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    List<VM> vmList = null;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        if (!isVdsGroupUnique(getVdsGroup().getName())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    // decreasing of compatibility version is not allowed
    if (result && getVdsGroup().getcompatibility_version().compareTo(oldGroup.getcompatibility_version()) < 0) {
        result = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION.toString());
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getcpu_name() != null || getVdsGroup().getcpu_name() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getcpu_name()) && !checkIfCpusSameManufacture(oldGroup) && !allForVdsGroup.isEmpty()) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDAO().getAllForVdsGroup(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForVdsGroup.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getVdsGroup().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getcpu_name(), getVdsGroup().getcpu_name());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getcpu_name());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<VDS>();
        boolean isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getcompatibility_version(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        AuditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDAO().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID).equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().getcompatibility_version() != null && Version.v3_3.compareTo(getVdsGroup().getcompatibility_version()) > 0 && getVdsGroup().isEnableBallooning()) {
        // Members of pre-3.3 clusters don't support ballooning; here we act like a 3.2 engine
        addCanDoActionMessage(VdcBllMessages.QOS_BALLOON_NOT_SUPPORTED);
        result = false;
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VdcBllMessages.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessage(String.format("$compatibilityVersion %1$s", getVdsGroup().getcompatibility_version().getValue()));
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getVdsGroup().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result) {
        result = validateClusterPolicy();
    }
    // non-empty required sources list and rng-unsupported cluster version
    if (result && !getVdsGroup().getRequiredRngSources().isEmpty() && !FeatureSupported.virtIoRngSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
        result = false;
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        if (!isVdsGroupUnique(getVdsGroup().getName())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getVdsGroup().getcompatibility_version().compareTo(oldGroup.getcompatibility_version()) < 0) {
        if (!allForVdsGroup.isEmpty()) {
            result = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            StoragePool storagePool = getStoragePoolDAO().get(oldGroup.getStoragePoolId());
            if (storagePool != null && getVdsGroup().getcompatibility_version().compareTo(storagePool.getcompatibility_version()) < 0) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForVdsGroup);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getcpu_name() != null || getVdsGroup().getcpu_name() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getcpu_name()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDAO().getAllForVdsGroup(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForVdsGroup.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getVdsGroup().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getcpu_name(), getVdsGroup().getcpu_name());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getcpu_name());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<VDS>();
        boolean isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getcompatibility_version(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        AuditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDAO().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID).equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().getcompatibility_version() != null && Version.v3_3.compareTo(getVdsGroup().getcompatibility_version()) > 0 && getVdsGroup().isEnableBallooning()) {
        // Members of pre-3.3 clusters don't support ballooning; here we act like a 3.2 engine
        addCanDoActionMessage(VdcBllMessages.QOS_BALLOON_NOT_SUPPORTED);
        result = false;
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VdcBllMessages.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessage(String.format("$compatibilityVersion %1$s", getVdsGroup().getcompatibility_version().getValue()));
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getVdsGroup().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result) {
        result = validateClusterPolicy();
    }
    // non-empty required sources list and rng-unsupported cluster version
    if (result && !getVdsGroup().getRequiredRngSources().isEmpty() && !FeatureSupported.virtIoRngSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
        result = false;
    }
    return result;
}
#end_block

#method_before
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.errorFormat("vm session value illegal : {0}", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_port)) {
        try {
            vm.setDisplay(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.display)) {
        try {
            vm.setDisplay(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.get(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display value illegal : {0}", xmlRpcStruct.get(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_secure_port)) {
        try {
            vm.setDisplaySecurePort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_secure_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayType))) {
        String displayType = xmlRpcStruct.get(VdsProperties.displayType).toString();
        try {
            vm.setDisplayType(DisplayType.valueOf(displayType));
        } catch (Exception e2) {
            log.errorFormat("vm display type value illegal : {0}", displayType);
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayIp))) {
        vm.setDisplayIp((String) xmlRpcStruct.get(VdsProperties.displayIp));
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.errorFormat("vm offset (utc_diff) value illegal : {0}", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.errorFormat("vm hash value illegal : {0}", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    } else {
        vm.setCurrentCd(null);
    }
}
#method_after
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.errorFormat("vm session value illegal : {0}", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_port)) {
        try {
            vm.setDisplay(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.display)) {
        try {
            vm.setDisplay(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.get(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display value illegal : {0}", xmlRpcStruct.get(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_secure_port)) {
        try {
            vm.setDisplaySecurePort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_secure_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayType))) {
        String displayType = xmlRpcStruct.get(VdsProperties.displayType).toString();
        try {
            vm.setDisplayType(DisplayType.valueOf(displayType));
        } catch (Exception e2) {
            log.errorFormat("vm display type value illegal : {0}", displayType);
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayIp))) {
        vm.setDisplayIp((String) xmlRpcStruct.get(VdsProperties.displayIp));
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.errorFormat("vm offset (utc_diff) value illegal : {0}", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.errorFormat("vm hash value illegal : {0}", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    } else {
        vm.setExitReason(VmExitReason.Unknown);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(AssignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
}
#end_block

#method_before
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setelapsed_time(AssignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK)) {
        Map networkStruct = (Map) xmlRpcStruct.get(VdsProperties.VM_NETWORK);
        vm.setInterfaceStatistics(new ArrayList<VmNetworkInterface>());
        for (Object tempNic : networkStruct.values()) {
            Map nic = (Map) tempNic;
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            Double rx_rate = AssignDoubleValue(nic, VdsProperties.rx_rate);
            Double rx_dropped = AssignDoubleValue(nic, VdsProperties.rx_dropped);
            Double tx_rate = AssignDoubleValue(nic, VdsProperties.tx_rate);
            Double tx_dropped = AssignDoubleValue(nic, VdsProperties.tx_dropped);
            stats.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
            stats.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
            stats.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
            stats.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
            stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
            stats.setSpeed(AssignIntValue(nic, VdsProperties.INTERFACE_SPEED));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setcpu_sys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setcpu_user(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setusage_mem_percent(AssignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    vm.setVmBalloonInfo(getBalloonInfo(xmlRpcStruct));
}
#method_after
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setelapsed_time(AssignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK)) {
        Map networkStruct = (Map) xmlRpcStruct.get(VdsProperties.VM_NETWORK);
        vm.setInterfaceStatistics(new ArrayList<VmNetworkInterface>());
        for (Object tempNic : networkStruct.values()) {
            Map nic = (Map) tempNic;
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            Double rx_rate = AssignDoubleValue(nic, VdsProperties.rx_rate);
            Double rx_dropped = AssignDoubleValue(nic, VdsProperties.rx_dropped);
            Double tx_rate = AssignDoubleValue(nic, VdsProperties.tx_rate);
            Double tx_dropped = AssignDoubleValue(nic, VdsProperties.tx_dropped);
            stats.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
            stats.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
            stats.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
            stats.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
            stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
            stats.setSpeed(AssignIntValue(nic, VdsProperties.INTERFACE_SPEED));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setcpu_sys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setcpu_user(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setusage_mem_percent(AssignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    vm.setVmBalloonInfo(getBalloonInfo(xmlRpcStruct));
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = AssignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    vds.getSupportedRngSources().clear();
    vds.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.rngSources)));
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(AssignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(AssignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface iface = nicsByName.get(entry.getKey());
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
}
#end_block

#method_before
public static void updateNetworkData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setActiveNic(AssignStringValue(xmlRpcStruct, VdsProperties.NETWORK_LAST_CLIENT_INTERFACE));
    List<VdsNetworkInterface> oldInterfaces = DbFacade.getInstance().getInterfaceDao().getAllInterfacesForVds(vds.getId());
    vds.getInterfaces().clear();
    addHostNetworkInterfaces(vds, xmlRpcStruct);
    Map<String, Integer> currVlans = addHostVlanDevices(vds, xmlRpcStruct);
    addHostBondDevices(vds, xmlRpcStruct);
    addHostNetworksAndUpdateInterfaces(vds, xmlRpcStruct, currVlans);
    // set bonding options
    setBondingOptions(vds, oldInterfaces);
    // This information was added in 3.1, so don't use it if it's not there.
    if (xmlRpcStruct.containsKey(VdsProperties.netConfigDirty)) {
        vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    }
}
#method_after
public static void updateNetworkData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setActiveNic(AssignStringValue(xmlRpcStruct, VdsProperties.NETWORK_LAST_CLIENT_INTERFACE));
    List<VdsNetworkInterface> oldInterfaces = DbFacade.getInstance().getInterfaceDao().getAllInterfacesForVds(vds.getId());
    vds.getInterfaces().clear();
    addHostNetworkInterfaces(vds, xmlRpcStruct);
    addHostVlanDevices(vds, xmlRpcStruct);
    addHostBondDevices(vds, xmlRpcStruct);
    addHostNetworksAndUpdateInterfaces(vds, xmlRpcStruct);
    // set bonding options
    setBondingOptions(vds, oldInterfaces);
    // This information was added in 3.1, so don't use it if it's not there.
    if (xmlRpcStruct.containsKey(VdsProperties.netConfigDirty)) {
        vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    }
}
#end_block

#method_before
private static void addHostNetworksAndUpdateInterfaces(VDS vds, Map<String, Object> xmlRpcStruct, Map<String, Integer> currVlans) {
    Map<String, Integer> networkVlans = new HashMap<String, Integer>();
    // Networks collection (name point to list of nics or bonds)
    Map<String, Object> networks = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    if (networks != null) {
        vds.getNetworks().clear();
        for (Entry<String, Object> entry : networks.entrySet()) {
            Map<String, Object> network = (Map<String, Object>) entry.getValue();
            if (network != null) {
                Network net = createNetworkData(entry.getKey(), network);
                List<VdsNetworkInterface> interfaces = findNetworkInterfaces(vds, xmlRpcStruct, network);
                for (VdsNetworkInterface iface : interfaces) {
                    updateNetworkDetailsInInterface(iface, currVlans, networkVlans, network, vds, net);
                }
                vds.getNetworks().add(net);
                reportInvalidInterfacesForNetwork(interfaces, net, vds);
            }
        }
    }
}
#method_after
private static void addHostNetworksAndUpdateInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    // Networks collection (name point to list of nics or bonds)
    Map<String, Object> networks = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    if (networks != null) {
        vds.getNetworks().clear();
        for (Entry<String, Object> entry : networks.entrySet()) {
            Map<String, Object> network = (Map<String, Object>) entry.getValue();
            if (network != null) {
                Network net = createNetworkData(entry.getKey(), network);
                List<VdsNetworkInterface> interfaces = findNetworkInterfaces(vds, xmlRpcStruct, network);
                for (VdsNetworkInterface iface : interfaces) {
                    updateNetworkDetailsInInterface(iface, network, vds, net);
                }
                vds.getNetworks().add(net);
                reportInvalidInterfacesForNetwork(interfaces, net, vds);
            }
        }
    }
}
#end_block

#method_before
private static Map<String, Integer> addHostVlanDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    // interface to vlan map
    Map<String, Integer> currVlans = new HashMap<String, Integer>();
    // vlans
    Map<String, Object> vlans = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_VLANS);
    if (vlans != null) {
        for (Entry<String, Object> entry : vlans.entrySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.newGuid());
            iface.setId(iStats.getId());
            String vlanDeviceName = entry.getKey();
            iface.setName(vlanDeviceName);
            iface.setVdsId(vds.getId());
            if (vlanDeviceName.contains(".")) {
                String[] names = vlanDeviceName.split("[.]", -1);
                String vlan = names[1];
                iface.setVlanId(Integer.parseInt(vlan));
                currVlans.put(vlanDeviceName, iface.getVlanId());
            }
            Map<String, Object> vlan = (Map<String, Object>) entry.getValue();
            iface.setAddress((String) vlan.get("addr"));
            iface.setSubnet((String) vlan.get("netmask"));
            if (StringUtils.isNotBlank((String) vlan.get(VdsProperties.MTU))) {
                iface.setMtu(Integer.parseInt((String) vlan.get(VdsProperties.MTU)));
            }
            iStats.setVdsId(vds.getId());
            addBootProtocol((Map<String, Object>) vlan.get("cfg"), vds, iface);
            vds.getInterfaces().add(iface);
        }
    }
    return currVlans;
}
#method_after
private static void addHostVlanDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    // vlans
    Map<String, Object> vlans = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_VLANS);
    if (vlans != null) {
        for (Entry<String, Object> entry : vlans.entrySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.newGuid());
            iface.setId(iStats.getId());
            String vlanDeviceName = entry.getKey();
            iface.setName(vlanDeviceName);
            iface.setVdsId(vds.getId());
            Map<String, Object> vlan = (Map<String, Object>) entry.getValue();
            if (vlan.get(VdsProperties.VLAN_ID) != null && vlan.get(VdsProperties.BASE_INTERFACE) != null) {
                iface.setVlanId((Integer) vlan.get(VdsProperties.VLAN_ID));
                iface.setBaseInterface((String) vlan.get(VdsProperties.BASE_INTERFACE));
            } else if (vlanDeviceName.contains(".")) {
                String[] names = vlanDeviceName.split("[.]", -1);
                String vlanId = names[1];
                iface.setVlanId(Integer.parseInt(vlanId));
                iface.setBaseInterface(names[0]);
            }
            iface.setAddress((String) vlan.get("addr"));
            iface.setSubnet((String) vlan.get("netmask"));
            if (StringUtils.isNotBlank((String) vlan.get(VdsProperties.MTU))) {
                iface.setMtu(Integer.parseInt((String) vlan.get(VdsProperties.MTU)));
            }
            iStats.setVdsId(vds.getId());
            addBootProtocol((Map<String, Object>) vlan.get("cfg"), vds, iface);
            vds.getInterfaces().add(iface);
        }
    }
}
#end_block

#method_before
private static void updateNetworkDetailsInInterface(VdsNetworkInterface iface, Map<String, Integer> currVlans, Map<String, Integer> networkVlans, Map<String, Object> network, VDS host, Network net) {
    if (iface != null) {
        iface.setNetworkName(net.getName());
        if (currVlans.containsKey(iface.getName())) {
            networkVlans.put(net.getName(), currVlans.get(iface.getName()));
        }
        // set the management ip
        if (StringUtils.equals(iface.getNetworkName(), NetworkUtils.getEngineNetwork())) {
            iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
        }
        iface.setAddress(net.getAddr());
        iface.setSubnet(net.getSubnet());
        boolean bridgedNetwork = isBridgedNetwork(network);
        iface.setBridged(bridgedNetwork);
        setGatewayIfNecessary(iface, host, net.getGateway());
        if (bridgedNetwork) {
            Map<String, Object> networkConfig = (Map<String, Object>) network.get("cfg");
            addBootProtocol(networkConfig, host, iface);
        }
        if (FeatureSupported.hostNetworkQos(Collections.max(host.getSupportedClusterVersionsSet()))) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(network, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            iface.setQos(qosMapper.deserialize());
        }
    }
}
#method_after
private static void updateNetworkDetailsInInterface(VdsNetworkInterface iface, Map<String, Object> network, VDS host, Network net) {
    if (iface != null) {
        iface.setNetworkName(net.getName());
        // set the management ip
        if (StringUtils.equals(iface.getNetworkName(), NetworkUtils.getEngineNetwork())) {
            iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
        }
        iface.setAddress(net.getAddr());
        iface.setSubnet(net.getSubnet());
        boolean bridgedNetwork = isBridgedNetwork(network);
        iface.setBridged(bridgedNetwork);
        setGatewayIfNecessary(iface, host, net.getGateway());
        if (bridgedNetwork) {
            Map<String, Object> networkConfig = (Map<String, Object>) network.get("cfg");
            addBootProtocol(networkConfig, host, iface);
        }
        if (FeatureSupported.hostNetworkQos(Collections.max(host.getSupportedClusterVersionsSet()))) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(network, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            iface.setQos(qosMapper.deserialize());
        }
    }
}
#end_block

#method_before
@Override
public VdsDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VdsDynamic entity = new VdsDynamic();
    entity.setcpu_cores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setcpu_model(rs.getString("cpu_model"));
    entity.setcpu_speed_mh(rs.getDouble("cpu_speed_mh"));
    entity.setif_total_speed(rs.getString("if_total_speed"));
    entity.setkvm_enabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setmem_commited((Integer) rs.getObject("mem_commited"));
    entity.setphysical_mem_mb((Integer) rs.getObject("physical_mem_mb"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setvm_active((Integer) rs.getObject("vm_active"));
    entity.setvm_count(rs.getInt("vm_count"));
    entity.setvms_cores_count(rs.getInt("vms_cores_count"));
    entity.setvm_migrating((Integer) rs.getObject("vm_migrating"));
    entity.setreserved_mem((Integer) rs.getObject("reserved_mem"));
    entity.setguest_overhead(rs.getInt("guest_overhead"));
    entity.setsoftware_version(rs.getString("software_version"));
    entity.setversion_name(rs.getString("version_name"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setbuild_name(rs.getString("build_name"));
    entity.setprevious_status(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setcpu_flags(rs.getString("cpu_flags"));
    entity.setcpu_over_commit_time_stamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setpending_vcpus_count((Integer) rs.getObject("pending_vcpus_count"));
    entity.setpending_vmem_size(rs.getInt("pending_vmem_size"));
    entity.setcpu_sockets((Integer) rs.getObject("cpu_sockets"));
    entity.setnet_config_dirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setsupported_cluster_levels(rs.getString("supported_cluster_levels"));
    entity.setsupported_engines(rs.getString("supported_engines"));
    entity.sethost_os(rs.getString("host_os"));
    entity.setkvm_version(rs.getString("kvm_version"));
    entity.setlibvirt_version(new RpmVersion(rs.getString("libvirt_version")));
    entity.setspice_version(rs.getString("spice_version"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setkernel_version(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    return entity;
}
#method_after
@Override
public VdsDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VdsDynamic entity = new VdsDynamic();
    entity.setcpu_cores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setcpu_model(rs.getString("cpu_model"));
    entity.setcpu_speed_mh(rs.getDouble("cpu_speed_mh"));
    entity.setif_total_speed(rs.getString("if_total_speed"));
    entity.setkvm_enabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setmem_commited((Integer) rs.getObject("mem_commited"));
    entity.setphysical_mem_mb((Integer) rs.getObject("physical_mem_mb"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setvm_active((Integer) rs.getObject("vm_active"));
    entity.setvm_count(rs.getInt("vm_count"));
    entity.setvms_cores_count(rs.getInt("vms_cores_count"));
    entity.setvm_migrating((Integer) rs.getObject("vm_migrating"));
    entity.setreserved_mem((Integer) rs.getObject("reserved_mem"));
    entity.setguest_overhead(rs.getInt("guest_overhead"));
    entity.setsoftware_version(rs.getString("software_version"));
    entity.setversion_name(rs.getString("version_name"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setbuild_name(rs.getString("build_name"));
    entity.setprevious_status(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setcpu_flags(rs.getString("cpu_flags"));
    entity.setcpu_over_commit_time_stamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setpending_vcpus_count((Integer) rs.getObject("pending_vcpus_count"));
    entity.setpending_vmem_size(rs.getInt("pending_vmem_size"));
    entity.setcpu_sockets((Integer) rs.getObject("cpu_sockets"));
    entity.setnet_config_dirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setsupported_cluster_levels(rs.getString("supported_cluster_levels"));
    entity.setsupported_engines(rs.getString("supported_engines"));
    entity.sethost_os(rs.getString("host_os"));
    entity.setkvm_version(rs.getString("kvm_version"));
    entity.setlibvirt_version(new RpmVersion(rs.getString("libvirt_version")));
    entity.setspice_version(rs.getString("spice_version"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setkernel_version(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    return entity;
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(VdsDynamic vds) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("cpu_cores", vds.getcpu_cores()).addValue("cpu_threads", vds.getCpuThreads()).addValue("cpu_model", vds.getcpu_model()).addValue("cpu_speed_mh", vds.getcpu_speed_mh()).addValue("if_total_speed", vds.getif_total_speed()).addValue("kvm_enabled", vds.getkvm_enabled()).addValue("mem_commited", vds.getmem_commited()).addValue("physical_mem_mb", vds.getphysical_mem_mb()).addValue("status", vds.getStatus()).addValue("vds_id", vds.getId()).addValue("vm_active", vds.getvm_active()).addValue("vm_count", vds.getvm_count()).addValue("vms_cores_count", vds.getvms_cores_count()).addValue("vm_migrating", vds.getvm_migrating()).addValue("reserved_mem", vds.getreserved_mem()).addValue("guest_overhead", vds.getguest_overhead()).addValue("rpm_version", vds.getVersion().getRpmName()).addValue("software_version", vds.getsoftware_version()).addValue("version_name", vds.getversion_name()).addValue("build_name", vds.getbuild_name()).addValue("previous_status", vds.getprevious_status()).addValue("cpu_flags", vds.getcpu_flags()).addValue("cpu_over_commit_time_stamp", vds.getcpu_over_commit_time_stamp()).addValue("pending_vcpus_count", vds.getpending_vcpus_count()).addValue("pending_vmem_size", vds.getpending_vmem_size()).addValue("cpu_sockets", vds.getcpu_sockets()).addValue("net_config_dirty", vds.getnet_config_dirty()).addValue("supported_cluster_levels", vds.getsupported_cluster_levels()).addValue("supported_engines", vds.getsupported_engines()).addValue("host_os", vds.gethost_os()).addValue("kvm_version", vds.getkvm_version()).addValue("libvirt_version", vds.getlibvirt_version().getRpmName()).addValue("spice_version", vds.getspice_version()).addValue("gluster_version", vds.getGlusterVersion().getRpmName()).addValue("kernel_version", vds.getkernel_version()).addValue("iscsi_initiator_name", vds.getIScsiInitiatorName()).addValue("transparent_hugepages_state", vds.getTransparentHugePagesState().getValue()).addValue("hooks", vds.getHooksStr()).addValue("non_operational_reason", vds.getNonOperationalReason().getValue()).addValue("hw_manufacturer", vds.getHardwareManufacturer()).addValue("hw_product_name", vds.getHardwareProductName()).addValue("hw_version", vds.getHardwareVersion()).addValue("hw_serial_number", vds.getHardwareSerialNumber()).addValue("hw_uuid", vds.getHardwareUUID()).addValue("hw_family", vds.getHardwareFamily()).addValue("hbas", new JsonObjectSerializer().serialize(vds.getHBAs())).addValue("supported_rng_sources", VmRngDevice.sourcesToCsv(vds.getSupportedRngSources())).addValue("supported_emulated_machines", vds.getSupportedEmulatedMachines());
    return parameterSource;
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(VdsDynamic vds) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("cpu_cores", vds.getcpu_cores()).addValue("cpu_threads", vds.getCpuThreads()).addValue("cpu_model", vds.getcpu_model()).addValue("cpu_speed_mh", vds.getcpu_speed_mh()).addValue("if_total_speed", vds.getif_total_speed()).addValue("kvm_enabled", vds.getkvm_enabled()).addValue("mem_commited", vds.getmem_commited()).addValue("physical_mem_mb", vds.getphysical_mem_mb()).addValue("status", vds.getStatus()).addValue("vds_id", vds.getId()).addValue("vm_active", vds.getvm_active()).addValue("vm_count", vds.getvm_count()).addValue("vms_cores_count", vds.getvms_cores_count()).addValue("vm_migrating", vds.getvm_migrating()).addValue("reserved_mem", vds.getreserved_mem()).addValue("guest_overhead", vds.getguest_overhead()).addValue("rpm_version", vds.getVersion().getRpmName()).addValue("software_version", vds.getsoftware_version()).addValue("version_name", vds.getversion_name()).addValue("build_name", vds.getbuild_name()).addValue("previous_status", vds.getprevious_status()).addValue("cpu_flags", vds.getcpu_flags()).addValue("cpu_over_commit_time_stamp", vds.getcpu_over_commit_time_stamp()).addValue("pending_vcpus_count", vds.getpending_vcpus_count()).addValue("pending_vmem_size", vds.getpending_vmem_size()).addValue("cpu_sockets", vds.getcpu_sockets()).addValue("net_config_dirty", vds.getnet_config_dirty()).addValue("supported_cluster_levels", vds.getsupported_cluster_levels()).addValue("supported_engines", vds.getsupported_engines()).addValue("host_os", vds.gethost_os()).addValue("kvm_version", vds.getkvm_version()).addValue("libvirt_version", vds.getlibvirt_version().getRpmName()).addValue("spice_version", vds.getspice_version()).addValue("gluster_version", vds.getGlusterVersion().getRpmName()).addValue("kernel_version", vds.getkernel_version()).addValue("iscsi_initiator_name", vds.getIScsiInitiatorName()).addValue("transparent_hugepages_state", vds.getTransparentHugePagesState().getValue()).addValue("hooks", vds.getHooksStr()).addValue("non_operational_reason", vds.getNonOperationalReason().getValue()).addValue("hw_manufacturer", vds.getHardwareManufacturer()).addValue("hw_product_name", vds.getHardwareProductName()).addValue("hw_version", vds.getHardwareVersion()).addValue("hw_serial_number", vds.getHardwareSerialNumber()).addValue("hw_uuid", vds.getHardwareUUID()).addValue("hw_family", vds.getHardwareFamily()).addValue("hbas", new JsonObjectSerializer().serialize(vds.getHBAs())).addValue("supported_emulated_machines", vds.getSupportedEmulatedMachines()).addValue("kdump_status", vds.getKdumpStatus().getAsNumber()).addValue("selinux_enforce_mode", (vds.getSELinuxEnforceMode() != null) ? vds.getSELinuxEnforceMode().toInt() : null).addValue("auto_numa_balancing", vds.getAutoNumaBalancing().getValue()).addValue("is_numa_supported", vds.isNumaSupport()).addValue("supported_rng_sources", VmRngDevice.sourcesToCsv(vds.getSupportedRngSources())).addValue("supported_emulated_machines", vds.getSupportedEmulatedMachines());
    return parameterSource;
}
#end_block

#method_before
private HashSet<Version> parseSupportedVersions(String supportedVersions) {
    HashSet<Version> parsedVersions = null;
    if (!StringHelper.isNullOrEmpty(supportedVersions)) {
        parsedVersions = new HashSet<Version>();
        for (String ver : supportedVersions.split("[,]", -1)) {
            try {
                parsedVersions.add(new Version(ver));
            } catch (Exception e) {
                throw new RuntimeException(StringFormat.format("Could not parse supported version %s for vds %s", ver, getId()));
            }
        }
    }
    return parsedVersions;
}
#method_after
private HashSet<Version> parseSupportedVersions(String supportedVersions) {
    HashSet<Version> parsedVersions = new HashSet<Version>();
    if (!StringHelper.isNullOrEmpty(supportedVersions)) {
        for (String ver : supportedVersions.split("[,]", -1)) {
            try {
                parsedVersions.add(new Version(ver));
            } catch (Exception e) {
                throw new RuntimeException(StringFormat.format("Could not parse supported version %s for vds %s", ver, getId()));
            }
        }
    }
    return parsedVersions;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((_supportedClusterVersionsSet == null) ? 0 : _supportedClusterVersionsSet.hashCode());
    result = prime * result + ((_supportedENGINESVersionsSet == null) ? 0 : _supportedENGINESVersionsSet.hashCode());
    result = prime * result + ((buildName == null) ? 0 : buildName.hashCode());
    result = prime * result + ((cpu_cores == null) ? 0 : cpu_cores.hashCode());
    result = prime * result + ((cpuThreads == null) ? 0 : cpuThreads.hashCode());
    result = prime * result + ((cpu_flags == null) ? 0 : cpu_flags.hashCode());
    result = prime * result + ((cpu_model == null) ? 0 : cpu_model.hashCode());
    result = prime * result + ((cpu_over_commit_time_stamp == null) ? 0 : cpu_over_commit_time_stamp.hashCode());
    result = prime * result + ((cpu_sockets == null) ? 0 : cpu_sockets.hashCode());
    result = prime * result + ((cpu_speed_mh == null) ? 0 : cpu_speed_mh.hashCode());
    result = prime * result + ((guest_overhead == null) ? 0 : guest_overhead.hashCode());
    result = prime * result + ((hooksStr == null) ? 0 : hooksStr.hashCode());
    result = prime * result + ((host_os == null) ? 0 : host_os.hashCode());
    result = prime * result + ((iScsiInitiatorName == null) ? 0 : iScsiInitiatorName.hashCode());
    result = prime * result + ((if_total_speed == null) ? 0 : if_total_speed.hashCode());
    result = prime * result + ((kernel_version == null) ? 0 : kernel_version.hashCode());
    result = prime * result + ((kvm_enabled == null) ? 0 : kvm_enabled.hashCode());
    result = prime * result + ((kvm_version == null) ? 0 : kvm_version.hashCode());
    result = prime * result + ((libvirt_version == null) ? 0 : libvirt_version.hashCode());
    result = prime * result + ((rpmVersion == null) ? 0 : rpmVersion.hashCode());
    result = prime * result + ((mem_commited == null) ? 0 : mem_commited.hashCode());
    result = prime * result + ((net_config_dirty == null) ? 0 : net_config_dirty.hashCode());
    result = prime * result + ((nonOperationalReason == null) ? 0 : nonOperationalReason.hashCode());
    result = prime * result + ((pending_vcpus_count == null) ? 0 : pending_vcpus_count.hashCode());
    result = prime * result + ((pending_vmem_size == null) ? 0 : pending_vmem_size.hashCode());
    result = prime * result + ((physical_mem_mb == null) ? 0 : physical_mem_mb.hashCode());
    result = prime * result + ((previous_status == null) ? 0 : previous_status.hashCode());
    result = prime * result + ((reserved_mem == null) ? 0 : reserved_mem.hashCode());
    result = prime * result + ((softwareVersion == null) ? 0 : softwareVersion.hashCode());
    result = prime * result + ((spice_version == null) ? 0 : spice_version.hashCode());
    result = prime * result + ((glusterVersion == null) ? 0 : glusterVersion.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + ((supported_cluster_levels == null) ? 0 : supported_cluster_levels.hashCode());
    result = prime * result + ((supported_engines == null) ? 0 : supported_engines.hashCode());
    result = prime * result + ((transparentHugePagesState == null) ? 0 : transparentHugePagesState.hashCode());
    result = prime * result + ((versionName == null) ? 0 : versionName.hashCode());
    result = prime * result + ((vm_active == null) ? 0 : vm_active.hashCode());
    result = prime * result + vm_count;
    result = prime * result + ((supportedRngSources == null) ? 0 : supportedRngSources.hashCode());
    result = prime * result + ((vm_migrating == null) ? 0 : vm_migrating.hashCode());
    result = prime * result + ((vms_cores_count == null) ? 0 : vms_cores_count.hashCode());
    result = prime * result + ((hwManufacturer == null) ? 0 : hwManufacturer.hashCode());
    result = prime * result + ((hwProductName == null) ? 0 : hwProductName.hashCode());
    result = prime * result + ((hwVersion == null) ? 0 : hwVersion.hashCode());
    result = prime * result + ((hwSerialNumber == null) ? 0 : hwSerialNumber.hashCode());
    result = prime * result + ((hwUUID == null) ? 0 : hwUUID.hashCode());
    result = prime * result + ((hwFamily == null) ? 0 : hwFamily.hashCode());
    result = prime * result + ((HBAs == null) ? 0 : HBAs.hashCode());
    result = prime * result + (powerManagementControlledByPolicy ? 0 : 1);
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((_supportedClusterVersionsSet == null) ? 0 : _supportedClusterVersionsSet.hashCode());
    result = prime * result + ((_supportedENGINESVersionsSet == null) ? 0 : _supportedENGINESVersionsSet.hashCode());
    result = prime * result + ((buildName == null) ? 0 : buildName.hashCode());
    result = prime * result + ((cpu_cores == null) ? 0 : cpu_cores.hashCode());
    result = prime * result + ((cpuThreads == null) ? 0 : cpuThreads.hashCode());
    result = prime * result + ((cpu_flags == null) ? 0 : cpu_flags.hashCode());
    result = prime * result + ((cpu_model == null) ? 0 : cpu_model.hashCode());
    result = prime * result + ((cpu_over_commit_time_stamp == null) ? 0 : cpu_over_commit_time_stamp.hashCode());
    result = prime * result + ((cpu_sockets == null) ? 0 : cpu_sockets.hashCode());
    result = prime * result + ((cpu_speed_mh == null) ? 0 : cpu_speed_mh.hashCode());
    result = prime * result + ((guest_overhead == null) ? 0 : guest_overhead.hashCode());
    result = prime * result + ((hooksStr == null) ? 0 : hooksStr.hashCode());
    result = prime * result + ((host_os == null) ? 0 : host_os.hashCode());
    result = prime * result + ((iScsiInitiatorName == null) ? 0 : iScsiInitiatorName.hashCode());
    result = prime * result + ((if_total_speed == null) ? 0 : if_total_speed.hashCode());
    result = prime * result + ((kernel_version == null) ? 0 : kernel_version.hashCode());
    result = prime * result + ((kvm_enabled == null) ? 0 : kvm_enabled.hashCode());
    result = prime * result + ((kvm_version == null) ? 0 : kvm_version.hashCode());
    result = prime * result + ((libvirt_version == null) ? 0 : libvirt_version.hashCode());
    result = prime * result + ((rpmVersion == null) ? 0 : rpmVersion.hashCode());
    result = prime * result + ((mem_commited == null) ? 0 : mem_commited.hashCode());
    result = prime * result + ((net_config_dirty == null) ? 0 : net_config_dirty.hashCode());
    result = prime * result + ((nonOperationalReason == null) ? 0 : nonOperationalReason.hashCode());
    result = prime * result + ((pending_vcpus_count == null) ? 0 : pending_vcpus_count.hashCode());
    result = prime * result + ((pending_vmem_size == null) ? 0 : pending_vmem_size.hashCode());
    result = prime * result + ((physical_mem_mb == null) ? 0 : physical_mem_mb.hashCode());
    result = prime * result + ((previous_status == null) ? 0 : previous_status.hashCode());
    result = prime * result + ((reserved_mem == null) ? 0 : reserved_mem.hashCode());
    result = prime * result + ((softwareVersion == null) ? 0 : softwareVersion.hashCode());
    result = prime * result + ((spice_version == null) ? 0 : spice_version.hashCode());
    result = prime * result + ((glusterVersion == null) ? 0 : glusterVersion.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + ((supported_cluster_levels == null) ? 0 : supported_cluster_levels.hashCode());
    result = prime * result + ((supported_engines == null) ? 0 : supported_engines.hashCode());
    result = prime * result + ((transparentHugePagesState == null) ? 0 : transparentHugePagesState.hashCode());
    result = prime * result + ((versionName == null) ? 0 : versionName.hashCode());
    result = prime * result + ((vm_active == null) ? 0 : vm_active.hashCode());
    result = prime * result + vm_count;
    result = prime * result + ((supportedRngSources == null) ? 0 : supportedRngSources.hashCode());
    result = prime * result + ((vm_migrating == null) ? 0 : vm_migrating.hashCode());
    result = prime * result + ((vms_cores_count == null) ? 0 : vms_cores_count.hashCode());
    result = prime * result + ((hwManufacturer == null) ? 0 : hwManufacturer.hashCode());
    result = prime * result + ((hwProductName == null) ? 0 : hwProductName.hashCode());
    result = prime * result + ((hwVersion == null) ? 0 : hwVersion.hashCode());
    result = prime * result + ((hwSerialNumber == null) ? 0 : hwSerialNumber.hashCode());
    result = prime * result + ((hwUUID == null) ? 0 : hwUUID.hashCode());
    result = prime * result + ((hwFamily == null) ? 0 : hwFamily.hashCode());
    result = prime * result + ((HBAs == null) ? 0 : HBAs.hashCode());
    result = prime * result + (powerManagementControlledByPolicy ? 0 : 1);
    result = prime * result + ((kdumpStatus == null) ? 0 : kdumpStatus.hashCode());
    result = prime * result + ((selinuxEnforceMode == null) ? 0 : selinuxEnforceMode.hashCode());
    result = prime * result + ((numaNodeList == null) ? 0 : numaNodeList.hashCode());
    result = prime * result + autoNumaBalancing.getValue();
    result = prime * result + (numaSupport ? 0 : 1);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VdsDynamic other = (VdsDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(_supportedClusterVersionsSet, other._supportedClusterVersionsSet) && ObjectUtils.objectsEqual(_supportedENGINESVersionsSet, other._supportedENGINESVersionsSet) && ObjectUtils.objectsEqual(buildName, other.buildName) && ObjectUtils.objectsEqual(cpu_cores, other.cpu_cores) && ObjectUtils.objectsEqual(cpuThreads, other.cpuThreads) && ObjectUtils.objectsEqual(cpu_flags, other.cpu_flags) && ObjectUtils.objectsEqual(cpu_model, other.cpu_model) && ObjectUtils.objectsEqual(cpu_over_commit_time_stamp, other.cpu_over_commit_time_stamp) && ObjectUtils.objectsEqual(cpu_sockets, other.cpu_sockets) && ObjectUtils.objectsEqual(cpu_speed_mh, other.cpu_speed_mh) && ObjectUtils.objectsEqual(guest_overhead, other.guest_overhead) && ObjectUtils.objectsEqual(hooksStr, other.hooksStr) && ObjectUtils.objectsEqual(host_os, other.host_os) && ObjectUtils.objectsEqual(iScsiInitiatorName, other.iScsiInitiatorName) && ObjectUtils.objectsEqual(if_total_speed, other.if_total_speed) && ObjectUtils.objectsEqual(kernel_version, other.kernel_version) && ObjectUtils.objectsEqual(kvm_enabled, other.kvm_enabled) && ObjectUtils.objectsEqual(kvm_version, other.kvm_version) && ObjectUtils.objectsEqual(libvirt_version, other.libvirt_version) && ObjectUtils.objectsEqual(rpmVersion, other.rpmVersion) && ObjectUtils.objectsEqual(mem_commited, other.mem_commited) && ObjectUtils.objectsEqual(net_config_dirty, other.net_config_dirty) && nonOperationalReason == other.nonOperationalReason && ObjectUtils.objectsEqual(pending_vcpus_count, other.pending_vcpus_count) && ObjectUtils.objectsEqual(pending_vmem_size, other.pending_vmem_size) && ObjectUtils.objectsEqual(physical_mem_mb, other.physical_mem_mb) && previous_status == other.previous_status && ObjectUtils.objectsEqual(reserved_mem, other.reserved_mem) && ObjectUtils.objectsEqual(getsoftware_version(), other.getsoftware_version()) && ObjectUtils.objectsEqual(spice_version, other.spice_version) && ObjectUtils.objectsEqual(glusterVersion, other.glusterVersion) && status == other.status && ObjectUtils.objectsEqual(supported_cluster_levels, other.supported_cluster_levels) && ObjectUtils.objectsEqual(supported_engines, other.supported_engines) && transparentHugePagesState == other.transparentHugePagesState && ObjectUtils.objectsEqual(versionName, other.versionName) && ObjectUtils.objectsEqual(vm_active, other.vm_active) && vm_count == other.vm_count && ObjectUtils.objectsEqual(vm_migrating, other.vm_migrating) && ObjectUtils.objectsEqual(vms_cores_count, other.vms_cores_count) && ObjectUtils.objectsEqual(hwManufacturer, other.hwManufacturer) && ObjectUtils.objectsEqual(hwProductName, other.hwProductName) && ObjectUtils.objectsEqual(hwVersion, other.hwVersion) && ObjectUtils.objectsEqual(hwSerialNumber, other.hwSerialNumber) && ObjectUtils.objectsEqual(hwUUID, other.hwUUID) && ObjectUtils.objectsEqual(hwFamily, other.hwFamily) && ObjectUtils.objectsEqual(HBAs, other.HBAs) && ObjectUtils.objectsEqual(supportedEmulatedMachines, other.supportedEmulatedMachines)) && powerManagementControlledByPolicy == other.powerManagementControlledByPolicy && ObjectUtils.objectsEqual(supportedRngSources, other.supportedRngSources);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VdsDynamic other = (VdsDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(_supportedClusterVersionsSet, other._supportedClusterVersionsSet) && ObjectUtils.objectsEqual(_supportedENGINESVersionsSet, other._supportedENGINESVersionsSet) && ObjectUtils.objectsEqual(buildName, other.buildName) && ObjectUtils.objectsEqual(cpu_cores, other.cpu_cores) && ObjectUtils.objectsEqual(cpuThreads, other.cpuThreads) && ObjectUtils.objectsEqual(cpu_flags, other.cpu_flags) && ObjectUtils.objectsEqual(cpu_model, other.cpu_model) && ObjectUtils.objectsEqual(cpu_over_commit_time_stamp, other.cpu_over_commit_time_stamp) && ObjectUtils.objectsEqual(cpu_sockets, other.cpu_sockets) && ObjectUtils.objectsEqual(cpu_speed_mh, other.cpu_speed_mh) && ObjectUtils.objectsEqual(guest_overhead, other.guest_overhead) && ObjectUtils.objectsEqual(hooksStr, other.hooksStr) && ObjectUtils.objectsEqual(host_os, other.host_os) && ObjectUtils.objectsEqual(iScsiInitiatorName, other.iScsiInitiatorName) && ObjectUtils.objectsEqual(if_total_speed, other.if_total_speed) && ObjectUtils.objectsEqual(kernel_version, other.kernel_version) && ObjectUtils.objectsEqual(kvm_enabled, other.kvm_enabled) && ObjectUtils.objectsEqual(kvm_version, other.kvm_version) && ObjectUtils.objectsEqual(libvirt_version, other.libvirt_version) && ObjectUtils.objectsEqual(rpmVersion, other.rpmVersion) && ObjectUtils.objectsEqual(mem_commited, other.mem_commited) && ObjectUtils.objectsEqual(net_config_dirty, other.net_config_dirty) && nonOperationalReason == other.nonOperationalReason && ObjectUtils.objectsEqual(pending_vcpus_count, other.pending_vcpus_count) && ObjectUtils.objectsEqual(pending_vmem_size, other.pending_vmem_size) && ObjectUtils.objectsEqual(physical_mem_mb, other.physical_mem_mb) && previous_status == other.previous_status && ObjectUtils.objectsEqual(reserved_mem, other.reserved_mem) && ObjectUtils.objectsEqual(getsoftware_version(), other.getsoftware_version()) && ObjectUtils.objectsEqual(spice_version, other.spice_version) && ObjectUtils.objectsEqual(glusterVersion, other.glusterVersion) && status == other.status && ObjectUtils.objectsEqual(supported_cluster_levels, other.supported_cluster_levels) && ObjectUtils.objectsEqual(supported_engines, other.supported_engines) && transparentHugePagesState == other.transparentHugePagesState && ObjectUtils.objectsEqual(versionName, other.versionName) && ObjectUtils.objectsEqual(vm_active, other.vm_active) && vm_count == other.vm_count && ObjectUtils.objectsEqual(vm_migrating, other.vm_migrating) && ObjectUtils.objectsEqual(vms_cores_count, other.vms_cores_count) && ObjectUtils.objectsEqual(hwManufacturer, other.hwManufacturer) && ObjectUtils.objectsEqual(hwProductName, other.hwProductName) && ObjectUtils.objectsEqual(hwVersion, other.hwVersion) && ObjectUtils.objectsEqual(hwSerialNumber, other.hwSerialNumber) && ObjectUtils.objectsEqual(hwUUID, other.hwUUID) && ObjectUtils.objectsEqual(hwFamily, other.hwFamily) && ObjectUtils.objectsEqual(HBAs, other.HBAs) && ObjectUtils.objectsEqual(supportedEmulatedMachines, other.supportedEmulatedMachines) && powerManagementControlledByPolicy == other.powerManagementControlledByPolicy && kdumpStatus == other.kdumpStatus && ObjectUtils.objectsEqual(selinuxEnforceMode, other.selinuxEnforceMode) && ObjectUtils.objectsEqual(numaNodeList, other.numaNodeList) && autoNumaBalancing.getValue() == other.autoNumaBalancing.getValue() && numaSupport == other.numaSupport) && ObjectUtils.objectsEqual(supportedEmulatedMachines, other.supportedEmulatedMachines) && powerManagementControlledByPolicy == other.powerManagementControlledByPolicy && ObjectUtils.objectsEqual(supportedRngSources, other.supportedRngSources);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((compatVersion == null) ? 0 : compatVersion.hashCode());
    result = prime * result + ((compatibility_version == null) ? 0 : compatibility_version.hashCode());
    result = prime * result + ((cpu_name == null) ? 0 : cpu_name.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + max_vds_memory_over_commit;
    result = prime * result + (countThreadsAsCores ? 1231 : 1237);
    result = prime * result + ((migrateOnError == null) ? 0 : migrateOnError.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugepages ? 1231 : 1237);
    result = prime * result + (virtService ? 1231 : 1237);
    result = prime * result + (glusterService ? 1231 : 1237);
    result = prime * result + (tunnelMigration ? 1231 : 1237);
    result = prime * result + (emulatedMachine == null ? 0 : emulatedMachine.hashCode());
    result = prime * result + (trustedService ? 1231 : 1237);
    result = prime * result + (haReservation ? 1231 : 1237);
    result = prime * result + ((clusterPolicyName == null) ? 0 : clusterPolicyName.hashCode());
    result = prime * result + (clusterPolicyProperties == null ? 0 : clusterPolicyProperties.hashCode());
    result = prime * result + (requiredRngSources == null ? 0 : requiredRngSources.hashCode());
    result = prime * result + (enableKsm ? 1231 : 1237);
    result = prime * result + (enableBallooning ? 1231 : 1237);
    result = prime * result + ((optimizationType == null) ? 0 : optimizationType.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((compatVersion == null) ? 0 : compatVersion.hashCode());
    result = prime * result + ((compatibility_version == null) ? 0 : compatibility_version.hashCode());
    result = prime * result + ((cpu_name == null) ? 0 : cpu_name.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + max_vds_memory_over_commit;
    result = prime * result + (countThreadsAsCores ? 1231 : 1237);
    result = prime * result + ((migrateOnError == null) ? 0 : migrateOnError.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugepages ? 1231 : 1237);
    result = prime * result + (virtService ? 1231 : 1237);
    result = prime * result + (glusterService ? 1231 : 1237);
    result = prime * result + (tunnelMigration ? 1231 : 1237);
    result = prime * result + (emulatedMachine == null ? 0 : emulatedMachine.hashCode());
    result = prime * result + (trustedService ? 1231 : 1237);
    result = prime * result + (haReservation ? 1231 : 1237);
    result = prime * result + ((clusterPolicyName == null) ? 0 : clusterPolicyName.hashCode());
    result = prime * result + (clusterPolicyProperties == null ? 0 : clusterPolicyProperties.hashCode());
    result = prime * result + (requiredRngSources == null ? 0 : requiredRngSources.hashCode());
    result = prime * result + (enableKsm ? 1231 : 1237);
    result = prime * result + (enableBallooning ? 1231 : 1237);
    result = prime * result + ((optimizationType == null) ? 0 : optimizationType.hashCode());
    result = prime * result + (serialNumberPolicy == null ? 0 : serialNumberPolicy.hashCode());
    result = prime * result + (customSerialNumber == null ? 0 : customSerialNumber.hashCode());
    result = prime * result + (groupHostsAndVms == null ? 0 : groupHostsAndVms.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VDSGroup other = (VDSGroup) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(compatVersion, other.compatVersion) && ObjectUtils.objectsEqual(compatibility_version, other.compatibility_version) && ObjectUtils.objectsEqual(cpu_name, other.cpu_name) && ObjectUtils.objectsEqual(description, other.description) && max_vds_memory_over_commit == other.max_vds_memory_over_commit && countThreadsAsCores == other.countThreadsAsCores && migrateOnError == other.migrateOnError && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && transparentHugepages == other.transparentHugepages && virtService == other.virtService && glusterService == other.glusterService && tunnelMigration == other.tunnelMigration && ObjectUtils.objectsEqual(emulatedMachine, other.emulatedMachine) && trustedService == other.trustedService && haReservation == other.haReservation && ObjectUtils.objectsEqual(clusterPolicyId, other.clusterPolicyId) && ObjectUtils.objectsEqual(clusterPolicyName, other.clusterPolicyName) && ObjectUtils.objectsEqual(clusterPolicyProperties, other.clusterPolicyProperties) && enableKsm == other.enableKsm && enableBallooning == other.enableBallooning && detectEmulatedMachine == other.detectEmulatedMachine && optimizationType == other.optimizationType) && ObjectUtils.objectsEqual(requiredRngSources, other.requiredRngSources);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VDSGroup other = (VDSGroup) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(compatVersion, other.compatVersion) && ObjectUtils.objectsEqual(compatibility_version, other.compatibility_version) && ObjectUtils.objectsEqual(cpu_name, other.cpu_name) && ObjectUtils.objectsEqual(description, other.description) && max_vds_memory_over_commit == other.max_vds_memory_over_commit && countThreadsAsCores == other.countThreadsAsCores && migrateOnError == other.migrateOnError && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && transparentHugepages == other.transparentHugepages && virtService == other.virtService && glusterService == other.glusterService && tunnelMigration == other.tunnelMigration && ObjectUtils.objectsEqual(emulatedMachine, other.emulatedMachine) && trustedService == other.trustedService && haReservation == other.haReservation && ObjectUtils.objectsEqual(clusterPolicyId, other.clusterPolicyId) && ObjectUtils.objectsEqual(clusterPolicyName, other.clusterPolicyName) && ObjectUtils.objectsEqual(clusterPolicyProperties, other.clusterPolicyProperties) && enableKsm == other.enableKsm && enableBallooning == other.enableBallooning && detectEmulatedMachine == other.detectEmulatedMachine && optimizationType == other.optimizationType) && serialNumberPolicy == other.serialNumberPolicy && ObjectUtils.objectsEqual(customSerialNumber, other.customSerialNumber) && ObjectUtils.objectsEqual(groupHostsAndVms, other.groupHostsAndVms) && ObjectUtils.objectsEqual(requiredRngSources, other.requiredRngSources);
}
#end_block

#method_before
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getParameters().getRngDevice() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_NOT_FOUND);
    }
    if (!getRngDevices().isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_ALREADY_EXISTS);
    }
    if (!isRngSourceCompatibleWithCluster()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    return true;
}
#method_after
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (!isRngSupportedByCluster()) {
        return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (!getRngDevices().isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_ALREADY_EXISTS);
    }
    return true;
}
#end_block

#method_before
private UpdateRngDeviceCommand mockCommand(final Version mockCompatibilityVersion) {
    final Guid vmId = new Guid("a09f57b1-5739-4352-bf88-a6f834ed46db");
    final Guid clusterId = new Guid("e862dae0-5c41-416a-922c-5395e7245c9b");
    final Guid deviceId = new Guid("b24ae590-f42b-49b6-b8f4-cbbc720b230d");
    VmRngDevice dev = getDevice(deviceId, vmId);
    final VM vmMock = Mockito.mock(VM.class);
    Mockito.when(vmMock.getVdsGroupId()).thenReturn(clusterId);
    final VmDAO vmDaoMock = Mockito.mock(VmDAO.class);
    Mockito.when(vmDaoMock.get(vmId)).thenReturn(vmMock);
    final VmDeviceDAO vmDeviceDaoMock = Mockito.mock(VmDeviceDAO.class);
    Mockito.when(vmDeviceDaoMock.getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.RNG)).thenReturn(Collections.<VmDevice>singletonList(new VmDevice()));
    final VDSGroup cluster = Mockito.mock(VDSGroup.class);
    Mockito.when(cluster.getcompatibility_version()).thenReturn(mockCompatibilityVersion);
    Mockito.when(cluster.getRequiredRngSources()).thenReturn(Collections.<VmRngDevice.Source>singleton(VmRngDevice.Source.RANDOM));
    final VdsGroupDAO vdsGroupMock = Mockito.mock(VdsGroupDAO.class);
    Mockito.when(vdsGroupMock.get(clusterId)).thenReturn(cluster);
    RngDeviceParameters params = new RngDeviceParameters(dev, true);
    UpdateRngDeviceCommand cmd = new UpdateRngDeviceCommand(params) {

        @Override
        public VmDAO getVmDAO() {
            return vmDaoMock;
        }

        @Override
        public VdsGroupDAO getVdsGroupDAO() {
            return vdsGroupMock;
        }

        @Override
        protected VmDeviceDAO getVmDeviceDao() {
            return vmDeviceDaoMock;
        }

        @Override
        public Guid getVdsGroupId() {
            return clusterId;
        }

        @Override
        boolean virtioRngSupportedByClusterLevel() {
            return mockCompatibilityVersion.compareTo(Version.v3_5) >= 0;
        }
    };
    return cmd;
}
#method_after
private UpdateRngDeviceCommand mockCommand(final Version mockCompatibilityVersion) {
    final Guid vmId = new Guid("a09f57b1-5739-4352-bf88-a6f834ed46db");
    final Guid clusterId = new Guid("e862dae0-5c41-416a-922c-5395e7245c9b");
    final Guid deviceId = new Guid("b24ae590-f42b-49b6-b8f4-cbbc720b230d");
    final VmRngDevice dev = getDevice(deviceId, vmId);
    final VmStatic vmMock = Mockito.mock(VmStatic.class);
    Mockito.when(vmMock.getVdsGroupId()).thenReturn(clusterId);
    final VmStaticDAO vmDaoMock = Mockito.mock(VmStaticDAO.class);
    Mockito.when(vmDaoMock.get(vmId)).thenReturn(vmMock);
    final VmDeviceDAO vmDeviceDaoMock = Mockito.mock(VmDeviceDAO.class);
    Mockito.when(vmDeviceDaoMock.getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.RNG)).thenReturn(Collections.singletonList(new VmDevice()));
    final VDSGroup cluster = Mockito.mock(VDSGroup.class);
    Mockito.when(cluster.getcompatibility_version()).thenReturn(mockCompatibilityVersion);
    Mockito.when(cluster.getRequiredRngSources()).thenReturn(Collections.singleton(VmRngDevice.Source.RANDOM));
    final VdsGroupDAO vdsGroupMock = Mockito.mock(VdsGroupDAO.class);
    Mockito.when(vdsGroupMock.get(clusterId)).thenReturn(cluster);
    RngDeviceParameters params = new RngDeviceParameters(dev, true);
    UpdateRngDeviceCommand cmd = new UpdateRngDeviceCommand(params) {

        @Override
        public VmStaticDAO getVmStaticDAO() {
            return vmDaoMock;
        }

        @Override
        public VdsGroupDAO getVdsGroupDAO() {
            return vdsGroupMock;
        }

        @Override
        protected VmDeviceDAO getVmDeviceDao() {
            return vmDeviceDaoMock;
        }

        @Override
        public Guid getVdsGroupId() {
            return clusterId;
        }

        @Override
        boolean isFeatureSupported(Version clusterVersion) {
            return mockCompatibilityVersion.compareTo(Version.v3_5) >= 0;
        }
    };
    return cmd;
}
#end_block

#method_before
private VmRngDevice getDevice(Guid deviceId, Guid vmId) {
    return VmRngDevice.create(deviceId, vmId, 12, 34, VmRngDevice.Source.RANDOM);
}
#method_after
private VmRngDevice getDevice(Guid deviceId, Guid vmId) {
    VmRngDevice device = new VmRngDevice();
    device.setVmId(vmId);
    device.setDeviceId(deviceId);
    device.setBytes(12);
    device.setPeriod(34);
    device.setSource(VmRngDevice.Source.RANDOM);
    return device;
}
#end_block

#method_before
@Override
public List<VDSGroup> getAllWithQuery(String query) {
    return jdbcTemplate.query(query, VdsGroupRowMapper.instance);
}
#method_after
@Override
public List<VDSGroup> getAllWithQuery(String query) {
    List<VDSGroup> groups = jdbcTemplate.query(query, VdsGroupRowMapper.instance);
    try {
        // The UI requires the host and vm count
        return getHostsAndVmsForClusters(groups);
    } catch (Exception e) {
        log.error("Can't load host and vm count for cluster. Query is " + query, e);
    }
    return groups;
}
#end_block

#method_before
private MapSqlParameterSource getVdsGroupParamSource(VDSGroup group) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", group.getdescription()).addValue("name", group.getName()).addValue("free_text_comment", group.getComment()).addValue("vds_group_id", group.getId()).addValue("cpu_name", group.getcpu_name()).addValue("storage_pool_id", group.getStoragePoolId()).addValue("max_vds_memory_over_commit", group.getmax_vds_memory_over_commit()).addValue("count_threads_as_cores", group.getCountThreadsAsCores()).addValue("transparent_hugepages", group.getTransparentHugepages()).addValue("compatibility_version", group.getcompatibility_version()).addValue("migrate_on_error", group.getMigrateOnError()).addValue("virt_service", group.supportsVirtService()).addValue("gluster_service", group.supportsGlusterService()).addValue("tunnel_migration", group.isTunnelMigration()).addValue("required_rng_sources", VmRngDevice.sourcesToCsv(group.getRequiredRngSources())).addValue("emulated_machine", group.getEmulatedMachine()).addValue("detect_emulated_machine", group.isDetectEmulatedMachine()).addValue("trusted_service", group.supportsTrustedService()).addValue("ha_reservation", group.supportsHaReservation()).addValue("cluster_policy_id", group.getClusterPolicyId()).addValue("cluster_policy_custom_properties", SerializationFactory.getSerializer().serialize(group.getClusterPolicyProperties())).addValue("architecture", group.getArchitecture()).addValue("enable_balloon", group.isEnableBallooning()).addValue("optimization_type", group.getOptimizationType()).addValue("enable_ksm", group.isEnableKsm()).addValue("spice_proxy", group.getSpiceProxy());
    return parameterSource;
}
#method_after
private MapSqlParameterSource getVdsGroupParamSource(VDSGroup group) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", group.getdescription()).addValue("name", group.getName()).addValue("free_text_comment", group.getComment()).addValue("vds_group_id", group.getId()).addValue("cpu_name", group.getcpu_name()).addValue("storage_pool_id", group.getStoragePoolId()).addValue("max_vds_memory_over_commit", group.getmax_vds_memory_over_commit()).addValue("count_threads_as_cores", group.getCountThreadsAsCores()).addValue("transparent_hugepages", group.getTransparentHugepages()).addValue("compatibility_version", group.getcompatibility_version()).addValue("migrate_on_error", group.getMigrateOnError()).addValue("virt_service", group.supportsVirtService()).addValue("gluster_service", group.supportsGlusterService()).addValue("tunnel_migration", group.isTunnelMigration()).addValue("required_rng_sources", VmRngDevice.sourcesToCsv(group.getRequiredRngSources())).addValue("emulated_machine", group.getEmulatedMachine()).addValue("detect_emulated_machine", group.isDetectEmulatedMachine()).addValue("trusted_service", group.supportsTrustedService()).addValue("ha_reservation", group.supportsHaReservation()).addValue("optional_reason", group.isOptionalReasonRequired()).addValue("cluster_policy_id", group.getClusterPolicyId()).addValue("cluster_policy_custom_properties", SerializationFactory.getSerializer().serialize(group.getClusterPolicyProperties())).addValue("architecture", group.getArchitecture()).addValue("enable_balloon", group.isEnableBallooning()).addValue("optimization_type", group.getOptimizationType()).addValue("enable_ksm", group.isEnableKsm()).addValue("spice_proxy", group.getSpiceProxy()).addValue("serial_number_policy", group.getSerialNumberPolicy() == null ? null : group.getSerialNumberPolicy().getValue()).addValue("custom_serial_number", group.getCustomSerialNumber());
    return parameterSource;
}
#end_block

#method_before
@Override
public VDSGroup mapRow(ResultSet rs, int rowNum) throws SQLException {
    VDSGroup entity = new VDSGroup();
    entity.setdescription(rs.getString("description"));
    entity.setName(rs.getString("name"));
    entity.setId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setcpu_name(rs.getString("cpu_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setmax_vds_memory_over_commit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCountThreadsAsCores(rs.getBoolean("count_threads_as_cores"));
    entity.setTransparentHugepages(rs.getBoolean("transparent_hugepages"));
    entity.setcompatibility_version(new Version(rs.getString("compatibility_version")));
    entity.setMigrateOnError(MigrateOnErrorOptions.forValue(rs.getInt("migrate_on_error")));
    entity.setVirtService(rs.getBoolean("virt_service"));
    entity.setGlusterService(rs.getBoolean("gluster_service"));
    entity.setTunnelMigration(rs.getBoolean("tunnel_migration"));
    entity.getRequiredRngSources().clear();
    entity.getRequiredRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("required_rng_sources")));
    entity.setEmulatedMachine(rs.getString("emulated_machine"));
    entity.setDetectEmulatedMachine(rs.getBoolean("detect_emulated_machine"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setHaReservation(rs.getBoolean("ha_reservation"));
    entity.setClusterPolicyId(Guid.createGuidFromString(rs.getString("cluster_policy_id")));
    entity.setClusterPolicyName(rs.getString("cluster_policy_name"));
    entity.setClusterPolicyProperties(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("cluster_policy_custom_properties"), LinkedHashMap.class));
    entity.setEnableBallooning(rs.getBoolean("enable_balloon"));
    entity.setEnableKsm(rs.getBoolean("enable_ksm"));
    entity.setArchitecture(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOptimizationType(OptimizationType.from(rs.getInt("optimization_type")));
    entity.setSpiceProxy(rs.getString("spice_proxy"));
    return entity;
}
#method_after
@Override
public VDSGroup mapRow(ResultSet rs, int rowNum) throws SQLException {
    VDSGroup entity = new VDSGroup();
    entity.setdescription(rs.getString("description"));
    entity.setName(rs.getString("name"));
    entity.setId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setcpu_name(rs.getString("cpu_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setmax_vds_memory_over_commit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCountThreadsAsCores(rs.getBoolean("count_threads_as_cores"));
    entity.setTransparentHugepages(rs.getBoolean("transparent_hugepages"));
    entity.setcompatibility_version(new Version(rs.getString("compatibility_version")));
    entity.setMigrateOnError(MigrateOnErrorOptions.forValue(rs.getInt("migrate_on_error")));
    entity.setVirtService(rs.getBoolean("virt_service"));
    entity.setGlusterService(rs.getBoolean("gluster_service"));
    entity.setTunnelMigration(rs.getBoolean("tunnel_migration"));
    entity.getRequiredRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("required_rng_sources")));
    entity.setEmulatedMachine(rs.getString("emulated_machine"));
    entity.setDetectEmulatedMachine(rs.getBoolean("detect_emulated_machine"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setHaReservation(rs.getBoolean("ha_reservation"));
    entity.setOptionalReasonRequired(rs.getBoolean("optional_reason"));
    entity.setClusterPolicyId(Guid.createGuidFromString(rs.getString("cluster_policy_id")));
    entity.setClusterPolicyName(rs.getString("cluster_policy_name"));
    entity.setClusterPolicyProperties(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("cluster_policy_custom_properties"), LinkedHashMap.class));
    entity.setEnableBallooning(rs.getBoolean("enable_balloon"));
    entity.setEnableKsm(rs.getBoolean("enable_ksm"));
    entity.setArchitecture(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOptimizationType(OptimizationType.from(rs.getInt("optimization_type")));
    entity.setSpiceProxy(rs.getString("spice_proxy"));
    entity.setSerialNumberPolicy(SerialNumberPolicy.forValue((Integer) rs.getObject("serial_number_policy")));
    entity.setCustomSerialNumber(rs.getString("custom_serial_number"));
    return entity;
}
#end_block

#method_before
@Override
public boolean isMonitoringNeeded(VDS vds) {
    // No need to update the run-time info for hosts that don't run VMs
    return (vds.getStatus() != VDSStatus.NonOperational || vds.getVmCount() > 0);
}
#method_after
@Override
public boolean isMonitoringNeeded(VDS vds) {
    // No need to update the run-time info for hosts that don't run VMs, depends on the non-operational reason
    return vds.getStatus() != VDSStatus.NonOperational || vds.getVmCount() > 0;
}
#end_block

#method_before
protected void vdsNonOperational(VDS vds, NonOperationalReason reason, Map<String, String> customLogValues) {
    ResourceManager.getInstance().getEventListener().vdsNonOperational(vds.getId(), reason, true, true, Guid.Empty, customLogValues);
}
#method_after
protected void vdsNonOperational(VDS vds, NonOperationalReason reason, Map<String, String> customLogValues) {
    ResourceManager.getInstance().getEventListener().vdsNonOperational(vds.getId(), reason, true, Guid.Empty, customLogValues);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getParameters().getRngDevice().getVmId() == null || !entityExists()) {
        return failCanDoAction(getParameters().isVm() ? VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND : VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!virtioRngSupportedByClusterLevel()) {
        return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_LEVEL);
    }
    if (getParameters().isVm() && getVm() != null && getVm().isRunningOrPaused()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getParameters().getRngDevice().getVmId() == null || cachedEntity == null) {
        return failCanDoAction(getParameters().isVm() ? VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND : VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getParameters().isVm() && getVm() != null && getVm().isRunningOrPaused()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING);
    }
    return true;
}
#end_block

#method_before
protected List<VmDevice> getRngDevices() {
    return getVmDeviceDao().getVmDeviceByVmIdAndType(getParameters().getRngDevice().getVmId(), VmDeviceGeneralType.RNG);
}
#method_after
protected List<VmDevice> getRngDevices() {
    return cachedRngDevices;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getParameters().getSaveToDb()) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.NonOperational, getParameters().getNonOperationalReason()));
        if (getVdsGroup() != null && getVdsGroup().supportsGlusterService()) {
            updateBrickStatusDown();
        }
    }
    // if host failed to recover, no point in sending migrate, as it would fail.
    if (getParameters().getNonOperationalReason() != NonOperationalReason.TIMEOUT_RECOVERING_FROM_CRASH) {
        orderListOfRunningVmsOnVds(getVdsId());
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                // migrate vms according to cluster migrateOnError option
                switch(getVdsGroup().getMigrateOnError()) {
                    case YES:
                        migrateAllVms(getExecutionContext());
                        break;
                    case HA_ONLY:
                        migrateAllVms(getExecutionContext(), true);
                        break;
                    default:
                        break;
                }
            }
        });
    }
    if (getParameters().getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE) {
        log.errorFormat("Host '{0}' is set to Non-Operational, it is missing the following networks: '{1}'", getVds().getName(), getParameters().getCustomLogValues().get("Networks"));
    }
    if (getParameters().getNonOperationalReason() == NonOperationalReason.VM_NETWORK_IS_BRIDGELESS) {
        log.errorFormat("Host '{0}' is set to Non-Operational, the following networks are implemented as non-VM instead of a VM networks: '{1}'", getVds().getName(), getParameters().getCustomLogValues().get("Networks"));
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.NonOperational, getParameters().getNonOperationalReason()));
    if (getVdsGroup() != null && getVdsGroup().supportsGlusterService()) {
        updateBrickStatusDown();
    }
    // if host failed to recover, no point in sending migrate, as it would fail.
    if (getParameters().getNonOperationalReason() != NonOperationalReason.TIMEOUT_RECOVERING_FROM_CRASH) {
        orderListOfRunningVmsOnVds(getVdsId());
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                // migrate vms according to cluster migrateOnError option
                switch(getVdsGroup().getMigrateOnError()) {
                    case YES:
                        migrateAllVms(getExecutionContext());
                        break;
                    case HA_ONLY:
                        migrateAllVms(getExecutionContext(), true);
                        break;
                    default:
                        break;
                }
            }
        });
    }
    if (getParameters().getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE) {
        log.errorFormat("Host '{0}' is set to Non-Operational, it is missing the following networks: '{1}'", getVds().getName(), getParameters().getCustomLogValues().get("Networks"));
    }
    if (getParameters().getNonOperationalReason() == NonOperationalReason.VM_NETWORK_IS_BRIDGELESS) {
        log.errorFormat("Host '{0}' is set to Non-Operational, the following networks are implemented as non-VM instead of a VM networks: '{1}'", getVds().getName(), getParameters().getCustomLogValues().get("Networks"));
    }
    setSucceeded(true);
}
#end_block

#method_before
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setManagementIp(getManagementIp());
    vds.setHostName(getHostName());
    setComment(getComment());
    vds.setPort(getPort());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setpm_enabled(getpm_enabled());
    vds.setPmPassword(getPmPassword());
    vds.setPmPort(getPort());
    vds.setPmOptions(getPmOptions());
    vds.setPmType(getPmType());
    vds.setPmUser(getPmUser());
    vds.setPmSecondaryIp(getPmSecondaryIp());
    vds.setPmSecondaryType(getPmSecondaryType());
    vds.setPmSecondaryPort(getPmSecondaryPort());
    vds.setPmSecondaryOptions(getPmSecondaryOptions());
    vds.setPmSecondaryUser(getPmSecondaryUser());
    vds.setPmSecondaryPassword(getPmSecondaryPassword());
    vds.setPmSecondaryConcurrent(isPmSecondaryConcurrent());
    vds.setPmPort(getPmPort());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    return vds;
}
#method_after
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setManagementIp(getManagementIp());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setpm_enabled(getpm_enabled());
    vds.setPmPassword(getPmPassword());
    vds.setPmPort(getPort());
    vds.setPmOptions(getPmOptions());
    vds.setPmType(getPmType());
    vds.setPmUser(getPmUser());
    vds.setPmSecondaryIp(getPmSecondaryIp());
    vds.setPmSecondaryType(getPmSecondaryType());
    vds.setPmSecondaryPort(getPmSecondaryPort());
    vds.setPmSecondaryOptions(getPmSecondaryOptions());
    vds.setPmSecondaryUser(getPmSecondaryUser());
    vds.setPmSecondaryPassword(getPmSecondaryPassword());
    vds.setPmSecondaryConcurrent(isPmSecondaryConcurrent());
    vds.setPmPort(getPmPort());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    return vds;
}
#end_block

#method_before
public String getComment() {
    return mVdsStatic.getComment();
}
#method_after
@Override
public String getComment() {
    return mVdsStatic.getComment();
}
#end_block

#method_before
public void setComment(String value) {
    mVdsStatic.setComment(value);
}
#method_after
@Override
public void setComment(String value) {
    mVdsStatic.setComment(value);
}
#end_block

#method_before
public java.util.HashSet<Version> getSupportedClusterVersionsSet() {
    return this.mVdsDynamic.getSupportedClusterVersionsSet();
}
#method_after
public HashSet<Version> getSupportedClusterVersionsSet() {
    return this.mVdsDynamic.getSupportedClusterVersionsSet();
}
#end_block

#method_before
public java.util.HashSet<Version> getSupportedENGINESVersionsSet() {
    return this.mVdsDynamic.getSupportedENGINESVersionsSet();
}
#method_after
public HashSet<Version> getSupportedENGINESVersionsSet() {
    return this.mVdsDynamic.getSupportedENGINESVersionsSet();
}
#end_block

#method_before
public void setCpuOverCommitTimestamp(java.util.Date value) {
    mVdsDynamic.setcpu_over_commit_time_stamp(value);
}
#method_after
public void setCpuOverCommitTimestamp(Date value) {
    mVdsDynamic.setcpu_over_commit_time_stamp(value);
}
#end_block

#method_before
public java.util.ArrayList<Network> getNetworks() {
    return this.mNetworkList;
}
#method_after
public ArrayList<Network> getNetworks() {
    return this.mNetworkList;
}
#end_block

#method_before
public java.util.ArrayList<VdsNetworkInterface> getInterfaces() {
    return this.mInterfaceList;
}
#method_after
public ArrayList<VdsNetworkInterface> getInterfaces() {
    return this.mInterfaceList;
}
#end_block

#method_before
public java.util.ArrayList<VDSDomainsData> getDomains() {
    return privateDomains;
}
#method_after
public ArrayList<VDSDomainsData> getDomains() {
    return privateDomains;
}
#end_block

#method_before
public void setDomains(java.util.ArrayList<VDSDomainsData> value) {
    privateDomains = value;
}
#method_after
public void setDomains(ArrayList<VDSDomainsData> value) {
    privateDomains = value;
}
#end_block

#method_before
public void calculateFreeVirtualMemory() {
    if (getMemCommited() != null && getPhysicalMemMb() != null && getReservedMem() != null) {
        maxSchedulingMemory = (getMaxVdsMemoryOverCommit() * getPhysicalMemMb() / 100.0f) - (getMemCommited() + getReservedMem());
        // avoid negative values
        maxSchedulingMemory = maxSchedulingMemory > 0 ? maxSchedulingMemory : 0;
    }
}
#method_after
public void calculateFreeVirtualMemory() {
    if (getMemCommited() != null && getPhysicalMemMb() != null && getReservedMem() != null) {
        maxSchedulingMemory = (getMaxVdsMemoryOverCommit() * getPhysicalMemMb() / 100.0f) - getMemCommited() - getReservedMem() - getPendingVmemSize();
        // avoid negative values
        maxSchedulingMemory = maxSchedulingMemory > 0 ? maxSchedulingMemory : 0;
    }
}
#end_block

#method_before
public String toString() {
    // is not enough, remove this once mVdsStatic can not be null
    return "Host[" + (mVdsStatic == null ? "null" : mVdsStatic.getName()) + "]";
}
#method_after
@Override
public String toString() {
    // is not enough, remove this once mVdsStatic can not be null
    return "Host[" + (mVdsStatic == null ? "null" : (mVdsStatic.getName() + "," + mVdsStatic.getId())) + "]";
}
#end_block

#method_before
@Override
public void initialize() {
    super.initialize();
    getModel().getActivateDomain().setEntity(false);
    getModel().getActivateDomain().setIsAvailable(true);
}
#method_after
@Override
public void initialize() {
    super.initialize();
    getModel().getActivateDomain().setEntity(false);
}
#end_block

#method_before
@Override
public void updateItemsAvailability() {
    super.updateItemsAvailability();
    StoragePool dataCenter = getModel().getDataCenter().getSelectedItem();
    updateAvailabilitByDatacenter(dataCenter);
    for (IStorageModel item : Linq.<IStorageModel>cast(getModel().getItems())) {
        if (item.getRole() == StorageDomainType.ISO) {
            AsyncDataProvider.getIsoDomainByDataCenterId(new AsyncQuery(new Object[] { this, item }, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    Object[] array = (Object[]) target;
                    ImportStorageModelBehavior behavior = (ImportStorageModelBehavior) array[0];
                    IStorageModel storageModelItem = (IStorageModel) array[1];
                    behavior.postUpdateItemsAvailability(storageModelItem, returnValue == null);
                }
            }, getHash()), dataCenter.getId());
        } else if (item.getRole() == StorageDomainType.ImportExport) {
            AsyncDataProvider.getExportDomainByDataCenterId(new AsyncQuery(new Object[] { this, item }, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    Object[] array = (Object[]) target;
                    ImportStorageModelBehavior behavior = (ImportStorageModelBehavior) array[0];
                    IStorageModel storageModelItem = (IStorageModel) array[1];
                    behavior.postUpdateItemsAvailability(storageModelItem, returnValue == null);
                }
            }, getHash()), dataCenter.getId());
        } else {
            postUpdateItemsAvailability(item, false);
        }
    }
}
#method_after
@Override
public void updateItemsAvailability() {
    super.updateItemsAvailability();
    StoragePool dataCenter = getModel().getDataCenter().getSelectedItem();
    updateAvailabilityByDatacenter(dataCenter);
    for (IStorageModel item : Linq.<IStorageModel>cast(getModel().getItems())) {
        if (item.getRole() == StorageDomainType.ISO) {
            AsyncDataProvider.getIsoDomainByDataCenterId(new AsyncQuery(new Object[] { this, item }, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    Object[] array = (Object[]) target;
                    ImportStorageModelBehavior behavior = (ImportStorageModelBehavior) array[0];
                    IStorageModel storageModelItem = (IStorageModel) array[1];
                    behavior.postUpdateItemsAvailability(storageModelItem, returnValue == null);
                }
            }, getHash()), dataCenter.getId());
        } else if (item.getRole() == StorageDomainType.ImportExport) {
            AsyncDataProvider.getExportDomainByDataCenterId(new AsyncQuery(new Object[] { this, item }, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    Object[] array = (Object[]) target;
                    ImportStorageModelBehavior behavior = (ImportStorageModelBehavior) array[0];
                    IStorageModel storageModelItem = (IStorageModel) array[1];
                    behavior.postUpdateItemsAvailability(storageModelItem, returnValue == null);
                }
            }, getHash()), dataCenter.getId());
        } else {
            postUpdateItemsAvailability(item, false);
        }
    }
}
#end_block

#method_before
private static String getQuotaRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.QUOTA_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.QUOTA_OBJ_NAME)).append(".* ");
    return query.toString();
}
#method_after
private static String getQuotaRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.QUOTA_OBJ_NAME)).append(".*").append(search.getRelatedTableName(SearchObjects.QUOTA_OBJ_NAME, false)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private static String getDiskImageRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.DISK_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.DISK_OBJ_NAME)).append(".* ");
    return query.toString();
}
#method_after
private static String getDiskImageRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.DISK_OBJ_NAME)).append(".*").append(search.getRelatedTableName(SearchObjects.DISK_OBJ_NAME, false)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private static String getVMRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.VM_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.VM_OBJ_NAME)).append(".* ");
    return query.toString();
}
#method_after
private static String getVMRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.VM_OBJ_NAME)).append(".*").append(search.getRelatedTableName(SearchObjects.VM_OBJ_NAME, false)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private static String getVdsRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.VDS_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.VDS_OBJ_NAME)).append(".* ");
    return query.toString();
}
#method_after
private static String getVdsRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.VDS_OBJ_NAME)).append(".*").append(search.getRelatedTableName(SearchObjects.VDS_OBJ_NAME, false)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private static String getVdsGroupRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.VDC_CLUSTER_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.VDC_CLUSTER_OBJ_NAME)).append(".* ");
    return query.toString();
}
#method_after
private static String getVdsGroupRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.VDC_CLUSTER_OBJ_NAME)).append(".*").append(search.getRelatedTableName(SearchObjects.VDC_CLUSTER_OBJ_NAME, false)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private static String getStoragePoolRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)).append(".* ");
    return query.toString();
}
#method_after
private static String getStoragePoolRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)).append(".*").append(search.getRelatedTableName(SearchObjects.VDC_STORAGE_POOL_OBJ_NAME, false)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private static String getGlusterVolumeRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.GLUSTER_VOLUME_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.GLUSTER_VOLUME_OBJ_NAME)).append(".* ");
    return query.toString();
}
#method_after
private static String getGlusterVolumeRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.GLUSTER_VOLUME_OBJ_NAME)).append(".*").append(search.getRelatedTableName(SearchObjects.GLUSTER_VOLUME_OBJ_NAME, false)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private static String getNetworkRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.NETWORK_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.NETWORK_OBJ_NAME)).append(".* ");
    return query.toString();
}
#method_after
private static String getNetworkRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.NETWORK_OBJ_NAME)).append(".*").append(search.getRelatedTableName(SearchObjects.NETWORK_OBJ_NAME, false)).append(".* ");
    return query.toString();
}
#end_block

#method_before
@Test
public void testGetAllMultiDiskImageSearch() throws Exception {
    SearchParameters searchParam = new SearchParameters("Disks : ", SearchType.Disk);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(diskImageResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#method_after
@Test
public void testGetAllMultiDiskImageSearch() throws Exception {
    SearchParameters searchParam = new SearchParameters("Disks" + CommonConstants.QUERY_RETURN_TYPE_SEPARATOR, SearchType.Disk);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(diskImageResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
@Test
public void testGetAllDiskImageSearch() throws Exception {
    // The query Should be used is : "SELECT * FROM (SELECT *, ROW_NUMBER() OVER( ORDER BY disk_name ASC ) as RowNum
    // FROM (SELECT * FROM vm_images_view WHERE ( image_guid IN (SELECT vm_images_view.image_guid FROM
    // vm_images_view ))) as T1 ) as T2"
    SearchParameters searchParam = new SearchParameters("Disk : ", SearchType.Disk);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(diskImageResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#method_after
@Test
public void testGetAllDiskImageSearch() throws Exception {
    // The query Should be used is : "SELECT * FROM (SELECT *, ROW_NUMBER() OVER( ORDER BY disk_name ASC ) as RowNum
    // FROM (SELECT * FROM vm_images_view WHERE ( image_guid IN (SELECT vm_images_view.image_guid FROM
    // vm_images_view ))) as T1 ) as T2"
    SearchParameters searchParam = new SearchParameters("Disk" + CommonConstants.QUERY_RETURN_TYPE_SEPARATOR, SearchType.Disk);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(diskImageResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
@Test
public void testGetAllVMSearch() throws Exception {
    SearchParameters searchParam = new SearchParameters("VM : ", SearchType.VM);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(vmResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#method_after
@Test
public void testGetAllVMSearch() throws Exception {
    SearchParameters searchParam = new SearchParameters("VM" + CommonConstants.QUERY_RETURN_TYPE_SEPARATOR, SearchType.VM);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(vmResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
@Test
public void testGetAllMultiVmSearch() throws Exception {
    SearchParameters searchParam = new SearchParameters("VMs : ", SearchType.VM);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(vmResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#method_after
@Test
public void testGetAllMultiVmSearch() throws Exception {
    SearchParameters searchParam = new SearchParameters("VMs" + CommonConstants.QUERY_RETURN_TYPE_SEPARATOR, SearchType.VM);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(vmResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
@Test
public void testGetAllVdsSearch() throws Exception {
    SearchParameters searchParam = new SearchParameters("Host : ", SearchType.VDS);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(vdsResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#method_after
@Test
public void testGetAllVdsSearch() throws Exception {
    SearchParameters searchParam = new SearchParameters("Host" + CommonConstants.QUERY_RETURN_TYPE_SEPARATOR, SearchType.VDS);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(vdsResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
@Test
public void testGetAllMultiVdsSearch() throws Exception {
    SearchParameters searchParam = new SearchParameters("Hosts : ", SearchType.VDS);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(vdsResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#method_after
@Test
public void testGetAllMultiVdsSearch() throws Exception {
    SearchParameters searchParam = new SearchParameters("Hosts" + CommonConstants.QUERY_RETURN_TYPE_SEPARATOR, SearchType.VDS);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(vdsResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
@Test
public void testGetAllClusterSearch() throws Exception {
    // The original query should be : SELECT * FROM (SELECT *, ROW_NUMBER() OVER( ORDER BY name ASC ) as RowNum FROM
    // (SELECT * FROM vds_groups WHERE ( vds_group_id IN (SELECT vds_groups_storage_domain.vds_group_id FROM
    // vds_groups_storage_domain ))) as T1 ) as T2
    SearchParameters searchParam = new SearchParameters("Cluster : ", SearchType.Cluster);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(vdsGroupResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#method_after
@Test
public void testGetAllClusterSearch() throws Exception {
    // The original query should be : SELECT * FROM (SELECT *, ROW_NUMBER() OVER( ORDER BY name ASC ) as RowNum FROM
    // (SELECT * FROM vds_groups WHERE ( vds_group_id IN (SELECT vds_groups_storage_domain.vds_group_id FROM
    // vds_groups_storage_domain ))) as T1 ) as T2
    SearchParameters searchParam = new SearchParameters("Cluster" + CommonConstants.QUERY_RETURN_TYPE_SEPARATOR, SearchType.Cluster);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(vdsGroupResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
@Test
public void testGetAllMultiClusterSearch() throws Exception {
    // The original query should be : SELECT * FROM (SELECT *, ROW_NUMBER() OVER( ORDER BY name ASC ) as RowNum FROM
    // (SELECT * FROM vds_groups WHERE ( vds_group_id IN (SELECT vds_groups_storage_domain.vds_group_id FROM
    // vds_groups_storage_domain ))) as T1 ) as T2
    SearchParameters searchParam = new SearchParameters("Clusters : ", SearchType.Cluster);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(vdsGroupResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#method_after
@Test
public void testGetAllMultiClusterSearch() throws Exception {
    // The original query should be : SELECT * FROM (SELECT *, ROW_NUMBER() OVER( ORDER BY name ASC ) as RowNum FROM
    // (SELECT * FROM vds_groups WHERE ( vds_group_id IN (SELECT vds_groups_storage_domain.vds_group_id FROM
    // vds_groups_storage_domain ))) as T1 ) as T2
    SearchParameters searchParam = new SearchParameters("Clusters" + CommonConstants.QUERY_RETURN_TYPE_SEPARATOR, SearchType.Cluster);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(vdsGroupResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
@Test
public void testGetAllStoragePoolSearch() throws Exception {
    SearchParameters searchParam = new SearchParameters("Datacenter : ", SearchType.StoragePool);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(storagePoolResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#method_after
@Test
public void testGetAllStoragePoolSearch() throws Exception {
    SearchParameters searchParam = new SearchParameters("Datacenter" + CommonConstants.QUERY_RETURN_TYPE_SEPARATOR, SearchType.StoragePool);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(storagePoolResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
@Ignore
@Test
public void testGetAllMultiStoragePoolSearch() throws Exception {
    SearchParameters searchParam = new SearchParameters("Datacenters : ", SearchType.StoragePool);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(storagePoolResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#method_after
@Ignore
@Test
public void testGetAllMultiStoragePoolSearch() throws Exception {
    SearchParameters searchParam = new SearchParameters("Datacenters" + CommonConstants.QUERY_RETURN_TYPE_SEPARATOR, SearchType.StoragePool);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(storagePoolResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
@Test
public void testGetAllGlusterVolumesSearch() throws Exception {
    SearchParameters searchParam = new SearchParameters("Volumes : ", SearchType.GlusterVolume);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(glusterVolumeList == searchQuery.getQueryReturnValue().getReturnValue());
}
#method_after
@Test
public void testGetAllGlusterVolumesSearch() throws Exception {
    SearchParameters searchParam = new SearchParameters("Volumes" + CommonConstants.QUERY_RETURN_TYPE_SEPARATOR, SearchType.GlusterVolume);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(glusterVolumeList == searchQuery.getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
@Test
public void testGetAllQuotaSearch() throws Exception {
    SearchParameters searchParam = new SearchParameters("Quota : ", SearchType.Quota);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(quotaResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#method_after
@Test
public void testGetAllQuotaSearch() throws Exception {
    SearchParameters searchParam = new SearchParameters("Quota" + CommonConstants.QUERY_RETURN_TYPE_SEPARATOR, SearchType.Quota);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(quotaResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
@Test
public void testGetAllNetworkSearch() throws Exception {
    SearchParameters searchParam = new SearchParameters("Network : ", SearchType.Network);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(networkResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#method_after
@Test
public void testGetAllNetworkSearch() throws Exception {
    SearchParameters searchParam = new SearchParameters("Network" + CommonConstants.QUERY_RETURN_TYPE_SEPARATOR, SearchType.Network);
    SearchQuery<SearchParameters> searchQuery = spySearchQuery(searchParam);
    searchQuery.executeQueryCommand();
    assertTrue(networkResultList == searchQuery.getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
private static Map<Class<?>, String> createReturnTypes() {
    final Map<Class<?>, String> map = new HashMap<>();
    putReturnType(map, VM.class, "VMs");
    putReturnType(map, Host.class, "Hosts");
    putReturnType(map, Cluster.class, "Clusters");
    putReturnType(map, DataCenter.class, "Datacenter");
    putReturnType(map, StorageDomain.class, "Storage");
    putReturnType(map, Template.class, "Template");
    putReturnType(map, User.class, "Users");
    putReturnType(map, Group.class, "Groups");
    putReturnType(map, VmPool.class, "Pools");
    putReturnType(map, Event.class, "Events");
    putReturnType(map, GlusterVolume.class, "Volumes");
    putReturnType(map, Disk.class, "Disks");
    putReturnType(map, Network.class, "Networks");
    return Collections.unmodifiableMap(map);
}
#method_after
private static Map<Class<?>, String> createReturnTypes() {
    final Map<Class<?>, String> map = new HashMap<>();
    map.put(VM.class, getName("VMs"));
    map.put(Host.class, getName("Hosts"));
    map.put(Cluster.class, getName("Clusters"));
    map.put(DataCenter.class, getName("Datacenter"));
    map.put(StorageDomain.class, getName("Storage"));
    map.put(Template.class, getName("Template"));
    map.put(InstanceType.class, getName("Instancetypes"));
    map.put(User.class, getName("Users"));
    map.put(Group.class, getName("Groups"));
    map.put(VmPool.class, getName("Pools"));
    map.put(Event.class, getName("Events"));
    map.put(GlusterVolume.class, getName("Volumes"));
    map.put(Disk.class, getName("Disks"));
    map.put(Network.class, getName("Networks"));
    return Collections.unmodifiableMap(map);
}
#end_block

#method_before
protected void initParametersForExternalNetworks() {
    Map<VmDeviceId, VmDevice> nicDevices = Entities.businessEntitiesById(getDbFacade().getVmDeviceDao().getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.INTERFACE));
    for (VmNic iface : getVm().getInterfaces()) {
        VnicProfile vnicProfile = getDbFacade().getVnicProfileDao().get(iface.getVnicProfileId());
        Network network = NetworkHelper.getNetworkByVnicProfile(vnicProfile);
        VmDevice vmDevice = nicDevices.get(new VmDeviceId(iface.getId(), getVmId()));
        if (network != null && network.isExternal() && vmDevice.getIsPlugged()) {
            Provider<?> provider = getDbFacade().getProviderDao().get(network.getProvidedBy().getProviderId());
            NetworkProviderProxy providerProxy = ProviderProxyFactory.getInstance().create(provider);
            Map<String, String> deviceProperties = providerProxy.allocate(network, vnicProfile, iface);
            getVm().getRuntimeDeviceCustomProperties().put(vmDevice, deviceProperties);
        }
    }
}
#method_after
protected void initParametersForExternalNetworks() {
    Map<VmDeviceId, VmDevice> nicDevices = Entities.businessEntitiesById(getDbFacade().getVmDeviceDao().getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.INTERFACE));
    for (VmNic iface : getVm().getInterfaces()) {
        VnicProfile vnicProfile = getDbFacade().getVnicProfileDao().get(iface.getVnicProfileId());
        Network network = NetworkHelper.getNetworkByVnicProfile(vnicProfile);
        VmDevice vmDevice = nicDevices.get(new VmDeviceId(iface.getId(), getVmId()));
        if (network != null && network.isExternal() && vmDevice.getIsPlugged()) {
            Provider<?> provider = getDbFacade().getProviderDao().get(network.getProvidedBy().getProviderId());
            NetworkProviderProxy providerProxy = ProviderProxyFactory.getInstance().create(provider);
            Map<String, String> deviceProperties = providerProxy.allocate(network, vnicProfile, iface);
            getVm().getRuntimeDeviceCustomProperties().put(vmDevice.getId(), deviceProperties);
        }
    }
}
#end_block

#method_before
@Override
public void processOnVmStop(Guid vmId) {
    Backend.getInstance().runInternalAction(VdcActionType.ProcessDownVm, new IdParameters(vmId));
}
#method_after
@Override
public void processOnVmStop(final Collection<Guid> vmIds) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            for (Guid vmId : vmIds) {
                Backend.getInstance().runInternalAction(VdcActionType.ProcessDownVm, new IdParameters(vmId));
            }
        }
    });
}
#end_block

#method_before
private String generateOvfStoreDescription(Date updateDate, boolean isUpdated, Long size) {
    Map<String, Object> description = new HashMap<>();
    description.put(OvfInfoFileConstants.DiskDescription, OvfInfoFileConstants.OvfStoreDescriptionLabel);
    description.put(OvfInfoFileConstants.Domains, Arrays.asList(getParameters().getStorageDomainId()));
    description.put(OvfInfoFileConstants.IsUpdated, isUpdated);
    description.put(OvfInfoFileConstants.LastUpdated, updateDate.toString());
    if (size != null) {
        description.put(OvfInfoFileConstants.Size, size);
    }
    return buildJson(description, false);
}
#method_after
private String generateOvfStoreDescription(Date updateDate, boolean isUpdated, Long size) {
    Map<String, Object> description = new HashMap<>();
    description.put(OvfInfoFileConstants.DiskDescription, OvfInfoFileConstants.OvfStoreDescriptionLabel);
    description.put(OvfInfoFileConstants.Domains, Arrays.asList(getParameters().getStorageDomainId()));
    description.put(OvfInfoFileConstants.IsUpdated, isUpdated);
    description.put(OvfInfoFileConstants.LastUpdated, updateDate != null ? updateDate.toString() : null);
    if (size != null) {
        description.put(OvfInfoFileConstants.Size, size);
    }
    return buildJson(description, false);
}
#end_block

#method_before
@Override
public void initialize() {
    lockObj.writeLock().lock();
    try {
        log.infoFormat("Start initializing " + getClass().getSimpleName());
        this.macsStorage = initRanges(rangesString);
        List<VmNic> interfaces = getVmNicInterfacesFromDB();
        for (VmNic iface : interfaces) {
            forceAddMac(iface.getMacAddress());
        }
        initialized = true;
        log.infoFormat("Finished initializing. Available MACs in pool: {0}", this.macsStorage.getAvailableMacsCount());
    } catch (Exception ex) {
        log.errorFormat("Error in initializing MAC Addresses pool manager.", ex);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public void initialize() {
    lockObj.writeLock().lock();
    try {
        if (initialized) {
            log.error("Trying to initialized " + getClass().getName() + " multiple times.");
            return;
        }
        log.infoFormat("Start initializing " + getClass().getSimpleName());
        this.macsStorage = createMacsStorage(rangesString);
        List<VmNic> interfaces = getVmNicInterfacesFromDb();
        for (VmNic iface : interfaces) {
            forceAddMacWithoutLocking(iface.getMacAddress());
        }
        initialized = true;
        log.infoFormat("Finished initializing. Available MACs in pool: {0}", macsStorage.getAvailableMacsCount());
    } catch (Exception ex) {
        log.errorFormat("Error in initializing MAC Addresses pool manager.", ex);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#end_block

#method_before
@Override
public String allocateNewMac() {
    lockObj.writeLock().lock();
    try {
        return allocateNewMacImpl(1)[0];
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public String allocateNewMac() {
    lockObj.writeLock().lock();
    try {
        checkIfInitialized();
        return allocateNewMacsWithoutLocking(1).get(0);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#end_block

#method_before
@Override
public int getAvailableMacsCount() {
    lockObj.readLock().lock();
    try {
        if (!initialized) {
            logInitializationError("Failed to get available Macs count.");
            throw new VdcBLLException(VdcBllErrors.MAC_POOL_NOT_INITIALIZED);
        }
        int availableMacsSize = macsStorage.getAvailableMacsCount();
        log.debugFormat("Number of available Mac addresses = {1}", availableMacsSize);
        return availableMacsSize;
    } finally {
        lockObj.readLock().unlock();
    }
}
#method_after
@Override
public int getAvailableMacsCount() {
    lockObj.readLock().lock();
    try {
        checkIfInitialized();
        int availableMacsSize = macsStorage.getAvailableMacsCount();
        log.debugFormat("Number of available Mac addresses = {1}", availableMacsSize);
        return availableMacsSize;
    } finally {
        lockObj.readLock().unlock();
    }
}
#end_block

#method_before
@Override
public void freeMac(String mac) {
    lockObj.writeLock().lock();
    try {
        if (!initialized) {
            logInitializationError("Failed to free mac address " + mac + " .");
        } else {
            macsStorage.freeMac(MacAddressRangeUtils.macStringToLong(mac));
        }
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public void freeMac(String mac) {
    lockObj.writeLock().lock();
    try {
        checkIfInitialized();
        macsStorage.freeMac(MacAddressRangeUtils.macToLong(mac));
    } finally {
        lockObj.writeLock().unlock();
    }
}
#end_block

#method_before
@Override
public boolean addMac(String mac) {
    lockObj.writeLock().lock();
    try {
        boolean added = this.macsStorage.useMac(MacAddressRangeUtils.macStringToLong(mac));
        if (macsStorage.noAvailableMacs()) {
            logMacPoolEmpty();
        }
        return added;
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public boolean addMac(String mac) {
    lockObj.writeLock().lock();
    try {
        checkIfInitialized();
        boolean added = macsStorage.useMac(MacAddressRangeUtils.macToLong(mac));
        logWhenMacPoolIsEmpty();
        return added;
    } finally {
        lockObj.writeLock().unlock();
    }
}
#end_block

#method_before
@Override
public void forceAddMac(String mac) {
    lockObj.writeLock().lock();
    try {
        this.macsStorage.useMacNoDuplicityCheck(MacAddressRangeUtils.macStringToLong(mac));
        if (macsStorage.noAvailableMacs()) {
            logMacPoolEmpty();
        }
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public void forceAddMac(String mac) {
    lockObj.writeLock().lock();
    try {
        checkIfInitialized();
        forceAddMacWithoutLocking(mac);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#end_block

#method_before
@Override
public boolean isMacInUse(String mac) {
    lockObj.readLock().lock();
    try {
        return this.macsStorage.isMacInUse(MacAddressRangeUtils.macStringToLong(mac));
    } finally {
        lockObj.readLock().unlock();
    }
}
#method_after
@Override
public boolean isMacInUse(String mac) {
    lockObj.readLock().lock();
    try {
        checkIfInitialized();
        return macsStorage.isMacInUse(MacAddressRangeUtils.macToLong(mac));
    } finally {
        lockObj.readLock().unlock();
    }
}
#end_block

#method_before
@Override
public void freeMacs(List<String> macs) {
    // TODO MM: how about some duplicities here? Release it twice or what?
    if (!macs.isEmpty()) {
        lockObj.writeLock().lock();
        try {
            if (!initialized) {
                logInitializationError("Failed to free MAC addresses.");
            }
            for (String mac : macs) {
                macsStorage.freeMac(MacAddressRangeUtils.macStringToLong(mac));
            }
        } finally {
            lockObj.writeLock().unlock();
        }
    }
}
#method_after
@Override
public void freeMacs(List<String> macs) {
    lockObj.writeLock().lock();
    try {
        checkIfInitialized();
        for (String mac : macs) {
            macsStorage.freeMac(MacAddressRangeUtils.macToLong(mac));
        }
    } finally {
        lockObj.writeLock().unlock();
    }
}
#end_block

#method_before
@Override
public List<String> allocateMacAddresses(int numberOfAddresses) {
    lockObj.writeLock().lock();
    try {
        String[] macAddresses = this.allocateNewMacImpl(numberOfAddresses);
        return Arrays.asList(macAddresses);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public List<String> allocateMacAddresses(int numberOfAddresses) {
    lockObj.writeLock().lock();
    try {
        checkIfInitialized();
        return allocateNewMacsWithoutLocking(numberOfAddresses);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#end_block

#method_before
private void removeDataCenter() {
    getCompensationContext().snapshotEntity(getStoragePool());
    getStoragePoolDAO().remove(getStoragePool().getId());
    getCompensationContext().stateChanged();
}
#method_after
private void removeDataCenter() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(getStoragePool());
            getStoragePoolDAO().remove(getStoragePool().getId());
            getCompensationContext().stateChanged();
            return null;
        }
    });
}
#end_block

#method_before
private boolean regularRemoveStorageDomains(List<StorageDomain> storageDomains) {
    boolean retVal = true;
    List<StorageDomain> temp = LinqUtils.filter(storageDomains, new Predicate<StorageDomain>() {

        @Override
        public boolean eval(StorageDomain storage_domain) {
            return storage_domain.getStorageDomainType() == StorageDomainType.Master;
        }
    });
    final StorageDomain masterDomain = LinqUtils.first(temp);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(masterDomain.getStoragePoolIsoMapData());
            masterDomain.setStatus(StorageDomainStatus.Locked);
            getDbFacade().getStoragePoolIsoMapDao().update(masterDomain.getStoragePoolIsoMapData());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // destroying a pool is an SPM action. We need to connect all hosts
    // to the pool. Later on, during spm election, one of the hosts will
    // lock the pool
    // and the spm status will be FREE. Only then we can invoke the
    // destroy verb.
    connectAllHostToPoolAndDomain(masterDomain);
    List<VDS> vdss = getAllRunningVdssInPool();
    for (StorageDomain storageDomain : storageDomains) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            if (!removeDomainFromPool(storageDomain, vdss.get(0))) {
                log.errorFormat("Unable to detach storage domain {0} {1}", storageDomain.getStorageName(), storageDomain.getId());
                retVal = false;
            }
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            detachStorageDomainWithEntities(masterDomain);
            getCompensationContext().snapshotEntity(masterDomain.getStorageStaticData());
            masterDomain.setStorageDomainType(StorageDomainType.Data);
            getDbFacade().getStorageDomainStaticDao().update(masterDomain.getStorageStaticData());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(getStoragePool());
            handleDestroyStoragePoolCommand();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    setSucceeded(true);
    if (!getStoragePool().isLocal()) {
        for (VDS vds : vdss) {
            StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).disconnectStorageFromDomainByVdsId(masterDomain, vds.getId());
        }
    } else {
        try {
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FormatStorageDomain, new FormatStorageDomainVDSCommandParameters(vdss.get(0).getId(), masterDomain.getId()));
        } catch (VdcBLLException e) {
        // Do nothing, exception already printed at logs
        }
        StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).disconnectStorageFromDomainByVdsId(masterDomain, vdss.get(0).getId());
        removeDomainFromDb(masterDomain);
    }
    runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    return retVal;
}
#method_after
private boolean regularRemoveStorageDomains(List<StorageDomain> storageDomains) {
    boolean retVal = true;
    List<StorageDomain> temp = LinqUtils.filter(storageDomains, new Predicate<StorageDomain>() {

        @Override
        public boolean eval(StorageDomain storage_domain) {
            return storage_domain.getStorageDomainType() == StorageDomainType.Master;
        }
    });
    final StorageDomain masterDomain = LinqUtils.first(temp);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(masterDomain.getStoragePoolIsoMapData());
            masterDomain.setStatus(StorageDomainStatus.Locked);
            getDbFacade().getStoragePoolIsoMapDao().update(masterDomain.getStoragePoolIsoMapData());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // destroying a pool is an SPM action. We need to connect all hosts
    // to the pool. Later on, during spm election, one of the hosts will
    // lock the pool
    // and the spm status will be FREE. Only then we can invoke the
    // destroy verb.
    connectAllHostToPoolAndDomain(masterDomain);
    List<VDS> vdss = getAllRunningVdssInPool();
    for (StorageDomain storageDomain : storageDomains) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            if (!removeDomainFromPool(storageDomain, vdss.get(0))) {
                log.errorFormat("Unable to detach storage domain {0} {1}", storageDomain.getStorageName(), storageDomain.getId());
                retVal = false;
            }
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            detachStorageDomainWithEntities(masterDomain);
            getCompensationContext().snapshotEntity(masterDomain.getStorageStaticData());
            masterDomain.setStorageDomainType(StorageDomainType.Data);
            getDbFacade().getStorageDomainStaticDao().update(masterDomain.getStorageStaticData());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    handleDestroyStoragePoolCommand();
    setSucceeded(true);
    if (!getStoragePool().isLocal()) {
        for (VDS vds : vdss) {
            StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).disconnectStorageFromDomainByVdsId(masterDomain, vds.getId());
        }
    } else {
        try {
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FormatStorageDomain, new FormatStorageDomainVDSCommandParameters(vdss.get(0).getId(), masterDomain.getId()));
        } catch (VdcBLLException e) {
        // Do nothing, exception already printed at logs
        }
        StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).disconnectStorageFromDomainByVdsId(masterDomain, vdss.get(0).getId());
        removeDomainFromDb(masterDomain);
    }
    runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    return retVal;
}
#end_block

#method_before
@Override
public void processOnVmStop(Collection<Guid> vmIds) {
    for (final Guid vmId : vmIds) {
        log.infoFormat("process VM {0} that went down", vmId);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                Backend.getInstance().runInternalAction(VdcActionType.ProcessDownVm, new IdParameters(vmId), ExecutionHandler.createInternalJobContext());
            }
        });
    }
}
#method_after
@Override
public void processOnVmStop(final Collection<Guid> vmIds) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            for (Guid vmId : vmIds) {
                Backend.getInstance().runInternalAction(VdcActionType.ProcessDownVm, new IdParameters(vmId));
            }
        }
    });
}
#end_block

#method_before
@Override
public void storagePoolUpEvent(StoragePool storagePool) {
    AsyncTaskManager.getInstance().addStoragePoolExistingTasks(storagePool);
}
#method_after
@Override
public void storagePoolUpEvent(StoragePool storagePool) {
    TaskManagerUtil.addStoragePoolExistingTasks(storagePool);
}
#end_block

#method_before
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
        if (refreshedCapabilities) {
            _vdsManager.updateNumaData(_vds);
        }
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
        saveCpuStatisticsDataToDb();
        saveNumaStatisticsDataToDb();
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#method_after
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
        if (refreshedCapabilities) {
            _vdsManager.updateNumaData(_vds);
        }
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
        saveCpuStatisticsDataToDb();
        saveNumaStatisticsDataToDb();
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllDiskImageDynamicWithDiskId(_vmDiskImageDynamicToSave);
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmJobsToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#end_block

#method_before
protected void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    if (fetchRunningVms()) {
        // refreshCommitedMemory must be called before we modify _runningVms, because
        // we iterate over it there, assuming it is the same as it was received from VDSM
        refreshCommitedMemory();
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    }
}
#method_after
protected void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    // Retrieve the list of existing jobs and/or job placeholders.  Only these jobs
    // are allowed to be updated by updateVmJobs()
    refreshExistingVmJobList();
    if (fetchRunningVms()) {
        // refreshCommitedMemory must be called before we modify _runningVms, because
        // we iterate over it there, assuming it is the same as it was received from VDSM
        refreshCommitedMemory();
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
        updateVmJobs();
    }
}
#end_block

#method_before
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        for (DiskImageDynamic imageDynamic : _runningVms.get(vmToUpdate.getId()).getVmDynamic().getDisks()) {
            Disk disk = getDbFacade().getDiskDao().get(imageDynamic.getId());
            // We also check if the disk is null, as, for external VMs the disk is not in the database
            if (disk != null && disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                Guid activeImageId = diskImage.getImageId();
                imageDynamic.setId(activeImageId);
                _vmDiskImageDynamicToSave.put(activeImageId, imageDynamic);
            }
        }
    }
}
#method_after
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        _vmDiskImageDynamicToSave.addAll(_runningVms.get(vmToUpdate.getId()).getVmDynamic().getDisks());
    }
}
#end_block

#method_before
public String getInnerJoin(String searchObj, String crossRefObj, boolean useTags) {
    final String[] joinKey = mJoinDictionary.get(StringFormat.format("%1$s.%2$s", searchObj, crossRefObj));
    final String crossRefTable = getRelatedTableName(crossRefObj, true);
    final String searchObjTable = getRelatedTableName(searchObj, useTags);
    return StringFormat.format(" LEFT OUTER JOIN %3$s ON %1$s.%2$s=%3$s.%4$s ", searchObjTable, joinKey[0], crossRefTable, joinKey[1]);
}
#method_after
public String getInnerJoin(String searchObj, String crossRefObj, boolean useTags) {
    final String[] joinKey = mJoinDictionary.get(StringFormat.format("%1$s.%2$s", searchObj, crossRefObj));
    // For joins, the table we join with is always the full view (including the tags)
    final String crossRefTable = getRelatedTableName(crossRefObj, true);
    final String searchObjTable = getRelatedTableName(searchObj, useTags);
    return StringFormat.format(" LEFT OUTER JOIN %3$s ON %1$s.%2$s=%3$s.%4$s ", searchObjTable, joinKey[0], crossRefTable, joinKey[1]);
}
#end_block

#method_before
public String getRelatedTableName(String obj, boolean useTags) {
    if (useTags) {
        return getRelatedTableName(obj);
    }
    return getRelatedTableNameWithOutTags(obj);
}
#method_after
public String getRelatedTableName(String obj, boolean useTags) {
    if (useTags) {
        return getRelatedTableName(obj);
    }
    return getRelatedTableNameWithoutTags(obj);
}
#end_block

#method_before
private String generateSqlFromSyntaxContainer(SyntaxContainer syntax, boolean isSafe) {
    String retval = "";
    if (syntax.getvalid()) {
        ListIterator<SyntaxObject> objIter = syntax.listIterator(0);
        IConditionFieldAutoCompleter conditionFieldAC;
        LinkedList<String> whereBuilder = new LinkedList<String>();
        String searchObjStr = syntax.getSearchObjectStr();
        String sortByPhrase = "";
        String fromStatement = "";
        String pageNumber = "";
        boolean useTags = syntax.isTags();
        while (objIter.hasNext()) {
            SyntaxObject obj = objIter.next();
            switch(obj.getType()) {
                case SEARCH_OBJECT:
                    fromStatement = generateFromStatement(syntax, useTags);
                    break;
                case OR:
                case AND:
                    whereBuilder.addLast(obj.getBody());
                    break;
                case CONDITION_VALUE:
                    whereBuilder.addLast(generateConditionStatment(obj, syntax.listIterator(objIter.previousIndex()), searchObjStr, syntax.getCaseSensitive(), isSafe, useTags));
                    break;
                case SORTBY:
                    break;
                case PAGE_VALUE:
                    pageNumber = obj.getBody();
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                    sortByPhrase = StringFormat.format(" ORDER BY %1$s", conditionFieldAC.getSortableDbField(obj.getBody()));
                    break;
                case SORT_DIRECTION:
                    // Forcing any sorting using DESC to show NULL values last (NULLS FIRST is the default)
                    String direction = (obj.getBody().equalsIgnoreCase("desc")) ? "DESC NULLS LAST" : obj.getBody();
                    sortByPhrase = StringFormat.format("%1$s %2$s", sortByPhrase, direction);
                    break;
                default:
                    break;
            }
        }
        // implying precedence rules
        String[] lookFor = { "AND", "OR" };
        for (int idx = 0; idx < lookFor.length; idx++) {
            boolean found = true;
            while (found) {
                found = false;
                ListIterator<String> iter = whereBuilder.listIterator(0);
                while (iter.hasNext()) {
                    String queryPart = iter.next();
                    if (lookFor[idx].equals(queryPart)) {
                        iter.remove();
                        String nextPart = iter.next();
                        iter.remove();
                        String prevPart = iter.previous();
                        iter.set(StringFormat.format("( %1$s %2$s %3$s )", prevPart, queryPart, nextPart));
                        found = true;
                        break;
                    }
                }
            }
        }
        // Add special handling (not deleted) to event searches
        if (searchObjStr.equalsIgnoreCase("EVENT")) {
            whereBuilder.add("not deleted");
        }
        // adding WHERE if required and All implicit AND
        StringBuilder wherePhrase = new StringBuilder();
        if (whereBuilder.size() > 0) {
            wherePhrase.append(" WHERE ");
            ListIterator<String> iter = whereBuilder.listIterator(0);
            while (iter.hasNext()) {
                String queryPart = iter.next();
                wherePhrase.append(queryPart);
                if (iter.hasNext()) {
                    wherePhrase.append(" AND ");
                }
            }
        }
        // adding the sorting part if required
        if ("".equals(sortByPhrase)) {
            sortByPhrase = " ORDER BY " + mSearchObjectAC.getDefaultSort(searchObjStr);
        }
        // adding the paging phrase
        String pagePhrase = getPagePhrase(syntax, pageNumber);
        String primeryKey = mSearchObjectAC.getPrimeryKeyName(searchObjStr);
        String tableName = mSearchObjectAC.getRelatedTableName(searchObjStr, useTags);
        // adding a secondary default sort by entity name
        StringBuilder sortExpr = new StringBuilder();
        sortExpr.append(sortByPhrase);
        if (sortByPhrase.indexOf(mSearchObjectAC.getDefaultSort(searchObjStr)) < 0) {
            sortExpr.append(",");
            sortExpr.append(mSearchObjectAC.getDefaultSort(searchObjStr));
        }
        // TODO: The database configuration PostgresSearchTemplate has an extra closing braces. Hence our
        // queries in this code have an extra opening one. Fix it in a future patch.
        String inQuery = "";
        if (useTags) {
            inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s IN (%3$s)", mSearchObjectAC.getRelatedTableName(searchObjStr, false), primeryKey, getInnerQuery(tableName, primeryKey, fromStatement, wherePhrase));
        } else {
            inQuery = "(" + getInnerQuery(tableName, "*", fromStatement, wherePhrase);
        }
        retval = StringFormat.format(Config.<String>getValue(ConfigValues.DBSearchTemplate), sortExpr.toString(), inQuery, pagePhrase);
        // Check for sql injection if query is not safe
        if (!isSafe) {
            if (sqlInjectionChecker.hasSqlInjection(retval)) {
                throw new SqlInjectionException();
            }
        }
        log.trace("Search: " + retval);
    }
    return retval;
}
#method_after
private String generateSqlFromSyntaxContainer(SyntaxContainer syntax, boolean isSafe) {
    String retval = "";
    if (syntax.getvalid()) {
        ListIterator<SyntaxObject> objIter = syntax.listIterator(0);
        IConditionFieldAutoCompleter conditionFieldAC;
        LinkedList<String> whereBuilder = new LinkedList<String>();
        String searchObjStr = syntax.getSearchObjectStr();
        String sortByPhrase = "";
        String fromStatement = "";
        String pageNumber = "";
        boolean useTags = syntax.isSearchUsingTags();
        while (objIter.hasNext()) {
            SyntaxObject obj = objIter.next();
            switch(obj.getType()) {
                case SEARCH_OBJECT:
                    fromStatement = generateFromStatement(syntax, useTags);
                    break;
                case OR:
                case AND:
                    whereBuilder.addLast(obj.getBody());
                    break;
                case CONDITION_VALUE:
                    whereBuilder.addLast(generateConditionStatment(obj, syntax.listIterator(objIter.previousIndex()), searchObjStr, syntax.getCaseSensitive(), isSafe, useTags));
                    break;
                case SORTBY:
                    break;
                case PAGE_VALUE:
                    pageNumber = obj.getBody();
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                    sortByPhrase = StringFormat.format(" ORDER BY %1$s", conditionFieldAC.getSortableDbField(obj.getBody()));
                    break;
                case SORT_DIRECTION:
                    // Forcing any sorting using DESC to show NULL values last (NULLS FIRST is the default)
                    String direction = (obj.getBody().equalsIgnoreCase("desc")) ? "DESC NULLS LAST" : obj.getBody();
                    sortByPhrase = StringFormat.format("%1$s %2$s", sortByPhrase, direction);
                    break;
                default:
                    break;
            }
        }
        // implying precedence rules
        String[] lookFor = { "AND", "OR" };
        for (int idx = 0; idx < lookFor.length; idx++) {
            boolean found = true;
            while (found) {
                found = false;
                ListIterator<String> iter = whereBuilder.listIterator(0);
                while (iter.hasNext()) {
                    String queryPart = iter.next();
                    if (lookFor[idx].equals(queryPart)) {
                        iter.remove();
                        String nextPart = iter.next();
                        iter.remove();
                        String prevPart = iter.previous();
                        iter.set(StringFormat.format("( %1$s %2$s %3$s )", prevPart, queryPart, nextPart));
                        found = true;
                        break;
                    }
                }
            }
        }
        // for not deleted events, add this to the where clause
        if (searchObjStr.equalsIgnoreCase("EVENT")) {
            whereBuilder.add("not deleted");
        }
        // adding WHERE if required and All implicit AND
        StringBuilder wherePhrase = new StringBuilder();
        if (whereBuilder.size() > 0) {
            wherePhrase.append(" WHERE ");
            ListIterator<String> iter = whereBuilder.listIterator(0);
            while (iter.hasNext()) {
                String queryPart = iter.next();
                wherePhrase.append(queryPart);
                if (iter.hasNext()) {
                    wherePhrase.append(" AND ");
                }
            }
        }
        // adding the sorting part if required
        if ("".equals(sortByPhrase)) {
            sortByPhrase = " ORDER BY " + mSearchObjectAC.getDefaultSort(searchObjStr);
        }
        // adding the paging phrase
        String pagePhrase = getPagePhrase(syntax, pageNumber);
        String primeryKey = mSearchObjectAC.getPrimeryKeyName(searchObjStr);
        String tableName = mSearchObjectAC.getRelatedTableName(searchObjStr, useTags);
        // adding a secondary default sort by entity name
        StringBuilder sortExpr = new StringBuilder();
        sortExpr.append(sortByPhrase);
        if (sortByPhrase.indexOf(mSearchObjectAC.getDefaultSort(searchObjStr)) < 0) {
            sortExpr.append(",");
            sortExpr.append(mSearchObjectAC.getDefaultSort(searchObjStr));
        }
        // TODO: The database configuration PostgresSearchTemplate has an extra closing braces. Hence our
        // queries in this code have an extra opening one. Fix it in a future patch.
        String inQuery = "";
        if (useTags) {
            inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s IN (%3$s)", mSearchObjectAC.getRelatedTableName(searchObjStr, false), primeryKey, getInnerQuery(tableName, primeryKey, fromStatement, wherePhrase));
        } else {
            inQuery = "(" + getInnerQuery(tableName, "*", fromStatement, wherePhrase);
        }
        retval = StringFormat.format(Config.<String>getValue(ConfigValues.DBSearchTemplate), sortExpr.toString(), inQuery, pagePhrase);
        // Check for sql injection if query is not safe
        if (!isSafe) {
            if (sqlInjectionChecker.hasSqlInjection(retval)) {
                throw new SqlInjectionException();
            }
        }
        log.trace("Search: " + retval);
    }
    return retval;
}
#end_block

#method_before
@Test
public void testHost() {
    testValidSql("Host: sortby cpu_usage desc", "SELECT * FROM ((SELECT vds.* FROM  vds  )  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    // Before: 19ms
    // "SELECT * FROM (SELECT * FROM vds WHERE ( vds_id IN (SELECT vds_with_tags.vds_id FROM  vds_with_tags   WHERE  vds_with_tags.vds_name LIKE 'test1' ))  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0"
    // Current: 5ms
    testValidSql("Host: name =\"test1\" sortby cpu_usage desc", "SELECT * FROM ((SELECT vds.* FROM  vds   WHERE  vds.vds_name LIKE test1 )  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    // Before: 17ms
    // "SELECT * FROM (SELECT * FROM vds WHERE ( vds_id IN (SELECT vds_with_tags.vds_id FROM  vds_with_tags   WHERE  vds_with_tags.usage_cpu_percent > 80 ))  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0"
    // Current: 5ms
    testValidSql("Host: CPU_USAGE > 80 sortby cpu_usage desc", "SELECT * FROM ((SELECT vds.* FROM  vds   WHERE  vds.usage_cpu_percent > 80 )  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    // Before: 25ms
    // "SELECT * FROM (SELECT * FROM vds WHERE ( vds_id IN (SELECT vds_with_tags.vds_id FROM  vds_with_tags   LEFT OUTER JOIN vdc_users_with_tags ON vds_with_tags.vds_id=vdc_users_with_tags.vm_guid    WHERE  vdc_users_with_tags.name LIKE user1 ))  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0"
    // Current: 10ms
    testValidSql("Host: user.name = \"user1\" sortby cpu_usage desc", "SELECT * FROM ((SELECT vds.* FROM  vds   LEFT OUTER JOIN vdc_users_with_tags ON vds.vds_id=vdc_users_with_tags.vm_guid    WHERE  vdc_users_with_tags.name LIKE user1 )  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    // Before: 63ms
    // "SELECT * FROM (SELECT * FROM vds WHERE ( storage_pool_id IN (SELECT storage_pool_id FROM storage_domains WHERE  storage_domains.storage_name LIKE 'pool1'))  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0"
    // Current: 68ms
    testValidSql("Host: STORAGE.name = \"pool1\" sortby cpu_usage desc", "SELECT * FROM ((SELECT vds.* FROM  vds   LEFT OUTER JOIN storage_domains_with_hosts_view ON vds.storage_pool_id=storage_domains_with_hosts_view.storage_pool_id    WHERE  storage_domains_with_hosts_view.storage_name LIKE pool1 )  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    // Before: 23ms
    // "SELECT * FROM (SELECT * FROM vds WHERE ( vds_id IN (SELECT vds_with_tags.vds_id FROM  vds_with_tags   LEFT OUTER JOIN audit_log ON vds_with_tags.vds_id=audit_log.vds_id    WHERE (  audit_log.severity = '2'  AND  vds_with_tags.usage_cpu_percent > 80  )))  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0"
    // Current: 9ms
    testValidSql("Host: EVENT.severity=error and CPU_USAGE > 80 sortby cpu_usage desc", "SELECT * FROM ((SELECT vds.* FROM  vds   LEFT OUTER JOIN audit_log ON vds.vds_id=audit_log.vds_id    WHERE (  audit_log.severity = '2'  AND  vds.usage_cpu_percent > 80  ))  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    testValidSql("Host: EVENT.severity=error and tag=tag1 sortby cpu_usage desc", "SELECT * FROM (SELECT * FROM vds WHERE ( vds_id IN (SELECT vds_with_tags.vds_id FROM  vds_with_tags   LEFT OUTER JOIN audit_log ON vds_with_tags.vds_id=audit_log.vds_id    WHERE (  audit_log.severity = '2'  AND  vds_with_tags.tag_name IN (tag1)  )))  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    testValidSql("Host: tag=\"tag1\"", "SELECT * FROM (SELECT * FROM vds WHERE ( vds_id IN (SELECT vds_with_tags.vds_id FROM  vds_with_tags   WHERE  vds_with_tags.tag_name IN (tag1) ))  ORDER BY vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    // Before: 22ms
    // "SELECT * FROM (SELECT * FROM vds WHERE ( vds_id IN (SELECT vds_with_tags.vds_id FROM  vds_with_tags   LEFT OUTER JOIN vms_with_tags ON vds_with_tags.vds_id=vms_with_tags.run_on_vds    WHERE  vms_with_tags.vm_name LIKE 'vm1' ))  ORDER BY vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0"
    // Current: 11ms
    testValidSql("Host: vm.name=\"vm1\"", "SELECT * FROM ((SELECT vds.* FROM  vds   LEFT OUTER JOIN vms_with_tags ON vds.vds_id=vms_with_tags.run_on_vds    WHERE  vms_with_tags.vm_name LIKE vm1 )  ORDER BY vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    testValidSql("Vms: cluster = default and Hosts.tag = tag_1 and Templates.name = template_1 and Storage.name = storage_1", "SELECT * FROM (SELECT * FROM vms WHERE ( vm_guid IN (SELECT vms_with_tags.vm_guid FROM  vms_with_tags   LEFT OUTER JOIN vds_with_tags ON vms_with_tags.run_on_vds=vds_with_tags.vds_id    LEFT OUTER JOIN vm_templates_storage_domain ON vms_with_tags.vmt_guid=vm_templates_storage_domain.vmt_guid    LEFT OUTER JOIN storage_domains_with_hosts_view ON vms_with_tags.storage_id=storage_domains_with_hosts_view.id    WHERE ( ( (  vms.vds_group_name LIKE default  AND  vds_with_tags.tag_name IN (tag1)  ) AND  vm_templates_storage_domain.name LIKE template\\_1  ) AND  storage_domains_with_hosts_view.storage_name LIKE storage\\_1  )))  ORDER BY vm_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    testValidSql("Vms: cluster = default and Hosts.tag = tag_1 and Templates.name = template_1 and Storage.name = storage_1 and Vnic.network_name = vnic_1", "SELECT * FROM (SELECT * FROM vms WHERE ( vm_guid IN (SELECT vms_with_tags.vm_guid FROM  vms_with_tags   LEFT OUTER JOIN vds_with_tags ON vms_with_tags.run_on_vds=vds_with_tags.vds_id    LEFT OUTER JOIN vm_templates_storage_domain ON vms_with_tags.vmt_guid=vm_templates_storage_domain.vmt_guid    LEFT OUTER JOIN storage_domains_with_hosts_view ON vms_with_tags.storage_id=storage_domains_with_hosts_view.id    LEFT OUTER JOIN vm_interface_view ON vms_with_tags.vm_guid=vm_interface_view.vm_guid    WHERE ( ( ( (  vms.vds_group_name LIKE default  AND  vds_with_tags.tag_name IN (tag1)  ) AND  vm_templates_storage_domain.name LIKE template\\_1  ) AND  storage_domains_with_hosts_view.storage_name LIKE storage\\_1  ) AND  vm_interface_view.network_name LIKE vnic\\_1  )))  ORDER BY vm_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
}
#method_after
@Test
public void testHost() {
    testValidSql("Host: sortby cpu_usage desc", "SELECT * FROM ((SELECT vds.* FROM  vds  )  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    // Before: 19ms
    // "SELECT * FROM (SELECT * FROM vds WHERE ( vds_id IN (SELECT vds_with_tags.vds_id FROM  vds_with_tags   WHERE  vds_with_tags.vds_name LIKE 'test1' ))  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0"
    // Current: 5ms
    testValidSql("Host: name =\"test1\" sortby cpu_usage desc", "SELECT * FROM ((SELECT vds.* FROM  vds   WHERE  vds.vds_name LIKE test1 )  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    // Before: 17ms
    // "SELECT * FROM (SELECT * FROM vds WHERE ( vds_id IN (SELECT vds_with_tags.vds_id FROM  vds_with_tags   WHERE  vds_with_tags.usage_cpu_percent > 80 ))  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0"
    // Current: 5ms
    testValidSql("Host: CPU_USAGE > 80 sortby cpu_usage desc", "SELECT * FROM ((SELECT vds.* FROM  vds   WHERE  vds.usage_cpu_percent > 80 )  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    // Before: 25ms
    // "SELECT * FROM (SELECT * FROM vds WHERE ( vds_id IN (SELECT vds_with_tags.vds_id FROM  vds_with_tags   LEFT OUTER JOIN vdc_users_with_tags ON vds_with_tags.vds_id=vdc_users_with_tags.vm_guid    WHERE  vdc_users_with_tags.name LIKE user1 ))  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0"
    // Current: 10ms
    testValidSql("Host: user.name = \"user1\" sortby cpu_usage desc", "SELECT * FROM ((SELECT vds.* FROM  vds   LEFT OUTER JOIN vdc_users_with_tags ON vds.vds_id=vdc_users_with_tags.vm_guid    WHERE  vdc_users_with_tags.name LIKE user1 )  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    // Before: 63ms
    // "SELECT * FROM (SELECT * FROM vds WHERE ( storage_pool_id IN (SELECT storage_pool_id FROM storage_domains WHERE  storage_domains.storage_name LIKE 'pool1'))  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0"
    // Current: 68ms
    testValidSql("Host: STORAGE.name = \"pool1\" sortby cpu_usage desc", "SELECT * FROM ((SELECT vds.* FROM  vds   LEFT OUTER JOIN storage_domains_with_hosts_view ON vds.storage_pool_id=storage_domains_with_hosts_view.storage_pool_id    WHERE  storage_domains_with_hosts_view.storage_name LIKE pool1 )  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    // Before: 23ms
    // "SELECT * FROM (SELECT * FROM vds WHERE ( vds_id IN (SELECT vds_with_tags.vds_id FROM  vds_with_tags   LEFT OUTER JOIN audit_log ON vds_with_tags.vds_id=audit_log.vds_id    WHERE (  audit_log.severity = '2'  AND  vds_with_tags.usage_cpu_percent > 80  )))  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0"
    // Current: 9ms
    testValidSql("Host: EVENT.severity=error and CPU_USAGE > 80 sortby cpu_usage desc", "SELECT * FROM ((SELECT vds.* FROM  vds   LEFT OUTER JOIN audit_log ON vds.vds_id=audit_log.vds_id    WHERE (  audit_log.severity = '2'  AND  vds.usage_cpu_percent > 80  ))  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    testValidSql("Host: EVENT.severity=error and tag=tag1 sortby cpu_usage desc", "SELECT * FROM (SELECT * FROM vds WHERE ( vds_id IN (SELECT vds_with_tags.vds_id FROM  vds_with_tags   LEFT OUTER JOIN audit_log ON vds_with_tags.vds_id=audit_log.vds_id    WHERE (  audit_log.severity = '2'  AND  vds_with_tags.tag_name IN (tag1)  )))  ORDER BY usage_cpu_percent DESC NULLS LAST,vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    testValidSql("Host: tag=\"tag1\"", "SELECT * FROM (SELECT * FROM vds WHERE ( vds_id IN (SELECT vds_with_tags.vds_id FROM  vds_with_tags   WHERE  vds_with_tags.tag_name IN (tag1) ))  ORDER BY vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    // Before: 22ms
    // "SELECT * FROM (SELECT * FROM vds WHERE ( vds_id IN (SELECT vds_with_tags.vds_id FROM  vds_with_tags   LEFT OUTER JOIN vms_with_tags ON vds_with_tags.vds_id=vms_with_tags.run_on_vds    WHERE  vms_with_tags.vm_name LIKE 'vm1' ))  ORDER BY vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0"
    // Current: 11ms
    testValidSql("Host: vm.name=\"vm1\"", "SELECT * FROM ((SELECT vds.* FROM  vds   LEFT OUTER JOIN vms_with_tags ON vds.vds_id=vms_with_tags.run_on_vds    WHERE  vms_with_tags.vm_name LIKE vm1 )  ORDER BY vds_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    testValidSql("Vms: cluster = default and Templates.name = template_1 and Storage.name = storage_1", "SELECT * FROM (SELECT * FROM vms WHERE ( vm_guid IN (SELECT vms_with_tags.vm_guid FROM  vms_with_tags   LEFT OUTER JOIN vm_templates_storage_domain ON vms_with_tags.vmt_guid=vm_templates_storage_domain.vmt_guid    LEFT OUTER JOIN storage_domains_with_hosts_view ON vms_with_tags.storage_id=storage_domains_with_hosts_view.id    WHERE ( (  vms.vds_group_name LIKE default  AND  vm_templates_storage_domain.name LIKE template\\_1  ) AND  storage_domains_with_hosts_view.storage_name LIKE storage\\_1  )))  ORDER BY vm_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    testValidSql("Vms: cluster = default and Templates.name = template_1 and Storage.name = storage_1 and Vnic.network_name = vnic_1", "SELECT * FROM (SELECT * FROM vms WHERE ( vm_guid IN (SELECT vms_with_tags.vm_guid FROM  vms_with_tags   LEFT OUTER JOIN vm_templates_storage_domain ON vms_with_tags.vmt_guid=vm_templates_storage_domain.vmt_guid    LEFT OUTER JOIN storage_domains_with_hosts_view ON vms_with_tags.storage_id=storage_domains_with_hosts_view.id    LEFT OUTER JOIN vm_interface_view ON vms_with_tags.vm_guid=vm_interface_view.vm_guid    WHERE ( ( (  vms.vds_group_name LIKE default  AND  vm_templates_storage_domain.name LIKE template\\_1  ) AND  storage_domains_with_hosts_view.storage_name LIKE storage\\_1  ) AND  vm_interface_view.network_name LIKE vnic\\_1  )))  ORDER BY vm_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
}
#end_block

#method_before
@Test
public void testStorage() {
    testValidSql("Storage: ", "SELECT * FROM ((SELECT storage_domains_for_search.* FROM  storage_domains_for_search  )  ORDER BY storage_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    testValidSql("Storage: datacenter = Default", "SELECT * FROM ((SELECT storage_domains_for_search.* FROM  storage_domains_for_search   WHERE  storage_domains_for_search.storage_pool_name::text LIKE Default )  ORDER BY storage_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
}
#method_after
@Test
public void testStorage() {
    testValidSql("Storage: ", "SELECT * FROM ((SELECT storage_domains_for_search.* FROM  storage_domains_for_search  )  ORDER BY storage_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    testValidSql("Storage: datacenter = Default", "SELECT * FROM ((SELECT storage_domains_for_search.* FROM  storage_domains_for_search   WHERE  storage_domains_for_search.storage_pool_name::text LIKE Default )  ORDER BY storage_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    testValidSql("Storage: host.name = fake1", "SELECT * FROM ((SELECT storage_domains_for_search.* FROM  storage_domains_for_search   LEFT OUTER JOIN vds_with_tags ON storage_domains_for_search.storage_pool_id=vds_with_tags.storage_pool_id    WHERE  vds_with_tags.vds_name LIKE fake1 )  ORDER BY storage_name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
}
#end_block

#method_before
public static List<String> initRange(String start, String end, int size) {
    try {
        long startNum = macStringToLong(start);
        long endNum = macStringToLong(end);
        return innerInitRange(size, startNum, endNum);
    } catch (InvalidMacString e) {
        LOGGER.warn(e);
        return Collections.emptyList();
    }
}
#method_after
public static List<String> initRange(String start, String end, int size) {
    long startNum = macToLong(start);
    long endNum = macToLong(end);
    return innerInitRange(size, startNum, endNum);
}
#end_block

#method_before
private static List<String> innerInitRange(int stopAfter, long startNum, long endNum) {
    if (startNum > endNum) {
        return Collections.emptyList();
    }
    // Initialize ArrayList for all potential records. (ignore that there need not be that many records.
    List<String> macAddresses = new ArrayList<>(Math.min(stopAfter, (int) (endNum - startNum)));
    for (long i = startNum; i <= endNum; i++) {
        if (macHasMultiCastBitSet(i)) {
            continue;
        }
        macAddresses.add(macAddressToString(i));
        if (--stopAfter <= 0) {
            return macAddresses;
        }
    }
    // Do a copy to reduce array length (array stored in ArrayList impl.)
    return new ArrayList<>(macAddresses);
}
#method_after
private static List<String> innerInitRange(int stopAfter, long startNum, long endNum) {
    if (startNum > endNum) {
        return Collections.emptyList();
    }
    // Initialize ArrayList for all potential records. (ignore that there need not be that many records.
    List<String> macAddresses = new ArrayList<>(Math.min(stopAfter, (int) (endNum - startNum)));
    for (long i = startNum; i <= endNum; i++) {
        if (macIsMulticast(i)) {
            continue;
        }
        macAddresses.add(macToString(i));
        if (--stopAfter <= 0) {
            return macAddresses;
        }
    }
    return macAddresses;
}
#end_block

#method_before
public static boolean isRangeValid(String start, String end) {
    List<String> result;
    try {
        long startNum = macStringToLong(start);
        long endNum = macStringToLong(end);
        result = innerInitRange(1, startNum, endNum);
    } catch (InvalidMacString e) {
        LOGGER.warn(e);
        result = Collections.emptyList();
    }
    return !result.isEmpty();
}
#method_after
public static boolean isRangeValid(String start, String end) {
    long startNum = macToLong(start);
    long endNum = macToLong(end);
    return !innerInitRange(1, startNum, endNum).isEmpty();
}
#end_block

#method_before
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#method_after
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
        if (refreshedCapabilities) {
            _vdsManager.updateNumaData(_vds);
        }
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
        saveCpuStatisticsDataToDb();
        saveNumaStatisticsDataToDb();
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllDiskImageDynamicWithDiskId(_vmDiskImageDynamicToSave);
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmJobsToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#end_block

#method_before
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        reportNicStatusChanges();
        Pair<List<String>, List<String>> problematicNics = NetworkMonitoringHelper.determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String networkNames = StringUtils.join(networks, ", ");
                String nicNames = StringUtils.join(brokenNics, ", ");
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), nicNames, networkNames);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", networkNames);
                logable.addCustomValue("Interfaces", nicNames);
                logable.setCustomId(nicNames + networkNames);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#method_after
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    Map<String, Set<String>> problematicNicsWithNetworks = new HashMap<String, Set<String>>();
    try {
        reportNicStatusChanges();
        problematicNicsWithNetworks = NetworkMonitoringHelper.determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!problematicNicsWithNetworks.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String problematicNicsWithNetworksString = constructNicsWithNetworksString(problematicNicsWithNetworks);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.infoFormat("Host '{0}' moved to Non-Operational state because interface/s which are down are needed by required network/s in the current cluster: '{1}'", _vds.getName(), problematicNicsWithNetworksString);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("NicsWithNetworks", problematicNicsWithNetworksString);
                logable.setCustomId(problematicNicsWithNetworksString);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#end_block

#method_before
protected void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    if (fetchRunningVms()) {
        // refreshCommitedMemory must be called before we modify _runningVms, because
        // we iterate over it there, assuming it is the same as it was received from VDSM
        refreshCommitedMemory();
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    }
}
#method_after
protected void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    // Retrieve the list of existing jobs and/or job placeholders.  Only these jobs
    // are allowed to be updated by updateVmJobs()
    refreshExistingVmJobList();
    if (fetchRunningVms()) {
        // refreshCommitedMemory must be called before we modify _runningVms, because
        // we iterate over it there, assuming it is the same as it was received from VDSM
        refreshCommitedMemory();
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
        updateVmJobs();
    }
}
#end_block

#method_before
private void updateRepository(List<Guid> staleRunningVms) {
    // Preload all disks and their image ID for all running VMs
    List<Guid> requiredDisks = new ArrayList<>();
    for (VmInternalData vmInternalData : _runningVms.values()) {
        for (DiskImageDynamic disk : vmInternalData.getVmDynamic().getDisks()) {
            requiredDisks.add(disk.getId());
        }
    }
    Map<Guid, Guid> diskImages = getDbFacade().getImageDao().getImageIdForDisks(requiredDisks);
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate, diskImages);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#method_after
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#end_block

#method_before
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()), VmExitReason.GenericError);
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#method_after
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean migrating = vmToRemove.getStatus() == VMStatus.MigratingFrom;
        if (migrating) {
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()), VmExitReason.GenericError);
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        Guid vmGuid = vmToRemove.getId();
        if (!migrating && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal)) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#end_block

#method_before
private void updateVmStatistics(VM vmToUpdate, Map<Guid, Guid> diskImages) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        try {
            for (DiskImageDynamic imageDynamic : _runningVms.get(vmToUpdate.getId()).getVmDynamic().getDisks()) {
                Guid activeImageId = diskImages.get(imageDynamic.getId());
                // We also check if the disk is null, as, for external VMs the disk is not in the database
                if (activeImageId != null) {
                    imageDynamic.setId(activeImageId);
                    _vmDiskImageDynamicToSave.put(activeImageId, imageDynamic);
                }
            }
        } catch (Exception e) {
            log.error("Can't load statistics data", e);
        }
    }
}
#method_after
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        _vmDiskImageDynamicToSave.addAll(_runningVms.get(vmToUpdate.getId()).getVmDynamic().getDisks());
    }
}
#end_block

#method_before
private void initUnregisteredVM() {
    OvfHelper ovfHelper = new OvfHelper();
    ovfEntityData = getUnregisteredOVFDataDao().getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (ovfEntityData != null) {
        try {
            vmFromConfiguration = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration.setVdsGroupId(getParameters().getVdsGroupId());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getImages(getParameters().getDiskMap()));
            }
        } catch (OvfReaderException e) {
            log.errorFormat("failed to parse a given ovf configuration: \n" + ovfEntityData.getOvfData(), e);
        }
    }
}
#method_after
private void initUnregisteredVM() {
    OvfHelper ovfHelper = new OvfHelper();
    ovfEntityData = getUnregisteredOVFDataDao().getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (ovfEntityData != null) {
        try {
            vmFromConfiguration = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration.setVdsGroupId(getParameters().getVdsGroupId());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
        } catch (OvfReaderException e) {
            log.errorFormat("failed to parse a given ovf configuration: \n" + ovfEntityData.getOvfData(), e);
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid vmId = getParameters().getId();
    VmPoolMap map = getVmPoolDAO().getVmPoolMapByVmGuid(vmId);
    List<DbUser> users = getDbUserDAO().getAllForVm(vmId);
    // Check if this is a Vm from a Vm pool, and is attached to a user
    if (map != null && users != null && !users.isEmpty()) {
        VmPool pool = getVmPoolDAO().get(map.getvm_pool_id());
        if (pool != null && pool.getVmPoolType() == VmPoolType.Automatic) {
            // should be only one user in the collection
            for (DbUser dbUser : users) {
                Backend.getInstance().runInternalAction(VdcActionType.DetachUserFromVmFromPool, new VmPoolSimpleUserParameters(map.getvm_pool_id(), dbUser.getId(), vmId), ExecutionHandler.createDefaultContexForTasks(getExecutionContext(), getLock()));
            }
        }
    } else {
        // If we are dealing with a prestarted Vm or a regular Vm - clean stateless images
        // Otherwise this was already done in DetachUserFromVmFromPoolCommand
        removeVmStatelessImages(vmId);
    }
    QuotaManager.getInstance().rollbackQuotaByVmId(vmId);
    VmHandler.removeStatelessVmUnmanagedDevices(vmId);
    applyNextRunConfiguration(vmId);
}
#method_after
@Override
protected void executeCommand() {
    boolean removedStatelessSnapshot = detachUsers();
    if (!removedStatelessSnapshot) {
        // If we are dealing with a prestarted Vm or a regular Vm - clean stateless images
        // Otherwise this was already done in DetachUserFromVmFromPoolCommand
        removeVmStatelessImages();
    }
    QuotaManager.getInstance().rollbackQuotaByVmId(getVmId());
    removeStatelessVmUnmanagedDevices();
    applyNextRunConfiguration();
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return null;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.emptyList();
}
#end_block

#method_before
private void applyNextRunConfiguration(Guid vmId) {
    // Remove snpashot first, in case other update is in progress, it will block this one with exclusive lock
    // and any newer update should be preffered to this one.
    Snapshot runSnap = getSnapshotDAO().get(vmId, SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDAO().remove(runSnap.getId());
        VM vm = DbFacade.getInstance().getVmDao().get(vmId);
        if (vm != null) {
            Date originalCreationDate = vm.getVmCreationDate();
            new SnapshotsManager().updateVmFromConfiguration(vm, runSnap.getVmConfiguration());
            // override creation date because the value in the config is the creation date of the config, not the vm
            vm.setVmCreationDate(originalCreationDate);
            VmManagementParametersBase updateVmParams = createUpdateVmParameters(vm);
            Backend.getInstance().runInternalAction(VdcActionType.UpdateVm, updateVmParams);
        }
    }
}
#method_after
private void applyNextRunConfiguration() {
    // Remove snpashot first, in case other update is in progress, it will block this one with exclusive lock
    // and any newer update should be preffered to this one.
    Snapshot runSnap = getSnapshotDAO().get(getVmId(), SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDAO().remove(runSnap.getId());
        Date originalCreationDate = getVm().getVmCreationDate();
        new SnapshotsManager().updateVmFromConfiguration(getVm(), runSnap.getVmConfiguration());
        // override creation date because the value in the config is the creation date of the config, not the vm
        getVm().setVmCreationDate(originalCreationDate);
        Backend.getInstance().runInternalAction(VdcActionType.UpdateVm, createUpdateVmParameters());
    }
}
#end_block

#method_before
private VmManagementParametersBase createUpdateVmParameters(VM vm) {
    // clear non updateable fields got from config
    vm.setExportDate(null);
    vm.setOvfVersion(null);
    VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vm);
    updateVmParams.setUpdateWatchdog(true);
    updateVmParams.setSoundDeviceEnabled(false);
    updateVmParams.setBalloonEnabled(false);
    updateVmParams.setVirtioScsiEnabled(false);
    updateVmParams.setClearPayload(true);
    for (VmDevice device : vm.getManagedVmDeviceMap().values()) {
        switch(device.getType()) {
            case WATCHDOG:
                updateVmParams.setWatchdog(new VmWatchdog(device));
                break;
            case SOUND:
                updateVmParams.setSoundDeviceEnabled(true);
                break;
            case BALLOON:
                updateVmParams.setBalloonEnabled(true);
                break;
            case CONTROLLER:
                if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    updateVmParams.setVirtioScsiEnabled(true);
                }
                break;
            case DISK:
                if (VmPayload.isPayload(device.getSpecParams())) {
                    updateVmParams.setVmPayload(new VmPayload(VmDeviceType.getByName(device.getDevice()), device.getSpecParams()));
                }
                break;
            case CONSOLE:
                updateVmParams.setConsoleEnabled(true);
                break;
            default:
        }
    }
    // clear these fields as these are non updatable
    vm.getManagedVmDeviceMap().clear();
    vm.getVmUnamagedDeviceList().clear();
    return updateVmParams;
}
#method_after
private VmManagementParametersBase createUpdateVmParameters() {
    // clear non updateable fields got from config
    getVm().setExportDate(null);
    getVm().setOvfVersion(null);
    VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getVm());
    updateVmParams.setUpdateWatchdog(true);
    updateVmParams.setSoundDeviceEnabled(false);
    updateVmParams.setBalloonEnabled(false);
    updateVmParams.setVirtioScsiEnabled(false);
    updateVmParams.setClearPayload(true);
    for (VmDevice device : getVm().getManagedVmDeviceMap().values()) {
        switch(device.getType()) {
            case WATCHDOG:
                updateVmParams.setWatchdog(new VmWatchdog(device));
                break;
            case SOUND:
                updateVmParams.setSoundDeviceEnabled(true);
                break;
            case BALLOON:
                updateVmParams.setBalloonEnabled(true);
                break;
            case CONTROLLER:
                if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    updateVmParams.setVirtioScsiEnabled(true);
                }
                break;
            case DISK:
                if (VmPayload.isPayload(device.getSpecParams())) {
                    updateVmParams.setVmPayload(new VmPayload(VmDeviceType.getByName(device.getDevice()), device.getSpecParams()));
                }
                break;
            case CONSOLE:
                updateVmParams.setConsoleEnabled(true);
                break;
            default:
        }
    }
    // clear these fields as these are non updatable
    getVm().getManagedVmDeviceMap().clear();
    getVm().getVmUnamagedDeviceList().clear();
    return updateVmParams;
}
#end_block

#method_before
private void removeVmStatelessImages(Guid vmId) {
    if (getSnapshotDAO().exists(vmId, SnapshotType.STATELESS)) {
        log.infoFormat("Deleting snapshot for stateless vm {0}", vmId);
        Backend.getInstance().runInternalAction(VdcActionType.RestoreStatelessVm, new VmOperationParameterBase(vmId), ExecutionHandler.createDefaultContexForTasks(getExecutionContext(), getLock()));
    }
}
#method_after
private void removeVmStatelessImages() {
    if (getSnapshotDAO().exists(getVmId(), SnapshotType.STATELESS)) {
        log.infoFormat("Deleting snapshot for stateless vm {0}", getVmId());
        Backend.getInstance().runInternalAction(VdcActionType.RestoreStatelessVm, new VmOperationParameterBase(getVmId()), ExecutionHandler.createDefaultContexForTasks(getExecutionContext(), getLock()));
    }
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<VM> nameColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "150px");
    TextColumnWithTooltip<VM> originColumn = new EnumColumn<VM, OriginType>() {

        @Override
        protected OriginType getRawValue(VM object) {
            return object.getOrigin();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(originColumn, constants.originVm(), "100px");
    TextColumnWithTooltip<VM> memoryColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            // $NON-NLS-1$
            return String.valueOf(object.getVmMemSizeMb()) + " MB";
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "100px");
    TextColumnWithTooltip<VM> cpuColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return String.valueOf(object.getNumOfCpus());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpusVm(), "100px");
    TextColumnWithTooltip<VM> archColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return String.valueOf(object.getClusterArch());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(archColumn, constants.architectureVm(), "100px");
    TextColumnWithTooltip<VM> diskColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return String.valueOf(object.getDiskMap().size());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(diskColumn, constants.disksVm(), "100px");
    TextColumnWithTooltip<VM> creationDateColumn = new GeneralDateTimeColumn<VM>() {

        @Override
        protected Date getRawValue(VM object) {
            return object.getVmCreationDate();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(creationDateColumn, constants.creationDateVm(), "200px");
    TextColumnWithTooltip<VM> exportDateColumn = new GeneralDateTimeColumn<VM>() {

        @Override
        protected Date getRawValue(VM object) {
            return object.getExportDate();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(exportDateColumn, constants.exportDateVm(), "200px");
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<VM> nameColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "150px");
    TextColumnWithTooltip<VM> originColumn = new EnumColumn<VM, OriginType>() {

        @Override
        protected OriginType getRawValue(VM object) {
            return object.getOrigin();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(originColumn, constants.originVm(), "100px");
    TextColumnWithTooltip<VM> memoryColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            // $NON-NLS-1$
            return String.valueOf(object.getVmMemSizeMb()) + " MB";
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "100px");
    TextColumnWithTooltip<VM> cpuColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return String.valueOf(object.getNumOfCpus());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpusVm(), "100px");
    TextColumnWithTooltip<VM> archColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return String.valueOf(object.getClusterArch());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(archColumn, constants.architectureVm(), "100px");
    TextColumnWithTooltip<VM> numOfDisksColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return String.valueOf(object.getDiskMap().size());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(numOfDisksColumn, constants.disksVm(), "100px");
    TextColumnWithTooltip<VM> creationDateColumn = new GeneralDateTimeColumn<VM>() {

        @Override
        protected Date getRawValue(VM object) {
            return object.getVmCreationDate();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(creationDateColumn, constants.creationDateVm(), "200px");
    TextColumnWithTooltip<VM> exportDateColumn = new GeneralDateTimeColumn<VM>() {

        @Override
        protected Date getRawValue(VM object) {
            return object.getExportDate();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(exportDateColumn, constants.exportDateVm(), "200px");
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<VmTemplate> nameColumn = new TextColumnWithTooltip<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "150px");
    TextColumnWithTooltip<VmTemplate> originColumn = new EnumColumn<VmTemplate, OriginType>() {

        @Override
        protected OriginType getRawValue(VmTemplate object) {
            return object.getOrigin();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(originColumn, constants.originVm(), "100px");
    TextColumnWithTooltip<VmTemplate> memoryColumn = new TextColumnWithTooltip<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            // $NON-NLS-1$
            return String.valueOf(object.getMemSizeMb()) + " MB";
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "100px");
    TextColumnWithTooltip<VmTemplate> cpuColumn = new TextColumnWithTooltip<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return String.valueOf(object.getNumOfCpus());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpusVm(), "100px");
    TextColumnWithTooltip<VmTemplate> archColumn = new TextColumnWithTooltip<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return String.valueOf(object.getClusterArch());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(archColumn, constants.architectureVm(), "100px");
    TextColumnWithTooltip<VmTemplate> diskColumn = new TextColumnWithTooltip<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return String.valueOf(object.getDiskTemplateMap().size());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(diskColumn, constants.disksVm(), "100px");
    TextColumnWithTooltip<VmTemplate> creationDateColumn = new GeneralDateTimeColumn<VmTemplate>() {

        @Override
        protected Date getRawValue(VmTemplate object) {
            return object.getCreationDate();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(creationDateColumn, constants.creationDateVm(), "200px");
    TextColumnWithTooltip<VmTemplate> exportDateColumn = new GeneralDateTimeColumn<VmTemplate>() {

        @Override
        protected Date getRawValue(VmTemplate object) {
            return object.getExportDate();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(exportDateColumn, constants.exportDateVm(), "200px");
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<VmTemplate> nameColumn = new TextColumnWithTooltip<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "150px");
    TextColumnWithTooltip<VmTemplate> originColumn = new EnumColumn<VmTemplate, OriginType>() {

        @Override
        protected OriginType getRawValue(VmTemplate object) {
            return object.getOrigin();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(originColumn, constants.originVm(), "100px");
    TextColumnWithTooltip<VmTemplate> memoryColumn = new TextColumnWithTooltip<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            // $NON-NLS-1$
            return String.valueOf(object.getMemSizeMb()) + " MB";
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "100px");
    TextColumnWithTooltip<VmTemplate> cpuColumn = new TextColumnWithTooltip<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return String.valueOf(object.getNumOfCpus());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpusVm(), "100px");
    TextColumnWithTooltip<VmTemplate> archColumn = new TextColumnWithTooltip<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return String.valueOf(object.getClusterArch());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(archColumn, constants.architectureVm(), "100px");
    TextColumnWithTooltip<VmTemplate> numOfDisksColumn = new TextColumnWithTooltip<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return String.valueOf(object.getDiskTemplateMap().size());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(numOfDisksColumn, constants.disksVm(), "100px");
    TextColumnWithTooltip<VmTemplate> creationDateColumn = new GeneralDateTimeColumn<VmTemplate>() {

        @Override
        protected Date getRawValue(VmTemplate object) {
            return object.getCreationDate();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(creationDateColumn, constants.creationDateVm(), "200px");
    TextColumnWithTooltip<VmTemplate> exportDateColumn = new GeneralDateTimeColumn<VmTemplate>() {

        @Override
        protected Date getRawValue(VmTemplate object) {
            return object.getExportDate();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(exportDateColumn, constants.exportDateVm(), "200px");
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getVdsGroup().setArchitecture(getArchitecture());
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldGroup.getcompatibility_version(), getParameters().getVdsGroup().getcompatibility_version())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed the canDo.
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = ListUtils.firstMatch(Config.<List<String>>getValue(ConfigValues.ClusterEmulatedMachines, getParameters().getVdsGroup().getcompatibility_version().getValue()), vds.getSupportedEmulatedMachines().split(","));
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        } else {
            getParameters().getVdsGroup().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldGroup.getArchitecture() != getVdsGroup().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        getParameters().getVdsGroup().setEmulatedMachine(null);
    }
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getVdsGroup().setArchitecture(getArchitecture());
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldGroup.getcompatibility_version(), getParameters().getVdsGroup().getcompatibility_version())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed the canDo.
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = ListUtils.firstMatch(Config.<List<String>>getValue(ConfigValues.ClusterEmulatedMachines, getParameters().getVdsGroup().getcompatibility_version().getValue()), vds.getSupportedEmulatedMachines().split(","));
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        } else {
            getParameters().getVdsGroup().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldGroup.getArchitecture() != getVdsGroup().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        getParameters().getVdsGroup().setEmulatedMachine(null);
    }
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    if (oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null) {
        for (VDS vds : allForVdsGroup) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = getBackend().runInternalAction(VdcActionType.AddVdsSpmId, parameters);
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        // when moving the cluster back into a DC, need to add its management network
        Network managementNetwork = getNetworkDAO().getByNameAndDataCenter(NetworkUtils.getEngineNetwork(), getVdsGroup().getStoragePoolId());
        getNetworkClusterDAO().save(new NetworkCluster(getVdsGroup().getId(), managementNetwork.getId(), NetworkStatus.OPERATIONAL, true, true, true));
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        if (!isVdsGroupUnique(getVdsGroup().getName())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getVdsGroup().getcompatibility_version().compareTo(oldGroup.getcompatibility_version()) < 0) {
        if (!allForVdsGroup.isEmpty()) {
            result = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            StoragePool storagePool = getStoragePoolDAO().get(oldGroup.getStoragePoolId());
            if (storagePool != null && getVdsGroup().getcompatibility_version().compareTo(storagePool.getcompatibility_version()) < 0) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForVdsGroup);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getcpu_name() != null || getVdsGroup().getcpu_name() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getcpu_name()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDAO().getAllForVdsGroup(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForVdsGroup.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getVdsGroup().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getcpu_name(), getVdsGroup().getcpu_name());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getcpu_name());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<VDS>();
        boolean isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getcompatibility_version(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        AuditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDAO().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID).equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().getcompatibility_version() != null && Version.v3_3.compareTo(getVdsGroup().getcompatibility_version()) > 0 && getVdsGroup().isEnableBallooning()) {
        // Members of pre-3.3 clusters don't support ballooning; here we act like a 3.2 engine
        addCanDoActionMessage(VdcBllMessages.QOS_BALLOON_NOT_SUPPORTED);
        result = false;
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VdcBllMessages.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessage(String.format("$compatibilityVersion %1$s", getVdsGroup().getcompatibility_version().getValue()));
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getVdsGroup().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result) {
        result = validateClusterPolicy();
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        if (!isVdsGroupUnique(getVdsGroup().getName())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getVdsGroup().getcompatibility_version().compareTo(oldGroup.getcompatibility_version()) < 0) {
        if (!allForVdsGroup.isEmpty()) {
            result = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            StoragePool storagePool = getStoragePoolDAO().get(oldGroup.getStoragePoolId());
            if (storagePool != null && getVdsGroup().getcompatibility_version().compareTo(storagePool.getcompatibility_version()) < 0) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForVdsGroup);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getcpu_name() != null || getVdsGroup().getcpu_name() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getcpu_name()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDAO().getAllForVdsGroup(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForVdsGroup.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getVdsGroup().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getcpu_name(), getVdsGroup().getcpu_name());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getcpu_name());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<VDS>();
        boolean isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getcompatibility_version(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        AuditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDAO().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID).equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().getcompatibility_version() != null && Version.v3_3.compareTo(getVdsGroup().getcompatibility_version()) > 0 && getVdsGroup().isEnableBallooning()) {
        // Members of pre-3.3 clusters don't support ballooning; here we act like a 3.2 engine
        addCanDoActionMessage(VdcBllMessages.QOS_BALLOON_NOT_SUPPORTED);
        result = false;
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VdcBllMessages.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessage(String.format("$compatibilityVersion %1$s", getVdsGroup().getcompatibility_version().getValue()));
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getVdsGroup().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result) {
        result = validateClusterPolicy();
    }
    // non-empty required sources list and rng-unsupported cluster version
    if (result && !getVdsGroup().getRequiredRngSources().isEmpty() && !FeatureSupported.virtIoRngSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
        result = false;
    }
    return result;
}
#end_block

#method_before
@Override
public void setAcceptableValues(Collection<K> values) {
    buttons.clear();
    panels.clear();
    wrapperPanel.clear();
    for (final K value : values) {
        addValue(value);
    }
    updateButtons();
}
#method_after
@Override
public void setAcceptableValues(Collection<K> values) {
    buttons.clear();
    panels.clear();
    wrapperPanel.clear();
    if (values != null) {
        for (final K value : values) {
            addValue(value);
        }
    }
    updateButtons();
}
#end_block

