278
#method_before
private String stripIccIdSuffix(String hexIccId) {
    if (hexIccId == null)
        return null;
    char[] arr = hexIccId.toCharArray();
    for (int i = arr.length; i > 0; i--) {
        if (!"f".equalsIgnoreCase(String.valueOf(arr[i - 1]))) {
            return hexIccId.substring(0, i);
        }
    }
    return ICCID_STRING_FOR_NO_SIM;
}
#method_after
private String stripIccIdSuffix(String hexIccId) {
    if (hexIccId == null) {
        return null;
    } else {
        return hexIccId.replaceAll("(?i)f*$", "");
    }
}
#end_block

#method_before
@Test
@SmallTest
public void testHexIccIdSuffix() throws Exception {
    doReturn(null).when(mSubscriptionController).getSubInfoUsingSlotIndexWithCheck(anyInt(), anyBoolean(), anyString());
    verify(mSubscriptionController, times(0)).clearSubInfo();
    doReturn("8901260420000000000f").when(mIccRecord).getFullIccId();
    // Mock sending a sim loaded for SIM 1
    Intent mIntent = new Intent(IccCardProxy.ACTION_INTERNAL_SIM_STATE_CHANGED);
    mIntent.putExtra(IccCardConstants.INTENT_KEY_ICC_STATE, IccCardConstants.INTENT_VALUE_ICC_LOADED);
    mIntent.putExtra(PhoneConstants.PHONE_KEY, FAKE_SUB_ID_1);
    mContext.sendBroadcast(mIntent);
    waitForMs(100);
    SubscriptionManager mSubscriptionManager = SubscriptionManager.from(mContext);
    verify(mSubscriptionController, times(1)).notifySubscriptionInfoChanged();
    verify(mSubscriptionManager, times(1)).addSubscriptionInfoRecord(eq("8901260420000000000"), eq(FAKE_SUB_ID_1));
    verify(mSubscriptionController, times(0)).clearSubInfo();
}
#method_after
@Test
@SmallTest
public void testHexIccIdSuffix() throws Exception {
    doReturn(null).when(mSubscriptionController).getSubInfoUsingSlotIndexWithCheck(anyInt(), anyBoolean(), anyString());
    verify(mSubscriptionController, times(0)).clearSubInfo();
    doReturn("890126042000000000Ff").when(mIccRecord).getFullIccId();
    // Mock sending a sim loaded for SIM 1
    Intent mIntent = new Intent(IccCardProxy.ACTION_INTERNAL_SIM_STATE_CHANGED);
    mIntent.putExtra(IccCardConstants.INTENT_KEY_ICC_STATE, IccCardConstants.INTENT_VALUE_ICC_LOADED);
    mIntent.putExtra(PhoneConstants.PHONE_KEY, FAKE_SUB_ID_1);
    mContext.sendBroadcast(mIntent);
    waitForMs(100);
    SubscriptionManager mSubscriptionManager = SubscriptionManager.from(mContext);
    verify(mSubscriptionController, times(1)).notifySubscriptionInfoChanged();
    verify(mSubscriptionManager, times(1)).addSubscriptionInfoRecord(eq("890126042000000000"), eq(FAKE_SUB_ID_1));
    verify(mSubscriptionController, times(0)).clearSubInfo();
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (o == null) {
        return false;
    }
    if (!(o instanceof MediaMetadata)) {
        return false;
    }
    final MediaMetadata m = (MediaMetadata) o;
    for (Entry<String, Integer> entry : METADATA_KEYS_TYPE.entrySet()) {
        String key = entry.getKey();
        switch(entry.getValue()) {
            case METADATA_TYPE_TEXT:
                if (!Objects.equals(getString(key), m.getString(key))) {
                    return false;
                }
                break;
            case METADATA_TYPE_LONG:
                if (getLong(key) != m.getLong(key)) {
                    return false;
                }
                break;
            case METADATA_TYPE_BITMAP:
                Bitmap b1 = getBitmap(key);
                Bitmap b2 = m.getBitmap(key);
                if ((b1 == null && b2 == null) || (b1 != null && b1.sameAs(b2))) {
                    return false;
                }
                break;
            default:
                // Ignore ratings
                break;
        }
    }
    return true;
}
#method_after
@Override
public boolean equals(Object o) {
    if (o == this) {
        return true;
    }
    if (!(o instanceof MediaMetadata)) {
        return false;
    }
    final MediaMetadata m = (MediaMetadata) o;
    for (int i = 0; i < METADATA_KEYS_TYPE.size(); i++) {
        String key = METADATA_KEYS_TYPE.keyAt(i);
        switch(METADATA_KEYS_TYPE.valueAt(i)) {
            case METADATA_TYPE_TEXT:
                if (!Objects.equals(getString(key), m.getString(key))) {
                    return false;
                }
                break;
            case METADATA_TYPE_LONG:
                if (getLong(key) != m.getLong(key)) {
                    return false;
                }
                break;
            default:
                // Ignore ratings and bitmaps when comparing
                break;
        }
    }
    return true;
}
#end_block

#method_before
protected void updateSpnDisplay() {
    updateOperatorNameFromEri();
    String wfcVoiceSpnFormat = null;
    String wfcDataSpnFormat = null;
    if (mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled()) {
        // In Wi-Fi Calling mode show SPN+WiFi
        String[] wfcSpnFormats = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.wfcSpnFormats);
        int voiceIdx = 0;
        int dataIdx = 0;
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (b != null) {
                    voiceIdx = b.getInt(CarrierConfigManager.KEY_WFC_SPN_FORMAT_IDX_INT);
                    dataIdx = b.getInt(CarrierConfigManager.KEY_WFC_DATA_SPN_FORMAT_IDX_INT);
                }
            } catch (Exception e) {
                loge("updateSpnDisplay: carrier config error: " + e);
            }
        }
        wfcVoiceSpnFormat = wfcSpnFormats[voiceIdx];
        wfcDataSpnFormat = wfcSpnFormats[dataIdx];
    }
    int combinedRegState = getCombinedRegState();
    if (mPhone.isPhoneTypeGsm()) {
        // The values of plmn/showPlmn change in different scenarios.
        // 1) No service but emergency call allowed -> expected
        // to show "Emergency call only"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "Emergency call only"
        // 2) No service at all --> expected to show "No service"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "No service"
        // 3) Normal operation in either home or roaming service
        // EXTRA_SHOW_PLMN = depending on IccRecords rule
        // EXTRA_PLMN = plmn
        // 4) No service due to power off, aka airplane mode
        // EXTRA_SHOW_PLMN = false
        // EXTRA_PLMN = null
        IccRecords iccRecords = mIccRecords;
        String plmn = null;
        boolean showPlmn = false;
        int rule = (iccRecords != null) ? iccRecords.getDisplayRule(mSS.getOperatorNumeric()) : 0;
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE || combinedRegState == ServiceState.STATE_EMERGENCY_ONLY) {
            showPlmn = true;
            // Force display no service
            final boolean forceDisplayNoService = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_display_no_service_when_sim_unready) && !mIsSimReady;
            if (mEmergencyOnly && !forceDisplayNoService) {
                // No service but emergency call allowed
                plmn = Resources.getSystem().getText(com.android.internal.R.string.emergency_calls_only).toString();
            } else {
                // No service at all
                plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            }
            if (DBG)
                log("updateSpnDisplay: radio is on but out " + "of service, set plmn='" + plmn + "'");
        } else if (combinedRegState == ServiceState.STATE_IN_SERVICE) {
            // In either home or roaming service
            plmn = mSS.getOperatorAlpha();
            showPlmn = !TextUtils.isEmpty(plmn) && ((rule & SIMRecords.SPN_RULE_SHOW_PLMN) == SIMRecords.SPN_RULE_SHOW_PLMN);
        } else {
            // Power off state, such as airplane mode, show plmn as "No service"
            showPlmn = true;
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG)
                log("updateSpnDisplay: radio is off w/ showPlmn=" + showPlmn + " plmn=" + plmn);
        }
        // The value of spn/showSpn are same in different scenarios.
        // EXTRA_SHOW_SPN = depending on IccRecords rule and radio/IMS state
        // EXTRA_SPN = spn
        // EXTRA_DATA_SPN = dataSpn
        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
        String dataSpn = spn;
        boolean showSpn = !TextUtils.isEmpty(spn) && ((rule & SIMRecords.SPN_RULE_SHOW_SPN) == SIMRecords.SPN_RULE_SHOW_SPN);
        if (!TextUtils.isEmpty(spn) && !TextUtils.isEmpty(wfcVoiceSpnFormat) && !TextUtils.isEmpty(wfcDataSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalSpn = spn.trim();
            spn = String.format(wfcVoiceSpnFormat, originalSpn);
            dataSpn = String.format(wfcDataSpnFormat, originalSpn);
            showSpn = true;
            showPlmn = false;
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF || (showPlmn && TextUtils.equals(spn, plmn))) {
            // airplane mode or spn equals plmn, do not show spn
            spn = null;
            showSpn = false;
        }
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
        if (mSubId != subId || showPlmn != mCurShowPlmn || showSpn != mCurShowSpn || !TextUtils.equals(spn, mCurSpn) || !TextUtils.equals(dataSpn, mCurDataSpn) || !TextUtils.equals(plmn, mCurPlmn)) {
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent rule=" + rule + " showPlmn='%b' plmn='%s' showSpn='%b' spn='%s' dataSpn='%s' " + "subId='%d'", showPlmn, plmn, showSpn, spn, dataSpn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
            intent.putExtra(TelephonyIntents.EXTRA_DATA_SPN, dataSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, showSpn, spn)) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = showSpn;
        mCurShowPlmn = showPlmn;
        mCurSpn = spn;
        mCurDataSpn = dataSpn;
        mCurPlmn = plmn;
    } else {
        // mOperatorAlpha contains the ERI text
        String plmn = mSS.getOperatorAlpha();
        boolean showPlmn = false;
        showPlmn = plmn != null;
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
            // todo: temporary hack; should have a better fix. This is to avoid using operator
            // name from ServiceState (populated in resetServiceStateInIwlanMode()) until
            // wifi calling is actually enabled
            log("updateSpnDisplay: overwriting plmn from " + plmn + " to null as radio " + "state is off");
            plmn = null;
        }
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE) {
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG) {
                log("updateSpnDisplay: radio is on but out of svc, set plmn='" + plmn + "'");
            }
        }
        if (mSubId != subId || !TextUtils.equals(plmn, mCurPlmn)) {
            // "No Service". Now showPlmn is set to true for any non null string.
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent" + " showPlmn='%b' plmn='%s' subId='%d'", showPlmn, plmn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, false);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, "");
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, false, "")) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = false;
        mCurShowPlmn = showPlmn;
        mCurSpn = "";
        mCurPlmn = plmn;
    }
}
#method_after
protected void updateSpnDisplay() {
    updateOperatorNameFromEri();
    String wfcVoiceSpnFormat = null;
    String wfcDataSpnFormat = null;
    int combinedRegState = getCombinedRegState();
    if (mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled() && (combinedRegState == ServiceState.STATE_IN_SERVICE)) {
        // In Wi-Fi Calling mode show SPN or PLMN + WiFi Calling
        // 
        // 1) Show SPN + Wi-Fi Calling If SIM has SPN and SPN display condition
        // is satisfied or SPN override is enabled for this carrier
        // 
        // 2) Show PLMN + Wi-Fi Calling if there is no valid SPN in case 1
        String[] wfcSpnFormats = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.wfcSpnFormats);
        int voiceIdx = 0;
        int dataIdx = 0;
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (b != null) {
                    voiceIdx = b.getInt(CarrierConfigManager.KEY_WFC_SPN_FORMAT_IDX_INT);
                    dataIdx = b.getInt(CarrierConfigManager.KEY_WFC_DATA_SPN_FORMAT_IDX_INT);
                }
            } catch (Exception e) {
                loge("updateSpnDisplay: carrier config error: " + e);
            }
        }
        wfcVoiceSpnFormat = wfcSpnFormats[voiceIdx];
        wfcDataSpnFormat = wfcSpnFormats[dataIdx];
    }
    if (mPhone.isPhoneTypeGsm()) {
        // The values of plmn/showPlmn change in different scenarios.
        // 1) No service but emergency call allowed -> expected
        // to show "Emergency call only"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "Emergency call only"
        // 2) No service at all --> expected to show "No service"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "No service"
        // 3) Normal operation in either home or roaming service
        // EXTRA_SHOW_PLMN = depending on IccRecords rule
        // EXTRA_PLMN = plmn
        // 4) No service due to power off, aka airplane mode
        // EXTRA_SHOW_PLMN = false
        // EXTRA_PLMN = null
        IccRecords iccRecords = mIccRecords;
        String plmn = null;
        boolean showPlmn = false;
        int rule = (iccRecords != null) ? iccRecords.getDisplayRule(mSS) : 0;
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE || combinedRegState == ServiceState.STATE_EMERGENCY_ONLY) {
            showPlmn = true;
            // Force display no service
            final boolean forceDisplayNoService = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_display_no_service_when_sim_unready) && !mIsSimReady;
            if (mEmergencyOnly && !forceDisplayNoService) {
                // No service but emergency call allowed
                plmn = Resources.getSystem().getText(com.android.internal.R.string.emergency_calls_only).toString();
            } else {
                // No service at all
                plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            }
            if (DBG)
                log("updateSpnDisplay: radio is on but out " + "of service, set plmn='" + plmn + "'");
        } else if (combinedRegState == ServiceState.STATE_IN_SERVICE) {
            // In either home or roaming service
            plmn = mSS.getOperatorAlpha();
            showPlmn = !TextUtils.isEmpty(plmn) && ((rule & SIMRecords.SPN_RULE_SHOW_PLMN) == SIMRecords.SPN_RULE_SHOW_PLMN);
        } else {
            // Power off state, such as airplane mode, show plmn as "No service"
            showPlmn = true;
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG)
                log("updateSpnDisplay: radio is off w/ showPlmn=" + showPlmn + " plmn=" + plmn);
        }
        // The value of spn/showSpn are same in different scenarios.
        // EXTRA_SHOW_SPN = depending on IccRecords rule and radio/IMS state
        // EXTRA_SPN = spn
        // EXTRA_DATA_SPN = dataSpn
        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
        String dataSpn = spn;
        boolean showSpn = !TextUtils.isEmpty(spn) && ((rule & SIMRecords.SPN_RULE_SHOW_SPN) == SIMRecords.SPN_RULE_SHOW_SPN);
        if (!TextUtils.isEmpty(spn) && !TextUtils.isEmpty(wfcVoiceSpnFormat) && !TextUtils.isEmpty(wfcDataSpnFormat)) {
            // Show SPN + Wi-Fi Calling If SIM has SPN and SPN display condition
            // is satisfied or SPN override is enabled for this carrier.
            String originalSpn = spn.trim();
            spn = String.format(wfcVoiceSpnFormat, originalSpn);
            dataSpn = String.format(wfcDataSpnFormat, originalSpn);
            showSpn = true;
            showPlmn = false;
        } else if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // Show PLMN + Wi-Fi Calling if there is no valid SPN in the above case
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF || (showPlmn && TextUtils.equals(spn, plmn))) {
            // airplane mode or spn equals plmn, do not show spn
            spn = null;
            showSpn = false;
        }
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
        if (mSubId != subId || showPlmn != mCurShowPlmn || showSpn != mCurShowSpn || !TextUtils.equals(spn, mCurSpn) || !TextUtils.equals(dataSpn, mCurDataSpn) || !TextUtils.equals(plmn, mCurPlmn)) {
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent rule=" + rule + " showPlmn='%b' plmn='%s' showSpn='%b' spn='%s' dataSpn='%s' " + "subId='%d'", showPlmn, plmn, showSpn, spn, dataSpn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
            intent.putExtra(TelephonyIntents.EXTRA_DATA_SPN, dataSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, showSpn, spn)) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = showSpn;
        mCurShowPlmn = showPlmn;
        mCurSpn = spn;
        mCurDataSpn = dataSpn;
        mCurPlmn = plmn;
    } else {
        // mOperatorAlpha contains the ERI text
        String plmn = mSS.getOperatorAlpha();
        boolean showPlmn = false;
        showPlmn = plmn != null;
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
            // todo: temporary hack; should have a better fix. This is to avoid using operator
            // name from ServiceState (populated in resetServiceStateInIwlanMode()) until
            // wifi calling is actually enabled
            log("updateSpnDisplay: overwriting plmn from " + plmn + " to null as radio " + "state is off");
            plmn = null;
        }
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE) {
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG) {
                log("updateSpnDisplay: radio is on but out of svc, set plmn='" + plmn + "'");
            }
        }
        if (mSubId != subId || !TextUtils.equals(plmn, mCurPlmn)) {
            // "No Service". Now showPlmn is set to true for any non null string.
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent" + " showPlmn='%b' plmn='%s' subId='%d'", showPlmn, plmn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, false);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, "");
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, false, "")) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = false;
        mCurShowPlmn = showPlmn;
        mCurSpn = "";
        mCurPlmn = plmn;
    }
}
#end_block

#method_before
private void pollStateDone() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // until cell change
    if (!hasLocationChanged) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasRejectCauseChanged = mRejectCode != mNewRejectCode;
    boolean hasCssIndicatorChanged = (mSS.getCssIndicator() != mNewSS.getCssIndicator());
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport + " hasCssIndicatorChanged=" + hasCssIndicatorChanged);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        if (hasCssIndicatorChanged) {
            mPhone.notifyDataConnection(Phone.REASON_CSS_INDICATOR_CHANGED);
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
        mRejectCode = mNewRejectCode;
    }
    ServiceState oldMergedSS = mPhone.getServiceState();
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        if (DBG) {
            log("pollStateDone: registering current mNitzUpdatedTime=" + mNitzUpdatedTime + " changing to false");
        }
        mNitzUpdatedTime = false;
    }
    if (hasDeregistered) {
        mNetworkDetachedRegistrants.notifyRegistrants();
    }
    if (hasRejectCauseChanged) {
        setNotification(CS_REJECT_CAUSE_ENABLED);
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
        } else if (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
            // Update time zone, ISO, and IDD.
            // 
            // If the device is on IWLAN, modems manufacture a ServiceState with the MCC/MNC of
            // the SIM as if we were talking to towers. Telephony code then uses that with
            // mccTable to suggest a timezone. We shouldn't do that if the MCC/MNC is from IWLAN
            String iso = "";
            String mcc = "";
            try {
                mcc = operatorNumeric.substring(0, 3);
                iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), iso);
            mGotCountryCode = true;
            if (!mNitzUpdatedTime && !mcc.equals("000") && !TextUtils.isEmpty(iso) && getAutoTimeZone()) {
                updateTimeZoneByNetworkCountryCode(iso);
            }
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(iso);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        // notify service state changed only if the merged service state is changed.
        if (!oldMergedSS.equals(mPhone.getServiceState())) {
            mPhone.notifyServiceStateChanged(mPhone.getServiceState());
        }
        // insert into ServiceStateProvider. This will trigger apps to wake through JobScheduler
        mPhone.getContext().getContentResolver().insert(getUriForSubscriptionId(mPhone.getSubId()), getContentValuesForServiceState(mSS));
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#method_after
private void pollStateDone() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (Build.IS_DEBUGGABLE && mPhone.mTelephonyTester != null) {
        mPhone.mTelephonyTester.overrideServiceState(mNewSS);
    }
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // until cell change
    if (!hasLocationChanged) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasRejectCauseChanged = mRejectCode != mNewRejectCode;
    boolean hasCssIndicatorChanged = (mSS.getCssIndicator() != mNewSS.getCssIndicator());
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport + " hasCssIndicatorChanged=" + hasCssIndicatorChanged);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        if (hasCssIndicatorChanged) {
            mPhone.notifyDataConnection(Phone.REASON_CSS_INDICATOR_CHANGED);
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
        mRejectCode = mNewRejectCode;
    }
    ServiceState oldMergedSS = mPhone.getServiceState();
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        if (DBG) {
            log("pollStateDone: registering current mNitzUpdatedTime=" + mNitzUpdatedTime + " changing to false");
        }
        mNitzUpdatedTime = false;
    }
    if (hasDeregistered) {
        mNetworkDetachedRegistrants.notifyRegistrants();
    }
    if (hasRejectCauseChanged) {
        setNotification(CS_REJECT_CAUSE_ENABLED);
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
        } else if (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
            // Update time zone, ISO, and IDD.
            // 
            // If the device is on IWLAN, modems manufacture a ServiceState with the MCC/MNC of
            // the SIM as if we were talking to towers. Telephony code then uses that with
            // mccTable to suggest a timezone. We shouldn't do that if the MCC/MNC is from IWLAN
            String iso = "";
            String mcc = "";
            try {
                mcc = operatorNumeric.substring(0, 3);
                iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), iso);
            mGotCountryCode = true;
            if (!mNitzUpdatedTime && !mcc.equals("000") && !TextUtils.isEmpty(iso) && getAutoTimeZone()) {
                updateTimeZoneByNetworkCountryCode(iso);
            }
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(iso);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        // notify service state changed only if the merged service state is changed.
        if (!oldMergedSS.equals(mPhone.getServiceState())) {
            mPhone.notifyServiceStateChanged(mPhone.getServiceState());
        }
        // insert into ServiceStateProvider. This will trigger apps to wake through JobScheduler
        mPhone.getContext().getContentResolver().insert(getUriForSubscriptionId(mPhone.getSubId()), getContentValuesForServiceState(mSS));
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#end_block

#method_before
protected boolean onSignalStrengthResult(AsyncResult ar) {
    boolean isGsm = false;
    int dataRat = mSS.getRilDataRadioTechnology();
    int voiceRat = mSS.getRilVoiceRadioTechnology();
    // Set isGsm to true if the RAT belongs to GSM family and not IWLAN
    if ((dataRat != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN && ServiceState.isGsm(dataRat)) || (voiceRat != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN && ServiceState.isGsm(voiceRat))) {
        isGsm = true;
    }
    if ((ar.exception == null) && (ar.result != null)) {
        mSignalStrength = (SignalStrength) ar.result;
        mSignalStrength.validateInput();
        if (dataRat == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN && voiceRat == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
            mSignalStrength.fixType();
        } else {
            mSignalStrength.setGsm(isGsm);
        }
        mSignalStrength.setLteRsrpBoost(mSS.getLteEarfcnRsrpBoost());
    } else {
        log("onSignalStrengthResult() Exception from RIL : " + ar.exception);
        mSignalStrength = new SignalStrength(isGsm);
    }
    boolean ssChanged = notifySignalStrength();
    return ssChanged;
}
#method_after
protected boolean onSignalStrengthResult(AsyncResult ar) {
    boolean isGsm = false;
    int dataRat = mSS.getRilDataRadioTechnology();
    int voiceRat = mSS.getRilVoiceRadioTechnology();
    // Set isGsm to true if the RAT belongs to GSM family and not IWLAN
    if ((dataRat != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN && ServiceState.isGsm(dataRat)) || (voiceRat != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN && ServiceState.isGsm(voiceRat))) {
        isGsm = true;
    }
    if ((ar.exception == null) && (ar.result != null)) {
        mSignalStrength = (SignalStrength) ar.result;
        mSignalStrength.validateInput();
        if (dataRat == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN && voiceRat == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
            mSignalStrength.fixType();
        } else {
            mSignalStrength.setGsm(isGsm);
        }
        mSignalStrength.setLteRsrpBoost(mSS.getLteEarfcnRsrpBoost());
        mSignalStrength.setUseOnlyRsrpForLteLevel(isUseOnlyRsrpForLteLevel());
    } else {
        log("onSignalStrengthResult() Exception from RIL : " + ar.exception);
        mSignalStrength = new SignalStrength(isGsm);
    }
    boolean ssChanged = notifySignalStrength();
    return ssChanged;
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (o instanceof BluetoothHidDeviceAppQosSettings) {
        BluetoothHidDeviceAppQosSettings qos = (BluetoothHidDeviceAppQosSettings) o;
        return false;
    }
    return false;
}
#method_after
@Override
public boolean equals(Object o) {
    if (o instanceof BluetoothHidDeviceAppQosSettings) {
        BluetoothHidDeviceAppQosSettings qos = (BluetoothHidDeviceAppQosSettings) o;
        return this.serviceType == qos.serviceType && this.tokenRate == qos.tokenRate && this.tokenBucketSize == qos.tokenBucketSize && this.peakBandwidth == qos.peakBandwidth && this.latency == qos.latency && this.delayVariation == qos.delayVariation;
    }
    return false;
}
#end_block

#method_before
public BluetoothHidDeviceAppQosSettings build() {
    return new BluetoothHidDeviceAppQosSettings(this);
}
#method_after
public BluetoothHidDeviceAppQosSettings build() {
    return new BluetoothHidDeviceAppQosSettings(mServiceType, mTokenRate, mTokenBucketSize, mPeakBandwidth, mLatency, mDelayVariation);
}
#end_block

#method_before
private CommandPacket makeCommand(byte[] test_values) {
    CommandPacket packet = new CommandPacket(JDWPCommands.DDMCommandSet.CommandSetID, JDWPCommands.DDMCommandSet.ChunkCommand);
    packet.setNextValueAsInt(DDMDebuggee.DDM_TEST_TYPE);
    packet.setNextValueAsInt(test_values.length);
    for (byte b : test_values) {
        packet.setNextValueAsByte(b);
    }
    return packet;
}
#method_after
private CommandPacket makeCommand(byte[] test_values) {
    CommandPacket packet = new CommandPacket(DDMCommandSet.CommandSetID, DDMCommandSet.ChunkCommand);
    packet.setNextValueAsInt(DDMDebuggee.DDM_TEST_TYPE);
    packet.setNextValueAsInt(test_values.length);
    for (byte b : test_values) {
        packet.setNextValueAsByte(b);
    }
    return packet;
}
#end_block

#method_before
public static junit.framework.Test suite() {
    junit.framework.TestSuite suite = new junit.framework.TestSuite();
    // 
    // "TODO".
    // 
    // I haven't yet found an IDE that will use these, but we might want to implement them anyway.
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MonitorContendedEnteredTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MonitorContendedEnterTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MonitorWaitedTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MonitorWaitTest.class);
    // I don't know when these are ever used, but they're not obviously useless.
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.DebuggerOnDemand.OnthrowDebuggerLaunchTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.NestedTypesTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.HoldEventsTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.ReleaseEventsTest.class);
    // 
    // "Will not fix".
    // 
    // It's not obvious how to translate this into our world, or what debuggers would do with it.
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.ClassFileVersionTest.class);
    // We don't implement Thread.stop at all, so it doesn't make sense for us to implement the JDWP.
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.StopTest.class);
    // We don't implement class unloading.
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ClassUnloadTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayReference.GetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayReference.LengthTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayReference.SetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayReference.SetValues003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayReference.SetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayType.NewInstanceTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassLoaderReference.VisibleClassesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassObjectReference.ReflectedType002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassObjectReference.ReflectedTypeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.InvokeMethod002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.InvokeMethod003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.InvokeMethodAfterMultipleThreadSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.InvokeMethodWithSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.InvokeMethodTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstance002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstanceTagTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstanceAfterMultipleThreadSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstanceStringTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstanceTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstanceWithSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.SetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.SetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.SuperClassTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Deoptimization.DeoptimizationWithExceptionHandlingTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.EventModifiers.CountModifierTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.EventModifiers.InstanceOnlyModifierTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.EventModifiers.ThreadOnlyModifierTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.Breakpoint002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.BreakpointMultipleTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.BreakpointOnCatchTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.BreakpointTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ClassPrepare002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ClassPrepareTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.CombinedEvents002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.CombinedEvents003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.CombinedEventsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.CombinedExceptionEventsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.EventWithExceptionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ExceptionCaughtTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ExceptionUncaughtTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ExceptionWithLocationTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.FieldAccessTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.FieldModification002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.FieldModificationTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.FieldWithLocationTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MethodEntryTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MethodExitTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MethodExitWithReturnValueTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.SingleStepTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.SingleStepThroughReflectionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.SingleStepWithLocationTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.SingleStepWithPendingExceptionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ThreadEndTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ThreadStartTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.VMDeath002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.VMDeathTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.InterfaceType.InvokeMethodTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Method.BytecodesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Method.IsObsoleteTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Method.LineTableTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Method.VariableTableTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Method.VariableTableWithGenericTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.AttachConnectorTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.BreakpointTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.ClassObjectIDTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.ClassPrepareTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.EnableCollectionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.ExceptionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.FieldAccessTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.FieldModificationTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.ListenConnectorTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.MethodEntryExitTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.RefTypeIDTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.ResumeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.SingleStepTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.VMDeathTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.DisableCollectionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.EnableCollectionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.GetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.GetValues003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.GetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethod002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethod003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodAfterMultipleThreadSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodDefault002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodDefaultTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodWithSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.IsCollectedTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.MonitorInfoTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.ReferenceTypeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.ReferringObjectsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.SetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.SetValues003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.SetValues004Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.SetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.ClassLoaderTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.ClassObjectTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.ConstantPoolTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.FieldsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.FieldsWithGenericTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues004Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues005Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues006Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues007Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.InstancesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.InterfacesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.MethodsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.MethodsWithGenericTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.ModifiersTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.Signature002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.SignatureTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.SignatureWithGenericTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.SourceDebugExtensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.SourceFileTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.StatusTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.SyntheticFieldsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.SyntheticMethodsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.GetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.GetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.PopFrames002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.PopFramesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.ProxyThisObjectTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.SetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.SetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.ThisObjectTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StringReference.ValueTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadGroupReference.ChildrenTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadGroupReference.NameTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadGroupReference.ParentTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.CurrentContendedMonitorTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturn002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturn003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturn004Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturn005Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturn006Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturnTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.FrameCountTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.FramesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.InterruptTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.NameTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.OwnedMonitorsStackDepthInfoTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.OwnedMonitorsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ResumeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.Status002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.Status003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.Status004Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.Status005Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.Status006Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.StatusTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.SuspendCountTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.SuspendTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ThreadGroup002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ThreadGroupTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.AllClassesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.AllClassesWithGenericTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.AllThreadsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.CapabilitiesNewTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.CapabilitiesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.ClassesBySignatureTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.ClassPathsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.CreateStringTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.DisposeDuringInvokeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.DisposeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.DisposeObjectsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.ExitTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.IDSizesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.InstanceCountsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.RedefineClassesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.Resume002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.ResumeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.SetDefaultStratumTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.SuspendTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.TopLevelThreadGroupsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.VersionTest.class);
    try {
        suite.addTestSuite((Class<? extends junit.framework.TestCase>) Class.forName("org.apache.harmony.jpda.tests.jdwp.DDM.DDMTest"));
    } catch (ClassNotFoundException e) {
    }
    return suite;
}
#method_after
public static junit.framework.Test suite() {
    junit.framework.TestSuite suite = new junit.framework.TestSuite();
    // 
    // "TODO".
    // 
    // I haven't yet found an IDE that will use these, but we might want to implement them anyway.
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MonitorContendedEnteredTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MonitorContendedEnterTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MonitorWaitedTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MonitorWaitTest.class);
    // I don't know when these are ever used, but they're not obviously useless.
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.DebuggerOnDemand.OnthrowDebuggerLaunchTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.NestedTypesTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.HoldEventsTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.ReleaseEventsTest.class);
    // 
    // "Will not fix".
    // 
    // It's not obvious how to translate this into our world, or what debuggers would do with it.
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.ClassFileVersionTest.class);
    // We don't implement Thread.stop at all, so it doesn't make sense for us to implement the JDWP.
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.StopTest.class);
    // We don't implement class unloading.
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ClassUnloadTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayReference.GetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayReference.LengthTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayReference.SetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayReference.SetValues003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayReference.SetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayType.NewInstanceTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassLoaderReference.VisibleClassesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassObjectReference.ReflectedType002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassObjectReference.ReflectedTypeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.InvokeMethod002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.InvokeMethod003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.InvokeMethodAfterMultipleThreadSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.InvokeMethodWithSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.InvokeMethodTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstance002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstanceTagTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstanceAfterMultipleThreadSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstanceStringTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstanceTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstanceWithSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.SetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.SetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.SuperClassTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Deoptimization.DeoptimizationWithExceptionHandlingTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.EventModifiers.CountModifierTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.EventModifiers.InstanceOnlyModifierTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.EventModifiers.ThreadOnlyModifierTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.Breakpoint002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.BreakpointMultipleTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.BreakpointOnCatchTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.BreakpointTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ClassPrepare002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ClassPrepareTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.CombinedEvents002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.CombinedEvents003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.CombinedEventsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.CombinedExceptionEventsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.EventWithExceptionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ExceptionCaughtTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ExceptionUncaughtTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ExceptionWithLocationTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.FieldAccessTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.FieldModification002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.FieldModificationTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.FieldWithLocationTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MethodEntryTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MethodExitTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MethodExitWithReturnValueTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.SingleStepTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.SingleStepThroughReflectionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.SingleStepWithLocationTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.SingleStepWithPendingExceptionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ThreadEndTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ThreadStartTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.VMDeath002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.VMDeathTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.InterfaceType.InvokeMethodTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Method.BytecodesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Method.IsObsoleteTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Method.LineTableTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Method.VariableTableTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Method.VariableTableWithGenericTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.AttachConnectorTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.BreakpointTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.ClassObjectIDTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.ClassPrepareTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.EnableCollectionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.ExceptionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.FieldAccessTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.FieldModificationTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.ListenConnectorTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.MethodEntryExitTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.RefTypeIDTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.ResumeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.SingleStepTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.VMDeathTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.DisableCollectionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.EnableCollectionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.GetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.GetValues003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.GetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethod002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethod003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodAfterMultipleThreadSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodDefault002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodDefaultTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodWithSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.IsCollectedTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.MonitorInfoTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.ReferenceTypeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.ReferringObjectsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.SetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.SetValues003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.SetValues004Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.SetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.ClassLoaderTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.ClassObjectTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.ConstantPoolTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.FieldsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.FieldsWithGenericTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues004Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues005Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues006Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues007Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.InstancesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.InterfacesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.MethodsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.MethodsWithGenericTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.ModifiersTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.Signature002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.SignatureTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.SignatureWithGenericTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.SourceDebugExtensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.SourceFileTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.StatusTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.SyntheticFieldsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.SyntheticMethodsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.GetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.GetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.PopFrames002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.PopFramesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.ProxyThisObjectTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.SetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.SetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.ThisObjectTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StringReference.ValueTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadGroupReference.ChildrenTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadGroupReference.NameTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadGroupReference.ParentTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.CurrentContendedMonitorTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturn002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturn003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturn004Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturn005Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturn006Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturnTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.FrameCountTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.FramesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.InterruptTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.NameTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.OwnedMonitorsStackDepthInfoTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.OwnedMonitorsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ResumeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.Status002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.Status003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.Status004Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.Status005Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.Status006Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.StatusTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.SuspendCountTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.SuspendTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ThreadGroup002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ThreadGroupTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.AllClassesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.AllClassesWithGenericTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.AllThreadsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.CapabilitiesNewTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.CapabilitiesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.ClassesBySignatureTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.ClassPathsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.CreateStringTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.DisposeDuringInvokeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.DisposeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.DisposeObjectsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.ExitTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.IDSizesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.InstanceCountsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.RedefineClassesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.Resume002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.ResumeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.SetDefaultStratumTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.SuspendTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.TopLevelThreadGroupsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.VersionTest.class);
    addOptionalTestSuite(suite, "org.apache.harmony.jpda.tests.jdwp.DDM.DDMTest");
    return suite;
}
#end_block

#method_before
public void updateNotification() {
    synchronized (BluetoothOppNotification.this) {
        mPendingUpdate++;
        if (mPendingUpdate > 1) {
            if (V)
                Log.v(TAG, "update too frequent, put in queue");
            return;
        }
        if (!mHandler.hasMessages(NOTIFY)) {
            if (V)
                Log.v(TAG, "send message");
            mHandler.sendMessage(mHandler.obtainMessage(NOTIFY));
        }
    }
}
#method_after
public void updateNotification() {
    synchronized (BluetoothOppNotification.this) {
        mPendingUpdate++;
        if (mPendingUpdate > 1) {
            if (V) {
                Log.v(TAG, "update too frequent, put in queue");
            }
            return;
        }
        if (!mHandler.hasMessages(NOTIFY)) {
            if (V) {
                Log.v(TAG, "send message");
            }
            mHandler.sendMessage(mHandler.obtainMessage(NOTIFY));
        }
    }
}
#end_block

#method_before
private void updateActiveNotification() {
    // Active transfers
    Cursor cursor = mContext.getContentResolver().query(BluetoothShare.CONTENT_URI, null, WHERE_RUNNING, null, BluetoothShare._ID);
    if (cursor == null) {
        return;
    }
    // notifications
    if (cursor.getCount() > 0) {
        mUpdateCompleteNotification = false;
    } else {
        mUpdateCompleteNotification = true;
    }
    if (V)
        Log.v(TAG, "mUpdateCompleteNotification = " + mUpdateCompleteNotification);
    // Collate the notifications
    final int timestampIndex = cursor.getColumnIndexOrThrow(BluetoothShare.TIMESTAMP);
    final int directionIndex = cursor.getColumnIndexOrThrow(BluetoothShare.DIRECTION);
    final int idIndex = cursor.getColumnIndexOrThrow(BluetoothShare._ID);
    final int totalBytesIndex = cursor.getColumnIndexOrThrow(BluetoothShare.TOTAL_BYTES);
    final int currentBytesIndex = cursor.getColumnIndexOrThrow(BluetoothShare.CURRENT_BYTES);
    final int dataIndex = cursor.getColumnIndexOrThrow(BluetoothShare._DATA);
    final int filenameHintIndex = cursor.getColumnIndexOrThrow(BluetoothShare.FILENAME_HINT);
    final int confirmIndex = cursor.getColumnIndexOrThrow(BluetoothShare.USER_CONFIRMATION);
    final int destinationIndex = cursor.getColumnIndexOrThrow(BluetoothShare.DESTINATION);
    mNotifications.clear();
    for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {
        long timeStamp = cursor.getLong(timestampIndex);
        int dir = cursor.getInt(directionIndex);
        int id = cursor.getInt(idIndex);
        long total = cursor.getLong(totalBytesIndex);
        long current = cursor.getLong(currentBytesIndex);
        int confirmation = cursor.getInt(confirmIndex);
        String destination = cursor.getString(destinationIndex);
        String fileName = cursor.getString(dataIndex);
        if (fileName == null) {
            fileName = cursor.getString(filenameHintIndex);
        }
        if (fileName == null) {
            fileName = mContext.getString(R.string.unknown_file);
        }
        String batchID = Long.toString(timeStamp);
        // sending objects in one batch has same timeStamp
        if (mNotifications.containsKey(batchID)) {
        // NOTE: currently no such case
        // Batch sending case
        } else {
            NotificationItem item = new NotificationItem();
            item.timeStamp = timeStamp;
            item.id = id;
            item.direction = dir;
            if (item.direction == BluetoothShare.DIRECTION_OUTBOUND) {
                item.description = mContext.getString(R.string.notification_sending, fileName);
            } else if (item.direction == BluetoothShare.DIRECTION_INBOUND) {
                item.description = mContext.getString(R.string.notification_receiving, fileName);
            } else {
                if (V)
                    Log.v(TAG, "mDirection ERROR!");
            }
            item.totalCurrent = current;
            item.totalTotal = total;
            item.handoverInitiated = confirmation == BluetoothShare.USER_CONFIRMATION_HANDOVER_CONFIRMED;
            item.destination = destination;
            mNotifications.put(batchID, item);
            if (V)
                Log.v(TAG, "ID=" + item.id + "; batchID=" + batchID + "; totoalCurrent" + item.totalCurrent + "; totalTotal=" + item.totalTotal);
        }
    }
    cursor.close();
    // Add the notifications
    for (NotificationItem item : mNotifications.values()) {
        if (item.handoverInitiated) {
            float progress = 0;
            if (item.totalTotal == -1) {
                progress = -1;
            } else {
                progress = (float) item.totalCurrent / item.totalTotal;
            }
            // Let NFC service deal with notifications for this transfer
            Intent intent = new Intent(Constants.ACTION_BT_OPP_TRANSFER_PROGRESS);
            if (item.direction == BluetoothShare.DIRECTION_INBOUND) {
                intent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_DIRECTION, Constants.DIRECTION_BLUETOOTH_INCOMING);
            } else {
                intent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_DIRECTION, Constants.DIRECTION_BLUETOOTH_OUTGOING);
            }
            intent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_ID, item.id);
            intent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_PROGRESS, progress);
            intent.putExtra(Constants.EXTRA_BT_OPP_ADDRESS, item.destination);
            mContext.sendBroadcast(intent, Constants.HANDOVER_STATUS_PERMISSION);
            continue;
        }
        // Build the notification object
        // TODO: split description into two rows with filename in second row
        Notification.Builder b = new Notification.Builder(mContext);
        b.setColor(mContext.getResources().getColor(com.android.internal.R.color.system_notification_accent_color));
        b.setContentTitle(item.description);
        b.setContentInfo(BluetoothOppUtility.formatProgressText(item.totalTotal, item.totalCurrent));
        if (item.totalTotal != 0) {
            if (V)
                Log.v(TAG, "mCurrentBytes: " + item.totalCurrent + " mTotalBytes: " + item.totalTotal + " (" + (int) ((item.totalCurrent * 100) / item.totalTotal) + " %)");
            b.setProgress(100, (int) ((item.totalCurrent * 100) / item.totalTotal), item.totalTotal == -1);
        } else {
            b.setProgress(100, 100, item.totalTotal == -1);
        }
        b.setWhen(item.timeStamp);
        if (item.direction == BluetoothShare.DIRECTION_OUTBOUND) {
            b.setSmallIcon(android.R.drawable.stat_sys_upload);
        } else if (item.direction == BluetoothShare.DIRECTION_INBOUND) {
            b.setSmallIcon(android.R.drawable.stat_sys_download);
        } else {
            if (V)
                Log.v(TAG, "mDirection ERROR!");
        }
        b.setOngoing(true);
        Intent intent = new Intent(Constants.ACTION_LIST);
        intent.setClassName(Constants.THIS_PACKAGE_NAME, BluetoothOppReceiver.class.getName());
        intent.setDataAndNormalize(Uri.parse(BluetoothShare.CONTENT_URI + "/" + item.id));
        b.setContentIntent(PendingIntent.getBroadcast(mContext, 0, intent, 0));
        mNotificationMgr.notify(item.id, b.getNotification());
        mActiveNotificationId = item.id;
    }
}
#method_after
private void updateActiveNotification() {
    // Active transfers
    Cursor cursor = mContentResolver.query(BluetoothShare.CONTENT_URI, null, WHERE_RUNNING, null, BluetoothShare._ID);
    if (cursor == null) {
        return;
    }
    // notifications
    if (cursor.getCount() > 0) {
        mUpdateCompleteNotification = false;
    } else {
        mUpdateCompleteNotification = true;
    }
    if (V) {
        Log.v(TAG, "mUpdateCompleteNotification = " + mUpdateCompleteNotification);
    }
    // Collate the notifications
    final int timestampIndex = cursor.getColumnIndexOrThrow(BluetoothShare.TIMESTAMP);
    final int directionIndex = cursor.getColumnIndexOrThrow(BluetoothShare.DIRECTION);
    final int idIndex = cursor.getColumnIndexOrThrow(BluetoothShare._ID);
    final int totalBytesIndex = cursor.getColumnIndexOrThrow(BluetoothShare.TOTAL_BYTES);
    final int currentBytesIndex = cursor.getColumnIndexOrThrow(BluetoothShare.CURRENT_BYTES);
    final int dataIndex = cursor.getColumnIndexOrThrow(BluetoothShare._DATA);
    final int filenameHintIndex = cursor.getColumnIndexOrThrow(BluetoothShare.FILENAME_HINT);
    final int confirmIndex = cursor.getColumnIndexOrThrow(BluetoothShare.USER_CONFIRMATION);
    final int destinationIndex = cursor.getColumnIndexOrThrow(BluetoothShare.DESTINATION);
    mNotifications.clear();
    for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {
        long timeStamp = cursor.getLong(timestampIndex);
        int dir = cursor.getInt(directionIndex);
        int id = cursor.getInt(idIndex);
        long total = cursor.getLong(totalBytesIndex);
        long current = cursor.getLong(currentBytesIndex);
        int confirmation = cursor.getInt(confirmIndex);
        String destination = cursor.getString(destinationIndex);
        String fileName = cursor.getString(dataIndex);
        if (fileName == null) {
            fileName = cursor.getString(filenameHintIndex);
        }
        if (fileName == null) {
            fileName = mContext.getString(R.string.unknown_file);
        }
        String batchID = Long.toString(timeStamp);
        // sending objects in one batch has same timeStamp
        if (mNotifications.containsKey(batchID)) {
        // NOTE: currently no such case
        // Batch sending case
        } else {
            NotificationItem item = new NotificationItem();
            item.timeStamp = timeStamp;
            item.id = id;
            item.direction = dir;
            if (item.direction == BluetoothShare.DIRECTION_OUTBOUND) {
                item.description = mContext.getString(R.string.notification_sending, fileName);
            } else if (item.direction == BluetoothShare.DIRECTION_INBOUND) {
                item.description = mContext.getString(R.string.notification_receiving, fileName);
            } else {
                if (V) {
                    Log.v(TAG, "mDirection ERROR!");
                }
            }
            item.totalCurrent = current;
            item.totalTotal = total;
            item.handoverInitiated = confirmation == BluetoothShare.USER_CONFIRMATION_HANDOVER_CONFIRMED;
            item.destination = destination;
            mNotifications.put(batchID, item);
            if (V) {
                Log.v(TAG, "ID=" + item.id + "; batchID=" + batchID + "; totoalCurrent" + item.totalCurrent + "; totalTotal=" + item.totalTotal);
            }
        }
    }
    cursor.close();
    // Add the notifications
    for (NotificationItem item : mNotifications.values()) {
        if (item.handoverInitiated) {
            float progress = 0;
            if (item.totalTotal == -1) {
                progress = -1;
            } else {
                progress = (float) item.totalCurrent / item.totalTotal;
            }
            // Let NFC service deal with notifications for this transfer
            Intent intent = new Intent(Constants.ACTION_BT_OPP_TRANSFER_PROGRESS);
            if (item.direction == BluetoothShare.DIRECTION_INBOUND) {
                intent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_DIRECTION, Constants.DIRECTION_BLUETOOTH_INCOMING);
            } else {
                intent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_DIRECTION, Constants.DIRECTION_BLUETOOTH_OUTGOING);
            }
            intent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_ID, item.id);
            intent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_PROGRESS, progress);
            intent.putExtra(Constants.EXTRA_BT_OPP_ADDRESS, item.destination);
            mContext.sendBroadcast(intent, Constants.HANDOVER_STATUS_PERMISSION);
            continue;
        }
        // Build the notification object
        // TODO: split description into two rows with filename in second row
        Notification.Builder b = new Notification.Builder(mContext, OPP_NOTIFICATION_CHANNEL);
        b.setOnlyAlertOnce(true);
        b.setColor(mContext.getResources().getColor(com.android.internal.R.color.system_notification_accent_color, mContext.getTheme()));
        b.setContentTitle(item.description);
        b.setSubText(BluetoothOppUtility.formatProgressText(item.totalTotal, item.totalCurrent));
        if (item.totalTotal != 0) {
            if (V) {
                Log.v(TAG, "mCurrentBytes: " + item.totalCurrent + " mTotalBytes: " + item.totalTotal + " (" + (int) ((item.totalCurrent * 100) / item.totalTotal) + " %)");
            }
            b.setProgress(100, (int) ((item.totalCurrent * 100) / item.totalTotal), item.totalTotal == -1);
        } else {
            b.setProgress(100, 100, item.totalTotal == -1);
        }
        b.setWhen(item.timeStamp);
        if (item.direction == BluetoothShare.DIRECTION_OUTBOUND) {
            b.setSmallIcon(android.R.drawable.stat_sys_upload);
        } else if (item.direction == BluetoothShare.DIRECTION_INBOUND) {
            b.setSmallIcon(android.R.drawable.stat_sys_download);
        } else {
            if (V) {
                Log.v(TAG, "mDirection ERROR!");
            }
        }
        b.setOngoing(true);
        Intent intent = new Intent(Constants.ACTION_LIST);
        intent.setClassName(Constants.THIS_PACKAGE_NAME, BluetoothOppReceiver.class.getName());
        intent.setDataAndNormalize(Uri.parse(BluetoothShare.CONTENT_URI + "/" + item.id));
        b.setContentIntent(PendingIntent.getBroadcast(mContext, 0, intent, 0));
        mNotificationMgr.notify(NOTIFICATION_ID_PROGRESS, b.build());
    }
}
#end_block

#method_before
private void updateCompletedNotification() {
    long timeStamp = 0;
    int outboundSuccNumber = 0;
    int outboundFailNumber = 0;
    int outboundNum;
    int inboundNum;
    int inboundSuccNumber = 0;
    int inboundFailNumber = 0;
    // notification
    if (!mUpdateCompleteNotification) {
        if (V)
            Log.v(TAG, "No need to update complete notification");
        return;
    }
    // transfer becomes complete.
    if (mNotificationMgr != null && mActiveNotificationId != 0) {
        mNotificationMgr.cancel(mActiveNotificationId);
        if (V)
            Log.v(TAG, "ongoing transfer notification was removed");
    }
    // Creating outbound notification
    Cursor cursor = mContext.getContentResolver().query(BluetoothShare.CONTENT_URI, null, WHERE_COMPLETED_OUTBOUND, null, BluetoothShare.TIMESTAMP + " DESC");
    if (cursor == null) {
        return;
    }
    final int timestampIndex = cursor.getColumnIndexOrThrow(BluetoothShare.TIMESTAMP);
    final int statusIndex = cursor.getColumnIndexOrThrow(BluetoothShare.STATUS);
    for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {
        if (cursor.isFirst()) {
            // Display the time for the latest transfer
            timeStamp = cursor.getLong(timestampIndex);
        }
        int status = cursor.getInt(statusIndex);
        if (BluetoothShare.isStatusError(status)) {
            outboundFailNumber++;
        } else {
            outboundSuccNumber++;
        }
    }
    if (V)
        Log.v(TAG, "outbound: succ-" + outboundSuccNumber + "  fail-" + outboundFailNumber);
    cursor.close();
    outboundNum = outboundSuccNumber + outboundFailNumber;
    // create the outbound notification
    if (outboundNum > 0) {
        String unsuccess_caption = mContext.getResources().getQuantityString(R.plurals.noti_caption_unsuccessful, outboundFailNumber, outboundFailNumber);
        String caption = mContext.getResources().getQuantityString(R.plurals.noti_caption_success, outboundSuccNumber, outboundSuccNumber, unsuccess_caption);
        Intent content_intent = new Intent(Constants.ACTION_OPEN_OUTBOUND_TRANSFER).setClassName(Constants.THIS_PACKAGE_NAME, BluetoothOppReceiver.class.getName());
        Intent delete_intent = new Intent(Constants.ACTION_COMPLETE_HIDE).setClassName(Constants.THIS_PACKAGE_NAME, BluetoothOppReceiver.class.getName());
        Notification outNoti = new Notification.Builder(mContext).setContentTitle(mContext.getString(R.string.outbound_noti_title)).setContentText(caption).setSmallIcon(android.R.drawable.stat_sys_upload_done).setColor(mContext.getResources().getColor(com.android.internal.R.color.system_notification_accent_color, mContext.getTheme())).setContentIntent(PendingIntent.getBroadcast(mContext, 0, content_intent, 0)).setDeleteIntent(PendingIntent.getBroadcast(mContext, 0, delete_intent, 0)).setWhen(timeStamp).build();
        mNotificationMgr.notify(NOTIFICATION_ID_OUTBOUND, outNoti);
    } else {
        if (mNotificationMgr != null) {
            mNotificationMgr.cancel(NOTIFICATION_ID_OUTBOUND);
            if (V)
                Log.v(TAG, "outbound notification was removed.");
        }
    }
    // Creating inbound notification
    cursor = mContext.getContentResolver().query(BluetoothShare.CONTENT_URI, null, WHERE_COMPLETED_INBOUND, null, BluetoothShare.TIMESTAMP + " DESC");
    if (cursor == null) {
        return;
    }
    for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {
        if (cursor.isFirst()) {
            // Display the time for the latest transfer
            timeStamp = cursor.getLong(timestampIndex);
        }
        int status = cursor.getInt(statusIndex);
        if (BluetoothShare.isStatusError(status)) {
            inboundFailNumber++;
        } else {
            inboundSuccNumber++;
        }
    }
    if (V)
        Log.v(TAG, "inbound: succ-" + inboundSuccNumber + "  fail-" + inboundFailNumber);
    cursor.close();
    inboundNum = inboundSuccNumber + inboundFailNumber;
    // create the inbound notification
    if (inboundNum > 0) {
        String unsuccess_caption = mContext.getResources().getQuantityString(R.plurals.noti_caption_unsuccessful, inboundFailNumber, inboundFailNumber);
        String caption = mContext.getResources().getQuantityString(R.plurals.noti_caption_success, inboundSuccNumber, inboundSuccNumber, unsuccess_caption);
        Intent content_intent = new Intent(Constants.ACTION_OPEN_INBOUND_TRANSFER).setClassName(Constants.THIS_PACKAGE_NAME, BluetoothOppReceiver.class.getName());
        Intent delete_intent = new Intent(Constants.ACTION_COMPLETE_HIDE).setClassName(Constants.THIS_PACKAGE_NAME, BluetoothOppReceiver.class.getName());
        Notification inNoti = new Notification.Builder(mContext).setContentTitle(mContext.getString(R.string.inbound_noti_title)).setContentText(caption).setSmallIcon(android.R.drawable.stat_sys_download_done).setColor(mContext.getResources().getColor(com.android.internal.R.color.system_notification_accent_color, mContext.getTheme())).setContentIntent(PendingIntent.getBroadcast(mContext, 0, content_intent, 0)).setDeleteIntent(PendingIntent.getBroadcast(mContext, 0, delete_intent, 0)).setWhen(timeStamp).build();
        mNotificationMgr.notify(NOTIFICATION_ID_INBOUND, inNoti);
    } else {
        if (mNotificationMgr != null) {
            mNotificationMgr.cancel(NOTIFICATION_ID_INBOUND);
            if (V)
                Log.v(TAG, "inbound notification was removed.");
        }
    }
}
#method_after
private void updateCompletedNotification() {
    long timeStamp = 0;
    int outboundSuccNumber = 0;
    int outboundFailNumber = 0;
    int outboundNum;
    int inboundNum;
    int inboundSuccNumber = 0;
    int inboundFailNumber = 0;
    // Creating outbound notification
    Cursor cursor = mContentResolver.query(BluetoothShare.CONTENT_URI, null, WHERE_COMPLETED_OUTBOUND, null, BluetoothShare.TIMESTAMP + " DESC");
    if (cursor == null) {
        return;
    }
    final int timestampIndex = cursor.getColumnIndexOrThrow(BluetoothShare.TIMESTAMP);
    final int statusIndex = cursor.getColumnIndexOrThrow(BluetoothShare.STATUS);
    for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {
        if (cursor.isFirst()) {
            // Display the time for the latest transfer
            timeStamp = cursor.getLong(timestampIndex);
        }
        int status = cursor.getInt(statusIndex);
        if (BluetoothShare.isStatusError(status)) {
            outboundFailNumber++;
        } else {
            outboundSuccNumber++;
        }
    }
    if (V) {
        Log.v(TAG, "outbound: succ-" + outboundSuccNumber + "  fail-" + outboundFailNumber);
    }
    cursor.close();
    outboundNum = outboundSuccNumber + outboundFailNumber;
    // create the outbound notification
    if (outboundNum > 0) {
        String unsuccessCaption = mContext.getResources().getQuantityString(R.plurals.noti_caption_unsuccessful, outboundFailNumber, outboundFailNumber);
        String caption = mContext.getResources().getQuantityString(R.plurals.noti_caption_success, outboundSuccNumber, outboundSuccNumber, unsuccessCaption);
        Intent contentIntent = new Intent(Constants.ACTION_OPEN_OUTBOUND_TRANSFER).setClassName(Constants.THIS_PACKAGE_NAME, BluetoothOppReceiver.class.getName());
        Intent deleteIntent = new Intent(Constants.ACTION_COMPLETE_HIDE).setClassName(Constants.THIS_PACKAGE_NAME, BluetoothOppReceiver.class.getName());
        Notification outNoti = new Notification.Builder(mContext, OPP_NOTIFICATION_CHANNEL).setOnlyAlertOnce(true).setContentTitle(mContext.getString(R.string.outbound_noti_title)).setContentText(caption).setSmallIcon(android.R.drawable.stat_sys_upload_done).setColor(mContext.getResources().getColor(com.android.internal.R.color.system_notification_accent_color, mContext.getTheme())).setContentIntent(PendingIntent.getBroadcast(mContext, 0, contentIntent, 0)).setDeleteIntent(PendingIntent.getBroadcast(mContext, 0, deleteIntent, 0)).setWhen(timeStamp).build();
        mNotificationMgr.notify(NOTIFICATION_ID_OUTBOUND_COMPLETE, outNoti);
    } else {
        if (mNotificationMgr != null) {
            mNotificationMgr.cancel(NOTIFICATION_ID_OUTBOUND_COMPLETE);
            if (V) {
                Log.v(TAG, "outbound notification was removed.");
            }
        }
    }
    // Creating inbound notification
    cursor = mContentResolver.query(BluetoothShare.CONTENT_URI, null, WHERE_COMPLETED_INBOUND, null, BluetoothShare.TIMESTAMP + " DESC");
    if (cursor == null) {
        return;
    }
    for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {
        if (cursor.isFirst()) {
            // Display the time for the latest transfer
            timeStamp = cursor.getLong(timestampIndex);
        }
        int status = cursor.getInt(statusIndex);
        if (BluetoothShare.isStatusError(status)) {
            inboundFailNumber++;
        } else {
            inboundSuccNumber++;
        }
    }
    if (V) {
        Log.v(TAG, "inbound: succ-" + inboundSuccNumber + "  fail-" + inboundFailNumber);
    }
    cursor.close();
    inboundNum = inboundSuccNumber + inboundFailNumber;
    // create the inbound notification
    if (inboundNum > 0) {
        String unsuccessCaption = mContext.getResources().getQuantityString(R.plurals.noti_caption_unsuccessful, inboundFailNumber, inboundFailNumber);
        String caption = mContext.getResources().getQuantityString(R.plurals.noti_caption_success, inboundSuccNumber, inboundSuccNumber, unsuccessCaption);
        Intent contentIntent = new Intent(Constants.ACTION_OPEN_INBOUND_TRANSFER).setClassName(Constants.THIS_PACKAGE_NAME, BluetoothOppReceiver.class.getName());
        Intent deleteIntent = new Intent(Constants.ACTION_COMPLETE_HIDE).setClassName(Constants.THIS_PACKAGE_NAME, BluetoothOppReceiver.class.getName());
        Notification inNoti = new Notification.Builder(mContext, OPP_NOTIFICATION_CHANNEL).setOnlyAlertOnce(true).setContentTitle(mContext.getString(R.string.inbound_noti_title)).setContentText(caption).setSmallIcon(android.R.drawable.stat_sys_download_done).setColor(mContext.getResources().getColor(com.android.internal.R.color.system_notification_accent_color, mContext.getTheme())).setContentIntent(PendingIntent.getBroadcast(mContext, 0, contentIntent, 0)).setDeleteIntent(PendingIntent.getBroadcast(mContext, 0, deleteIntent, 0)).setWhen(timeStamp).build();
        mNotificationMgr.notify(NOTIFICATION_ID_INBOUND_COMPLETE, inNoti);
    } else {
        if (mNotificationMgr != null) {
            mNotificationMgr.cancel(NOTIFICATION_ID_INBOUND_COMPLETE);
            if (V) {
                Log.v(TAG, "inbound notification was removed.");
            }
        }
    }
}
#end_block

#method_before
private void updateIncomingFileConfirmNotification() {
    Cursor cursor = mContext.getContentResolver().query(BluetoothShare.CONTENT_URI, null, WHERE_CONFIRM_PENDING, null, BluetoothShare._ID);
    if (cursor == null) {
        return;
    }
    mIncomingNotificationId = 0;
    for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {
        BluetoothOppTransferInfo info = new BluetoothOppTransferInfo();
        BluetoothOppUtility.fillRecord(mContext, cursor, info);
        Uri contentUri = Uri.parse(BluetoothShare.CONTENT_URI + "/" + info.mID);
        Intent baseIntent = new Intent().setDataAndNormalize(contentUri).setClassName(Constants.THIS_PACKAGE_NAME, BluetoothOppReceiver.class.getName());
        Notification n = new Notification.Builder(mContext).setOnlyAlertOnce(true).setOngoing(true).setVibrate(new long[] { 200 }).setWhen(info.mTimeStamp).setDefaults(Notification.DEFAULT_SOUND).setPriority(Notification.PRIORITY_HIGH).addAction(R.drawable.ic_decline, mContext.getText(R.string.incoming_file_confirm_cancel), PendingIntent.getBroadcast(mContext, 0, new Intent(baseIntent).setAction(Constants.ACTION_DECLINE), 0)).addAction(R.drawable.ic_accept, mContext.getText(R.string.incoming_file_confirm_ok), PendingIntent.getBroadcast(mContext, 0, new Intent(baseIntent).setAction(Constants.ACTION_ACCEPT), 0)).setContentIntent(PendingIntent.getBroadcast(mContext, 0, new Intent(baseIntent).setAction(Constants.ACTION_INCOMING_FILE_CONFIRM), 0)).setDeleteIntent(PendingIntent.getBroadcast(mContext, 0, new Intent(baseIntent).setAction(Constants.ACTION_HIDE), 0)).setColor(mContext.getResources().getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(mContext.getText(R.string.incoming_file_confirm_Notification_title)).setContentText(info.mFileName).setStyle(new Notification.BigTextStyle().bigText(mContext.getString(R.string.incoming_file_confirm_Notification_content, info.mDeviceName, info.mFileName))).setContentInfo(Formatter.formatFileSize(mContext, info.mTotalBytes)).setSmallIcon(R.drawable.bt_incomming_file_notification).build();
        mNotificationMgr.notify(info.mID, n);
        mIncomingNotificationId = info.mID;
    }
    cursor.close();
}
#method_after
private void updateIncomingFileConfirmNotification() {
    Cursor cursor = mContentResolver.query(BluetoothShare.CONTENT_URI, null, WHERE_CONFIRM_PENDING, null, BluetoothShare._ID);
    if (cursor == null) {
        return;
    }
    for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {
        BluetoothOppTransferInfo info = new BluetoothOppTransferInfo();
        BluetoothOppUtility.fillRecord(mContext, cursor, info);
        Uri contentUri = Uri.parse(BluetoothShare.CONTENT_URI + "/" + info.mID);
        Intent baseIntent = new Intent().setDataAndNormalize(contentUri).setClassName(Constants.THIS_PACKAGE_NAME, BluetoothOppReceiver.class.getName());
        Notification.Action actionDecline = new Notification.Action.Builder(R.drawable.ic_decline, mContext.getText(R.string.incoming_file_confirm_cancel), PendingIntent.getBroadcast(mContext, 0, new Intent(baseIntent).setAction(Constants.ACTION_DECLINE), 0)).build();
        Notification.Action actionAccept = new Notification.Action.Builder(R.drawable.ic_accept, mContext.getText(R.string.incoming_file_confirm_ok), PendingIntent.getBroadcast(mContext, 0, new Intent(baseIntent).setAction(Constants.ACTION_ACCEPT), 0)).build();
        Notification n = new Notification.Builder(mContext, OPP_NOTIFICATION_CHANNEL).setOnlyAlertOnce(true).setOngoing(true).setWhen(info.mTimeStamp).addAction(actionDecline).addAction(actionAccept).setContentIntent(PendingIntent.getBroadcast(mContext, 0, new Intent(baseIntent).setAction(Constants.ACTION_INCOMING_FILE_CONFIRM), 0)).setDeleteIntent(PendingIntent.getBroadcast(mContext, 0, new Intent(baseIntent).setAction(Constants.ACTION_HIDE), 0)).setColor(mContext.getResources().getColor(com.android.internal.R.color.system_notification_accent_color, mContext.getTheme())).setContentTitle(mContext.getText(R.string.incoming_file_confirm_Notification_title)).setContentText(info.mFileName).setStyle(new Notification.BigTextStyle().bigText(mContext.getString(R.string.incoming_file_confirm_Notification_content, info.mDeviceName, info.mFileName))).setContentInfo(Formatter.formatFileSize(mContext, info.mTotalBytes)).setSmallIcon(R.drawable.bt_incomming_file_notification).build();
        mNotificationMgr.notify(NOTIFICATION_ID_PROGRESS, n);
    }
    cursor.close();
}
#end_block

#method_before
@Override
public void onChange(boolean selfChange) {
    if (V)
        Log.v(TAG, "ContentObserver received notification");
    updateFromProvider();
}
#method_after
@Override
public void onChange(boolean selfChange) {
    if (V) {
        Log.v(TAG, "ContentObserver received notification");
    }
    updateFromProvider();
}
#end_block

#method_before
@Override
protected void create() {
    if (V)
        Log.v(TAG, "onCreate");
    mShares = Lists.newArrayList();
    mBatchs = Lists.newArrayList();
    mObserver = new BluetoothShareContentObserver();
    getContentResolver().registerContentObserver(BluetoothShare.CONTENT_URI, true, mObserver);
    mBatchId = 1;
    mNotifier = new BluetoothOppNotification(this);
    mNotifier.mNotificationMgr.cancelAll();
    mNotifier.updateNotification();
    final ContentResolver contentResolver = getContentResolver();
    new Thread("trimDatabase") {

        public void run() {
            trimDatabase(contentResolver);
        }
    }.start();
    IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
    registerReceiver(mBluetoothReceiver, filter);
    synchronized (BluetoothOppService.this) {
        if (mAdapter == null) {
            Log.w(TAG, "Local BT device is not enabled");
        }
    }
    if (V)
        BluetoothOppPreference.getInstance(this).dump();
    updateFromProvider();
}
#method_after
@Override
protected void create() {
    if (V) {
        Log.v(TAG, "onCreate");
    }
    mShares = Lists.newArrayList();
    mBatchs = Lists.newArrayList();
    mBatchId = 1;
    final ContentResolver contentResolver = getContentResolver();
    new Thread("trimDatabase") {

        @Override
        public void run() {
            trimDatabase(contentResolver);
        }
    }.start();
    IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
    registerReceiver(mBluetoothReceiver, filter);
    synchronized (BluetoothOppService.this) {
        if (mAdapter == null) {
            Log.w(TAG, "Local BT device is not enabled");
        }
    }
    if (V) {
        BluetoothOppPreference.getInstance(this).dump();
    }
    updateFromProvider();
}
#end_block

#method_before
@Override
public boolean start() {
    if (V)
        Log.v(TAG, "start()");
    updateFromProvider();
    return true;
}
#method_after
@Override
public boolean start() {
    if (V) {
        Log.v(TAG, "start()");
    }
    /* Register observer during BT on */
    mObserver = new BluetoothShareContentObserver();
    getContentResolver().registerContentObserver(BluetoothShare.CONTENT_URI, true, mObserver);
    mNotifier = new BluetoothOppNotification(this);
    mNotifier.mNotificationMgr.cancelAll();
    mNotifier.updateNotification();
    updateFromProvider();
    return true;
}
#end_block

#method_before
private void startListener() {
    if (!mListenStarted) {
        if (mAdapter.isEnabled()) {
            if (V)
                Log.v(TAG, "Starting RfcommListener");
            mHandler.sendMessage(mHandler.obtainMessage(START_LISTENER));
            mListenStarted = true;
        }
    }
}
#method_after
private void startListener() {
    if (!mListenStarted) {
        if (mAdapter.isEnabled()) {
            if (V) {
                Log.v(TAG, "Starting RfcommListener");
            }
            mHandler.sendMessage(mHandler.obtainMessage(START_LISTENER));
            mListenStarted = true;
        }
    }
}
#end_block

#method_before
private void startSocketListener() {
    if (D)
        Log.d(TAG, "start Socket Listeners");
    stopListeners();
    mServerSocket = ObexServerSockets.createInsecure(this);
    SdpManager sdpManager = SdpManager.getDefaultManager();
    if (sdpManager == null || mServerSocket == null) {
        Log.e(TAG, "ERROR:serversocket object is NULL  sdp manager :" + sdpManager + " mServerSocket:" + mServerSocket);
        return;
    }
    sdpManager.createOppOpsRecord("OBEX Object Push", mServerSocket.getRfcommChannel(), mServerSocket.getL2capPsm(), 0x0102, SdpManager.OPP_FORMAT_ALL);
}
#method_after
private void startSocketListener() {
    if (D) {
        Log.d(TAG, "start Socket Listeners");
    }
    stopListeners();
    mServerSocket = ObexServerSockets.createInsecure(this);
    SdpManager sdpManager = SdpManager.getDefaultManager();
    if (sdpManager == null || mServerSocket == null) {
        Log.e(TAG, "ERROR:serversocket object is NULL  sdp manager :" + sdpManager + " mServerSocket:" + mServerSocket);
        return;
    }
    mOppSdpHandle = sdpManager.createOppOpsRecord("OBEX Object Push", mServerSocket.getRfcommChannel(), mServerSocket.getL2capPsm(), 0x0102, SUPPORTED_OPP_FORMAT);
    if (D) {
        Log.d(TAG, "mOppSdpHandle :" + mOppSdpHandle);
    }
}
#end_block

#method_before
@Override
public boolean cleanup() {
    if (V)
        Log.v(TAG, "onDestroy");
    getContentResolver().unregisterContentObserver(mObserver);
    unregisterReceiver(mBluetoothReceiver);
    stopListeners();
    if (mBatchs != null) {
        mBatchs.clear();
    }
    if (mShares != null) {
        mShares.clear();
    }
    if (mHandler != null) {
        mHandler.removeCallbacksAndMessages(null);
    }
    return true;
}
#method_after
@Override
public boolean cleanup() {
    if (V) {
        Log.v(TAG, "onDestroy");
    }
    stopListeners();
    if (mBatchs != null) {
        mBatchs.clear();
    }
    if (mShares != null) {
        mShares.clear();
    }
    if (mHandler != null) {
        mHandler.removeCallbacksAndMessages(null);
    }
    return true;
}
#end_block

#method_before
private void createServerSession(ObexTransport transport) {
    mServerSession = new BluetoothOppObexServerSession(this, transport, mServerSocket);
    mServerSession.preStart();
    if (D)
        Log.d(TAG, "Get ServerSession " + mServerSession.toString() + " for incoming connection" + transport.toString());
}
#method_after
private void createServerSession(ObexTransport transport) {
    mServerSession = new BluetoothOppObexServerSession(this, transport, mServerSocket);
    mServerSession.preStart();
    if (D) {
        Log.d(TAG, "Get ServerSession " + mServerSession.toString() + " for incoming connection" + transport.toString());
    }
}
#end_block

#method_before
@Override
public void interrupt() {
    isInterrupted = true;
    if (D)
        Log.d(TAG, "Interrupted :" + isInterrupted);
    super.interrupt();
}
#method_after
@Override
public void interrupt() {
    mIsInterrupted = true;
    if (D) {
        Log.d(TAG, "Interrupted :" + mIsInterrupted);
    }
    super.interrupt();
}
#end_block

#method_before
@Override
public void run() {
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
    boolean keepService = false;
    while (!isInterrupted) {
        synchronized (BluetoothOppService.this) {
            if (mUpdateThread != this) {
                throw new IllegalStateException("multiple UpdateThreads in BluetoothOppService");
            }
            if (V)
                Log.v(TAG, "pendingUpdate is " + mPendingUpdate + " keepUpdateThread is " + keepService + " sListenStarted is " + mListenStarted + " isInterrupted :" + isInterrupted);
            if (!mPendingUpdate) {
                mUpdateThread = null;
                return;
            }
            mPendingUpdate = false;
        }
        Cursor cursor = getContentResolver().query(BluetoothShare.CONTENT_URI, null, null, null, BluetoothShare._ID);
        if (cursor == null) {
            return;
        }
        cursor.moveToFirst();
        int arrayPos = 0;
        keepService = false;
        boolean isAfterLast = cursor.isAfterLast();
        int idColumn = cursor.getColumnIndexOrThrow(BluetoothShare._ID);
        /*
                 * Walk the cursor and the local array to keep them in sync. The
                 * key to the algorithm is that the ids are unique and sorted
                 * both in the cursor and in the array, so that they can be
                 * processed in order in both sources at the same time: at each
                 * step, both sources point to the lowest id that hasn't been
                 * processed from that source, and the algorithm processes the
                 * lowest id from those two possibilities. At each step: -If the
                 * array contains an entry that's not in the cursor, remove the
                 * entry, move to next entry in the array. -If the array
                 * contains an entry that's in the cursor, nothing to do, move
                 * to next cursor row and next array entry. -If the cursor
                 * contains an entry that's not in the array, insert a new entry
                 * in the array, move to next cursor row and next array entry.
                 */
        while (!isAfterLast || arrayPos < mShares.size() && mListenStarted) {
            if (isAfterLast) {
                // stuff in the local array, which can only be junk
                if (mShares.size() != 0)
                    if (V)
                        Log.v(TAG, "Array update: trimming " + mShares.get(arrayPos).mId + " @ " + arrayPos);
                if (shouldScanFile(arrayPos)) {
                    scanFile(null, arrayPos);
                }
                // this advances in the array
                deleteShare(arrayPos);
            } else {
                int id = cursor.getInt(idColumn);
                if (arrayPos == mShares.size()) {
                    insertShare(cursor, arrayPos);
                    if (V)
                        Log.v(TAG, "Array update: inserting " + id + " @ " + arrayPos);
                    if (shouldScanFile(arrayPos) && (!scanFile(cursor, arrayPos))) {
                        keepService = true;
                    }
                    if (visibleNotification(arrayPos)) {
                        keepService = true;
                    }
                    if (needAction(arrayPos)) {
                        keepService = true;
                    }
                    ++arrayPos;
                    cursor.moveToNext();
                    isAfterLast = cursor.isAfterLast();
                } else {
                    int arrayId = 0;
                    if (mShares.size() != 0)
                        arrayId = mShares.get(arrayPos).mId;
                    if (arrayId < id) {
                        if (V)
                            Log.v(TAG, "Array update: removing " + arrayId + " @ " + arrayPos);
                        if (shouldScanFile(arrayPos)) {
                            scanFile(null, arrayPos);
                        }
                        deleteShare(arrayPos);
                    } else if (arrayId == id) {
                        // This cursor row already exists in the stored
                        // array
                        updateShare(cursor, arrayPos, userAccepted);
                        if (shouldScanFile(arrayPos) && (!scanFile(cursor, arrayPos))) {
                            keepService = true;
                        }
                        if (visibleNotification(arrayPos)) {
                            keepService = true;
                        }
                        if (needAction(arrayPos)) {
                            keepService = true;
                        }
                        ++arrayPos;
                        cursor.moveToNext();
                        isAfterLast = cursor.isAfterLast();
                    } else {
                        // array
                        if (V)
                            Log.v(TAG, "Array update: appending " + id + " @ " + arrayPos);
                        insertShare(cursor, arrayPos);
                        if (shouldScanFile(arrayPos) && (!scanFile(cursor, arrayPos))) {
                            keepService = true;
                        }
                        if (visibleNotification(arrayPos)) {
                            keepService = true;
                        }
                        if (needAction(arrayPos)) {
                            keepService = true;
                        }
                        ++arrayPos;
                        cursor.moveToNext();
                        isAfterLast = cursor.isAfterLast();
                    }
                }
            }
        }
        mNotifier.updateNotification();
        cursor.close();
    }
}
#method_after
@Override
public void run() {
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
    boolean keepService = false;
    while (!mIsInterrupted) {
        synchronized (BluetoothOppService.this) {
            if (mUpdateThread != this) {
                throw new IllegalStateException("multiple UpdateThreads in BluetoothOppService");
            }
            if (V) {
                Log.v(TAG, "pendingUpdate is " + mPendingUpdate + " keepUpdateThread is " + keepService + " sListenStarted is " + mListenStarted + " isInterrupted :" + mIsInterrupted);
            }
            if (!mPendingUpdate) {
                mUpdateThread = null;
                return;
            }
            mPendingUpdate = false;
        }
        Cursor cursor = getContentResolver().query(BluetoothShare.CONTENT_URI, null, null, null, BluetoothShare._ID);
        if (cursor == null) {
            return;
        }
        cursor.moveToFirst();
        int arrayPos = 0;
        keepService = false;
        boolean isAfterLast = cursor.isAfterLast();
        int idColumn = cursor.getColumnIndexOrThrow(BluetoothShare._ID);
        /*
                 * Walk the cursor and the local array to keep them in sync. The
                 * key to the algorithm is that the ids are unique and sorted
                 * both in the cursor and in the array, so that they can be
                 * processed in order in both sources at the same time: at each
                 * step, both sources point to the lowest id that hasn't been
                 * processed from that source, and the algorithm processes the
                 * lowest id from those two possibilities. At each step: -If the
                 * array contains an entry that's not in the cursor, remove the
                 * entry, move to next entry in the array. -If the array
                 * contains an entry that's in the cursor, nothing to do, move
                 * to next cursor row and next array entry. -If the cursor
                 * contains an entry that's not in the array, insert a new entry
                 * in the array, move to next cursor row and next array entry.
                 */
        while (!isAfterLast || arrayPos < mShares.size() && mListenStarted) {
            if (isAfterLast) {
                // stuff in the local array, which can only be junk
                if (mShares.size() != 0) {
                    if (V) {
                        Log.v(TAG, "Array update: trimming " + mShares.get(arrayPos).mId + " @ " + arrayPos);
                    }
                }
                if (shouldScanFile(arrayPos)) {
                    scanFile(null, arrayPos);
                }
                // this advances in the array
                deleteShare(arrayPos);
            } else {
                int id = cursor.getInt(idColumn);
                if (arrayPos == mShares.size()) {
                    insertShare(cursor, arrayPos);
                    if (V) {
                        Log.v(TAG, "Array update: inserting " + id + " @ " + arrayPos);
                    }
                    if (shouldScanFile(arrayPos) && (!scanFile(cursor, arrayPos))) {
                        keepService = true;
                    }
                    if (visibleNotification(arrayPos)) {
                        keepService = true;
                    }
                    if (needAction(arrayPos)) {
                        keepService = true;
                    }
                    ++arrayPos;
                    cursor.moveToNext();
                    isAfterLast = cursor.isAfterLast();
                } else {
                    int arrayId = 0;
                    if (mShares.size() != 0) {
                        arrayId = mShares.get(arrayPos).mId;
                    }
                    if (arrayId < id) {
                        if (V) {
                            Log.v(TAG, "Array update: removing " + arrayId + " @ " + arrayPos);
                        }
                        if (shouldScanFile(arrayPos)) {
                            scanFile(null, arrayPos);
                        }
                        deleteShare(arrayPos);
                    } else if (arrayId == id) {
                        // This cursor row already exists in the stored
                        // array
                        updateShare(cursor, arrayPos, mUserAccepted);
                        if (shouldScanFile(arrayPos) && (!scanFile(cursor, arrayPos))) {
                            keepService = true;
                        }
                        if (visibleNotification(arrayPos)) {
                            keepService = true;
                        }
                        if (needAction(arrayPos)) {
                            keepService = true;
                        }
                        ++arrayPos;
                        cursor.moveToNext();
                        isAfterLast = cursor.isAfterLast();
                    } else {
                        // array
                        if (V) {
                            Log.v(TAG, "Array update: appending " + id + " @ " + arrayPos);
                        }
                        insertShare(cursor, arrayPos);
                        if (shouldScanFile(arrayPos) && (!scanFile(cursor, arrayPos))) {
                            keepService = true;
                        }
                        if (visibleNotification(arrayPos)) {
                            keepService = true;
                        }
                        if (needAction(arrayPos)) {
                            keepService = true;
                        }
                        ++arrayPos;
                        cursor.moveToNext();
                        isAfterLast = cursor.isAfterLast();
                    }
                }
            }
        }
        mNotifier.updateNotification();
        cursor.close();
    }
}
#end_block

#method_before
private void insertShare(Cursor cursor, int arrayPos) {
    String uriString = cursor.getString(cursor.getColumnIndexOrThrow(BluetoothShare.URI));
    Uri uri;
    if (uriString != null) {
        uri = Uri.parse(uriString);
        Log.d(TAG, "insertShare parsed URI: " + uri);
    } else {
        uri = null;
        Log.e(TAG, "insertShare found null URI at cursor!");
    }
    BluetoothOppShareInfo info = new BluetoothOppShareInfo(cursor.getInt(cursor.getColumnIndexOrThrow(BluetoothShare._ID)), uri, cursor.getString(cursor.getColumnIndexOrThrow(BluetoothShare.FILENAME_HINT)), cursor.getString(cursor.getColumnIndexOrThrow(BluetoothShare._DATA)), cursor.getString(cursor.getColumnIndexOrThrow(BluetoothShare.MIMETYPE)), cursor.getInt(cursor.getColumnIndexOrThrow(BluetoothShare.DIRECTION)), cursor.getString(cursor.getColumnIndexOrThrow(BluetoothShare.DESTINATION)), cursor.getInt(cursor.getColumnIndexOrThrow(BluetoothShare.VISIBILITY)), cursor.getInt(cursor.getColumnIndexOrThrow(BluetoothShare.USER_CONFIRMATION)), cursor.getInt(cursor.getColumnIndexOrThrow(BluetoothShare.STATUS)), cursor.getLong(cursor.getColumnIndexOrThrow(BluetoothShare.TOTAL_BYTES)), cursor.getLong(cursor.getColumnIndexOrThrow(BluetoothShare.CURRENT_BYTES)), cursor.getLong(cursor.getColumnIndexOrThrow(BluetoothShare.TIMESTAMP)), cursor.getInt(cursor.getColumnIndexOrThrow(Constants.MEDIA_SCANNED)) != Constants.MEDIA_SCANNED_NOT_SCANNED);
    if (V) {
        Log.v(TAG, "Service adding new entry");
        Log.v(TAG, "ID      : " + info.mId);
        // Log.v(TAG, "URI     : " + ((info.mUri != null) ? "yes" : "no"));
        Log.v(TAG, "URI     : " + info.mUri);
        Log.v(TAG, "HINT    : " + info.mHint);
        Log.v(TAG, "FILENAME: " + info.mFilename);
        Log.v(TAG, "MIMETYPE: " + info.mMimetype);
        Log.v(TAG, "DIRECTION: " + info.mDirection);
        Log.v(TAG, "DESTINAT: " + info.mDestination);
        Log.v(TAG, "VISIBILI: " + info.mVisibility);
        Log.v(TAG, "CONFIRM : " + info.mConfirm);
        Log.v(TAG, "STATUS  : " + info.mStatus);
        Log.v(TAG, "TOTAL   : " + info.mTotalBytes);
        Log.v(TAG, "CURRENT : " + info.mCurrentBytes);
        Log.v(TAG, "TIMESTAMP : " + info.mTimestamp);
        Log.v(TAG, "SCANNED : " + info.mMediaScanned);
    }
    mShares.add(arrayPos, info);
    /* Mark the info as failed if it's in invalid status */
    if (info.isObsolete()) {
        Constants.updateShareStatus(this, info.mId, BluetoothShare.STATUS_UNKNOWN_ERROR);
    }
    if (info.isReadyToStart()) {
        if (info.mDirection == BluetoothShare.DIRECTION_OUTBOUND) {
            /* check if the file exists */
            BluetoothOppSendFileInfo sendFileInfo = BluetoothOppUtility.getSendFileInfo(info.mUri);
            if (sendFileInfo == null || sendFileInfo.mInputStream == null) {
                Log.e(TAG, "Can't open file for OUTBOUND info " + info.mId);
                Constants.updateShareStatus(this, info.mId, BluetoothShare.STATUS_BAD_REQUEST);
                BluetoothOppUtility.closeSendFileInfo(info.mUri);
                return;
            }
        }
        if (mBatchs.size() == 0) {
            BluetoothOppBatch newBatch = new BluetoothOppBatch(this, info);
            newBatch.mId = mBatchId;
            mBatchId++;
            mBatchs.add(newBatch);
            if (info.mDirection == BluetoothShare.DIRECTION_OUTBOUND) {
                if (V)
                    Log.v(TAG, "Service create new Batch " + newBatch.mId + " for OUTBOUND info " + info.mId);
                mTransfer = new BluetoothOppTransfer(this, mPowerManager, newBatch);
            } else if (info.mDirection == BluetoothShare.DIRECTION_INBOUND) {
                if (V)
                    Log.v(TAG, "Service create new Batch " + newBatch.mId + " for INBOUND info " + info.mId);
                mServerTransfer = new BluetoothOppTransfer(this, mPowerManager, newBatch, mServerSession);
            }
            if (info.mDirection == BluetoothShare.DIRECTION_OUTBOUND && mTransfer != null) {
                if (V)
                    Log.v(TAG, "Service start transfer new Batch " + newBatch.mId + " for info " + info.mId);
                mTransfer.start();
            } else if (info.mDirection == BluetoothShare.DIRECTION_INBOUND && mServerTransfer != null) {
                if (V)
                    Log.v(TAG, "Service start server transfer new Batch " + newBatch.mId + " for info " + info.mId);
                mServerTransfer.start();
            }
        } else {
            int i = findBatchWithTimeStamp(info.mTimestamp);
            if (i != -1) {
                if (V)
                    Log.v(TAG, "Service add info " + info.mId + " to existing batch " + mBatchs.get(i).mId);
                mBatchs.get(i).addShare(info);
            } else {
                // There is ongoing batch
                BluetoothOppBatch newBatch = new BluetoothOppBatch(this, info);
                newBatch.mId = mBatchId;
                mBatchId++;
                mBatchs.add(newBatch);
                if (V)
                    Log.v(TAG, "Service add new Batch " + newBatch.mId + " for info " + info.mId);
                if (Constants.USE_TCP_DEBUG && !Constants.USE_TCP_SIMPLE_SERVER) {
                    // only allow  concurrent serverTransfer in debug mode
                    if (info.mDirection == BluetoothShare.DIRECTION_INBOUND) {
                        if (V)
                            Log.v(TAG, "TCP_DEBUG start server transfer new Batch " + newBatch.mId + " for info " + info.mId);
                        mServerTransfer = new BluetoothOppTransfer(this, mPowerManager, newBatch, mServerSession);
                        mServerTransfer.start();
                    }
                }
            }
        }
    }
}
#method_after
private void insertShare(Cursor cursor, int arrayPos) {
    String uriString = cursor.getString(cursor.getColumnIndexOrThrow(BluetoothShare.URI));
    Uri uri;
    if (uriString != null) {
        uri = Uri.parse(uriString);
        Log.d(TAG, "insertShare parsed URI: " + uri);
    } else {
        uri = null;
        Log.e(TAG, "insertShare found null URI at cursor!");
    }
    BluetoothOppShareInfo info = new BluetoothOppShareInfo(cursor.getInt(cursor.getColumnIndexOrThrow(BluetoothShare._ID)), uri, cursor.getString(cursor.getColumnIndexOrThrow(BluetoothShare.FILENAME_HINT)), cursor.getString(cursor.getColumnIndexOrThrow(BluetoothShare._DATA)), cursor.getString(cursor.getColumnIndexOrThrow(BluetoothShare.MIMETYPE)), cursor.getInt(cursor.getColumnIndexOrThrow(BluetoothShare.DIRECTION)), cursor.getString(cursor.getColumnIndexOrThrow(BluetoothShare.DESTINATION)), cursor.getInt(cursor.getColumnIndexOrThrow(BluetoothShare.VISIBILITY)), cursor.getInt(cursor.getColumnIndexOrThrow(BluetoothShare.USER_CONFIRMATION)), cursor.getInt(cursor.getColumnIndexOrThrow(BluetoothShare.STATUS)), cursor.getLong(cursor.getColumnIndexOrThrow(BluetoothShare.TOTAL_BYTES)), cursor.getLong(cursor.getColumnIndexOrThrow(BluetoothShare.CURRENT_BYTES)), cursor.getLong(cursor.getColumnIndexOrThrow(BluetoothShare.TIMESTAMP)), cursor.getInt(cursor.getColumnIndexOrThrow(Constants.MEDIA_SCANNED)) != Constants.MEDIA_SCANNED_NOT_SCANNED);
    if (V) {
        Log.v(TAG, "Service adding new entry");
        Log.v(TAG, "ID      : " + info.mId);
        // Log.v(TAG, "URI     : " + ((info.mUri != null) ? "yes" : "no"));
        Log.v(TAG, "URI     : " + info.mUri);
        Log.v(TAG, "HINT    : " + info.mHint);
        Log.v(TAG, "FILENAME: " + info.mFilename);
        Log.v(TAG, "MIMETYPE: " + info.mMimetype);
        Log.v(TAG, "DIRECTION: " + info.mDirection);
        Log.v(TAG, "DESTINAT: " + info.mDestination);
        Log.v(TAG, "VISIBILI: " + info.mVisibility);
        Log.v(TAG, "CONFIRM : " + info.mConfirm);
        Log.v(TAG, "STATUS  : " + info.mStatus);
        Log.v(TAG, "TOTAL   : " + info.mTotalBytes);
        Log.v(TAG, "CURRENT : " + info.mCurrentBytes);
        Log.v(TAG, "TIMESTAMP : " + info.mTimestamp);
        Log.v(TAG, "SCANNED : " + info.mMediaScanned);
    }
    mShares.add(arrayPos, info);
    /* Mark the info as failed if it's in invalid status */
    if (info.isObsolete()) {
        Constants.updateShareStatus(this, info.mId, BluetoothShare.STATUS_UNKNOWN_ERROR);
    }
    if (info.isReadyToStart()) {
        if (info.mDirection == BluetoothShare.DIRECTION_OUTBOUND) {
            /* check if the file exists */
            BluetoothOppSendFileInfo sendFileInfo = BluetoothOppUtility.getSendFileInfo(info.mUri);
            if (sendFileInfo == null || sendFileInfo.mInputStream == null) {
                Log.e(TAG, "Can't open file for OUTBOUND info " + info.mId);
                Constants.updateShareStatus(this, info.mId, BluetoothShare.STATUS_BAD_REQUEST);
                BluetoothOppUtility.closeSendFileInfo(info.mUri);
                return;
            }
        }
        if (mBatchs.size() == 0) {
            BluetoothOppBatch newBatch = new BluetoothOppBatch(this, info);
            newBatch.mId = mBatchId;
            mBatchId++;
            mBatchs.add(newBatch);
            if (info.mDirection == BluetoothShare.DIRECTION_OUTBOUND) {
                if (V) {
                    Log.v(TAG, "Service create new Batch " + newBatch.mId + " for OUTBOUND info " + info.mId);
                }
                mTransfer = new BluetoothOppTransfer(this, mPowerManager, newBatch);
            } else if (info.mDirection == BluetoothShare.DIRECTION_INBOUND) {
                if (V) {
                    Log.v(TAG, "Service create new Batch " + newBatch.mId + " for INBOUND info " + info.mId);
                }
                mServerTransfer = new BluetoothOppTransfer(this, mPowerManager, newBatch, mServerSession);
            }
            if (info.mDirection == BluetoothShare.DIRECTION_OUTBOUND && mTransfer != null) {
                if (V) {
                    Log.v(TAG, "Service start transfer new Batch " + newBatch.mId + " for info " + info.mId);
                }
                mTransfer.start();
            } else if (info.mDirection == BluetoothShare.DIRECTION_INBOUND && mServerTransfer != null) {
                if (V) {
                    Log.v(TAG, "Service start server transfer new Batch " + newBatch.mId + " for info " + info.mId);
                }
                mServerTransfer.start();
            }
        } else {
            int i = findBatchWithTimeStamp(info.mTimestamp);
            if (i != -1) {
                if (V) {
                    Log.v(TAG, "Service add info " + info.mId + " to existing batch " + mBatchs.get(i).mId);
                }
                mBatchs.get(i).addShare(info);
            } else {
                // There is ongoing batch
                BluetoothOppBatch newBatch = new BluetoothOppBatch(this, info);
                newBatch.mId = mBatchId;
                mBatchId++;
                mBatchs.add(newBatch);
                if (V) {
                    Log.v(TAG, "Service add new Batch " + newBatch.mId + " for info " + info.mId);
                }
                if (Constants.USE_TCP_DEBUG && !Constants.USE_TCP_SIMPLE_SERVER) {
                    // only allow  concurrent serverTransfer in debug mode
                    if (info.mDirection == BluetoothShare.DIRECTION_INBOUND) {
                        if (V) {
                            Log.v(TAG, "TCP_DEBUG start server transfer new Batch " + newBatch.mId + " for info " + info.mId);
                        }
                        mServerTransfer = new BluetoothOppTransfer(this, mPowerManager, newBatch, mServerSession);
                        mServerTransfer.start();
                    }
                }
            }
        }
    }
}
#end_block

#method_before
private void updateShare(Cursor cursor, int arrayPos, boolean userAccepted) {
    BluetoothOppShareInfo info = mShares.get(arrayPos);
    int statusColumn = cursor.getColumnIndexOrThrow(BluetoothShare.STATUS);
    info.mId = cursor.getInt(cursor.getColumnIndexOrThrow(BluetoothShare._ID));
    if (info.mUri != null) {
        info.mUri = Uri.parse(stringFromCursor(info.mUri.toString(), cursor, BluetoothShare.URI));
    } else {
        Log.w(TAG, "updateShare() called for ID " + info.mId + " with null URI");
    }
    info.mHint = stringFromCursor(info.mHint, cursor, BluetoothShare.FILENAME_HINT);
    info.mFilename = stringFromCursor(info.mFilename, cursor, BluetoothShare._DATA);
    info.mMimetype = stringFromCursor(info.mMimetype, cursor, BluetoothShare.MIMETYPE);
    info.mDirection = cursor.getInt(cursor.getColumnIndexOrThrow(BluetoothShare.DIRECTION));
    info.mDestination = stringFromCursor(info.mDestination, cursor, BluetoothShare.DESTINATION);
    int newVisibility = cursor.getInt(cursor.getColumnIndexOrThrow(BluetoothShare.VISIBILITY));
    boolean confirmUpdated = false;
    int newConfirm = cursor.getInt(cursor.getColumnIndexOrThrow(BluetoothShare.USER_CONFIRMATION));
    if (info.mVisibility == BluetoothShare.VISIBILITY_VISIBLE && newVisibility != BluetoothShare.VISIBILITY_VISIBLE && (BluetoothShare.isStatusCompleted(info.mStatus) || newConfirm == BluetoothShare.USER_CONFIRMATION_PENDING)) {
        mNotifier.mNotificationMgr.cancel(info.mId);
    }
    info.mVisibility = newVisibility;
    if (info.mConfirm == BluetoothShare.USER_CONFIRMATION_PENDING && newConfirm != BluetoothShare.USER_CONFIRMATION_PENDING) {
        confirmUpdated = true;
    }
    info.mConfirm = cursor.getInt(cursor.getColumnIndexOrThrow(BluetoothShare.USER_CONFIRMATION));
    int newStatus = cursor.getInt(statusColumn);
    if (BluetoothShare.isStatusCompleted(info.mStatus)) {
        mNotifier.mNotificationMgr.cancel(info.mId);
    }
    info.mStatus = newStatus;
    info.mTotalBytes = cursor.getLong(cursor.getColumnIndexOrThrow(BluetoothShare.TOTAL_BYTES));
    info.mCurrentBytes = cursor.getLong(cursor.getColumnIndexOrThrow(BluetoothShare.CURRENT_BYTES));
    info.mTimestamp = cursor.getLong(cursor.getColumnIndexOrThrow(BluetoothShare.TIMESTAMP));
    info.mMediaScanned = (cursor.getInt(cursor.getColumnIndexOrThrow(Constants.MEDIA_SCANNED)) != Constants.MEDIA_SCANNED_NOT_SCANNED);
    if (confirmUpdated) {
        if (V)
            Log.v(TAG, "Service handle info " + info.mId + " confirmation updated");
        /* Inbounds transfer user confirmation status changed, update the session server */
        int i = findBatchWithTimeStamp(info.mTimestamp);
        if (i != -1) {
            BluetoothOppBatch batch = mBatchs.get(i);
            if (mServerTransfer != null && batch.mId == mServerTransfer.getBatchId()) {
                mServerTransfer.confirmStatusChanged();
            }
        // TODO need to think about else
        }
    }
    int i = findBatchWithTimeStamp(info.mTimestamp);
    if (i != -1) {
        BluetoothOppBatch batch = mBatchs.get(i);
        if (batch.mStatus == Constants.BATCH_STATUS_FINISHED || batch.mStatus == Constants.BATCH_STATUS_FAILED) {
            if (V)
                Log.v(TAG, "Batch " + batch.mId + " is finished");
            if (batch.mDirection == BluetoothShare.DIRECTION_OUTBOUND) {
                if (mTransfer == null) {
                    Log.e(TAG, "Unexpected error! mTransfer is null");
                } else if (batch.mId == mTransfer.getBatchId()) {
                    mTransfer.stop();
                } else {
                    Log.e(TAG, "Unexpected error! batch id " + batch.mId + " doesn't match mTransfer id " + mTransfer.getBatchId());
                }
                mTransfer = null;
            } else {
                if (mServerTransfer == null) {
                    Log.e(TAG, "Unexpected error! mServerTransfer is null");
                } else if (batch.mId == mServerTransfer.getBatchId()) {
                    mServerTransfer.stop();
                } else {
                    Log.e(TAG, "Unexpected error! batch id " + batch.mId + " doesn't match mServerTransfer id " + mServerTransfer.getBatchId());
                }
                mServerTransfer = null;
            }
            removeBatch(batch);
        }
    }
}
#method_after
private void updateShare(Cursor cursor, int arrayPos, boolean userAccepted) {
    BluetoothOppShareInfo info = mShares.get(arrayPos);
    int statusColumn = cursor.getColumnIndexOrThrow(BluetoothShare.STATUS);
    info.mId = cursor.getInt(cursor.getColumnIndexOrThrow(BluetoothShare._ID));
    if (info.mUri != null) {
        info.mUri = Uri.parse(stringFromCursor(info.mUri.toString(), cursor, BluetoothShare.URI));
    } else {
        Log.w(TAG, "updateShare() called for ID " + info.mId + " with null URI");
    }
    info.mHint = stringFromCursor(info.mHint, cursor, BluetoothShare.FILENAME_HINT);
    info.mFilename = stringFromCursor(info.mFilename, cursor, BluetoothShare._DATA);
    info.mMimetype = stringFromCursor(info.mMimetype, cursor, BluetoothShare.MIMETYPE);
    info.mDirection = cursor.getInt(cursor.getColumnIndexOrThrow(BluetoothShare.DIRECTION));
    info.mDestination = stringFromCursor(info.mDestination, cursor, BluetoothShare.DESTINATION);
    int newVisibility = cursor.getInt(cursor.getColumnIndexOrThrow(BluetoothShare.VISIBILITY));
    boolean confirmUpdated = false;
    int newConfirm = cursor.getInt(cursor.getColumnIndexOrThrow(BluetoothShare.USER_CONFIRMATION));
    if (info.mVisibility == BluetoothShare.VISIBILITY_VISIBLE && newVisibility != BluetoothShare.VISIBILITY_VISIBLE && (BluetoothShare.isStatusCompleted(info.mStatus) || newConfirm == BluetoothShare.USER_CONFIRMATION_PENDING)) {
        mNotifier.mNotificationMgr.cancel(info.mId);
    }
    info.mVisibility = newVisibility;
    if (info.mConfirm == BluetoothShare.USER_CONFIRMATION_PENDING && newConfirm != BluetoothShare.USER_CONFIRMATION_PENDING) {
        confirmUpdated = true;
    }
    info.mConfirm = cursor.getInt(cursor.getColumnIndexOrThrow(BluetoothShare.USER_CONFIRMATION));
    int newStatus = cursor.getInt(statusColumn);
    if (BluetoothShare.isStatusCompleted(info.mStatus)) {
        mNotifier.mNotificationMgr.cancel(info.mId);
    }
    info.mStatus = newStatus;
    info.mTotalBytes = cursor.getLong(cursor.getColumnIndexOrThrow(BluetoothShare.TOTAL_BYTES));
    info.mCurrentBytes = cursor.getLong(cursor.getColumnIndexOrThrow(BluetoothShare.CURRENT_BYTES));
    info.mTimestamp = cursor.getLong(cursor.getColumnIndexOrThrow(BluetoothShare.TIMESTAMP));
    info.mMediaScanned = (cursor.getInt(cursor.getColumnIndexOrThrow(Constants.MEDIA_SCANNED)) != Constants.MEDIA_SCANNED_NOT_SCANNED);
    if (confirmUpdated) {
        if (V) {
            Log.v(TAG, "Service handle info " + info.mId + " confirmation updated");
        }
        /* Inbounds transfer user confirmation status changed, update the session server */
        int i = findBatchWithTimeStamp(info.mTimestamp);
        if (i != -1) {
            BluetoothOppBatch batch = mBatchs.get(i);
            if (mServerTransfer != null && batch.mId == mServerTransfer.getBatchId()) {
                mServerTransfer.confirmStatusChanged();
            }
        // TODO need to think about else
        }
    }
    int i = findBatchWithTimeStamp(info.mTimestamp);
    if (i != -1) {
        BluetoothOppBatch batch = mBatchs.get(i);
        if (batch.mStatus == Constants.BATCH_STATUS_FINISHED || batch.mStatus == Constants.BATCH_STATUS_FAILED) {
            if (V) {
                Log.v(TAG, "Batch " + batch.mId + " is finished");
            }
            if (batch.mDirection == BluetoothShare.DIRECTION_OUTBOUND) {
                if (mTransfer == null) {
                    Log.e(TAG, "Unexpected error! mTransfer is null");
                } else if (batch.mId == mTransfer.getBatchId()) {
                    mTransfer.stop();
                } else {
                    Log.e(TAG, "Unexpected error! batch id " + batch.mId + " doesn't match mTransfer id " + mTransfer.getBatchId());
                }
                mTransfer = null;
            } else {
                if (mServerTransfer == null) {
                    Log.e(TAG, "Unexpected error! mServerTransfer is null");
                } else if (batch.mId == mServerTransfer.getBatchId()) {
                    mServerTransfer.stop();
                } else {
                    Log.e(TAG, "Unexpected error! batch id " + batch.mId + " doesn't match mServerTransfer id " + mServerTransfer.getBatchId());
                }
                mServerTransfer = null;
            }
            removeBatch(batch);
        }
    }
}
#end_block

#method_before
private void deleteShare(int arrayPos) {
    BluetoothOppShareInfo info = mShares.get(arrayPos);
    /*
         * Delete arrayPos from a batch. The logic is
         * 1) Search existing batch for the info
         * 2) cancel the batch
         * 3) If the batch become empty delete the batch
         */
    int i = findBatchWithTimeStamp(info.mTimestamp);
    if (i != -1) {
        BluetoothOppBatch batch = mBatchs.get(i);
        if (batch.hasShare(info)) {
            if (V)
                Log.v(TAG, "Service cancel batch for share " + info.mId);
            batch.cancelBatch();
        }
        if (batch.isEmpty()) {
            if (V)
                Log.v(TAG, "Service remove batch  " + batch.mId);
            removeBatch(batch);
        }
    }
    mShares.remove(arrayPos);
}
#method_after
private void deleteShare(int arrayPos) {
    BluetoothOppShareInfo info = mShares.get(arrayPos);
    /*
         * Delete arrayPos from a batch. The logic is
         * 1) Search existing batch for the info
         * 2) cancel the batch
         * 3) If the batch become empty delete the batch
         */
    int i = findBatchWithTimeStamp(info.mTimestamp);
    if (i != -1) {
        BluetoothOppBatch batch = mBatchs.get(i);
        if (batch.hasShare(info)) {
            if (V) {
                Log.v(TAG, "Service cancel batch for share " + info.mId);
            }
            batch.cancelBatch();
        }
        if (batch.isEmpty()) {
            if (V) {
                Log.v(TAG, "Service remove batch  " + batch.mId);
            }
            removeBatch(batch);
        }
    }
    mShares.remove(arrayPos);
}
#end_block

#method_before
private void removeBatch(BluetoothOppBatch batch) {
    if (V)
        Log.v(TAG, "Remove batch " + batch.mId);
    mBatchs.remove(batch);
    BluetoothOppBatch nextBatch;
    if (mBatchs.size() > 0) {
        for (int i = 0; i < mBatchs.size(); i++) {
            // we have a running batch
            nextBatch = mBatchs.get(i);
            if (nextBatch.mStatus == Constants.BATCH_STATUS_RUNNING) {
                return;
            } else {
                // just finish a transfer, start pending outbound transfer
                if (nextBatch.mDirection == BluetoothShare.DIRECTION_OUTBOUND) {
                    if (V)
                        Log.v(TAG, "Start pending outbound batch " + nextBatch.mId);
                    mTransfer = new BluetoothOppTransfer(this, mPowerManager, nextBatch);
                    mTransfer.start();
                    return;
                } else if (nextBatch.mDirection == BluetoothShare.DIRECTION_INBOUND && mServerSession != null) {
                    // if an outbound transfer and incoming socket happens together
                    if (V)
                        Log.v(TAG, "Start pending inbound batch " + nextBatch.mId);
                    mServerTransfer = new BluetoothOppTransfer(this, mPowerManager, nextBatch, mServerSession);
                    mServerTransfer.start();
                    if (nextBatch.getPendingShare() != null && nextBatch.getPendingShare().mConfirm == BluetoothShare.USER_CONFIRMATION_CONFIRMED) {
                        mServerTransfer.confirmStatusChanged();
                    }
                    return;
                }
            }
        }
    }
}
#method_after
private void removeBatch(BluetoothOppBatch batch) {
    if (V) {
        Log.v(TAG, "Remove batch " + batch.mId);
    }
    mBatchs.remove(batch);
    BluetoothOppBatch nextBatch;
    if (mBatchs.size() > 0) {
        for (int i = 0; i < mBatchs.size(); i++) {
            // we have a running batch
            nextBatch = mBatchs.get(i);
            if (nextBatch.mStatus == Constants.BATCH_STATUS_RUNNING) {
                return;
            } else {
                // just finish a transfer, start pending outbound transfer
                if (nextBatch.mDirection == BluetoothShare.DIRECTION_OUTBOUND) {
                    if (V) {
                        Log.v(TAG, "Start pending outbound batch " + nextBatch.mId);
                    }
                    mTransfer = new BluetoothOppTransfer(this, mPowerManager, nextBatch);
                    mTransfer.start();
                    return;
                } else if (nextBatch.mDirection == BluetoothShare.DIRECTION_INBOUND && mServerSession != null) {
                    // if an outbound transfer and incoming socket happens together
                    if (V) {
                        Log.v(TAG, "Start pending inbound batch " + nextBatch.mId);
                    }
                    mServerTransfer = new BluetoothOppTransfer(this, mPowerManager, nextBatch, mServerSession);
                    mServerTransfer.start();
                    if (nextBatch.getPendingShare() != null && nextBatch.getPendingShare().mConfirm == BluetoothShare.USER_CONFIRMATION_CONFIRMED) {
                        mServerTransfer.confirmStatusChanged();
                    }
                    return;
                }
            }
        }
    }
}
#end_block

#method_before
private boolean scanFile(Cursor cursor, int arrayPos) {
    BluetoothOppShareInfo info = mShares.get(arrayPos);
    synchronized (BluetoothOppService.this) {
        if (D)
            Log.d(TAG, "Scanning file " + info.mFilename);
        if (!mMediaScanInProgress) {
            mMediaScanInProgress = true;
            new MediaScannerNotifier(this, info, mHandler);
            return true;
        } else {
            return false;
        }
    }
}
#method_after
private boolean scanFile(Cursor cursor, int arrayPos) {
    BluetoothOppShareInfo info = mShares.get(arrayPos);
    synchronized (BluetoothOppService.this) {
        if (D) {
            Log.d(TAG, "Scanning file " + info.mFilename);
        }
        if (!mMediaScanInProgress) {
            mMediaScanInProgress = true;
            new MediaScannerNotifier(this, info, mHandler);
            return true;
        } else {
            return false;
        }
    }
}
#end_block

#method_before
private static void trimDatabase(ContentResolver contentResolver) {
    final String INVISIBLE = BluetoothShare.VISIBILITY + "=" + BluetoothShare.VISIBILITY_HIDDEN;
    // remove the invisible/complete/outbound shares
    final String WHERE_INVISIBLE_COMPLETE_OUTBOUND = BluetoothShare.DIRECTION + "=" + BluetoothShare.DIRECTION_OUTBOUND + " AND " + BluetoothShare.STATUS + ">=" + BluetoothShare.STATUS_SUCCESS + " AND " + INVISIBLE;
    int delNum = contentResolver.delete(BluetoothShare.CONTENT_URI, WHERE_INVISIBLE_COMPLETE_OUTBOUND, null);
    if (V)
        Log.v(TAG, "Deleted complete outbound shares, number =  " + delNum);
    // remove the invisible/finished/inbound/failed shares
    final String WHERE_INVISIBLE_COMPLETE_INBOUND_FAILED = BluetoothShare.DIRECTION + "=" + BluetoothShare.DIRECTION_INBOUND + " AND " + BluetoothShare.STATUS + ">" + BluetoothShare.STATUS_SUCCESS + " AND " + INVISIBLE;
    delNum = contentResolver.delete(BluetoothShare.CONTENT_URI, WHERE_INVISIBLE_COMPLETE_INBOUND_FAILED, null);
    if (V)
        Log.v(TAG, "Deleted complete inbound failed shares, number = " + delNum);
    // remove unconfirmed inbound shares.
    final String WHERE_CONFIRMATION_PENDING_INBOUND = BluetoothShare.DIRECTION + "=" + BluetoothShare.DIRECTION_INBOUND + " AND " + BluetoothShare.USER_CONFIRMATION + "=" + BluetoothShare.USER_CONFIRMATION_PENDING;
    delNum = contentResolver.delete(BluetoothShare.CONTENT_URI, WHERE_CONFIRMATION_PENDING_INBOUND, null);
    if (V)
        Log.v(TAG, "Deleted unconfirmed incoming shares, number = " + delNum);
    // Only keep the inbound and successful shares for LiverFolder use
    // Keep the latest 1000 to easy db query
    final String WHERE_INBOUND_SUCCESS = BluetoothShare.DIRECTION + "=" + BluetoothShare.DIRECTION_INBOUND + " AND " + BluetoothShare.STATUS + "=" + BluetoothShare.STATUS_SUCCESS + " AND " + INVISIBLE;
    Cursor cursor = contentResolver.query(BluetoothShare.CONTENT_URI, new String[] { BluetoothShare._ID }, WHERE_INBOUND_SUCCESS, null, // sort by id
    BluetoothShare._ID);
    if (cursor == null) {
        return;
    }
    int recordNum = cursor.getCount();
    if (recordNum > Constants.MAX_RECORDS_IN_DATABASE) {
        int numToDelete = recordNum - Constants.MAX_RECORDS_IN_DATABASE;
        if (cursor.moveToPosition(numToDelete)) {
            int columnId = cursor.getColumnIndexOrThrow(BluetoothShare._ID);
            long id = cursor.getLong(columnId);
            delNum = contentResolver.delete(BluetoothShare.CONTENT_URI, BluetoothShare._ID + " < " + id, null);
            if (V)
                Log.v(TAG, "Deleted old inbound success share: " + delNum);
        }
    }
    cursor.close();
}
#method_after
private static void trimDatabase(ContentResolver contentResolver) {
    // remove the invisible/complete/outbound shares
    int delNum = contentResolver.delete(BluetoothShare.CONTENT_URI, WHERE_INVISIBLE_COMPLETE_OUTBOUND, null);
    if (V) {
        Log.v(TAG, "Deleted complete outbound shares, number =  " + delNum);
    }
    // remove the invisible/finished/inbound/failed shares
    delNum = contentResolver.delete(BluetoothShare.CONTENT_URI, WHERE_INVISIBLE_COMPLETE_INBOUND_FAILED, null);
    if (V) {
        Log.v(TAG, "Deleted complete inbound failed shares, number = " + delNum);
    }
    // remove unconfirmed inbound shares.
    final String whereConfirmationPendingInbound = BluetoothShare.DIRECTION + "=" + BluetoothShare.DIRECTION_INBOUND + " AND " + BluetoothShare.USER_CONFIRMATION + "=" + BluetoothShare.USER_CONFIRMATION_PENDING;
    delNum = contentResolver.delete(BluetoothShare.CONTENT_URI, whereConfirmationPendingInbound, null);
    if (V)
        Log.v(TAG, "Deleted unconfirmed incoming shares, number = " + delNum);
    // Only keep the inbound and successful shares for LiverFolder use
    // Keep the latest 1000 to easy db query
    Cursor cursor = contentResolver.query(BluetoothShare.CONTENT_URI, new String[] { BluetoothShare._ID }, WHERE_INBOUND_SUCCESS, null, // sort by id
    BluetoothShare._ID);
    if (cursor == null) {
        return;
    }
    int recordNum = cursor.getCount();
    if (recordNum > Constants.MAX_RECORDS_IN_DATABASE) {
        int numToDelete = recordNum - Constants.MAX_RECORDS_IN_DATABASE;
        if (cursor.moveToPosition(numToDelete)) {
            int columnId = cursor.getColumnIndexOrThrow(BluetoothShare._ID);
            long id = cursor.getLong(columnId);
            delNum = contentResolver.delete(BluetoothShare.CONTENT_URI, BluetoothShare._ID + " < " + id, null);
            if (V) {
                Log.v(TAG, "Deleted old inbound success share: " + delNum);
            }
        }
    }
    cursor.close();
}
#end_block

#method_before
public void onMediaScannerConnected() {
    if (V)
        Log.v(TAG, "MediaScannerConnection onMediaScannerConnected");
    mConnection.scanFile(mInfo.mFilename, mInfo.mMimetype);
}
#method_after
@Override
public void onMediaScannerConnected() {
    if (V) {
        Log.v(TAG, "MediaScannerConnection onMediaScannerConnected");
    }
    mConnection.scanFile(mInfo.mFilename, mInfo.mMimetype);
}
#end_block

#method_before
public void onScanCompleted(String path, Uri uri) {
    try {
        if (V) {
            Log.v(TAG, "MediaScannerConnection onScanCompleted");
            Log.v(TAG, "MediaScannerConnection path is " + path);
            Log.v(TAG, "MediaScannerConnection Uri is " + uri);
        }
        if (uri != null) {
            Message msg = Message.obtain();
            msg.setTarget(mCallback);
            msg.what = MEDIA_SCANNED;
            msg.arg1 = mInfo.mId;
            msg.obj = uri;
            msg.sendToTarget();
        } else {
            Message msg = Message.obtain();
            msg.setTarget(mCallback);
            msg.what = MEDIA_SCANNED_FAILED;
            msg.arg1 = mInfo.mId;
            msg.sendToTarget();
        }
    } catch (Exception ex) {
        Log.v(TAG, "!!!MediaScannerConnection exception: " + ex);
    } finally {
        if (V)
            Log.v(TAG, "MediaScannerConnection disconnect");
        mConnection.disconnect();
    }
}
#method_after
@Override
public void onScanCompleted(String path, Uri uri) {
    try {
        if (V) {
            Log.v(TAG, "MediaScannerConnection onScanCompleted");
            Log.v(TAG, "MediaScannerConnection path is " + path);
            Log.v(TAG, "MediaScannerConnection Uri is " + uri);
        }
        if (uri != null) {
            Message msg = Message.obtain();
            msg.setTarget(mCallback);
            msg.what = MEDIA_SCANNED;
            msg.arg1 = mInfo.mId;
            msg.obj = uri;
            msg.sendToTarget();
        } else {
            Message msg = Message.obtain();
            msg.setTarget(mCallback);
            msg.what = MEDIA_SCANNED_FAILED;
            msg.arg1 = mInfo.mId;
            msg.sendToTarget();
        }
    } catch (Exception ex) {
        Log.v(TAG, "!!!MediaScannerConnection exception: " + ex);
    } finally {
        if (V) {
            Log.v(TAG, "MediaScannerConnection disconnect");
        }
        mConnection.disconnect();
    }
}
#end_block

#method_before
private void stopListeners() {
    if (mServerSocket != null) {
        mServerSocket.shutdown(false);
        mServerSocket = null;
    }
    if (D)
        Log.d(TAG, "stopListeners   mServerSocket :" + mServerSocket);
}
#method_after
private void stopListeners() {
    if (mAdapter != null && mOppSdpHandle >= 0 && SdpManager.getDefaultManager() != null) {
        if (D) {
            Log.d(TAG, "Removing SDP record mOppSdpHandle :" + mOppSdpHandle);
        }
        boolean status = SdpManager.getDefaultManager().removeSdpRecord(mOppSdpHandle);
        Log.d(TAG, "RemoveSDPrecord returns " + status);
        mOppSdpHandle = -1;
    }
    if (mServerSocket != null) {
        mServerSocket.shutdown(false);
        mServerSocket = null;
    }
    if (D) {
        Log.d(TAG, "stopListeners   mServerSocket :" + mServerSocket);
    }
}
#end_block

#method_before
@Override
public boolean onConnect(BluetoothDevice device, BluetoothSocket socket) {
    if (D)
        Log.d(TAG, " onConnect BluetoothSocket :" + socket + " \n :device :" + device);
    BluetoothObexTransport transport = new BluetoothObexTransport(socket);
    Message msg = Message.obtain();
    msg.setTarget(mHandler);
    msg.what = MSG_INCOMING_BTOPP_CONNECTION;
    msg.obj = transport;
    msg.sendToTarget();
    return true;
}
#method_after
@Override
public boolean onConnect(BluetoothDevice device, BluetoothSocket socket) {
    if (D) {
        Log.d(TAG, " onConnect BluetoothSocket :" + socket + " \n :device :" + device);
    }
    BluetoothObexTransport transport = new BluetoothObexTransport(socket);
    Message msg = Message.obtain();
    msg.setTarget(mHandler);
    msg.what = MSG_INCOMING_BTOPP_CONNECTION;
    msg.obj = transport;
    msg.sendToTarget();
    return true;
}
#end_block

#method_before
void destroyLocked() {
    if (sVerbose)
        Slog.v(TAG, "destroyLocked()");
    final int numSessions = mSessions.size();
    final ArraySet<RemoteFillService> remoteFillServices = new ArraySet<>(numSessions);
    for (int i = 0; i < numSessions; i++) {
        final RemoteFillService remoteFillService = mSessions.valueAt(i).destroyLocked();
        if (remoteFillService != null) {
            remoteFillServices.add(remoteFillService);
        }
    }
    mSessions.clear();
    for (int i = 0; i < remoteFillServices.size(); i++) {
        remoteFillServices.valueAt(i).destroy();
    }
    sendStateToClients(true);
    if (mClients != null) {
        mClients.kill();
    }
}
#method_after
void destroyLocked() {
    if (sVerbose)
        Slog.v(TAG, "destroyLocked()");
    final int numSessions = mSessions.size();
    final ArraySet<RemoteFillService> remoteFillServices = new ArraySet<>(numSessions);
    for (int i = 0; i < numSessions; i++) {
        final RemoteFillService remoteFillService = mSessions.valueAt(i).destroyLocked();
        if (remoteFillService != null) {
            remoteFillServices.add(remoteFillService);
        }
    }
    mSessions.clear();
    for (int i = 0; i < remoteFillServices.size(); i++) {
        remoteFillServices.valueAt(i).destroy();
    }
    sendStateToClients(true);
    if (mClients != null) {
        mClients.kill();
        mClients = null;
    }
}
#end_block

#method_before
void dumpLocked(String prefix, PrintWriter pw) {
    final String prefix2 = prefix + "  ";
    pw.print(prefix);
    pw.print("User: ");
    pw.println(mUserId);
    pw.print(prefix);
    pw.print("Component: ");
    pw.println(mInfo != null ? mInfo.getServiceInfo().getComponentName() : null);
    pw.print(prefix);
    pw.print("Component from settings: ");
    pw.println(getComponentNameFromSettings());
    pw.print(prefix);
    pw.print("Default component: ");
    pw.println(mContext.getString(R.string.config_defaultAutofillService));
    pw.print(prefix);
    pw.print("Disabled: ");
    pw.println(mDisabled);
    pw.print(prefix);
    pw.print("Setup complete: ");
    pw.println(mSetupComplete);
    pw.print(prefix);
    pw.print("Last prune: ");
    pw.println(mLastPrune);
    final int size = mSessions.size();
    if (size == 0) {
        pw.print(prefix);
        pw.println("No sessions");
    } else {
        pw.print(prefix);
        pw.print(size);
        pw.println(" sessions:");
        for (int i = 0; i < size; i++) {
            pw.print(prefix);
            pw.print("#");
            pw.println(i + 1);
            mSessions.valueAt(i).dumpLocked(prefix2, pw);
        }
    }
    if (mEventHistory == null || mEventHistory.getEvents() == null || mEventHistory.getEvents().size() == 0) {
        pw.print(prefix);
        pw.println("No event on last fill response");
    } else {
        pw.print(prefix);
        pw.println("Events of last fill response:");
        pw.print(prefix);
        int numEvents = mEventHistory.getEvents().size();
        for (int i = 0; i < numEvents; i++) {
            final Event event = mEventHistory.getEvents().get(i);
            pw.println("  " + i + ": eventType=" + event.getType() + " datasetId=" + event.getDatasetId());
        }
    }
}
#method_after
void dumpLocked(String prefix, PrintWriter pw) {
    final String prefix2 = prefix + "  ";
    pw.print(prefix);
    pw.print("User: ");
    pw.println(mUserId);
    pw.print(prefix);
    pw.print("Component: ");
    pw.println(mInfo != null ? mInfo.getServiceInfo().getComponentName() : null);
    pw.print(prefix);
    pw.print("Component from settings: ");
    pw.println(getComponentNameFromSettings());
    pw.print(prefix);
    pw.print("Default component: ");
    pw.println(mContext.getString(R.string.config_defaultAutofillService));
    pw.print(prefix);
    pw.print("Disabled: ");
    pw.println(mDisabled);
    pw.print(prefix);
    pw.print("Setup complete: ");
    pw.println(mSetupComplete);
    pw.print(prefix);
    pw.print("Last prune: ");
    pw.println(mLastPrune);
    final int size = mSessions.size();
    if (size == 0) {
        pw.print(prefix);
        pw.println("No sessions");
    } else {
        pw.print(prefix);
        pw.print(size);
        pw.println(" sessions:");
        for (int i = 0; i < size; i++) {
            pw.print(prefix);
            pw.print("#");
            pw.println(i + 1);
            mSessions.valueAt(i).dumpLocked(prefix2, pw);
        }
    }
    pw.print(prefix);
    pw.println("Clients");
    mClients.dump(pw, prefix2);
    if (mEventHistory == null || mEventHistory.getEvents() == null || mEventHistory.getEvents().size() == 0) {
        pw.print(prefix);
        pw.println("No event on last fill response");
    } else {
        pw.print(prefix);
        pw.println("Events of last fill response:");
        pw.print(prefix);
        int numEvents = mEventHistory.getEvents().size();
        for (int i = 0; i < numEvents; i++) {
            final Event event = mEventHistory.getEvents().get(i);
            pw.println("  " + i + ": eventType=" + event.getType() + " datasetId=" + event.getDatasetId());
        }
    }
}
#end_block

#method_before
public static final UserHandle getCallingUserHandle() {
    return UserHandle.of(UserHandle.getUserId(getCallingUid()));
}
#method_after
@NonNull
public static final UserHandle getCallingUserHandle() {
    return UserHandle.of(UserHandle.getUserId(getCallingUid()));
}
#end_block

#method_before
public static final void withCleanCallingIdentity(ThrowingRunnable action) {
    long callingIdentity = clearCallingIdentity();
    Throwable throwableToPropagate = null;
    try {
        action.run();
    } catch (Throwable throwable) {
        throwableToPropagate = throwable;
    } finally {
        restoreCallingIdentity(callingIdentity);
        if (throwableToPropagate != null) {
            throw ExceptionUtils.propagate(throwableToPropagate);
        }
    }
}
#method_after
public static final void withCleanCallingIdentity(@NonNull ThrowingRunnable action) {
    long callingIdentity = clearCallingIdentity();
    Throwable throwableToPropagate = null;
    try {
        action.run();
    } catch (Throwable throwable) {
        throwableToPropagate = throwable;
    } finally {
        restoreCallingIdentity(callingIdentity);
        if (throwableToPropagate != null) {
            throw ExceptionUtils.propagate(throwableToPropagate);
        }
    }
}
#end_block

#method_before
public static final <T> T withCleanCallingIdentity(ThrowingSupplier<T> action) {
    long callingIdentity = clearCallingIdentity();
    Throwable throwableToPropagate = null;
    try {
        return action.get();
    } catch (Throwable throwable) {
        throwableToPropagate = throwable;
        // overridden by throwing in finally block
        return null;
    } finally {
        restoreCallingIdentity(callingIdentity);
        if (throwableToPropagate != null) {
            throw ExceptionUtils.propagate(throwableToPropagate);
        }
    }
}
#method_after
public static final <T> T withCleanCallingIdentity(@NonNull ThrowingSupplier<T> action) {
    long callingIdentity = clearCallingIdentity();
    Throwable throwableToPropagate = null;
    try {
        return action.get();
    } catch (Throwable throwable) {
        throwableToPropagate = throwable;
        // overridden by throwing in finally block
        return null;
    } finally {
        restoreCallingIdentity(callingIdentity);
        if (throwableToPropagate != null) {
            throw ExceptionUtils.propagate(throwableToPropagate);
        }
    }
}
#end_block

#method_before
public void attachInterface(IInterface owner, String descriptor) {
    mOwner = owner;
    mDescriptor = descriptor;
}
#method_after
public void attachInterface(@Nullable IInterface owner, @Nullable String descriptor) {
    mOwner = owner;
    mDescriptor = descriptor;
}
#end_block

#method_before
public String getInterfaceDescriptor() {
    return mDescriptor;
}
#method_after
@Nullable
public String getInterfaceDescriptor() {
    return mDescriptor;
}
#end_block

#method_before
public IInterface queryLocalInterface(String descriptor) {
    if (mDescriptor.equals(descriptor)) {
        return mOwner;
    }
    return null;
}
#method_after
@Nullable
public IInterface queryLocalInterface(@NonNull String descriptor) {
    if (mDescriptor.equals(descriptor)) {
        return mOwner;
    }
    return null;
}
#end_block

#method_before
protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
    if (code == INTERFACE_TRANSACTION) {
        reply.writeString(getInterfaceDescriptor());
        return true;
    } else if (code == DUMP_TRANSACTION) {
        ParcelFileDescriptor fd = data.readFileDescriptor();
        String[] args = data.readStringArray();
        if (fd != null) {
            try {
                dump(fd.getFileDescriptor(), args);
            } finally {
                IoUtils.closeQuietly(fd);
            }
        }
        // Write the StrictMode header.
        if (reply != null) {
            reply.writeNoException();
        } else {
            StrictMode.clearGatheredViolations();
        }
        return true;
    } else if (code == SHELL_COMMAND_TRANSACTION) {
        ParcelFileDescriptor in = data.readFileDescriptor();
        ParcelFileDescriptor out = data.readFileDescriptor();
        ParcelFileDescriptor err = data.readFileDescriptor();
        String[] args = data.readStringArray();
        ShellCallback shellCallback = ShellCallback.CREATOR.createFromParcel(data);
        ResultReceiver resultReceiver = ResultReceiver.CREATOR.createFromParcel(data);
        try {
            if (out != null) {
                shellCommand(in != null ? in.getFileDescriptor() : null, out.getFileDescriptor(), err != null ? err.getFileDescriptor() : out.getFileDescriptor(), args, shellCallback, resultReceiver);
            }
        } finally {
            IoUtils.closeQuietly(in);
            IoUtils.closeQuietly(out);
            IoUtils.closeQuietly(err);
            // Write the StrictMode header.
            if (reply != null) {
                reply.writeNoException();
            } else {
                StrictMode.clearGatheredViolations();
            }
        }
        return true;
    }
    return false;
}
#method_after
protected boolean onTransact(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags) throws RemoteException {
    if (code == INTERFACE_TRANSACTION) {
        reply.writeString(getInterfaceDescriptor());
        return true;
    } else if (code == DUMP_TRANSACTION) {
        ParcelFileDescriptor fd = data.readFileDescriptor();
        String[] args = data.readStringArray();
        if (fd != null) {
            try {
                dump(fd.getFileDescriptor(), args);
            } finally {
                IoUtils.closeQuietly(fd);
            }
        }
        // Write the StrictMode header.
        if (reply != null) {
            reply.writeNoException();
        } else {
            StrictMode.clearGatheredViolations();
        }
        return true;
    } else if (code == SHELL_COMMAND_TRANSACTION) {
        ParcelFileDescriptor in = data.readFileDescriptor();
        ParcelFileDescriptor out = data.readFileDescriptor();
        ParcelFileDescriptor err = data.readFileDescriptor();
        String[] args = data.readStringArray();
        ShellCallback shellCallback = ShellCallback.CREATOR.createFromParcel(data);
        ResultReceiver resultReceiver = ResultReceiver.CREATOR.createFromParcel(data);
        try {
            if (out != null) {
                shellCommand(in != null ? in.getFileDescriptor() : null, out.getFileDescriptor(), err != null ? err.getFileDescriptor() : out.getFileDescriptor(), args, shellCallback, resultReceiver);
            }
        } finally {
            IoUtils.closeQuietly(in);
            IoUtils.closeQuietly(out);
            IoUtils.closeQuietly(err);
            // Write the StrictMode header.
            if (reply != null) {
                reply.writeNoException();
            } else {
                StrictMode.clearGatheredViolations();
            }
        }
        return true;
    }
    return false;
}
#end_block

#method_before
public void dump(FileDescriptor fd, String[] args) {
    FileOutputStream fout = new FileOutputStream(fd);
    PrintWriter pw = new FastPrintWriter(fout);
    try {
        doDump(fd, pw, args);
    } finally {
        pw.flush();
    }
}
#method_after
public void dump(@NonNull FileDescriptor fd, @Nullable String[] args) {
    FileOutputStream fout = new FileOutputStream(fd);
    PrintWriter pw = new FastPrintWriter(fout);
    try {
        doDump(fd, pw, args);
    } finally {
        pw.flush();
    }
}
#end_block

#method_before
public void dumpAsync(final FileDescriptor fd, final String[] args) {
    final FileOutputStream fout = new FileOutputStream(fd);
    final PrintWriter pw = new FastPrintWriter(fout);
    Thread thr = new Thread("Binder.dumpAsync") {

        public void run() {
            try {
                dump(fd, pw, args);
            } finally {
                pw.flush();
            }
        }
    };
    thr.start();
}
#method_after
public void dumpAsync(@NonNull final FileDescriptor fd, @Nullable final String[] args) {
    final FileOutputStream fout = new FileOutputStream(fd);
    final PrintWriter pw = new FastPrintWriter(fout);
    Thread thr = new Thread("Binder.dumpAsync") {

        public void run() {
            try {
                dump(fd, pw, args);
            } finally {
                pw.flush();
            }
        }
    };
    thr.start();
}
#end_block

#method_before
protected void dump(FileDescriptor fd, PrintWriter fout, String[] args) {
}
#method_after
protected void dump(@NonNull FileDescriptor fd, @NonNull PrintWriter fout, @Nullable String[] args) {
}
#end_block

#method_before
public void shellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err, String[] args, ShellCallback callback, ResultReceiver resultReceiver) throws RemoteException {
    onShellCommand(in, out, err, args, callback, resultReceiver);
}
#method_after
public void shellCommand(@Nullable FileDescriptor in, @Nullable FileDescriptor out, @Nullable FileDescriptor err, @NonNull String[] args, @Nullable ShellCallback callback, @NonNull ResultReceiver resultReceiver) throws RemoteException {
    onShellCommand(in, out, err, args, callback, resultReceiver);
}
#end_block

#method_before
public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err, String[] args, ShellCallback callback, ResultReceiver resultReceiver) throws RemoteException {
    FileOutputStream fout = new FileOutputStream(err != null ? err : out);
    PrintWriter pw = new FastPrintWriter(fout);
    pw.println("No shell command implementation.");
    pw.flush();
    resultReceiver.send(0, null);
}
#method_after
public void onShellCommand(@Nullable FileDescriptor in, @Nullable FileDescriptor out, @Nullable FileDescriptor err, @NonNull String[] args, @Nullable ShellCallback callback, @NonNull ResultReceiver resultReceiver) throws RemoteException {
    FileOutputStream fout = new FileOutputStream(err != null ? err : out);
    PrintWriter pw = new FastPrintWriter(fout);
    pw.println("No shell command implementation.");
    pw.flush();
    resultReceiver.send(0, null);
}
#end_block

#method_before
public final boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
    if (false)
        Log.v("Binder", "Transact: " + code + " to " + this);
    if (data != null) {
        data.setDataPosition(0);
    }
    boolean r = onTransact(code, data, reply, flags);
    if (reply != null) {
        reply.setDataPosition(0);
    }
    return r;
}
#method_after
public final boolean transact(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags) throws RemoteException {
    if (false)
        Log.v("Binder", "Transact: " + code + " to " + this);
    if (data != null) {
        data.setDataPosition(0);
    }
    boolean r = onTransact(code, data, reply, flags);
    if (reply != null) {
        reply.setDataPosition(0);
    }
    return r;
}
#end_block

#method_before
public void linkToDeath(DeathRecipient recipient, int flags) {
}
#method_after
public void linkToDeath(@NonNull DeathRecipient recipient, int flags) {
}
#end_block

#method_before
public boolean unlinkToDeath(DeathRecipient recipient, int flags) {
    return true;
}
#method_after
public boolean unlinkToDeath(@NonNull DeathRecipient recipient, int flags) {
    return true;
}
#end_block

#method_before
void set(long key, @NonNull BinderProxy value) {
    int myHash = hash(key);
    ArrayList<WeakReference<BinderProxy>> valueArray = mMainIndexValues[myHash];
    if (valueArray == null) {
        valueArray = mMainIndexValues[myHash] = new ArrayList<>();
        mMainIndexKeys[myHash] = new Long[1];
    }
    int size = valueArray.size();
    WeakReference<BinderProxy> newWr = new WeakReference<>(value);
    // that bucket.
    for (int i = 0; i < size; ++i) {
        if (valueArray.get(i).get() == null) {
            valueArray.set(i, newWr);
            Long[] keyArray = mMainIndexKeys[myHash];
            keyArray[i] = key;
            if (i < size - 1) {
                // "Randomly" check one of the remaining entries in [i+1, size), so that
                // needlessly long buckets are eventually pruned.
                int rnd = (++mRandom) % (size - (i + 1));
                if (valueArray.get(i + 1 + rnd).get() == null) {
                    remove(myHash, i + 1 + rnd);
                }
            }
            return;
        }
    }
    valueArray.add(size, newWr);
    Long[] keyArray = mMainIndexKeys[myHash];
    if (keyArray.length == size) {
        // size >= 1, since we initially allocated one element
        Long[] newArray = new Long[size + size / 2 + 2];
        System.arraycopy(keyArray, 0, newArray, 0, size);
        newArray[size] = key;
        mMainIndexKeys[myHash] = newArray;
    } else {
        keyArray[size] = key;
    }
    if (size >= mWarnBucketSize) {
        Log.v(Binder.TAG, "BinderProxy map growth! bucket size = " + size + " total = " + size());
        mWarnBucketSize += WARN_INCREMENT;
    }
}
#method_after
void set(long key, @NonNull BinderProxy value) {
    int myHash = hash(key);
    ArrayList<WeakReference<BinderProxy>> valueArray = mMainIndexValues[myHash];
    if (valueArray == null) {
        valueArray = mMainIndexValues[myHash] = new ArrayList<>();
        mMainIndexKeys[myHash] = new Long[1];
    }
    int size = valueArray.size();
    WeakReference<BinderProxy> newWr = new WeakReference<>(value);
    // that bucket.
    for (int i = 0; i < size; ++i) {
        if (valueArray.get(i).get() == null) {
            valueArray.set(i, newWr);
            Long[] keyArray = mMainIndexKeys[myHash];
            keyArray[i] = key;
            if (i < size - 1) {
                // "Randomly" check one of the remaining entries in [i+1, size), so that
                // needlessly long buckets are eventually pruned.
                int rnd = Math.floorMod(++mRandom, size - (i + 1));
                if (valueArray.get(i + 1 + rnd).get() == null) {
                    remove(myHash, i + 1 + rnd);
                }
            }
            return;
        }
    }
    valueArray.add(size, newWr);
    Long[] keyArray = mMainIndexKeys[myHash];
    if (keyArray.length == size) {
        // size >= 1, since we initially allocated one element
        Long[] newArray = new Long[size + size / 2 + 2];
        System.arraycopy(keyArray, 0, newArray, 0, size);
        newArray[size] = key;
        mMainIndexKeys[myHash] = newArray;
    } else {
        keyArray[size] = key;
    }
    if (size >= mWarnBucketSize) {
        Log.v(Binder.TAG, "BinderProxy map growth! bucket size = " + size + " total = " + size());
        mWarnBucketSize += WARN_INCREMENT;
    }
}
#end_block

#method_before
private void loadGlobalSettings(SQLiteDatabase db) {
    SQLiteStatement stmt = null;
    try {
        stmt = db.compileStatement("INSERT OR IGNORE INTO global(name,value)" + " VALUES(?,?);");
        // --- Previously in 'system'
        loadBooleanSetting(stmt, Settings.Global.AIRPLANE_MODE_ON, R.bool.def_airplane_mode_on);
        loadBooleanSetting(stmt, Settings.Global.THEATER_MODE_ON, R.bool.def_theater_mode_on);
        loadStringSetting(stmt, Settings.Global.AIRPLANE_MODE_RADIOS, R.string.def_airplane_mode_radios);
        loadStringSetting(stmt, Settings.Global.AIRPLANE_MODE_TOGGLEABLE_RADIOS, R.string.airplane_mode_toggleable_radios);
        loadBooleanSetting(stmt, Settings.Global.ASSISTED_GPS_ENABLED, R.bool.assisted_gps_enabled);
        loadBooleanSetting(stmt, Settings.Global.AUTO_TIME, // Sync time to NITZ
        R.bool.def_auto_time);
        loadBooleanSetting(stmt, Settings.Global.AUTO_TIME_ZONE, // Sync timezone to NITZ
        R.bool.def_auto_time_zone);
        loadSetting(stmt, Settings.Global.STAY_ON_WHILE_PLUGGED_IN, ("1".equals(SystemProperties.get("ro.kernel.qemu")) || mContext.getResources().getBoolean(R.bool.def_stay_on_while_plugged_in)) ? 1 : 0);
        loadIntegerSetting(stmt, Settings.Global.WIFI_SLEEP_POLICY, R.integer.def_wifi_sleep_policy);
        loadSetting(stmt, Settings.Global.MODE_RINGER, AudioManager.RINGER_MODE_NORMAL);
        // --- Previously in 'secure'
        loadBooleanSetting(stmt, Settings.Global.PACKAGE_VERIFIER_ENABLE, R.bool.def_package_verifier_enable);
        loadBooleanSetting(stmt, Settings.Global.WIFI_ON, R.bool.def_wifi_on);
        loadBooleanSetting(stmt, Settings.Global.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON, R.bool.def_networks_available_notification_on);
        loadBooleanSetting(stmt, Settings.Global.BLUETOOTH_ON, R.bool.def_bluetooth_on);
        // Enable or disable Cell Broadcast SMS
        loadSetting(stmt, Settings.Global.CDMA_CELL_BROADCAST_SMS, RILConstants.CDMA_CELL_BROADCAST_SMS_DISABLED);
        // Data roaming default, based on build
        loadSetting(stmt, Settings.Global.DATA_ROAMING, "true".equalsIgnoreCase(SystemProperties.get("ro.com.android.dataroaming", "false")) ? 1 : 0);
        loadBooleanSetting(stmt, Settings.Global.DEVICE_PROVISIONED, R.bool.def_device_provisioned);
        final int maxBytes = mContext.getResources().getInteger(R.integer.def_download_manager_max_bytes_over_mobile);
        if (maxBytes > 0) {
            loadSetting(stmt, Settings.Global.DOWNLOAD_MAX_BYTES_OVER_MOBILE, Integer.toString(maxBytes));
        }
        final int recommendedMaxBytes = mContext.getResources().getInteger(R.integer.def_download_manager_recommended_max_bytes_over_mobile);
        if (recommendedMaxBytes > 0) {
            loadSetting(stmt, Settings.Global.DOWNLOAD_RECOMMENDED_MAX_BYTES_OVER_MOBILE, Integer.toString(recommendedMaxBytes));
        }
        // Mobile Data default, based on build
        loadSetting(stmt, Settings.Global.MOBILE_DATA, "true".equalsIgnoreCase(SystemProperties.get("ro.com.android.mobiledata", "true")) ? 1 : 0);
        loadBooleanSetting(stmt, Settings.Global.NETSTATS_ENABLED, R.bool.def_netstats_enabled);
        loadBooleanSetting(stmt, Settings.Global.USB_MASS_STORAGE_ENABLED, R.bool.def_usb_mass_storage_enabled);
        loadIntegerSetting(stmt, Settings.Global.WIFI_MAX_DHCP_RETRY_COUNT, R.integer.def_max_dhcp_retries);
        loadBooleanSetting(stmt, Settings.Global.WIFI_DISPLAY_ON, R.bool.def_wifi_display_on);
        loadStringSetting(stmt, Settings.Global.LOCK_SOUND, R.string.def_lock_sound);
        loadStringSetting(stmt, Settings.Global.UNLOCK_SOUND, R.string.def_unlock_sound);
        loadStringSetting(stmt, Settings.Global.TRUSTED_SOUND, R.string.def_trusted_sound);
        loadIntegerSetting(stmt, Settings.Global.POWER_SOUNDS_ENABLED, R.integer.def_power_sounds_enabled);
        loadStringSetting(stmt, Settings.Global.LOW_BATTERY_SOUND, R.string.def_low_battery_sound);
        loadIntegerSetting(stmt, Settings.Global.DOCK_SOUNDS_ENABLED, R.integer.def_dock_sounds_enabled);
        loadIntegerSetting(stmt, Settings.Global.DOCK_SOUNDS_ENABLED_WHEN_ACCESSIBILITY, R.integer.def_dock_sounds_enabled_when_accessibility);
        loadStringSetting(stmt, Settings.Global.DESK_DOCK_SOUND, R.string.def_desk_dock_sound);
        loadStringSetting(stmt, Settings.Global.DESK_UNDOCK_SOUND, R.string.def_desk_undock_sound);
        loadStringSetting(stmt, Settings.Global.CAR_DOCK_SOUND, R.string.def_car_dock_sound);
        loadStringSetting(stmt, Settings.Global.CAR_UNDOCK_SOUND, R.string.def_car_undock_sound);
        loadStringSetting(stmt, Settings.Global.WIRELESS_CHARGING_STARTED_SOUND, R.string.def_wireless_charging_started_sound);
        loadIntegerSetting(stmt, Settings.Global.DOCK_AUDIO_MEDIA_ENABLED, R.integer.def_dock_audio_media_enabled);
        loadSetting(stmt, Settings.Global.SET_INSTALL_LOCATION, 0);
        loadSetting(stmt, Settings.Global.DEFAULT_INSTALL_LOCATION, PackageHelper.APP_INSTALL_AUTO);
        // Set default cdma emergency tone
        loadSetting(stmt, Settings.Global.EMERGENCY_TONE, 0);
        // Set default cdma call auto retry
        loadSetting(stmt, Settings.Global.CALL_AUTO_RETRY, 0);
        // Set the preferred network mode to target desired value or Default
        // value defined in RILConstants
        int type;
        type = RILConstants.PREFERRED_NETWORK_MODE;
        loadSetting(stmt, Settings.Global.PREFERRED_NETWORK_MODE, type);
        // Set the preferred cdma subscription source to target desired value or default
        // value defined in CdmaSubscriptionSourceManager
        type = SystemProperties.getInt("ro.telephony.default_cdma_sub", CdmaSubscriptionSourceManager.PREFERRED_CDMA_SUBSCRIPTION);
        loadSetting(stmt, Settings.Global.CDMA_SUBSCRIPTION_MODE, type);
        loadIntegerSetting(stmt, Settings.Global.LOW_BATTERY_SOUND_TIMEOUT, R.integer.def_low_battery_sound_timeout);
        loadIntegerSetting(stmt, Settings.Global.WIFI_SCAN_ALWAYS_AVAILABLE, R.integer.def_wifi_scan_always_available);
        loadIntegerSetting(stmt, Global.HEADS_UP_NOTIFICATIONS_ENABLED, R.integer.def_heads_up_enabled);
        loadSetting(stmt, Settings.Global.DEVICE_NAME, getDefaultDeviceName());
    /*
             * IMPORTANT: Do not add any more upgrade steps here as the global,
             * secure, and system settings are no longer stored in a database
             * but are kept in memory and persisted to XML.
             *
             * See: SettingsProvider.UpgradeController#onUpgradeLocked
             */
    } finally {
        if (stmt != null)
            stmt.close();
    }
}
#method_after
private void loadGlobalSettings(SQLiteDatabase db) {
    SQLiteStatement stmt = null;
    try {
        stmt = db.compileStatement("INSERT OR IGNORE INTO global(name,value)" + " VALUES(?,?);");
        // --- Previously in 'system'
        loadBooleanSetting(stmt, Settings.Global.AIRPLANE_MODE_ON, R.bool.def_airplane_mode_on);
        loadBooleanSetting(stmt, Settings.Global.THEATER_MODE_ON, R.bool.def_theater_mode_on);
        loadStringSetting(stmt, Settings.Global.AIRPLANE_MODE_RADIOS, R.string.def_airplane_mode_radios);
        loadStringSetting(stmt, Settings.Global.AIRPLANE_MODE_TOGGLEABLE_RADIOS, R.string.airplane_mode_toggleable_radios);
        loadBooleanSetting(stmt, Settings.Global.ASSISTED_GPS_ENABLED, R.bool.assisted_gps_enabled);
        loadBooleanSetting(stmt, Settings.Global.AUTO_TIME, // Sync time to NITZ
        R.bool.def_auto_time);
        loadBooleanSetting(stmt, Settings.Global.AUTO_TIME_ZONE, // Sync timezone to NITZ
        R.bool.def_auto_time_zone);
        loadSetting(stmt, Settings.Global.STAY_ON_WHILE_PLUGGED_IN, ("1".equals(SystemProperties.get("ro.kernel.qemu")) || mContext.getResources().getBoolean(R.bool.def_stay_on_while_plugged_in)) ? 1 : 0);
        loadIntegerSetting(stmt, Settings.Global.WIFI_SLEEP_POLICY, R.integer.def_wifi_sleep_policy);
        loadSetting(stmt, Settings.Global.MODE_RINGER, AudioManager.RINGER_MODE_NORMAL);
        // --- Previously in 'secure'
        loadBooleanSetting(stmt, Settings.Global.PACKAGE_VERIFIER_ENABLE, R.bool.def_package_verifier_enable);
        loadBooleanSetting(stmt, Settings.Global.WIFI_ON, R.bool.def_wifi_on);
        loadBooleanSetting(stmt, Settings.Global.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON, R.bool.def_networks_available_notification_on);
        loadBooleanSetting(stmt, Settings.Global.BLUETOOTH_ON, R.bool.def_bluetooth_on);
        // Enable or disable Cell Broadcast SMS
        loadSetting(stmt, Settings.Global.CDMA_CELL_BROADCAST_SMS, RILConstants.CDMA_CELL_BROADCAST_SMS_DISABLED);
        // Data roaming default, based on build
        loadSetting(stmt, Settings.Global.DATA_ROAMING, "true".equalsIgnoreCase(SystemProperties.get("ro.com.android.dataroaming", "false")) ? 1 : 0);
        loadBooleanSetting(stmt, Settings.Global.DEVICE_PROVISIONED, R.bool.def_device_provisioned);
        final int maxBytes = mContext.getResources().getInteger(R.integer.def_download_manager_max_bytes_over_mobile);
        if (maxBytes > 0) {
            loadSetting(stmt, Settings.Global.DOWNLOAD_MAX_BYTES_OVER_MOBILE, Integer.toString(maxBytes));
        }
        final int recommendedMaxBytes = mContext.getResources().getInteger(R.integer.def_download_manager_recommended_max_bytes_over_mobile);
        if (recommendedMaxBytes > 0) {
            loadSetting(stmt, Settings.Global.DOWNLOAD_RECOMMENDED_MAX_BYTES_OVER_MOBILE, Integer.toString(recommendedMaxBytes));
        }
        // Mobile Data default, based on build
        loadSetting(stmt, Settings.Global.MOBILE_DATA, "true".equalsIgnoreCase(SystemProperties.get("ro.com.android.mobiledata", "true")) ? 1 : 0);
        loadBooleanSetting(stmt, Settings.Global.NETSTATS_ENABLED, R.bool.def_netstats_enabled);
        loadBooleanSetting(stmt, Settings.Global.USB_MASS_STORAGE_ENABLED, R.bool.def_usb_mass_storage_enabled);
        loadIntegerSetting(stmt, Settings.Global.WIFI_MAX_DHCP_RETRY_COUNT, R.integer.def_max_dhcp_retries);
        loadBooleanSetting(stmt, Settings.Global.WIFI_DISPLAY_ON, R.bool.def_wifi_display_on);
        loadStringSetting(stmt, Settings.Global.LOCK_SOUND, R.string.def_lock_sound);
        loadStringSetting(stmt, Settings.Global.UNLOCK_SOUND, R.string.def_unlock_sound);
        loadStringSetting(stmt, Settings.Global.TRUSTED_SOUND, R.string.def_trusted_sound);
        loadIntegerSetting(stmt, Settings.Global.POWER_SOUNDS_ENABLED, R.integer.def_power_sounds_enabled);
        loadStringSetting(stmt, Settings.Global.LOW_BATTERY_SOUND, R.string.def_low_battery_sound);
        loadIntegerSetting(stmt, Settings.Global.DOCK_SOUNDS_ENABLED, R.integer.def_dock_sounds_enabled);
        loadIntegerSetting(stmt, Settings.Global.DOCK_SOUNDS_ENABLED_WHEN_ACCESSIBILITY, R.integer.def_dock_sounds_enabled_when_accessibility);
        loadStringSetting(stmt, Settings.Global.DESK_DOCK_SOUND, R.string.def_desk_dock_sound);
        loadStringSetting(stmt, Settings.Global.DESK_UNDOCK_SOUND, R.string.def_desk_undock_sound);
        loadStringSetting(stmt, Settings.Global.CAR_DOCK_SOUND, R.string.def_car_dock_sound);
        loadStringSetting(stmt, Settings.Global.CAR_UNDOCK_SOUND, R.string.def_car_undock_sound);
        loadStringSetting(stmt, Settings.Global.WIRELESS_CHARGING_STARTED_SOUND, R.string.def_wireless_charging_started_sound);
        loadIntegerSetting(stmt, Settings.Global.DOCK_AUDIO_MEDIA_ENABLED, R.integer.def_dock_audio_media_enabled);
        loadSetting(stmt, Settings.Global.SET_INSTALL_LOCATION, 0);
        loadSetting(stmt, Settings.Global.DEFAULT_INSTALL_LOCATION, PackageHelper.APP_INSTALL_AUTO);
        // Set default cdma emergency tone
        loadSetting(stmt, Settings.Global.EMERGENCY_TONE, 0);
        // Set default cdma call auto retry
        loadSetting(stmt, Settings.Global.CALL_AUTO_RETRY, 0);
        // Set the preferred network mode to target desired value or Default
        // value defined in RILConstants
        int type;
        type = RILConstants.PREFERRED_NETWORK_MODE;
        loadSetting(stmt, Settings.Global.PREFERRED_NETWORK_MODE, type);
        // Set the preferred cdma subscription source to target desired value or default
        // value defined in Phone
        type = SystemProperties.getInt("ro.telephony.default_cdma_sub", Phone.PREFERRED_CDMA_SUBSCRIPTION);
        loadSetting(stmt, Settings.Global.CDMA_SUBSCRIPTION_MODE, type);
        loadIntegerSetting(stmt, Settings.Global.LOW_BATTERY_SOUND_TIMEOUT, R.integer.def_low_battery_sound_timeout);
        loadIntegerSetting(stmt, Settings.Global.WIFI_SCAN_ALWAYS_AVAILABLE, R.integer.def_wifi_scan_always_available);
        loadIntegerSetting(stmt, Global.HEADS_UP_NOTIFICATIONS_ENABLED, R.integer.def_heads_up_enabled);
        loadSetting(stmt, Settings.Global.DEVICE_NAME, getDefaultDeviceName());
    /*
             * IMPORTANT: Do not add any more upgrade steps here as the global,
             * secure, and system settings are no longer stored in a database
             * but are kept in memory and persisted to XML.
             *
             * See: SettingsProvider.UpgradeController#onUpgradeLocked
             */
    } finally {
        if (stmt != null)
            stmt.close();
    }
}
#end_block

#method_before
public boolean isEnhanced4gLteModeSettingEnabledByUser() {
    // If user changes SIM from editable mode to uneditable mode, need to return true.
    if (!getBooleanCarrierConfig(CarrierConfigManager.KEY_EDITABLE_ENHANCED_4G_LTE_BOOL)) {
        return true;
    }
    int enabled = android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED, getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_ENHANCED_4G_LTE_ENABLED_BOOL) ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF);
    return (enabled == 1);
}
#method_after
public boolean isEnhanced4gLteModeSettingEnabledByUser() {
    // If user can't edit Enhanced 4G LTE Mode, it assumes Enhanced 4G LTE Mode is default
    // value.
    // If user changes SIM from editable mode to uneditable mode, need to return default value.
    int defaultValue = getBooleanCarrierConfig(CarrierConfigManager.KEY_ENHANCED_4G_LTE_ON_BY_DEFAULT_BOOL) ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF;
    if (!getBooleanCarrierConfig(CarrierConfigManager.KEY_EDITABLE_ENHANCED_4G_LTE_BOOL)) {
        return (defaultValue == ImsConfig.FeatureValueConstants.ON);
    }
    int enabled = android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED, defaultValue);
    return (enabled == ImsConfig.FeatureValueConstants.ON);
}
#end_block

#method_before
public void setEnhanced4gLteModeSetting(boolean enabled) {
    // If false, we must always keep advanced 4G mode set to true (1).
    int value = getBooleanCarrierConfig(CarrierConfigManager.KEY_EDITABLE_ENHANCED_4G_LTE_BOOL) ? (enabled ? 1 : 0) : 1;
    try {
        int prevSetting = android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED);
        if (prevSetting == value) {
            // Don't trigger setAdvanced4GMode if the setting hasn't changed.
            return;
        }
    } catch (Settings.SettingNotFoundException e) {
    // Setting doesn't exist yet, so set it below.
    }
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED, value);
    if (isNonTtyOrTtyOnVolteEnabled()) {
        try {
            setAdvanced4GMode(enabled);
        } catch (ImsException ie) {
        // do nothing
        }
    }
}
#method_after
public void setEnhanced4gLteModeSetting(boolean enabled) {
    int value = enabled ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF;
    // If editable=false, we must keep default advanced 4G mode.
    if (!getBooleanCarrierConfig(CarrierConfigManager.KEY_EDITABLE_ENHANCED_4G_LTE_BOOL)) {
        value = getBooleanCarrierConfig(CarrierConfigManager.KEY_ENHANCED_4G_LTE_ON_BY_DEFAULT_BOOL) ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF;
    }
    try {
        int prevSetting = android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED);
        if (prevSetting == value) {
            // Don't trigger setAdvanced4GMode if the setting hasn't changed.
            return;
        }
    } catch (Settings.SettingNotFoundException e) {
    // Setting doesn't exist yet, so set it below.
    }
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED, value);
    if (isNonTtyOrTtyOnVolteEnabled()) {
        try {
            setAdvanced4GMode(value == ImsConfig.FeatureValueConstants.ON);
        } catch (ImsException ie) {
        // do nothing
        }
    }
}
#end_block

#method_before
public void factoryReset() {
    // Set VoLTE to default
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED, getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_ENHANCED_4G_LTE_ENABLED_BOOL) ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF);
    // Set VoWiFi to default
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ENABLED, getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ENABLED_BOOL) ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF);
    // Set VoWiFi mode to default
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_MODE, getIntCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_MODE_INT));
    // Set VoWiFi roaming to default
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ROAMING_ENABLED, getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_ENABLED_BOOL) ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF);
    // Set VT to default
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.VT_IMS_ENABLED, ImsConfig.FeatureValueConstants.ON);
    // Push settings to ImsConfig
    updateImsServiceConfig(true);
}
#method_after
public void factoryReset() {
    // Delete VoLTE row to retrieve the default value.
    mContext.getContentResolver().delete(Settings.Global.getUriFor(Settings.Global.ENHANCED_4G_MODE_ENABLED), null, null);
    // Set VoWiFi to default
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ENABLED, getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ENABLED_BOOL) ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF);
    // Set VoWiFi mode to default
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_MODE, getIntCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_MODE_INT));
    // Set VoWiFi roaming to default
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ROAMING_ENABLED, getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_ENABLED_BOOL) ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF);
    // Set VT to default
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.VT_IMS_ENABLED, ImsConfig.FeatureValueConstants.ON);
    // Push settings to ImsConfig
    updateImsServiceConfig(true);
}
#end_block

#method_before
public void setSortingKey(String sortingKey) {
    mSortingKey = sortingKey;
}
#method_after
public void setSortingKey(String sortingKey) {
    mSortingKey = sortingKey;
    mSortedByName = ZoneGetter.KEY_DISPLAY_LABEL.equals(sortingKey);
}
#end_block

#method_before
@Override
public synchronized void onWakeupEvent(String prefix, int uid, int gid, int ethertype, int ipProtocol, byte[] dstHw, String srcIp, String dstIp, int srcPort, int dstPort, long timestampNs) {
    String iface = prefix.replaceFirst(WAKEUP_EVENT_IFACE_PREFIX, "");
    final long timestampMs;
    if (timestampNs > 0) {
        timestampMs = timestampNs / NANOS_PER_MS;
    } else {
        timestampMs = System.currentTimeMillis();
    }
    WakeupEvent event = new WakeupEvent();
    event.iface = iface;
    event.timestampMs = timestampMs;
    event.uid = uid;
    event.ethertype = ethertype;
    event.dstHwAddr = dstHw;
    event.srcIp = srcIp;
    event.dstIp = dstIp;
    event.ipProtocol = ipProtocol;
    event.srcPort = srcPort;
    event.dstPort = dstPort;
    addWakeupEvent(event);
}
#method_after
@Override
public synchronized void onWakeupEvent(String prefix, int uid, int ethertype, int ipNextHeader, byte[] dstHw, String srcIp, String dstIp, int srcPort, int dstPort, long timestampNs) {
    String iface = prefix.replaceFirst(WAKEUP_EVENT_IFACE_PREFIX, "");
    final long timestampMs;
    if (timestampNs > 0) {
        timestampMs = timestampNs / NANOS_PER_MS;
    } else {
        timestampMs = System.currentTimeMillis();
    }
    WakeupEvent event = new WakeupEvent();
    event.iface = iface;
    event.timestampMs = timestampMs;
    event.uid = uid;
    event.ethertype = ethertype;
    event.dstHwAddr = dstHw;
    event.srcIp = srcIp;
    event.dstIp = dstIp;
    event.ipNextHeader = ipNextHeader;
    event.srcPort = srcPort;
    event.dstPort = dstPort;
    addWakeupEvent(event);
}
#end_block

#method_before
public synchronized void list(PrintWriter pw) {
    for (int i = 0; i < mNetworkMetrics.size(); i++) {
        pw.println(mNetworkMetrics.valueAt(i).connectMetrics);
    }
    for (int i = 0; i < mNetworkMetrics.size(); i++) {
        pw.println(mNetworkMetrics.valueAt(i).dnsMetrics);
    }
    for (NetworkMetricsSnapshot s : getNetworkMetricsSnapshots()) {
        pw.println(s);
    }
    for (int i = 0; i < mWakeupStats.size(); i++) {
        pw.println(mWakeupStats.valueAt(i));
    }
    for (WakeupEvent wakeup : mWakeupEvents.toArray()) {
        pw.println(wakeup);
    }
}
#method_after
public synchronized void list(PrintWriter pw) {
    pw.println("dns/connect events:");
    for (int i = 0; i < mNetworkMetrics.size(); i++) {
        pw.println(mNetworkMetrics.valueAt(i).connectMetrics);
    }
    for (int i = 0; i < mNetworkMetrics.size(); i++) {
        pw.println(mNetworkMetrics.valueAt(i).dnsMetrics);
    }
    pw.println("");
    pw.println("network statistics:");
    for (NetworkMetricsSnapshot s : getNetworkMetricsSnapshots()) {
        pw.println(s);
    }
    pw.println("");
    pw.println("packet wakeup events:");
    for (int i = 0; i < mWakeupStats.size(); i++) {
        pw.println(mWakeupStats.valueAt(i));
    }
    for (WakeupEvent wakeup : mWakeupEvents.toArray()) {
        pw.println(wakeup);
    }
}
#end_block

#method_before
@Override
public String toString() {
    StringJoiner j = new StringJoiner(", ", "WakeupEvent(", ")");
    j.add(String.format("%tT.%tL", timestampMs, timestampMs));
    j.add(iface);
    j.add("uid: " + Integer.toString(uid));
    j.add("eth=0x" + Integer.toHexString(ethertype));
    j.add("dstHw=" + hardwareAddrToString(dstHwAddr));
    if (ipProtocol > 0) {
        j.add("ip=" + ipProtocol);
        j.add("srcIp=" + srcIp);
        j.add("dstIp=" + dstIp);
        if (srcPort > 0) {
            j.add("srcPort=" + srcPort);
        }
        if (dstPort > 0) {
            j.add("dstPort=" + dstPort);
        }
    }
    return j.toString();
}
#method_after
@Override
public String toString() {
    StringJoiner j = new StringJoiner(", ", "WakeupEvent(", ")");
    j.add(String.format("%tT.%tL", timestampMs, timestampMs));
    j.add(iface);
    j.add("uid: " + Integer.toString(uid));
    j.add("eth=0x" + Integer.toHexString(ethertype));
    j.add("dstHw=" + MacAddress.stringAddrFromByteAddr(dstHwAddr));
    if (ipNextHeader > 0) {
        j.add("ipNxtHdr=" + ipNextHeader);
        j.add("srcIp=" + srcIp);
        j.add("dstIp=" + dstIp);
        if (srcPort > -1) {
            j.add("srcPort=" + srcPort);
        }
        if (dstPort > -1) {
            j.add("dstPort=" + dstPort);
        }
    }
    return j.toString();
}
#end_block

#method_before
public static IpConnectivityEvent toProto(WakeupStats in) {
    IpConnectivityLogClass.WakeupStats wakeupStats = new IpConnectivityLogClass.WakeupStats();
    in.updateDuration();
    wakeupStats.durationSec = in.durationSec;
    wakeupStats.totalWakeups = in.totalWakeups;
    wakeupStats.rootWakeups = in.rootWakeups;
    wakeupStats.systemWakeups = in.systemWakeups;
    wakeupStats.nonApplicationWakeups = in.nonApplicationWakeups;
    wakeupStats.applicationWakeups = in.applicationWakeups;
    wakeupStats.noUidWakeups = in.noUidWakeups;
    wakeupStats.l2UnicastCounts = in.l2UnicastCounts;
    wakeupStats.l2MulticastCounts = in.l2MulticastCounts;
    wakeupStats.l2BroadcastCounts = in.l2BroadcastCounts;
    wakeupStats.ethertypeCounts = toPairArray(in.ethertypes);
    wakeupStats.ipProtocolCounts = toPairArray(in.ipProtocols);
    final IpConnectivityEvent out = buildEvent(0, 0, in.iface);
    out.setWakeupStats(wakeupStats);
    return out;
}
#method_after
public static IpConnectivityEvent toProto(WakeupStats in) {
    IpConnectivityLogClass.WakeupStats wakeupStats = new IpConnectivityLogClass.WakeupStats();
    in.updateDuration();
    wakeupStats.durationSec = in.durationSec;
    wakeupStats.totalWakeups = in.totalWakeups;
    wakeupStats.rootWakeups = in.rootWakeups;
    wakeupStats.systemWakeups = in.systemWakeups;
    wakeupStats.nonApplicationWakeups = in.nonApplicationWakeups;
    wakeupStats.applicationWakeups = in.applicationWakeups;
    wakeupStats.noUidWakeups = in.noUidWakeups;
    wakeupStats.l2UnicastCount = in.l2UnicastCount;
    wakeupStats.l2MulticastCount = in.l2MulticastCount;
    wakeupStats.l2BroadcastCount = in.l2BroadcastCount;
    wakeupStats.ethertypeCounts = toPairArray(in.ethertypes);
    wakeupStats.ipNextHeaderCounts = toPairArray(in.ipNextHeaders);
    final IpConnectivityEvent out = buildEvent(0, 0, in.iface);
    out.setWakeupStats(wakeupStats);
    return out;
}
#end_block

#method_before
public static IpConnectivityEvent toProto(WakeupStats in) {
    IpConnectivityLogClass.WakeupStats wakeupStats = new IpConnectivityLogClass.WakeupStats();
    in.updateDuration();
    wakeupStats.durationSec = in.durationSec;
    wakeupStats.totalWakeups = in.totalWakeups;
    wakeupStats.rootWakeups = in.rootWakeups;
    wakeupStats.systemWakeups = in.systemWakeups;
    wakeupStats.nonApplicationWakeups = in.nonApplicationWakeups;
    wakeupStats.applicationWakeups = in.applicationWakeups;
    wakeupStats.noUidWakeups = in.noUidWakeups;
    wakeupStats.l2UnicastCounts = in.l2UnicastCounts;
    wakeupStats.l2MulticastCounts = in.l2MulticastCounts;
    wakeupStats.l2BroadcastCounts = in.l2BroadcastCounts;
    wakeupStats.ethertypeCounts = toPairArray(in.ethertypes);
    wakeupStats.ipProtocolCounts = toPairArray(in.ipProtocols);
    final IpConnectivityEvent out = buildEvent(0, 0, in.iface);
    out.setWakeupStats(wakeupStats);
    return out;
}
#method_after
public static IpConnectivityEvent toProto(DefaultNetworkEvent in) {
    IpConnectivityLogClass.DefaultNetworkEvent ev = new IpConnectivityLogClass.DefaultNetworkEvent();
    ev.finalScore = in.finalScore;
    ev.initialScore = in.initialScore;
    ev.ipSupport = ipSupportOf(in);
    ev.defaultNetworkDurationMs = in.durationMs;
    ev.validationDurationMs = in.validatedMs;
    ev.previousDefaultNetworkLinkLayer = transportsToLinkLayer(in.previousTransports);
    final IpConnectivityEvent out = buildEvent(in.netId, in.transports, null);
    if (in.transports == 0) {
        // Set link layer to NONE for events representing the absence of a default network.
        out.linkLayer = IpConnectivityLogClass.NONE;
    }
    out.setDefaultNetworkEvent(ev);
    return out;
}
#end_block

#method_before
private static boolean setEvent(IpConnectivityEvent out, Parcelable in) {
    if (in instanceof DhcpErrorEvent) {
        setDhcpErrorEvent(out, (DhcpErrorEvent) in);
        return true;
    }
    if (in instanceof DhcpClientEvent) {
        setDhcpClientEvent(out, (DhcpClientEvent) in);
        return true;
    }
    if (in instanceof IpManagerEvent) {
        setIpManagerEvent(out, (IpManagerEvent) in);
        return true;
    }
    if (in instanceof IpReachabilityEvent) {
        setIpReachabilityEvent(out, (IpReachabilityEvent) in);
        return true;
    }
    if (in instanceof DefaultNetworkEvent) {
        setDefaultNetworkEvent(out, (DefaultNetworkEvent) in);
        return true;
    }
    if (in instanceof NetworkEvent) {
        setNetworkEvent(out, (NetworkEvent) in);
        return true;
    }
    if (in instanceof ValidationProbeEvent) {
        setValidationProbeEvent(out, (ValidationProbeEvent) in);
        return true;
    }
    if (in instanceof ApfProgramEvent) {
        setApfProgramEvent(out, (ApfProgramEvent) in);
        return true;
    }
    if (in instanceof ApfStats) {
        setApfStats(out, (ApfStats) in);
        return true;
    }
    if (in instanceof RaEvent) {
        setRaEvent(out, (RaEvent) in);
        return true;
    }
    return false;
}
#method_after
private static boolean setEvent(IpConnectivityEvent out, Parcelable in) {
    if (in instanceof DhcpErrorEvent) {
        setDhcpErrorEvent(out, (DhcpErrorEvent) in);
        return true;
    }
    if (in instanceof DhcpClientEvent) {
        setDhcpClientEvent(out, (DhcpClientEvent) in);
        return true;
    }
    if (in instanceof IpManagerEvent) {
        setIpManagerEvent(out, (IpManagerEvent) in);
        return true;
    }
    if (in instanceof IpReachabilityEvent) {
        setIpReachabilityEvent(out, (IpReachabilityEvent) in);
        return true;
    }
    if (in instanceof NetworkEvent) {
        setNetworkEvent(out, (NetworkEvent) in);
        return true;
    }
    if (in instanceof ValidationProbeEvent) {
        setValidationProbeEvent(out, (ValidationProbeEvent) in);
        return true;
    }
    if (in instanceof ApfProgramEvent) {
        setApfProgramEvent(out, (ApfProgramEvent) in);
        return true;
    }
    if (in instanceof ApfStats) {
        setApfStats(out, (ApfStats) in);
        return true;
    }
    if (in instanceof RaEvent) {
        setRaEvent(out, (RaEvent) in);
        return true;
    }
    return false;
}
#end_block

#method_before
private static int ipSupportOf(DefaultNetworkEvent in) {
    if (in.prevIPv4 && in.prevIPv6) {
        return IpConnectivityLogClass.DefaultNetworkEvent.DUAL;
    }
    if (in.prevIPv6) {
        return IpConnectivityLogClass.DefaultNetworkEvent.IPV6;
    }
    if (in.prevIPv4) {
        return IpConnectivityLogClass.DefaultNetworkEvent.IPV4;
    }
    return IpConnectivityLogClass.DefaultNetworkEvent.NONE;
}
#method_after
private static int ipSupportOf(DefaultNetworkEvent in) {
    if (in.ipv4 && in.ipv6) {
        return IpConnectivityLogClass.DefaultNetworkEvent.DUAL;
    }
    if (in.ipv6) {
        return IpConnectivityLogClass.DefaultNetworkEvent.IPV6;
    }
    if (in.ipv4) {
        return IpConnectivityLogClass.DefaultNetworkEvent.IPV4;
    }
    return IpConnectivityLogClass.DefaultNetworkEvent.NONE;
}
#end_block

#method_before
@Test
public void testWakeupEventLogging() throws Exception {
    final int BUFFER_LENGTH = NetdEventListenerService.WAKEUP_EVENT_BUFFER_LENGTH;
    final long now = System.currentTimeMillis();
    final String iface = "wlan0";
    final byte[] mac = MAC_ADDR;
    final String srcIp = "192.168.2.1";
    final String dstIp = "192.168.2.23";
    final String srcIp6 = "2401:fa00:4:fd00:a585:13d1:6a23:4fb4";
    final String dstIp6 = "2404:6800:4006:807::200a";
    final int sport = 2356;
    final int dport = 13489;
    final int v4 = 0x800;
    final int v6 = 0x86dd;
    final int tcp = 6;
    final int udp = 17;
    final int icmp6 = 58;
    // Assert no events
    String[] events1 = listNetdEvent();
    assertEquals(new String[] { "" }, events1);
    int[] uids = { 10001, 10002, 10004, 1000, 10052, 10023, 10002, 10123, 10004 };
    wakeupEvent(iface, uids[0], v4, tcp, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent(iface, uids[1], v6, udp, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent(iface, uids[2], v6, udp, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent(iface, uids[3], v4, icmp6, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent(iface, uids[4], v6, tcp, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent(iface, uids[5], v4, tcp, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent(iface, uids[6], v6, udp, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent(iface, uids[7], v6, tcp, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent(iface, uids[8], v6, udp, mac, srcIp6, dstIp6, sport, dport, now);
    String[] events2 = listNetdEvent();
    // +1 for the WakeupStats line
    int expectedLength2 = uids.length + 1;
    assertEquals(expectedLength2, events2.length);
    assertContains(events2[0], "WakeupStats");
    assertContains(events2[0], "wlan0");
    assertContains(events2[0], "0x800");
    assertContains(events2[0], "0x86dd");
    for (int i = 0; i < uids.length; i++) {
        String got = events2[i + 1];
        assertContains(got, "WakeupEvent");
        assertContains(got, "wlan0");
        assertContains(got, "uid: " + uids[i]);
    }
    int uid = 20000;
    for (int i = 0; i < BUFFER_LENGTH * 2; i++) {
        long ts = now + 10;
        wakeupEvent(iface, uid, 0x800, 6, mac, srcIp, dstIp, 23, 24, ts);
    }
    String[] events3 = listNetdEvent();
    // +1 for the WakeupStats line
    int expectedLength3 = BUFFER_LENGTH + 1;
    assertEquals(expectedLength3, events3.length);
    assertContains(events2[0], "WakeupStats");
    assertContains(events2[0], "wlan0");
    for (int i = 1; i < expectedLength3; i++) {
        String got = events3[i];
        assertContains(got, "WakeupEvent");
        assertContains(got, "wlan0");
        assertContains(got, "uid: " + uid);
    }
    uid = 45678;
    wakeupEvent(iface, uid, 0x800, 6, mac, srcIp, dstIp, 23, 24, now);
    String[] events4 = listNetdEvent();
    String lastEvent = events4[events4.length - 1];
    assertContains(lastEvent, "WakeupEvent");
    assertContains(lastEvent, "wlan0");
    assertContains(lastEvent, "uid: " + uid);
}
#method_after
@Test
public void testWakeupEventLogging() throws Exception {
    final int BUFFER_LENGTH = NetdEventListenerService.WAKEUP_EVENT_BUFFER_LENGTH;
    final long now = System.currentTimeMillis();
    final String iface = "wlan0";
    final byte[] mac = MAC_ADDR;
    final String srcIp = "192.168.2.1";
    final String dstIp = "192.168.2.23";
    final String srcIp6 = "2001:db8:4:fd00:a585:13d1:6a23:4fb4";
    final String dstIp6 = "2001:db8:4006:807::200a";
    final int sport = 2356;
    final int dport = 13489;
    final int v4 = 0x800;
    final int v6 = 0x86dd;
    final int tcp = 6;
    final int udp = 17;
    final int icmp6 = 58;
    // Baseline without any event
    String[] baseline = listNetdEvent();
    int[] uids = { 10001, 10002, 10004, 1000, 10052, 10023, 10002, 10123, 10004 };
    wakeupEvent(iface, uids[0], v4, tcp, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent(iface, uids[1], v6, udp, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent(iface, uids[2], v6, udp, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent(iface, uids[3], v4, icmp6, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent(iface, uids[4], v6, tcp, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent(iface, uids[5], v4, tcp, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent(iface, uids[6], v6, udp, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent(iface, uids[7], v6, tcp, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent(iface, uids[8], v6, udp, mac, srcIp6, dstIp6, sport, dport, now);
    String[] events2 = remove(listNetdEvent(), baseline);
    // +1 for the WakeupStats line
    int expectedLength2 = uids.length + 1;
    assertEquals(expectedLength2, events2.length);
    assertContains(events2[0], "WakeupStats");
    assertContains(events2[0], "wlan0");
    assertContains(events2[0], "0x800");
    assertContains(events2[0], "0x86dd");
    for (int i = 0; i < uids.length; i++) {
        String got = events2[i + 1];
        assertContains(got, "WakeupEvent");
        assertContains(got, "wlan0");
        assertContains(got, "uid: " + uids[i]);
    }
    int uid = 20000;
    for (int i = 0; i < BUFFER_LENGTH * 2; i++) {
        long ts = now + 10;
        wakeupEvent(iface, uid, 0x800, 6, mac, srcIp, dstIp, 23, 24, ts);
    }
    String[] events3 = remove(listNetdEvent(), baseline);
    // +1 for the WakeupStats line
    int expectedLength3 = BUFFER_LENGTH + 1;
    assertEquals(expectedLength3, events3.length);
    assertContains(events2[0], "WakeupStats");
    assertContains(events2[0], "wlan0");
    for (int i = 1; i < expectedLength3; i++) {
        String got = events3[i];
        assertContains(got, "WakeupEvent");
        assertContains(got, "wlan0");
        assertContains(got, "uid: " + uid);
    }
    uid = 45678;
    wakeupEvent(iface, uid, 0x800, 6, mac, srcIp, dstIp, 23, 24, now);
    String[] events4 = remove(listNetdEvent(), baseline);
    String lastEvent = events4[events4.length - 1];
    assertContains(lastEvent, "WakeupEvent");
    assertContains(lastEvent, "wlan0");
    assertContains(lastEvent, "uid: " + uid);
}
#end_block

#method_before
@Test
public void testWakeupStatsLogging() throws Exception {
    final byte[] mac = MAC_ADDR;
    final String srcIp = "192.168.2.1";
    final String dstIp = "192.168.2.23";
    final String srcIp6 = "2401:fa00:4:fd00:a585:13d1:6a23:4fb4";
    final String dstIp6 = "2404:6800:4006:807::200a";
    final int sport = 2356;
    final int dport = 13489;
    final long now = 1001L;
    final int v4 = 0x800;
    final int v6 = 0x86dd;
    final int tcp = 6;
    final int udp = 17;
    final int icmp6 = 58;
    wakeupEvent("wlan0", 1000, v4, tcp, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent("rmnet0", 10123, v4, tcp, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent("wlan0", 1000, v4, udp, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent("rmnet0", 10008, v4, tcp, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent("wlan0", -1, v6, icmp6, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent("wlan0", 10008, v4, tcp, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent("rmnet0", 1000, v4, tcp, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent("wlan0", 10004, v4, udp, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent("wlan0", 1000, v6, tcp, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent("wlan0", 0, v6, udp, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent("wlan0", -1, v6, icmp6, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent("rmnet0", 10052, v4, tcp, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent("wlan0", 0, v6, udp, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent("rmnet0", 1000, v6, tcp, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent("wlan0", 1010, v4, udp, mac, srcIp, dstIp, sport, dport, now);
    String got = flushStatistics();
    String want = String.join("\n", "dropped_events: 0", "events <", "  if_name: \"\"", "  link_layer: 2", "  network_id: 0", "  time_ms: 0", "  transports: 0", "  wakeup_stats <", "    application_wakeups: 3", "    duration_sec: 0", "    ethertype_counts <", "      key: 2048", "      value: 4", "    >", "    ethertype_counts <", "      key: 34525", "      value: 1", "    >", "    ip_protocol_counts <", "      key: 6", "      value: 5", "    >", "    l2_broadcast_counts: 0", "    l2_multicast_counts: 0", "    l2_unicast_counts: 5", "    no_uid_wakeups: 0", "    non_application_wakeups: 0", "    root_wakeups: 0", "    system_wakeups: 2", "    total_wakeups: 5", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 0", "  time_ms: 0", "  transports: 0", "  wakeup_stats <", "    application_wakeups: 2", "    duration_sec: 0", "    ethertype_counts <", "      key: 2048", "      value: 5", "    >", "    ethertype_counts <", "      key: 34525", "      value: 5", "    >", "    ip_protocol_counts <", "      key: 6", "      value: 3", "    >", "    ip_protocol_counts <", "      key: 17", "      value: 5", "    >", "    ip_protocol_counts <", "      key: 58", "      value: 2", "    >", "    l2_broadcast_counts: 0", "    l2_multicast_counts: 0", "    l2_unicast_counts: 10", "    no_uid_wakeups: 2", "    non_application_wakeups: 1", "    root_wakeups: 2", "    system_wakeups: 3", "    total_wakeups: 10", "  >", ">", "version: 2\n");
    assertEquals(want, got);
}
#method_after
@Test
public void testWakeupStatsLogging() throws Exception {
    final byte[] mac = MAC_ADDR;
    final String srcIp = "192.168.2.1";
    final String dstIp = "192.168.2.23";
    final String srcIp6 = "2401:fa00:4:fd00:a585:13d1:6a23:4fb4";
    final String dstIp6 = "2404:6800:4006:807::200a";
    final int sport = 2356;
    final int dport = 13489;
    final long now = 1001L;
    final int v4 = 0x800;
    final int v6 = 0x86dd;
    final int tcp = 6;
    final int udp = 17;
    final int icmp6 = 58;
    wakeupEvent("wlan0", 1000, v4, tcp, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent("rmnet0", 10123, v4, tcp, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent("wlan0", 1000, v4, udp, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent("rmnet0", 10008, v4, tcp, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent("wlan0", -1, v6, icmp6, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent("wlan0", 10008, v4, tcp, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent("rmnet0", 1000, v4, tcp, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent("wlan0", 10004, v4, udp, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent("wlan0", 1000, v6, tcp, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent("wlan0", 0, v6, udp, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent("wlan0", -1, v6, icmp6, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent("rmnet0", 10052, v4, tcp, mac, srcIp, dstIp, sport, dport, now);
    wakeupEvent("wlan0", 0, v6, udp, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent("rmnet0", 1000, v6, tcp, mac, srcIp6, dstIp6, sport, dport, now);
    wakeupEvent("wlan0", 1010, v4, udp, mac, srcIp, dstIp, sport, dport, now);
    String got = flushStatistics();
    String want = String.join("\n", "dropped_events: 0", "events <", "  if_name: \"\"", "  link_layer: 2", "  network_id: 0", "  time_ms: 0", "  transports: 0", "  wakeup_stats <", "    application_wakeups: 3", "    duration_sec: 0", "    ethertype_counts <", "      key: 2048", "      value: 4", "    >", "    ethertype_counts <", "      key: 34525", "      value: 1", "    >", "    ip_next_header_counts <", "      key: 6", "      value: 5", "    >", "    l2_broadcast_count: 0", "    l2_multicast_count: 0", "    l2_unicast_count: 5", "    no_uid_wakeups: 0", "    non_application_wakeups: 0", "    root_wakeups: 0", "    system_wakeups: 2", "    total_wakeups: 5", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 0", "  time_ms: 0", "  transports: 0", "  wakeup_stats <", "    application_wakeups: 2", "    duration_sec: 0", "    ethertype_counts <", "      key: 2048", "      value: 5", "    >", "    ethertype_counts <", "      key: 34525", "      value: 5", "    >", "    ip_next_header_counts <", "      key: 6", "      value: 3", "    >", "    ip_next_header_counts <", "      key: 17", "      value: 5", "    >", "    ip_next_header_counts <", "      key: 58", "      value: 2", "    >", "    l2_broadcast_count: 0", "    l2_multicast_count: 0", "    l2_unicast_count: 10", "    no_uid_wakeups: 2", "    non_application_wakeups: 1", "    root_wakeups: 2", "    system_wakeups: 3", "    total_wakeups: 10", "  >", ">", "version: 2\n");
    assertEquals(want, got);
}
#end_block

#method_before
void wakeupEvent(String iface, int uid, int ether, int ip, byte[] mac, String srcIp, String dstIp, int sport, int dport, long now) throws Exception {
    String prefix = NetdEventListenerService.WAKEUP_EVENT_IFACE_PREFIX + iface;
    mService.onWakeupEvent(prefix, uid, uid, ether, ip, mac, srcIp, dstIp, sport, dport, now);
}
#method_after
void wakeupEvent(String iface, int uid, int ether, int ip, byte[] mac, String srcIp, String dstIp, int sport, int dport, long now) throws Exception {
    String prefix = NetdEventListenerService.WAKEUP_EVENT_IFACE_PREFIX + iface;
    mService.onWakeupEvent(prefix, uid, ether, ip, mac, srcIp, dstIp, sport, dport, now);
}
#end_block

#method_before
void asyncDump(long durationMs) throws Exception {
    final long stop = System.currentTimeMillis() + durationMs;
    final PrintWriter pw = new PrintWriter(new FileOutputStream("/dev/null"));
    new Thread(() -> {
        while (System.currentTimeMillis() < stop) {
            mService.dump(pw);
        }
    }).start();
}
#method_after
void asyncDump(long durationMs) throws Exception {
    final long stop = System.currentTimeMillis() + durationMs;
    final PrintWriter pw = new PrintWriter(new FileOutputStream("/dev/null"));
    new Thread(() -> {
        while (System.currentTimeMillis() < stop) {
            mService.list(pw);
        }
    }).start();
}
#end_block

#method_before
public void countEvent(WakeupEvent ev) {
    totalWakeups++;
    switch(ev.uid) {
        case Process.ROOT_UID:
            rootWakeups++;
            break;
        case Process.SYSTEM_UID:
            systemWakeups++;
            break;
        case NO_UID:
            noUidWakeups++;
            break;
        default:
            if (ev.uid >= Process.FIRST_APPLICATION_UID) {
                applicationWakeups++;
            } else {
                nonApplicationWakeups++;
            }
            break;
    }
    if (ev.dstHwAddr.length == L2_BROADCAST.length) {
        if (Arrays.equals(ev.dstHwAddr, L2_BROADCAST)) {
            l2BroadcastCounts++;
        } else if (ev.dstHwAddr[0] == 1) {
            l2MulticastCounts++;
        } else {
            l2UnicastCounts++;
        }
    }
    increment(ethertypes, ev.ethertype);
    if (ev.ipProtocol >= 0) {
        increment(ipProtocols, ev.ipProtocol);
    }
}
#method_after
public void countEvent(WakeupEvent ev) {
    totalWakeups++;
    switch(ev.uid) {
        case Process.ROOT_UID:
            rootWakeups++;
            break;
        case Process.SYSTEM_UID:
            systemWakeups++;
            break;
        case NO_UID:
            noUidWakeups++;
            break;
        default:
            if (ev.uid >= Process.FIRST_APPLICATION_UID) {
                applicationWakeups++;
            } else {
                nonApplicationWakeups++;
            }
            break;
    }
    switch(MacAddress.macAddressType(ev.dstHwAddr)) {
        case UNICAST:
            l2UnicastCount++;
            break;
        case MULTICAST:
            l2MulticastCount++;
            break;
        case BROADCAST:
            l2BroadcastCount++;
            break;
        default:
            break;
    }
    increment(ethertypes, ev.ethertype);
    if (ev.ipNextHeader >= 0) {
        increment(ipNextHeaders, ev.ipNextHeader);
    }
}
#end_block

#method_before
@Override
public String toString() {
    updateDuration();
    StringJoiner j = new StringJoiner(", ", "WakeupStats(", ")");
    j.add(iface);
    j.add("" + durationSec + "s");
    j.add("total: " + totalWakeups);
    j.add("root: " + rootWakeups);
    j.add("system: " + systemWakeups);
    j.add("apps: " + applicationWakeups);
    j.add("non-apps: " + nonApplicationWakeups);
    j.add("no uid: " + noUidWakeups);
    j.add(String.format("l2 unicast/multicast/broadcast: %d/%d/%d", l2UnicastCounts, l2MulticastCounts, l2BroadcastCounts));
    for (int i = 0; i < ethertypes.size(); i++) {
        int eth = ethertypes.keyAt(i);
        int count = ethertypes.valueAt(i);
        j.add(String.format("ethertype 0x%x: %d", eth, count));
    }
    for (int i = 0; i < ipProtocols.size(); i++) {
        int proto = ipProtocols.keyAt(i);
        int count = ipProtocols.valueAt(i);
        j.add(String.format("ipproto %d: %d", proto, count));
    }
    return j.toString();
}
#method_after
@Override
public String toString() {
    updateDuration();
    StringJoiner j = new StringJoiner(", ", "WakeupStats(", ")");
    j.add(iface);
    j.add("" + durationSec + "s");
    j.add("total: " + totalWakeups);
    j.add("root: " + rootWakeups);
    j.add("system: " + systemWakeups);
    j.add("apps: " + applicationWakeups);
    j.add("non-apps: " + nonApplicationWakeups);
    j.add("no uid: " + noUidWakeups);
    j.add(String.format("l2 unicast/multicast/broadcast: %d/%d/%d", l2UnicastCount, l2MulticastCount, l2BroadcastCount));
    for (int i = 0; i < ethertypes.size(); i++) {
        int eth = ethertypes.keyAt(i);
        int count = ethertypes.valueAt(i);
        j.add(String.format("ethertype 0x%x: %d", eth, count));
    }
    for (int i = 0; i < ipNextHeaders.size(); i++) {
        int proto = ipNextHeaders.keyAt(i);
        int count = ipNextHeaders.valueAt(i);
        j.add(String.format("ipNxtHdr %d: %d", proto, count));
    }
    return j.toString();
}
#end_block

#method_before
@Test
public void testDefaultNetworkEventSerialization() {
    ConnectivityMetricsEvent ev = describeIpEvent(aType(DefaultNetworkEvent.class), anInt(102), anIntArray(1, 2, 3), anInt(101), aBool(true), aBool(false));
    String want = String.join("\n", "dropped_events: 0", "events <", "  if_name: \"\"", "  link_layer: 0", "  network_id: 0", "  time_ms: 1", "  transports: 0", "  default_network_event <", "    default_network_duration_ms: 0", "    final_score: 0", "    initial_score: 0", "    ip_support: 0", "    network_id <", "      network_id: 102", "    >", "    no_default_network_duration_ms: 0", "    previous_network_id <", "      network_id: 101", "    >", "    previous_network_ip_support: 1", "    transport_types: 1", "    transport_types: 2", "    transport_types: 3", "  >", ">", "version: 2\n");
    verifySerialization(want, ev);
}
#method_after
@Test
public void testDefaultNetworkEventSerialization() {
    DefaultNetworkEvent ev = new DefaultNetworkEvent(1001);
    ev.netId = 102;
    ev.transports = 2;
    ev.previousTransports = 4;
    ev.ipv4 = true;
    ev.initialScore = 20;
    ev.finalScore = 60;
    ev.durationMs = 54;
    ev.validatedMs = 27;
    String want = String.join("\n", "dropped_events: 0", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 102", "  time_ms: 0", "  transports: 2", "  default_network_event <", "    default_network_duration_ms: 54", "    final_score: 60", "    initial_score: 20", "    ip_support: 1", "    no_default_network_duration_ms: 0", "    previous_default_network_link_layer: 1", "    previous_network_ip_support: 0", "    validation_duration_ms: 27", "  >", ">", "version: 2\n");
    verifySerialization(want, IpConnectivityEventBuilder.toProto(ev));
}
#end_block

#method_before
@Test
public void testWakeupStatsSerialization() {
    WakeupStats stats = new WakeupStats("wlan0");
    stats.totalWakeups = 14;
    stats.applicationWakeups = 5;
    stats.nonApplicationWakeups = 1;
    stats.rootWakeups = 2;
    stats.systemWakeups = 3;
    stats.noUidWakeups = 3;
    stats.l2UnicastCounts = 5;
    stats.l2MulticastCounts = 1;
    stats.l2BroadcastCounts = 2;
    stats.ethertypes.put(0x800, 3);
    stats.ethertypes.put(0x86dd, 3);
    stats.ipProtocols.put(6, 5);
    IpConnectivityEvent got = IpConnectivityEventBuilder.toProto(stats);
    String want = String.join("\n", "dropped_events: 0", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 0", "  time_ms: 0", "  transports: 0", "  wakeup_stats <", "    application_wakeups: 5", "    duration_sec: 0", "    ethertype_counts <", "      key: 2048", "      value: 3", "    >", "    ethertype_counts <", "      key: 34525", "      value: 3", "    >", "    ip_protocol_counts <", "      key: 6", "      value: 5", "    >", "    l2_broadcast_counts: 2", "    l2_multicast_counts: 1", "    l2_unicast_counts: 5", "    no_uid_wakeups: 3", "    non_application_wakeups: 1", "    root_wakeups: 2", "    system_wakeups: 3", "    total_wakeups: 14", "  >", ">", "version: 2\n");
    verifySerialization(want, got);
}
#method_after
@Test
public void testWakeupStatsSerialization() {
    WakeupStats stats = new WakeupStats("wlan0");
    stats.totalWakeups = 14;
    stats.applicationWakeups = 5;
    stats.nonApplicationWakeups = 1;
    stats.rootWakeups = 2;
    stats.systemWakeups = 3;
    stats.noUidWakeups = 3;
    stats.l2UnicastCount = 5;
    stats.l2MulticastCount = 1;
    stats.l2BroadcastCount = 2;
    stats.ethertypes.put(0x800, 3);
    stats.ethertypes.put(0x86dd, 3);
    stats.ipNextHeaders.put(6, 5);
    IpConnectivityEvent got = IpConnectivityEventBuilder.toProto(stats);
    String want = String.join("\n", "dropped_events: 0", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 0", "  time_ms: 0", "  transports: 0", "  wakeup_stats <", "    application_wakeups: 5", "    duration_sec: 0", "    ethertype_counts <", "      key: 2048", "      value: 3", "    >", "    ethertype_counts <", "      key: 34525", "      value: 3", "    >", "    ip_next_header_counts <", "      key: 6", "      value: 5", "    >", "    l2_broadcast_count: 2", "    l2_multicast_count: 1", "    l2_unicast_count: 5", "    no_uid_wakeups: 3", "    non_application_wakeups: 1", "    root_wakeups: 2", "    system_wakeups: 3", "    total_wakeups: 14", "  >", ">", "version: 2\n");
    verifySerialization(want, got);
}
#end_block

#method_before
@Test
public void testEndToEndLogging() throws Exception {
    // TODO: instead of comparing textpb to textpb, parse textpb and compare proto to proto.
    IpConnectivityLog logger = new IpConnectivityLog(mService.impl);
    NetworkCapabilities ncWifi = new NetworkCapabilities();
    NetworkCapabilities ncCell = new NetworkCapabilities();
    ncWifi.addTransportType(NetworkCapabilities.TRANSPORT_WIFI);
    ncCell.addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR);
    when(mCm.getNetworkCapabilities(new Network(100))).thenReturn(ncWifi);
    when(mCm.getNetworkCapabilities(new Network(101))).thenReturn(ncCell);
    ApfStats apfStats = new ApfStats();
    apfStats.durationMs = 45000;
    apfStats.receivedRas = 10;
    apfStats.matchingRas = 2;
    apfStats.droppedRas = 2;
    apfStats.parseErrors = 2;
    apfStats.zeroLifetimeRas = 1;
    apfStats.programUpdates = 4;
    apfStats.programUpdatesAll = 7;
    apfStats.programUpdatesAllowingMulticast = 3;
    apfStats.maxProgramSize = 2048;
    ValidationProbeEvent validationEv = new ValidationProbeEvent();
    validationEv.durationMs = 40730;
    validationEv.probeType = ValidationProbeEvent.PROBE_HTTP;
    validationEv.returnCode = 204;
    Parcelable[] events = { new IpReachabilityEvent(IpReachabilityEvent.NUD_FAILED), new DhcpClientEvent("SomeState", 192), new DefaultNetworkEvent(102, new int[] { 1, 2, 3 }, 101, true, false), new IpManagerEvent(IpManagerEvent.PROVISIONING_OK, 5678), validationEv, apfStats, new RaEvent(2000, 400, 300, -1, 1000, -1) };
    for (int i = 0; i < events.length; i++) {
        ConnectivityMetricsEvent ev = new ConnectivityMetricsEvent();
        ev.timestamp = 100 * (i + 1);
        ev.ifname = "wlan0";
        ev.data = events[i];
        logger.log(ev);
    }
    // netId, errno, latency, destination
    connectEvent(100, OsConstants.EALREADY, 0, EXAMPLE_IPV4);
    connectEvent(100, OsConstants.EINPROGRESS, 0, EXAMPLE_IPV6);
    connectEvent(100, 0, 110, EXAMPLE_IPV4);
    connectEvent(101, 0, 23, EXAMPLE_IPV4);
    connectEvent(101, 0, 45, EXAMPLE_IPV6);
    connectEvent(100, OsConstants.EAGAIN, 0, EXAMPLE_IPV4);
    // netId, type, return code, latency
    dnsEvent(100, EVENT_GETADDRINFO, 0, 3456);
    dnsEvent(100, EVENT_GETADDRINFO, 3, 45);
    dnsEvent(100, EVENT_GETHOSTBYNAME, 0, 638);
    dnsEvent(101, EVENT_GETADDRINFO, 0, 56);
    dnsEvent(101, EVENT_GETHOSTBYNAME, 0, 34);
    // iface, uid
    final byte[] mac = { 11, 22, 33, 44, 55, 66 };
    final String srcIp = "192.168.2.1";
    final String dstIp = "192.168.2.23";
    final int sport = 2356;
    final int dport = 13489;
    final long now = 1001L;
    final int v4 = 0x800;
    final int tcp = 6;
    final int udp = 17;
    wakeupEvent("wlan0", 1000, v4, tcp, mac, srcIp, dstIp, sport, dport, 1001L);
    wakeupEvent("wlan0", 10123, v4, tcp, mac, srcIp, dstIp, sport, dport, 1001L);
    wakeupEvent("wlan0", 1000, v4, udp, mac, srcIp, dstIp, sport, dport, 1001L);
    wakeupEvent("wlan0", 10008, v4, udp, mac, srcIp, dstIp, sport, dport, 1001L);
    wakeupEvent("wlan0", -1, v4, udp, mac, srcIp, dstIp, sport, dport, 1001L);
    wakeupEvent("wlan0", 10008, v4, tcp, mac, srcIp, dstIp, sport, dport, 1001L);
    String want = String.join("\n", "dropped_events: 0", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 0", "  time_ms: 100", "  transports: 0", "  ip_reachability_event <", "    event_type: 512", "    if_name: \"\"", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 0", "  time_ms: 200", "  transports: 0", "  dhcp_event <", "    duration_ms: 192", "    if_name: \"\"", "    state_transition: \"SomeState\"", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 0", "  time_ms: 300", "  transports: 0", "  default_network_event <", "    default_network_duration_ms: 0", "    final_score: 0", "    initial_score: 0", "    ip_support: 0", "    network_id <", "      network_id: 102", "    >", "    no_default_network_duration_ms: 0", "    previous_network_id <", "      network_id: 101", "    >", "    previous_network_ip_support: 1", "    transport_types: 1", "    transport_types: 2", "    transport_types: 3", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 0", "  time_ms: 400", "  transports: 0", "  ip_provisioning_event <", "    event_type: 1", "    if_name: \"\"", "    latency_ms: 5678", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 0", "  time_ms: 500", "  transports: 0", "  validation_probe_event <", "    latency_ms: 40730", "    probe_result: 204", "    probe_type: 1", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 0", "  time_ms: 600", "  transports: 0", "  apf_statistics <", "    dropped_ras: 2", "    duration_ms: 45000", "    matching_ras: 2", "    max_program_size: 2048", "    parse_errors: 2", "    program_updates: 4", "    program_updates_all: 7", "    program_updates_allowing_multicast: 3", "    received_ras: 10", "    total_packet_dropped: 0", "    total_packet_processed: 0", "    zero_lifetime_ras: 1", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 0", "  time_ms: 700", "  transports: 0", "  ra_event <", "    dnssl_lifetime: -1", "    prefix_preferred_lifetime: 300", "    prefix_valid_lifetime: 400", "    rdnss_lifetime: 1000", "    route_info_lifetime: -1", "    router_lifetime: 2000", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 100", "  time_ms: 0", "  transports: 2", "  connect_statistics <", "    connect_blocking_count: 1", "    connect_count: 3", "    errnos_counters <", "      key: 11", "      value: 1", "    >", "    ipv6_addr_count: 1", "    latencies_ms: 110", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 2", "  network_id: 101", "  time_ms: 0", "  transports: 1", "  connect_statistics <", "    connect_blocking_count: 2", "    connect_count: 2", "    ipv6_addr_count: 1", "    latencies_ms: 23", "    latencies_ms: 45", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 100", "  time_ms: 0", "  transports: 2", "  dns_lookup_batch <", "    event_types: 1", "    event_types: 1", "    event_types: 2", "    getaddrinfo_error_count: 0", "    getaddrinfo_query_count: 0", "    gethostbyname_error_count: 0", "    gethostbyname_query_count: 0", "    latencies_ms: 3456", "    latencies_ms: 45", "    latencies_ms: 638", "    return_codes: 0", "    return_codes: 3", "    return_codes: 0", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 2", "  network_id: 101", "  time_ms: 0", "  transports: 1", "  dns_lookup_batch <", "    event_types: 1", "    event_types: 2", "    getaddrinfo_error_count: 0", "    getaddrinfo_query_count: 0", "    gethostbyname_error_count: 0", "    gethostbyname_query_count: 0", "    latencies_ms: 56", "    latencies_ms: 34", "    return_codes: 0", "    return_codes: 0", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 0", "  time_ms: 0", "  transports: 0", "  wakeup_stats <", "    application_wakeups: 3", "    duration_sec: 0", "    ethertype_counts <", "      key: 2048", "      value: 6", "    >", "    ip_protocol_counts <", "      key: 6", "      value: 3", "    >", "    ip_protocol_counts <", "      key: 17", "      value: 3", "    >", "    l2_broadcast_counts: 0", "    l2_multicast_counts: 0", "    l2_unicast_counts: 6", "    no_uid_wakeups: 1", "    non_application_wakeups: 0", "    root_wakeups: 0", "    system_wakeups: 2", "    total_wakeups: 6", "  >", ">", "version: 2\n");
    verifySerialization(want, getdump("flush"));
}
#method_after
@Test
public void testEndToEndLogging() throws Exception {
    // TODO: instead of comparing textpb to textpb, parse textpb and compare proto to proto.
    IpConnectivityLog logger = new IpConnectivityLog(mService.impl);
    NetworkCapabilities ncWifi = new NetworkCapabilities();
    NetworkCapabilities ncCell = new NetworkCapabilities();
    ncWifi.addTransportType(NetworkCapabilities.TRANSPORT_WIFI);
    ncCell.addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR);
    when(mCm.getNetworkCapabilities(new Network(100))).thenReturn(ncWifi);
    when(mCm.getNetworkCapabilities(new Network(101))).thenReturn(ncCell);
    ApfStats apfStats = new ApfStats();
    apfStats.durationMs = 45000;
    apfStats.receivedRas = 10;
    apfStats.matchingRas = 2;
    apfStats.droppedRas = 2;
    apfStats.parseErrors = 2;
    apfStats.zeroLifetimeRas = 1;
    apfStats.programUpdates = 4;
    apfStats.programUpdatesAll = 7;
    apfStats.programUpdatesAllowingMulticast = 3;
    apfStats.maxProgramSize = 2048;
    ValidationProbeEvent validationEv = new ValidationProbeEvent();
    validationEv.durationMs = 40730;
    validationEv.probeType = ValidationProbeEvent.PROBE_HTTP;
    validationEv.returnCode = 204;
    Parcelable[] events = { new IpReachabilityEvent(IpReachabilityEvent.NUD_FAILED), new DhcpClientEvent("SomeState", 192), new IpManagerEvent(IpManagerEvent.PROVISIONING_OK, 5678), validationEv, apfStats, new RaEvent(2000, 400, 300, -1, 1000, -1) };
    for (int i = 0; i < events.length; i++) {
        ConnectivityMetricsEvent ev = new ConnectivityMetricsEvent();
        ev.timestamp = 100 * (i + 1);
        ev.ifname = "wlan0";
        ev.data = events[i];
        logger.log(ev);
    }
    // netId, errno, latency, destination
    connectEvent(100, OsConstants.EALREADY, 0, EXAMPLE_IPV4);
    connectEvent(100, OsConstants.EINPROGRESS, 0, EXAMPLE_IPV6);
    connectEvent(100, 0, 110, EXAMPLE_IPV4);
    connectEvent(101, 0, 23, EXAMPLE_IPV4);
    connectEvent(101, 0, 45, EXAMPLE_IPV6);
    connectEvent(100, OsConstants.EAGAIN, 0, EXAMPLE_IPV4);
    // netId, type, return code, latency
    dnsEvent(100, EVENT_GETADDRINFO, 0, 3456);
    dnsEvent(100, EVENT_GETADDRINFO, 3, 45);
    dnsEvent(100, EVENT_GETHOSTBYNAME, 0, 638);
    dnsEvent(101, EVENT_GETADDRINFO, 0, 56);
    dnsEvent(101, EVENT_GETHOSTBYNAME, 0, 34);
    // iface, uid
    final byte[] mac = { 0x48, 0x7c, 0x2b, 0x6a, 0x3e, 0x4b };
    final String srcIp = "192.168.2.1";
    final String dstIp = "192.168.2.23";
    final int sport = 2356;
    final int dport = 13489;
    final long now = 1001L;
    final int v4 = 0x800;
    final int tcp = 6;
    final int udp = 17;
    wakeupEvent("wlan0", 1000, v4, tcp, mac, srcIp, dstIp, sport, dport, 1001L);
    wakeupEvent("wlan0", 10123, v4, tcp, mac, srcIp, dstIp, sport, dport, 1001L);
    wakeupEvent("wlan0", 1000, v4, udp, mac, srcIp, dstIp, sport, dport, 1001L);
    wakeupEvent("wlan0", 10008, v4, udp, mac, srcIp, dstIp, sport, dport, 1001L);
    wakeupEvent("wlan0", -1, v4, udp, mac, srcIp, dstIp, sport, dport, 1001L);
    wakeupEvent("wlan0", 10008, v4, tcp, mac, srcIp, dstIp, sport, dport, 1001L);
    long timeMs = mService.mDefaultNetworkMetrics.creationTimeMs;
    final long cell = BitUtils.packBits(new int[] { NetworkCapabilities.TRANSPORT_CELLULAR });
    final long wifi = BitUtils.packBits(new int[] { NetworkCapabilities.TRANSPORT_WIFI });
    NetworkAgentInfo cellNai = makeNai(100, 50, false, true, cell);
    NetworkAgentInfo wifiNai = makeNai(101, 60, true, false, wifi);
    mService.mDefaultNetworkMetrics.logDefaultNetworkEvent(timeMs + 200, cellNai, null);
    mService.mDefaultNetworkMetrics.logDefaultNetworkEvent(timeMs + 300, wifiNai, cellNai);
    String want = String.join("\n", "dropped_events: 0", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 0", "  time_ms: 100", "  transports: 0", "  ip_reachability_event <", "    event_type: 512", "    if_name: \"\"", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 0", "  time_ms: 200", "  transports: 0", "  dhcp_event <", "    duration_ms: 192", "    if_name: \"\"", "    state_transition: \"SomeState\"", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 0", "  time_ms: 300", "  transports: 0", "  ip_provisioning_event <", "    event_type: 1", "    if_name: \"\"", "    latency_ms: 5678", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 0", "  time_ms: 400", "  transports: 0", "  validation_probe_event <", "    latency_ms: 40730", "    probe_result: 204", "    probe_type: 1", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 0", "  time_ms: 500", "  transports: 0", "  apf_statistics <", "    dropped_ras: 2", "    duration_ms: 45000", "    matching_ras: 2", "    max_program_size: 2048", "    parse_errors: 2", "    program_updates: 4", "    program_updates_all: 7", "    program_updates_allowing_multicast: 3", "    received_ras: 10", "    total_packet_dropped: 0", "    total_packet_processed: 0", "    zero_lifetime_ras: 1", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 0", "  time_ms: 600", "  transports: 0", "  ra_event <", "    dnssl_lifetime: -1", "    prefix_preferred_lifetime: 300", "    prefix_valid_lifetime: 400", "    rdnss_lifetime: 1000", "    route_info_lifetime: -1", "    router_lifetime: 2000", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 5", "  network_id: 0", "  time_ms: 0", "  transports: 0", "  default_network_event <", "    default_network_duration_ms: 200", "    final_score: 0", "    initial_score: 0", "    ip_support: 0", "    no_default_network_duration_ms: 0", "    previous_default_network_link_layer: 0", "    previous_network_ip_support: 0", "    validation_duration_ms: 0", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 2", "  network_id: 100", "  time_ms: 0", "  transports: 1", "  default_network_event <", "    default_network_duration_ms: 100", "    final_score: 50", "    initial_score: 50", "    ip_support: 2", "    no_default_network_duration_ms: 0", "    previous_default_network_link_layer: 0", "    previous_network_ip_support: 0", "    validation_duration_ms: 100", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 100", "  time_ms: 0", "  transports: 2", "  connect_statistics <", "    connect_blocking_count: 1", "    connect_count: 3", "    errnos_counters <", "      key: 11", "      value: 1", "    >", "    ipv6_addr_count: 1", "    latencies_ms: 110", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 2", "  network_id: 101", "  time_ms: 0", "  transports: 1", "  connect_statistics <", "    connect_blocking_count: 2", "    connect_count: 2", "    ipv6_addr_count: 1", "    latencies_ms: 23", "    latencies_ms: 45", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 100", "  time_ms: 0", "  transports: 2", "  dns_lookup_batch <", "    event_types: 1", "    event_types: 1", "    event_types: 2", "    getaddrinfo_error_count: 0", "    getaddrinfo_query_count: 0", "    gethostbyname_error_count: 0", "    gethostbyname_query_count: 0", "    latencies_ms: 3456", "    latencies_ms: 45", "    latencies_ms: 638", "    return_codes: 0", "    return_codes: 3", "    return_codes: 0", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 2", "  network_id: 101", "  time_ms: 0", "  transports: 1", "  dns_lookup_batch <", "    event_types: 1", "    event_types: 2", "    getaddrinfo_error_count: 0", "    getaddrinfo_query_count: 0", "    gethostbyname_error_count: 0", "    gethostbyname_query_count: 0", "    latencies_ms: 56", "    latencies_ms: 34", "    return_codes: 0", "    return_codes: 0", "  >", ">", "events <", "  if_name: \"\"", "  link_layer: 4", "  network_id: 0", "  time_ms: 0", "  transports: 0", "  wakeup_stats <", "    application_wakeups: 3", "    duration_sec: 0", "    ethertype_counts <", "      key: 2048", "      value: 6", "    >", "    ip_next_header_counts <", "      key: 6", "      value: 3", "    >", "    ip_next_header_counts <", "      key: 17", "      value: 3", "    >", "    l2_broadcast_count: 0", "    l2_multicast_count: 0", "    l2_unicast_count: 6", "    no_uid_wakeups: 1", "    non_application_wakeups: 0", "    root_wakeups: 0", "    system_wakeups: 2", "    total_wakeups: 6", "  >", ">", "version: 2\n");
    verifySerialization(want, getdump("flush"));
}
#end_block

#method_before
void wakeupEvent(String iface, int uid, int ether, int ip, byte[] mac, String srcIp, String dstIp, int sport, int dport, long now) throws Exception {
    String prefix = NetdEventListenerService.WAKEUP_EVENT_IFACE_PREFIX + iface;
    mNetdListener.onWakeupEvent(prefix, uid, uid, ether, ip, mac, srcIp, dstIp, sport, dport, now);
}
#method_after
void wakeupEvent(String iface, int uid, int ether, int ip, byte[] mac, String srcIp, String dstIp, int sport, int dport, long now) throws Exception {
    String prefix = NetdEventListenerService.WAKEUP_EVENT_IFACE_PREFIX + iface;
    mNetdListener.onWakeupEvent(prefix, uid, ether, ip, mac, srcIp, dstIp, sport, dport, now);
}
#end_block

#method_before
private void sendDisconnectInd(int discType) {
    if (VERBOSE)
        Log.v(TAG, "in sendDisconnectInd()");
    if (discType != SapMessage.DISC_FORCED) {
        if (VERBOSE)
            Log.d(TAG, "Sending  disconnect (" + discType + ") indication to client");
        /* Send disconnect to client */
        SapMessage discInd = new SapMessage(SapMessage.ID_DISCONNECT_IND);
        discInd.setDisconnectionType(discType);
        sendClientMessage(discInd);
        /* Handle local disconnect procedures */
        if (discType == SapMessage.DISC_GRACEFULL) {
            /* Update the notification to allow the user to initiate a force disconnect */
            setNotification(SapMessage.DISC_IMMEDIATE, PendingIntent.FLAG_CANCEL_CURRENT);
        } else if (discType == SapMessage.DISC_IMMEDIATE) {
            /* Request an immediate disconnect, but start a timer to force disconnect if the
                 * client do not obey our request. */
            startDisconnectTimer(SapMessage.DISC_FORCED, DISCONNECT_TIMEOUT_IMMEDIATE);
        }
    } else {
        SapMessage msg = new SapMessage(SapMessage.ID_DISCONNECT_REQ);
        /* Force disconnect of RFCOMM - but first we need to clean up. */
        clearPendingRilResponses(msg);
        /* We simply need to forward to RIL, but not change state to busy - hence send and set
               message to null. */
        changeState(SAP_STATE.DISCONNECTING);
        sendRilThreadMessage(msg);
        mIsLocalInitDisconnect = true;
    }
}
#method_after
private void sendDisconnectInd(int discType) {
    if (VERBOSE) {
        Log.v(TAG, "in sendDisconnectInd()");
    }
    if (discType != SapMessage.DISC_FORCED) {
        if (VERBOSE) {
            Log.d(TAG, "Sending  disconnect (" + discType + ") indication to client");
        }
        /* Send disconnect to client */
        SapMessage discInd = new SapMessage(SapMessage.ID_DISCONNECT_IND);
        discInd.setDisconnectionType(discType);
        sendClientMessage(discInd);
        /* Handle local disconnect procedures */
        if (discType == SapMessage.DISC_GRACEFULL) {
            /* Update the notification to allow the user to initiate a force disconnect */
            setNotification(SapMessage.DISC_IMMEDIATE, PendingIntent.FLAG_CANCEL_CURRENT);
        } else if (discType == SapMessage.DISC_IMMEDIATE) {
            /* Request an immediate disconnect, but start a timer to force disconnect if the
                 * client do not obey our request. */
            startDisconnectTimer(SapMessage.DISC_FORCED, DISCONNECT_TIMEOUT_IMMEDIATE);
        }
    } else {
        SapMessage msg = new SapMessage(SapMessage.ID_DISCONNECT_REQ);
        /* Force disconnect of RFCOMM - but first we need to clean up. */
        clearPendingRilResponses(msg);
        /* We simply need to forward to RIL, but not change state to busy - hence send and set
               message to null. */
        changeState(SAP_STATE.DISCONNECTING);
        sendRilThreadMessage(msg);
        mIsLocalInitDisconnect = true;
    }
}
#end_block

#method_before
void setNotification(int type, int flags) {
    String title, text, button, ticker;
    Notification notification;
    if (VERBOSE)
        Log.i(TAG, "setNotification type: " + type);
    /* For PTS TC_SERVER_DCN_BV_03_I we need to expose the option to send immediate disconnect
         * without first sending a graceful disconnect.
         * To enable this option set
         * bt.sap.pts="true" */
    String pts_enabled = SystemProperties.get("bt.sap.pts");
    Boolean pts_test = Boolean.parseBoolean(pts_enabled);
    /* put notification up for the user to be able to disconnect from the client*/
    Intent sapDisconnectIntent = new Intent(SapServer.SAP_DISCONNECT_ACTION);
    if (type == SapMessage.DISC_GRACEFULL) {
        title = mContext.getString(R.string.bluetooth_sap_notif_title);
        button = mContext.getString(R.string.bluetooth_sap_notif_disconnect_button);
        text = mContext.getString(R.string.bluetooth_sap_notif_message);
        ticker = mContext.getString(R.string.bluetooth_sap_notif_ticker);
    } else {
        title = mContext.getString(R.string.bluetooth_sap_notif_title);
        button = mContext.getString(R.string.bluetooth_sap_notif_force_disconnect_button);
        text = mContext.getString(R.string.bluetooth_sap_notif_disconnecting);
        ticker = mContext.getString(R.string.bluetooth_sap_notif_ticker);
    }
    if (!pts_test) {
        sapDisconnectIntent.putExtra(SapServer.SAP_DISCONNECT_TYPE_EXTRA, type);
        PendingIntent pIntentDisconnect = PendingIntent.getBroadcast(mContext, type, sapDisconnectIntent, flags);
        notification = new Notification.Builder(mContext).setOngoing(true).addAction(android.R.drawable.stat_sys_data_bluetooth, button, pIntentDisconnect).setContentTitle(title).setTicker(ticker).setContentText(text).setSmallIcon(android.R.drawable.stat_sys_data_bluetooth).setAutoCancel(false).setPriority(Notification.PRIORITY_MAX).setOnlyAlertOnce(true).build();
    } else {
        sapDisconnectIntent.putExtra(SapServer.SAP_DISCONNECT_TYPE_EXTRA, SapMessage.DISC_GRACEFULL);
        Intent sapForceDisconnectIntent = new Intent(SapServer.SAP_DISCONNECT_ACTION);
        sapForceDisconnectIntent.putExtra(SapServer.SAP_DISCONNECT_TYPE_EXTRA, SapMessage.DISC_IMMEDIATE);
        PendingIntent pIntentDisconnect = PendingIntent.getBroadcast(mContext, SapMessage.DISC_GRACEFULL, sapDisconnectIntent, flags);
        PendingIntent pIntentForceDisconnect = PendingIntent.getBroadcast(mContext, SapMessage.DISC_IMMEDIATE, sapForceDisconnectIntent, flags);
        notification = new Notification.Builder(mContext).setOngoing(true).addAction(android.R.drawable.stat_sys_data_bluetooth, mContext.getString(R.string.bluetooth_sap_notif_disconnect_button), pIntentDisconnect).addAction(android.R.drawable.stat_sys_data_bluetooth, mContext.getString(R.string.bluetooth_sap_notif_force_disconnect_button), pIntentForceDisconnect).setContentTitle(title).setTicker(ticker).setContentText(text).setSmallIcon(android.R.drawable.stat_sys_data_bluetooth).setAutoCancel(false).setPriority(Notification.PRIORITY_MAX).setOnlyAlertOnce(true).build();
    }
    // cannot be set with the builder
    notification.flags |= Notification.FLAG_NO_CLEAR | Notification.FLAG_ONLY_ALERT_ONCE;
    NotificationManager notificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    notificationManager.notify(NOTIFICATION_ID, notification);
}
#method_after
void setNotification(int type, int flags) {
    String title, text, button, ticker;
    Notification notification;
    NotificationManager notificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    NotificationChannel notificationChannel = new NotificationChannel(SAP_NOTIFICATION_CHANNEL, mContext.getString(R.string.bluetooth_sap_notif_title), NotificationManager.IMPORTANCE_HIGH);
    notificationManager.createNotificationChannel(notificationChannel);
    if (VERBOSE) {
        Log.i(TAG, "setNotification type: " + type);
    }
    /* For PTS TC_SERVER_DCN_BV_03_I we need to expose the option to send immediate disconnect
         * without first sending a graceful disconnect.
         * To enable this option set
         * bt.sap.pts="true" */
    String ptsEnabled = SystemProperties.get("bt.sap.pts");
    Boolean ptsTest = Boolean.parseBoolean(ptsEnabled);
    /* put notification up for the user to be able to disconnect from the client*/
    Intent sapDisconnectIntent = new Intent(SapServer.SAP_DISCONNECT_ACTION);
    if (type == SapMessage.DISC_GRACEFULL) {
        title = mContext.getString(R.string.bluetooth_sap_notif_title);
        button = mContext.getString(R.string.bluetooth_sap_notif_disconnect_button);
        text = mContext.getString(R.string.bluetooth_sap_notif_message);
        ticker = mContext.getString(R.string.bluetooth_sap_notif_ticker);
    } else {
        title = mContext.getString(R.string.bluetooth_sap_notif_title);
        button = mContext.getString(R.string.bluetooth_sap_notif_force_disconnect_button);
        text = mContext.getString(R.string.bluetooth_sap_notif_disconnecting);
        ticker = mContext.getString(R.string.bluetooth_sap_notif_ticker);
    }
    if (!ptsTest) {
        sapDisconnectIntent.putExtra(SapServer.SAP_DISCONNECT_TYPE_EXTRA, type);
        PendingIntent pIntentDisconnect = PendingIntent.getBroadcast(mContext, type, sapDisconnectIntent, flags);
        notification = new Notification.Builder(mContext, SAP_NOTIFICATION_CHANNEL).setOngoing(true).addAction(android.R.drawable.stat_sys_data_bluetooth, button, pIntentDisconnect).setContentTitle(title).setTicker(ticker).setContentText(text).setSmallIcon(android.R.drawable.stat_sys_data_bluetooth).setAutoCancel(false).setPriority(Notification.PRIORITY_MAX).setOnlyAlertOnce(true).build();
    } else {
        sapDisconnectIntent.putExtra(SapServer.SAP_DISCONNECT_TYPE_EXTRA, SapMessage.DISC_GRACEFULL);
        Intent sapForceDisconnectIntent = new Intent(SapServer.SAP_DISCONNECT_ACTION);
        sapForceDisconnectIntent.putExtra(SapServer.SAP_DISCONNECT_TYPE_EXTRA, SapMessage.DISC_IMMEDIATE);
        PendingIntent pIntentDisconnect = PendingIntent.getBroadcast(mContext, SapMessage.DISC_GRACEFULL, sapDisconnectIntent, flags);
        PendingIntent pIntentForceDisconnect = PendingIntent.getBroadcast(mContext, SapMessage.DISC_IMMEDIATE, sapForceDisconnectIntent, flags);
        notification = new Notification.Builder(mContext, SAP_NOTIFICATION_CHANNEL).setOngoing(true).addAction(android.R.drawable.stat_sys_data_bluetooth, mContext.getString(R.string.bluetooth_sap_notif_disconnect_button), pIntentDisconnect).addAction(android.R.drawable.stat_sys_data_bluetooth, mContext.getString(R.string.bluetooth_sap_notif_force_disconnect_button), pIntentForceDisconnect).setContentTitle(title).setTicker(ticker).setContentText(text).setSmallIcon(android.R.drawable.stat_sys_data_bluetooth).setAutoCancel(false).setPriority(Notification.PRIORITY_MAX).setOnlyAlertOnce(true).build();
    }
    // cannot be set with the builder
    notification.flags |= Notification.FLAG_NO_CLEAR | Notification.FLAG_ONLY_ALERT_ONCE;
    notificationManager.notify(NOTIFICATION_ID, notification);
}
#end_block

#method_before
@Override
public void run() {
    try {
        /* SAP is not time critical, hence lowering priority to ensure critical tasks are
             * executed in a timely manner. */
        android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
        /* Start the SAP message handler thread */
        mHandlerThread = new HandlerThread("SapServerHandler", android.os.Process.THREAD_PRIORITY_BACKGROUND);
        mHandlerThread.start();
        // This will return when the looper is ready
        Looper sapLooper = mHandlerThread.getLooper();
        mSapHandler = new Handler(sapLooper, this);
        mRilBtReceiver = new SapRilReceiver(mSapHandler, mSapServiceHandler);
        boolean done = false;
        while (!done) {
            if (VERBOSE)
                Log.i(TAG, "Waiting for incomming RFCOMM message...");
            int requestType = mRfcommIn.read();
            if (VERBOSE)
                Log.i(TAG, "RFCOMM message read...");
            if (requestType == -1) {
                if (VERBOSE)
                    Log.i(TAG, "requestType == -1");
                // EOF reached
                done = true;
            } else {
                if (VERBOSE)
                    Log.i(TAG, "requestType != -1");
                SapMessage msg = SapMessage.readMessage(requestType, mRfcommIn);
                /* notify about an incoming message from the BT Client */
                SapService.notifyUpdateWakeLock(mSapServiceHandler);
                if (msg != null && mState != SAP_STATE.DISCONNECTING) {
                    switch(requestType) {
                        case SapMessage.ID_CONNECT_REQ:
                            if (VERBOSE)
                                Log.d(TAG, "CONNECT_REQ - MaxMsgSize: " + msg.getMaxMsgSize());
                            onConnectRequest(msg);
                            msg = null;
                            /* don't send ril connect yet */
                            break;
                        case SapMessage.ID_DISCONNECT_REQ:
                            /*
                             * 1) send RIL_REQUEST_SIM_SAP_DISCONNECT
                             *      (block for all incoming requests, as they are not
                             *       allowed, don't even send an error_resp)
                             * 2) on response disconnect ril socket.
                             * 3) when disconnected send RIL.ACTION_RIL_RECONNECT_OFF_REQ
                             * 4) on RIL.ACTION_RIL_RECONNECT_CFM
                             *       send SAP_DISCONNECT_RESP to client.
                             * 5) Start RFCOMM disconnect timer
                             * 6.a) on rfcomm disconnect:
                             *       cancel timer and initiate cleanup
                             * 6.b) on rfcomm disc. timeout:
                             *       close socket-streams and initiate cleanup */
                            if (VERBOSE)
                                Log.d(TAG, "DISCONNECT_REQ");
                            if (mState == SAP_STATE.CONNECTING_CALL_ONGOING) {
                                Log.d(TAG, "disconnect received when call was ongoing, " + "send disconnect response");
                                changeState(SAP_STATE.DISCONNECTING);
                                SapMessage reply = new SapMessage(SapMessage.ID_DISCONNECT_RESP);
                                sendClientMessage(reply);
                            } else {
                                clearPendingRilResponses(msg);
                                changeState(SAP_STATE.DISCONNECTING);
                                sendRilThreadMessage(msg);
                                /*cancel the timer for the hard-disconnect intent*/
                                stopDisconnectTimer();
                            }
                            // No message needs to be sent to RIL
                            msg = null;
                            break;
                        // Fall through
                        case SapMessage.ID_POWER_SIM_OFF_REQ:
                        case SapMessage.ID_RESET_SIM_REQ:
                            /* Forward these to the RIL regardless of the state, and clear any
                             * pending resp */
                            clearPendingRilResponses(msg);
                            break;
                        case SapMessage.ID_SET_TRANSPORT_PROTOCOL_REQ:
                            /* The RIL might support more protocols that specified in the SAP,
                             * allow only the valid values. */
                            if (mState == SAP_STATE.CONNECTED && msg.getTransportProtocol() != 0 && msg.getTransportProtocol() != 1) {
                                Log.w(TAG, "Invalid TransportProtocol received:" + msg.getTransportProtocol());
                                // We shall only handle one request at the time, hence return error
                                SapMessage errorReply = new SapMessage(SapMessage.ID_ERROR_RESP);
                                sendClientMessage(errorReply);
                                msg = null;
                            }
                        // Fall through
                        default:
                            /* Remaining cases just needs to be forwarded to the RIL unless we are
                             * in busy state. */
                            if (mState != SAP_STATE.CONNECTED) {
                                Log.w(TAG, "Message received in STATE != CONNECTED - state = " + mState.name());
                                // We shall only handle one request at the time, hence return error
                                SapMessage errorReply = new SapMessage(SapMessage.ID_ERROR_RESP);
                                sendClientMessage(errorReply);
                                msg = null;
                            }
                    }
                    if (msg != null && msg.getSendToRil() == true) {
                        changeState(SAP_STATE.CONNECTED_BUSY);
                        sendRilThreadMessage(msg);
                    }
                } else {
                    // An unknown message or in disconnecting state - send error indication
                    Log.e(TAG, "Unable to parse message.");
                    SapMessage atrReply = new SapMessage(SapMessage.ID_ERROR_RESP);
                    sendClientMessage(atrReply);
                }
            }
        }
    // end while
    } catch (NullPointerException e) {
        Log.w(TAG, e);
    } catch (IOException e) {
        /* This is expected during shutdown */
        Log.i(TAG, "IOException received, this is probably a shutdown signal, cleaning up...");
    } catch (Exception e) {
        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        int state = (adapter != null) ? adapter.getState() : -1;
        if (DEBUG)
            Log.d(TAG, "BT State :" + state);
        if (state != BluetoothAdapter.STATE_ON) {
            mDeinitSignal.countDown();
        }
        /* TODO: Change to the needed Exception types when done testing */
        Log.w(TAG, e);
    } finally {
        // Do cleanup even if an exception occurs
        stopDisconnectTimer();
        /* In case of e.g. a RFCOMM close while connected:
             *        - Initiate a FORCED shutdown
             *        - Wait for RIL deinit to complete
             */
        if (mState == SAP_STATE.CONNECTING_CALL_ONGOING) {
            /* Most likely remote device closed rfcomm, update state */
            changeState(SAP_STATE.DISCONNECTED);
        } else if (mState != SAP_STATE.DISCONNECTED) {
            if (mState != SAP_STATE.DISCONNECTING && mIsLocalInitDisconnect != true) {
                sendDisconnectInd(SapMessage.DISC_FORCED);
            }
            if (DEBUG)
                Log.i(TAG, "Waiting for deinit to complete");
            try {
                mDeinitSignal.await();
            } catch (InterruptedException e) {
                Log.e(TAG, "Interrupt received while waitinf for de-init to complete", e);
            }
        }
        if (mIntentReceiver != null) {
            mContext.unregisterReceiver(mIntentReceiver);
            mIntentReceiver = null;
        }
        stopDisconnectTimer();
        clearNotification();
        if (mHandlerThread != null)
            try {
                mHandlerThread.quit();
                mHandlerThread.join();
                mHandlerThread = null;
            } catch (InterruptedException e) {
            }
        if (mRilBtReceiver != null) {
            mRilBtReceiver.resetSapProxy();
            mRilBtReceiver = null;
        }
        if (mRfcommIn != null)
            try {
                if (VERBOSE)
                    Log.i(TAG, "Closing mRfcommIn...");
                mRfcommIn.close();
                mRfcommIn = null;
            } catch (IOException e) {
            }
        if (mRfcommOut != null)
            try {
                if (VERBOSE)
                    Log.i(TAG, "Closing mRfcommOut...");
                mRfcommOut.close();
                mRfcommOut = null;
            } catch (IOException e) {
            }
        if (mSapServiceHandler != null) {
            Message msg = Message.obtain(mSapServiceHandler);
            msg.what = SapService.MSG_SERVERSESSION_CLOSE;
            msg.sendToTarget();
            if (DEBUG)
                Log.d(TAG, "MSG_SERVERSESSION_CLOSE sent out.");
        }
        Log.i(TAG, "All done exiting thread...");
    }
}
#method_after
@Override
public void run() {
    try {
        /* SAP is not time critical, hence lowering priority to ensure critical tasks are
             * executed in a timely manner. */
        android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
        /* Start the SAP message handler thread */
        mHandlerThread = new HandlerThread("SapServerHandler", android.os.Process.THREAD_PRIORITY_BACKGROUND);
        mHandlerThread.start();
        // This will return when the looper is ready
        Looper sapLooper = mHandlerThread.getLooper();
        mSapHandler = new Handler(sapLooper, this);
        mRilBtReceiver = new SapRilReceiver(mSapHandler, mSapServiceHandler);
        boolean done = false;
        while (!done) {
            if (VERBOSE) {
                Log.i(TAG, "Waiting for incomming RFCOMM message...");
            }
            int requestType = mRfcommIn.read();
            if (VERBOSE) {
                Log.i(TAG, "RFCOMM message read...");
            }
            if (requestType == -1) {
                if (VERBOSE) {
                    Log.i(TAG, "requestType == -1");
                }
                // EOF reached
                done = true;
            } else {
                if (VERBOSE) {
                    Log.i(TAG, "requestType != -1");
                }
                SapMessage msg = SapMessage.readMessage(requestType, mRfcommIn);
                /* notify about an incoming message from the BT Client */
                SapService.notifyUpdateWakeLock(mSapServiceHandler);
                if (msg != null && mState != SAP_STATE.DISCONNECTING) {
                    switch(requestType) {
                        case SapMessage.ID_CONNECT_REQ:
                            if (VERBOSE) {
                                Log.d(TAG, "CONNECT_REQ - MaxMsgSize: " + msg.getMaxMsgSize());
                            }
                            onConnectRequest(msg);
                            msg = null;
                            /* don't send ril connect yet */
                            break;
                        case SapMessage.ID_DISCONNECT_REQ:
                            /*
                             * 1) send RIL_REQUEST_SIM_SAP_DISCONNECT
                             *      (block for all incoming requests, as they are not
                             *       allowed, don't even send an error_resp)
                             * 2) on response disconnect ril socket.
                             * 3) when disconnected send RIL.ACTION_RIL_RECONNECT_OFF_REQ
                             * 4) on RIL.ACTION_RIL_RECONNECT_CFM
                             *       send SAP_DISCONNECT_RESP to client.
                             * 5) Start RFCOMM disconnect timer
                             * 6.a) on rfcomm disconnect:
                             *       cancel timer and initiate cleanup
                             * 6.b) on rfcomm disc. timeout:
                             *       close socket-streams and initiate cleanup */
                            if (VERBOSE) {
                                Log.d(TAG, "DISCONNECT_REQ");
                            }
                            if (mState == SAP_STATE.CONNECTING_CALL_ONGOING) {
                                Log.d(TAG, "disconnect received when call was ongoing, " + "send disconnect response");
                                changeState(SAP_STATE.DISCONNECTING);
                                SapMessage reply = new SapMessage(SapMessage.ID_DISCONNECT_RESP);
                                sendClientMessage(reply);
                            } else {
                                clearPendingRilResponses(msg);
                                changeState(SAP_STATE.DISCONNECTING);
                                sendRilThreadMessage(msg);
                                /*cancel the timer for the hard-disconnect intent*/
                                stopDisconnectTimer();
                            }
                            // No message needs to be sent to RIL
                            msg = null;
                            break;
                        // Fall through
                        case SapMessage.ID_POWER_SIM_OFF_REQ:
                        case SapMessage.ID_RESET_SIM_REQ:
                            /* Forward these to the RIL regardless of the state, and clear any
                             * pending resp */
                            clearPendingRilResponses(msg);
                            break;
                        case SapMessage.ID_SET_TRANSPORT_PROTOCOL_REQ:
                            /* The RIL might support more protocols that specified in the SAP,
                             * allow only the valid values. */
                            if (mState == SAP_STATE.CONNECTED && msg.getTransportProtocol() != 0 && msg.getTransportProtocol() != 1) {
                                Log.w(TAG, "Invalid TransportProtocol received:" + msg.getTransportProtocol());
                                // We shall only handle one request at the time, hence return
                                // error
                                SapMessage errorReply = new SapMessage(SapMessage.ID_ERROR_RESP);
                                sendClientMessage(errorReply);
                                msg = null;
                            }
                        // Fall through
                        default:
                            /* Remaining cases just needs to be forwarded to the RIL unless we are
                             * in busy state. */
                            if (mState != SAP_STATE.CONNECTED) {
                                Log.w(TAG, "Message received in STATE != CONNECTED - state = " + mState.name());
                                // We shall only handle one request at the time, hence return
                                // error
                                SapMessage errorReply = new SapMessage(SapMessage.ID_ERROR_RESP);
                                sendClientMessage(errorReply);
                                msg = null;
                            }
                    }
                    if (msg != null && msg.getSendToRil()) {
                        changeState(SAP_STATE.CONNECTED_BUSY);
                        sendRilThreadMessage(msg);
                    }
                } else {
                    // An unknown message or in disconnecting state - send error indication
                    Log.e(TAG, "Unable to parse message.");
                    SapMessage atrReply = new SapMessage(SapMessage.ID_ERROR_RESP);
                    sendClientMessage(atrReply);
                }
            }
        }
    // end while
    } catch (NullPointerException e) {
        Log.w(TAG, e);
    } catch (IOException e) {
        /* This is expected during shutdown */
        Log.i(TAG, "IOException received, this is probably a shutdown signal, cleaning up...");
    } catch (Exception e) {
        /* TODO: Change to the needed Exception types when done testing */
        Log.w(TAG, e);
    } finally {
        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        int state = (adapter != null) ? adapter.getState() : -1;
        if (state != BluetoothAdapter.STATE_ON) {
            if (DEBUG)
                Log.d(TAG, "BT State :" + state);
            mDeinitSignal.countDown();
        }
        // Do cleanup even if an exception occurs
        stopDisconnectTimer();
        /* In case of e.g. a RFCOMM close while connected:
             *        - Initiate a FORCED shutdown
             *        - Wait for RIL deinit to complete
             */
        if (mState == SAP_STATE.CONNECTING_CALL_ONGOING) {
            /* Most likely remote device closed rfcomm, update state */
            changeState(SAP_STATE.DISCONNECTED);
        } else if (mState != SAP_STATE.DISCONNECTED) {
            if (mState != SAP_STATE.DISCONNECTING && !mIsLocalInitDisconnect) {
                sendDisconnectInd(SapMessage.DISC_FORCED);
            }
            if (DEBUG) {
                Log.i(TAG, "Waiting for deinit to complete");
            }
            try {
                mDeinitSignal.await();
            } catch (InterruptedException e) {
                Log.e(TAG, "Interrupt received while waitinf for de-init to complete", e);
            }
        }
        if (mIntentReceiver != null) {
            mContext.unregisterReceiver(mIntentReceiver);
            mIntentReceiver = null;
        }
        stopDisconnectTimer();
        clearNotification();
        if (mHandlerThread != null) {
            try {
                mHandlerThread.quit();
                mHandlerThread.join();
                mHandlerThread = null;
            } catch (InterruptedException e) {
            }
        }
        if (mRilBtReceiver != null) {
            mRilBtReceiver.resetSapProxy();
            mRilBtReceiver = null;
        }
        if (mRfcommIn != null) {
            try {
                if (VERBOSE) {
                    Log.i(TAG, "Closing mRfcommIn...");
                }
                mRfcommIn.close();
                mRfcommIn = null;
            } catch (IOException e) {
            }
        }
        if (mRfcommOut != null) {
            try {
                if (VERBOSE) {
                    Log.i(TAG, "Closing mRfcommOut...");
                }
                mRfcommOut.close();
                mRfcommOut = null;
            } catch (IOException e) {
            }
        }
        if (mSapServiceHandler != null) {
            Message msg = Message.obtain(mSapServiceHandler);
            msg.what = SapService.MSG_SERVERSESSION_CLOSE;
            msg.sendToTarget();
            if (DEBUG) {
                Log.d(TAG, "MSG_SERVERSESSION_CLOSE sent out.");
            }
        }
        Log.i(TAG, "All done exiting thread...");
    }
}
#end_block

#method_before
private void onConnectRequest(SapMessage msg) {
    SapMessage reply = new SapMessage(SapMessage.ID_CONNECT_RESP);
    if (mState == SAP_STATE.CONNECTING) {
        /* A connect request might have been rejected because of maxMessageSize negotiation, and
             * this is a new connect request. Simply forward to RIL, and stay in connecting state.
             * */
        reply = null;
        sendRilMessage(msg);
        stopDisconnectTimer();
    } else if (mState != SAP_STATE.DISCONNECTED && mState != SAP_STATE.CONNECTING_CALL_ONGOING) {
        reply.setConnectionStatus(SapMessage.CON_STATUS_ERROR_CONNECTION);
    } else {
        // Store the MaxMsgSize for future use
        mMaxMsgSize = msg.getMaxMsgSize();
        // All parameters OK, examine if a call is ongoing and start the RIL-BT listener thread
        if (isCallOngoing() == true) {
            /* If a call is ongoing we set the state, inform the SAP client and wait for a state
                 * change intent from the TelephonyManager with state IDLE. */
            reply.setConnectionStatus(SapMessage.CON_STATUS_OK_ONGOING_CALL);
        } else {
            /* no call is ongoing, initiate the connect sequence:
                 *  1) Start the SapRilReceiver thread (open the rild-bt socket)
                 *  2) Send a RIL_SIM_SAP_CONNECT request to RILD
                 *  3) Send a RIL_SIM_RESET request and a connect confirm to the SAP client */
            changeState(SAP_STATE.CONNECTING);
            if (mRilBtReceiver != null) {
                // Notify the SapServer that we have connected to the SAP service
                mRilBtReceiver.sendRilConnectMessage();
                // Don't send reply yet
                reply = null;
            } else {
                reply = new SapMessage(SapMessage.ID_CONNECT_RESP);
                reply.setConnectionStatus(SapMessage.CON_STATUS_ERROR_CONNECTION);
                sendClientMessage(reply);
            }
        }
    }
    if (reply != null)
        sendClientMessage(reply);
}
#method_after
private void onConnectRequest(SapMessage msg) {
    SapMessage reply = new SapMessage(SapMessage.ID_CONNECT_RESP);
    if (mState == SAP_STATE.CONNECTING) {
        /* A connect request might have been rejected because of maxMessageSize negotiation, and
             * this is a new connect request. Simply forward to RIL, and stay in connecting state.
             * */
        reply = null;
        sendRilMessage(msg);
        stopDisconnectTimer();
    } else if (mState != SAP_STATE.DISCONNECTED && mState != SAP_STATE.CONNECTING_CALL_ONGOING) {
        reply.setConnectionStatus(SapMessage.CON_STATUS_ERROR_CONNECTION);
    } else {
        // Store the MaxMsgSize for future use
        mMaxMsgSize = msg.getMaxMsgSize();
        // All parameters OK, examine if a call is ongoing and start the RIL-BT listener thread
        if (isCallOngoing()) {
            /* If a call is ongoing we set the state, inform the SAP client and wait for a state
                 * change intent from the TelephonyManager with state IDLE. */
            reply.setConnectionStatus(SapMessage.CON_STATUS_OK_ONGOING_CALL);
        } else {
            /* no call is ongoing, initiate the connect sequence:
                 *  1) Start the SapRilReceiver thread (open the rild-bt socket)
                 *  2) Send a RIL_SIM_SAP_CONNECT request to RILD
                 *  3) Send a RIL_SIM_RESET request and a connect confirm to the SAP client */
            changeState(SAP_STATE.CONNECTING);
            if (mRilBtReceiver != null) {
                // Notify the SapServer that we have connected to the SAP service
                mRilBtReceiver.sendRilConnectMessage();
                // Don't send reply yet
                reply = null;
            } else {
                reply = new SapMessage(SapMessage.ID_CONNECT_RESP);
                reply.setConnectionStatus(SapMessage.CON_STATUS_ERROR_CONNECTION);
                sendClientMessage(reply);
            }
        }
    }
    if (reply != null) {
        sendClientMessage(reply);
    }
}
#end_block

#method_before
private void changeState(SAP_STATE newState) {
    if (DEBUG)
        Log.i(TAG_HANDLER, "Changing state from " + mState.name() + " to " + newState.name());
    synchronized (this) {
        mState = newState;
    }
}
#method_after
private void changeState(SAP_STATE newState) {
    if (DEBUG) {
        Log.i(TAG_HANDLER, "Changing state from " + mState.name() + " to " + newState.name());
    }
    synchronized (this) {
        mState = newState;
    }
}
#end_block

#method_before
/**
 * **********************************************************************
 *  SAP Server Message Handler Thread Functions
 * ***********************************************************************
 */
@Override
public boolean handleMessage(Message msg) {
    if (VERBOSE)
        Log.i(TAG_HANDLER, "Handling message (ID: " + msg.what + "): " + getMessageName(msg.what));
    SapMessage sapMsg = null;
    switch(msg.what) {
        case SAP_MSG_RFC_REPLY:
            sapMsg = (SapMessage) msg.obj;
            handleRfcommReply(sapMsg);
            break;
        case SAP_MSG_RIL_CONNECT:
            /* The connection to rild-bt have been established. Store the outStream handle
             * and send the connect request. */
            if (mTestMode != SapMessage.INVALID_VALUE) {
                SapMessage rilTestModeReq = new SapMessage(SapMessage.ID_RIL_SIM_ACCESS_TEST_REQ);
                rilTestModeReq.setTestMode(mTestMode);
                sendRilMessage(rilTestModeReq);
                mTestMode = SapMessage.INVALID_VALUE;
            }
            SapMessage rilSapConnect = new SapMessage(SapMessage.ID_CONNECT_REQ);
            rilSapConnect.setMaxMsgSize(mMaxMsgSize);
            sendRilMessage(rilSapConnect);
            break;
        case SAP_MSG_RIL_REQ:
            sapMsg = (SapMessage) msg.obj;
            if (sapMsg != null) {
                sendRilMessage(sapMsg);
            }
            break;
        case SAP_MSG_RIL_IND:
            sapMsg = (SapMessage) msg.obj;
            handleRilInd(sapMsg);
            break;
        case SAP_RIL_SOCK_CLOSED:
            /* The RIL socket was closed unexpectedly, send immediate disconnect indication
               - close RFCOMM after timeout if no response. */
            sendDisconnectInd(SapMessage.DISC_IMMEDIATE);
            startDisconnectTimer(SapMessage.DISC_RFCOMM, DISCONNECT_TIMEOUT_RFCOMM);
            break;
        case SAP_PROXY_DEAD:
            if ((long) msg.obj == mRilBtReceiver.mSapProxyCookie.get()) {
                mRilBtReceiver.notifyShutdown();
                /* Only needed in case of a connection error */
                mRilBtReceiver.resetSapProxy();
                // todo: rild should be back up since message was sent with a delay. this is a hack.
                mRilBtReceiver.getSapProxy();
            }
        default:
            /* Message not handled */
            return false;
    }
    // Message handles
    return true;
}
#method_after
/**
 * **********************************************************************
 *  SAP Server Message Handler Thread Functions
 * ***********************************************************************
 */
@Override
public boolean handleMessage(Message msg) {
    if (VERBOSE) {
        Log.i(TAG_HANDLER, "Handling message (ID: " + msg.what + "): " + getMessageName(msg.what));
    }
    SapMessage sapMsg = null;
    switch(msg.what) {
        case SAP_MSG_RFC_REPLY:
            sapMsg = (SapMessage) msg.obj;
            handleRfcommReply(sapMsg);
            break;
        case SAP_MSG_RIL_CONNECT:
            /* The connection to rild-bt have been established. Store the outStream handle
             * and send the connect request. */
            if (mTestMode != SapMessage.INVALID_VALUE) {
                SapMessage rilTestModeReq = new SapMessage(SapMessage.ID_RIL_SIM_ACCESS_TEST_REQ);
                rilTestModeReq.setTestMode(mTestMode);
                sendRilMessage(rilTestModeReq);
                mTestMode = SapMessage.INVALID_VALUE;
            }
            SapMessage rilSapConnect = new SapMessage(SapMessage.ID_CONNECT_REQ);
            rilSapConnect.setMaxMsgSize(mMaxMsgSize);
            sendRilMessage(rilSapConnect);
            break;
        case SAP_MSG_RIL_REQ:
            sapMsg = (SapMessage) msg.obj;
            if (sapMsg != null) {
                sendRilMessage(sapMsg);
            }
            break;
        case SAP_MSG_RIL_IND:
            sapMsg = (SapMessage) msg.obj;
            handleRilInd(sapMsg);
            break;
        case SAP_RIL_SOCK_CLOSED:
            /* The RIL socket was closed unexpectedly, send immediate disconnect indication
               - close RFCOMM after timeout if no response. */
            startDisconnectTimer(SapMessage.DISC_RFCOMM, DISCONNECT_TIMEOUT_RFCOMM);
            break;
        case SAP_PROXY_DEAD:
            if ((long) msg.obj == mRilBtReceiver.mSapProxyCookie.get()) {
                mRilBtReceiver.notifyShutdown();
                /* Only needed in case of a connection error */
                mRilBtReceiver.resetSapProxy();
                // todo: rild should be back up since message was sent with a delay. this is
                // a hack.
                mRilBtReceiver.getSapProxy();
            }
            break;
        default:
            /* Message not handled */
            return false;
    }
    // Message handles
    return true;
}
#end_block

#method_before
private void shutdown() {
    if (DEBUG)
        Log.i(TAG_HANDLER, "in Shutdown()");
    try {
        if (mRfcommOut != null)
            mRfcommOut.close();
    } catch (IOException e) {
    }
    try {
        if (mRfcommIn != null)
            mRfcommIn.close();
    } catch (IOException e) {
    }
    mRfcommIn = null;
    mRfcommOut = null;
    stopDisconnectTimer();
    clearNotification();
}
#method_after
private void shutdown() {
    if (DEBUG) {
        Log.i(TAG_HANDLER, "in Shutdown()");
    }
    try {
        if (mRfcommOut != null) {
            mRfcommOut.close();
        }
    } catch (IOException e) {
    }
    try {
        if (mRfcommIn != null) {
            mRfcommIn.close();
        }
    } catch (IOException e) {
    }
    mRfcommIn = null;
    mRfcommOut = null;
    stopDisconnectTimer();
    clearNotification();
}
#end_block

#method_before
private void startDisconnectTimer(int discType, int timeMs) {
    stopDisconnectTimer();
    synchronized (this) {
        Intent sapDisconnectIntent = new Intent(SapServer.SAP_DISCONNECT_ACTION);
        sapDisconnectIntent.putExtra(SAP_DISCONNECT_TYPE_EXTRA, discType);
        AlarmManager alarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
        pDiscIntent = PendingIntent.getBroadcast(mContext, discType, sapDisconnectIntent, PendingIntent.FLAG_CANCEL_CURRENT);
        alarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + timeMs, pDiscIntent);
        if (VERBOSE)
            Log.d(TAG_HANDLER, "Setting alarm for " + timeMs + " ms to activate disconnect type " + discType);
    }
}
#method_after
private void startDisconnectTimer(int discType, int timeMs) {
    stopDisconnectTimer();
    synchronized (this) {
        Intent sapDisconnectIntent = new Intent(SapServer.SAP_DISCONNECT_ACTION);
        sapDisconnectIntent.putExtra(SAP_DISCONNECT_TYPE_EXTRA, discType);
        AlarmManager alarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
        mPendingDiscIntent = PendingIntent.getBroadcast(mContext, discType, sapDisconnectIntent, PendingIntent.FLAG_CANCEL_CURRENT);
        alarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + timeMs, mPendingDiscIntent);
        if (VERBOSE) {
            Log.d(TAG_HANDLER, "Setting alarm for " + timeMs + " ms to activate disconnect type " + discType);
        }
    }
}
#end_block

#method_before
private void stopDisconnectTimer() {
    synchronized (this) {
        if (pDiscIntent != null) {
            AlarmManager alarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
            alarmManager.cancel(pDiscIntent);
            pDiscIntent.cancel();
            if (VERBOSE) {
                Log.d(TAG_HANDLER, "Canceling disconnect alarm");
            }
            pDiscIntent = null;
        }
    }
}
#method_after
private void stopDisconnectTimer() {
    synchronized (this) {
        if (mPendingDiscIntent != null) {
            AlarmManager alarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
            alarmManager.cancel(mPendingDiscIntent);
            mPendingDiscIntent.cancel();
            if (VERBOSE) {
                Log.d(TAG_HANDLER, "Canceling disconnect alarm");
            }
            mPendingDiscIntent = null;
        }
    }
}
#end_block

#method_before
private void handleRfcommReply(SapMessage sapMsg) {
    if (sapMsg != null) {
        if (DEBUG)
            Log.i(TAG_HANDLER, "handleRfcommReply() handling " + SapMessage.getMsgTypeName(sapMsg.getMsgType()));
        switch(sapMsg.getMsgType()) {
            case SapMessage.ID_CONNECT_RESP:
                if (mState == SAP_STATE.CONNECTING_CALL_ONGOING) {
                    /* Hold back the connect resp if a call was ongoing when the connect req
                         * was received.
                         * A response with status call-ongoing was sent, and the connect response
                         * received from the RIL when call ends must be discarded.
                         */
                    if (sapMsg.getConnectionStatus() == SapMessage.CON_STATUS_OK) {
                        // This is successful connect response from RIL/modem.
                        changeState(SAP_STATE.CONNECTED);
                    }
                    if (VERBOSE)
                        Log.i(TAG, "Hold back the connect resp, as a call was ongoing" + " when the initial response were sent.");
                    sapMsg = null;
                } else if (sapMsg.getConnectionStatus() == SapMessage.CON_STATUS_OK) {
                    // This is successful connect response from RIL/modem.
                    changeState(SAP_STATE.CONNECTED);
                } else if (sapMsg.getConnectionStatus() == SapMessage.CON_STATUS_OK_ONGOING_CALL) {
                    changeState(SAP_STATE.CONNECTING_CALL_ONGOING);
                } else if (sapMsg.getConnectionStatus() != SapMessage.CON_STATUS_OK) {
                    /* Most likely the peer will try to connect again, hence we keep the
                         * connection to RIL open and stay in connecting state.
                         *
                         * Start timer to do shutdown if a new connect request is not received in
                         * time. */
                    startDisconnectTimer(SapMessage.DISC_FORCED, DISCONNECT_TIMEOUT_RFCOMM);
                }
                break;
            case SapMessage.ID_DISCONNECT_RESP:
                if (mState == SAP_STATE.DISCONNECTING) {
                    /* Close the RIL-BT output Stream and signal to SapRilReceiver to close
                         * down the input stream. */
                    if (DEBUG)
                        Log.i(TAG, "ID_DISCONNECT_RESP received in SAP_STATE." + "DISCONNECTING.");
                    /* Send the disconnect resp, and wait for the client to close the Rfcomm,
                         * but start a timeout timer, just to be sure. Use alarm, to ensure we wake
                         * the host to close the connection to minimize power consumption. */
                    SapMessage disconnectResp = new SapMessage(SapMessage.ID_DISCONNECT_RESP);
                    changeState(SAP_STATE.DISCONNECTED);
                    sapMsg = disconnectResp;
                    startDisconnectTimer(SapMessage.DISC_RFCOMM, DISCONNECT_TIMEOUT_RFCOMM);
                    mDeinitSignal.countDown();
                /* Signal deinit complete */
                } else {
                    /* DISCONNECTED */
                    mDeinitSignal.countDown();
                    /* Signal deinit complete */
                    if (mIsLocalInitDisconnect == true) {
                        if (VERBOSE)
                            Log.i(TAG_HANDLER, "This is a FORCED disconnect.");
                        /* We needed to force the disconnect, hence no hope for the client to
                             * close the RFCOMM connection, hence we do it here. */
                        shutdown();
                        sapMsg = null;
                    } else {
                        /* The client must disconnect the RFCOMM, but in case it does not, we
                             * need to do it.
                             * We start an alarm, and if it triggers, we must send the
                             * MSG_SERVERSESSION_CLOSE */
                        if (VERBOSE)
                            Log.i(TAG_HANDLER, "This is a NORMAL disconnect.");
                        startDisconnectTimer(SapMessage.DISC_RFCOMM, DISCONNECT_TIMEOUT_RFCOMM);
                    }
                }
                break;
            case SapMessage.ID_STATUS_IND:
                /* Some car-kits only "likes" status indication when connected, hence discard
                     * any arriving outside this state */
                if (mState == SAP_STATE.DISCONNECTED || mState == SAP_STATE.CONNECTING || mState == SAP_STATE.DISCONNECTING) {
                    sapMsg = null;
                }
                if (mSapServiceHandler != null && mState == SAP_STATE.CONNECTED) {
                    Message msg = Message.obtain(mSapServiceHandler);
                    msg.what = SapService.MSG_CHANGE_STATE;
                    msg.arg1 = BluetoothSap.STATE_CONNECTED;
                    msg.sendToTarget();
                    setNotification(SapMessage.DISC_GRACEFULL, 0);
                    if (DEBUG)
                        Log.d(TAG, "MSG_CHANGE_STATE sent out.");
                }
                break;
            default:
        }
    }
    /* Update state variable based on the number of pending commands. We are only able to
         * handle one request at the time, except from disconnect, sim off and sim reset.
         * Hence if one of these are received while in busy state, we might have a crossing
         * response, hence we must stay in BUSY state if we have an ongoing RIL request. */
    if (mState == SAP_STATE.CONNECTED_BUSY) {
        if (SapMessage.getNumPendingRilMessages() == 0) {
            changeState(SAP_STATE.CONNECTED);
        }
    }
    // This is the default case - just send the message to the SAP client.
    if (sapMsg != null)
        sendReply(sapMsg);
}
#method_after
private void handleRfcommReply(SapMessage sapMsg) {
    if (sapMsg != null) {
        if (DEBUG) {
            Log.i(TAG_HANDLER, "handleRfcommReply() handling " + SapMessage.getMsgTypeName(sapMsg.getMsgType()));
        }
        switch(sapMsg.getMsgType()) {
            case SapMessage.ID_CONNECT_RESP:
                if (mState == SAP_STATE.CONNECTING_CALL_ONGOING) {
                    /* Hold back the connect resp if a call was ongoing when the connect req
                         * was received.
                         * A response with status call-ongoing was sent, and the connect response
                         * received from the RIL when call ends must be discarded.
                         */
                    if (sapMsg.getConnectionStatus() == SapMessage.CON_STATUS_OK) {
                        // This is successful connect response from RIL/modem.
                        changeState(SAP_STATE.CONNECTED);
                    }
                    if (VERBOSE) {
                        Log.i(TAG, "Hold back the connect resp, as a call was ongoing" + " when the initial response were sent.");
                    }
                    sapMsg = null;
                } else if (sapMsg.getConnectionStatus() == SapMessage.CON_STATUS_OK) {
                    // This is successful connect response from RIL/modem.
                    changeState(SAP_STATE.CONNECTED);
                } else if (sapMsg.getConnectionStatus() == SapMessage.CON_STATUS_OK_ONGOING_CALL) {
                    changeState(SAP_STATE.CONNECTING_CALL_ONGOING);
                } else if (sapMsg.getConnectionStatus() != SapMessage.CON_STATUS_OK) {
                    /* Most likely the peer will try to connect again, hence we keep the
                         * connection to RIL open and stay in connecting state.
                         *
                         * Start timer to do shutdown if a new connect request is not received in
                         * time. */
                    startDisconnectTimer(SapMessage.DISC_FORCED, DISCONNECT_TIMEOUT_RFCOMM);
                }
                break;
            case SapMessage.ID_DISCONNECT_RESP:
                if (mState == SAP_STATE.DISCONNECTING) {
                    /* Close the RIL-BT output Stream and signal to SapRilReceiver to close
                         * down the input stream. */
                    if (DEBUG) {
                        Log.i(TAG, "ID_DISCONNECT_RESP received in SAP_STATE." + "DISCONNECTING.");
                    }
                    /* Send the disconnect resp, and wait for the client to close the Rfcomm,
                         * but start a timeout timer, just to be sure. Use alarm, to ensure we wake
                         * the host to close the connection to minimize power consumption. */
                    SapMessage disconnectResp = new SapMessage(SapMessage.ID_DISCONNECT_RESP);
                    changeState(SAP_STATE.DISCONNECTED);
                    sapMsg = disconnectResp;
                    startDisconnectTimer(SapMessage.DISC_RFCOMM, DISCONNECT_TIMEOUT_RFCOMM);
                    mDeinitSignal.countDown();
                /* Signal deinit complete */
                } else {
                    /* DISCONNECTED */
                    mDeinitSignal.countDown();
                    /* Signal deinit complete */
                    if (mIsLocalInitDisconnect) {
                        if (VERBOSE) {
                            Log.i(TAG_HANDLER, "This is a FORCED disconnect.");
                        }
                        /* We needed to force the disconnect, hence no hope for the client to
                             * close the RFCOMM connection, hence we do it here. */
                        shutdown();
                        sapMsg = null;
                    } else {
                        /* The client must disconnect the RFCOMM, but in case it does not, we
                             * need to do it.
                             * We start an alarm, and if it triggers, we must send the
                             * MSG_SERVERSESSION_CLOSE */
                        if (VERBOSE) {
                            Log.i(TAG_HANDLER, "This is a NORMAL disconnect.");
                        }
                        startDisconnectTimer(SapMessage.DISC_RFCOMM, DISCONNECT_TIMEOUT_RFCOMM);
                    }
                }
                break;
            case SapMessage.ID_STATUS_IND:
                /* Some car-kits only "likes" status indication when connected, hence discard
                     * any arriving outside this state */
                if (mState == SAP_STATE.DISCONNECTED || mState == SAP_STATE.CONNECTING || mState == SAP_STATE.DISCONNECTING) {
                    sapMsg = null;
                }
                if (mSapServiceHandler != null && mState == SAP_STATE.CONNECTED) {
                    Message msg = Message.obtain(mSapServiceHandler);
                    msg.what = SapService.MSG_CHANGE_STATE;
                    msg.arg1 = BluetoothSap.STATE_CONNECTED;
                    msg.sendToTarget();
                    setNotification(SapMessage.DISC_GRACEFULL, 0);
                    if (DEBUG) {
                        Log.d(TAG, "MSG_CHANGE_STATE sent out.");
                    }
                }
                break;
            default:
        }
    }
    /* Update state variable based on the number of pending commands. We are only able to
         * handle one request at the time, except from disconnect, sim off and sim reset.
         * Hence if one of these are received while in busy state, we might have a crossing
         * response, hence we must stay in BUSY state if we have an ongoing RIL request. */
    if (mState == SAP_STATE.CONNECTED_BUSY) {
        if (SapMessage.getNumPendingRilMessages() == 0) {
            changeState(SAP_STATE.CONNECTED);
        }
    }
    // This is the default case - just send the message to the SAP client.
    if (sapMsg != null) {
        sendReply(sapMsg);
    }
}
#end_block

#method_before
private void handleRilInd(SapMessage sapMsg) {
    if (sapMsg == null)
        return;
    switch(sapMsg.getMsgType()) {
        case SapMessage.ID_DISCONNECT_IND:
            {
                if (mState != SAP_STATE.DISCONNECTED && mState != SAP_STATE.DISCONNECTING) {
                    /* we only send disconnect indication to the client if we are actually connected*/
                    SapMessage reply = new SapMessage(SapMessage.ID_DISCONNECT_IND);
                    reply.setDisconnectionType(sapMsg.getDisconnectionType());
                    sendClientMessage(reply);
                } else {
                    /* TODO: This was introduced to handle disconnect indication from RIL */
                    sendDisconnectInd(sapMsg.getDisconnectionType());
                }
                break;
            }
        default:
            if (DEBUG)
                Log.w(TAG_HANDLER, "Unhandled message - type: " + SapMessage.getMsgTypeName(sapMsg.getMsgType()));
    }
}
#method_after
private void handleRilInd(SapMessage sapMsg) {
    if (sapMsg == null) {
        return;
    }
    switch(sapMsg.getMsgType()) {
        case SapMessage.ID_RIL_UNSOL_DISCONNECT_IND:
            {
                if (mState != SAP_STATE.DISCONNECTED && mState != SAP_STATE.DISCONNECTING) {
                    /* we only send disconnect indication to the client if we are actually connected*/
                    SapMessage reply = new SapMessage(SapMessage.ID_DISCONNECT_IND);
                    reply.setDisconnectionType(sapMsg.getDisconnectionType());
                    sendClientMessage(reply);
                } else {
                    /* TODO: This was introduced to handle disconnect indication from RIL */
                    sendDisconnectInd(sapMsg.getDisconnectionType());
                }
                break;
            }
        default:
            if (DEBUG) {
                Log.w(TAG_HANDLER, "Unhandled message - type: " + SapMessage.getMsgTypeName(sapMsg.getMsgType()));
            }
    }
}
#end_block

#method_before
private void sendRilMessage(SapMessage sapMsg) {
    if (VERBOSE)
        Log.i(TAG_HANDLER, "sendRilMessage() - " + SapMessage.getMsgTypeName(sapMsg.getMsgType()));
    Log.d(TAG_HANDLER, "sendRilMessage: calling getSapProxy");
    synchronized (mRilBtReceiver.getSapProxyLock()) {
        ISap sapProxy = mRilBtReceiver.getSapProxy();
        if (sapProxy == null) {
            Log.e(TAG_HANDLER, "sendRilMessage: Unable to send message to RIL; sapProxy is null");
            sendClientMessage(new SapMessage(SapMessage.ID_ERROR_RESP));
            return;
        }
        try {
            sapMsg.send(sapProxy);
            if (VERBOSE) {
                Log.d(TAG_HANDLER, "sendRilMessage: sapMsg.callISapReq called successfully");
            }
        } catch (IllegalArgumentException e) {
            Log.e(TAG_HANDLER, "sendRilMessage: IllegalArgumentException", e);
            sendClientMessage(new SapMessage(SapMessage.ID_ERROR_RESP));
        } catch (RemoteException | RuntimeException e) {
            Log.e(TAG_HANDLER, "sendRilMessage: Unable to send message to RIL: " + e);
            sendClientMessage(new SapMessage(SapMessage.ID_ERROR_RESP));
            mRilBtReceiver.notifyShutdown();
            /* Only needed in case of a connection error */
            mRilBtReceiver.resetSapProxy();
        }
    }
}
#method_after
private void sendRilMessage(SapMessage sapMsg) {
    if (VERBOSE) {
        Log.i(TAG_HANDLER, "sendRilMessage() - " + SapMessage.getMsgTypeName(sapMsg.getMsgType()));
    }
    Log.d(TAG_HANDLER, "sendRilMessage: calling getSapProxy");
    synchronized (mRilBtReceiver.getSapProxyLock()) {
        ISap sapProxy = mRilBtReceiver.getSapProxy();
        if (sapProxy == null) {
            Log.e(TAG_HANDLER, "sendRilMessage: Unable to send message to RIL; sapProxy is null");
            sendClientMessage(new SapMessage(SapMessage.ID_ERROR_RESP));
            return;
        }
        try {
            sapMsg.send(sapProxy);
            if (VERBOSE) {
                Log.d(TAG_HANDLER, "sendRilMessage: sapMsg.callISapReq called successfully");
            }
        } catch (IllegalArgumentException e) {
            Log.e(TAG_HANDLER, "sendRilMessage: IllegalArgumentException", e);
            sendClientMessage(new SapMessage(SapMessage.ID_ERROR_RESP));
        } catch (RemoteException | RuntimeException e) {
            Log.e(TAG_HANDLER, "sendRilMessage: Unable to send message to RIL: " + e);
            sendClientMessage(new SapMessage(SapMessage.ID_ERROR_RESP));
            mRilBtReceiver.notifyShutdown();
            /* Only needed in case of a connection error */
            mRilBtReceiver.resetSapProxy();
        }
    }
}
#end_block

#method_before
private void sendReply(SapMessage msg) {
    if (VERBOSE)
        Log.i(TAG_HANDLER, "sendReply() RFCOMM - " + SapMessage.getMsgTypeName(msg.getMsgType()));
    if (mRfcommOut != null) {
        // Needed to handle brutal shutdown from car-kit and out of range
        try {
            msg.write(mRfcommOut);
            mRfcommOut.flush();
        } catch (IOException e) {
            Log.w(TAG_HANDLER, e);
        /* As we cannot write to the rfcomm channel we are disconnected.
                   Shutdown and prepare for a new connect. */
        }
    }
}
#method_after
private void sendReply(SapMessage msg) {
    if (VERBOSE) {
        Log.i(TAG_HANDLER, "sendReply() RFCOMM - " + SapMessage.getMsgTypeName(msg.getMsgType()));
    }
    if (mRfcommOut != null) {
        // Needed to handle brutal shutdown from car-kit and out of range
        try {
            msg.write(mRfcommOut);
            mRfcommOut.flush();
        } catch (IOException e) {
            Log.w(TAG_HANDLER, e);
        /* As we cannot write to the rfcomm channel we are disconnected.
                   Shutdown and prepare for a new connect. */
        }
    }
}
#end_block

#method_before
public static byte[] updateHeaderSet(HeaderSet header, byte[] headerArray) throws IOException {
    int index = 0;
    int length = 0;
    int headerID;
    byte[] value = null;
    byte[] body = null;
    HeaderSet headerImpl = header;
    try {
        while (index < headerArray.length) {
            headerID = 0xFF & headerArray[index];
            switch(headerID & (0xC0)) {
                /*
                     * 0x00 is a unicode null terminate string with the first
                     * two bytes after the header identifier being the length
                     */
                case 0x00:
                /*
                         * 0x40 is a byte sequence with the first
                         * two bytes after the header identifier being the length
                         */
                case 0x40:
                    boolean trimTail = true;
                    index++;
                    length = 0xFF & headerArray[index];
                    length = length << 8;
                    index++;
                    length += 0xFF & headerArray[index];
                    length -= 3;
                    if (length <= 0) {
                        Log.e(TAG, "Remote not sending proper Obex connect response" + " length :" + length);
                        break;
                    }
                    index++;
                    value = new byte[length];
                    System.arraycopy(headerArray, index, value, 0, length);
                    if (length == 0 || (length > 0 && (value[length - 1] != 0))) {
                        trimTail = false;
                    }
                    switch(headerID) {
                        case HeaderSet.TYPE:
                            try {
                                // Remove trailing null
                                if (trimTail == false) {
                                    headerImpl.setHeader(headerID, new String(value, 0, value.length, "ISO8859_1"));
                                } else {
                                    headerImpl.setHeader(headerID, new String(value, 0, value.length - 1, "ISO8859_1"));
                                }
                            } catch (UnsupportedEncodingException e) {
                                throw e;
                            }
                            break;
                        case HeaderSet.AUTH_CHALLENGE:
                            headerImpl.mAuthChall = new byte[length];
                            System.arraycopy(headerArray, index, headerImpl.mAuthChall, 0, length);
                            break;
                        case HeaderSet.AUTH_RESPONSE:
                            headerImpl.mAuthResp = new byte[length];
                            System.arraycopy(headerArray, index, headerImpl.mAuthResp, 0, length);
                            break;
                        case HeaderSet.BODY:
                        /* Fall Through */
                        case HeaderSet.END_OF_BODY:
                            body = new byte[length + 1];
                            body[0] = (byte) headerID;
                            System.arraycopy(headerArray, index, body, 1, length);
                            break;
                        case HeaderSet.TIME_ISO_8601:
                            try {
                                String dateString = new String(value, "ISO8859_1");
                                Calendar temp = Calendar.getInstance();
                                if ((dateString.length() == 16) && (dateString.charAt(15) == 'Z')) {
                                    temp.setTimeZone(TimeZone.getTimeZone("UTC"));
                                }
                                temp.set(Calendar.YEAR, Integer.parseInt(dateString.substring(0, 4)));
                                temp.set(Calendar.MONTH, Integer.parseInt(dateString.substring(4, 6)));
                                temp.set(Calendar.DAY_OF_MONTH, Integer.parseInt(dateString.substring(6, 8)));
                                temp.set(Calendar.HOUR_OF_DAY, Integer.parseInt(dateString.substring(9, 11)));
                                temp.set(Calendar.MINUTE, Integer.parseInt(dateString.substring(11, 13)));
                                temp.set(Calendar.SECOND, Integer.parseInt(dateString.substring(13, 15)));
                                headerImpl.setHeader(HeaderSet.TIME_ISO_8601, temp);
                            } catch (UnsupportedEncodingException e) {
                                throw e;
                            }
                            break;
                        default:
                            if ((headerID & 0xC0) == 0x00) {
                                headerImpl.setHeader(headerID, ObexHelper.convertToUnicode(value, true));
                            } else {
                                headerImpl.setHeader(headerID, value);
                            }
                    }
                    index += length;
                    break;
                /*
                     * 0x80 is a byte header.  The only valid byte headers are
                     * the 16 user defined byte headers.
                     */
                case 0x80:
                    index++;
                    try {
                        headerImpl.setHeader(headerID, Byte.valueOf(headerArray[index]));
                    } catch (Exception e) {
                    // Not a valid header so ignore
                    }
                    index++;
                    break;
                /*
                     * 0xC0 is a 4 byte unsigned integer header and with the
                     * exception of TIME_4_BYTE will be converted to a Long
                     * and added.
                     */
                case 0xC0:
                    index++;
                    value = new byte[4];
                    System.arraycopy(headerArray, index, value, 0, 4);
                    try {
                        if (headerID != HeaderSet.TIME_4_BYTE) {
                            // need to be handled differently
                            if (headerID == HeaderSet.CONNECTION_ID) {
                                headerImpl.mConnectionID = new byte[4];
                                System.arraycopy(value, 0, headerImpl.mConnectionID, 0, 4);
                            } else {
                                headerImpl.setHeader(headerID, Long.valueOf(convertToLong(value)));
                            }
                        } else {
                            Calendar temp = Calendar.getInstance();
                            temp.setTime(new Date(convertToLong(value) * 1000L));
                            headerImpl.setHeader(HeaderSet.TIME_4_BYTE, temp);
                        }
                    } catch (Exception e) {
                        // Not a valid header so ignore
                        throw new IOException("Header was not formatted properly", e);
                    }
                    index += 4;
                    break;
            }
        }
    } catch (IOException e) {
        throw new IOException("Header was not formatted properly", e);
    }
    return body;
}
#method_after
public static byte[] updateHeaderSet(HeaderSet header, byte[] headerArray) throws IOException {
    int index = 0;
    int length = 0;
    int headerID;
    byte[] value = null;
    byte[] body = null;
    HeaderSet headerImpl = header;
    try {
        while (index < headerArray.length) {
            headerID = 0xFF & headerArray[index];
            switch(headerID & (0xC0)) {
                /*
                     * 0x00 is a unicode null terminate string with the first
                     * two bytes after the header identifier being the length
                     */
                case 0x00:
                /*
                         * 0x40 is a byte sequence with the first
                         * two bytes after the header identifier being the length
                         */
                case 0x40:
                    boolean trimTail = true;
                    index++;
                    length = ((0xFF & headerArray[index]) << 8) + (0xFF & headerArray[index + 1]);
                    index += 2;
                    if (length <= OBEX_BYTE_SEQ_HEADER_LEN) {
                        Log.e(TAG, "Remote sent an OBEX packet with " + "incorrect header length = " + length);
                        break;
                    }
                    length -= OBEX_BYTE_SEQ_HEADER_LEN;
                    value = new byte[length];
                    System.arraycopy(headerArray, index, value, 0, length);
                    if (length == 0 || (length > 0 && (value[length - 1] != 0))) {
                        trimTail = false;
                    }
                    switch(headerID) {
                        case HeaderSet.TYPE:
                            try {
                                // Remove trailing null
                                if (trimTail == false) {
                                    headerImpl.setHeader(headerID, new String(value, 0, value.length, "ISO8859_1"));
                                } else {
                                    headerImpl.setHeader(headerID, new String(value, 0, value.length - 1, "ISO8859_1"));
                                }
                            } catch (UnsupportedEncodingException e) {
                                throw e;
                            }
                            break;
                        case HeaderSet.AUTH_CHALLENGE:
                            headerImpl.mAuthChall = new byte[length];
                            System.arraycopy(headerArray, index, headerImpl.mAuthChall, 0, length);
                            break;
                        case HeaderSet.AUTH_RESPONSE:
                            headerImpl.mAuthResp = new byte[length];
                            System.arraycopy(headerArray, index, headerImpl.mAuthResp, 0, length);
                            break;
                        case HeaderSet.BODY:
                        /* Fall Through */
                        case HeaderSet.END_OF_BODY:
                            body = new byte[length + 1];
                            body[0] = (byte) headerID;
                            System.arraycopy(headerArray, index, body, 1, length);
                            break;
                        case HeaderSet.TIME_ISO_8601:
                            try {
                                String dateString = new String(value, "ISO8859_1");
                                Calendar temp = Calendar.getInstance();
                                if ((dateString.length() == 16) && (dateString.charAt(15) == 'Z')) {
                                    temp.setTimeZone(TimeZone.getTimeZone("UTC"));
                                }
                                temp.set(Calendar.YEAR, Integer.parseInt(dateString.substring(0, 4)));
                                temp.set(Calendar.MONTH, Integer.parseInt(dateString.substring(4, 6)));
                                temp.set(Calendar.DAY_OF_MONTH, Integer.parseInt(dateString.substring(6, 8)));
                                temp.set(Calendar.HOUR_OF_DAY, Integer.parseInt(dateString.substring(9, 11)));
                                temp.set(Calendar.MINUTE, Integer.parseInt(dateString.substring(11, 13)));
                                temp.set(Calendar.SECOND, Integer.parseInt(dateString.substring(13, 15)));
                                headerImpl.setHeader(HeaderSet.TIME_ISO_8601, temp);
                            } catch (UnsupportedEncodingException e) {
                                throw e;
                            }
                            break;
                        default:
                            if ((headerID & 0xC0) == 0x00) {
                                headerImpl.setHeader(headerID, ObexHelper.convertToUnicode(value, true));
                            } else {
                                headerImpl.setHeader(headerID, value);
                            }
                    }
                    index += length;
                    break;
                /*
                     * 0x80 is a byte header.  The only valid byte headers are
                     * the 16 user defined byte headers.
                     */
                case 0x80:
                    index++;
                    try {
                        headerImpl.setHeader(headerID, Byte.valueOf(headerArray[index]));
                    } catch (Exception e) {
                    // Not a valid header so ignore
                    }
                    index++;
                    break;
                /*
                     * 0xC0 is a 4 byte unsigned integer header and with the
                     * exception of TIME_4_BYTE will be converted to a Long
                     * and added.
                     */
                case 0xC0:
                    index++;
                    value = new byte[4];
                    System.arraycopy(headerArray, index, value, 0, 4);
                    try {
                        if (headerID != HeaderSet.TIME_4_BYTE) {
                            // need to be handled differently
                            if (headerID == HeaderSet.CONNECTION_ID) {
                                headerImpl.mConnectionID = new byte[4];
                                System.arraycopy(value, 0, headerImpl.mConnectionID, 0, 4);
                            } else {
                                headerImpl.setHeader(headerID, Long.valueOf(convertToLong(value)));
                            }
                        } else {
                            Calendar temp = Calendar.getInstance();
                            temp.setTime(new Date(convertToLong(value) * 1000L));
                            headerImpl.setHeader(HeaderSet.TIME_4_BYTE, temp);
                        }
                    } catch (Exception e) {
                        // Not a valid header so ignore
                        throw new IOException("Header was not formatted properly", e);
                    }
                    index += 4;
                    break;
            }
        }
    } catch (IOException e) {
        throw new IOException("Header was not formatted properly", e);
    }
    return body;
}
#end_block

#method_before
@Override
public String toString() {
    String iccIdToPrint = SubscriptionInfo.givePrintableIccid(mFullIccId);
    return "mDestroyed=" + mDestroyed + " mContext=" + mContext + " mCi=" + mCi + " mFh=" + mFh + " mParentApp=" + mParentApp + " recordsLoadedRegistrants=" + mRecordsLoadedRegistrants + " mImsiReadyRegistrants=" + mImsiReadyRegistrants + " mRecordsEventsRegistrants=" + mRecordsEventsRegistrants + " mNewSmsRegistrants=" + mNewSmsRegistrants + " mNetworkSelectionModeAutomaticRegistrants=" + mNetworkSelectionModeAutomaticRegistrants + " recordsToLoad=" + mRecordsToLoad + " adnCache=" + mAdnCache + " recordsRequested=" + mRecordsRequested + " iccid=" + iccIdToPrint + " msisdnTag=" + mMsisdnTag + " voiceMailNum=" + Rlog.pii(VDBG, mVoiceMailNum) + " voiceMailTag=" + mVoiceMailTag + " voiceMailNum=" + Rlog.pii(VDBG, mNewVoiceMailNum) + " newVoiceMailTag=" + mNewVoiceMailTag + " isVoiceMailFixed=" + mIsVoiceMailFixed + " mImsi=" + ((mImsi != null) ? mImsi.substring(0, 6) + Rlog.pii(VDBG, mImsi.substring(6)) : "null") + (mCarrierTestOverride.isInTestMode() ? (" mFakeImsi=" + ((mFakeImsi != null) ? mFakeImsi : "null")) : "") + " mncLength=" + mMncLength + " mailboxIndex=" + mMailboxIndex + " spn=" + mSpn + (mCarrierTestOverride.isInTestMode() ? (" mFakeSpn=" + ((mFakeSpn != null) ? mFakeSpn : "null")) : "");
}
#method_after
@Override
public String toString() {
    String iccIdToPrint = SubscriptionInfo.givePrintableIccid(mFullIccId);
    return "mDestroyed=" + mDestroyed + " mContext=" + mContext + " mCi=" + mCi + " mFh=" + mFh + " mParentApp=" + mParentApp + " recordsToLoad=" + mRecordsToLoad + " adnCache=" + mAdnCache + " recordsRequested=" + mRecordsRequested + " iccid=" + iccIdToPrint + " msisdnTag=" + mMsisdnTag + " voiceMailNum=" + Rlog.pii(VDBG, mVoiceMailNum) + " voiceMailTag=" + mVoiceMailTag + " voiceMailNum=" + Rlog.pii(VDBG, mNewVoiceMailNum) + " newVoiceMailTag=" + mNewVoiceMailTag + " isVoiceMailFixed=" + mIsVoiceMailFixed + " mImsi=" + ((mImsi != null) ? mImsi.substring(0, 6) + Rlog.pii(VDBG, mImsi.substring(6)) : "null") + (mCarrierTestOverride.isInTestMode() ? " mFakeImsi=" + mFakeImsi : "") + " mncLength=" + mMncLength + " mailboxIndex=" + mMailboxIndex + " spn=" + mSpn + (mCarrierTestOverride.isInTestMode() ? " mFakeSpn=" + mFakeSpn : "");
}
#end_block

#method_before
protected void setServiceProviderName(String spn) {
    mSpn = spn;
}
#method_after
protected void setServiceProviderName(String spn) {
    if (!TextUtils.equals(mSpn, spn)) {
        mSpnUpdatedRegistrants.notifyRegistrants();
        mSpn = spn;
    }
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("IccRecords: " + this);
    pw.println(" mDestroyed=" + mDestroyed);
    pw.println(" mCi=" + mCi);
    pw.println(" mFh=" + mFh);
    pw.println(" mParentApp=" + mParentApp);
    pw.println(" recordsLoadedRegistrants: size=" + mRecordsLoadedRegistrants.size());
    for (int i = 0; i < mRecordsLoadedRegistrants.size(); i++) {
        pw.println("  recordsLoadedRegistrants[" + i + "]=" + ((Registrant) mRecordsLoadedRegistrants.get(i)).getHandler());
    }
    pw.println(" mImsiReadyRegistrants: size=" + mImsiReadyRegistrants.size());
    for (int i = 0; i < mImsiReadyRegistrants.size(); i++) {
        pw.println("  mImsiReadyRegistrants[" + i + "]=" + ((Registrant) mImsiReadyRegistrants.get(i)).getHandler());
    }
    pw.println(" mRecordsEventsRegistrants: size=" + mRecordsEventsRegistrants.size());
    for (int i = 0; i < mRecordsEventsRegistrants.size(); i++) {
        pw.println("  mRecordsEventsRegistrants[" + i + "]=" + ((Registrant) mRecordsEventsRegistrants.get(i)).getHandler());
    }
    pw.println(" mNewSmsRegistrants: size=" + mNewSmsRegistrants.size());
    for (int i = 0; i < mNewSmsRegistrants.size(); i++) {
        pw.println("  mNewSmsRegistrants[" + i + "]=" + ((Registrant) mNewSmsRegistrants.get(i)).getHandler());
    }
    pw.println(" mNetworkSelectionModeAutomaticRegistrants: size=" + mNetworkSelectionModeAutomaticRegistrants.size());
    for (int i = 0; i < mNetworkSelectionModeAutomaticRegistrants.size(); i++) {
        pw.println("  mNetworkSelectionModeAutomaticRegistrants[" + i + "]=" + ((Registrant) mNetworkSelectionModeAutomaticRegistrants.get(i)).getHandler());
    }
    pw.println(" mRecordsRequested=" + mRecordsRequested);
    pw.println(" mRecordsToLoad=" + mRecordsToLoad);
    pw.println(" mRdnCache=" + mAdnCache);
    String iccIdToPrint = SubscriptionInfo.givePrintableIccid(mFullIccId);
    pw.println(" iccid=" + iccIdToPrint);
    pw.println(" mMsisdn=" + Rlog.pii(VDBG, mMsisdn));
    pw.println(" mMsisdnTag=" + mMsisdnTag);
    pw.println(" mVoiceMailNum=" + Rlog.pii(VDBG, mVoiceMailNum));
    pw.println(" mVoiceMailTag=" + mVoiceMailTag);
    pw.println(" mNewVoiceMailNum=" + Rlog.pii(VDBG, mNewVoiceMailNum));
    pw.println(" mNewVoiceMailTag=" + mNewVoiceMailTag);
    pw.println(" mIsVoiceMailFixed=" + mIsVoiceMailFixed);
    pw.println(" mImsi=" + ((mImsi != null) ? mImsi.substring(0, 6) + Rlog.pii(VDBG, mImsi.substring(6)) : "null"));
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeImsi=" + ((mFakeImsi != null) ? mFakeImsi : "null"));
    }
    pw.println(" mMncLength=" + mMncLength);
    pw.println(" mMailboxIndex=" + mMailboxIndex);
    pw.println(" mSpn=" + mSpn);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeSpn=" + ((mFakeSpn != null) ? mFakeSpn : "null"));
    }
    pw.flush();
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("IccRecords: " + this);
    pw.println(" mDestroyed=" + mDestroyed);
    pw.println(" mCi=" + mCi);
    pw.println(" mFh=" + mFh);
    pw.println(" mParentApp=" + mParentApp);
    pw.println(" recordsLoadedRegistrants: size=" + mRecordsLoadedRegistrants.size());
    for (int i = 0; i < mRecordsLoadedRegistrants.size(); i++) {
        pw.println("  recordsLoadedRegistrants[" + i + "]=" + ((Registrant) mRecordsLoadedRegistrants.get(i)).getHandler());
    }
    pw.println(" mImsiReadyRegistrants: size=" + mImsiReadyRegistrants.size());
    for (int i = 0; i < mImsiReadyRegistrants.size(); i++) {
        pw.println("  mImsiReadyRegistrants[" + i + "]=" + ((Registrant) mImsiReadyRegistrants.get(i)).getHandler());
    }
    pw.println(" mRecordsEventsRegistrants: size=" + mRecordsEventsRegistrants.size());
    for (int i = 0; i < mRecordsEventsRegistrants.size(); i++) {
        pw.println("  mRecordsEventsRegistrants[" + i + "]=" + ((Registrant) mRecordsEventsRegistrants.get(i)).getHandler());
    }
    pw.println(" mNewSmsRegistrants: size=" + mNewSmsRegistrants.size());
    for (int i = 0; i < mNewSmsRegistrants.size(); i++) {
        pw.println("  mNewSmsRegistrants[" + i + "]=" + ((Registrant) mNewSmsRegistrants.get(i)).getHandler());
    }
    pw.println(" mNetworkSelectionModeAutomaticRegistrants: size=" + mNetworkSelectionModeAutomaticRegistrants.size());
    for (int i = 0; i < mNetworkSelectionModeAutomaticRegistrants.size(); i++) {
        pw.println("  mNetworkSelectionModeAutomaticRegistrants[" + i + "]=" + ((Registrant) mNetworkSelectionModeAutomaticRegistrants.get(i)).getHandler());
    }
    pw.println(" mRecordsRequested=" + mRecordsRequested);
    pw.println(" mRecordsToLoad=" + mRecordsToLoad);
    pw.println(" mRdnCache=" + mAdnCache);
    String iccIdToPrint = SubscriptionInfo.givePrintableIccid(mFullIccId);
    pw.println(" iccid=" + iccIdToPrint);
    pw.println(" mMsisdn=" + Rlog.pii(VDBG, mMsisdn));
    pw.println(" mMsisdnTag=" + mMsisdnTag);
    pw.println(" mVoiceMailNum=" + Rlog.pii(VDBG, mVoiceMailNum));
    pw.println(" mVoiceMailTag=" + mVoiceMailTag);
    pw.println(" mNewVoiceMailNum=" + Rlog.pii(VDBG, mNewVoiceMailNum));
    pw.println(" mNewVoiceMailTag=" + mNewVoiceMailTag);
    pw.println(" mIsVoiceMailFixed=" + mIsVoiceMailFixed);
    pw.println(" mImsi=" + ((mImsi != null) ? mImsi.substring(0, 6) + Rlog.pii(VDBG, mImsi.substring(6)) : "null"));
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeImsi=" + mFakeImsi);
    }
    pw.println(" mMncLength=" + mMncLength);
    pw.println(" mMailboxIndex=" + mMailboxIndex);
    pw.println(" mSpn=" + mSpn);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeSpn=" + mFakeSpn);
    }
    pw.flush();
}
#end_block

#method_before
private boolean validEfCfis(byte[] data) {
    if (data != null) {
        if (data[0] < 1 || data[0] > 4) {
            // The MSP (Multiple Subscriber Profile) byte should be between
            // 1 and 4 according to ETSI TS 131 102 v11.3.0 section 4.2.64.
            logw("MSP byte: " + data[0] + " is not between 1 and 4", null);
        }
        return true;
    }
    return false;
}
#method_after
private boolean validEfCfis(byte[] data) {
    if (data != null) {
        if (data[0] < 1 || data[0] > 4) {
            // The MSP (Multiple Subscriber Profile) byte should be between
            // 1 and 4 according to ETSI TS 131 102 v11.3.0 section 4.2.64.
            logw("MSP byte: " + data[0] + " is not between 1 and 4", null);
        }
        // empty EF_CFIS should be considered as call forward disabled
        for (byte b : data) {
            if (b != (byte) 0xFF) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    AdnRecord adn;
    byte[] data;
    boolean isRecordLoadResponse = false;
    if (mDestroyed.get()) {
        loge("Received message " + msg + "[" + msg.what + "] " + " while being destroyed. Ignoring.");
        return;
    }
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            case EVENT_APP_LOCKED:
                onLocked();
                break;
            /* IO events */
            case EVENT_GET_IMSI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception querying IMSI, Exception:" + ar.exception);
                    break;
                }
                mImsi = (String) ar.result;
                // than 15 (and usually 15).
                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
                    loge("invalid IMSI " + mImsi);
                    mImsi = null;
                }
                log("IMSI: mMncLength=" + mMncLength);
                if (mImsi != null && mImsi.length() >= 6) {
                    log("IMSI: " + mImsi.substring(0, 6) + Rlog.pii(LOG_TAG, mImsi.substring(6)));
                }
                String imsi = getIMSI();
                if (((mMncLength == UNKNOWN) || (mMncLength == 2)) && ((imsi != null) && (imsi.length() >= 6))) {
                    String mccmncCode = imsi.substring(0, 6);
                    for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                        if (mccmnc.equals(mccmncCode)) {
                            mMncLength = 3;
                            log("IMSI: setting1 mMncLength=" + mMncLength);
                            break;
                        }
                    }
                }
                if (mMncLength == UNKNOWN) {
                    // guess using the mcc
                    try {
                        int mcc = Integer.parseInt(imsi.substring(0, 3));
                        mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                        log("setting2 mMncLength=" + mMncLength);
                    } catch (NumberFormatException e) {
                        mMncLength = UNKNOWN;
                        loge("Corrupt IMSI! setting3 mMncLength=" + mMncLength);
                    }
                }
                if (mMncLength != UNKNOWN && mMncLength != UNINITIALIZED && imsi.length() >= 3 + mMncLength) {
                    log("update mccmnc=" + imsi.substring(0, 3 + mMncLength));
                    // finally have both the imsi and the mncLength and
                    // can parse the imsi properly
                    MccTable.updateMccMncConfiguration(mContext, imsi.substring(0, 3 + mMncLength), false);
                }
                mImsiReadyRegistrants.notifyRegistrants();
                break;
            case EVENT_GET_MBI_DONE:
                boolean isValidMbdn;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                isValidMbdn = false;
                if (ar.exception == null) {
                    // Refer TS 51.011 Section 10.3.44 for content details
                    log("EF_MBI: " + IccUtils.bytesToHexString(data));
                    // Voice mail record number stored first
                    mMailboxIndex = data[0] & 0xff;
                    // check if dailing numbe id valid
                    if (mMailboxIndex != 0 && mMailboxIndex != 0xff) {
                        log("Got valid mailbox number for MBDN");
                        isValidMbdn = true;
                    }
                }
                // one more record to load
                mRecordsToLoad += 1;
                if (isValidMbdn) {
                    // Note: MBDN was not included in NUM_OF_SIM_RECORDS_LOADED
                    new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6, mMailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
                } else {
                    // If this EF not present, try mailbox as in CPHS standard
                    // CPHS (CPHS4_2.WW6) is a european standard.
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                }
                break;
            case EVENT_GET_CPHS_MAILBOX_DONE:
            case EVENT_GET_MBDN_DONE:
                // Resetting the voice mail number and voice mail tag to null
                // as these should be updated from the data read from EF_MBDN.
                // If they are not reset, incase of invalid data/exception these
                // variables are retaining their previous values and are
                // causing invalid voice mailbox info display to user.
                mVoiceMailNum = null;
                mVoiceMailTag = null;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF" + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? "[MAILBOX]" : "[MBDN]"));
                    if (msg.what == EVENT_GET_MBDN_DONE) {
                        // load CPHS on fail...
                        // FIXME right now, only load line1's CPHS voice mail entry
                        mRecordsToLoad += 1;
                        new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    }
                    break;
                }
                adn = (AdnRecord) ar.result;
                log("VM: " + adn + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? " EF[MAILBOX]" : " EF[MBDN]"));
                if (adn.isEmpty() && msg.what == EVENT_GET_MBDN_DONE) {
                    // Bug #645770 fall back to CPHS
                    // FIXME should use SST to decide
                    // FIXME right now, only load line1's CPHS voice mail entry
                    mRecordsToLoad += 1;
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    break;
                }
                mVoiceMailNum = adn.getNumber();
                mVoiceMailTag = adn.getAlphaTag();
                break;
            case EVENT_GET_MSISDN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF[MSISDN]");
                    break;
                }
                adn = (AdnRecord) ar.result;
                mMsisdn = adn.getNumber();
                mMsisdnTag = adn.getAlphaTag();
                log("MSISDN: " + /*mMsisdn*/
                Rlog.pii(LOG_TAG, mMsisdn));
                break;
            case EVENT_SET_MSISDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mMsisdn = mNewMsisdn;
                    mMsisdnTag = mNewMsisdnTag;
                    log("Success to update EF[MSISDN]");
                }
                if (ar.userObj != null) {
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_GET_MWIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_MWIS : " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG)
                        log("EVENT_GET_MWIS_DONE exception = " + ar.exception);
                    break;
                }
                if ((data[0] & 0xff) == 0xff) {
                    if (DBG)
                        log("SIMRecords: Uninitialized record MWIS");
                    break;
                }
                mEfMWIS = data;
                break;
            case EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_CPHS_MWI: " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG) {
                        log("EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE exception = " + ar.exception);
                    }
                    break;
                }
                mEfCPHS_MWI = data;
                break;
            case EVENT_GET_ICCID_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mIccId = IccUtils.bcdToString(data, 0, data.length);
                mFullIccId = IccUtils.bchToString(data, 0, data.length);
                log("iccid: " + SubscriptionInfo.givePrintableIccid(mFullIccId));
                break;
            case EVENT_GET_AD_DONE:
                try {
                    isRecordLoadResponse = true;
                    if (mCarrierTestOverride.isInTestMode() && getIMSI() != null) {
                        imsi = getIMSI();
                        try {
                            int mcc = Integer.parseInt(imsi.substring(0, 3));
                            mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                            log("[TestMode] mMncLength=" + mMncLength);
                        } catch (NumberFormatException e) {
                            mMncLength = UNKNOWN;
                            loge("[TestMode] Corrupt IMSI! mMncLength=" + mMncLength);
                        }
                    } else {
                        ar = (AsyncResult) msg.obj;
                        data = (byte[]) ar.result;
                        if (ar.exception != null) {
                            break;
                        }
                        log("EF_AD: " + IccUtils.bytesToHexString(data));
                        if (data.length < 3) {
                            log("Corrupt AD data on SIM");
                            break;
                        }
                        if (data.length == 3) {
                            log("MNC length not present in EF_AD");
                            break;
                        }
                        mMncLength = data[3] & 0xf;
                        log("setting4 mMncLength=" + mMncLength);
                    }
                    if (mMncLength == 0xf) {
                        mMncLength = UNKNOWN;
                        log("setting5 mMncLength=" + mMncLength);
                    } else if (mMncLength != 2 && mMncLength != 3) {
                        mMncLength = UNINITIALIZED;
                        log("setting5 mMncLength=" + mMncLength);
                    }
                } finally {
                    // IMSI could be a value reading from Sim or a fake IMSI if in the test mode
                    imsi = getIMSI();
                    if (((mMncLength == UNINITIALIZED) || (mMncLength == UNKNOWN) || (mMncLength == 2)) && ((imsi != null) && (imsi.length() >= 6))) {
                        String mccmncCode = imsi.substring(0, 6);
                        log("mccmncCode=" + mccmncCode);
                        for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                            if (mccmnc.equals(mccmncCode)) {
                                mMncLength = 3;
                                log("setting6 mMncLength=" + mMncLength);
                                break;
                            }
                        }
                    }
                    if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
                        if (imsi != null) {
                            try {
                                int mcc = Integer.parseInt(imsi.substring(0, 3));
                                mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                                log("setting7 mMncLength=" + mMncLength);
                            } catch (NumberFormatException e) {
                                mMncLength = UNKNOWN;
                                loge("Corrupt IMSI! setting8 mMncLength=" + mMncLength);
                            }
                        } else {
                            // Indicate we got this info, but it didn't contain the length.
                            mMncLength = UNKNOWN;
                            log("MNC length not present in EF_AD setting9 " + "mMncLength=" + mMncLength);
                        }
                    }
                    if (imsi != null && mMncLength != UNKNOWN && imsi.length() >= 3 + mMncLength) {
                        // finally have both imsi and the length of the mnc and can parse
                        // the imsi properly
                        log("update mccmnc=" + imsi.substring(0, 3 + mMncLength));
                        MccTable.updateMccMncConfiguration(mContext, imsi.substring(0, 3 + mMncLength), false);
                    }
                }
                break;
            case EVENT_GET_SPN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                getSpnFsm(false, ar);
                break;
            case EVENT_GET_CFF_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCff = null;
                } else {
                    log("EF_CFF_CPHS: " + IccUtils.bytesToHexString(data));
                    mEfCff = data;
                }
                break;
            case EVENT_GET_SPDI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                parseEfSpdi(data);
                break;
            case EVENT_UPDATE_DONE:
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    logw("update failed. ", ar.exception);
                }
                break;
            case EVENT_GET_PNN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                SimTlv tlv = new SimTlv(data, 0, data.length);
                for (; tlv.isValidObject(); tlv.nextObject()) {
                    if (tlv.getTag() == TAG_FULL_NETWORK_NAME) {
                        mPnnHomeName = IccUtils.networkNameToString(tlv.getData(), 0, tlv.getData().length);
                        break;
                    }
                }
                break;
            case EVENT_GET_ALL_SMS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                handleSmses((ArrayList<byte[]>) ar.result);
                break;
            case EVENT_MARK_SMS_READ_DONE:
                Rlog.i("ENF", "marked read: sms " + msg.arg1);
                break;
            case EVENT_SMS_ON_SIM:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                Integer index = (Integer) ar.result;
                if (ar.exception != null || index == null) {
                    loge("Error on SMS_ON_SIM with exp " + ar.exception + " index " + index);
                } else {
                    log("READ EF_SMS RECORD index=" + index);
                    mFh.loadEFLinearFixed(EF_SMS, index, obtainMessage(EVENT_GET_SMS_DONE));
                }
                break;
            case EVENT_GET_SMS_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    handleSms((byte[]) ar.result);
                } else {
                    loge("Error on GET_SMS with exp " + ar.exception);
                }
                break;
            case EVENT_GET_SST_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mUsimServiceTable = new UsimServiceTable(data);
                if (DBG)
                    log("SST: " + mUsimServiceTable);
                break;
            case EVENT_GET_INFO_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                mCphsInfo = (byte[]) ar.result;
                if (DBG)
                    log("iCPHS: " + IccUtils.bytesToHexString(mCphsInfo));
                break;
            case EVENT_SET_MBDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("EVENT_SET_MBDN_DONE ex:" + ar.exception);
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                }
                if (isCphsMailboxEnabled()) {
                    adn = new AdnRecord(mVoiceMailTag, mVoiceMailNum);
                    Message onCphsCompleted = (Message) ar.userObj;
                    /* write to cphs mailbox whenever it is available but
                        * we only need notify caller once if both updating are
                        * successful.
                        *
                        * so if set_mbdn successful, notify caller here and set
                        * onCphsCompleted to null
                        */
                    if (ar.exception == null && ar.userObj != null) {
                        AsyncResult.forMessage(((Message) ar.userObj)).exception = null;
                        ((Message) ar.userObj).sendToTarget();
                        if (DBG)
                            log("Callback with MBDN successful.");
                        onCphsCompleted = null;
                    }
                    new AdnRecordLoader(mFh).updateEF(adn, EF_MAILBOX_CPHS, EF_EXT1, 1, null, obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE, onCphsCompleted));
                } else {
                    if (ar.userObj != null) {
                        CarrierConfigManager configLoader = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
                        if (ar.exception != null && configLoader != null && configLoader.getConfig().getBoolean(CarrierConfigManager.KEY_EDITABLE_VOICEMAIL_NUMBER_BOOL)) {
                            // GsmCdmaPhone will store vm number on device
                            // when IccVmNotSupportedException occurred
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = new IccVmNotSupportedException("Update SIM voice mailbox error");
                        } else {
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                        }
                        ((Message) ar.userObj).sendToTarget();
                    }
                }
                break;
            case EVENT_SET_CPHS_MAILBOX_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                } else {
                    if (DBG)
                        log("Set CPHS MailBox with exception: " + ar.exception);
                }
                if (ar.userObj != null) {
                    if (DBG)
                        log("Callback with CPHS MB successful.");
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_SIM_REFRESH:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("Sim REFRESH with exception: " + ar.exception);
                if (ar.exception == null) {
                    handleSimRefresh((IccRefreshResponse) ar.result);
                }
                break;
            case EVENT_GET_CFIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCfis = null;
                } else {
                    log("EF_CFIS: " + IccUtils.bytesToHexString(data));
                    mEfCfis = data;
                }
                break;
            case EVENT_GET_CSP_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception in fetching EF_CSP data " + ar.exception);
                    break;
                }
                data = (byte[]) ar.result;
                log("EF_CSP: " + IccUtils.bytesToHexString(data));
                handleEfCspData(data);
                break;
            case EVENT_GET_GID1_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID1 " + ar.exception);
                    mGid1 = null;
                    break;
                }
                mGid1 = IccUtils.bytesToHexString(data);
                log("GID1: " + mGid1);
                break;
            case EVENT_GET_GID2_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID2 " + ar.exception);
                    mGid2 = null;
                    break;
                }
                mGid2 = IccUtils.bytesToHexString(data);
                log("GID2: " + mGid2);
                break;
            case EVENT_GET_PLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting User PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mPlmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("PlmnActRecords=" + Arrays.toString(mPlmnActRecords));
                }
                break;
            case EVENT_GET_OPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Operator PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mOplmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("OplmnActRecord[]=" + Arrays.toString(mOplmnActRecords));
                }
                break;
            case EVENT_GET_HPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Home PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mHplmnActRecords = PlmnActRecord.getRecords(data);
                    log("HplmnActRecord[]=" + Arrays.toString(mHplmnActRecords));
                }
                break;
            case EVENT_GET_EHPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Equivalent Home PLMNs: " + ar.exception);
                    break;
                } else {
                    mEhplmns = parseBcdPlmnList(data, "Equivalent Home");
                }
                break;
            case EVENT_GET_FPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Forbidden PLMNs: " + ar.exception);
                    break;
                } else {
                    mFplmns = parseBcdPlmnList(data, "Forbidden");
                }
                if (msg.arg1 == HANDLER_ACTION_SEND_RESPONSE) {
                    if (VDBG)
                        logv("getForbiddenPlmns(): send async response");
                    isRecordLoadResponse = false;
                    Message response = retrievePendingResponseMessage(msg.arg2);
                    if (response != null) {
                        AsyncResult.forMessage(response, Arrays.copyOf(mFplmns, mFplmns.length), null);
                        response.sendToTarget();
                    } else {
                        loge("Failed to retrieve a response message for FPLMN");
                        break;
                    }
                }
                break;
            case EVENT_CARRIER_CONFIG_CHANGED:
                handleCarrierNameOverride();
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        logw("Exception parsing SIM record", exc);
    } finally {
        // Count up record load responses even if they are fails
        if (isRecordLoadResponse) {
            onRecordLoaded();
        }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    AdnRecord adn;
    byte[] data;
    boolean isRecordLoadResponse = false;
    if (mDestroyed.get()) {
        loge("Received message " + msg + "[" + msg.what + "] " + " while being destroyed. Ignoring.");
        return;
    }
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            case EVENT_APP_LOCKED:
                onLocked();
                break;
            /* IO events */
            case EVENT_GET_IMSI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception querying IMSI, Exception:" + ar.exception);
                    break;
                }
                mImsi = (String) ar.result;
                // than 15 (and usually 15).
                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
                    loge("invalid IMSI " + mImsi);
                    mImsi = null;
                }
                log("IMSI: mMncLength=" + mMncLength);
                if (mImsi != null && mImsi.length() >= 6) {
                    log("IMSI: " + mImsi.substring(0, 6) + Rlog.pii(LOG_TAG, mImsi.substring(6)));
                }
                String imsi = getIMSI();
                if (((mMncLength == UNKNOWN) || (mMncLength == 2)) && ((imsi != null) && (imsi.length() >= 6))) {
                    String mccmncCode = imsi.substring(0, 6);
                    for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                        if (mccmnc.equals(mccmncCode)) {
                            mMncLength = 3;
                            log("IMSI: setting1 mMncLength=" + mMncLength);
                            break;
                        }
                    }
                }
                if (mMncLength == UNKNOWN) {
                    // guess using the mcc
                    try {
                        int mcc = Integer.parseInt(imsi.substring(0, 3));
                        mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                        log("setting2 mMncLength=" + mMncLength);
                    } catch (NumberFormatException e) {
                        mMncLength = UNKNOWN;
                        loge("Corrupt IMSI! setting3 mMncLength=" + mMncLength);
                    }
                }
                if (mMncLength != UNKNOWN && mMncLength != UNINITIALIZED && imsi.length() >= 3 + mMncLength) {
                    log("update mccmnc=" + imsi.substring(0, 3 + mMncLength));
                    // finally have both the imsi and the mncLength and
                    // can parse the imsi properly
                    MccTable.updateMccMncConfiguration(mContext, imsi.substring(0, 3 + mMncLength), false);
                }
                mImsiReadyRegistrants.notifyRegistrants();
                break;
            case EVENT_GET_MBI_DONE:
                boolean isValidMbdn;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                isValidMbdn = false;
                if (ar.exception == null) {
                    // Refer TS 51.011 Section 10.3.44 for content details
                    log("EF_MBI: " + IccUtils.bytesToHexString(data));
                    // Voice mail record number stored first
                    mMailboxIndex = data[0] & 0xff;
                    // check if dailing numbe id valid
                    if (mMailboxIndex != 0 && mMailboxIndex != 0xff) {
                        log("Got valid mailbox number for MBDN");
                        isValidMbdn = true;
                    }
                }
                // one more record to load
                mRecordsToLoad += 1;
                if (isValidMbdn) {
                    // Note: MBDN was not included in NUM_OF_SIM_RECORDS_LOADED
                    new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6, mMailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
                } else {
                    // If this EF not present, try mailbox as in CPHS standard
                    // CPHS (CPHS4_2.WW6) is a european standard.
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                }
                break;
            case EVENT_GET_CPHS_MAILBOX_DONE:
            case EVENT_GET_MBDN_DONE:
                // Resetting the voice mail number and voice mail tag to null
                // as these should be updated from the data read from EF_MBDN.
                // If they are not reset, incase of invalid data/exception these
                // variables are retaining their previous values and are
                // causing invalid voice mailbox info display to user.
                mVoiceMailNum = null;
                mVoiceMailTag = null;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF" + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? "[MAILBOX]" : "[MBDN]"));
                    if (msg.what == EVENT_GET_MBDN_DONE) {
                        // load CPHS on fail...
                        // FIXME right now, only load line1's CPHS voice mail entry
                        mRecordsToLoad += 1;
                        new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    }
                    break;
                }
                adn = (AdnRecord) ar.result;
                log("VM: " + adn + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? " EF[MAILBOX]" : " EF[MBDN]"));
                if (adn.isEmpty() && msg.what == EVENT_GET_MBDN_DONE) {
                    // Bug #645770 fall back to CPHS
                    // FIXME should use SST to decide
                    // FIXME right now, only load line1's CPHS voice mail entry
                    mRecordsToLoad += 1;
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    break;
                }
                mVoiceMailNum = adn.getNumber();
                mVoiceMailTag = adn.getAlphaTag();
                break;
            case EVENT_GET_MSISDN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF[MSISDN]");
                    break;
                }
                adn = (AdnRecord) ar.result;
                mMsisdn = adn.getNumber();
                mMsisdnTag = adn.getAlphaTag();
                log("MSISDN: " + /*mMsisdn*/
                Rlog.pii(LOG_TAG, mMsisdn));
                break;
            case EVENT_SET_MSISDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mMsisdn = mNewMsisdn;
                    mMsisdnTag = mNewMsisdnTag;
                    log("Success to update EF[MSISDN]");
                }
                if (ar.userObj != null) {
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_GET_MWIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_MWIS : " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG)
                        log("EVENT_GET_MWIS_DONE exception = " + ar.exception);
                    break;
                }
                if ((data[0] & 0xff) == 0xff) {
                    if (DBG)
                        log("SIMRecords: Uninitialized record MWIS");
                    break;
                }
                mEfMWIS = data;
                break;
            case EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_CPHS_MWI: " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG) {
                        log("EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE exception = " + ar.exception);
                    }
                    break;
                }
                mEfCPHS_MWI = data;
                break;
            case EVENT_GET_ICCID_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mIccId = IccUtils.bcdToString(data, 0, data.length);
                mFullIccId = IccUtils.bchToString(data, 0, data.length);
                log("iccid: " + SubscriptionInfo.givePrintableIccid(mFullIccId));
                break;
            case EVENT_GET_AD_DONE:
                try {
                    isRecordLoadResponse = true;
                    if (mCarrierTestOverride.isInTestMode() && getIMSI() != null) {
                        imsi = getIMSI();
                        try {
                            int mcc = Integer.parseInt(imsi.substring(0, 3));
                            mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                            log("[TestMode] mMncLength=" + mMncLength);
                        } catch (NumberFormatException e) {
                            mMncLength = UNKNOWN;
                            loge("[TestMode] Corrupt IMSI! mMncLength=" + mMncLength);
                        }
                    } else {
                        ar = (AsyncResult) msg.obj;
                        data = (byte[]) ar.result;
                        if (ar.exception != null) {
                            break;
                        }
                        log("EF_AD: " + IccUtils.bytesToHexString(data));
                        if (data.length < 3) {
                            log("Corrupt AD data on SIM");
                            break;
                        }
                        if (data.length == 3) {
                            log("MNC length not present in EF_AD");
                            break;
                        }
                        mMncLength = data[3] & 0xf;
                        log("setting4 mMncLength=" + mMncLength);
                    }
                    if (mMncLength == 0xf) {
                        mMncLength = UNKNOWN;
                        log("setting5 mMncLength=" + mMncLength);
                    } else if (mMncLength != 2 && mMncLength != 3) {
                        mMncLength = UNINITIALIZED;
                        log("setting5 mMncLength=" + mMncLength);
                    }
                } finally {
                    // IMSI could be a value reading from Sim or a fake IMSI if in the test mode
                    imsi = getIMSI();
                    if (((mMncLength == UNINITIALIZED) || (mMncLength == UNKNOWN) || (mMncLength == 2)) && ((imsi != null) && (imsi.length() >= 6))) {
                        String mccmncCode = imsi.substring(0, 6);
                        log("mccmncCode=" + mccmncCode);
                        for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                            if (mccmnc.equals(mccmncCode)) {
                                mMncLength = 3;
                                log("setting6 mMncLength=" + mMncLength);
                                break;
                            }
                        }
                    }
                    if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
                        if (imsi != null) {
                            try {
                                int mcc = Integer.parseInt(imsi.substring(0, 3));
                                mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                                log("setting7 mMncLength=" + mMncLength);
                            } catch (NumberFormatException e) {
                                mMncLength = UNKNOWN;
                                loge("Corrupt IMSI! setting8 mMncLength=" + mMncLength);
                            }
                        } else {
                            // Indicate we got this info, but it didn't contain the length.
                            mMncLength = UNKNOWN;
                            log("MNC length not present in EF_AD setting9 " + "mMncLength=" + mMncLength);
                        }
                    }
                    if (imsi != null && mMncLength != UNKNOWN && imsi.length() >= 3 + mMncLength) {
                        // finally have both imsi and the length of the mnc and can parse
                        // the imsi properly
                        log("update mccmnc=" + imsi.substring(0, 3 + mMncLength));
                        MccTable.updateMccMncConfiguration(mContext, imsi.substring(0, 3 + mMncLength), false);
                    }
                }
                break;
            case EVENT_GET_SPN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                getSpnFsm(false, ar);
                break;
            case EVENT_GET_CFF_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCff = null;
                } else {
                    log("EF_CFF_CPHS: " + IccUtils.bytesToHexString(data));
                    mEfCff = data;
                }
                break;
            case EVENT_GET_SPDI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                parseEfSpdi(data);
                break;
            case EVENT_UPDATE_DONE:
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    logw("update failed. ", ar.exception);
                }
                break;
            case EVENT_GET_PNN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                SimTlv tlv = new SimTlv(data, 0, data.length);
                for (; tlv.isValidObject(); tlv.nextObject()) {
                    if (tlv.getTag() == TAG_FULL_NETWORK_NAME) {
                        mPnnHomeName = IccUtils.networkNameToString(tlv.getData(), 0, tlv.getData().length);
                        log("PNN: " + mPnnHomeName);
                        break;
                    }
                }
                break;
            case EVENT_GET_ALL_SMS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                handleSmses((ArrayList<byte[]>) ar.result);
                break;
            case EVENT_MARK_SMS_READ_DONE:
                Rlog.i("ENF", "marked read: sms " + msg.arg1);
                break;
            case EVENT_SMS_ON_SIM:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                Integer index = (Integer) ar.result;
                if (ar.exception != null || index == null) {
                    loge("Error on SMS_ON_SIM with exp " + ar.exception + " index " + index);
                } else {
                    log("READ EF_SMS RECORD index=" + index);
                    mFh.loadEFLinearFixed(EF_SMS, index, obtainMessage(EVENT_GET_SMS_DONE));
                }
                break;
            case EVENT_GET_SMS_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    handleSms((byte[]) ar.result);
                } else {
                    loge("Error on GET_SMS with exp " + ar.exception);
                }
                break;
            case EVENT_GET_SST_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mUsimServiceTable = new UsimServiceTable(data);
                if (DBG)
                    log("SST: " + mUsimServiceTable);
                break;
            case EVENT_GET_INFO_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                mCphsInfo = (byte[]) ar.result;
                if (DBG)
                    log("iCPHS: " + IccUtils.bytesToHexString(mCphsInfo));
                break;
            case EVENT_SET_MBDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("EVENT_SET_MBDN_DONE ex:" + ar.exception);
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                }
                if (isCphsMailboxEnabled()) {
                    adn = new AdnRecord(mVoiceMailTag, mVoiceMailNum);
                    Message onCphsCompleted = (Message) ar.userObj;
                    /* write to cphs mailbox whenever it is available but
                        * we only need notify caller once if both updating are
                        * successful.
                        *
                        * so if set_mbdn successful, notify caller here and set
                        * onCphsCompleted to null
                        */
                    if (ar.exception == null && ar.userObj != null) {
                        AsyncResult.forMessage(((Message) ar.userObj)).exception = null;
                        ((Message) ar.userObj).sendToTarget();
                        if (DBG)
                            log("Callback with MBDN successful.");
                        onCphsCompleted = null;
                    }
                    new AdnRecordLoader(mFh).updateEF(adn, EF_MAILBOX_CPHS, EF_EXT1, 1, null, obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE, onCphsCompleted));
                } else {
                    if (ar.userObj != null) {
                        CarrierConfigManager configLoader = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
                        if (ar.exception != null && configLoader != null && configLoader.getConfig().getBoolean(CarrierConfigManager.KEY_EDITABLE_VOICEMAIL_NUMBER_BOOL)) {
                            // GsmCdmaPhone will store vm number on device
                            // when IccVmNotSupportedException occurred
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = new IccVmNotSupportedException("Update SIM voice mailbox error");
                        } else {
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                        }
                        ((Message) ar.userObj).sendToTarget();
                    }
                }
                break;
            case EVENT_SET_CPHS_MAILBOX_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                } else {
                    if (DBG)
                        log("Set CPHS MailBox with exception: " + ar.exception);
                }
                if (ar.userObj != null) {
                    if (DBG)
                        log("Callback with CPHS MB successful.");
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_SIM_REFRESH:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("Sim REFRESH with exception: " + ar.exception);
                if (ar.exception == null) {
                    handleSimRefresh((IccRefreshResponse) ar.result);
                }
                break;
            case EVENT_GET_CFIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCfis = null;
                } else {
                    log("EF_CFIS: " + IccUtils.bytesToHexString(data));
                    mEfCfis = data;
                }
                break;
            case EVENT_GET_CSP_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception in fetching EF_CSP data " + ar.exception);
                    break;
                }
                data = (byte[]) ar.result;
                log("EF_CSP: " + IccUtils.bytesToHexString(data));
                handleEfCspData(data);
                break;
            case EVENT_GET_GID1_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID1 " + ar.exception);
                    mGid1 = null;
                    break;
                }
                mGid1 = IccUtils.bytesToHexString(data);
                log("GID1: " + mGid1);
                break;
            case EVENT_GET_GID2_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID2 " + ar.exception);
                    mGid2 = null;
                    break;
                }
                mGid2 = IccUtils.bytesToHexString(data);
                log("GID2: " + mGid2);
                break;
            case EVENT_GET_PLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting User PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mPlmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("PlmnActRecords=" + Arrays.toString(mPlmnActRecords));
                }
                break;
            case EVENT_GET_OPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Operator PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mOplmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("OplmnActRecord[]=" + Arrays.toString(mOplmnActRecords));
                }
                break;
            case EVENT_GET_HPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Home PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mHplmnActRecords = PlmnActRecord.getRecords(data);
                    log("HplmnActRecord[]=" + Arrays.toString(mHplmnActRecords));
                }
                break;
            case EVENT_GET_EHPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Equivalent Home PLMNs: " + ar.exception);
                    break;
                } else {
                    mEhplmns = parseBcdPlmnList(data, "Equivalent Home");
                }
                break;
            case EVENT_GET_FPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Forbidden PLMNs: " + ar.exception);
                    break;
                } else {
                    mFplmns = parseBcdPlmnList(data, "Forbidden");
                }
                if (msg.arg1 == HANDLER_ACTION_SEND_RESPONSE) {
                    if (VDBG)
                        logv("getForbiddenPlmns(): send async response");
                    isRecordLoadResponse = false;
                    Message response = retrievePendingResponseMessage(msg.arg2);
                    if (response != null) {
                        AsyncResult.forMessage(response, Arrays.copyOf(mFplmns, mFplmns.length), null);
                        response.sendToTarget();
                    } else {
                        loge("Failed to retrieve a response message for FPLMN");
                        break;
                    }
                }
                break;
            case EVENT_CARRIER_CONFIG_CHANGED:
                handleCarrierNameOverride();
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        logw("Exception parsing SIM record", exc);
    } finally {
        // Count up record load responses even if they are fails
        if (isRecordLoadResponse) {
            onRecordLoaded();
        }
    }
}
#end_block

#method_before
@Override
public int getDisplayRule(ServiceState serviceState) {
    int rule;
    if (mParentApp != null && mParentApp.getUiccCard() != null && mParentApp.getUiccCard().getOperatorBrandOverride() != null) {
        // If the operator has been overridden, treat it as the SPN file on the SIM did not exist.
        rule = SPN_RULE_SHOW_PLMN;
    } else if (TextUtils.isEmpty(getServiceProviderName()) || mSpnDisplayCondition == -1) {
        // No EF_SPN content was found on the SIM, or not yet loaded.  Just show ONS.
        rule = SPN_RULE_SHOW_PLMN;
    } else if (shouldConsiderServiceStateRoaming() ? !serviceState.getRoaming() : isOnMatchingPlmn(serviceState.getOperatorNumeric())) {
        rule = SPN_RULE_SHOW_SPN;
        if ((mSpnDisplayCondition & 0x01) == 0x01) {
            // ONS required when registered to HPLMN or PLMN in EF_SPDI
            rule |= SPN_RULE_SHOW_PLMN;
        }
    } else {
        rule = SPN_RULE_SHOW_PLMN;
        if ((mSpnDisplayCondition & 0x02) == 0x00) {
            // SPN required if not registered to HPLMN or PLMN in EF_SPDI
            rule |= SPN_RULE_SHOW_SPN;
        }
    }
    return rule;
}
#method_after
@Override
public int getDisplayRule(ServiceState serviceState) {
    int rule;
    if (mParentApp != null && mParentApp.getUiccCard() != null && mParentApp.getUiccCard().getOperatorBrandOverride() != null) {
        // If the operator has been overridden, treat it as the SPN file on the SIM did not exist.
        rule = SPN_RULE_SHOW_PLMN;
    } else if (TextUtils.isEmpty(getServiceProviderName()) || mSpnDisplayCondition == -1) {
        // No EF_SPN content was found on the SIM, or not yet loaded.  Just show ONS.
        rule = SPN_RULE_SHOW_PLMN;
    } else if (useRoamingFromServiceState() ? !serviceState.getRoaming() : isOnMatchingPlmn(serviceState.getOperatorNumeric())) {
        rule = SPN_RULE_SHOW_SPN;
        if ((mSpnDisplayCondition & 0x01) == 0x01) {
            // ONS required when registered to HPLMN or PLMN in EF_SPDI
            rule |= SPN_RULE_SHOW_PLMN;
        }
    } else {
        rule = SPN_RULE_SHOW_PLMN;
        if ((mSpnDisplayCondition & 0x02) == 0x00) {
            // SPN required if not registered to HPLMN or PLMN in EF_SPDI
            rule |= SPN_RULE_SHOW_SPN;
        }
    }
    return rule;
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("SIMRecords: " + this);
    pw.println(" extends:");
    super.dump(fd, pw, args);
    pw.println(" mVmConfig=" + mVmConfig);
    pw.println(" mSpnOverride=" + mSpnOverride);
    pw.println(" mCallForwardingStatus=" + mCallForwardingStatus);
    pw.println(" mSpnState=" + mSpnState);
    pw.println(" mCphsInfo=" + mCphsInfo);
    pw.println(" mCspPlmnEnabled=" + mCspPlmnEnabled);
    pw.println(" mEfMWIS[]=" + Arrays.toString(mEfMWIS));
    pw.println(" mEfCPHS_MWI[]=" + Arrays.toString(mEfCPHS_MWI));
    pw.println(" mEfCff[]=" + Arrays.toString(mEfCff));
    pw.println(" mEfCfis[]=" + Arrays.toString(mEfCfis));
    pw.println(" mSpnDisplayCondition=" + mSpnDisplayCondition);
    pw.println(" mSpdiNetworks[]=" + mSpdiNetworks);
    pw.println(" mPnnHomeName=" + mPnnHomeName);
    pw.println(" mUsimServiceTable=" + mUsimServiceTable);
    pw.println(" mGid1=" + mGid1);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeGid1=" + ((mFakeGid1 != null) ? mFakeGid1 : "null"));
    }
    pw.println(" mGid2=" + mGid2);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeGid2=" + ((mFakeGid2 != null) ? mFakeGid2 : "null"));
    }
    pw.println(" mPlmnActRecords[]=" + Arrays.toString(mPlmnActRecords));
    pw.println(" mOplmnActRecords[]=" + Arrays.toString(mOplmnActRecords));
    pw.println(" mHplmnActRecords[]=" + Arrays.toString(mHplmnActRecords));
    pw.println(" mFplmns[]=" + Arrays.toString(mFplmns));
    pw.println(" mEhplmns[]=" + Arrays.toString(mEhplmns));
    pw.flush();
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("SIMRecords: " + this);
    pw.println(" extends:");
    super.dump(fd, pw, args);
    pw.println(" mVmConfig=" + mVmConfig);
    pw.println(" mSpnOverride=" + mSpnOverride);
    pw.println(" mCallForwardingStatus=" + mCallForwardingStatus);
    pw.println(" mSpnState=" + mSpnState);
    pw.println(" mCphsInfo=" + mCphsInfo);
    pw.println(" mCspPlmnEnabled=" + mCspPlmnEnabled);
    pw.println(" mEfMWIS[]=" + Arrays.toString(mEfMWIS));
    pw.println(" mEfCPHS_MWI[]=" + Arrays.toString(mEfCPHS_MWI));
    pw.println(" mEfCff[]=" + Arrays.toString(mEfCff));
    pw.println(" mEfCfis[]=" + Arrays.toString(mEfCfis));
    pw.println(" mSpnDisplayCondition=" + mSpnDisplayCondition);
    pw.println(" mSpdiNetworks[]=" + mSpdiNetworks);
    pw.println(" mPnnHomeName=" + mPnnHomeName);
    pw.println(" mUsimServiceTable=" + mUsimServiceTable);
    pw.println(" mGid1=" + mGid1);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeGid1=" + mFakeGid1);
    }
    pw.println(" mGid2=" + mGid2);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeGid2=" + mFakeGid2);
    }
    pw.println(" mPnnHomeName=" + mPnnHomeName);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakePnnHomeName=" + mFakePnnHomeName);
    }
    pw.println(" mPlmnActRecords[]=" + Arrays.toString(mPlmnActRecords));
    pw.println(" mOplmnActRecords[]=" + Arrays.toString(mOplmnActRecords));
    pw.println(" mHplmnActRecords[]=" + Arrays.toString(mHplmnActRecords));
    pw.println(" mFplmns[]=" + Arrays.toString(mFplmns));
    pw.println(" mEhplmns[]=" + Arrays.toString(mEhplmns));
    pw.flush();
}
#end_block

#method_before
private void checkOutputApkNotDebuggableIfDebuggableMustBeRejected() throws SignatureException {
    if (mDebuggableApkPermitted) {
        return;
    }
    try {
        if (isOutputApkDebuggable()) {
            throw new SignatureException("APK is debuggable (see android:debuggable attribute) and this engine is" + " configured to refuse to sign debuggable APKs");
        }
    } catch (DebuggableException e) {
        throw new SignatureException("Failed to determine whether the APK is debuggable", e);
    }
}
#method_after
private void checkOutputApkNotDebuggableIfDebuggableMustBeRejected() throws SignatureException {
    if (mDebuggableApkPermitted) {
        return;
    }
    try {
        if (isOutputApkDebuggable()) {
            throw new SignatureException("APK is debuggable (see android:debuggable attribute) and this engine is" + " configured to refuse to sign debuggable APKs");
        }
    } catch (ApkFormatException e) {
        throw new SignatureException("Failed to determine whether the APK is debuggable", e);
    }
}
#end_block

#method_before
private boolean isOutputApkDebuggable() throws DebuggableException {
    if (mDebuggable != null) {
        return mDebuggable;
    }
    if (mOutputAndroidManifestEntryDataRequest == null) {
        throw new IllegalStateException("Cannot determine debuggable status of output APK because " + ApkUtils.ANDROID_MANIFEST_ZIP_ENTRY_NAME + " entry contents have not yet been requested");
    }
    if (!mOutputAndroidManifestEntryDataRequest.isDone()) {
        throw new IllegalStateException("Still waiting to inspect output APK's " + mOutputAndroidManifestEntryDataRequest.getEntryName());
    }
    mDebuggable = ApkUtils.getDebuggableFromBinaryAndroidManifest(ByteBuffer.wrap(mOutputAndroidManifestEntryDataRequest.getData()));
    return mDebuggable;
}
#method_after
private boolean isOutputApkDebuggable() throws ApkFormatException {
    if (mDebuggable != null) {
        return mDebuggable;
    }
    if (mOutputAndroidManifestEntryDataRequest == null) {
        throw new IllegalStateException("Cannot determine debuggable status of output APK because " + ApkUtils.ANDROID_MANIFEST_ZIP_ENTRY_NAME + " entry contents have not yet been requested");
    }
    if (!mOutputAndroidManifestEntryDataRequest.isDone()) {
        throw new IllegalStateException("Still waiting to inspect output APK's " + mOutputAndroidManifestEntryDataRequest.getEntryName());
    }
    mDebuggable = ApkUtils.getDebuggableFromBinaryAndroidManifest(ByteBuffer.wrap(mOutputAndroidManifestEntryDataRequest.getData()));
    return mDebuggable;
}
#end_block

#method_before
public DefaultApkSignerEngine build() throws InvalidKeyException {
    return new DefaultApkSignerEngine(mSignerConfigs, mMinSdkVersion, mV1SigningEnabled, mV2SigningEnabled, mDebuggableApkPermitted, mOtherSignersSignaturesPreserved, mCreatedBy);
}
#method_after
public SignerConfig build() {
    return new SignerConfig(mName, mPrivateKey, mCertificates);
}
#end_block

#method_before
public ApkSigner build() {
    return new ApkSigner(mSignerConfigs, mMinSdkVersion, mV1SigningEnabled, mV2SigningEnabled, mDebuggableApkPermitted, mOtherSignersSignaturesPreserved, mCreatedBy, mSignerEngine, mInputApkFile, mInputApkDataSource, mOutputApkFile, mOutputApkDataSink, mOutputApkDataSource);
}
#method_after
public SignerConfig build() {
    return new SignerConfig(mName, mPrivateKey, mCertificates);
}
#end_block

#method_before
public static boolean getDebuggableFromBinaryAndroidManifest(ByteBuffer androidManifestContents) throws DebuggableException {
    try {
        AndroidBinXmlParser parser = new AndroidBinXmlParser(androidManifestContents);
        int eventType = parser.getEventType();
        while (eventType != AndroidBinXmlParser.EVENT_END_DOCUMENT) {
            if ((eventType == AndroidBinXmlParser.EVENT_START_ELEMENT) && (parser.getDepth() == 2) && ("application".equals(parser.getName())) && (parser.getNamespace().isEmpty())) {
                for (int i = 0; i < parser.getAttributeCount(); i++) {
                    if (parser.getAttributeNameResourceId(i) == DEBUGGABLE_ATTR_ID) {
                        int valueType = parser.getAttributeValueType(i);
                        switch(valueType) {
                            case AndroidBinXmlParser.VALUE_TYPE_BOOLEAN:
                            case AndroidBinXmlParser.VALUE_TYPE_STRING:
                            case AndroidBinXmlParser.VALUE_TYPE_INT:
                                String value = parser.getAttributeStringValue(i);
                                return ("true".equals(value)) || ("TRUE".equals(value)) || ("1".equals(value));
                            case AndroidBinXmlParser.VALUE_TYPE_REFERENCE:
                                // situation. Such APKs may put users at risk.
                                throw new DebuggableException("Unable to determine whether APK is debuggable" + ": " + ANDROID_MANIFEST_ZIP_ENTRY_NAME + "'s" + " android:debuggable attribute references a" + " resource. References are not supported for" + " security reasons. Only constant boolean," + " string and int values are supported.");
                            default:
                                throw new DebuggableException("Unable to determine whether APK is debuggable" + ": " + ANDROID_MANIFEST_ZIP_ENTRY_NAME + "'s" + " android:debuggable attribute uses" + " unsupported value type. Only boolean," + " string and int values are supported.");
                        }
                    }
                }
                // This application element does not declare the debuggable attribute
                return false;
            }
            eventType = parser.next();
        }
        // No application element found
        return false;
    } catch (AndroidBinXmlParser.XmlParserException e) {
        throw new DebuggableException("Unable to whether APK is debuggable: malformed binary resource: " + ANDROID_MANIFEST_ZIP_ENTRY_NAME, e);
    }
}
#method_after
public static boolean getDebuggableFromBinaryAndroidManifest(ByteBuffer androidManifestContents) throws ApkFormatException {
    try {
        AndroidBinXmlParser parser = new AndroidBinXmlParser(androidManifestContents);
        int eventType = parser.getEventType();
        while (eventType != AndroidBinXmlParser.EVENT_END_DOCUMENT) {
            if ((eventType == AndroidBinXmlParser.EVENT_START_ELEMENT) && (parser.getDepth() == 2) && ("application".equals(parser.getName())) && (parser.getNamespace().isEmpty())) {
                for (int i = 0; i < parser.getAttributeCount(); i++) {
                    if (parser.getAttributeNameResourceId(i) == DEBUGGABLE_ATTR_ID) {
                        int valueType = parser.getAttributeValueType(i);
                        switch(valueType) {
                            case AndroidBinXmlParser.VALUE_TYPE_BOOLEAN:
                            case AndroidBinXmlParser.VALUE_TYPE_STRING:
                            case AndroidBinXmlParser.VALUE_TYPE_INT:
                                String value = parser.getAttributeStringValue(i);
                                return ("true".equals(value)) || ("TRUE".equals(value)) || ("1".equals(value));
                            case AndroidBinXmlParser.VALUE_TYPE_REFERENCE:
                                // situation. Such APKs may put users at risk.
                                throw new ApkFormatException("Unable to determine whether APK is debuggable" + ": " + ANDROID_MANIFEST_ZIP_ENTRY_NAME + "'s" + " android:debuggable attribute references a" + " resource. References are not supported for" + " security reasons. Only constant boolean," + " string and int values are supported.");
                            default:
                                throw new ApkFormatException("Unable to determine whether APK is debuggable" + ": " + ANDROID_MANIFEST_ZIP_ENTRY_NAME + "'s" + " android:debuggable attribute uses" + " unsupported value type. Only boolean," + " string and int values are supported.");
                        }
                    }
                }
                // This application element does not declare the debuggable attribute
                return false;
            }
            eventType = parser.next();
        }
        // No application element found
        return false;
    } catch (AndroidBinXmlParser.XmlParserException e) {
        throw new ApkFormatException("Unable to determine whether APK is debuggable: malformed binary resource: " + ANDROID_MANIFEST_ZIP_ENTRY_NAME, e);
    }
}
#end_block

#method_before
public static int ioctlInt(FileDescriptor fd, int cmd, IoctlIntArg arg) throws ErrnoException {
    libcore.util.MutableInt internalArg = new libcore.util.MutableInt(arg.value);
    try {
        return Libcore.os.ioctlInt(fd, cmd, internalArg);
    } finally {
        arg.value = internalArg.value;
    }
}
#method_after
public static int ioctlInt(FileDescriptor fd, int cmd, Int32Ref arg) throws ErrnoException {
    libcore.util.MutableInt internalArg = new libcore.util.MutableInt(arg.value);
    try {
        return Libcore.os.ioctlInt(fd, cmd, internalArg);
    } finally {
        arg.value = internalArg.value;
    }
}
#end_block

#method_before
@Deprecated
public static long sendfile(FileDescriptor outFd, FileDescriptor inFd, MutableLong inOffset, long byteCount) throws ErrnoException {
    libcore.util.MutableLong internalInOffset = new libcore.util.MutableLong(inOffset.value);
    try {
        return Libcore.os.sendfile(outFd, inFd, internalInOffset, byteCount);
    } finally {
        inOffset.value = internalInOffset.value;
    }
}
#method_after
@Deprecated
public static long sendfile(FileDescriptor outFd, FileDescriptor inFd, MutableLong inOffset, long byteCount) throws ErrnoException {
    if (inOffset == null) {
        return Libcore.os.sendfile(outFd, inFd, null, byteCount);
    } else {
        libcore.util.MutableLong internalInOffset = new libcore.util.MutableLong(inOffset.value);
        try {
            return Libcore.os.sendfile(outFd, inFd, internalInOffset, byteCount);
        } finally {
            inOffset.value = internalInOffset.value;
        }
    }
}
#end_block

#method_before
public static long sendfile(FileDescriptor outFd, FileDescriptor inFd, SendfileOffset inOffset, long byteCount) throws ErrnoException {
    libcore.util.MutableLong internalInOffset = new libcore.util.MutableLong(inOffset.value);
    try {
        return Libcore.os.sendfile(outFd, inFd, internalInOffset, byteCount);
    } finally {
        inOffset.value = internalInOffset.value;
    }
}
#method_after
public static long sendfile(FileDescriptor outFd, FileDescriptor inFd, Int64Ref inOffset, long byteCount) throws ErrnoException {
    if (inOffset == null) {
        return Libcore.os.sendfile(outFd, inFd, null, byteCount);
    } else {
        libcore.util.MutableLong internalInOffset = new libcore.util.MutableLong(inOffset.value);
        try {
            return Libcore.os.sendfile(outFd, inFd, internalInOffset, byteCount);
        } finally {
            inOffset.value = internalInOffset.value;
        }
    }
}
#end_block

#method_before
public static int waitpid(int pid, WaitpidStatus status, int options) throws ErrnoException {
    if (status == null) {
        return Libcore.os.waitpid(pid, null, options);
    } else {
        libcore.util.MutableInt internalStatus = new libcore.util.MutableInt(status.value);
        try {
            return Libcore.os.waitpid(pid, internalStatus, options);
        } finally {
            status.value = internalStatus.value;
        }
    }
}
#method_after
public static int waitpid(int pid, Int32Ref status, int options) throws ErrnoException {
    if (status == null) {
        return Libcore.os.waitpid(pid, null, options);
    } else {
        libcore.util.MutableInt internalStatus = new libcore.util.MutableInt(status.value);
        try {
            return Libcore.os.waitpid(pid, internalStatus, options);
        } finally {
            status.value = internalStatus.value;
        }
    }
}
#end_block

#method_before
// http://b/26117827
// 
public void test_available_on_nonIOCTL_supported_file() throws Exception {
    File file = new File("/dev/zero");
    try (FileInputStream input = new FileInputStream(file)) {
        assertEquals(0, input.available());
    }
    try (FileInputStream input = new FileInputStream(file)) {
        android.system.Os.ioctlInt(input.getFD(), OsConstants.FIONREAD, new IoctlIntArg(0));
        fail();
    } catch (ErrnoException expected) {
        assertEquals("FIONREAD should have returned ENOTTY for the file. If it doesn't return" + " FIONREAD, the test is no longer valid.", OsConstants.ENOTTY, expected.errno);
    }
}
#method_after
// http://b/26117827
// 
public void test_available_on_nonIOCTL_supported_file() throws Exception {
    File file = new File("/dev/zero");
    try (FileInputStream input = new FileInputStream(file)) {
        assertEquals(0, input.available());
    }
    try (FileInputStream input = new FileInputStream(file)) {
        android.system.Os.ioctlInt(input.getFD(), OsConstants.FIONREAD, new Int32Ref(0));
        fail();
    } catch (ErrnoException expected) {
        assertEquals("FIONREAD should have returned ENOTTY for the file. If it doesn't return" + " FIONREAD, the test is no longer valid.", OsConstants.ENOTTY, expected.errno);
    }
}
#end_block

#method_before
public void test_sendfile_null() throws Exception {
    try {
        Libcore.os.sendfile(FileDescriptor.out, FileDescriptor.in, null, 0);
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
public void test_sendfile_null() throws Exception {
    File in = createTempFile("test_sendfile_null", "Hello, world!");
    try {
        int len = "Hello".length();
        assertEquals("Hello", checkSendfile(ANDROID_SYSTEM_OS_MUTABLE_LONG, in, null, len, null));
        assertEquals("Hello", checkSendfile(ANDROID_SYSTEM_OS_INT64_REF, in, null, len, null));
        assertEquals("Hello", checkSendfile(LIBCORE_OS, in, null, len, null));
    } finally {
        in.delete();
    }
}
#end_block

#method_before
public String getOperatorBrandOverride() {
    String iccId = getIccId();
    if (TextUtils.isEmpty(iccId)) {
        return null;
    }
    SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
    String brandName = sp.getString(OPERATOR_BRAND_OVERRIDE_PREFIX + iccId, null);
    if (brandName == null) {
        // Check if  CarrierConfig sets carrier name
        CarrierConfigManager manager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
        int subId = SubscriptionController.getInstance().getSubIdUsingPhoneId(mPhoneId);
        PersistableBundle bundle = manager.getConfigForSubId(subId);
        if (bundle != null && bundle.getBoolean(CarrierConfigManager.KEY_CARRIER_NAME_OVERRIDE_BOOL)) {
            brandName = bundle.getString(CarrierConfigManager.KEY_CARRIER_NAME_STRING);
        }
    }
    return brandName;
}
#method_after
public String getOperatorBrandOverride() {
    String iccId = getIccId();
    if (TextUtils.isEmpty(iccId)) {
        return null;
    }
    SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
    String brandName = sp.getString(OPERATOR_BRAND_OVERRIDE_PREFIX + iccId, null);
    if (brandName == null) {
        // Check if  CarrierConfig sets carrier name
        CarrierConfigManager manager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
        int subId = SubscriptionController.getInstance().getSubIdUsingPhoneId(mPhoneId);
        if (manager != null) {
            PersistableBundle bundle = manager.getConfigForSubId(subId);
            if (bundle != null && bundle.getBoolean(CarrierConfigManager.KEY_CARRIER_NAME_OVERRIDE_BOOL)) {
                brandName = bundle.getString(CarrierConfigManager.KEY_CARRIER_NAME_STRING);
            }
        }
    }
    return brandName;
}
#end_block

#method_before
public void test_sendfile_null() throws Exception {
    File in = createTempFile("test_sendfile_null", "Hello, world!");
    try {
        assertEquals("Hello", checkSendfile(true, in, null, "Hello".length()));
        assertEquals("Hello", checkSendfile(false, in, null, "Hello".length()));
    } finally {
        in.delete();
    }
}
#method_after
public void test_sendfile_null() throws Exception {
    File in = createTempFile("test_sendfile_null", "Hello, world!");
    try {
        int len = "Hello".length();
        assertEquals("Hello", checkSendfile(true, in, null, len, null));
        assertEquals("Hello", checkSendfile(false, in, null, len, null));
    } finally {
        in.delete();
    }
}
#end_block

#method_before
public void test_sendfile_offset() throws Exception {
    File in = createTempFile("test_sendfile_offset", "Hello, world!");
    try {
        // checkSendfile(useSystemOs, in, _offset, maxBytes)
        assertEquals("Hello", checkSendfile(true, in, 0L, 5));
        assertEquals("Hello", checkSendfile(false, in, 0L, 5));
        assertEquals("ello,", checkSendfile(true, in, 1L, 5));
        assertEquals("ello,", checkSendfile(false, in, 1L, 5));
        assertEquals("rld!", checkSendfile(true, in, (long) "Hello, wo".length(), 5));
        assertEquals("rld!", checkSendfile(false, in, (long) "Hello, wo".length(), 5));
        assertEquals("", checkSendfile(true, in, 1L, 0));
        assertEquals("", checkSendfile(false, in, 1L, 0));
    } finally {
        in.delete();
    }
}
#method_after
public void test_sendfile_offset() throws Exception {
    File in = createTempFile("test_sendfile_offset", "Hello, world!");
    try {
        // checkSendfile(useSystemOs, in, startOffset, maxBytes, expectedEndOffset)
        assertEquals("Hello", checkSendfile(true, in, 0L, 5, 5L));
        assertEquals("Hello", checkSendfile(false, in, 0L, 5, 5L));
        assertEquals("ello,", checkSendfile(true, in, 1L, 5, 6L));
        assertEquals("ello,", checkSendfile(false, in, 1L, 5, 6L));
        // At offset 9, only 4 bytes/chars available, even though we're asking for 5.
        assertEquals("rld!", checkSendfile(true, in, 9L, 5, 13L));
        assertEquals("rld!", checkSendfile(false, in, 9L, 5, 13L));
        assertEquals("", checkSendfile(true, in, 1L, 0, 1L));
        assertEquals("", checkSendfile(false, in, 1L, 0, 1L));
    } finally {
        in.delete();
    }
}
#end_block

#method_before
private static String checkSendfile(boolean useSystemOs, File in, Long _offset, int maxBytes) throws IOException, ErrnoException {
    File out = File.createTempFile(OsTest.class.getSimpleName(), "checkSendfile.out");
    try (FileInputStream inStream = new FileInputStream(in)) {
        FileDescriptor inFd = inStream.getFD();
        try (FileOutputStream outStream = new FileOutputStream(out)) {
            FileDescriptor outFd = outStream.getFD();
            if (useSystemOs) {
                android.util.MutableLong offset = (_offset == null) ? null : new android.util.MutableLong(_offset);
                android.system.Os.sendfile(outFd, inFd, offset, maxBytes);
            } else {
                libcore.util.MutableLong offset = (_offset == null) ? null : new libcore.util.MutableLong(_offset);
                libcore.io.Libcore.os.sendfile(outFd, inFd, offset, maxBytes);
            }
        }
        return IoUtils.readFileAsString(out.getPath());
    } finally {
        out.delete();
    }
}
#method_after
private static String checkSendfile(boolean useSystemOs, File in, Long startOffset, int maxBytes, Long expectedEndOffset) throws IOException, ErrnoException {
    File out = File.createTempFile(OsTest.class.getSimpleName(), "checkSendfile.out");
    try (FileInputStream inStream = new FileInputStream(in)) {
        FileDescriptor inFd = inStream.getFD();
        try (FileOutputStream outStream = new FileOutputStream(out)) {
            FileDescriptor outFd = outStream.getFD();
            if (useSystemOs) {
                android.util.MutableLong offset = (startOffset == null) ? null : new android.util.MutableLong(startOffset);
                android.system.Os.sendfile(outFd, inFd, offset, maxBytes);
                assertEquals(expectedEndOffset, offset == null ? null : offset.value);
            } else {
                libcore.util.MutableLong offset = (startOffset == null) ? null : new libcore.util.MutableLong(startOffset);
                libcore.io.Libcore.os.sendfile(outFd, inFd, offset, maxBytes);
                assertEquals(expectedEndOffset, offset == null ? null : offset.value);
            }
        }
        return IoUtils.readFileAsString(out.getPath());
    } finally {
        out.delete();
    }
}
#end_block

#method_before
@Override
public void setDnsConfigurationForNetwork(int netId, String[] servers, String domains) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    final ContentResolver cr = mContext.getContentResolver();
    int sampleValidity = Settings.Global.getInt(cr, Settings.Global.DNS_RESOLVER_SAMPLE_VALIDITY_SECONDS, DNS_RESOLVER_DEFAULT_SAMPLE_VALIDITY_SECONDS);
    if (sampleValidity < 0 || sampleValidity > 65535) {
        Slog.w(TAG, "Invalid sampleValidity=" + sampleValidity + ", using default=" + DNS_RESOLVER_DEFAULT_SAMPLE_VALIDITY_SECONDS);
        sampleValidity = DNS_RESOLVER_DEFAULT_SAMPLE_VALIDITY_SECONDS;
    }
    int successThreshold = Settings.Global.getInt(cr, Settings.Global.DNS_RESOLVER_SUCCESS_THRESHOLD_PERCENT, DNS_RESOLVER_DEFAULT_SUCCESS_THRESHOLD_PERCENT);
    if (successThreshold < 0 || successThreshold > 100) {
        Slog.w(TAG, "Invalid successThreshold=" + successThreshold + ", using default=" + DNS_RESOLVER_DEFAULT_SUCCESS_THRESHOLD_PERCENT);
        successThreshold = DNS_RESOLVER_DEFAULT_SUCCESS_THRESHOLD_PERCENT;
    }
    int minSamples = Settings.Global.getInt(cr, Settings.Global.DNS_RESOLVER_MIN_SAMPLES, DNS_RESOLVER_DEFAULT_MIN_SAMPLES);
    int maxSamples = Settings.Global.getInt(cr, Settings.Global.DNS_RESOLVER_MAX_SAMPLES, DNS_RESOLVER_DEFAULT_MAX_SAMPLES);
    if (minSamples < 0 || minSamples > maxSamples || maxSamples > 64) {
        Slog.w(TAG, "Invalid sample count (min, max)=(" + minSamples + ", " + maxSamples + "), using default=(" + DNS_RESOLVER_DEFAULT_MIN_SAMPLES + ", " + DNS_RESOLVER_DEFAULT_MAX_SAMPLES + ")");
        minSamples = DNS_RESOLVER_DEFAULT_MIN_SAMPLES;
        maxSamples = DNS_RESOLVER_DEFAULT_MAX_SAMPLES;
    }
    final String[] domainStrs = domains == null ? new String[0] : domains.split(" ");
    final int[] params = { sampleValidity, successThreshold, minSamples, maxSamples };
    final boolean useTls = shouldUseTls(cr);
    final String tlsHostname = "";
    final String[] tlsFingerprints = new String[0];
    try {
        mNetdService.setResolverConfiguration(netId, servers, domainStrs, params, useTls, tlsHostname, tlsFingerprints);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
#method_after
@Override
public void setDnsConfigurationForNetwork(int netId, String[] servers, String domains) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    final ContentResolver cr = mContext.getContentResolver();
    int sampleValidity = Settings.Global.getInt(cr, Settings.Global.DNS_RESOLVER_SAMPLE_VALIDITY_SECONDS, DNS_RESOLVER_DEFAULT_SAMPLE_VALIDITY_SECONDS);
    if (sampleValidity < 0 || sampleValidity > 65535) {
        Slog.w(TAG, "Invalid sampleValidity=" + sampleValidity + ", using default=" + DNS_RESOLVER_DEFAULT_SAMPLE_VALIDITY_SECONDS);
        sampleValidity = DNS_RESOLVER_DEFAULT_SAMPLE_VALIDITY_SECONDS;
    }
    int successThreshold = Settings.Global.getInt(cr, Settings.Global.DNS_RESOLVER_SUCCESS_THRESHOLD_PERCENT, DNS_RESOLVER_DEFAULT_SUCCESS_THRESHOLD_PERCENT);
    if (successThreshold < 0 || successThreshold > 100) {
        Slog.w(TAG, "Invalid successThreshold=" + successThreshold + ", using default=" + DNS_RESOLVER_DEFAULT_SUCCESS_THRESHOLD_PERCENT);
        successThreshold = DNS_RESOLVER_DEFAULT_SUCCESS_THRESHOLD_PERCENT;
    }
    int minSamples = Settings.Global.getInt(cr, Settings.Global.DNS_RESOLVER_MIN_SAMPLES, DNS_RESOLVER_DEFAULT_MIN_SAMPLES);
    int maxSamples = Settings.Global.getInt(cr, Settings.Global.DNS_RESOLVER_MAX_SAMPLES, DNS_RESOLVER_DEFAULT_MAX_SAMPLES);
    if (minSamples < 0 || minSamples > maxSamples || maxSamples > 64) {
        Slog.w(TAG, "Invalid sample count (min, max)=(" + minSamples + ", " + maxSamples + "), using default=(" + DNS_RESOLVER_DEFAULT_MIN_SAMPLES + ", " + DNS_RESOLVER_DEFAULT_MAX_SAMPLES + ")");
        minSamples = DNS_RESOLVER_DEFAULT_MIN_SAMPLES;
        maxSamples = DNS_RESOLVER_DEFAULT_MAX_SAMPLES;
    }
    final String[] domainStrs = domains == null ? new String[0] : domains.split(" ");
    final int[] params = { sampleValidity, successThreshold, minSamples, maxSamples };
    final boolean useTls = shouldUseTls(cr);
    // TODO: Populate tlsHostname once it's decided how the hostname's IP
    // addresses will be resolved:
    // 
    // [1] network-provided DNS servers are included here with the
    // hostname and netd will use the network-provided servers to
    // resolve the hostname and fix up its internal structures, or
    // 
    // [2] network-provided DNS servers are included here without the
    // hostname, the ConnectivityService layer resolves the given
    // hostname, and then reconfigures netd with this information.
    // 
    // In practice, there will always be a need for ConnectivityService or
    // the captive portal app to use the network-provided services to make
    // some queries. This argues in favor of [1], in concert with another
    // mechanism, perhaps setting a high bit in the netid, to indicate
    // via existing DNS APIs which set of servers (network-provided or
    // non-network-provided private DNS) should be queried.
    final String tlsHostname = "";
    final String[] tlsFingerprints = new String[0];
    try {
        mNetdService.setResolverConfiguration(netId, servers, domainStrs, params, useTls, tlsHostname, tlsFingerprints);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
private static boolean shouldUseTls(ContentResolver cr) {
    String private_dns = Settings.Global.getString(cr, Settings.Global.PRIVATE_DNS_MODE);
    if (TextUtils.isEmpty(private_dns)) {
        // The default is to "opportunistically" attempt things like
        // DNS-over-TLS (and possibly other protocols in the future).
        private_dns = PRIVATE_DNS_MODE_OPPORTUNISTIC;
    }
    return private_dns.equals(PRIVATE_DNS_MODE_OPPORTUNISTIC) || private_dns.startsWith(PRIVATE_DNS_MODE_PROVIDER_HOSTNAME);
}
#method_after
private static boolean shouldUseTls(ContentResolver cr) {
    String privateDns = Settings.Global.getString(cr, Settings.Global.PRIVATE_DNS_MODE);
    if (TextUtils.isEmpty(privateDns)) {
        privateDns = PRIVATE_DNS_DEFAULT_MODE;
    }
    return privateDns.equals(PRIVATE_DNS_MODE_OPPORTUNISTIC) || privateDns.startsWith(PRIVATE_DNS_MODE_PROVIDER_HOSTNAME);
}
#end_block

#method_before
@Override
protected void onBindDialogView(View view) {
    final String settingsValue = getSettingsString();
    RadioButton rb = (RadioButton) view.findViewById(R.id.private_dns_mode_off);
    if (settingsValue.equals(PRIVATE_DNS_MODE_OFF))
        rb.setChecked(true);
    rb.setOnCheckedChangeListener(this);
    rb = (RadioButton) view.findViewById(R.id.private_dns_mode_opportunistic);
    if (settingsValue.equals(PRIVATE_DNS_MODE_OPPORTUNISTIC))
        rb.setChecked(true);
    rb.setOnCheckedChangeListener(this);
    rb = (RadioButton) view.findViewById(R.id.private_dns_mode_provider);
    if (settingsValue.startsWith(PRIVATE_DNS_MODE_PROVIDER_HOSTNAME))
        rb.setChecked(true);
    rb.setOnCheckedChangeListener(this);
    mEditText = (EditText) view.findViewById(R.id.private_dns_mode_provider_hostname);
    mEditText.setOnEditorActionListener((TextView tv, int actionId, KeyEvent k) -> {
        if (actionId == EditorInfo.IME_ACTION_DONE) {
            saveDialogValue();
            PrivateDnsModeDialogPreference.this.getDialog().dismiss();
            return true;
        }
        return false;
    });
    mEditText.addTextChangedListener(this);
    // (Mostly) Fix the EditText field's indentation to align underneath the
    // displayed radio button text, and not under the radio button itself.
    final int padding = rb.isLayoutRtl() ? rb.getCompoundPaddingRight() : rb.getCompoundPaddingLeft();
    final MarginLayoutParams marginParams = (MarginLayoutParams) mEditText.getLayoutParams();
    marginParams.setMarginStart(marginParams.getMarginStart() + padding);
    mEditText.setLayoutParams(marginParams);
    if (settingsValue.startsWith(PRIVATE_DNS_MODE_PROVIDER_HOSTNAME)) {
        mEditText.setEnabled(true);
        mEditText.setText(getHostname(settingsValue));
    } else {
        mEditText.setEnabled(false);
    }
}
#method_after
@Override
protected void onBindDialogView(View view) {
    final String mode = getModeFromSettings();
    RadioButton rb = (RadioButton) view.findViewById(R.id.private_dns_mode_off);
    if (mode.equals(PRIVATE_DNS_MODE_OFF))
        rb.setChecked(true);
    rb.setOnCheckedChangeListener(this);
    rb = (RadioButton) view.findViewById(R.id.private_dns_mode_opportunistic);
    if (mode.equals(PRIVATE_DNS_MODE_OPPORTUNISTIC))
        rb.setChecked(true);
    rb.setOnCheckedChangeListener(this);
    rb = (RadioButton) view.findViewById(R.id.private_dns_mode_provider);
    if (mode.equals(PRIVATE_DNS_MODE_PROVIDER_HOSTNAME))
        rb.setChecked(true);
    rb.setOnCheckedChangeListener(this);
    mEditText = (EditText) view.findViewById(R.id.private_dns_mode_provider_hostname);
    mEditText.setOnEditorActionListener(this);
    mEditText.addTextChangedListener(this);
    // (Mostly) Fix the EditText field's indentation to align underneath the
    // displayed radio button text, and not under the radio button itself.
    final int padding = rb.isLayoutRtl() ? rb.getCompoundPaddingRight() : rb.getCompoundPaddingLeft();
    final MarginLayoutParams marginParams = (MarginLayoutParams) mEditText.getLayoutParams();
    marginParams.setMarginStart(marginParams.getMarginStart() + padding);
    mEditText.setLayoutParams(marginParams);
    mEditText.setText(getHostnameFromSettings());
    setDialogValue(mode);
}
#end_block

#method_before
@Override
protected void onDialogClosed(boolean positiveResult) {
    if (positiveResult && !TextUtils.isEmpty(mDialogValue)) {
        saveDialogValue();
    }
}
#method_after
@Override
protected void onDialogClosed(boolean positiveResult) {
    if (!positiveResult)
        return;
    saveDialogValue();
    setSummary(getSummaryStringForModeFromSettings(getContext().getContentResolver(), getContext().getResources()));
}
#end_block

#method_before
@Override
public void afterTextChanged(Editable s) {
    final String hostname = s.toString();
    if (isWeaklyValidatedHostname(hostname))
        return;
// TODO: Display something like an "!" somewhere and clear it when the
// hostname appears valid.
}
#method_after
@Override
public void afterTextChanged(Editable s) {
    final String hostname = s.toString();
    final boolean appearsValid = isWeaklyValidatedHostname(hostname);
// TODO: Disable the "positive button" ("Save") when appearsValid is false.
}
#end_block

#method_before
private void setDialogValue(String mode) {
    mDialogValue = mode;
    final boolean txtEnabled = mDialogValue.startsWith(PRIVATE_DNS_MODE_PROVIDER_HOSTNAME);
    mEditText.setEnabled(txtEnabled);
}
#method_after
private void setDialogValue(String mode) {
    mMode = mode;
    final boolean txtEnabled = mMode.equals(PRIVATE_DNS_MODE_PROVIDER_HOSTNAME);
    mEditText.setEnabled(txtEnabled);
}
#end_block

#method_before
private void saveDialogValue() {
    if (!isValidMode(mDialogValue)) {
        mDialogValue = DEFAULT_MODE;
    }
    if (mDialogValue.startsWith(PRIVATE_DNS_MODE_PROVIDER_HOSTNAME)) {
        final String hostname = mEditText.getText().toString();
        if (isWeaklyValidatedHostname(hostname)) {
            mDialogValue = PRIVATE_DNS_MODE_PROVIDER_HOSTNAME + hostname;
        } else {
            mDialogValue = PRIVATE_DNS_MODE_OPPORTUNISTIC;
        }
    }
    Log.w(TAG, String.format("Setting %s=%s", SETTINGS_KEY, mDialogValue));
    putSettingsString(mDialogValue);
}
#method_after
private void saveDialogValue() {
    if (!isValidMode(mMode)) {
        mMode = PRIVATE_DNS_DEFAULT_MODE;
    }
    if (mMode.equals(PRIVATE_DNS_MODE_PROVIDER_HOSTNAME)) {
        final String hostname = mEditText.getText().toString();
        if (isWeaklyValidatedHostname(hostname)) {
            saveHostnameToSettings(hostname);
        } else {
            // TODO: Once quasi-validation of hostnames works and acceptable
            // user signaling is working, this can be deleted.
            mMode = PRIVATE_DNS_MODE_OPPORTUNISTIC;
            if (TextUtils.isEmpty(hostname))
                saveHostnameToSettings("");
        }
    }
    saveModeToSettings(mMode);
}
#end_block

#method_before
private static boolean isValidMode(String mode) {
    return !TextUtils.isEmpty(mode) && (mode.equals(PRIVATE_DNS_MODE_OFF) || mode.equals(PRIVATE_DNS_MODE_OPPORTUNISTIC) || mode.startsWith(PRIVATE_DNS_MODE_PROVIDER_HOSTNAME));
}
#method_after
private static boolean isValidMode(String mode) {
    return !TextUtils.isEmpty(mode) && (mode.equals(PRIVATE_DNS_MODE_OFF) || mode.equals(PRIVATE_DNS_MODE_OPPORTUNISTIC) || mode.equals(PRIVATE_DNS_MODE_PROVIDER_HOSTNAME));
}
#end_block

#method_before
private static boolean isWeaklyValidatedHostname(String hostname) {
    // TODO: Make stronger.
    final String WEAK_HOSTNAME_REGEX = "^[a-zA-Z0-9_.-]+$";
    return hostname.matches(WEAK_HOSTNAME_REGEX);
}
#method_after
private static boolean isWeaklyValidatedHostname(String hostname) {
    // TODO: Find and use a better validation method.  Specifically:
    // [1] this should reject IP string literals, and
    // [2] do the best, simplest, future-proof verification that
    // the input approximates a DNS hostname.
    final String WEAK_HOSTNAME_REGEX = "^[a-zA-Z0-9_.-]+$";
    return hostname.matches(WEAK_HOSTNAME_REGEX);
}
#end_block

#method_before
@Override
public void onCreate(Bundle icicle) {
    super.onCreate(icicle);
    mWindowManager = IWindowManager.Stub.asInterface(ServiceManager.getService("window"));
    mBackupManager = IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
    mWebViewUpdateService = WebViewFactory.getUpdateService();
    mOemLockManager = (OemLockManager) getSystemService(Context.OEM_LOCK_SERVICE);
    mTelephonyManager = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
    mUm = (UserManager) getSystemService(Context.USER_SERVICE);
    mWifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);
    mBugReportController = new BugReportPreferenceController(getActivity());
    mBugReportInPowerController = new BugReportInPowerPreferenceController(getActivity());
    mTelephonyMonitorController = new TelephonyMonitorPreferenceController(getActivity());
    mWebViewAppPrefController = new WebViewAppPreferenceController(getActivity());
    mVerifyAppsOverUsbController = new VerifyAppsOverUsbPreferenceController(getActivity());
    setIfOnlyAvailableForAdmins(true);
    if (isUiRestricted() || !Utils.isDeviceProvisioned(getActivity())) {
        // Block access to developer options if the user is not the owner, if user policy
        // restricts it, or if the device has not been provisioned
        mUnavailable = true;
        addPreferencesFromResource(R.xml.placeholder_prefs);
        return;
    }
    addPreferencesFromResource(R.xml.development_prefs);
    final PreferenceGroup debugDebuggingCategory = (PreferenceGroup) findPreference(DEBUG_DEBUGGING_CATEGORY_KEY);
    mEnableAdb = findAndInitSwitchPref(ENABLE_ADB);
    mClearAdbKeys = findPreference(CLEAR_ADB_KEYS);
    if (!SystemProperties.getBoolean("ro.adb.secure", false)) {
        if (debugDebuggingCategory != null) {
            debugDebuggingCategory.removePreference(mClearAdbKeys);
        }
    }
    mAllPrefs.add(mClearAdbKeys);
    mEnableTerminal = findAndInitSwitchPref(ENABLE_TERMINAL);
    if (!isPackageInstalled(getActivity(), TERMINAL_APP_PACKAGE)) {
        debugDebuggingCategory.removePreference(mEnableTerminal);
        mEnableTerminal = null;
    }
    mBugReportController.displayPreference(getPreferenceScreen());
    mBugReportInPowerController.displayPreference(getPreferenceScreen());
    mTelephonyMonitorController.displayPreference(getPreferenceScreen());
    mWebViewAppPrefController.displayPreference(getPreferenceScreen());
    mKeepScreenOn = (RestrictedSwitchPreference) findAndInitSwitchPref(KEEP_SCREEN_ON);
    mBtHciSnoopLog = findAndInitSwitchPref(BT_HCI_SNOOP_LOG);
    mEnableOemUnlock = (RestrictedSwitchPreference) findAndInitSwitchPref(ENABLE_OEM_UNLOCK);
    if (!showEnableOemUnlockPreference(getActivity())) {
        removePreference(mEnableOemUnlock);
        mEnableOemUnlock = null;
    }
    mDebugViewAttributes = findAndInitSwitchPref(DEBUG_VIEW_ATTRIBUTES);
    mForceAllowOnExternal = findAndInitSwitchPref(FORCE_ALLOW_ON_EXTERNAL_KEY);
    mPassword = findPreference(LOCAL_BACKUP_PASSWORD);
    mAllPrefs.add(mPassword);
    if (!mUm.isAdminUser()) {
        disableForUser(mEnableAdb);
        disableForUser(mClearAdbKeys);
        disableForUser(mEnableTerminal);
        disableForUser(mPassword);
    }
    mDebugAppPref = findPreference(DEBUG_APP_KEY);
    mAllPrefs.add(mDebugAppPref);
    mWaitForDebugger = findAndInitSwitchPref(WAIT_FOR_DEBUGGER_KEY);
    mMockLocationAppPref = findPreference(MOCK_LOCATION_APP_KEY);
    mAllPrefs.add(mMockLocationAppPref);
    mVerifyAppsOverUsbController.displayPreference(getPreferenceScreen());
    mStrictMode = findAndInitSwitchPref(STRICT_MODE_KEY);
    mPointerLocation = findAndInitSwitchPref(POINTER_LOCATION_KEY);
    mShowTouches = findAndInitSwitchPref(SHOW_TOUCHES_KEY);
    mShowScreenUpdates = findAndInitSwitchPref(SHOW_SCREEN_UPDATES_KEY);
    mDisableOverlays = findAndInitSwitchPref(DISABLE_OVERLAYS_KEY);
    mForceHardwareUi = findAndInitSwitchPref(FORCE_HARDWARE_UI_KEY);
    mForceMsaa = findAndInitSwitchPref(FORCE_MSAA_KEY);
    mTrackFrameTime = addListPreference(TRACK_FRAME_TIME_KEY);
    mShowNonRectClip = addListPreference(SHOW_NON_RECTANGULAR_CLIP_KEY);
    mShowHwScreenUpdates = findAndInitSwitchPref(SHOW_HW_SCREEN_UPDATES_KEY);
    mShowHwLayersUpdates = findAndInitSwitchPref(SHOW_HW_LAYERS_UPDATES_KEY);
    mDebugLayout = findAndInitSwitchPref(DEBUG_LAYOUT_KEY);
    mForceRtlLayout = findAndInitSwitchPref(FORCE_RTL_LAYOUT_KEY);
    mDebugHwOverdraw = addListPreference(DEBUG_HW_OVERDRAW_KEY);
    mDebugHwRenderer = addListPreference(DEBUG_HW_RENDERER_KEY);
    mWifiDisplayCertification = findAndInitSwitchPref(WIFI_DISPLAY_CERTIFICATION_KEY);
    mWifiVerboseLogging = findAndInitSwitchPref(WIFI_VERBOSE_LOGGING_KEY);
    mWifiAggressiveHandover = findAndInitSwitchPref(WIFI_AGGRESSIVE_HANDOVER_KEY);
    mWifiAllowScansWithTraffic = findAndInitSwitchPref(WIFI_ALLOW_SCAN_WITH_TRAFFIC_KEY);
    mMobileDataAlwaysOn = findAndInitSwitchPref(MOBILE_DATA_ALWAYS_ON);
    mTetheringHardwareOffload = findAndInitSwitchPref(TETHERING_HARDWARE_OFFLOAD);
    mLogdSize = addListPreference(SELECT_LOGD_SIZE_KEY);
    if ("1".equals(SystemProperties.get("ro.debuggable", "0"))) {
        mLogpersist = addListPreference(SELECT_LOGPERSIST_KEY);
    } else {
        mLogpersist = (ListPreference) findPreference(SELECT_LOGPERSIST_KEY);
        if (mLogpersist != null) {
            mLogpersist.setEnabled(false);
            if (debugDebuggingCategory != null) {
                debugDebuggingCategory.removePreference(mLogpersist);
            }
        }
        mLogpersist = null;
    }
    mUsbConfiguration = addListPreference(USB_CONFIGURATION_KEY);
    mBluetoothDisableAbsVolume = findAndInitSwitchPref(BLUETOOTH_DISABLE_ABSOLUTE_VOLUME_KEY);
    mBluetoothEnableInbandRinging = findAndInitSwitchPref(BLUETOOTH_ENABLE_INBAND_RINGING_KEY);
    if (!BluetoothHeadset.isInbandRingingSupported(getContext())) {
        removePreference(mBluetoothEnableInbandRinging);
        mBluetoothEnableInbandRinging = null;
    }
    mBluetoothSelectAvrcpVersion = addListPreference(BLUETOOTH_SELECT_AVRCP_VERSION_KEY);
    mBluetoothSelectA2dpCodec = addListPreference(BLUETOOTH_SELECT_A2DP_CODEC_KEY);
    mBluetoothSelectA2dpSampleRate = addListPreference(BLUETOOTH_SELECT_A2DP_SAMPLE_RATE_KEY);
    mBluetoothSelectA2dpBitsPerSample = addListPreference(BLUETOOTH_SELECT_A2DP_BITS_PER_SAMPLE_KEY);
    mBluetoothSelectA2dpChannelMode = addListPreference(BLUETOOTH_SELECT_A2DP_CHANNEL_MODE_KEY);
    mBluetoothSelectA2dpLdacPlaybackQuality = addListPreference(BLUETOOTH_SELECT_A2DP_LDAC_PLAYBACK_QUALITY_KEY);
    initBluetoothConfigurationValues();
    mWindowAnimationScale = addListPreference(WINDOW_ANIMATION_SCALE_KEY);
    mTransitionAnimationScale = addListPreference(TRANSITION_ANIMATION_SCALE_KEY);
    mAnimatorDurationScale = addListPreference(ANIMATOR_DURATION_SCALE_KEY);
    mOverlayDisplayDevices = addListPreference(OVERLAY_DISPLAY_DEVICES_KEY);
    mSimulateColorSpace = addListPreference(SIMULATE_COLOR_SPACE);
    mUSBAudio = findAndInitSwitchPref(USB_AUDIO_KEY);
    mForceResizable = findAndInitSwitchPref(FORCE_RESIZABLE_KEY);
    mImmediatelyDestroyActivities = (SwitchPreference) findPreference(IMMEDIATELY_DESTROY_ACTIVITIES_KEY);
    mAllPrefs.add(mImmediatelyDestroyActivities);
    mResetSwitchPrefs.add(mImmediatelyDestroyActivities);
    mAppProcessLimit = addListPreference(APP_PROCESS_LIMIT_KEY);
    mShowAllANRs = (SwitchPreference) findPreference(SHOW_ALL_ANRS_KEY);
    mAllPrefs.add(mShowAllANRs);
    mResetSwitchPrefs.add(mShowAllANRs);
    mShowNotificationChannelWarnings = (SwitchPreference) findPreference(SHOW_NOTIFICATION_CHANNEL_WARNINGS_KEY);
    mAllPrefs.add(mShowNotificationChannelWarnings);
    mResetSwitchPrefs.add(mShowNotificationChannelWarnings);
    Preference hdcpChecking = findPreference(HDCP_CHECKING_KEY);
    if (hdcpChecking != null) {
        mAllPrefs.add(hdcpChecking);
        removePreferenceForProduction(hdcpChecking);
    }
    Preference convertFbePreference = findPreference(KEY_CONVERT_FBE);
    try {
        IBinder service = ServiceManager.getService("mount");
        IStorageManager storageManager = IStorageManager.Stub.asInterface(service);
        if (!storageManager.isConvertibleToFBE()) {
            removePreference(KEY_CONVERT_FBE);
        } else if ("file".equals(SystemProperties.get("ro.crypto.type", "none"))) {
            convertFbePreference.setEnabled(false);
            convertFbePreference.setSummary(getResources().getString(R.string.convert_to_file_encryption_done));
        }
    } catch (RemoteException e) {
        removePreference(KEY_CONVERT_FBE);
    }
    mOtaDisableAutomaticUpdate = findAndInitSwitchPref(OTA_DISABLE_AUTOMATIC_UPDATE_KEY);
    mColorModePreference = (ColorModePreference) findPreference(KEY_COLOR_MODE);
    mColorModePreference.updateCurrentAndSupported();
    if (mColorModePreference.getColorModeCount() < 2 || getContext().getDisplay().isWideColorGamut()) {
        removePreference(KEY_COLOR_MODE);
        mColorModePreference = null;
    }
    mColorTemperaturePreference = (SwitchPreference) findPreference(COLOR_TEMPERATURE_KEY);
    if (getResources().getBoolean(R.bool.config_enableColorTemperature)) {
        mAllPrefs.add(mColorTemperaturePreference);
        mResetSwitchPrefs.add(mColorTemperaturePreference);
    } else {
        removePreference(COLOR_TEMPERATURE_KEY);
        mColorTemperaturePreference = null;
    }
    addDashboardCategoryPreferences();
}
#method_after
@Override
public void onCreate(Bundle icicle) {
    super.onCreate(icicle);
    mWindowManager = IWindowManager.Stub.asInterface(ServiceManager.getService("window"));
    mBackupManager = IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
    mWebViewUpdateService = WebViewFactory.getUpdateService();
    mOemLockManager = (OemLockManager) getSystemService(Context.OEM_LOCK_SERVICE);
    mTelephonyManager = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
    mUm = (UserManager) getSystemService(Context.USER_SERVICE);
    mWifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);
    mBugReportController = new BugReportPreferenceController(getActivity());
    mBugReportInPowerController = new BugReportInPowerPreferenceController(getActivity());
    mTelephonyMonitorController = new TelephonyMonitorPreferenceController(getActivity());
    mWebViewAppPrefController = new WebViewAppPreferenceController(getActivity());
    mVerifyAppsOverUsbController = new VerifyAppsOverUsbPreferenceController(getActivity());
    setIfOnlyAvailableForAdmins(true);
    if (isUiRestricted() || !Utils.isDeviceProvisioned(getActivity())) {
        // Block access to developer options if the user is not the owner, if user policy
        // restricts it, or if the device has not been provisioned
        mUnavailable = true;
        addPreferencesFromResource(R.xml.placeholder_prefs);
        return;
    }
    addPreferencesFromResource(R.xml.development_prefs);
    final PreferenceGroup debugDebuggingCategory = (PreferenceGroup) findPreference(DEBUG_DEBUGGING_CATEGORY_KEY);
    mEnableAdb = findAndInitSwitchPref(ENABLE_ADB);
    mClearAdbKeys = findPreference(CLEAR_ADB_KEYS);
    if (!SystemProperties.getBoolean("ro.adb.secure", false)) {
        if (debugDebuggingCategory != null) {
            debugDebuggingCategory.removePreference(mClearAdbKeys);
        }
    }
    mAllPrefs.add(mClearAdbKeys);
    mEnableTerminal = findAndInitSwitchPref(ENABLE_TERMINAL);
    if (!isPackageInstalled(getActivity(), TERMINAL_APP_PACKAGE)) {
        debugDebuggingCategory.removePreference(mEnableTerminal);
        mEnableTerminal = null;
    }
    mBugReportController.displayPreference(getPreferenceScreen());
    mBugReportInPowerController.displayPreference(getPreferenceScreen());
    mTelephonyMonitorController.displayPreference(getPreferenceScreen());
    mWebViewAppPrefController.displayPreference(getPreferenceScreen());
    mKeepScreenOn = (RestrictedSwitchPreference) findAndInitSwitchPref(KEEP_SCREEN_ON);
    mBtHciSnoopLog = findAndInitSwitchPref(BT_HCI_SNOOP_LOG);
    mEnableOemUnlock = (RestrictedSwitchPreference) findAndInitSwitchPref(ENABLE_OEM_UNLOCK);
    if (!showEnableOemUnlockPreference(getActivity())) {
        removePreference(mEnableOemUnlock);
        mEnableOemUnlock = null;
    }
    mDebugViewAttributes = findAndInitSwitchPref(DEBUG_VIEW_ATTRIBUTES);
    mForceAllowOnExternal = findAndInitSwitchPref(FORCE_ALLOW_ON_EXTERNAL_KEY);
    mPassword = findPreference(LOCAL_BACKUP_PASSWORD);
    mAllPrefs.add(mPassword);
    if (!mUm.isAdminUser()) {
        disableForUser(mEnableAdb);
        disableForUser(mClearAdbKeys);
        disableForUser(mEnableTerminal);
        disableForUser(mPassword);
    }
    mDebugAppPref = findPreference(DEBUG_APP_KEY);
    mAllPrefs.add(mDebugAppPref);
    mWaitForDebugger = findAndInitSwitchPref(WAIT_FOR_DEBUGGER_KEY);
    mMockLocationAppPref = findPreference(MOCK_LOCATION_APP_KEY);
    mAllPrefs.add(mMockLocationAppPref);
    mVerifyAppsOverUsbController.displayPreference(getPreferenceScreen());
    mStrictMode = findAndInitSwitchPref(STRICT_MODE_KEY);
    mPointerLocation = findAndInitSwitchPref(POINTER_LOCATION_KEY);
    mShowTouches = findAndInitSwitchPref(SHOW_TOUCHES_KEY);
    mShowScreenUpdates = findAndInitSwitchPref(SHOW_SCREEN_UPDATES_KEY);
    mDisableOverlays = findAndInitSwitchPref(DISABLE_OVERLAYS_KEY);
    mForceHardwareUi = findAndInitSwitchPref(FORCE_HARDWARE_UI_KEY);
    mForceMsaa = findAndInitSwitchPref(FORCE_MSAA_KEY);
    mTrackFrameTime = addListPreference(TRACK_FRAME_TIME_KEY);
    mShowNonRectClip = addListPreference(SHOW_NON_RECTANGULAR_CLIP_KEY);
    mShowHwScreenUpdates = findAndInitSwitchPref(SHOW_HW_SCREEN_UPDATES_KEY);
    mShowHwLayersUpdates = findAndInitSwitchPref(SHOW_HW_LAYERS_UPDATES_KEY);
    mDebugLayout = findAndInitSwitchPref(DEBUG_LAYOUT_KEY);
    mForceRtlLayout = findAndInitSwitchPref(FORCE_RTL_LAYOUT_KEY);
    mDebugHwOverdraw = addListPreference(DEBUG_HW_OVERDRAW_KEY);
    mDebugHwRenderer = addListPreference(DEBUG_HW_RENDERER_KEY);
    mWifiDisplayCertification = findAndInitSwitchPref(WIFI_DISPLAY_CERTIFICATION_KEY);
    mWifiVerboseLogging = findAndInitSwitchPref(WIFI_VERBOSE_LOGGING_KEY);
    mWifiAggressiveHandover = findAndInitSwitchPref(WIFI_AGGRESSIVE_HANDOVER_KEY);
    mWifiAllowScansWithTraffic = findAndInitSwitchPref(WIFI_ALLOW_SCAN_WITH_TRAFFIC_KEY);
    mMobileDataAlwaysOn = findAndInitSwitchPref(MOBILE_DATA_ALWAYS_ON);
    mTetheringHardwareOffload = findAndInitSwitchPref(TETHERING_HARDWARE_OFFLOAD);
    mLogdSize = addListPreference(SELECT_LOGD_SIZE_KEY);
    if ("1".equals(SystemProperties.get("ro.debuggable", "0"))) {
        mLogpersist = addListPreference(SELECT_LOGPERSIST_KEY);
    } else {
        mLogpersist = (ListPreference) findPreference(SELECT_LOGPERSIST_KEY);
        if (mLogpersist != null) {
            mLogpersist.setEnabled(false);
            if (debugDebuggingCategory != null) {
                debugDebuggingCategory.removePreference(mLogpersist);
            }
        }
        mLogpersist = null;
    }
    mUsbConfiguration = addListPreference(USB_CONFIGURATION_KEY);
    mBluetoothDisableAbsVolume = findAndInitSwitchPref(BLUETOOTH_DISABLE_ABSOLUTE_VOLUME_KEY);
    mBluetoothEnableInbandRinging = findAndInitSwitchPref(BLUETOOTH_ENABLE_INBAND_RINGING_KEY);
    if (!BluetoothHeadset.isInbandRingingSupported(getContext())) {
        removePreference(mBluetoothEnableInbandRinging);
        mBluetoothEnableInbandRinging = null;
    }
    mBluetoothSelectAvrcpVersion = addListPreference(BLUETOOTH_SELECT_AVRCP_VERSION_KEY);
    mBluetoothSelectA2dpCodec = addListPreference(BLUETOOTH_SELECT_A2DP_CODEC_KEY);
    mBluetoothSelectA2dpSampleRate = addListPreference(BLUETOOTH_SELECT_A2DP_SAMPLE_RATE_KEY);
    mBluetoothSelectA2dpBitsPerSample = addListPreference(BLUETOOTH_SELECT_A2DP_BITS_PER_SAMPLE_KEY);
    mBluetoothSelectA2dpChannelMode = addListPreference(BLUETOOTH_SELECT_A2DP_CHANNEL_MODE_KEY);
    mBluetoothSelectA2dpLdacPlaybackQuality = addListPreference(BLUETOOTH_SELECT_A2DP_LDAC_PLAYBACK_QUALITY_KEY);
    initBluetoothConfigurationValues();
    updatePrivateDnsSummary();
    mWindowAnimationScale = addListPreference(WINDOW_ANIMATION_SCALE_KEY);
    mTransitionAnimationScale = addListPreference(TRANSITION_ANIMATION_SCALE_KEY);
    mAnimatorDurationScale = addListPreference(ANIMATOR_DURATION_SCALE_KEY);
    mOverlayDisplayDevices = addListPreference(OVERLAY_DISPLAY_DEVICES_KEY);
    mSimulateColorSpace = addListPreference(SIMULATE_COLOR_SPACE);
    mUSBAudio = findAndInitSwitchPref(USB_AUDIO_KEY);
    mForceResizable = findAndInitSwitchPref(FORCE_RESIZABLE_KEY);
    mImmediatelyDestroyActivities = (SwitchPreference) findPreference(IMMEDIATELY_DESTROY_ACTIVITIES_KEY);
    mAllPrefs.add(mImmediatelyDestroyActivities);
    mResetSwitchPrefs.add(mImmediatelyDestroyActivities);
    mAppProcessLimit = addListPreference(APP_PROCESS_LIMIT_KEY);
    mShowAllANRs = (SwitchPreference) findPreference(SHOW_ALL_ANRS_KEY);
    mAllPrefs.add(mShowAllANRs);
    mResetSwitchPrefs.add(mShowAllANRs);
    mShowNotificationChannelWarnings = (SwitchPreference) findPreference(SHOW_NOTIFICATION_CHANNEL_WARNINGS_KEY);
    mAllPrefs.add(mShowNotificationChannelWarnings);
    mResetSwitchPrefs.add(mShowNotificationChannelWarnings);
    Preference hdcpChecking = findPreference(HDCP_CHECKING_KEY);
    if (hdcpChecking != null) {
        mAllPrefs.add(hdcpChecking);
        removePreferenceForProduction(hdcpChecking);
    }
    Preference convertFbePreference = findPreference(KEY_CONVERT_FBE);
    try {
        IBinder service = ServiceManager.getService("mount");
        IStorageManager storageManager = IStorageManager.Stub.asInterface(service);
        if (!storageManager.isConvertibleToFBE()) {
            removePreference(KEY_CONVERT_FBE);
        } else if ("file".equals(SystemProperties.get("ro.crypto.type", "none"))) {
            convertFbePreference.setEnabled(false);
            convertFbePreference.setSummary(getResources().getString(R.string.convert_to_file_encryption_done));
        }
    } catch (RemoteException e) {
        removePreference(KEY_CONVERT_FBE);
    }
    mOtaDisableAutomaticUpdate = findAndInitSwitchPref(OTA_DISABLE_AUTOMATIC_UPDATE_KEY);
    mColorModePreference = (ColorModePreference) findPreference(KEY_COLOR_MODE);
    mColorModePreference.updateCurrentAndSupported();
    if (mColorModePreference.getColorModeCount() < 2 || getContext().getDisplay().isWideColorGamut()) {
        removePreference(KEY_COLOR_MODE);
        mColorModePreference = null;
    }
    mColorTemperaturePreference = (SwitchPreference) findPreference(COLOR_TEMPERATURE_KEY);
    if (getResources().getBoolean(R.bool.config_enableColorTemperature)) {
        mAllPrefs.add(mColorTemperaturePreference);
        mResetSwitchPrefs.add(mColorTemperaturePreference);
    } else {
        removePreference(COLOR_TEMPERATURE_KEY);
        mColorTemperaturePreference = null;
    }
    addDashboardCategoryPreferences();
}
#end_block

#method_before
private void updateAllOptions() {
    final Context context = getActivity();
    final ContentResolver cr = context.getContentResolver();
    mHaveDebugSettings = false;
    updateSwitchPreference(mEnableAdb, Settings.Global.getInt(cr, Settings.Global.ADB_ENABLED, 0) != 0);
    if (mEnableTerminal != null) {
        updateSwitchPreference(mEnableTerminal, context.getPackageManager().getApplicationEnabledSetting(TERMINAL_APP_PACKAGE) == PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
    }
    mHaveDebugSettings |= mBugReportInPowerController.updatePreference();
    mHaveDebugSettings |= mTelephonyMonitorController.updatePreference();
    updateSwitchPreference(mKeepScreenOn, Settings.Global.getInt(cr, Settings.Global.STAY_ON_WHILE_PLUGGED_IN, 0) != 0);
    updateSwitchPreference(mBtHciSnoopLog, SystemProperties.getBoolean(BLUETOOTH_BTSNOOP_ENABLE_PROPERTY, false));
    updateSwitchPreference(mDebugViewAttributes, Settings.Global.getInt(cr, Settings.Global.DEBUG_VIEW_ATTRIBUTES, 0) != 0);
    updateSwitchPreference(mForceAllowOnExternal, Settings.Global.getInt(cr, Settings.Global.FORCE_ALLOW_ON_EXTERNAL, 0) != 0);
    updateHdcpValues();
    updatePasswordSummary();
    updateDebuggerOptions();
    updateMockLocation();
    updateStrictModeVisualOptions();
    updatePointerLocationOptions();
    updateShowTouchesOptions();
    updateFlingerOptions();
    updateHardwareUiOptions();
    updateMsaaOptions();
    updateTrackFrameTimeOptions();
    updateShowNonRectClipOptions();
    updateShowHwScreenUpdatesOptions();
    updateShowHwLayersUpdatesOptions();
    updateDebugHwOverdrawOptions();
    updateDebugHwRendererOptions();
    updateDebugLayoutOptions();
    updateAnimationScaleOptions();
    updateOverlayDisplayDevicesOptions();
    updateImmediatelyDestroyActivitiesOptions();
    updateAppProcessLimitOptions();
    updateShowAllANRsOptions();
    updateShowNotificationChannelWarningsOptions();
    mVerifyAppsOverUsbController.updatePreference();
    updateOtaDisableAutomaticUpdateOptions();
    updateBugreportOptions();
    updateForceRtlOptions();
    updateLogdSizeValues();
    updateLogpersistValues();
    updateWifiDisplayCertificationOptions();
    updateWifiVerboseLoggingOptions();
    updateWifiAggressiveHandoverOptions();
    updateWifiAllowScansWithTrafficOptions();
    updateMobileDataAlwaysOnOptions();
    updateTetheringHardwareOffloadOptions();
    updateSimulateColorSpace();
    updateUSBAudioOptions();
    updateForceResizableOptions();
    Preference webViewAppPref = findPreference(mWebViewAppPrefController.getPreferenceKey());
    mWebViewAppPrefController.updateState(webViewAppPref);
    updateOemUnlockOptions();
    if (mColorTemperaturePreference != null) {
        updateColorTemperature();
    }
    updateBluetoothDisableAbsVolumeOptions();
    updateBluetoothEnableInbandRingingOptions();
    updateBluetoothA2dpConfigurationValues();
}
#method_after
private void updateAllOptions() {
    final Context context = getActivity();
    final ContentResolver cr = context.getContentResolver();
    mHaveDebugSettings = false;
    updateSwitchPreference(mEnableAdb, Settings.Global.getInt(cr, Settings.Global.ADB_ENABLED, 0) != 0);
    if (mEnableTerminal != null) {
        updateSwitchPreference(mEnableTerminal, context.getPackageManager().getApplicationEnabledSetting(TERMINAL_APP_PACKAGE) == PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
    }
    mHaveDebugSettings |= mBugReportInPowerController.updatePreference();
    mHaveDebugSettings |= mTelephonyMonitorController.updatePreference();
    updateSwitchPreference(mKeepScreenOn, Settings.Global.getInt(cr, Settings.Global.STAY_ON_WHILE_PLUGGED_IN, 0) != 0);
    updateSwitchPreference(mBtHciSnoopLog, SystemProperties.getBoolean(BLUETOOTH_BTSNOOP_ENABLE_PROPERTY, false));
    updateSwitchPreference(mDebugViewAttributes, Settings.Global.getInt(cr, Settings.Global.DEBUG_VIEW_ATTRIBUTES, 0) != 0);
    updateSwitchPreference(mForceAllowOnExternal, Settings.Global.getInt(cr, Settings.Global.FORCE_ALLOW_ON_EXTERNAL, 0) != 0);
    updateHdcpValues();
    updatePasswordSummary();
    updateDebuggerOptions();
    updateMockLocation();
    updateStrictModeVisualOptions();
    updatePointerLocationOptions();
    updateShowTouchesOptions();
    updateFlingerOptions();
    updateHardwareUiOptions();
    updateMsaaOptions();
    updateTrackFrameTimeOptions();
    updateShowNonRectClipOptions();
    updateShowHwScreenUpdatesOptions();
    updateShowHwLayersUpdatesOptions();
    updateDebugHwOverdrawOptions();
    updateDebugHwRendererOptions();
    updateDebugLayoutOptions();
    updateAnimationScaleOptions();
    updateOverlayDisplayDevicesOptions();
    updateImmediatelyDestroyActivitiesOptions();
    updateAppProcessLimitOptions();
    updateShowAllANRsOptions();
    updateShowNotificationChannelWarningsOptions();
    mVerifyAppsOverUsbController.updatePreference();
    updateOtaDisableAutomaticUpdateOptions();
    updateBugreportOptions();
    updateForceRtlOptions();
    updateLogdSizeValues();
    updateLogpersistValues();
    updateWifiDisplayCertificationOptions();
    updateWifiVerboseLoggingOptions();
    updateWifiAggressiveHandoverOptions();
    updateWifiAllowScansWithTrafficOptions();
    updateMobileDataAlwaysOnOptions();
    updateTetheringHardwareOffloadOptions();
    updateSimulateColorSpace();
    updateUSBAudioOptions();
    updateForceResizableOptions();
    Preference webViewAppPref = findPreference(mWebViewAppPrefController.getPreferenceKey());
    mWebViewAppPrefController.updateState(webViewAppPref);
    updateOemUnlockOptions();
    if (mColorTemperaturePreference != null) {
        updateColorTemperature();
    }
    updateBluetoothDisableAbsVolumeOptions();
    updateBluetoothEnableInbandRingingOptions();
    updateBluetoothA2dpConfigurationValues();
    updatePrivateDnsSummary();
}
#end_block

#method_before
@Before
public void setUp() {
    mContext = RuntimeEnvironment.application;
}
#method_after
@Before
public void setUp() {
    MockitoAnnotations.initMocks(this);
}
#end_block

#method_before
@Override
public OutputApkSigningBlockRequest outputZipSections(DataSource zipEntries, DataSource zipCentralDirectory, DataSource zipEocd) throws IOException, InvalidKeyException, SignatureException, NoSuchAlgorithmException {
    checkNotClosed();
    checkV1SigningDoneIfEnabled();
    if (!mV2SigningEnabled) {
        return null;
    }
    invalidateV2Signature();
    byte[] apkSigningBlock = V2SchemeSigner.generateApkSigningBlock(zipEntries, zipCentralDirectory, zipEocd, mV2SignerConfigs);
    mAddV2SignatureRequest = new OutputApkSigningBlockRequestImpl(apkSigningBlock);
    return mAddV2SignatureRequest;
}
#method_after
@Deprecated
@Override
public OutputApkSigningBlockRequest outputZipSections(DataSource zipEntries, DataSource zipCentralDirectory, DataSource zipEocd) throws IOException, InvalidKeyException, SignatureException, NoSuchAlgorithmException {
    return outputZipSectionsInternal(zipEntries, zipCentralDirectory, zipEocd, false);
}
#end_block

#method_before
public DefaultApkSignerEngine build() throws InvalidKeyException {
    return new DefaultApkSignerEngine(mSignerConfigs, mMinSdkVersion, mMaxSdkVersion, mV1SigningEnabled, mV2SigningEnabled, mOtherSignersSignaturesPreserved, mCreatedBy);
}
#method_after
public SignerConfig build() {
    return new SignerConfig(mName, mPrivateKey, mCertificates);
}
#end_block

#method_before
public DefaultApkSignerEngine build() throws InvalidKeyException {
    return new DefaultApkSignerEngine(mSignerConfigs, mMinSdkVersion, mMaxSdkVersion, mV1SigningEnabled, mV2SigningEnabled, mOtherSignersSignaturesPreserved, mCreatedBy);
}
#method_after
public DefaultApkSignerEngine build() throws InvalidKeyException {
    return new DefaultApkSignerEngine(mSignerConfigs, mMinSdkVersion, mV1SigningEnabled, mV2SigningEnabled, mOtherSignersSignaturesPreserved, mCreatedBy);
}
#end_block

#method_before
private static int compareContentDigestAlgorithm(ContentDigestAlgorithm alg1, ContentDigestAlgorithm alg2) {
    switch(alg1) {
        case CHUNKED_SHA256:
            switch(alg2) {
                case CHUNKED_SHA256:
                    return 0;
                case CHUNKED_SHA512:
                case VERITY_CHUNKED_SHA256:
                    return -1;
                default:
                    throw new IllegalArgumentException("Unknown alg2: " + alg2);
            }
        case CHUNKED_SHA512:
            switch(alg2) {
                case CHUNKED_SHA256:
                    return 1;
                case CHUNKED_SHA512:
                    return 0;
                case VERITY_CHUNKED_SHA256:
                    return -1;
                default:
                    throw new IllegalArgumentException("Unknown alg2: " + alg2);
            }
        case VERITY_CHUNKED_SHA256:
            switch(alg2) {
                case CHUNKED_SHA256:
                case CHUNKED_SHA512:
                    return 1;
                case VERITY_CHUNKED_SHA256:
                    return 0;
                default:
                    throw new IllegalArgumentException("Unknown alg2: " + alg2);
            }
        default:
            throw new IllegalArgumentException("Unknown alg1: " + alg1);
    }
}
#method_after
private static int compareContentDigestAlgorithm(ContentDigestAlgorithm alg1, ContentDigestAlgorithm alg2) {
    switch(alg1) {
        case CHUNKED_SHA256:
            switch(alg2) {
                case CHUNKED_SHA256:
                    return 0;
                case CHUNKED_SHA512:
                case VERITY_CHUNKED_SHA256:
                    return -1;
                default:
                    throw new IllegalArgumentException("Unknown alg2: " + alg2);
            }
        case CHUNKED_SHA512:
            switch(alg2) {
                case CHUNKED_SHA256:
                case VERITY_CHUNKED_SHA256:
                    return 1;
                case CHUNKED_SHA512:
                    return 0;
                default:
                    throw new IllegalArgumentException("Unknown alg2: " + alg2);
            }
        case VERITY_CHUNKED_SHA256:
            switch(alg2) {
                case CHUNKED_SHA256:
                    return 1;
                case VERITY_CHUNKED_SHA256:
                    return 0;
                case CHUNKED_SHA512:
                    return -1;
                default:
                    throw new IllegalArgumentException("Unknown alg2: " + alg2);
            }
        default:
            throw new IllegalArgumentException("Unknown alg1: " + alg1);
    }
}
#end_block

#method_before
public static List<SignatureAlgorithm> getSuggestedSignatureAlgorithms(PublicKey signingKey, int minSdkVersion, int maxSdkVersion) throws InvalidKeyException {
    String keyAlgorithm = signingKey.getAlgorithm();
    if ("RSA".equalsIgnoreCase(keyAlgorithm)) {
        // Use RSASSA-PKCS1-v1_5 signature scheme instead of RSASSA-PSS to guarantee
        // deterministic signatures which make life easier for OTA updates (fewer files
        // changed when deterministic signature schemes are used).
        // Pick a digest which is no weaker than the key.
        int modulusLengthBits = ((RSAKey) signingKey).getModulus().bitLength();
        if (modulusLengthBits <= 3072) {
            // 3072-bit RSA is roughly 128-bit strong, meaning SHA-256 is a good fit.
            List<SignatureAlgorithm> algorithms = new ArrayList<>();
            algorithms.add(SignatureAlgorithm.RSA_PKCS1_V1_5_WITH_SHA256);
            if (maxSdkVersion >= AndroidSdkVersion.P) {
                algorithms.add(SignatureAlgorithm.VERITY_RSA_PKCS1_V1_5_WITH_SHA256);
            }
            return algorithms;
        } else {
            // digest being the weak link. SHA-512 is the next strongest supported digest.
            return Collections.singletonList(SignatureAlgorithm.RSA_PKCS1_V1_5_WITH_SHA512);
        }
    } else if ("DSA".equalsIgnoreCase(keyAlgorithm)) {
        // DSA is supported only with SHA-256.
        List<SignatureAlgorithm> algorithms = new ArrayList<>();
        algorithms.add(SignatureAlgorithm.DSA_WITH_SHA256);
        if (maxSdkVersion >= AndroidSdkVersion.P) {
            algorithms.add(SignatureAlgorithm.VERITY_DSA_WITH_SHA256);
        }
        return algorithms;
    } else if ("EC".equalsIgnoreCase(keyAlgorithm)) {
        // Pick a digest which is no weaker than the key.
        int keySizeBits = ((ECKey) signingKey).getParams().getOrder().bitLength();
        if (keySizeBits <= 256) {
            // 256-bit Elliptic Curve is roughly 128-bit strong, meaning SHA-256 is a good fit.
            List<SignatureAlgorithm> algorithms = new ArrayList<>();
            algorithms.add(SignatureAlgorithm.ECDSA_WITH_SHA256);
            if (maxSdkVersion >= AndroidSdkVersion.P) {
                algorithms.add(SignatureAlgorithm.VERITY_ECDSA_WITH_SHA256);
            }
            return algorithms;
        } else {
            // digest being the weak link. SHA-512 is the next strongest supported digest.
            return Collections.singletonList(SignatureAlgorithm.ECDSA_WITH_SHA512);
        }
    } else {
        throw new InvalidKeyException("Unsupported key algorithm: " + keyAlgorithm);
    }
}
#method_after
public static List<SignatureAlgorithm> getSuggestedSignatureAlgorithms(PublicKey signingKey, int minSdkVersion, boolean apkSigningBlockPaddingSupported) throws InvalidKeyException {
    String keyAlgorithm = signingKey.getAlgorithm();
    if ("RSA".equalsIgnoreCase(keyAlgorithm)) {
        // Use RSASSA-PKCS1-v1_5 signature scheme instead of RSASSA-PSS to guarantee
        // deterministic signatures which make life easier for OTA updates (fewer files
        // changed when deterministic signature schemes are used).
        // Pick a digest which is no weaker than the key.
        int modulusLengthBits = ((RSAKey) signingKey).getModulus().bitLength();
        if (modulusLengthBits <= 3072) {
            // 3072-bit RSA is roughly 128-bit strong, meaning SHA-256 is a good fit.
            List<SignatureAlgorithm> algorithms = new ArrayList<>();
            algorithms.add(SignatureAlgorithm.RSA_PKCS1_V1_5_WITH_SHA256);
            if (apkSigningBlockPaddingSupported) {
                algorithms.add(SignatureAlgorithm.VERITY_RSA_PKCS1_V1_5_WITH_SHA256);
            }
            return algorithms;
        } else {
            // digest being the weak link. SHA-512 is the next strongest supported digest.
            return Collections.singletonList(SignatureAlgorithm.RSA_PKCS1_V1_5_WITH_SHA512);
        }
    } else if ("DSA".equalsIgnoreCase(keyAlgorithm)) {
        // DSA is supported only with SHA-256.
        List<SignatureAlgorithm> algorithms = new ArrayList<>();
        algorithms.add(SignatureAlgorithm.DSA_WITH_SHA256);
        if (apkSigningBlockPaddingSupported) {
            algorithms.add(SignatureAlgorithm.VERITY_DSA_WITH_SHA256);
        }
        return algorithms;
    } else if ("EC".equalsIgnoreCase(keyAlgorithm)) {
        // Pick a digest which is no weaker than the key.
        int keySizeBits = ((ECKey) signingKey).getParams().getOrder().bitLength();
        if (keySizeBits <= 256) {
            // 256-bit Elliptic Curve is roughly 128-bit strong, meaning SHA-256 is a good fit.
            List<SignatureAlgorithm> algorithms = new ArrayList<>();
            algorithms.add(SignatureAlgorithm.ECDSA_WITH_SHA256);
            if (apkSigningBlockPaddingSupported) {
                algorithms.add(SignatureAlgorithm.VERITY_ECDSA_WITH_SHA256);
            }
            return algorithms;
        } else {
            // digest being the weak link. SHA-512 is the next strongest supported digest.
            return Collections.singletonList(SignatureAlgorithm.ECDSA_WITH_SHA512);
        }
    } else {
        throw new InvalidKeyException("Unsupported key algorithm: " + keyAlgorithm);
    }
}
#end_block

#method_before
private static byte[] generateApkSigningBlock(byte[] apkSignatureSchemeV2Block) {
    // FORMAT:
    // uint64:  size (excluding this field)
    // repeated ID-value pairs:
    // uint64:           size (excluding this field)
    // uint32:           ID
    // (size - 4) bytes: value
    // (extra dummy ID-value for padding to make block size a multiple of 4096 bytes)
    // uint64:  size (same as the one above)
    // uint128: magic
    int resultSize = // size
    8 + 8 + 4 + // v2Block as ID-value pair
    apkSignatureSchemeV2Block.length + // size
    8 + // magic
    16;
    ByteBuffer paddingPair = null;
    if (resultSize % ANDROID_COMMON_PAGE_ALIGNMENT_BYTES != 0) {
        int padding = ANDROID_COMMON_PAGE_ALIGNMENT_BYTES - (resultSize % ANDROID_COMMON_PAGE_ALIGNMENT_BYTES);
        if (padding < 12) {
            // minimum size of an ID-value pair
            padding += ANDROID_COMMON_PAGE_ALIGNMENT_BYTES;
        }
        paddingPair = ByteBuffer.allocate(padding).order(ByteOrder.LITTLE_ENDIAN);
        paddingPair.putLong(padding - 8);
        paddingPair.putInt(VERITY_PADDING_BLOCK_ID);
        paddingPair.rewind();
        resultSize += padding;
    }
    ByteBuffer result = ByteBuffer.allocate(resultSize);
    result.order(ByteOrder.LITTLE_ENDIAN);
    long blockSizeFieldValue = resultSize - 8;
    result.putLong(blockSizeFieldValue);
    long pairSizeFieldValue = 4 + apkSignatureSchemeV2Block.length;
    result.putLong(pairSizeFieldValue);
    result.putInt(APK_SIGNATURE_SCHEME_V2_BLOCK_ID);
    result.put(apkSignatureSchemeV2Block);
    if (paddingPair != null) {
        result.put(paddingPair);
    }
    result.putLong(blockSizeFieldValue);
    result.put(APK_SIGNING_BLOCK_MAGIC);
    return result.array();
}
#method_after
public static Pair<byte[], Integer> generateApkSigningBlock(DataSource beforeCentralDir, DataSource centralDir, DataSource eocd, List<SignerConfig> signerConfigs, boolean apkSigningBlockPaddingSupported) throws IOException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
    if (signerConfigs.isEmpty()) {
        throw new IllegalArgumentException("No signer configs provided. At least one is required");
    }
    // Figure out which digest(s) to use for APK contents.
    Set<ContentDigestAlgorithm> contentDigestAlgorithms = new HashSet<>(1);
    for (SignerConfig signerConfig : signerConfigs) {
        for (SignatureAlgorithm signatureAlgorithm : signerConfig.signatureAlgorithms) {
            contentDigestAlgorithms.add(signatureAlgorithm.getContentDigestAlgorithm());
        }
    }
    // Ensure APK Signing Block starts from page boundary.
    int padSizeBeforeSigningBlock = 0;
    if (apkSigningBlockPaddingSupported && (beforeCentralDir.size() % ANDROID_COMMON_PAGE_ALIGNMENT_BYTES != 0)) {
        padSizeBeforeSigningBlock = (int) (ANDROID_COMMON_PAGE_ALIGNMENT_BYTES - beforeCentralDir.size() % ANDROID_COMMON_PAGE_ALIGNMENT_BYTES);
        beforeCentralDir = new ChainedDataSource(beforeCentralDir, DataSources.asDataSource(ByteBuffer.allocate(padSizeBeforeSigningBlock)));
    }
    // Ensure that, when digesting, ZIP End of Central Directory record's Central Directory
    // offset field is treated as pointing to the offset at which the APK Signing Block will
    // start.
    long centralDirOffsetForDigesting = beforeCentralDir.size();
    ByteBuffer eocdBuf = ByteBuffer.allocate((int) eocd.size());
    eocdBuf.order(ByteOrder.LITTLE_ENDIAN);
    eocd.copyTo(0, (int) eocd.size(), eocdBuf);
    eocdBuf.flip();
    ZipUtils.setZipEocdCentralDirectoryOffset(eocdBuf, centralDirOffsetForDigesting);
    // Compute digests of APK contents.
    // digest algorithm ID -> digest
    Map<ContentDigestAlgorithm, byte[]> contentDigests;
    try {
        contentDigests = computeContentDigests(contentDigestAlgorithms, beforeCentralDir, centralDir, DataSources.asDataSource(eocdBuf));
    } catch (IOException e) {
        throw new IOException("Failed to read APK being signed", e);
    } catch (DigestException e) {
        throw new SignatureException("Failed to compute digests of APK", e);
    }
    // Sign the digests and wrap the signatures and signer info into an APK Signing Block.
    return Pair.of(generateApkSigningBlock(signerConfigs, contentDigests), padSizeBeforeSigningBlock);
}
#end_block

#method_before
static Map<ContentDigestAlgorithm, byte[]> computeContentDigests(Set<ContentDigestAlgorithm> digestAlgorithms, DataSource beforeCentralDir, DataSource centralDir, DataSource eocd) throws IOException, NoSuchAlgorithmException, DigestException {
    Set<ContentDigestAlgorithm> oneMbChunkBasedAlgorithm = digestAlgorithms.stream().filter(a -> a == ContentDigestAlgorithm.CHUNKED_SHA256 || a == ContentDigestAlgorithm.CHUNKED_SHA512).collect(Collectors.toSet());
    Map<ContentDigestAlgorithm, byte[]> contentDigests = computeOneMbChunkContentDigests(oneMbChunkBasedAlgorithm, new DataSource[] { beforeCentralDir, centralDir, eocd });
    if (digestAlgorithms.contains(ContentDigestAlgorithm.VERITY_CHUNKED_SHA256)) {
        contentDigests.put(ContentDigestAlgorithm.VERITY_CHUNKED_SHA256, computeApkVerityDigest(beforeCentralDir, centralDir, eocd));
    }
    return contentDigests;
}
#method_after
static Map<ContentDigestAlgorithm, byte[]> computeContentDigests(Set<ContentDigestAlgorithm> digestAlgorithms, DataSource beforeCentralDir, DataSource centralDir, DataSource eocd) throws IOException, NoSuchAlgorithmException, DigestException {
    Map<ContentDigestAlgorithm, byte[]> contentDigests = new HashMap<>();
    Set<ContentDigestAlgorithm> oneMbChunkBasedAlgorithm = digestAlgorithms.stream().filter(a -> a == ContentDigestAlgorithm.CHUNKED_SHA256 || a == ContentDigestAlgorithm.CHUNKED_SHA512).collect(Collectors.toSet());
    computeOneMbChunkContentDigests(oneMbChunkBasedAlgorithm, new DataSource[] { beforeCentralDir, centralDir, eocd }, contentDigests);
    if (digestAlgorithms.contains(ContentDigestAlgorithm.VERITY_CHUNKED_SHA256)) {
        computeApkVerityDigest(beforeCentralDir, centralDir, eocd, contentDigests);
    }
    return contentDigests;
}
#end_block

#method_before
static private Map<ContentDigestAlgorithm, byte[]> computeOneMbChunkContentDigests(Set<ContentDigestAlgorithm> digestAlgorithms, DataSource[] contents) throws IOException, NoSuchAlgorithmException, DigestException {
    // For each digest algorithm the result is computed as follows:
    // 1. Each segment of contents is split into consecutive chunks of 1 MB in size.
    // The final chunk will be shorter iff the length of segment is not a multiple of 1 MB.
    // No chunks are produced for empty (zero length) segments.
    // 2. The digest of each chunk is computed over the concatenation of byte 0xa5, the chunk's
    // length in bytes (uint32 little-endian) and the chunk's contents.
    // 3. The output digest is computed over the concatenation of the byte 0x5a, the number of
    // chunks (uint32 little-endian) and the concatenation of digests of chunks of all
    // segments in-order.
    long chunkCountLong = 0;
    for (DataSource input : contents) {
        chunkCountLong += getChunkCount(input.size(), CONTENT_DIGESTED_CHUNK_MAX_SIZE_BYTES);
    }
    if (chunkCountLong > Integer.MAX_VALUE) {
        throw new DigestException("Input too long: " + chunkCountLong + " chunks");
    }
    int chunkCount = (int) chunkCountLong;
    ContentDigestAlgorithm[] digestAlgorithmsArray = digestAlgorithms.toArray(new ContentDigestAlgorithm[digestAlgorithms.size()]);
    MessageDigest[] mds = new MessageDigest[digestAlgorithmsArray.length];
    byte[][] digestsOfChunks = new byte[digestAlgorithmsArray.length][];
    int[] digestOutputSizes = new int[digestAlgorithmsArray.length];
    for (int i = 0; i < digestAlgorithmsArray.length; i++) {
        ContentDigestAlgorithm digestAlgorithm = digestAlgorithmsArray[i];
        int digestOutputSizeBytes = digestAlgorithm.getChunkDigestOutputSizeBytes();
        digestOutputSizes[i] = digestOutputSizeBytes;
        byte[] concatenationOfChunkCountAndChunkDigests = new byte[5 + chunkCount * digestOutputSizeBytes];
        concatenationOfChunkCountAndChunkDigests[0] = 0x5a;
        setUnsignedInt32LittleEndian(chunkCount, concatenationOfChunkCountAndChunkDigests, 1);
        digestsOfChunks[i] = concatenationOfChunkCountAndChunkDigests;
        String jcaAlgorithm = digestAlgorithm.getJcaMessageDigestAlgorithm();
        mds[i] = MessageDigest.getInstance(jcaAlgorithm);
    }
    MessageDigestSink mdSink = new MessageDigestSink(mds);
    byte[] chunkContentPrefix = new byte[5];
    chunkContentPrefix[0] = (byte) 0xa5;
    int chunkIndex = 0;
    // digest to be more efficient because it's presented with all of its input in one go.
    for (DataSource input : contents) {
        long inputOffset = 0;
        long inputRemaining = input.size();
        while (inputRemaining > 0) {
            int chunkSize = (int) Math.min(inputRemaining, CONTENT_DIGESTED_CHUNK_MAX_SIZE_BYTES);
            setUnsignedInt32LittleEndian(chunkSize, chunkContentPrefix, 1);
            for (int i = 0; i < mds.length; i++) {
                mds[i].update(chunkContentPrefix);
            }
            try {
                input.feed(inputOffset, chunkSize, mdSink);
            } catch (IOException e) {
                throw new IOException("Failed to read chunk #" + chunkIndex, e);
            }
            for (int i = 0; i < digestAlgorithmsArray.length; i++) {
                MessageDigest md = mds[i];
                byte[] concatenationOfChunkCountAndChunkDigests = digestsOfChunks[i];
                int expectedDigestSizeBytes = digestOutputSizes[i];
                int actualDigestSizeBytes = md.digest(concatenationOfChunkCountAndChunkDigests, 5 + chunkIndex * expectedDigestSizeBytes, expectedDigestSizeBytes);
                if (actualDigestSizeBytes != expectedDigestSizeBytes) {
                    throw new RuntimeException("Unexpected output size of " + md.getAlgorithm() + " digest: " + actualDigestSizeBytes);
                }
            }
            inputOffset += chunkSize;
            inputRemaining -= chunkSize;
            chunkIndex++;
        }
    }
    Map<ContentDigestAlgorithm, byte[]> result = new HashMap<>(digestAlgorithmsArray.length);
    for (int i = 0; i < digestAlgorithmsArray.length; i++) {
        ContentDigestAlgorithm digestAlgorithm = digestAlgorithmsArray[i];
        byte[] concatenationOfChunkCountAndChunkDigests = digestsOfChunks[i];
        MessageDigest md = mds[i];
        byte[] digest = md.digest(concatenationOfChunkCountAndChunkDigests);
        result.put(digestAlgorithm, digest);
    }
    return result;
}
#method_after
private static void computeOneMbChunkContentDigests(Set<ContentDigestAlgorithm> digestAlgorithms, DataSource[] contents, Map<ContentDigestAlgorithm, byte[]> outputContentDigests) throws IOException, NoSuchAlgorithmException, DigestException {
    // For each digest algorithm the result is computed as follows:
    // 1. Each segment of contents is split into consecutive chunks of 1 MB in size.
    // The final chunk will be shorter iff the length of segment is not a multiple of 1 MB.
    // No chunks are produced for empty (zero length) segments.
    // 2. The digest of each chunk is computed over the concatenation of byte 0xa5, the chunk's
    // length in bytes (uint32 little-endian) and the chunk's contents.
    // 3. The output digest is computed over the concatenation of the byte 0x5a, the number of
    // chunks (uint32 little-endian) and the concatenation of digests of chunks of all
    // segments in-order.
    long chunkCountLong = 0;
    for (DataSource input : contents) {
        chunkCountLong += getChunkCount(input.size(), CONTENT_DIGESTED_CHUNK_MAX_SIZE_BYTES);
    }
    if (chunkCountLong > Integer.MAX_VALUE) {
        throw new DigestException("Input too long: " + chunkCountLong + " chunks");
    }
    int chunkCount = (int) chunkCountLong;
    ContentDigestAlgorithm[] digestAlgorithmsArray = digestAlgorithms.toArray(new ContentDigestAlgorithm[digestAlgorithms.size()]);
    MessageDigest[] mds = new MessageDigest[digestAlgorithmsArray.length];
    byte[][] digestsOfChunks = new byte[digestAlgorithmsArray.length][];
    int[] digestOutputSizes = new int[digestAlgorithmsArray.length];
    for (int i = 0; i < digestAlgorithmsArray.length; i++) {
        ContentDigestAlgorithm digestAlgorithm = digestAlgorithmsArray[i];
        int digestOutputSizeBytes = digestAlgorithm.getChunkDigestOutputSizeBytes();
        digestOutputSizes[i] = digestOutputSizeBytes;
        byte[] concatenationOfChunkCountAndChunkDigests = new byte[5 + chunkCount * digestOutputSizeBytes];
        concatenationOfChunkCountAndChunkDigests[0] = 0x5a;
        setUnsignedInt32LittleEndian(chunkCount, concatenationOfChunkCountAndChunkDigests, 1);
        digestsOfChunks[i] = concatenationOfChunkCountAndChunkDigests;
        String jcaAlgorithm = digestAlgorithm.getJcaMessageDigestAlgorithm();
        mds[i] = MessageDigest.getInstance(jcaAlgorithm);
    }
    MessageDigestSink mdSink = new MessageDigestSink(mds);
    byte[] chunkContentPrefix = new byte[5];
    chunkContentPrefix[0] = (byte) 0xa5;
    int chunkIndex = 0;
    // digest to be more efficient because it's presented with all of its input in one go.
    for (DataSource input : contents) {
        long inputOffset = 0;
        long inputRemaining = input.size();
        while (inputRemaining > 0) {
            int chunkSize = (int) Math.min(inputRemaining, CONTENT_DIGESTED_CHUNK_MAX_SIZE_BYTES);
            setUnsignedInt32LittleEndian(chunkSize, chunkContentPrefix, 1);
            for (int i = 0; i < mds.length; i++) {
                mds[i].update(chunkContentPrefix);
            }
            try {
                input.feed(inputOffset, chunkSize, mdSink);
            } catch (IOException e) {
                throw new IOException("Failed to read chunk #" + chunkIndex, e);
            }
            for (int i = 0; i < digestAlgorithmsArray.length; i++) {
                MessageDigest md = mds[i];
                byte[] concatenationOfChunkCountAndChunkDigests = digestsOfChunks[i];
                int expectedDigestSizeBytes = digestOutputSizes[i];
                int actualDigestSizeBytes = md.digest(concatenationOfChunkCountAndChunkDigests, 5 + chunkIndex * expectedDigestSizeBytes, expectedDigestSizeBytes);
                if (actualDigestSizeBytes != expectedDigestSizeBytes) {
                    throw new RuntimeException("Unexpected output size of " + md.getAlgorithm() + " digest: " + actualDigestSizeBytes);
                }
            }
            inputOffset += chunkSize;
            inputRemaining -= chunkSize;
            chunkIndex++;
        }
    }
    for (int i = 0; i < digestAlgorithmsArray.length; i++) {
        ContentDigestAlgorithm digestAlgorithm = digestAlgorithmsArray[i];
        byte[] concatenationOfChunkCountAndChunkDigests = digestsOfChunks[i];
        MessageDigest md = mds[i];
        byte[] digest = md.digest(concatenationOfChunkCountAndChunkDigests);
        outputContentDigests.put(digestAlgorithm, digest);
    }
}
#end_block

#method_before
static byte[] computeApkVerityDigest(DataSource beforeCentralDir, DataSource centralDir, DataSource eocd) throws IOException, NoSuchAlgorithmException {
    // Use 0s as salt for now.  This also needs to be consistent in the fsverify header for
    // kernel to use.
    VerityTreeBuilder builder = new VerityTreeBuilder(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 });
    return builder.generateVerityTreeRootHash(beforeCentralDir, centralDir, eocd);
}
#method_after
private static void computeApkVerityDigest(DataSource beforeCentralDir, DataSource centralDir, DataSource eocd, Map<ContentDigestAlgorithm, byte[]> outputContentDigests) throws IOException, NoSuchAlgorithmException {
    // Use 0s as salt for now.  This also needs to be consistent in the fsverify header for
    // kernel to use.
    VerityTreeBuilder builder = new VerityTreeBuilder(new byte[8]);
    outputContentDigests.put(ContentDigestAlgorithm.VERITY_CHUNKED_SHA256, builder.generateVerityTreeRootHash(beforeCentralDir, centralDir, eocd));
}
#end_block

#method_before
private OutputApkSigningBlockRequestImpl outputZipSectionsInternal(DataSource zipEntries, DataSource zipCentralDirectory, DataSource zipEocd, boolean apkSigningBlockPaddingSupported) throws IOException, InvalidKeyException, SignatureException, NoSuchAlgorithmException {
    checkNotClosed();
    checkV1SigningDoneIfEnabled();
    if (!mV2SigningEnabled) {
        return null;
    }
    invalidateV2Signature();
    Pair<byte[], Integer> result = V2SchemeSigner.generateApkSigningBlock(zipEntries, zipCentralDirectory, zipEocd, mV2SignerConfigs, apkSigningBlockPaddingSupported);
    byte[] apkSigningBlock = result.getFirst();
    int padSizeBeforeApkSigningBlock = result.getSecond();
    mAddV2SignatureRequest = new OutputApkSigningBlockRequestImpl(apkSigningBlock, padSizeBeforeApkSigningBlock);
    return mAddV2SignatureRequest;
}
#method_after
private OutputApkSigningBlockRequestImpl outputZipSectionsInternal(DataSource zipEntries, DataSource zipCentralDirectory, DataSource zipEocd, boolean apkSigningBlockPaddingSupported) throws IOException, InvalidKeyException, SignatureException, NoSuchAlgorithmException {
    checkNotClosed();
    checkV1SigningDoneIfEnabled();
    if (!mV2SigningEnabled) {
        return null;
    }
    invalidateV2Signature();
    List<V2SchemeSigner.SignerConfig> v2SignerConfigs = getV2SignerConfigs();
    Pair<byte[], Integer> result = V2SchemeSigner.generateApkSigningBlock(zipEntries, zipCentralDirectory, zipEocd, v2SignerConfigs, apkSigningBlockPaddingSupported);
    byte[] apkSigningBlock = result.getFirst();
    int padSizeBeforeApkSigningBlock = result.getSecond();
    mAddV2SignatureRequest = new OutputApkSigningBlockRequestImpl(apkSigningBlock, padSizeBeforeApkSigningBlock);
    return mAddV2SignatureRequest;
}
#end_block

#method_before
public DefaultApkSignerEngine build() throws InvalidKeyException {
    return new DefaultApkSignerEngine(mSignerConfigs, mMinSdkVersion, mV1SigningEnabled, mV2SigningEnabled, mOtherSignersSignaturesPreserved, mCreatedBy);
}
#method_after
public SignerConfig build() {
    return new SignerConfig(mName, mPrivateKey, mCertificates);
}
#end_block

#method_before
public final MethodType accessModeType(AccessMode accessMode) {
    // Android-added: alternative implementation.
    if (coordinateType1 == null) {
        return accessMode.at.accessModeType(coordinateType0, varType);
    } else {
        return accessMode.at.accessModeType(coordinateType0, varType, coordinateType1);
    }
}
#method_after
public final MethodType accessModeType(AccessMode accessMode) {
    // Android-added: alternative implementation.
    if (coordinateType1 == null) {
        // receiver and adapts accordingly if it is null.
        return accessMode.at.accessModeType(coordinateType0, varType);
    } else {
        return accessMode.at.accessModeType(coordinateType0, varType, coordinateType1);
    }
}
#end_block

#method_before
public void heyItsMe(IBazCallback cb) {
    Log.d(TAG, "SERVER: heyItsMe");
}
#method_after
public void heyItsMe(IBazCallback cb) throws RemoteException {
    mCalled = true;
    cb.heyItsMe(null);
}
#end_block

#method_before
public void hey() {
    Log.d(TAG, "SERVER: hey");
}
#method_after
public void hey() {
    mCalled = true;
}
#end_block

#method_before
private void client() throws RemoteException {
    ExpectDeepEq(null, null);
    ExpectDeepNe(null, new String());
    ExpectDeepNe(new String(), null);
    ExpectDeepEq(new String(), new String());
    ExpectDeepEq("hey", "hey");
    ExpectDeepEq(new int[] { 1, 2 }, new int[] { 1, 2 });
    ExpectDeepNe(new int[] { 1, 2 }, new int[] { 1, 3 });
    ExpectDeepNe(new int[] { 1, 2 }, new int[] { 1, 2, 3 });
    ExpectDeepEq(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 4 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 5 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2, 3 }, { 4, 5, 6 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 4, 5 } });
    ExpectDeepEq(new Integer[] { 1, 2 }, new Integer[] { 1, 2 });
    ExpectDeepNe(new Integer[] { 1, 2 }, new Integer[] { 1, 3 });
    ExpectDeepNe(new Integer[] { 1, 2 }, new Integer[] { 1, 2, 3 });
    ExpectDeepEq(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 4 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 5 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2, 3 }, { 4, 5, 6 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 4, 5 } });
    ExpectDeepEq(new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(1, 2)));
    ExpectDeepNe(new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(1, 2, 3)));
    ExpectDeepEq(new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })), new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })));
    ExpectDeepNe(new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })), new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 5 })));
    ExpectDeepEq(new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })), new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })));
    ExpectDeepNe(new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })), new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 5 })));
    ExpectDeepEq(new ArrayList[] { new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(3, 4)) }, new ArrayList[] { new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(3, 4)) });
    {
        // Test proper exceptions are thrown
        try {
            IBase proxy = IBase.getService("this-doesn't-exist");
        } catch (Exception e) {
            ExpectTrue(e instanceof NoSuchElementException);
        }
    }
    {
        // Test access through base interface binder.
        IBase baseProxy = IBase.getService("baz");
        baseProxy.someBaseMethod();
        IBaz bazProxy = IBaz.castFrom(baseProxy);
        ExpectTrue(bazProxy != null);
        // IQuux is completely unrelated to IBase/IBaz, so the following
        // should fail, i.e. return null.
        IQuux quuxProxy = IQuux.castFrom(baseProxy);
        ExpectTrue(quuxProxy == null);
    }
    {
        // Test waiting API
        IBase baseProxyA = IBaz.getService("baz", true);
        ExpectTrue(baseProxyA != null);
        IBase baseProxyB = IBaz.getService("baz", false);
        ExpectTrue(baseProxyB != null);
    }
    IBaz proxy = IBaz.getService("baz");
    proxy.someBaseMethod();
    {
        Expect(proxy.interfaceDescriptor(), IBaz.kInterfaceName);
    }
    {
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        IBase.Foo result = proxy.someOtherBaseMethod(foo);
        ExpectTrue(result.equals(foo));
    }
    {
        IBase.Foo[] inputArray = new IBase.Foo[2];
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputArray[0] = foo;
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputArray[1] = foo;
        IBase.Foo[] expectedOutputArray = new IBase.Foo[2];
        expectedOutputArray[0] = inputArray[1];
        expectedOutputArray[1] = inputArray[0];
        IBase.Foo[] outputArray = proxy.someMethodWithFooArrays(inputArray);
        ExpectTrue(java.util.Objects.deepEquals(outputArray, expectedOutputArray));
    }
    {
        ArrayList<IBase.Foo> inputVec = new ArrayList<IBase.Foo>();
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputVec.add(foo);
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputVec.add(foo);
        ArrayList<IBase.Foo> expectedOutputVec = new ArrayList<IBase.Foo>();
        expectedOutputVec.add(inputVec.get(1));
        expectedOutputVec.add(inputVec.get(0));
        ArrayList<IBase.Foo> outputVec = proxy.someMethodWithFooVectors(inputVec);
        ExpectTrue(java.util.Objects.deepEquals(outputVec, expectedOutputVec));
    }
    {
        IBase.VectorOfArray in = new IBase.VectorOfArray();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.addresses.add(mac);
        }
        IBase.VectorOfArray expectedOut = new IBase.VectorOfArray();
        int n = in.addresses.size();
        for (int i = 0; i < n; ++i) {
            expectedOut.addresses.add(in.addresses.get(n - 1 - i));
        }
        IBase.VectorOfArray out = proxy.someMethodWithVectorOfArray(in);
        ExpectTrue(out.equals(expectedOut));
    }
    {
        ArrayList<byte[]> in = new ArrayList<byte[]>();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.add(mac);
        }
        ArrayList<byte[]> expectedOut = new ArrayList<byte[]>();
        int n = in.size();
        for (int i = 0; i < n; ++i) {
            expectedOut.add(in.get(n - 1 - i));
        }
        ArrayList<byte[]> out = proxy.someMethodTakingAVectorOfArray(in);
        ExpectTrue(out.size() == expectedOut.size());
        for (int i = 0; i < n; ++i) {
            ExpectTrue(java.util.Objects.deepEquals(out.get(i), expectedOut.get(i)));
        }
    }
    {
        IBase.StringMatrix5x3 in = new IBase.StringMatrix5x3();
        IBase.StringMatrix3x5 expectedOut = new IBase.StringMatrix3x5();
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in.s[i][j] = numberToEnglish(3 * i + j + 1);
                expectedOut.s[j][i] = in.s[i][j];
            }
        }
        IBase.StringMatrix3x5 out = proxy.transpose(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        ExpectTrue(out.equals(expectedOut));
    }
    {
        String[][] in = new String[5][3];
        String[][] expectedOut = new String[3][5];
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in[i][j] = numberToEnglish(3 * i + j + 1);
                expectedOut[j][i] = in[i][j];
            }
        }
        String[][] out = proxy.transpose2(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        ExpectTrue(java.util.Arrays.deepEquals(out, expectedOut));
    }
    ExpectTrue(proxy.someBoolMethod(true) == false);
    {
        boolean[] someBoolArray = new boolean[3];
        someBoolArray[0] = true;
        someBoolArray[1] = false;
        someBoolArray[2] = true;
        boolean[] resultArray = proxy.someBoolArrayMethod(someBoolArray);
        ExpectTrue(resultArray[0] == false);
        ExpectTrue(resultArray[1] == true);
        ExpectTrue(resultArray[2] == false);
        ArrayList<Boolean> someBoolVec = new ArrayList<Boolean>();
        someBoolVec.add(true);
        someBoolVec.add(false);
        someBoolVec.add(true);
        ArrayList<Boolean> resultVec = proxy.someBoolVectorMethod(someBoolVec);
        ExpectTrue(resultVec.get(0) == false);
        ExpectTrue(resultVec.get(1) == true);
        ExpectTrue(resultVec.get(2) == false);
    }
    proxy.doThis(1.0f);
    ExpectTrue(proxy.doThatAndReturnSomething(1) == 666);
    ExpectTrue(proxy.doQuiteABit(1, 2L, 3.0f, 4.0) == 666.5);
    {
        int[] paramArray = new int[15];
        int[] expectedOutArray = new int[32];
        ArrayList<Integer> paramVec = new ArrayList<Integer>();
        ArrayList<Integer> expectedOutVec = new ArrayList<Integer>();
        for (int i = 0; i < paramArray.length; ++i) {
            paramArray[i] = i;
            paramVec.add(i);
            expectedOutArray[i] = 2 * i;
            expectedOutArray[15 + i] = i;
            expectedOutVec.add(2 * i);
        }
        expectedOutArray[30] = 1;
        expectedOutArray[31] = 2;
        int[] outArray = proxy.doSomethingElse(paramArray);
        ExpectTrue(java.util.Objects.deepEquals(outArray, expectedOutArray));
        ArrayList<Integer> outVec = proxy.mapThisVector(paramVec);
        java.util.Objects.equals(outVec, expectedOutVec);
    }
    Expect(proxy.doStuffAndReturnAString(), "Hello, world!");
    BazCallback cb = new BazCallback();
    ExpectTrue(!cb.wasCalled());
    proxy.callMe(cb);
    ExpectTrue(cb.wasCalled());
    ExpectTrue(proxy.useAnEnum(IBaz.SomeEnum.goober) == -64);
    {
        String[] stringArray = new String[3];
        stringArray[0] = "one";
        stringArray[1] = "two";
        stringArray[2] = "three";
        String[] expectedOutArray = new String[2];
        expectedOutArray[0] = "Hello";
        expectedOutArray[1] = "World";
        String[] outArray = proxy.haveSomeStrings(stringArray);
        ExpectTrue(java.util.Arrays.deepEquals(outArray, expectedOutArray));
        ArrayList<String> stringVec = new ArrayList<String>();
        stringVec.add("one");
        stringVec.add("two");
        stringVec.add("three");
        ArrayList<String> expectedOutVec = new ArrayList<String>();
        expectedOutVec.add("Hello");
        expectedOutVec.add("World");
        ExpectTrue(expectedOutVec.equals(proxy.haveAStringVec(stringVec)));
    }
    proxy.returnABunchOfStrings(new IBaz.returnABunchOfStringsCallback() {

        @Override
        public void onValues(String a, String b, String c) {
            Expect(a, "Eins");
            Expect(b, "Zwei");
            Expect(c, "Drei");
        }
    });
    proxy.returnABunchOfStrings((a, b, c) -> Expect(a + b + c, "EinsZweiDrei"));
    proxy.callMeLater(new BazCallback());
    System.gc();
    proxy.iAmFreeNow();
    {
        IBaz.T t1 = new IBaz.T();
        IBaz.T t2 = new IBaz.T();
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 3; j++) {
                t1.matrix5x3[i][j] = t2.matrix5x3[i][j] = (i + 1) * (j + 1);
            }
        }
        ExpectTrue(t1.equals(t2));
        ExpectTrue(t1.hashCode() == t2.hashCode());
        t2.matrix5x3[4][2] = -60;
        ExpectTrue(!t1.equals(t2));
    }
    ArrayList<NestedStruct> structs = proxy.getNestedStructs();
    ExpectTrue(structs.size() == 5);
    ExpectTrue(structs.get(1).matrices.size() == 6);
    {
        IBaz.Everything e = new IBaz.Everything();
        Expect(e.toString(), "{.number = 0, .anotherNumber = 0, .s = , " + ".vs = [], .multidimArray = [[null, null], [null, null]], " + ".sArray = [null, null, null], .anotherStruct = {.first = , .last = }, .bf = }");
        e.s = "string!";
        e.number = 127;
        e.anotherNumber = 100;
        e.vs.addAll(Arrays.asList("One", "Two", "Three"));
        for (int i = 0; i < e.multidimArray.length; i++) for (int j = 0; j < e.multidimArray[i].length; j++) e.multidimArray[i][j] = Integer.toString(i) + Integer.toString(j);
        e.bf = IBaz.BitField.VALL;
        e.anotherStruct.first = "James";
        e.anotherStruct.last = "Bond";
        Expect(e.toString(), "{.number = 127, .anotherNumber = 100, .s = string!, " + ".vs = [One, Two, Three], .multidimArray = [[00, 01], [10, 11]], " + ".sArray = [null, null, null], .anotherStruct = {.first = James, .last = Bond}, " + ".bf = V0 | V1 | V2 | V3 | VALL}");
        Expect(IBaz.BitField.toString(IBaz.BitField.VALL), "VALL");
        Expect(IBaz.BitField.toString((byte) (IBaz.BitField.V0 | IBaz.BitField.V2)), "0x5");
        Expect(IBaz.BitField.dumpBitfield(IBaz.BitField.VALL), "V0 | V1 | V2 | V3 | VALL");
        Expect(IBaz.BitField.dumpBitfield((byte) (IBaz.BitField.V1 | IBaz.BitField.V3 | 0xF0)), "V1 | V3 | 0xf0");
        Expect(proxy.toString(), IBaz.kInterfaceName + "@Proxy");
    }
    {
        // Ensure that native parcel is cleared even if the corresponding
        // Java object isn't GC'd.
        ArrayList<Integer> data4K = new ArrayList<>(1024);
        for (int i = 0; i < 1024; i++) {
            data4K.add(i);
        }
        for (int i = 0; i < 1024; i++) {
            // kernel binder buffer, and will fail.
            try {
                proxy.mapThisVector(data4K);
            } catch (RemoteException ex) {
                throw new RuntimeException("Failed at call #" + Integer.toString(i), ex);
            }
        }
    }
    {
        // TestArrays
        IBase.LotsOfPrimitiveArrays in = new IBase.LotsOfPrimitiveArrays();
        for (int i = 0; i < 128; ++i) {
            in.byte1[i] = (byte) i;
            in.boolean1[i] = (i & 4) != 0;
            in.double1[i] = i;
        }
        int m = 0;
        for (int i = 0; i < 8; ++i) {
            for (int j = 0; j < 128; ++j, ++m) {
                in.byte2[i][j] = (byte) m;
                in.boolean2[i][j] = (m & 4) != 0;
                in.double2[i][j] = m;
            }
        }
        m = 0;
        for (int i = 0; i < 8; ++i) {
            for (int j = 0; j < 16; ++j) {
                for (int k = 0; k < 128; ++k, ++m) {
                    in.byte3[i][j][k] = (byte) m;
                    in.boolean3[i][j][k] = (m & 4) != 0;
                    in.double3[i][j][k] = m;
                }
            }
        }
        IBase.LotsOfPrimitiveArrays out = proxy.testArrays(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testByteVecs
        ArrayList<byte[]> in = new ArrayList<byte[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            byte[] elem = new byte[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = (byte) k;
            }
            in.add(elem);
        }
        ArrayList<byte[]> out = proxy.testByteVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testBooleanVecs
        ArrayList<boolean[]> in = new ArrayList<boolean[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            boolean[] elem = new boolean[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = (k & 4) != 0;
            }
            in.add(elem);
        }
        ArrayList<boolean[]> out = proxy.testBooleanVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testDoubleVecs
        ArrayList<double[]> in = new ArrayList<double[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            double[] elem = new double[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = k;
            }
            in.add(elem);
        }
        ArrayList<double[]> out = proxy.testDoubleVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        IBase proxy1 = IBase.getService("baz");
        IBase proxy2 = IBase.getService("baz");
        ExpectTrue(proxy1.equals(proxy2));
        ExpectTrue(proxy2.equals(proxy1));
        // test hash
        java.util.HashSet<IBase> set = new java.util.HashSet<>();
        set.add(proxy1);
        ExpectTrue(set.contains(proxy2));
    }
    // --- DEATH RECIPIENT TESTING ---
    // This must always be done last, since it will kill the native server process
    HidlDeathRecipient recipient1 = new HidlDeathRecipient();
    HidlDeathRecipient recipient2 = new HidlDeathRecipient();
    final int cookie1 = 0x1481;
    final int cookie2 = 0x1482;
    ExpectTrue(proxy.linkToDeath(recipient1, cookie1));
    ExpectTrue(proxy.linkToDeath(recipient2, cookie2));
    ExpectTrue(proxy.unlinkToDeath(recipient2));
    try {
        proxy.dieNow();
    } catch (RemoteException e) {
    // Expected
    }
    ExpectTrue(recipient1.waitUntilServiceDied(2000));
    ExpectTrue(!recipient2.waitUntilServiceDied(2000));
    ExpectTrue(recipient1.cookieMatches(cookie1));
    Log.d(TAG, "OK, exiting");
}
#method_after
private void client() throws RemoteException {
    ExpectDeepEq(null, null);
    ExpectDeepNe(null, new String());
    ExpectDeepNe(new String(), null);
    ExpectDeepEq(new String(), new String());
    ExpectDeepEq("hey", "hey");
    ExpectDeepEq(new int[] { 1, 2 }, new int[] { 1, 2 });
    ExpectDeepNe(new int[] { 1, 2 }, new int[] { 1, 3 });
    ExpectDeepNe(new int[] { 1, 2 }, new int[] { 1, 2, 3 });
    ExpectDeepEq(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 4 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 5 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2, 3 }, { 4, 5, 6 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 4, 5 } });
    ExpectDeepEq(new Integer[] { 1, 2 }, new Integer[] { 1, 2 });
    ExpectDeepNe(new Integer[] { 1, 2 }, new Integer[] { 1, 3 });
    ExpectDeepNe(new Integer[] { 1, 2 }, new Integer[] { 1, 2, 3 });
    ExpectDeepEq(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 4 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 5 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2, 3 }, { 4, 5, 6 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 4, 5 } });
    ExpectDeepEq(new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(1, 2)));
    ExpectDeepNe(new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(1, 2, 3)));
    ExpectDeepEq(new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })), new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })));
    ExpectDeepNe(new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })), new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 5 })));
    ExpectDeepEq(new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })), new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })));
    ExpectDeepNe(new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })), new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 5 })));
    ExpectDeepEq(new ArrayList[] { new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(3, 4)) }, new ArrayList[] { new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(3, 4)) });
    {
        // Test proper exceptions are thrown
        try {
            IBase proxy = IBase.getService("this-doesn't-exist");
        } catch (Exception e) {
            ExpectTrue(e instanceof NoSuchElementException);
        }
    }
    {
        // Test access through base interface binder.
        IBase baseProxy = IBase.getService("baz");
        baseProxy.someBaseMethod();
        IBaz bazProxy = IBaz.castFrom(baseProxy);
        ExpectTrue(bazProxy != null);
        // IQuux is completely unrelated to IBase/IBaz, so the following
        // should fail, i.e. return null.
        IQuux quuxProxy = IQuux.castFrom(baseProxy);
        ExpectTrue(quuxProxy == null);
    }
    {
        // Test waiting API
        IBase baseProxyA = IBaz.getService("baz", true);
        ExpectTrue(baseProxyA != null);
        IBase baseProxyB = IBaz.getService("baz", false);
        ExpectTrue(baseProxyB != null);
    }
    IBaz proxy = IBaz.getService("baz");
    proxy.someBaseMethod();
    {
        Expect(proxy.interfaceDescriptor(), IBaz.kInterfaceName);
    }
    {
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        IBase.Foo result = proxy.someOtherBaseMethod(foo);
        ExpectTrue(result.equals(foo));
    }
    {
        IBase.Foo[] inputArray = new IBase.Foo[2];
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputArray[0] = foo;
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputArray[1] = foo;
        IBase.Foo[] expectedOutputArray = new IBase.Foo[2];
        expectedOutputArray[0] = inputArray[1];
        expectedOutputArray[1] = inputArray[0];
        IBase.Foo[] outputArray = proxy.someMethodWithFooArrays(inputArray);
        ExpectTrue(java.util.Objects.deepEquals(outputArray, expectedOutputArray));
    }
    {
        ArrayList<IBase.Foo> inputVec = new ArrayList<IBase.Foo>();
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputVec.add(foo);
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputVec.add(foo);
        ArrayList<IBase.Foo> expectedOutputVec = new ArrayList<IBase.Foo>();
        expectedOutputVec.add(inputVec.get(1));
        expectedOutputVec.add(inputVec.get(0));
        ArrayList<IBase.Foo> outputVec = proxy.someMethodWithFooVectors(inputVec);
        ExpectTrue(java.util.Objects.deepEquals(outputVec, expectedOutputVec));
    }
    {
        IBase.VectorOfArray in = new IBase.VectorOfArray();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.addresses.add(mac);
        }
        IBase.VectorOfArray expectedOut = new IBase.VectorOfArray();
        int n = in.addresses.size();
        for (int i = 0; i < n; ++i) {
            expectedOut.addresses.add(in.addresses.get(n - 1 - i));
        }
        IBase.VectorOfArray out = proxy.someMethodWithVectorOfArray(in);
        ExpectTrue(out.equals(expectedOut));
    }
    {
        ArrayList<byte[]> in = new ArrayList<byte[]>();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.add(mac);
        }
        ArrayList<byte[]> expectedOut = new ArrayList<byte[]>();
        int n = in.size();
        for (int i = 0; i < n; ++i) {
            expectedOut.add(in.get(n - 1 - i));
        }
        ArrayList<byte[]> out = proxy.someMethodTakingAVectorOfArray(in);
        ExpectTrue(out.size() == expectedOut.size());
        for (int i = 0; i < n; ++i) {
            ExpectTrue(java.util.Objects.deepEquals(out.get(i), expectedOut.get(i)));
        }
    }
    {
        IBase.StringMatrix5x3 in = new IBase.StringMatrix5x3();
        IBase.StringMatrix3x5 expectedOut = new IBase.StringMatrix3x5();
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in.s[i][j] = numberToEnglish(3 * i + j + 1);
                expectedOut.s[j][i] = in.s[i][j];
            }
        }
        IBase.StringMatrix3x5 out = proxy.transpose(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        ExpectTrue(out.equals(expectedOut));
    }
    {
        String[][] in = new String[5][3];
        String[][] expectedOut = new String[3][5];
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in[i][j] = numberToEnglish(3 * i + j + 1);
                expectedOut[j][i] = in[i][j];
            }
        }
        String[][] out = proxy.transpose2(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        ExpectTrue(java.util.Arrays.deepEquals(out, expectedOut));
    }
    ExpectTrue(proxy.someBoolMethod(true) == false);
    {
        boolean[] someBoolArray = new boolean[3];
        someBoolArray[0] = true;
        someBoolArray[1] = false;
        someBoolArray[2] = true;
        boolean[] resultArray = proxy.someBoolArrayMethod(someBoolArray);
        ExpectTrue(resultArray[0] == false);
        ExpectTrue(resultArray[1] == true);
        ExpectTrue(resultArray[2] == false);
        ArrayList<Boolean> someBoolVec = new ArrayList<Boolean>();
        someBoolVec.add(true);
        someBoolVec.add(false);
        someBoolVec.add(true);
        ArrayList<Boolean> resultVec = proxy.someBoolVectorMethod(someBoolVec);
        ExpectTrue(resultVec.get(0) == false);
        ExpectTrue(resultVec.get(1) == true);
        ExpectTrue(resultVec.get(2) == false);
    }
    proxy.doThis(1.0f);
    ExpectTrue(proxy.doThatAndReturnSomething(1) == 666);
    ExpectTrue(proxy.doQuiteABit(1, 2L, 3.0f, 4.0) == 666.5);
    {
        int[] paramArray = new int[15];
        int[] expectedOutArray = new int[32];
        ArrayList<Integer> paramVec = new ArrayList<Integer>();
        ArrayList<Integer> expectedOutVec = new ArrayList<Integer>();
        for (int i = 0; i < paramArray.length; ++i) {
            paramArray[i] = i;
            paramVec.add(i);
            expectedOutArray[i] = 2 * i;
            expectedOutArray[15 + i] = i;
            expectedOutVec.add(2 * i);
        }
        expectedOutArray[30] = 1;
        expectedOutArray[31] = 2;
        int[] outArray = proxy.doSomethingElse(paramArray);
        ExpectTrue(java.util.Objects.deepEquals(outArray, expectedOutArray));
        ArrayList<Integer> outVec = proxy.mapThisVector(paramVec);
        java.util.Objects.equals(outVec, expectedOutVec);
    }
    Expect(proxy.doStuffAndReturnAString(), "Hello, world!");
    BazCallback cb = new BazCallback();
    ExpectTrue(!cb.wasCalled());
    proxy.callMe(cb);
    ExpectTrue(cb.wasCalled());
    ExpectTrue(proxy.useAnEnum(IBaz.SomeEnum.goober) == -64);
    {
        String[] stringArray = new String[3];
        stringArray[0] = "one";
        stringArray[1] = "two";
        stringArray[2] = "three";
        String[] expectedOutArray = new String[2];
        expectedOutArray[0] = "Hello";
        expectedOutArray[1] = "World";
        String[] outArray = proxy.haveSomeStrings(stringArray);
        ExpectTrue(java.util.Arrays.deepEquals(outArray, expectedOutArray));
        ArrayList<String> stringVec = new ArrayList<String>();
        stringVec.add("one");
        stringVec.add("two");
        stringVec.add("three");
        ArrayList<String> expectedOutVec = new ArrayList<String>();
        expectedOutVec.add("Hello");
        expectedOutVec.add("World");
        ExpectTrue(expectedOutVec.equals(proxy.haveAStringVec(stringVec)));
    }
    proxy.returnABunchOfStrings(new IBaz.returnABunchOfStringsCallback() {

        @Override
        public void onValues(String a, String b, String c) {
            Expect(a, "Eins");
            Expect(b, "Zwei");
            Expect(c, "Drei");
        }
    });
    proxy.returnABunchOfStrings((a, b, c) -> Expect(a + b + c, "EinsZweiDrei"));
    proxy.callMeLater(new BazCallback());
    System.gc();
    proxy.iAmFreeNow();
    {
        IBaz.T t1 = new IBaz.T();
        IBaz.T t2 = new IBaz.T();
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 3; j++) {
                t1.matrix5x3[i][j] = t2.matrix5x3[i][j] = (i + 1) * (j + 1);
            }
        }
        ExpectTrue(t1.equals(t2));
        ExpectTrue(t1.hashCode() == t2.hashCode());
        t2.matrix5x3[4][2] = -60;
        ExpectTrue(!t1.equals(t2));
    }
    ArrayList<NestedStruct> structs = proxy.getNestedStructs();
    ExpectTrue(structs.size() == 5);
    ExpectTrue(structs.get(1).matrices.size() == 6);
    {
        IBaz.Everything e = new IBaz.Everything();
        Expect(e.toString(), "{.number = 0, .anotherNumber = 0, .s = , " + ".vs = [], .multidimArray = [[null, null], [null, null]], " + ".sArray = [null, null, null], .anotherStruct = {.first = , .last = }, .bf = }");
        e.s = "string!";
        e.number = 127;
        e.anotherNumber = 100;
        e.vs.addAll(Arrays.asList("One", "Two", "Three"));
        for (int i = 0; i < e.multidimArray.length; i++) for (int j = 0; j < e.multidimArray[i].length; j++) e.multidimArray[i][j] = Integer.toString(i) + Integer.toString(j);
        e.bf = IBaz.BitField.VALL;
        e.anotherStruct.first = "James";
        e.anotherStruct.last = "Bond";
        Expect(e.toString(), "{.number = 127, .anotherNumber = 100, .s = string!, " + ".vs = [One, Two, Three], .multidimArray = [[00, 01], [10, 11]], " + ".sArray = [null, null, null], .anotherStruct = {.first = James, .last = Bond}, " + ".bf = V0 | V1 | V2 | V3 | VALL}");
        Expect(IBaz.BitField.toString(IBaz.BitField.VALL), "VALL");
        Expect(IBaz.BitField.toString((byte) (IBaz.BitField.V0 | IBaz.BitField.V2)), "0x5");
        Expect(IBaz.BitField.dumpBitfield(IBaz.BitField.VALL), "V0 | V1 | V2 | V3 | VALL");
        Expect(IBaz.BitField.dumpBitfield((byte) (IBaz.BitField.V1 | IBaz.BitField.V3 | 0xF0)), "V1 | V3 | 0xf0");
        Expect(proxy.toString(), IBaz.kInterfaceName + "@Proxy");
    }
    {
        // Ensure that native parcel is cleared even if the corresponding
        // Java object isn't GC'd.
        ArrayList<Integer> data4K = new ArrayList<>(1024);
        for (int i = 0; i < 1024; i++) {
            data4K.add(i);
        }
        for (int i = 0; i < 1024; i++) {
            // kernel binder buffer, and will fail.
            try {
                proxy.mapThisVector(data4K);
            } catch (RemoteException ex) {
                throw new RuntimeException("Failed at call #" + Integer.toString(i), ex);
            }
        }
    }
    {
        // TestArrays
        IBase.LotsOfPrimitiveArrays in = new IBase.LotsOfPrimitiveArrays();
        for (int i = 0; i < 128; ++i) {
            in.byte1[i] = (byte) i;
            in.boolean1[i] = (i & 4) != 0;
            in.double1[i] = i;
        }
        int m = 0;
        for (int i = 0; i < 8; ++i) {
            for (int j = 0; j < 128; ++j, ++m) {
                in.byte2[i][j] = (byte) m;
                in.boolean2[i][j] = (m & 4) != 0;
                in.double2[i][j] = m;
            }
        }
        m = 0;
        for (int i = 0; i < 8; ++i) {
            for (int j = 0; j < 16; ++j) {
                for (int k = 0; k < 128; ++k, ++m) {
                    in.byte3[i][j][k] = (byte) m;
                    in.boolean3[i][j][k] = (m & 4) != 0;
                    in.double3[i][j][k] = m;
                }
            }
        }
        IBase.LotsOfPrimitiveArrays out = proxy.testArrays(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testByteVecs
        ArrayList<byte[]> in = new ArrayList<byte[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            byte[] elem = new byte[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = (byte) k;
            }
            in.add(elem);
        }
        ArrayList<byte[]> out = proxy.testByteVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testBooleanVecs
        ArrayList<boolean[]> in = new ArrayList<boolean[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            boolean[] elem = new boolean[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = (k & 4) != 0;
            }
            in.add(elem);
        }
        ArrayList<boolean[]> out = proxy.testBooleanVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testDoubleVecs
        ArrayList<double[]> in = new ArrayList<double[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            double[] elem = new double[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = k;
            }
            in.add(elem);
        }
        ArrayList<double[]> out = proxy.testDoubleVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testProxyEquals
        // TODO(b/68727931): test passthrough services as well.
        IBase proxy1 = IBase.getService("baz");
        IBase proxy2 = IBase.getService("baz");
        IBaz proxy3 = IBaz.getService("baz");
        IBazCallback callback1 = new BazCallback();
        IBazCallback callback2 = new BazCallback();
        IServiceManager manager = IServiceManager.getService();
        // test hwbinder proxies
        // same proxy class
        ExpectEqual(proxy1, proxy2);
        // different proxy class
        ExpectEqual(proxy1, proxy3);
        // negative tests
        ExpectNotEqual(proxy1, null);
        // proxy != stub
        ExpectNotEqual(proxy1, callback1);
        ExpectNotEqual(proxy1, manager);
        // HidlSupport.interfacesEqual use overridden .equals for stubs
        ExpectEqual(callback1, callback1);
        ExpectEqual(callback1, callback2);
        callback1.hey();
        ExpectNotEqual(callback1, callback2);
        callback2.hey();
        ExpectEqual(callback1, callback2);
        // test hash for proxies
        java.util.HashSet<IBase> set = new java.util.HashSet<>();
        set.add(proxy1);
        // hash is stable
        ExpectTrue(set.contains(proxy1));
        ExpectTrue(set.contains(proxy2));
        ExpectFalse(set.contains(manager));
    }
    // --- DEATH RECIPIENT TESTING ---
    // This must always be done last, since it will kill the native server process
    HidlDeathRecipient recipient1 = new HidlDeathRecipient();
    HidlDeathRecipient recipient2 = new HidlDeathRecipient();
    final int cookie1 = 0x1481;
    final int cookie2 = 0x1482;
    ExpectTrue(proxy.linkToDeath(recipient1, cookie1));
    ExpectTrue(proxy.linkToDeath(recipient2, cookie2));
    ExpectTrue(proxy.unlinkToDeath(recipient2));
    try {
        proxy.dieNow();
    } catch (RemoteException e) {
    // Expected
    }
    ExpectTrue(recipient1.waitUntilServiceDied(2000));
    ExpectTrue(!recipient2.waitUntilServiceDied(2000));
    ExpectTrue(recipient1.cookieMatches(cookie1));
    Log.d(TAG, "OK, exiting");
}
#end_block

#method_before
@Override
public void enter() {
    Log.d(TAG, "Enter Disconnected: " + getCurrentMessage().what);
    // cleanup
    mIndicatorNetworkState = HeadsetClientHalConstants.NETWORK_STATE_NOT_AVAILABLE;
    mIndicatorNetworkType = HeadsetClientHalConstants.SERVICE_TYPE_HOME;
    mIndicatorNetworkSignal = 0;
    mIndicatorBatteryLevel = 0;
    mAudioWbs = false;
    // will be set on connect
    mOperatorName = null;
    mSubscriberInfo = null;
    mQueuedActions = new LinkedList<Pair<Integer, Object>>();
    clearPendingAction();
    mCurrentDevice = null;
    mCalls.clear();
    mCallsUpdate.clear();
    mPeerFeatures = 0;
    mChldFeatures = 0;
    removeMessages(QUERY_CURRENT_CALLS);
    if (mPrevState == mConnecting) {
        broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_DISCONNECTED, BluetoothProfile.STATE_CONNECTING);
    } else if (mPrevState == mConnected || mPrevState == mAudioOn) {
        broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_DISCONNECTED, BluetoothProfile.STATE_CONNECTED);
    }
}
#method_after
@Override
public void enter() {
    Log.d(TAG, "Enter Disconnected: " + getCurrentMessage().what);
    // cleanup
    mIndicatorNetworkState = HeadsetClientHalConstants.NETWORK_STATE_NOT_AVAILABLE;
    mIndicatorNetworkType = HeadsetClientHalConstants.SERVICE_TYPE_HOME;
    mIndicatorNetworkSignal = 0;
    mIndicatorBatteryLevel = 0;
    mAudioWbs = false;
    // will be set on connect
    mOperatorName = null;
    mSubscriberInfo = null;
    mQueuedActions = new LinkedList<Pair<Integer, Object>>();
    clearPendingAction();
    mCurrentDevice = null;
    mCalls.clear();
    mCallsUpdate.clear();
    mPeerFeatures = 0;
    mChldFeatures = 0;
    removeMessages(QUERY_CURRENT_CALLS);
    if (mPrevState == mConnecting) {
        broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_DISCONNECTED, BluetoothProfile.STATE_CONNECTING);
    } else if (mPrevState == mConnected || mPrevState == mAudioOn) {
        broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_DISCONNECTED, BluetoothProfile.STATE_CONNECTED);
    } else if (mPrevState != null) {
        // null is the default state before Disconnected
        Log.e(TAG, "Connected: Illegal state transition from " + mPrevState.getName() + " to Connecting, mCurrentDevice=" + mCurrentDevice);
    }
}
#end_block

#method_before
@Override
public void enter() {
    if (DBG) {
        Log.d(TAG, "Enter Connecting: " + getCurrentMessage().what);
    }
    // This message is either consumed in processMessage or
    // removed in exit. It is safe to send a CONNECTING_TIMEOUT here since
    // the only transition is when connection attempt is initiated.
    sendMessageDelayed(CONNECTING_TIMEOUT, CONNECTING_TIMEOUT_MS);
    if (mPrevState == mDisconnected) {
        broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_CONNECTING, BluetoothProfile.STATE_DISCONNECTED);
    }
}
#method_after
@Override
public void enter() {
    if (DBG) {
        Log.d(TAG, "Enter Connecting: " + getCurrentMessage().what);
    }
    // This message is either consumed in processMessage or
    // removed in exit. It is safe to send a CONNECTING_TIMEOUT here since
    // the only transition is when connection attempt is initiated.
    sendMessageDelayed(CONNECTING_TIMEOUT, CONNECTING_TIMEOUT_MS);
    if (mPrevState == mDisconnected) {
        broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_CONNECTING, BluetoothProfile.STATE_DISCONNECTED);
    } else {
        String prevStateName = mPrevState == null ? "null" : mPrevState.getName();
        Log.e(TAG, "Connected: Illegal state transition from " + prevStateName + " to Connecting, mCurrentDevice=" + mCurrentDevice);
    }
}
#end_block

#method_before
@Override
public void enter() {
    if (DBG) {
        Log.d(TAG, "Enter Connected: " + getCurrentMessage().what);
    }
    mAudioWbs = false;
    mCommandedSpeakerVolume = -1;
    if (mPrevState == mConnecting) {
        broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_CONNECTING);
    } else if (mPrevState == mDisconnected) {
        broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_DISCONNECTED);
    }
}
#method_after
@Override
public void enter() {
    if (DBG) {
        Log.d(TAG, "Enter Connected: " + getCurrentMessage().what);
    }
    mAudioWbs = false;
    mCommandedSpeakerVolume = -1;
    if (mPrevState == mConnecting) {
        broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_CONNECTING);
    } else if (mPrevState != mAudioOn) {
        String prevStateName = mPrevState == null ? "null" : mPrevState.getName();
        Log.e(TAG, "Connected: Illegal state transition from " + prevStateName + " to Connecting, mCurrentDevice=" + mCurrentDevice);
    }
}
#end_block

#method_before
@Override
public synchronized boolean processMessage(Message message) {
    if (DBG) {
        Log.d(TAG, "Connected process message: " + message.what);
    }
    if (DBG) {
        if (mCurrentDevice == null) {
            Log.e(TAG, "ERROR: mCurrentDevice is null in Connected");
            return NOT_HANDLED;
        }
    }
    switch(message.what) {
        case CONNECT:
            BluetoothDevice device = (BluetoothDevice) message.obj;
            if (mCurrentDevice.equals(device)) {
                // already connected to this device, do nothing
                break;
            }
            NativeInterface.connectNative(getByteAddress(device));
            break;
        case DISCONNECT:
            BluetoothDevice dev = (BluetoothDevice) message.obj;
            if (!mCurrentDevice.equals(dev)) {
                break;
            }
            // No state transition is involved, fire broadcast immediately
            broadcastConnectionState(dev, BluetoothProfile.STATE_DISCONNECTING, BluetoothProfile.STATE_CONNECTED);
            if (!NativeInterface.disconnectNative(getByteAddress(dev))) {
                // disconnecting failed
                // No state transition is involved, fire broadcast immediately
                broadcastConnectionState(dev, BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_DISCONNECTING);
                break;
            }
            break;
        case CONNECT_AUDIO:
            if (!NativeInterface.connectAudioNative(getByteAddress(mCurrentDevice))) {
                Log.e(TAG, "ERROR: Couldn't connect Audio for device " + mCurrentDevice);
                // No state transition is involved, fire broadcast immediately
                broadcastAudioState(mCurrentDevice, BluetoothHeadsetClient.STATE_AUDIO_DISCONNECTED, BluetoothHeadsetClient.STATE_AUDIO_DISCONNECTED);
            } else {
                // We have successfully sent a connect request!
                mAudioState = BluetoothHeadsetClient.STATE_AUDIO_CONNECTING;
            }
            break;
        case DISCONNECT_AUDIO:
            if (!NativeInterface.disconnectAudioNative(getByteAddress(mCurrentDevice))) {
                Log.e(TAG, "ERROR: Couldn't disconnect Audio for device " + mCurrentDevice);
            }
            break;
        case VOICE_RECOGNITION_START:
            if (mVoiceRecognitionActive == HeadsetClientHalConstants.VR_STATE_STOPPED) {
                if (NativeInterface.startVoiceRecognitionNative(getByteAddress(mCurrentDevice))) {
                    addQueuedAction(VOICE_RECOGNITION_START);
                } else {
                    Log.e(TAG, "ERROR: Couldn't start voice recognition");
                }
            }
            break;
        case VOICE_RECOGNITION_STOP:
            if (mVoiceRecognitionActive == HeadsetClientHalConstants.VR_STATE_STARTED) {
                if (NativeInterface.stopVoiceRecognitionNative(getByteAddress(mCurrentDevice))) {
                    addQueuedAction(VOICE_RECOGNITION_STOP);
                } else {
                    Log.e(TAG, "ERROR: Couldn't stop voice recognition");
                }
            }
            break;
        // Called only for Mute/Un-mute - Mic volume change is not allowed.
        case SET_MIC_VOLUME:
            break;
        case SET_SPEAKER_VOLUME:
            // This message should always contain the volume in AudioManager max normalized.
            int amVol = message.arg1;
            int hfVol = amToHfVol(amVol);
            if (amVol != mCommandedSpeakerVolume) {
                Log.d(TAG, "Volume" + amVol + ":" + mCommandedSpeakerVolume);
                // Volume was changed by a 3rd party
                mCommandedSpeakerVolume = -1;
                if (NativeInterface.setVolumeNative(getByteAddress(mCurrentDevice), HeadsetClientHalConstants.VOLUME_TYPE_SPK, hfVol)) {
                    addQueuedAction(SET_SPEAKER_VOLUME);
                }
            }
            break;
        case DIAL_NUMBER:
            // Add the call as an outgoing call.
            BluetoothHeadsetClientCall c = (BluetoothHeadsetClientCall) message.obj;
            mCalls.put(HF_ORIGINATED_CALL_ID, c);
            if (NativeInterface.dialNative(getByteAddress(mCurrentDevice), c.getNumber())) {
                addQueuedAction(DIAL_NUMBER, c.getNumber());
                // Start looping on calling current calls.
                sendMessage(QUERY_CURRENT_CALLS);
            } else {
                Log.e(TAG, "ERROR: Cannot dial with a given number:" + (String) message.obj);
                // Set the call to terminated remove.
                c.setState(BluetoothHeadsetClientCall.CALL_STATE_TERMINATED);
                sendCallChangedIntent(c);
                mCalls.remove(HF_ORIGINATED_CALL_ID);
            }
            break;
        case ACCEPT_CALL:
            acceptCall(message.arg1);
            break;
        case REJECT_CALL:
            rejectCall();
            break;
        case HOLD_CALL:
            holdCall();
            break;
        case TERMINATE_CALL:
            terminateCall();
            break;
        case ENTER_PRIVATE_MODE:
            enterPrivateMode(message.arg1);
            break;
        case EXPLICIT_CALL_TRANSFER:
            explicitCallTransfer();
            break;
        case SEND_DTMF:
            if (NativeInterface.sendDtmfNative(getByteAddress(mCurrentDevice), (byte) message.arg1)) {
                addQueuedAction(SEND_DTMF);
            } else {
                Log.e(TAG, "ERROR: Couldn't send DTMF");
            }
            break;
        case SUBSCRIBER_INFO:
            if (NativeInterface.retrieveSubscriberInfoNative(getByteAddress(mCurrentDevice))) {
                addQueuedAction(SUBSCRIBER_INFO);
            } else {
                Log.e(TAG, "ERROR: Couldn't retrieve subscriber info");
            }
            break;
        case QUERY_CURRENT_CALLS:
            // Whenever the timer expires we query calls if there are outstanding requests
            // for query calls.
            long currentElapsed = SystemClock.elapsedRealtime();
            if (mClccTimer < currentElapsed) {
                queryCallsStart();
                mClccTimer = currentElapsed + QUERY_CURRENT_CALLS_WAIT_MILLIS;
                // Request satisfied, ignore all other call query messages.
                removeMessages(QUERY_CURRENT_CALLS);
            } else {
                // Replace all messages with one concrete message.
                removeMessages(QUERY_CURRENT_CALLS);
                sendMessageDelayed(QUERY_CURRENT_CALLS, QUERY_CURRENT_CALLS_WAIT_MILLIS);
            }
            break;
        case StackEvent.STACK_EVENT:
            Intent intent = null;
            StackEvent event = (StackEvent) message.obj;
            if (DBG) {
                Log.d(TAG, "Connected: event type: " + event.type);
            }
            switch(event.type) {
                case StackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED:
                    if (DBG) {
                        Log.d(TAG, "Connected: Connection state changed: " + event.device + ": " + event.valueInt);
                    }
                    processConnectionEvent(event.valueInt, event.device);
                    break;
                case StackEvent.EVENT_TYPE_AUDIO_STATE_CHANGED:
                    if (DBG) {
                        Log.d(TAG, "Connected: Audio state changed: " + event.device + ": " + event.valueInt);
                    }
                    processAudioEvent(event.valueInt, event.device);
                    break;
                case StackEvent.EVENT_TYPE_NETWORK_STATE:
                    if (DBG) {
                        Log.d(TAG, "Connected: Network state: " + event.valueInt);
                    }
                    mIndicatorNetworkState = event.valueInt;
                    intent = new Intent(BluetoothHeadsetClient.ACTION_AG_EVENT);
                    intent.putExtra(BluetoothHeadsetClient.EXTRA_NETWORK_STATUS, event.valueInt);
                    if (mIndicatorNetworkState == HeadsetClientHalConstants.NETWORK_STATE_NOT_AVAILABLE) {
                        mOperatorName = null;
                        intent.putExtra(BluetoothHeadsetClient.EXTRA_OPERATOR_NAME, mOperatorName);
                    }
                    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, event.device);
                    mService.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
                    if (mIndicatorNetworkState == HeadsetClientHalConstants.NETWORK_STATE_AVAILABLE) {
                        if (NativeInterface.queryCurrentOperatorNameNative(getByteAddress(mCurrentDevice))) {
                            addQueuedAction(QUERY_OPERATOR_NAME);
                        } else {
                            Log.e(TAG, "ERROR: Couldn't querry operator name");
                        }
                    }
                    break;
                case StackEvent.EVENT_TYPE_ROAMING_STATE:
                    mIndicatorNetworkType = event.valueInt;
                    intent = new Intent(BluetoothHeadsetClient.ACTION_AG_EVENT);
                    intent.putExtra(BluetoothHeadsetClient.EXTRA_NETWORK_ROAMING, event.valueInt);
                    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, event.device);
                    mService.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
                    break;
                case StackEvent.EVENT_TYPE_NETWORK_SIGNAL:
                    mIndicatorNetworkSignal = event.valueInt;
                    intent = new Intent(BluetoothHeadsetClient.ACTION_AG_EVENT);
                    intent.putExtra(BluetoothHeadsetClient.EXTRA_NETWORK_SIGNAL_STRENGTH, event.valueInt);
                    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, event.device);
                    mService.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
                    break;
                case StackEvent.EVENT_TYPE_BATTERY_LEVEL:
                    mIndicatorBatteryLevel = event.valueInt;
                    intent = new Intent(BluetoothHeadsetClient.ACTION_AG_EVENT);
                    intent.putExtra(BluetoothHeadsetClient.EXTRA_BATTERY_LEVEL, event.valueInt);
                    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, event.device);
                    mService.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
                    break;
                case StackEvent.EVENT_TYPE_OPERATOR_NAME:
                    mOperatorName = event.valueString;
                    intent = new Intent(BluetoothHeadsetClient.ACTION_AG_EVENT);
                    intent.putExtra(BluetoothHeadsetClient.EXTRA_OPERATOR_NAME, event.valueString);
                    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, event.device);
                    mService.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
                    break;
                case StackEvent.EVENT_TYPE_VR_STATE_CHANGED:
                    if (mVoiceRecognitionActive != event.valueInt) {
                        mVoiceRecognitionActive = event.valueInt;
                        intent = new Intent(BluetoothHeadsetClient.ACTION_AG_EVENT);
                        intent.putExtra(BluetoothHeadsetClient.EXTRA_VOICE_RECOGNITION, mVoiceRecognitionActive);
                        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, event.device);
                        mService.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
                    }
                    break;
                case StackEvent.EVENT_TYPE_CALL:
                case StackEvent.EVENT_TYPE_CALLSETUP:
                case StackEvent.EVENT_TYPE_CALLHELD:
                case StackEvent.EVENT_TYPE_RESP_AND_HOLD:
                case StackEvent.EVENT_TYPE_CLIP:
                case StackEvent.EVENT_TYPE_CALL_WAITING:
                    sendMessage(QUERY_CURRENT_CALLS);
                    break;
                case StackEvent.EVENT_TYPE_CURRENT_CALLS:
                    queryCallsUpdate(event.valueInt, event.valueInt3, event.valueString, event.valueInt4 == HeadsetClientHalConstants.CALL_MPTY_TYPE_MULTI, event.valueInt2 == HeadsetClientHalConstants.CALL_DIRECTION_OUTGOING);
                    break;
                case StackEvent.EVENT_TYPE_VOLUME_CHANGED:
                    if (event.valueInt == HeadsetClientHalConstants.VOLUME_TYPE_SPK) {
                        mCommandedSpeakerVolume = hfToAmVol(event.valueInt2);
                        Log.d(TAG, "AM volume set to " + mCommandedSpeakerVolume);
                        sAudioManager.setStreamVolume(AudioManager.STREAM_VOICE_CALL, +mCommandedSpeakerVolume, AudioManager.FLAG_SHOW_UI);
                    } else if (event.valueInt == HeadsetClientHalConstants.VOLUME_TYPE_MIC) {
                        sAudioManager.setMicrophoneMute(event.valueInt2 == 0);
                    }
                    break;
                case StackEvent.EVENT_TYPE_CMD_RESULT:
                    Pair<Integer, Object> queuedAction = mQueuedActions.poll();
                    // should not happen but...
                    if (queuedAction == null || queuedAction.first == NO_ACTION) {
                        clearPendingAction();
                        break;
                    }
                    if (DBG) {
                        Log.d(TAG, "Connected: command result: " + event.valueInt + " queuedAction: " + queuedAction.first);
                    }
                    switch(queuedAction.first) {
                        case QUERY_CURRENT_CALLS:
                            queryCallsDone();
                            break;
                        case VOICE_RECOGNITION_START:
                            if (event.valueInt == AT_OK) {
                                mVoiceRecognitionActive = HeadsetClientHalConstants.VR_STATE_STARTED;
                            }
                            break;
                        case VOICE_RECOGNITION_STOP:
                            if (event.valueInt == AT_OK) {
                                mVoiceRecognitionActive = HeadsetClientHalConstants.VR_STATE_STOPPED;
                            }
                            break;
                        default:
                            Log.w(TAG, "Unhandled AT OK " + event);
                            break;
                    }
                    break;
                case StackEvent.EVENT_TYPE_SUBSCRIBER_INFO:
                    mSubscriberInfo = event.valueString;
                    intent = new Intent(BluetoothHeadsetClient.ACTION_AG_EVENT);
                    intent.putExtra(BluetoothHeadsetClient.EXTRA_SUBSCRIBER_INFO, mSubscriberInfo);
                    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, event.device);
                    mService.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
                    break;
                case StackEvent.EVENT_TYPE_RING_INDICATION:
                    // CALL_STATE_INCOMING (and similar) handle ringing.
                    break;
                default:
                    Log.e(TAG, "Unknown stack event: " + event.type);
                    break;
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public synchronized boolean processMessage(Message message) {
    if (DBG) {
        Log.d(TAG, "Connected process message: " + message.what);
    }
    if (DBG) {
        if (mCurrentDevice == null) {
            Log.e(TAG, "ERROR: mCurrentDevice is null in Connected");
            return NOT_HANDLED;
        }
    }
    switch(message.what) {
        case CONNECT:
            BluetoothDevice device = (BluetoothDevice) message.obj;
            if (mCurrentDevice.equals(device)) {
                // already connected to this device, do nothing
                break;
            }
            NativeInterface.connectNative(getByteAddress(device));
            break;
        case DISCONNECT:
            BluetoothDevice dev = (BluetoothDevice) message.obj;
            if (!mCurrentDevice.equals(dev)) {
                break;
            }
            if (NativeInterface.disconnectNative(getByteAddress(dev))) {
                // No state transition is involved, fire broadcast immediately
                broadcastConnectionState(dev, BluetoothProfile.STATE_DISCONNECTING, BluetoothProfile.STATE_CONNECTED);
            } else {
                Log.e(TAG, "disconnectNative failed for " + dev);
            }
            break;
        case CONNECT_AUDIO:
            if (!NativeInterface.connectAudioNative(getByteAddress(mCurrentDevice))) {
                Log.e(TAG, "ERROR: Couldn't connect Audio for device " + mCurrentDevice);
                // No state transition is involved, fire broadcast immediately
                broadcastAudioState(mCurrentDevice, BluetoothHeadsetClient.STATE_AUDIO_DISCONNECTED, BluetoothHeadsetClient.STATE_AUDIO_DISCONNECTED);
            } else {
                // We have successfully sent a connect request!
                mAudioState = BluetoothHeadsetClient.STATE_AUDIO_CONNECTING;
            }
            break;
        case DISCONNECT_AUDIO:
            if (!NativeInterface.disconnectAudioNative(getByteAddress(mCurrentDevice))) {
                Log.e(TAG, "ERROR: Couldn't disconnect Audio for device " + mCurrentDevice);
            }
            break;
        case VOICE_RECOGNITION_START:
            if (mVoiceRecognitionActive == HeadsetClientHalConstants.VR_STATE_STOPPED) {
                if (NativeInterface.startVoiceRecognitionNative(getByteAddress(mCurrentDevice))) {
                    addQueuedAction(VOICE_RECOGNITION_START);
                } else {
                    Log.e(TAG, "ERROR: Couldn't start voice recognition");
                }
            }
            break;
        case VOICE_RECOGNITION_STOP:
            if (mVoiceRecognitionActive == HeadsetClientHalConstants.VR_STATE_STARTED) {
                if (NativeInterface.stopVoiceRecognitionNative(getByteAddress(mCurrentDevice))) {
                    addQueuedAction(VOICE_RECOGNITION_STOP);
                } else {
                    Log.e(TAG, "ERROR: Couldn't stop voice recognition");
                }
            }
            break;
        // Called only for Mute/Un-mute - Mic volume change is not allowed.
        case SET_MIC_VOLUME:
            break;
        case SET_SPEAKER_VOLUME:
            // This message should always contain the volume in AudioManager max normalized.
            int amVol = message.arg1;
            int hfVol = amToHfVol(amVol);
            if (amVol != mCommandedSpeakerVolume) {
                Log.d(TAG, "Volume" + amVol + ":" + mCommandedSpeakerVolume);
                // Volume was changed by a 3rd party
                mCommandedSpeakerVolume = -1;
                if (NativeInterface.setVolumeNative(getByteAddress(mCurrentDevice), HeadsetClientHalConstants.VOLUME_TYPE_SPK, hfVol)) {
                    addQueuedAction(SET_SPEAKER_VOLUME);
                }
            }
            break;
        case DIAL_NUMBER:
            // Add the call as an outgoing call.
            BluetoothHeadsetClientCall c = (BluetoothHeadsetClientCall) message.obj;
            mCalls.put(HF_ORIGINATED_CALL_ID, c);
            if (NativeInterface.dialNative(getByteAddress(mCurrentDevice), c.getNumber())) {
                addQueuedAction(DIAL_NUMBER, c.getNumber());
                // Start looping on calling current calls.
                sendMessage(QUERY_CURRENT_CALLS);
            } else {
                Log.e(TAG, "ERROR: Cannot dial with a given number:" + (String) message.obj);
                // Set the call to terminated remove.
                c.setState(BluetoothHeadsetClientCall.CALL_STATE_TERMINATED);
                sendCallChangedIntent(c);
                mCalls.remove(HF_ORIGINATED_CALL_ID);
            }
            break;
        case ACCEPT_CALL:
            acceptCall(message.arg1);
            break;
        case REJECT_CALL:
            rejectCall();
            break;
        case HOLD_CALL:
            holdCall();
            break;
        case TERMINATE_CALL:
            terminateCall();
            break;
        case ENTER_PRIVATE_MODE:
            enterPrivateMode(message.arg1);
            break;
        case EXPLICIT_CALL_TRANSFER:
            explicitCallTransfer();
            break;
        case SEND_DTMF:
            if (NativeInterface.sendDtmfNative(getByteAddress(mCurrentDevice), (byte) message.arg1)) {
                addQueuedAction(SEND_DTMF);
            } else {
                Log.e(TAG, "ERROR: Couldn't send DTMF");
            }
            break;
        case SUBSCRIBER_INFO:
            if (NativeInterface.retrieveSubscriberInfoNative(getByteAddress(mCurrentDevice))) {
                addQueuedAction(SUBSCRIBER_INFO);
            } else {
                Log.e(TAG, "ERROR: Couldn't retrieve subscriber info");
            }
            break;
        case QUERY_CURRENT_CALLS:
            // Whenever the timer expires we query calls if there are outstanding requests
            // for query calls.
            long currentElapsed = SystemClock.elapsedRealtime();
            if (mClccTimer < currentElapsed) {
                queryCallsStart();
                mClccTimer = currentElapsed + QUERY_CURRENT_CALLS_WAIT_MILLIS;
                // Request satisfied, ignore all other call query messages.
                removeMessages(QUERY_CURRENT_CALLS);
            } else {
                // Replace all messages with one concrete message.
                removeMessages(QUERY_CURRENT_CALLS);
                sendMessageDelayed(QUERY_CURRENT_CALLS, QUERY_CURRENT_CALLS_WAIT_MILLIS);
            }
            break;
        case StackEvent.STACK_EVENT:
            Intent intent = null;
            StackEvent event = (StackEvent) message.obj;
            if (DBG) {
                Log.d(TAG, "Connected: event type: " + event.type);
            }
            switch(event.type) {
                case StackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED:
                    if (DBG) {
                        Log.d(TAG, "Connected: Connection state changed: " + event.device + ": " + event.valueInt);
                    }
                    processConnectionEvent(event.valueInt, event.device);
                    break;
                case StackEvent.EVENT_TYPE_AUDIO_STATE_CHANGED:
                    if (DBG) {
                        Log.d(TAG, "Connected: Audio state changed: " + event.device + ": " + event.valueInt);
                    }
                    processAudioEvent(event.valueInt, event.device);
                    break;
                case StackEvent.EVENT_TYPE_NETWORK_STATE:
                    if (DBG) {
                        Log.d(TAG, "Connected: Network state: " + event.valueInt);
                    }
                    mIndicatorNetworkState = event.valueInt;
                    intent = new Intent(BluetoothHeadsetClient.ACTION_AG_EVENT);
                    intent.putExtra(BluetoothHeadsetClient.EXTRA_NETWORK_STATUS, event.valueInt);
                    if (mIndicatorNetworkState == HeadsetClientHalConstants.NETWORK_STATE_NOT_AVAILABLE) {
                        mOperatorName = null;
                        intent.putExtra(BluetoothHeadsetClient.EXTRA_OPERATOR_NAME, mOperatorName);
                    }
                    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, event.device);
                    mService.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
                    if (mIndicatorNetworkState == HeadsetClientHalConstants.NETWORK_STATE_AVAILABLE) {
                        if (NativeInterface.queryCurrentOperatorNameNative(getByteAddress(mCurrentDevice))) {
                            addQueuedAction(QUERY_OPERATOR_NAME);
                        } else {
                            Log.e(TAG, "ERROR: Couldn't querry operator name");
                        }
                    }
                    break;
                case StackEvent.EVENT_TYPE_ROAMING_STATE:
                    mIndicatorNetworkType = event.valueInt;
                    intent = new Intent(BluetoothHeadsetClient.ACTION_AG_EVENT);
                    intent.putExtra(BluetoothHeadsetClient.EXTRA_NETWORK_ROAMING, event.valueInt);
                    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, event.device);
                    mService.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
                    break;
                case StackEvent.EVENT_TYPE_NETWORK_SIGNAL:
                    mIndicatorNetworkSignal = event.valueInt;
                    intent = new Intent(BluetoothHeadsetClient.ACTION_AG_EVENT);
                    intent.putExtra(BluetoothHeadsetClient.EXTRA_NETWORK_SIGNAL_STRENGTH, event.valueInt);
                    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, event.device);
                    mService.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
                    break;
                case StackEvent.EVENT_TYPE_BATTERY_LEVEL:
                    mIndicatorBatteryLevel = event.valueInt;
                    intent = new Intent(BluetoothHeadsetClient.ACTION_AG_EVENT);
                    intent.putExtra(BluetoothHeadsetClient.EXTRA_BATTERY_LEVEL, event.valueInt);
                    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, event.device);
                    mService.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
                    break;
                case StackEvent.EVENT_TYPE_OPERATOR_NAME:
                    mOperatorName = event.valueString;
                    intent = new Intent(BluetoothHeadsetClient.ACTION_AG_EVENT);
                    intent.putExtra(BluetoothHeadsetClient.EXTRA_OPERATOR_NAME, event.valueString);
                    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, event.device);
                    mService.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
                    break;
                case StackEvent.EVENT_TYPE_VR_STATE_CHANGED:
                    if (mVoiceRecognitionActive != event.valueInt) {
                        mVoiceRecognitionActive = event.valueInt;
                        intent = new Intent(BluetoothHeadsetClient.ACTION_AG_EVENT);
                        intent.putExtra(BluetoothHeadsetClient.EXTRA_VOICE_RECOGNITION, mVoiceRecognitionActive);
                        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, event.device);
                        mService.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
                    }
                    break;
                case StackEvent.EVENT_TYPE_CALL:
                case StackEvent.EVENT_TYPE_CALLSETUP:
                case StackEvent.EVENT_TYPE_CALLHELD:
                case StackEvent.EVENT_TYPE_RESP_AND_HOLD:
                case StackEvent.EVENT_TYPE_CLIP:
                case StackEvent.EVENT_TYPE_CALL_WAITING:
                    sendMessage(QUERY_CURRENT_CALLS);
                    break;
                case StackEvent.EVENT_TYPE_CURRENT_CALLS:
                    queryCallsUpdate(event.valueInt, event.valueInt3, event.valueString, event.valueInt4 == HeadsetClientHalConstants.CALL_MPTY_TYPE_MULTI, event.valueInt2 == HeadsetClientHalConstants.CALL_DIRECTION_OUTGOING);
                    break;
                case StackEvent.EVENT_TYPE_VOLUME_CHANGED:
                    if (event.valueInt == HeadsetClientHalConstants.VOLUME_TYPE_SPK) {
                        mCommandedSpeakerVolume = hfToAmVol(event.valueInt2);
                        Log.d(TAG, "AM volume set to " + mCommandedSpeakerVolume);
                        sAudioManager.setStreamVolume(AudioManager.STREAM_VOICE_CALL, +mCommandedSpeakerVolume, AudioManager.FLAG_SHOW_UI);
                    } else if (event.valueInt == HeadsetClientHalConstants.VOLUME_TYPE_MIC) {
                        sAudioManager.setMicrophoneMute(event.valueInt2 == 0);
                    }
                    break;
                case StackEvent.EVENT_TYPE_CMD_RESULT:
                    Pair<Integer, Object> queuedAction = mQueuedActions.poll();
                    // should not happen but...
                    if (queuedAction == null || queuedAction.first == NO_ACTION) {
                        clearPendingAction();
                        break;
                    }
                    if (DBG) {
                        Log.d(TAG, "Connected: command result: " + event.valueInt + " queuedAction: " + queuedAction.first);
                    }
                    switch(queuedAction.first) {
                        case QUERY_CURRENT_CALLS:
                            queryCallsDone();
                            break;
                        case VOICE_RECOGNITION_START:
                            if (event.valueInt == AT_OK) {
                                mVoiceRecognitionActive = HeadsetClientHalConstants.VR_STATE_STARTED;
                            }
                            break;
                        case VOICE_RECOGNITION_STOP:
                            if (event.valueInt == AT_OK) {
                                mVoiceRecognitionActive = HeadsetClientHalConstants.VR_STATE_STOPPED;
                            }
                            break;
                        default:
                            Log.w(TAG, "Unhandled AT OK " + event);
                            break;
                    }
                    break;
                case StackEvent.EVENT_TYPE_SUBSCRIBER_INFO:
                    mSubscriberInfo = event.valueString;
                    intent = new Intent(BluetoothHeadsetClient.ACTION_AG_EVENT);
                    intent.putExtra(BluetoothHeadsetClient.EXTRA_SUBSCRIBER_INFO, mSubscriberInfo);
                    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, event.device);
                    mService.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
                    break;
                case StackEvent.EVENT_TYPE_RING_INDICATION:
                    // CALL_STATE_INCOMING (and similar) handle ringing.
                    break;
                default:
                    Log.e(TAG, "Unknown stack event: " + event.type);
                    break;
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
private void initializeCarrierApps() {
    // Initialize carrier apps:
    // -Now (on system startup)
    // -Whenever new carrier privilege rules might change (new SIM is loaded)
    // -Whenever we switch to a new user
    mCurrentlyActiveUserId = 0;
    try {
        ActivityManagerNative.getDefault().registerUserSwitchObserver(new IUserSwitchObserver.Stub() {

            @Override
            public void onUserSwitching(int newUserId, IRemoteCallback reply) throws RemoteException {
                mCurrentlyActiveUserId = newUserId;
                CarrierAppUtils.disableCarrierAppsUntilPrivileged(mContext.getOpPackageName(), mPackageManager, TelephonyManager.getDefault(), mContext.getContentResolver(), mCurrentlyActiveUserId);
                if (reply != null) {
                    try {
                        reply.sendResult(null);
                    } catch (RemoteException e) {
                    }
                }
            }

            @Override
            public void onUserSwitchComplete(int newUserId) {
            // Ignore.
            }

            @Override
            public void onForegroundProfileSwitch(int newProfileId) throws RemoteException {
            // Ignore.
            }
        }, LOG_TAG);
        mCurrentlyActiveUserId = ActivityManagerNative.getDefault().getCurrentUser().id;
    } catch (RemoteException e) {
        logd("Couldn't get current user ID; guessing it's 0: " + e.getMessage());
    }
    CarrierAppUtils.disableCarrierAppsUntilPrivileged(mContext.getOpPackageName(), mPackageManager, TelephonyManager.getDefault(), mContext.getContentResolver(), mCurrentlyActiveUserId);
}
#method_after
private void initializeCarrierApps() {
    // Initialize carrier apps:
    // -Now (on system startup)
    // -Whenever new carrier privilege rules might change (new SIM is loaded)
    // -Whenever we switch to a new user
    mCurrentlyActiveUserId = 0;
    try {
        ActivityManager.getService().registerUserSwitchObserver(new UserSwitchObserver() {

            @Override
            public void onUserSwitching(int newUserId, IRemoteCallback reply) throws RemoteException {
                mCurrentlyActiveUserId = newUserId;
                CarrierAppUtils.disableCarrierAppsUntilPrivileged(mContext.getOpPackageName(), mPackageManager, TelephonyManager.getDefault(), mContext.getContentResolver(), mCurrentlyActiveUserId);
                if (reply != null) {
                    try {
                        reply.sendResult(null);
                    } catch (RemoteException e) {
                    }
                }
            }
        }, LOG_TAG);
        mCurrentlyActiveUserId = ActivityManager.getService().getCurrentUser().id;
    } catch (RemoteException e) {
        logd("Couldn't get current user ID; guessing it's 0: " + e.getMessage());
    }
    CarrierAppUtils.disableCarrierAppsUntilPrivileged(mContext.getOpPackageName(), mPackageManager, TelephonyManager.getDefault(), mContext.getContentResolver(), mCurrentlyActiveUserId);
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_SIM_LOCKED_QUERY_ICCID_DONE:
            {
                AsyncResult ar = (AsyncResult) msg.obj;
                QueryIccIdUserObj uObj = (QueryIccIdUserObj) ar.userObj;
                int slotId = uObj.slotId;
                logd("handleMessage : <EVENT_SIM_LOCKED_QUERY_ICCID_DONE> SIM" + (slotId + 1));
                if (ar.exception == null) {
                    if (ar.result != null) {
                        byte[] data = (byte[]) ar.result;
                        mIccId[slotId] = IccUtils.bchToString(data, 0, data.length);
                    } else {
                        logd("Null ar");
                        mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
                    }
                } else {
                    mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
                    logd("Query IccId fail: " + ar.exception);
                }
                logd("sIccId[" + slotId + "] = " + mIccId[slotId]);
                if (isAllIccIdQueryDone()) {
                    updateSubscriptionInfoByIccId();
                }
                broadcastSimStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED, uObj.reason);
                if (!ICCID_STRING_FOR_NO_SIM.equals(mIccId[slotId])) {
                    updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED);
                }
                break;
            }
        case EVENT_GET_NETWORK_SELECTION_MODE_DONE:
            {
                AsyncResult ar = (AsyncResult) msg.obj;
                Integer slotId = (Integer) ar.userObj;
                if (ar.exception == null && ar.result != null) {
                    int[] modes = (int[]) ar.result;
                    if (modes[0] == 1) {
                        // Manual mode.
                        mPhone[slotId].setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    logd("EVENT_GET_NETWORK_SELECTION_MODE_DONE: error getting network mode.");
                }
                break;
            }
        case EVENT_SIM_LOADED:
            handleSimLoaded(msg.arg1);
            break;
        case EVENT_SIM_ABSENT:
            handleSimAbsent(msg.arg1);
            break;
        case EVENT_SIM_LOCKED:
            handleSimLocked(msg.arg1, (String) msg.obj);
            break;
        case EVENT_SIM_UNKNOWN:
            updateCarrierServices(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_UNKNOWN);
            break;
        case EVENT_SIM_IO_ERROR:
            handleSimError(msg.arg1);
            break;
        case EVENT_SIM_RESTRICTED:
            updateCarrierServices(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_CARD_RESTRICTED);
            break;
        default:
            logd("Unknown msg:" + msg.what);
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_SIM_LOCKED_QUERY_ICCID_DONE:
            {
                AsyncResult ar = (AsyncResult) msg.obj;
                QueryIccIdUserObj uObj = (QueryIccIdUserObj) ar.userObj;
                int slotId = uObj.slotId;
                logd("handleMessage : <EVENT_SIM_LOCKED_QUERY_ICCID_DONE> SIM" + (slotId + 1));
                if (ar.exception == null) {
                    if (ar.result != null) {
                        byte[] data = (byte[]) ar.result;
                        mIccId[slotId] = IccUtils.bchToString(data, 0, data.length);
                    } else {
                        logd("Null ar");
                        mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
                    }
                } else {
                    mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
                    logd("Query IccId fail: " + ar.exception);
                }
                logd("sIccId[" + slotId + "] = " + mIccId[slotId]);
                if (isAllIccIdQueryDone()) {
                    updateSubscriptionInfoByIccId();
                }
                broadcastSimStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED, uObj.reason);
                if (!ICCID_STRING_FOR_NO_SIM.equals(mIccId[slotId])) {
                    updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED);
                }
                break;
            }
        case EVENT_GET_NETWORK_SELECTION_MODE_DONE:
            {
                AsyncResult ar = (AsyncResult) msg.obj;
                Integer slotId = (Integer) ar.userObj;
                if (ar.exception == null && ar.result != null) {
                    int[] modes = (int[]) ar.result;
                    if (modes[0] == 1) {
                        // Manual mode.
                        mPhone[slotId].setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    logd("EVENT_GET_NETWORK_SELECTION_MODE_DONE: error getting network mode.");
                }
                break;
            }
        case EVENT_SIM_LOADED:
            handleSimLoaded(msg.arg1);
            break;
        case EVENT_SIM_ABSENT:
            handleSimAbsent(msg.arg1);
            break;
        case EVENT_SIM_LOCKED:
            handleSimLocked(msg.arg1, (String) msg.obj);
            break;
        case EVENT_SIM_UNKNOWN:
            updateCarrierServices(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_UNKNOWN);
            break;
        case EVENT_SIM_IO_ERROR:
            handleSimError(msg.arg1);
            break;
        case EVENT_SIM_RESTRICTED:
            updateCarrierServices(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_CARD_RESTRICTED);
            break;
        case EVENT_REFRESH_EMBEDDED_SUBSCRIPTIONS:
            if (updateEmbeddedSubscriptions()) {
                SubscriptionController.getInstance().notifySubscriptionInfoChanged();
            }
            if (msg.obj != null) {
                ((Runnable) msg.obj).run();
            }
            break;
        default:
            logd("Unknown msg:" + msg.what);
    }
}
#end_block

#method_before
private void handleSimLoaded(int slotId) {
    logd("handleSimStateLoadedInternal: slotId: " + slotId);
    // The SIM should be loaded at this state, but it is possible in cases such as SIM being
    // removed or a refresh RESET that the IccRecords could be null. The right behavior is to
    // not broadcast the SIM loaded.
    IccRecords records = mPhone[slotId].getIccCard().getIccRecords();
    if (records == null) {
        // Possibly a race condition.
        logd("onRecieve: IccRecords null");
        return;
    }
    if (records.getFullIccId() == null) {
        logd("onRecieve: IccID null");
        return;
    }
    mIccId[slotId] = records.getFullIccId();
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
    }
    int subId = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
    int[] subIds = SubscriptionController.getInstance().getSubId(slotId);
    if (subIds != null) {
        // Why an array?
        subId = subIds[0];
    }
    if (SubscriptionManager.isValidSubscriptionId(subId)) {
        TelephonyManager tm = TelephonyManager.getDefault();
        String operator = tm.getSimOperatorNumericForPhone(slotId);
        if (!TextUtils.isEmpty(operator)) {
            if (subId == SubscriptionController.getInstance().getDefaultSubId()) {
                MccTable.updateMccMncConfiguration(mContext, operator, false);
            }
            SubscriptionController.getInstance().setMccMnc(operator, subId);
        } else {
            logd("EVENT_RECORDS_LOADED Operator name is null");
        }
        String msisdn = tm.getLine1Number(subId);
        ContentResolver contentResolver = mContext.getContentResolver();
        if (msisdn != null) {
            ContentValues number = new ContentValues(1);
            number.put(SubscriptionManager.NUMBER, msisdn);
            contentResolver.update(SubscriptionManager.CONTENT_URI, number, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subId), null);
        }
        SubscriptionInfo subInfo = mSubscriptionManager.getActiveSubscriptionInfo(subId);
        String nameToSet;
        String simCarrierName = tm.getSimOperatorName(subId);
        ContentValues name = new ContentValues(1);
        if (subInfo != null && subInfo.getNameSource() != SubscriptionManager.NAME_SOURCE_USER_INPUT) {
            if (!TextUtils.isEmpty(simCarrierName)) {
                nameToSet = simCarrierName;
            } else {
                nameToSet = "CARD " + Integer.toString(slotId + 1);
            }
            name.put(SubscriptionManager.DISPLAY_NAME, nameToSet);
            logd("sim name = " + nameToSet);
            contentResolver.update(SubscriptionManager.CONTENT_URI, name, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subId), null);
        }
        /* Update preferred network type and network selection mode on SIM change.
             * Storing last subId in SharedPreference for now to detect SIM change. */
        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
        int storedSubId = sp.getInt(CURR_SUBID + slotId, -1);
        if (storedSubId != subId) {
            int networkType = RILConstants.PREFERRED_NETWORK_MODE;
            // Set the modem network mode
            mPhone[slotId].setPreferredNetworkType(networkType, null);
            Settings.Global.putInt(mPhone[slotId].getContext().getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE + subId, networkType);
            // Only support automatic selection mode on SIM change.
            mPhone[slotId].getNetworkSelectionMode(obtainMessage(EVENT_GET_NETWORK_SELECTION_MODE_DONE, new Integer(slotId)));
            // Update stored subId
            SharedPreferences.Editor editor = sp.edit();
            editor.putInt(CURR_SUBID + slotId, subId);
            editor.apply();
        }
    } else {
        logd("Invalid subId, could not update ContentResolver");
    }
    // Update set of enabled carrier apps now that the privilege rules may have changed.
    CarrierAppUtils.disableCarrierAppsUntilPrivileged(mContext.getOpPackageName(), mPackageManager, TelephonyManager.getDefault(), mContext.getContentResolver(), mCurrentlyActiveUserId);
    broadcastSimStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_LOADED, null);
    updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_LOADED);
}
#method_after
private void handleSimLoaded(int slotId) {
    logd("handleSimLoaded: slotId: " + slotId);
    // The SIM should be loaded at this state, but it is possible in cases such as SIM being
    // removed or a refresh RESET that the IccRecords could be null. The right behavior is to
    // not broadcast the SIM loaded.
    int loadedSlotId = slotId;
    IccRecords records = mPhone[slotId].getIccCard().getIccRecords();
    if (records == null) {
        // Possibly a race condition.
        logd("handleSimLoaded: IccRecords null");
        return;
    }
    if (records.getFullIccId() == null) {
        logd("onRecieve: IccID null");
        return;
    }
    mIccId[slotId] = records.getFullIccId();
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
        int[] subIds = mSubscriptionManager.getActiveSubscriptionIdList();
        for (int subId : subIds) {
            TelephonyManager tm = TelephonyManager.getDefault();
            String operator = tm.getSimOperatorNumeric(subId);
            slotId = SubscriptionController.getInstance().getPhoneId(subId);
            if (!TextUtils.isEmpty(operator)) {
                if (subId == SubscriptionController.getInstance().getDefaultSubId()) {
                    MccTable.updateMccMncConfiguration(mContext, operator, false);
                }
                SubscriptionController.getInstance().setMccMnc(operator, subId);
            } else {
                logd("EVENT_RECORDS_LOADED Operator name is null");
            }
            String msisdn = tm.getLine1Number(subId);
            ContentResolver contentResolver = mContext.getContentResolver();
            if (msisdn != null) {
                ContentValues number = new ContentValues(1);
                number.put(SubscriptionManager.NUMBER, msisdn);
                contentResolver.update(SubscriptionManager.CONTENT_URI, number, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subId), null);
            }
            SubscriptionInfo subInfo = mSubscriptionManager.getActiveSubscriptionInfo(subId);
            String nameToSet;
            String simCarrierName = tm.getSimOperatorName(subId);
            ContentValues name = new ContentValues(1);
            if (subInfo != null && subInfo.getNameSource() != SubscriptionManager.NAME_SOURCE_USER_INPUT) {
                if (!TextUtils.isEmpty(simCarrierName)) {
                    nameToSet = simCarrierName;
                } else {
                    nameToSet = "CARD " + Integer.toString(slotId + 1);
                }
                name.put(SubscriptionManager.DISPLAY_NAME, nameToSet);
                logd("sim name = " + nameToSet);
                contentResolver.update(SubscriptionManager.CONTENT_URI, name, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subId), null);
            }
            /* Update preferred network type and network selection mode on SIM change.
                 * Storing last subId in SharedPreference for now to detect SIM change. */
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
            int storedSubId = sp.getInt(CURR_SUBID + slotId, -1);
            if (storedSubId != subId) {
                int networkType = RILConstants.PREFERRED_NETWORK_MODE;
                // Set the modem network mode
                mPhone[slotId].setPreferredNetworkType(networkType, null);
                Settings.Global.putInt(mPhone[slotId].getContext().getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE + subId, networkType);
                // Only support automatic selection mode on SIM change.
                mPhone[slotId].getNetworkSelectionMode(obtainMessage(EVENT_GET_NETWORK_SELECTION_MODE_DONE, new Integer(slotId)));
                // Update stored subId
                SharedPreferences.Editor editor = sp.edit();
                editor.putInt(CURR_SUBID + slotId, subId);
                editor.apply();
            }
        }
    }
    // Update set of enabled carrier apps now that the privilege rules may have changed.
    CarrierAppUtils.disableCarrierAppsUntilPrivileged(mContext.getOpPackageName(), mPackageManager, TelephonyManager.getDefault(), mContext.getContentResolver(), mCurrentlyActiveUserId);
    broadcastSimStateChanged(loadedSlotId, IccCardConstants.INTENT_VALUE_ICC_LOADED, null);
    updateCarrierServices(loadedSlotId, IccCardConstants.INTENT_VALUE_ICC_LOADED);
}
#end_block

#method_before
synchronized private void updateSubscriptionInfoByIccId() {
    logd("updateSubscriptionInfoByIccId:+ Start");
    mSubscriptionManager.clearSubscriptionInfo();
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        mInsertSimState[i] = SIM_NOT_CHANGE;
    }
    int insertedSimCount = PROJECT_SIM_NUM;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (ICCID_STRING_FOR_NO_SIM.equals(mIccId[i])) {
            insertedSimCount--;
            mInsertSimState[i] = SIM_NOT_INSERT;
        }
    }
    logd("insertedSimCount = " + insertedSimCount);
    int index = 0;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (mInsertSimState[i] == SIM_NOT_INSERT) {
            continue;
        }
        index = 2;
        for (int j = i + 1; j < PROJECT_SIM_NUM; j++) {
            if (mInsertSimState[j] == SIM_NOT_CHANGE && mIccId[i].equals(mIccId[j])) {
                mInsertSimState[i] = 1;
                mInsertSimState[j] = index;
                index++;
            }
        }
    }
    ContentResolver contentResolver = mContext.getContentResolver();
    String[] oldIccId = new String[PROJECT_SIM_NUM];
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        oldIccId[i] = null;
        List<SubscriptionInfo> oldSubInfo = SubscriptionController.getInstance().getSubInfoUsingSlotIndexWithCheck(i, false, mContext.getOpPackageName());
        if (oldSubInfo != null && oldSubInfo.size() > 0) {
            oldIccId[i] = oldSubInfo.get(0).getIccId();
            logd("updateSubscriptionInfoByIccId: oldSubId = " + oldSubInfo.get(0).getSubscriptionId());
            if (mInsertSimState[i] == SIM_NOT_CHANGE && !mIccId[i].equals(oldIccId[i])) {
                mInsertSimState[i] = SIM_CHANGED;
            }
            if (mInsertSimState[i] != SIM_NOT_CHANGE) {
                ContentValues value = new ContentValues(1);
                value.put(SubscriptionManager.SIM_SLOT_INDEX, SubscriptionManager.INVALID_SIM_SLOT_INDEX);
                contentResolver.update(SubscriptionManager.CONTENT_URI, value, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Integer.toString(oldSubInfo.get(0).getSubscriptionId()), null);
            }
        } else {
            if (mInsertSimState[i] == SIM_NOT_CHANGE) {
                // no SIM inserted last time, but there is one SIM inserted now
                mInsertSimState[i] = SIM_CHANGED;
            }
            oldIccId[i] = ICCID_STRING_FOR_NO_SIM;
            logd("updateSubscriptionInfoByIccId: No SIM in slot " + i + " last time");
        }
    }
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        logd("updateSubscriptionInfoByIccId: oldIccId[" + i + "] = " + oldIccId[i] + ", sIccId[" + i + "] = " + mIccId[i]);
    }
    // check if the inserted SIM is new SIM
    int nNewCardCount = 0;
    int nNewSimStatus = 0;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (mInsertSimState[i] == SIM_NOT_INSERT) {
            logd("updateSubscriptionInfoByIccId: No SIM inserted in slot " + i + " this time");
        } else {
            if (mInsertSimState[i] > 0) {
                // some special SIMs may have the same IccIds, add suffix to distinguish them
                // FIXME: addSubInfoRecord can return an error.
                mSubscriptionManager.addSubscriptionInfoRecord(mIccId[i] + Integer.toString(mInsertSimState[i]), i);
                logd("SUB" + (i + 1) + " has invalid IccId");
            } else /*if (sInsertSimState[i] != SIM_NOT_INSERT)*/
            {
                mSubscriptionManager.addSubscriptionInfoRecord(mIccId[i], i);
            }
            if (isNewSim(mIccId[i], oldIccId)) {
                nNewCardCount++;
                switch(i) {
                    case PhoneConstants.SUB1:
                        nNewSimStatus |= STATUS_SIM1_INSERTED;
                        break;
                    case PhoneConstants.SUB2:
                        nNewSimStatus |= STATUS_SIM2_INSERTED;
                        break;
                    case PhoneConstants.SUB3:
                        nNewSimStatus |= STATUS_SIM3_INSERTED;
                        break;
                }
                mInsertSimState[i] = SIM_NEW;
            }
        }
    }
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (mInsertSimState[i] == SIM_CHANGED) {
            mInsertSimState[i] = SIM_REPOSITION;
        }
        logd("updateSubscriptionInfoByIccId: sInsertSimState[" + i + "] = " + mInsertSimState[i]);
    }
    List<SubscriptionInfo> subInfos = mSubscriptionManager.getActiveSubscriptionInfoList();
    int nSubCount = (subInfos == null) ? 0 : subInfos.size();
    logd("updateSubscriptionInfoByIccId: nSubCount = " + nSubCount);
    for (int i = 0; i < nSubCount; i++) {
        SubscriptionInfo temp = subInfos.get(i);
        String msisdn = TelephonyManager.getDefault().getLine1Number(temp.getSubscriptionId());
        if (msisdn != null) {
            ContentValues value = new ContentValues(1);
            value.put(SubscriptionManager.NUMBER, msisdn);
            contentResolver.update(SubscriptionManager.CONTENT_URI, value, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Integer.toString(temp.getSubscriptionId()), null);
        }
    }
    // Ensure the modems are mapped correctly
    mSubscriptionManager.setDefaultDataSubId(mSubscriptionManager.getDefaultDataSubscriptionId());
    SubscriptionController.getInstance().notifySubscriptionInfoChanged();
    logd("updateSubscriptionInfoByIccId:- SsubscriptionInfo update complete");
}
#method_after
synchronized private void updateSubscriptionInfoByIccId() {
    logd("updateSubscriptionInfoByIccId:+ Start");
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        mInsertSimState[i] = SIM_NOT_CHANGE;
    }
    int insertedSimCount = PROJECT_SIM_NUM;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (ICCID_STRING_FOR_NO_SIM.equals(mIccId[i])) {
            insertedSimCount--;
            mInsertSimState[i] = SIM_NOT_INSERT;
        }
    }
    logd("insertedSimCount = " + insertedSimCount);
    // rebuilding the map.
    if (SubscriptionController.getInstance().getActiveSubIdList().length > insertedSimCount) {
        SubscriptionController.getInstance().clearSubInfo();
    }
    int index = 0;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (mInsertSimState[i] == SIM_NOT_INSERT) {
            continue;
        }
        index = 2;
        for (int j = i + 1; j < PROJECT_SIM_NUM; j++) {
            if (mInsertSimState[j] == SIM_NOT_CHANGE && mIccId[i].equals(mIccId[j])) {
                mInsertSimState[i] = 1;
                mInsertSimState[j] = index;
                index++;
            }
        }
    }
    ContentResolver contentResolver = mContext.getContentResolver();
    String[] oldIccId = new String[PROJECT_SIM_NUM];
    String[] decIccId = new String[PROJECT_SIM_NUM];
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        oldIccId[i] = null;
        List<SubscriptionInfo> oldSubInfo = SubscriptionController.getInstance().getSubInfoUsingSlotIndexWithCheck(i, false, mContext.getOpPackageName());
        decIccId[i] = IccUtils.getDecimalSubstring(mIccId[i]);
        if (oldSubInfo != null && oldSubInfo.size() > 0) {
            oldIccId[i] = oldSubInfo.get(0).getIccId();
            logd("updateSubscriptionInfoByIccId: oldSubId = " + oldSubInfo.get(0).getSubscriptionId());
            if (mInsertSimState[i] == SIM_NOT_CHANGE && !(mIccId[i].equals(oldIccId[i]) || (decIccId[i] != null && decIccId[i].equals(oldIccId[i])))) {
                mInsertSimState[i] = SIM_CHANGED;
            }
            if (mInsertSimState[i] != SIM_NOT_CHANGE) {
                ContentValues value = new ContentValues(1);
                value.put(SubscriptionManager.SIM_SLOT_INDEX, SubscriptionManager.INVALID_SIM_SLOT_INDEX);
                contentResolver.update(SubscriptionManager.CONTENT_URI, value, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Integer.toString(oldSubInfo.get(0).getSubscriptionId()), null);
            }
        } else {
            if (mInsertSimState[i] == SIM_NOT_CHANGE) {
                // no SIM inserted last time, but there is one SIM inserted now
                mInsertSimState[i] = SIM_CHANGED;
            }
            oldIccId[i] = ICCID_STRING_FOR_NO_SIM;
            logd("updateSubscriptionInfoByIccId: No SIM in slot " + i + " last time");
        }
    }
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        logd("updateSubscriptionInfoByIccId: oldIccId[" + i + "] = " + oldIccId[i] + ", sIccId[" + i + "] = " + mIccId[i]);
    }
    // check if the inserted SIM is new SIM
    int nNewCardCount = 0;
    int nNewSimStatus = 0;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (mInsertSimState[i] == SIM_NOT_INSERT) {
            logd("updateSubscriptionInfoByIccId: No SIM inserted in slot " + i + " this time");
        } else {
            if (mInsertSimState[i] > 0) {
                // some special SIMs may have the same IccIds, add suffix to distinguish them
                // FIXME: addSubInfoRecord can return an error.
                mSubscriptionManager.addSubscriptionInfoRecord(mIccId[i] + Integer.toString(mInsertSimState[i]), i);
                logd("SUB" + (i + 1) + " has invalid IccId");
            } else /*if (sInsertSimState[i] != SIM_NOT_INSERT)*/
            {
                mSubscriptionManager.addSubscriptionInfoRecord(mIccId[i], i);
            }
            if (isNewSim(mIccId[i], decIccId[i], oldIccId)) {
                nNewCardCount++;
                switch(i) {
                    case PhoneConstants.SUB1:
                        nNewSimStatus |= STATUS_SIM1_INSERTED;
                        break;
                    case PhoneConstants.SUB2:
                        nNewSimStatus |= STATUS_SIM2_INSERTED;
                        break;
                    case PhoneConstants.SUB3:
                        nNewSimStatus |= STATUS_SIM3_INSERTED;
                        break;
                }
                mInsertSimState[i] = SIM_NEW;
            }
        }
    }
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (mInsertSimState[i] == SIM_CHANGED) {
            mInsertSimState[i] = SIM_REPOSITION;
        }
        logd("updateSubscriptionInfoByIccId: sInsertSimState[" + i + "] = " + mInsertSimState[i]);
    }
    List<SubscriptionInfo> subInfos = mSubscriptionManager.getActiveSubscriptionInfoList();
    int nSubCount = (subInfos == null) ? 0 : subInfos.size();
    logd("updateSubscriptionInfoByIccId: nSubCount = " + nSubCount);
    for (int i = 0; i < nSubCount; i++) {
        SubscriptionInfo temp = subInfos.get(i);
        String msisdn = TelephonyManager.getDefault().getLine1Number(temp.getSubscriptionId());
        if (msisdn != null) {
            ContentValues value = new ContentValues(1);
            value.put(SubscriptionManager.NUMBER, msisdn);
            contentResolver.update(SubscriptionManager.CONTENT_URI, value, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Integer.toString(temp.getSubscriptionId()), null);
        }
    }
    // Ensure the modems are mapped correctly
    mSubscriptionManager.setDefaultDataSubId(mSubscriptionManager.getDefaultDataSubscriptionId());
    // No need to check return value here as we notify for the above changes anyway.
    updateEmbeddedSubscriptions();
    SubscriptionController.getInstance().notifySubscriptionInfoChanged();
    logd("updateSubscriptionInfoByIccId:- SubscriptionInfo update complete");
}
#end_block

#method_before
private boolean isNewSim(String iccId, String[] oldIccId) {
    boolean newSim = true;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (iccId.equals(oldIccId[i])) {
            newSim = false;
            break;
        }
    }
    logd("newSim = " + newSim);
    return newSim;
}
#method_after
private boolean isNewSim(String iccId, String decIccId, String[] oldIccId) {
    boolean newSim = true;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (iccId.equals(oldIccId[i])) {
            newSim = false;
            break;
        } else if (decIccId != null && decIccId.equals(oldIccId[i])) {
            newSim = false;
            break;
        }
    }
    logd("newSim = " + newSim);
    return newSim;
}
#end_block

#method_before
private void broadcastSimStateChanged(int slotId, String state, String reason) {
    Intent i = new Intent(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
    // TODO - we'd like this intent to have a single snapshot of all sim state,
    // but until then this should not use REPLACE_PENDING or we may lose
    // information
    // i.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING
    // | Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    i.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    i.putExtra(PhoneConstants.PHONE_NAME_KEY, "Phone");
    i.putExtra(IccCardConstants.INTENT_KEY_ICC_STATE, state);
    i.putExtra(IccCardConstants.INTENT_KEY_LOCKED_REASON, reason);
    SubscriptionManager.putPhoneIdAndSubIdExtra(i, slotId);
    logd("Broadcasting intent ACTION_SIM_STATE_CHANGED " + state + " reason " + reason + " for mCardIndex: " + slotId);
    ActivityManagerNative.broadcastStickyIntent(i, READ_PHONE_STATE, UserHandle.USER_ALL);
    rebroadcastIntentsOnUnlock.put(slotId, i);
}
#method_after
private void broadcastSimStateChanged(int slotId, String state, String reason) {
    Intent i = new Intent(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
    // TODO - we'd like this intent to have a single snapshot of all sim state,
    // but until then this should not use REPLACE_PENDING or we may lose
    // information
    // i.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING
    // | Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    i.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    i.putExtra(PhoneConstants.PHONE_NAME_KEY, "Phone");
    i.putExtra(IccCardConstants.INTENT_KEY_ICC_STATE, state);
    i.putExtra(IccCardConstants.INTENT_KEY_LOCKED_REASON, reason);
    SubscriptionManager.putPhoneIdAndSubIdExtra(i, slotId);
    logd("Broadcasting intent ACTION_SIM_STATE_CHANGED " + state + " reason " + reason + " for mCardIndex: " + slotId);
    IntentBroadcaster.getInstance().broadcastStickyIntent(i, slotId);
}
#end_block

#method_before
private OutputApkSigningBlockRequestImpl outputZipSectionsInternal(DataSource zipEntries, DataSource zipCentralDirectory, DataSource zipEocd, boolean apkSigningBlockPaddingSupported) throws IOException, InvalidKeyException, SignatureException, NoSuchAlgorithmException {
    checkNotClosed();
    checkV1SigningDoneIfEnabled();
    if (!mV2SigningEnabled) {
        return null;
    }
    invalidateV2Signature();
    List<V2SchemeSigner.SignerConfig> v2SignerConfigs = createV2SignerConfigs(apkSigningBlockPaddingSupported);
    Pair<byte[], Integer> result = V2SchemeSigner.generateApkSigningBlock(zipEntries, zipCentralDirectory, zipEocd, v2SignerConfigs, apkSigningBlockPaddingSupported);
    byte[] apkSigningBlock = result.getFirst();
    int padSizeBeforeApkSigningBlock = result.getSecond();
    mAddV2SignatureRequest = new OutputApkSigningBlockRequestImpl(apkSigningBlock, padSizeBeforeApkSigningBlock);
    return mAddV2SignatureRequest;
}
#method_after
private OutputApkSigningBlockRequestImpl outputZipSectionsInternal(DataSource zipEntries, DataSource zipCentralDirectory, DataSource zipEocd, boolean apkSigningBlockPaddingSupported) throws IOException, InvalidKeyException, SignatureException, NoSuchAlgorithmException {
    checkNotClosed();
    checkV1SigningDoneIfEnabled();
    if (!mV2SigningEnabled) {
        return null;
    }
    invalidateV2Signature();
    List<V2SchemeSigner.SignerConfig> v2SignerConfigs = getV2SignerConfigs();
    Pair<byte[], Integer> result = V2SchemeSigner.generateApkSigningBlock(zipEntries, zipCentralDirectory, zipEocd, v2SignerConfigs, apkSigningBlockPaddingSupported);
    byte[] apkSigningBlock = result.getFirst();
    int padSizeBeforeApkSigningBlock = result.getSecond();
    mAddV2SignatureRequest = new OutputApkSigningBlockRequestImpl(apkSigningBlock, padSizeBeforeApkSigningBlock);
    return mAddV2SignatureRequest;
}
#end_block

#method_before
public DefaultApkSignerEngine build() throws InvalidKeyException {
    return new DefaultApkSignerEngine(mSignerConfigs, mMinSdkVersion, mV1SigningEnabled, mV2SigningEnabled, mOtherSignersSignaturesPreserved, mCreatedBy);
}
#method_after
public SignerConfig build() {
    return new SignerConfig(mName, mPrivateKey, mCertificates);
}
#end_block

#method_before
private boolean isUseOnlyRsrpForLteLevel() {
    CarrierConfigManager configManager = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    PersistableBundle config = null;
    if (configManager != null) {
        // If an invalid subId is used, this bundle will contain default values.
        config = configManager.getConfigForSubId(mPhone.getSubId());
    }
    if (config != null) {
        return config.getBoolean(CarrierConfigManager.KEY_USE_ONLY_RSRP_FOR_LTE_SIGNAL_BAR_BOOL);
    } else {
        // Return static default defined in CarrierConfigManager.
        return CarrierConfigManager.getDefaultConfig().getBoolean(CarrierConfigManager.KEY_USE_ONLY_RSRP_FOR_LTE_SIGNAL_BAR_BOOL);
    }
}
#method_after
private boolean isUseOnlyRsrpForLteLevel() {
    CarrierConfigManager configManager = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager != null) {
        // If an invalid subId is used, this bundle will contain default values.
        PersistableBundle config = configManager.getConfigForSubId(mPhone.getSubId());
        if (config != null) {
            return config.getBoolean(CarrierConfigManager.KEY_USE_ONLY_RSRP_FOR_LTE_SIGNAL_BAR_BOOL);
        }
    }
    // Return static default defined in CarrierConfigManager.
    return CarrierConfigManager.getDefaultConfig().getBoolean(CarrierConfigManager.KEY_USE_ONLY_RSRP_FOR_LTE_SIGNAL_BAR_BOOL);
}
#end_block

#method_before
public int getLteLevel() {
    /*
         * TS 36.214 Physical Layer Section 5.1.3 TS 36.331 RRC RSSI = received
         * signal + noise RSRP = reference signal dBm RSRQ = quality of signal
         * dB= Number of Resource blocksxRSRP/RSSI SNR = gain=signal/noise ratio
         * = -10log P1/P2 dB
         */
    int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN, rsrpIconLevel = -1, snrIconLevel = -1;
    int[] threshRsrp = Resources.getSystem().getIntArray(com.android.internal.R.array.config_lteDbmThresholds);
    if (threshRsrp.length != 6) {
        Log.wtf(LOG_TAG, "getLteLevel - config_lteDbmThresholds has invalid num of elements." + " Cannot evaluate RSRP signal.");
    } else {
        if (mLteRsrp > threshRsrp[5]) {
            rsrpIconLevel = -1;
        } else if (mLteRsrp >= (threshRsrp[4] - mLteRsrpBoost)) {
            rsrpIconLevel = SIGNAL_STRENGTH_GREAT;
        } else if (mLteRsrp >= (threshRsrp[3] - mLteRsrpBoost)) {
            rsrpIconLevel = SIGNAL_STRENGTH_GOOD;
        } else if (mLteRsrp >= (threshRsrp[2] - mLteRsrpBoost)) {
            rsrpIconLevel = SIGNAL_STRENGTH_MODERATE;
        } else if (mLteRsrp >= (threshRsrp[1] - mLteRsrpBoost)) {
            rsrpIconLevel = SIGNAL_STRENGTH_POOR;
        } else if (mLteRsrp >= threshRsrp[0]) {
            rsrpIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
        }
    }
    if (isUseOnlyRsrpForLteLevel()) {
        log("getLTELevel - rsrp = " + rsrpIconLevel);
        if (rsrpIconLevel != -1) {
            return rsrpIconLevel;
        }
    }
    /*
         * Values are -200 dB to +300 (SNR*10dB) RS_SNR >= 13.0 dB =>4 bars 4.5
         * dB <= RS_SNR < 13.0 dB => 3 bars 1.0 dB <= RS_SNR < 4.5 dB => 2 bars
         * -3.0 dB <= RS_SNR < 1.0 dB 1 bar RS_SNR < -3.0 dB/No Service Antenna
         * Icon Only
         */
    if (mLteRssnr > 300)
        snrIconLevel = -1;
    else if (mLteRssnr >= 130)
        snrIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRssnr >= 45)
        snrIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRssnr >= 10)
        snrIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRssnr >= -30)
        snrIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRssnr >= -200)
        snrIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (DBG)
        log("getLTELevel - rsrp:" + mLteRsrp + " snr:" + mLteRssnr + " rsrpIconLevel:" + rsrpIconLevel + " snrIconLevel:" + snrIconLevel + " lteRsrpBoost:" + mLteRsrpBoost);
    /* Choose a measurement type to use for notification */
    if (snrIconLevel != -1 && rsrpIconLevel != -1) {
        /*
             * The number of bars displayed shall be the smaller of the bars
             * associated with LTE RSRP and the bars associated with the LTE
             * RS_SNR
             */
        return (rsrpIconLevel < snrIconLevel ? rsrpIconLevel : snrIconLevel);
    }
    if (snrIconLevel != -1)
        return snrIconLevel;
    if (rsrpIconLevel != -1)
        return rsrpIconLevel;
    /* Valid values are (0-63, 99) as defined in TS 36.331 */
    if (mLteSignalStrength > 63)
        rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (mLteSignalStrength >= 12)
        rssiIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteSignalStrength >= 8)
        rssiIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteSignalStrength >= 5)
        rssiIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteSignalStrength >= 0)
        rssiIconLevel = SIGNAL_STRENGTH_POOR;
    if (DBG)
        log("getLTELevel - rssi:" + mLteSignalStrength + " rssiIconLevel:" + rssiIconLevel);
    return rssiIconLevel;
}
#method_after
public int getLteLevel() {
    /*
         * TS 36.214 Physical Layer Section 5.1.3 TS 36.331 RRC RSSI = received
         * signal + noise RSRP = reference signal dBm RSRQ = quality of signal
         * dB= Number of Resource blocksxRSRP/RSSI SNR = gain=signal/noise ratio
         * = -10log P1/P2 dB
         */
    int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN, rsrpIconLevel = -1, snrIconLevel = -1;
    int[] threshRsrp = Resources.getSystem().getIntArray(com.android.internal.R.array.config_lteDbmThresholds);
    if (threshRsrp.length != 6) {
        Log.wtf(LOG_TAG, "getLteLevel - config_lteDbmThresholds has invalid num of elements." + " Cannot evaluate RSRP signal.");
    } else {
        if (mLteRsrp > threshRsrp[5]) {
            rsrpIconLevel = -1;
        } else if (mLteRsrp >= (threshRsrp[4] - mLteRsrpBoost)) {
            rsrpIconLevel = SIGNAL_STRENGTH_GREAT;
        } else if (mLteRsrp >= (threshRsrp[3] - mLteRsrpBoost)) {
            rsrpIconLevel = SIGNAL_STRENGTH_GOOD;
        } else if (mLteRsrp >= (threshRsrp[2] - mLteRsrpBoost)) {
            rsrpIconLevel = SIGNAL_STRENGTH_MODERATE;
        } else if (mLteRsrp >= (threshRsrp[1] - mLteRsrpBoost)) {
            rsrpIconLevel = SIGNAL_STRENGTH_POOR;
        } else if (mLteRsrp >= threshRsrp[0]) {
            rsrpIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
        }
    }
    if (useOnlyRsrpForLteLevel()) {
        log("getLTELevel - rsrp = " + rsrpIconLevel);
        if (rsrpIconLevel != -1) {
            return rsrpIconLevel;
        }
    }
    /*
         * Values are -200 dB to +300 (SNR*10dB) RS_SNR >= 13.0 dB =>4 bars 4.5
         * dB <= RS_SNR < 13.0 dB => 3 bars 1.0 dB <= RS_SNR < 4.5 dB => 2 bars
         * -3.0 dB <= RS_SNR < 1.0 dB 1 bar RS_SNR < -3.0 dB/No Service Antenna
         * Icon Only
         */
    if (mLteRssnr > 300)
        snrIconLevel = -1;
    else if (mLteRssnr >= 130)
        snrIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRssnr >= 45)
        snrIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRssnr >= 10)
        snrIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRssnr >= -30)
        snrIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRssnr >= -200)
        snrIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (DBG)
        log("getLTELevel - rsrp:" + mLteRsrp + " snr:" + mLteRssnr + " rsrpIconLevel:" + rsrpIconLevel + " snrIconLevel:" + snrIconLevel + " lteRsrpBoost:" + mLteRsrpBoost);
    /* Choose a measurement type to use for notification */
    if (snrIconLevel != -1 && rsrpIconLevel != -1) {
        /*
             * The number of bars displayed shall be the smaller of the bars
             * associated with LTE RSRP and the bars associated with the LTE
             * RS_SNR
             */
        return (rsrpIconLevel < snrIconLevel ? rsrpIconLevel : snrIconLevel);
    }
    if (snrIconLevel != -1)
        return snrIconLevel;
    if (rsrpIconLevel != -1)
        return rsrpIconLevel;
    /* Valid values are (0-63, 99) as defined in TS 36.331 */
    if (mLteSignalStrength > 63)
        rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (mLteSignalStrength >= 12)
        rssiIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteSignalStrength >= 8)
        rssiIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteSignalStrength >= 5)
        rssiIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteSignalStrength >= 0)
        rssiIconLevel = SIGNAL_STRENGTH_POOR;
    if (DBG)
        log("getLTELevel - rssi:" + mLteSignalStrength + " rssiIconLevel:" + rssiIconLevel);
    return rssiIconLevel;
}
#end_block

#method_before
@Override
public String toString() {
    return ("SignalStrength:" + " " + mGsmSignalStrength + " " + mGsmBitErrorRate + " " + mCdmaDbm + " " + mCdmaEcio + " " + mEvdoDbm + " " + mEvdoEcio + " " + mEvdoSnr + " " + mLteSignalStrength + " " + mLteRsrp + " " + mLteRsrq + " " + mLteRssnr + " " + mLteCqi + " " + mLteRsrpBoost + " " + mTdScdmaRscp + " " + (isGsm ? "gsm|lte" : "cdma") + " " + (mUseOnlyRsrpForLteLevel ? "lte_level_base_on_rsrp" : "lte_level_not_base_on_rsrp"));
}
#method_after
@Override
public String toString() {
    return ("SignalStrength:" + " " + mGsmSignalStrength + " " + mGsmBitErrorRate + " " + mCdmaDbm + " " + mCdmaEcio + " " + mEvdoDbm + " " + mEvdoEcio + " " + mEvdoSnr + " " + mLteSignalStrength + " " + mLteRsrp + " " + mLteRsrq + " " + mLteRssnr + " " + mLteCqi + " " + mLteRsrpBoost + " " + mTdScdmaRscp + " " + (isGsm ? "gsm|lte" : "cdma") + " " + (mUseOnlyRsrpForLteLevel ? "use_only_rsrp_for_lte_level" : "use_rsrp_and_rssnr_for_lte_level"));
}
#end_block

#method_before
@Override
public void onCreate(Bundle icicle) {
    LogHelper.d(TAG, "onCreate()");
    super.onCreate(icicle);
    setVolumeControlStream(AudioManager.STREAM_MUSIC);
    requestWindowFeature(Window.FEATURE_NO_TITLE);
    setContentView(R.layout.audio_player);
    mCurrentTime = (TextView) findViewById(R.id.currenttime);
    mTotalTime = (TextView) findViewById(R.id.totaltime);
    mProgress = (ProgressBar) findViewById(android.R.id.progress);
    mAlbumArt = (ImageView) findViewById(R.id.album);
    mArtistName = (TextView) findViewById(R.id.artistname);
    mAlbumName = (TextView) findViewById(R.id.albumname);
    mTrackName = (TextView) findViewById(R.id.trackname);
    Bitmap b = BitmapFactory.decodeResource(getResources(), R.drawable.albumart_mp_unknown);
    mDefaultAlbumArt = new BitmapDrawable(getResources(), b);
    // no filter or dither, it's a lot faster and we can't tell the difference
    mDefaultAlbumArt.setFilterBitmap(false);
    mDefaultAlbumArt.setDither(false);
    /* Set metadata listeners */
    View v = (View) mArtistName.getParent();
    v.setOnTouchListener(this);
    v.setOnLongClickListener(this);
    v = (View) mAlbumName.getParent();
    v.setOnTouchListener(this);
    v.setOnLongClickListener(this);
    v = (View) mTrackName.getParent();
    v.setOnTouchListener(this);
    v.setOnLongClickListener(this);
    /* Set button listeners */
    mPrevButton = (RepeatingImageButton) findViewById(R.id.prev);
    mPrevButton.setOnClickListener(new View.OnClickListener() {

        public void onClick(View v) {
            if (getMediaController() == null)
                return;
            if (getMediaController().getPlaybackState().getPosition() < 2000) {
                getMediaController().getTransportControls().skipToPrevious();
            } else {
                getMediaController().getTransportControls().seekTo(0);
                getMediaController().getTransportControls().play();
            }
        }
    });
    mPrevButton.setRepeatListener(new RepeatingImageButton.RepeatListener() {

        public void onRepeat(View v, long howlong, int repcnt) {
            scanBackward(repcnt, howlong);
        }
    }, 260);
    mPlayPauseButton = (ImageButton) findViewById(R.id.pause);
    mPlayPauseButton.requestFocus();
    mPlayPauseButton.setOnClickListener(new View.OnClickListener() {

        public void onClick(View v) {
            if (getMediaController() != null) {
                if (getMediaController().getPlaybackState().getState() != PlaybackState.STATE_PLAYING) {
                    getMediaController().getTransportControls().play();
                } else {
                    getMediaController().getTransportControls().pause();
                }
            }
        }
    });
    mNextButton = (RepeatingImageButton) findViewById(R.id.next);
    mNextButton.setOnClickListener(new View.OnClickListener() {

        public void onClick(View v) {
            if (getMediaController() == null)
                return;
            getMediaController().getTransportControls().skipToNext();
        }
    });
    mNextButton.setRepeatListener(new RepeatingImageButton.RepeatListener() {

        public void onRepeat(View v, long howlong, int repcnt) {
            scanForward(repcnt, howlong);
        }
    }, 260);
    mQueueButton = (ImageButton) findViewById(R.id.curplaylist);
    mQueueButton.setOnClickListener(new View.OnClickListener() {

        public void onClick(View v) {
            LogHelper.d(TAG, "mQueueButton onClick");
            MediaBrowser.MediaItem parentItem = new MediaBrowser.MediaItem(new MediaDescription.Builder().setMediaId(MediaIDHelper.createBrowseCategoryMediaID(MediaIDHelper.MEDIA_ID_MUSICS_BY_PLAYLIST, MediaIDHelper.MEDIA_ID_NOW_PLAYING)).setTitle("Now Playing").build(), MediaBrowser.MediaItem.FLAG_BROWSABLE);
            Intent intent = new Intent(Intent.ACTION_PICK).setDataAndType(Uri.EMPTY, "vnd.android.cursor.dir/track").putExtra(MusicUtils.TAG_WITH_TABS, false).putExtra(MusicUtils.TAG_PARENT_ITEM, parentItem);
            startActivity(intent);
        }
    });
    mShuffleButton = ((ImageButton) findViewById(R.id.shuffle));
    mShuffleButton.setOnClickListener(new View.OnClickListener() {

        public void onClick(View v) {
            toggleShuffle();
        }
    });
    mRepeatButton = ((ImageButton) findViewById(R.id.repeat));
    mRepeatButton.setOnClickListener(new View.OnClickListener() {

        public void onClick(View v) {
            LogHelper.d(TAG, "Repeat button clicked");
            if (getMediaController() == null)
                return;
            Bundle extras = getMediaController().getExtras();
            if (extras == null)
                return;
            MediaPlaybackService.RepeatMode repeatMode = MediaPlaybackService.RepeatMode.values()[extras.getInt(MediaPlaybackService.REPEAT_MODE)];
            MediaPlaybackService.RepeatMode nextRepeatMode;
            switch(repeatMode) {
                case REPEAT_NONE:
                    nextRepeatMode = MediaPlaybackService.RepeatMode.REPEAT_ALL;
                    showToast(R.string.repeat_all_notif);
                    break;
                case REPEAT_ALL:
                    nextRepeatMode = MediaPlaybackService.RepeatMode.REPEAT_CURRENT;
                    showToast(R.string.repeat_current_notif);
                    break;
                case REPEAT_CURRENT:
                default:
                    nextRepeatMode = MediaPlaybackService.RepeatMode.REPEAT_NONE;
                    showToast(R.string.repeat_off_notif);
                    break;
            }
            setRepeatMode(nextRepeatMode);
            // TODO(siyuanh): Should use a callback to register changes on service side
            setRepeatButtonImage(nextRepeatMode);
        }
    });
    if (mProgress instanceof SeekBar) {
        SeekBar seeker = (SeekBar) mProgress;
        seeker.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {

            boolean mmFromTouch = false;

            public void onStartTrackingTouch(SeekBar bar) {
                mLastSeekEventTime = 0;
                mmFromTouch = true;
            }

            public void onProgressChanged(SeekBar bar, int progress, boolean fromuser) {
                if (!fromuser || (getMediaController() == null))
                    return;
                long now = SystemClock.elapsedRealtime();
                if ((now - mLastSeekEventTime) > 250) {
                    mLastSeekEventTime = now;
                    long duration = getMediaController().getMetadata().getLong(MediaMetadata.METADATA_KEY_DURATION);
                    long position = duration * progress / 1000;
                    getMediaController().getTransportControls().seekTo(position);
                    // trackball event, allow progress updates
                    if (!mmFromTouch) {
                        updateProgressBar();
                    }
                }
            }

            public void onStopTrackingTouch(SeekBar bar) {
                mmFromTouch = false;
            }
        });
    } else {
        LogHelper.d(TAG, "Seeking not supported");
    }
    mProgress.setMax(1000);
    mTouchSlop = ViewConfiguration.get(this).getScaledTouchSlop();
    Log.d(TAG, "Creating MediaBrowser");
    mMediaBrowser = new MediaBrowser(this, new ComponentName(this, MediaPlaybackService.class), mConnectionCallback, null);
}
#method_after
@Override
public void onCreate(Bundle icicle) {
    LogHelper.d(TAG, "onCreate()");
    super.onCreate(icicle);
    setVolumeControlStream(AudioManager.STREAM_MUSIC);
    requestWindowFeature(Window.FEATURE_NO_TITLE);
    setContentView(R.layout.audio_player);
    mCurrentTime = (TextView) findViewById(R.id.currenttime);
    mTotalTime = (TextView) findViewById(R.id.totaltime);
    mProgress = (ProgressBar) findViewById(android.R.id.progress);
    mAlbumArt = (ImageView) findViewById(R.id.album);
    mArtistName = (TextView) findViewById(R.id.artistname);
    mAlbumName = (TextView) findViewById(R.id.albumname);
    mTrackName = (TextView) findViewById(R.id.trackname);
    mTrackInfo = (LinearLayout) findViewById(R.id.trackinfo);
    Bitmap b = BitmapFactory.decodeResource(getResources(), R.drawable.albumart_mp_unknown);
    mDefaultAlbumArt = new BitmapDrawable(getResources(), b);
    // no filter or dither, it's a lot faster and we can't tell the difference
    mDefaultAlbumArt.setFilterBitmap(false);
    mDefaultAlbumArt.setDither(false);
    /* Set metadata listeners */
    View v = (View) mArtistName.getParent();
    v.setOnTouchListener(this);
    v.setOnLongClickListener(this);
    v = (View) mAlbumName.getParent();
    v.setOnTouchListener(this);
    v.setOnLongClickListener(this);
    v = (View) mTrackName.getParent();
    v.setOnTouchListener(this);
    v.setOnLongClickListener(this);
    /* Set button listeners */
    mPrevButton = (RepeatingImageButton) findViewById(R.id.prev);
    mPrevButton.setOnClickListener(new View.OnClickListener() {

        public void onClick(View v) {
            if (getMediaController() == null)
                return;
            if (getMediaController().getPlaybackState().getPosition() < 2000) {
                getMediaController().getTransportControls().skipToPrevious();
            } else {
                getMediaController().getTransportControls().seekTo(0);
                getMediaController().getTransportControls().play();
            }
        }
    });
    mPrevButton.setRepeatListener(new RepeatingImageButton.RepeatListener() {

        public void onRepeat(View v, long howlong, int repcnt) {
            scanBackward(repcnt, howlong);
        }
    }, 260);
    mPlayPauseButton = (ImageButton) findViewById(R.id.pause);
    mPlayPauseButton.requestFocus();
    mPlayPauseButton.setOnClickListener(new View.OnClickListener() {

        public void onClick(View v) {
            if (getMediaController() != null) {
                if (getMediaController().getPlaybackState().getState() != PlaybackState.STATE_PLAYING) {
                    getMediaController().getTransportControls().play();
                } else {
                    getMediaController().getTransportControls().pause();
                }
            }
        }
    });
    mNextButton = (RepeatingImageButton) findViewById(R.id.next);
    mNextButton.setOnClickListener(new View.OnClickListener() {

        public void onClick(View v) {
            if (getMediaController() == null)
                return;
            getMediaController().getTransportControls().skipToNext();
        }
    });
    mNextButton.setRepeatListener(new RepeatingImageButton.RepeatListener() {

        public void onRepeat(View v, long howlong, int repcnt) {
            scanForward(repcnt, howlong);
        }
    }, 260);
    mQueueButton = (ImageButton) findViewById(R.id.curplaylist);
    mQueueButton.setOnClickListener(new View.OnClickListener() {

        public void onClick(View v) {
            LogHelper.d(TAG, "mQueueButton onClick");
            MediaBrowser.MediaItem parentItem = new MediaBrowser.MediaItem(new MediaDescription.Builder().setMediaId(MediaIDHelper.createBrowseCategoryMediaID(MediaIDHelper.MEDIA_ID_MUSICS_BY_PLAYLIST, MediaIDHelper.MEDIA_ID_NOW_PLAYING)).setTitle("Now Playing").build(), MediaBrowser.MediaItem.FLAG_BROWSABLE);
            Intent intent = new Intent(Intent.ACTION_PICK).setDataAndType(Uri.EMPTY, "vnd.android.cursor.dir/track").putExtra(MusicUtils.TAG_WITH_TABS, false).putExtra(MusicUtils.TAG_PARENT_ITEM, parentItem);
            startActivity(intent);
        }
    });
    mShuffleButton = ((ImageButton) findViewById(R.id.shuffle));
    mShuffleButton.setOnClickListener(new View.OnClickListener() {

        public void onClick(View v) {
            toggleShuffle();
        }
    });
    mRepeatButton = ((ImageButton) findViewById(R.id.repeat));
    mRepeatButton.setOnClickListener(new View.OnClickListener() {

        public void onClick(View v) {
            LogHelper.d(TAG, "Repeat button clicked");
            if (getMediaController() == null)
                return;
            Bundle extras = getMediaController().getExtras();
            if (extras == null)
                return;
            MediaPlaybackService.RepeatMode repeatMode = MediaPlaybackService.RepeatMode.values()[extras.getInt(MediaPlaybackService.REPEAT_MODE)];
            MediaPlaybackService.RepeatMode nextRepeatMode;
            switch(repeatMode) {
                case REPEAT_NONE:
                    nextRepeatMode = MediaPlaybackService.RepeatMode.REPEAT_ALL;
                    showToast(R.string.repeat_all_notif);
                    break;
                case REPEAT_ALL:
                    nextRepeatMode = MediaPlaybackService.RepeatMode.REPEAT_CURRENT;
                    showToast(R.string.repeat_current_notif);
                    break;
                case REPEAT_CURRENT:
                default:
                    nextRepeatMode = MediaPlaybackService.RepeatMode.REPEAT_NONE;
                    showToast(R.string.repeat_off_notif);
                    break;
            }
            setRepeatMode(nextRepeatMode);
            // TODO(siyuanh): Should use a callback to register changes on service side
            setRepeatButtonImage(nextRepeatMode);
        }
    });
    if (mProgress instanceof SeekBar) {
        SeekBar seeker = (SeekBar) mProgress;
        seeker.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {

            boolean mmFromTouch = false;

            public void onStartTrackingTouch(SeekBar bar) {
                mLastSeekEventTime = 0;
                mmFromTouch = true;
            }

            public void onProgressChanged(SeekBar bar, int progress, boolean fromuser) {
                if (!fromuser || (getMediaController() == null))
                    return;
                long now = SystemClock.elapsedRealtime();
                if ((now - mLastSeekEventTime) > 250) {
                    mLastSeekEventTime = now;
                    long duration = getMediaController().getMetadata().getLong(MediaMetadata.METADATA_KEY_DURATION);
                    long position = duration * progress / 1000;
                    getMediaController().getTransportControls().seekTo(position);
                    // trackball event, allow progress updates
                    if (!mmFromTouch) {
                        updateProgressBar();
                    }
                }
            }

            public void onStopTrackingTouch(SeekBar bar) {
                mmFromTouch = false;
            }
        });
    } else {
        LogHelper.d(TAG, "Seeking not supported");
    }
    mProgress.setMax(1000);
    mTouchSlop = ViewConfiguration.get(this).getScaledTouchSlop();
    Log.d(TAG, "Creating MediaBrowser");
    mMediaBrowser = new MediaBrowser(this, new ComponentName(this, MediaPlaybackService.class), mConnectionCallback, null);
}
#end_block

#method_before
@Override
public void onStop() {
    LogHelper.d(TAG, "onStop()");
    super.onStop();
    mMediaBrowser.disconnect();
}
#method_after
@Override
public void onStop() {
    LogHelper.d(TAG, "onStop()");
    mMediaBrowser.disconnect();
    super.onStop();
}
#end_block

#method_before
private void toggleShuffle() {
    // TODO(siyuanh): Implement shuffle for SHUFFLE_NORMAL, SHUFFLE_AUTO, SHUFFLE_NONE
    LogHelper.d(TAG, "Shuffle not implemented yet");
}
#method_after
private void toggleShuffle() {
    // TODO(b/36371715): Implement shuffle for SHUFFLE_NORMAL, SHUFFLE_AUTO, SHUFFLE_NONE
    LogHelper.d(TAG, "Shuffle not implemented yet");
    Toast.makeText(this, "Shuffle not implemented yet", Toast.LENGTH_SHORT).show();
}
#end_block

#method_before
private void setShuffleButtonImage() {
    if (getMediaController() == null)
        return;
    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_off_btn);
// try {
// switch (mService.getShuffleMode()) {
// case MediaPlaybackService.SHUFFLE_NONE:
// mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_off_btn);
// break;
// case MediaPlaybackService.SHUFFLE_AUTO:
// mShuffleButton.setImageResource(R.drawable.ic_mp_partyshuffle_on_btn);
// break;
// default:
// mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_on_btn);
// break;
// }
// } catch (RemoteException ex) {
// }
}
#method_after
private void setShuffleButtonImage() {
    if (getMediaController() == null)
        return;
    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_off_btn);
}
#end_block

#method_before
private void updateTrackInfo() {
    LogHelper.d(TAG, "updateTrackInfo()");
    if (getMediaController() == null) {
        return;
    }
    MediaMetadata metadata = getMediaController().getMetadata();
    if (metadata == null) {
        return;
    }
    ((View) mArtistName.getParent()).setVisibility(View.VISIBLE);
    ((View) mAlbumName.getParent()).setVisibility(View.VISIBLE);
    ((View) mTrackName.getParent()).setVisibility(View.VISIBLE);
    mTrackName.setText(metadata.getString(MediaMetadata.METADATA_KEY_TITLE));
    LogHelper.d(TAG, "Track Name: ", mTrackName.getText());
    String artistName = metadata.getString(MediaMetadata.METADATA_KEY_ARTIST);
    if (artistName.equals(MusicProvider.UNKOWN)) {
        artistName = getString(R.string.unknown_artist_name);
    }
    mArtistName.setText(artistName);
    String albumName = metadata.getString(MediaMetadata.METADATA_KEY_ALBUM);
    if (albumName.equals(MusicProvider.UNKOWN)) {
        albumName = getString(R.string.unknown_album_name);
    }
    mAlbumName.setText(albumName);
    Bitmap albumArt = metadata.getBitmap(MediaMetadata.METADATA_KEY_ALBUM_ART);
    if (albumArt != null) {
        mAlbumArt.setImageBitmap(albumArt);
    } else {
        mAlbumArt.setImageDrawable(mDefaultAlbumArt);
    }
    mAlbumArt.setVisibility(View.VISIBLE);
    long duration = metadata.getLong(MediaMetadata.METADATA_KEY_DURATION);
    mTotalTime.setText(MusicUtils.makeTimeString(this, duration / 1000));
}
#method_after
private void updateTrackInfo() {
    LogHelper.d(TAG, "updateTrackInfo()");
    if (getMediaController() == null) {
        return;
    }
    MediaMetadata metadata = getMediaController().getMetadata();
    if (metadata == null) {
        return;
    }
    mTrackInfo.setVisibility(View.VISIBLE);
    mTrackName.setText(metadata.getString(MediaMetadata.METADATA_KEY_TITLE));
    LogHelper.d(TAG, "Track Name: ", mTrackName.getText());
    String artistName = metadata.getString(MediaMetadata.METADATA_KEY_ARTIST);
    if (artistName.equals(MusicProvider.UNKOWN)) {
        artistName = getString(R.string.unknown_artist_name);
    }
    mArtistName.setText(artistName);
    String albumName = metadata.getString(MediaMetadata.METADATA_KEY_ALBUM);
    if (albumName.equals(MusicProvider.UNKOWN)) {
        albumName = getString(R.string.unknown_album_name);
    }
    mAlbumName.setText(albumName);
    Bitmap albumArt = metadata.getBitmap(MediaMetadata.METADATA_KEY_ALBUM_ART);
    if (albumArt != null) {
        mAlbumArt.setImageBitmap(albumArt);
    } else {
        mAlbumArt.setImageDrawable(mDefaultAlbumArt);
    }
    mAlbumArt.setVisibility(View.VISIBLE);
    long duration = metadata.getLong(MediaMetadata.METADATA_KEY_DURATION);
    mTotalTime.setText(MusicUtils.makeTimeString(this, duration / 1000));
}
#end_block

#method_before
@Override
public void onLoadChildren(final String parentMediaId, final Result<List<MediaItem>> result) {
    Log.d(TAG, "OnLoadChildren: parentMediaId=" + parentMediaId);
    // Browsing not allowed
    if (parentMediaId == null) {
        result.sendResult(null);
        return;
    }
    if (!mMusicProvider.isInitialized()) {
        // Use result.detach to allow calling result.sendResult from another thread:
        result.detach();
        mMusicProvider.retrieveMediaAsync(new MusicProvider.MusicProviderCallback() {

            @Override
            public void onMusicCatalogReady(boolean success) {
                Log.d(TAG, "Received catalog result, success:  " + String.valueOf(success));
                if (success) {
                    loadChildrenImpl(parentMediaId, result);
                } else {
                    result.sendResult(Collections.emptyList());
                }
            }
        });
    } else {
        // If our music catalog is already loaded/cached, load them into result immediately
        loadChildrenImpl(parentMediaId, result);
    }
}
#method_after
@Override
public void onLoadChildren(final String parentMediaId, final Result<List<MediaItem>> result) {
    Log.d(TAG, "OnLoadChildren: parentMediaId=" + parentMediaId);
    // Browsing not allowed
    if (parentMediaId == null) {
        result.sendResult(null);
        return;
    }
    if (!mMusicProvider.isInitialized()) {
        // Use result.detach to allow calling result.sendResult from another thread:
        result.detach();
        mMusicProvider.retrieveMediaAsync(new MusicProvider.MusicProviderCallback() {

            @Override
            public void onMusicCatalogReady(boolean success) {
                Log.d(TAG, "Received catalog result, success:  " + String.valueOf(success));
                if (success) {
                    onLoadChildren(parentMediaId, result);
                } else {
                    result.sendResult(Collections.emptyList());
                }
            }
        });
    } else {
        // If our music catalog is already loaded/cached, load them into result immediately
        List<MediaItem> mediaItems = new ArrayList<>();
        switch(parentMediaId) {
            case MEDIA_ID_ROOT:
                Log.d(TAG, "OnLoadChildren.ROOT");
                mediaItems.add(new MediaItem(new MediaDescription.Builder().setMediaId(MEDIA_ID_MUSICS_BY_ARTIST).setTitle("Artists").build(), MediaItem.FLAG_BROWSABLE));
                mediaItems.add(new MediaItem(new MediaDescription.Builder().setMediaId(MEDIA_ID_MUSICS_BY_ALBUM).setTitle("Albums").build(), MediaItem.FLAG_BROWSABLE));
                mediaItems.add(new MediaItem(new MediaDescription.Builder().setMediaId(MEDIA_ID_MUSICS_BY_SONG).setTitle("Songs").build(), MediaItem.FLAG_BROWSABLE));
                mediaItems.add(new MediaItem(new MediaDescription.Builder().setMediaId(MEDIA_ID_MUSICS_BY_PLAYLIST).setTitle("Playlists").build(), MediaItem.FLAG_BROWSABLE));
                break;
            case MEDIA_ID_MUSICS_BY_ARTIST:
                Log.d(TAG, "OnLoadChildren.ARTIST");
                for (String artist : mMusicProvider.getArtists()) {
                    MediaItem item = new MediaItem(new MediaDescription.Builder().setMediaId(MediaIDHelper.createBrowseCategoryMediaID(MEDIA_ID_MUSICS_BY_ARTIST, artist)).setTitle(artist).build(), MediaItem.FLAG_BROWSABLE);
                    mediaItems.add(item);
                }
                break;
            case MEDIA_ID_MUSICS_BY_PLAYLIST:
                LogHelper.d(TAG, "OnLoadChildren.PLAYLIST");
                for (String playlist : mMusicProvider.getPlaylists()) {
                    MediaItem item = new MediaItem(new MediaDescription.Builder().setMediaId(MediaIDHelper.createBrowseCategoryMediaID(MEDIA_ID_MUSICS_BY_PLAYLIST, playlist)).setTitle(playlist).build(), MediaItem.FLAG_BROWSABLE);
                    mediaItems.add(item);
                }
                break;
            case MEDIA_ID_MUSICS_BY_ALBUM:
                Log.d(TAG, "OnLoadChildren.ALBUM");
                loadAlbum(mMusicProvider.getAlbums(), mediaItems);
                break;
            case MEDIA_ID_MUSICS_BY_SONG:
                Log.d(TAG, "OnLoadChildren.SONG");
                String hierarchyAwareMediaID = MediaIDHelper.createBrowseCategoryMediaID(parentMediaId, MEDIA_ID_MUSICS_BY_SONG);
                loadSong(mMusicProvider.getMusicList(), mediaItems, hierarchyAwareMediaID);
                break;
            default:
                if (parentMediaId.startsWith(MEDIA_ID_MUSICS_BY_ARTIST)) {
                    String artist = MediaIDHelper.getHierarchy(parentMediaId)[1];
                    Log.d(TAG, "OnLoadChildren.SONGS_BY_ARTIST  artist=" + artist);
                    loadAlbum(mMusicProvider.getAlbumByArtist(artist), mediaItems);
                } else if (parentMediaId.startsWith(MEDIA_ID_MUSICS_BY_ALBUM)) {
                    String album = MediaIDHelper.getHierarchy(parentMediaId)[1];
                    Log.d(TAG, "OnLoadChildren.SONGS_BY_ALBUM  album=" + album);
                    loadSong(mMusicProvider.getMusicsByAlbum(album), mediaItems, parentMediaId);
                } else if (parentMediaId.startsWith(MEDIA_ID_MUSICS_BY_PLAYLIST)) {
                    String playlist = MediaIDHelper.getHierarchy(parentMediaId)[1];
                    LogHelper.d(TAG, "OnLoadChildren.SONGS_BY_PLAYLIST playlist=", playlist);
                    if (playlist.equals(MEDIA_ID_NOW_PLAYING) && mPlayingQueue != null && mPlayingQueue.size() > 0) {
                        loadPlayingQueue(mediaItems, parentMediaId);
                    } else {
                        loadSong(mMusicProvider.getMusicsByPlaylist(playlist), mediaItems, parentMediaId);
                    }
                } else {
                    Log.w(TAG, "Skipping unmatched parentMediaId: " + parentMediaId);
                }
                break;
        }
        Log.d(TAG, "OnLoadChildren sending " + mediaItems.size() + " results for " + parentMediaId);
        result.sendResult(mediaItems);
    }
}
#end_block

#method_before
private synchronized MediaMetadata retrievMediaMetadata(long musicId, String musicPath) {
    LogHelper.d(TAG, "getting metadata for music: ", musicPath);
    MediaMetadataRetriever retriever = new MediaMetadataRetriever();
    Uri contentUri = ContentUris.withAppendedId(android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, musicId);
    if (!(new File(musicPath).exists())) {
        LogHelper.d(TAG, "Does not exist, deleting item");
        mContext.getContentResolver().delete(contentUri, null, null);
        return null;
    }
    retriever.setDataSource(mContext, contentUri);
    String title = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE);
    String album = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ALBUM);
    String artist = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST);
    long duration = Long.parseLong(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION));
    MediaMetadata.Builder metadataBuilder = new MediaMetadata.Builder().putString(MediaMetadata.METADATA_KEY_MEDIA_ID, String.valueOf(musicId)).putString(CUSTOM_METADATA_TRACK_SOURCE, musicPath).putString(MediaMetadata.METADATA_KEY_TITLE, title != null ? title : UNKOWN).putString(MediaMetadata.METADATA_KEY_ALBUM, album != null ? album : UNKOWN).putString(MediaMetadata.METADATA_KEY_ARTIST, artist != null ? artist : UNKOWN).putLong(MediaMetadata.METADATA_KEY_DURATION, duration);
    byte[] albumArtData = retriever.getEmbeddedPicture();
    Bitmap bitmap;
    if (albumArtData != null) {
        bitmap = BitmapFactory.decodeByteArray(albumArtData, 0, albumArtData.length);
        bitmap = MusicUtils.resizeBitmap(bitmap, getDefaultAlbumArt());
        metadataBuilder.putBitmap(MediaMetadata.METADATA_KEY_ALBUM_ART, bitmap);
    }
    retriever.release();
    return metadataBuilder.build();
}
#method_after
private synchronized MediaMetadata retrievMediaMetadata(long musicId, String musicPath) {
    LogHelper.d(TAG, "getting metadata for music: ", musicPath);
    MediaMetadataRetriever retriever = new MediaMetadataRetriever();
    Uri contentUri = ContentUris.withAppendedId(android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, musicId);
    if (!(new File(musicPath).exists())) {
        LogHelper.d(TAG, "Does not exist, deleting item");
        mContext.getContentResolver().delete(contentUri, null, null);
        return null;
    }
    retriever.setDataSource(mContext, contentUri);
    String title = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE);
    String album = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ALBUM);
    String artist = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST);
    String durationString = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION);
    long duration = durationString != null ? Long.parseLong(durationString) : 0;
    MediaMetadata.Builder metadataBuilder = new MediaMetadata.Builder().putString(MediaMetadata.METADATA_KEY_MEDIA_ID, String.valueOf(musicId)).putString(CUSTOM_METADATA_TRACK_SOURCE, musicPath).putString(MediaMetadata.METADATA_KEY_TITLE, title != null ? title : UNKOWN).putString(MediaMetadata.METADATA_KEY_ALBUM, album != null ? album : UNKOWN).putString(MediaMetadata.METADATA_KEY_ARTIST, artist != null ? artist : UNKOWN).putLong(MediaMetadata.METADATA_KEY_DURATION, duration);
    byte[] albumArtData = retriever.getEmbeddedPicture();
    Bitmap bitmap;
    if (albumArtData != null) {
        bitmap = BitmapFactory.decodeByteArray(albumArtData, 0, albumArtData.length);
        bitmap = MusicUtils.resizeBitmap(bitmap, getDefaultAlbumArt());
        metadataBuilder.putBitmap(MediaMetadata.METADATA_KEY_ALBUM_ART, bitmap);
    }
    retriever.release();
    return metadataBuilder.build();
}
#end_block

#method_before
@Override
public void onCreate(Bundle icicle) {
    super.onCreate(icicle);
    LogHelper.d(TAG, "onCreate()");
    // Handle past states
    if (icicle != null) {
        mParentItem = icicle.getParcelable(MusicUtils.TAG_PARENT_ITEM);
    } else if (getIntent() != null) {
        mParentItem = getIntent().getExtras().getParcelable(MusicUtils.TAG_PARENT_ITEM);
    }
    if (mParentItem == null) {
        mParentItem = DEFAULT_PARENT_ITEM;
    }
    requestWindowFeature(Window.FEATURE_NO_TITLE);
    setVolumeControlStream(AudioManager.STREAM_MUSIC);
    // Init layout
    setContentView(R.layout.media_picker_activity_expanding);
    MusicUtils.updateButtonBar(this, R.id.artisttab);
    // Init expandable list
    ExpandableListView lv = getExpandableListView();
    lv.setTextFilterEnabled(true);
    mAdapter = (ArtistAlbumListAdapter) getLastNonConfigurationInstance();
    if (mAdapter == null) {
        // Log.i("@@@", "starting query");
        mAdapter = new ArtistAlbumListAdapter(this, new ArrayList<ConcurrentHashMap<String, MediaBrowser.MediaItem>>(), R.layout.track_list_item_group, new String[] {}, new int[] {}, new ArrayList<ArrayList<ConcurrentHashMap<String, MediaBrowser.MediaItem>>>(), R.layout.track_list_item_child, new String[] {}, new int[] {});
        setListAdapter(mAdapter);
        setTitle(R.string.working_artists);
    } else {
        mAdapter.setActivity(this);
    }
    setListAdapter(mAdapter);
    LogHelper.d(TAG, "Creating MediaBrowser");
    mMediaBrowser = new MediaBrowser(this, new ComponentName(this, MediaPlaybackService.class), mConnectionCallback, null);
}
#method_after
@Override
public void onCreate(Bundle icicle) {
    super.onCreate(icicle);
    LogHelper.d(TAG, "onCreate()");
    // Handle past states
    if (icicle != null) {
        mParentItem = icicle.getParcelable(MusicUtils.TAG_PARENT_ITEM);
    } else if (getIntent() != null) {
        mParentItem = getIntent().getExtras().getParcelable(MusicUtils.TAG_PARENT_ITEM);
    }
    if (mParentItem == null) {
        mParentItem = DEFAULT_PARENT_ITEM;
    }
    requestWindowFeature(Window.FEATURE_NO_TITLE);
    setVolumeControlStream(AudioManager.STREAM_MUSIC);
    // Init layout
    setContentView(R.layout.media_picker_activity_expanding);
    MusicUtils.updateButtonBar(this, R.id.artisttab);
    // Init expandable list
    ExpandableListView lv = getExpandableListView();
    lv.setTextFilterEnabled(true);
    mAdapter = (ArtistAlbumListAdapter) getLastNonConfigurationInstance();
    if (mAdapter == null) {
        // Log.i("@@@", "starting query");
        mAdapter = new ArtistAlbumListAdapter(this, new ArrayList<>(), new ArrayList<>());
        setListAdapter(mAdapter);
        setTitle(R.string.working_artists);
    } else {
        mAdapter.setActivity(this);
    }
    setListAdapter(mAdapter);
    LogHelper.d(TAG, "Creating MediaBrowser");
    mMediaBrowser = new MediaBrowser(this, new ComponentName(this, MediaPlaybackService.class), mConnectionCallback, null);
}
#end_block

#method_before
private void postBootUpdate(JobParameters jobParams, PackageManagerService pm, ArraySet<String> pkgs) {
    // Load low battery threshold from the system config. This is a 0-100 integer.
    final int lowBatteryThreshold = getResources().getInteger(com.android.internal.R.integer.config_lowBatteryWarningLevel);
    final long lowThreshold = getLowStorageThreshold(this);
    mAbortPostBootUpdate.set(false);
    for (String pkg : pkgs) {
        if (mAbortPostBootUpdate.get()) {
            // JobScheduler requested an early abort.
            return;
        }
        if (mExitPostBootUpdate.get()) {
            // Different job, which supersedes this one, is running.
            break;
        }
        if (getBatteryLevel() < lowBatteryThreshold) {
            // Rather bail than completely drain the battery.
            break;
        }
        long usableSpace = mDataDir.getUsableSpace();
        if (usableSpace < lowThreshold) {
            // Rather bail than completely fill up the disk.
            Log.w(TAG, "Aborting background dex opt job due to low storage: " + usableSpace);
            break;
        }
        if (DEBUG_DEXOPT) {
            Log.i(TAG, "Updating package " + pkg);
        }
        // Update package if needed. Note that there can be no race between concurrent
        // jobs because PackageDexOptimizer.performDexOpt is synchronized.
        // checkProfiles is false to avoid merging profiles during boot which
        // might interfere with background compilation (b/28612421).
        // Unfortunately this will also means that "pm.dexopt.boot=speed-profile" will
        // behave differently than "pm.dexopt.bg-dexopt=speed-profile" but that's a
        // trade-off worth doing to save boot time work.
        pm.performDexOpt(pkg, /* checkProfiles */
        false, PackageManagerService.REASON_BOOT, /* force */
        false);
    }
    // Ran to completion, so we abandon our timeslice and do not reschedule.
    jobFinished(jobParams, /* reschedule */
    false);
}
#method_after
private void postBootUpdate(JobParameters jobParams, PackageManagerService pm, ArraySet<String> pkgs) {
    // Load low battery threshold from the system config. This is a 0-100 integer.
    final int lowBatteryThreshold = getResources().getInteger(com.android.internal.R.integer.config_lowBatteryWarningLevel);
    final long lowThreshold = getLowStorageThreshold(this);
    mAbortPostBootUpdate.set(false);
    ArraySet<String> updatedPackages = new ArraySet<>();
    for (String pkg : pkgs) {
        if (mAbortPostBootUpdate.get()) {
            // JobScheduler requested an early abort.
            return;
        }
        if (mExitPostBootUpdate.get()) {
            // Different job, which supersedes this one, is running.
            break;
        }
        if (getBatteryLevel() < lowBatteryThreshold) {
            // Rather bail than completely drain the battery.
            break;
        }
        long usableSpace = mDataDir.getUsableSpace();
        if (usableSpace < lowThreshold) {
            // Rather bail than completely fill up the disk.
            Log.w(TAG, "Aborting background dex opt job due to low storage: " + usableSpace);
            break;
        }
        if (DEBUG_DEXOPT) {
            Log.i(TAG, "Updating package " + pkg);
        }
        // Update package if needed. Note that there can be no race between concurrent
        // jobs because PackageDexOptimizer.performDexOpt is synchronized.
        // checkProfiles is false to avoid merging profiles during boot which
        // might interfere with background compilation (b/28612421).
        // Unfortunately this will also means that "pm.dexopt.boot=speed-profile" will
        // behave differently than "pm.dexopt.bg-dexopt=speed-profile" but that's a
        // trade-off worth doing to save boot time work.
        int result = pm.performDexOptWithStatus(pkg, /* checkProfiles */
        false, PackageManagerService.REASON_BOOT, /* force */
        false, /* bootComplete */
        true, /* downgrade */
        false);
        if (result == PackageDexOptimizer.DEX_OPT_PERFORMED) {
            updatedPackages.add(pkg);
        }
    }
    notifyPinService(updatedPackages);
    // Ran to completion, so we abandon our timeslice and do not reschedule.
    jobFinished(jobParams, /* reschedule */
    false);
}
#end_block

#method_before
private int optimizePackages(PackageManagerService pm, ArraySet<String> pkgs, long lowStorageThreshold, boolean is_for_primary_dex, ArraySet<String> failedPackageNames) {
    Collection<Package> packages = pm.mPackages.values();
    Set<String> unusedPkgSet = new HashSet<>();
    // Prepare a list of packages which haven't been used for 30 days in foreground.
    for (Package pkg : packages) {
        if (System.currentTimeMillis() - pkg.getLatestForegroundPackageUseTimeInMills() > QUICKEN_UNUSED_APPS_THRESHOLD_IN_MILLIS) {
            unusedPkgSet.add(pkg.packageName);
        }
    }
    for (String pkg : pkgs) {
        int abort_code = abortIdleOptimizations(lowStorageThreshold);
        if (abort_code != OPTIMIZE_CONTINUE) {
            return abort_code;
        }
        synchronized (failedPackageNames) {
            if (failedPackageNames.contains(pkg)) {
                // Skip previously failing package
                continue;
            } else {
                // Conservatively add package to the list of failing ones in case performDexOpt
                // never returns.
                failedPackageNames.add(pkg);
            }
        }
        int reason;
        boolean forceCompile;
        // Force compile the unused package to quicken.
        if (unusedPkgSet.contains(pkg)) {
            reason = PackageManagerService.REASON_INSTALL;
            forceCompile = true;
        } else {
            reason = PackageManagerService.REASON_BACKGROUND_DEXOPT;
            forceCompile = false;
        }
        // Optimize package if needed. Note that there can be no race between
        // concurrent jobs because PackageDexOptimizer.performDexOpt is synchronized.
        boolean success = is_for_primary_dex ? pm.performDexOpt(pkg, /* checkProfiles */
        true, reason, forceCompile) : pm.performDexOptSecondary(pkg, reason, forceCompile);
        if (success) {
            // Dexopt succeeded, remove package from the list of failing ones.
            synchronized (failedPackageNames) {
                failedPackageNames.remove(pkg);
            }
        }
    }
    return OPTIMIZE_PROCESSED;
}
#method_after
private int optimizePackages(PackageManagerService pm, ArraySet<String> pkgs, long lowStorageThreshold, boolean is_for_primary_dex, ArraySet<String> failedPackageNames) {
    ArraySet<String> updatedPackages = new ArraySet<>();
    Set<String> unusedPackages = pm.getUnusedPackages(mDowngradeUnusedAppsThresholdInMillis);
    // Only downgrade apps when space is low on device.
    // Threshold is selected above the lowStorageThreshold so that we can pro-actively clean
    // up disk before user hits the actual lowStorageThreshold.
    final long lowStorageThresholdForDowngrade = LOW_THRESHOLD_MULTIPLIER_FOR_DOWNGRADE * lowStorageThreshold;
    boolean shouldDowngrade = shouldDowngrade(lowStorageThresholdForDowngrade);
    for (String pkg : pkgs) {
        int abort_code = abortIdleOptimizations(lowStorageThreshold);
        if (abort_code == OPTIMIZE_ABORT_BY_JOB_SCHEDULER) {
            return abort_code;
        }
        synchronized (failedPackageNames) {
            if (failedPackageNames.contains(pkg)) {
                // Skip previously failing package
                continue;
            }
        }
        int reason;
        boolean downgrade;
        // Downgrade unused packages.
        if (unusedPackages.contains(pkg) && shouldDowngrade) {
            // monolithic install.
            if (is_for_primary_dex && !pm.canHaveOatDir(pkg)) {
                // For apps that don't have the oat directory, instead of downgrading,
                // remove their compiler artifacts from dalvik cache.
                pm.deleteOatArtifactsOfPackage(pkg);
                continue;
            } else {
                reason = PackageManagerService.REASON_INACTIVE_PACKAGE_DOWNGRADE;
                downgrade = true;
            }
        } else if (abort_code != OPTIMIZE_ABORT_NO_SPACE_LEFT) {
            reason = PackageManagerService.REASON_BACKGROUND_DEXOPT;
            downgrade = false;
        } else {
            // can't dexopt because of low space.
            continue;
        }
        synchronized (failedPackageNames) {
            // Conservatively add package to the list of failing ones in case
            // performDexOpt never returns.
            failedPackageNames.add(pkg);
        }
        // Optimize package if needed. Note that there can be no race between
        // concurrent jobs because PackageDexOptimizer.performDexOpt is synchronized.
        boolean success;
        if (is_for_primary_dex) {
            int result = pm.performDexOptWithStatus(pkg, /* checkProfiles */
            true, reason, false, /* forceCompile*/
            true, /* bootComplete */
            downgrade);
            success = result != PackageDexOptimizer.DEX_OPT_FAILED;
            if (result == PackageDexOptimizer.DEX_OPT_PERFORMED) {
                updatedPackages.add(pkg);
            }
        } else {
            success = pm.performDexOptSecondary(pkg, reason, false, /* force */
            downgrade);
        }
        if (success) {
            // Dexopt succeeded, remove package from the list of failing ones.
            synchronized (failedPackageNames) {
                failedPackageNames.remove(pkg);
            }
        }
    }
    notifyPinService(updatedPackages);
    return OPTIMIZE_PROCESSED;
}
#end_block

#method_before
@Override
public boolean onStartJob(JobParameters params) {
    if (DEBUG_DEXOPT) {
        Log.i(TAG, "onStartJob");
    }
    // NOTE: PackageManagerService.isStorageLow uses a different set of criteria from
    // the checks above. This check is not "live" - the value is determined by a background
    // restart with a period of ~1 minute.
    PackageManagerService pm = (PackageManagerService) ServiceManager.getService("package");
    if (pm.isStorageLow()) {
        if (DEBUG_DEXOPT) {
            Log.i(TAG, "Low storage, skipping this run");
        }
        return false;
    }
    final ArraySet<String> pkgs = pm.getOptimizablePackages();
    if (pkgs.isEmpty()) {
        if (DEBUG_DEXOPT) {
            Log.i(TAG, "No packages to optimize");
        }
        return false;
    }
    if (params.getJobId() == JOB_POST_BOOT_UPDATE) {
        return runPostBootUpdate(params, pm, pkgs);
    } else {
        return runIdleOptimization(params, pm, pkgs);
    }
}
#method_after
@Override
public boolean onStartJob(JobParameters params) {
    if (DEBUG_DEXOPT) {
        Log.i(TAG, "onStartJob");
    }
    // NOTE: PackageManagerService.isStorageLow uses a different set of criteria from
    // the checks above. This check is not "live" - the value is determined by a background
    // restart with a period of ~1 minute.
    PackageManagerService pm = (PackageManagerService) ServiceManager.getService("package");
    if (pm.isStorageLow()) {
        if (DEBUG_DEXOPT) {
            Log.i(TAG, "Low storage, skipping this run");
        }
        return false;
    }
    final ArraySet<String> pkgs = pm.getOptimizablePackages();
    if (pkgs.isEmpty()) {
        if (DEBUG_DEXOPT) {
            Log.i(TAG, "No packages to optimize");
        }
        return false;
    }
    boolean result;
    if (params.getJobId() == JOB_POST_BOOT_UPDATE) {
        result = runPostBootUpdate(params, pm, pkgs);
    } else {
        result = runIdleOptimization(params, pm, pkgs);
    }
    return result;
}
#end_block

#method_before
public void heyItsMe(IBazCallback cb) {
    Log.d(TAG, "SERVER: heyItsMe");
}
#method_after
public void heyItsMe(IBazCallback cb) throws RemoteException {
    mCalled = true;
    cb.heyItsMe(null);
}
#end_block

#method_before
public void hey() {
    Log.d(TAG, "SERVER: hey");
}
#method_after
public void hey() {
    mCalled = true;
}
#end_block

#method_before
private void client() throws RemoteException {
    ExpectDeepEq(null, null);
    ExpectDeepNe(null, new String());
    ExpectDeepNe(new String(), null);
    ExpectDeepEq(new String(), new String());
    ExpectDeepEq("hey", "hey");
    ExpectDeepEq(new int[] { 1, 2 }, new int[] { 1, 2 });
    ExpectDeepNe(new int[] { 1, 2 }, new int[] { 1, 3 });
    ExpectDeepNe(new int[] { 1, 2 }, new int[] { 1, 2, 3 });
    ExpectDeepEq(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 4 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 5 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2, 3 }, { 4, 5, 6 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 4, 5 } });
    ExpectDeepEq(new Integer[] { 1, 2 }, new Integer[] { 1, 2 });
    ExpectDeepNe(new Integer[] { 1, 2 }, new Integer[] { 1, 3 });
    ExpectDeepNe(new Integer[] { 1, 2 }, new Integer[] { 1, 2, 3 });
    ExpectDeepEq(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 4 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 5 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2, 3 }, { 4, 5, 6 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 4, 5 } });
    ExpectDeepEq(new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(1, 2)));
    ExpectDeepNe(new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(1, 2, 3)));
    ExpectDeepEq(new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })), new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })));
    ExpectDeepNe(new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })), new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 5 })));
    ExpectDeepEq(new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })), new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })));
    ExpectDeepNe(new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })), new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 5 })));
    ExpectDeepEq(new ArrayList[] { new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(3, 4)) }, new ArrayList[] { new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(3, 4)) });
    {
        // Test proper exceptions are thrown
        try {
            IBase proxy = IBase.getService("this-doesn't-exist");
        } catch (Exception e) {
            ExpectTrue(e instanceof NoSuchElementException);
        }
    }
    {
        // Test access through base interface binder.
        IBase baseProxy = IBase.getService("baz");
        baseProxy.someBaseMethod();
        IBaz bazProxy = IBaz.castFrom(baseProxy);
        ExpectTrue(bazProxy != null);
        // IQuux is completely unrelated to IBase/IBaz, so the following
        // should fail, i.e. return null.
        IQuux quuxProxy = IQuux.castFrom(baseProxy);
        ExpectTrue(quuxProxy == null);
    }
    IBaz proxy = IBaz.getService("baz");
    proxy.someBaseMethod();
    {
        Expect(proxy.interfaceDescriptor(), IBaz.kInterfaceName);
    }
    {
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        IBase.Foo result = proxy.someOtherBaseMethod(foo);
        ExpectTrue(result.equals(foo));
    }
    {
        IBase.Foo[] inputArray = new IBase.Foo[2];
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputArray[0] = foo;
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputArray[1] = foo;
        IBase.Foo[] expectedOutputArray = new IBase.Foo[2];
        expectedOutputArray[0] = inputArray[1];
        expectedOutputArray[1] = inputArray[0];
        IBase.Foo[] outputArray = proxy.someMethodWithFooArrays(inputArray);
        ExpectTrue(java.util.Objects.deepEquals(outputArray, expectedOutputArray));
    }
    {
        ArrayList<IBase.Foo> inputVec = new ArrayList<IBase.Foo>();
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputVec.add(foo);
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputVec.add(foo);
        ArrayList<IBase.Foo> expectedOutputVec = new ArrayList<IBase.Foo>();
        expectedOutputVec.add(inputVec.get(1));
        expectedOutputVec.add(inputVec.get(0));
        ArrayList<IBase.Foo> outputVec = proxy.someMethodWithFooVectors(inputVec);
        ExpectTrue(java.util.Objects.deepEquals(outputVec, expectedOutputVec));
    }
    {
        IBase.VectorOfArray in = new IBase.VectorOfArray();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.addresses.add(mac);
        }
        IBase.VectorOfArray expectedOut = new IBase.VectorOfArray();
        int n = in.addresses.size();
        for (int i = 0; i < n; ++i) {
            expectedOut.addresses.add(in.addresses.get(n - 1 - i));
        }
        IBase.VectorOfArray out = proxy.someMethodWithVectorOfArray(in);
        ExpectTrue(out.equals(expectedOut));
    }
    {
        ArrayList<byte[]> in = new ArrayList<byte[]>();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.add(mac);
        }
        ArrayList<byte[]> expectedOut = new ArrayList<byte[]>();
        int n = in.size();
        for (int i = 0; i < n; ++i) {
            expectedOut.add(in.get(n - 1 - i));
        }
        ArrayList<byte[]> out = proxy.someMethodTakingAVectorOfArray(in);
        ExpectTrue(out.size() == expectedOut.size());
        for (int i = 0; i < n; ++i) {
            ExpectTrue(java.util.Objects.deepEquals(out.get(i), expectedOut.get(i)));
        }
    }
    {
        IBase.StringMatrix5x3 in = new IBase.StringMatrix5x3();
        IBase.StringMatrix3x5 expectedOut = new IBase.StringMatrix3x5();
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in.s[i][j] = numberToEnglish(3 * i + j + 1);
                expectedOut.s[j][i] = in.s[i][j];
            }
        }
        IBase.StringMatrix3x5 out = proxy.transpose(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        ExpectTrue(out.equals(expectedOut));
    }
    {
        String[][] in = new String[5][3];
        String[][] expectedOut = new String[3][5];
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in[i][j] = numberToEnglish(3 * i + j + 1);
                expectedOut[j][i] = in[i][j];
            }
        }
        String[][] out = proxy.transpose2(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        ExpectTrue(java.util.Arrays.deepEquals(out, expectedOut));
    }
    ExpectTrue(proxy.someBoolMethod(true) == false);
    {
        boolean[] someBoolArray = new boolean[3];
        someBoolArray[0] = true;
        someBoolArray[1] = false;
        someBoolArray[2] = true;
        boolean[] resultArray = proxy.someBoolArrayMethod(someBoolArray);
        ExpectTrue(resultArray[0] == false);
        ExpectTrue(resultArray[1] == true);
        ExpectTrue(resultArray[2] == false);
        ArrayList<Boolean> someBoolVec = new ArrayList<Boolean>();
        someBoolVec.add(true);
        someBoolVec.add(false);
        someBoolVec.add(true);
        ArrayList<Boolean> resultVec = proxy.someBoolVectorMethod(someBoolVec);
        ExpectTrue(resultVec.get(0) == false);
        ExpectTrue(resultVec.get(1) == true);
        ExpectTrue(resultVec.get(2) == false);
    }
    proxy.doThis(1.0f);
    ExpectTrue(proxy.doThatAndReturnSomething(1) == 666);
    ExpectTrue(proxy.doQuiteABit(1, 2L, 3.0f, 4.0) == 666.5);
    {
        int[] paramArray = new int[15];
        int[] expectedOutArray = new int[32];
        ArrayList<Integer> paramVec = new ArrayList<Integer>();
        ArrayList<Integer> expectedOutVec = new ArrayList<Integer>();
        for (int i = 0; i < paramArray.length; ++i) {
            paramArray[i] = i;
            paramVec.add(i);
            expectedOutArray[i] = 2 * i;
            expectedOutArray[15 + i] = i;
            expectedOutVec.add(2 * i);
        }
        expectedOutArray[30] = 1;
        expectedOutArray[31] = 2;
        int[] outArray = proxy.doSomethingElse(paramArray);
        ExpectTrue(java.util.Objects.deepEquals(outArray, expectedOutArray));
        ArrayList<Integer> outVec = proxy.mapThisVector(paramVec);
        java.util.Objects.equals(outVec, expectedOutVec);
    }
    Expect(proxy.doStuffAndReturnAString(), "Hello, world!");
    BazCallback cb = new BazCallback();
    ExpectTrue(!cb.wasCalled());
    proxy.callMe(cb);
    ExpectTrue(cb.wasCalled());
    ExpectTrue(proxy.useAnEnum(IBaz.SomeEnum.goober) == -64);
    {
        String[] stringArray = new String[3];
        stringArray[0] = "one";
        stringArray[1] = "two";
        stringArray[2] = "three";
        String[] expectedOutArray = new String[2];
        expectedOutArray[0] = "Hello";
        expectedOutArray[1] = "World";
        String[] outArray = proxy.haveSomeStrings(stringArray);
        ExpectTrue(java.util.Arrays.deepEquals(outArray, expectedOutArray));
        ArrayList<String> stringVec = new ArrayList<String>();
        stringVec.add("one");
        stringVec.add("two");
        stringVec.add("three");
        ArrayList<String> expectedOutVec = new ArrayList<String>();
        expectedOutVec.add("Hello");
        expectedOutVec.add("World");
        ExpectTrue(expectedOutVec.equals(proxy.haveAStringVec(stringVec)));
    }
    proxy.returnABunchOfStrings(new IBaz.returnABunchOfStringsCallback() {

        @Override
        public void onValues(String a, String b, String c) {
            Expect(a, "Eins");
            Expect(b, "Zwei");
            Expect(c, "Drei");
        }
    });
    proxy.returnABunchOfStrings((a, b, c) -> Expect(a + b + c, "EinsZweiDrei"));
    proxy.callMeLater(new BazCallback());
    System.gc();
    proxy.iAmFreeNow();
    {
        IBaz.T t1 = new IBaz.T();
        IBaz.T t2 = new IBaz.T();
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 3; j++) {
                t1.matrix5x3[i][j] = t2.matrix5x3[i][j] = (i + 1) * (j + 1);
            }
        }
        ExpectTrue(t1.equals(t2));
        ExpectTrue(t1.hashCode() == t2.hashCode());
        t2.matrix5x3[4][2] = -60;
        ExpectTrue(!t1.equals(t2));
    }
    ArrayList<NestedStruct> structs = proxy.getNestedStructs();
    ExpectTrue(structs.size() == 5);
    ExpectTrue(structs.get(1).matrices.size() == 6);
    {
        IBaz.Everything e = new IBaz.Everything();
        Expect(e.toString(), "{.number = 0, .anotherNumber = 0, .s = , " + ".vs = [], .multidimArray = [[null, null], [null, null]], " + ".sArray = [null, null, null], .anotherStruct = {.first = , .last = }, .bf = }");
        e.s = "string!";
        e.number = 127;
        e.anotherNumber = 100;
        e.vs.addAll(Arrays.asList("One", "Two", "Three"));
        for (int i = 0; i < e.multidimArray.length; i++) for (int j = 0; j < e.multidimArray[i].length; j++) e.multidimArray[i][j] = Integer.toString(i) + Integer.toString(j);
        e.bf = IBaz.BitField.VALL;
        e.anotherStruct.first = "James";
        e.anotherStruct.last = "Bond";
        Expect(e.toString(), "{.number = 127, .anotherNumber = 100, .s = string!, " + ".vs = [One, Two, Three], .multidimArray = [[00, 01], [10, 11]], " + ".sArray = [null, null, null], .anotherStruct = {.first = James, .last = Bond}, " + ".bf = V0 | V1 | V2 | V3 | VALL}");
        Expect(IBaz.BitField.toString(IBaz.BitField.VALL), "VALL");
        Expect(IBaz.BitField.toString((byte) (IBaz.BitField.V0 | IBaz.BitField.V2)), "0x5");
        Expect(IBaz.BitField.dumpBitfield(IBaz.BitField.VALL), "V0 | V1 | V2 | V3 | VALL");
        Expect(IBaz.BitField.dumpBitfield((byte) (IBaz.BitField.V1 | IBaz.BitField.V3 | 0xF0)), "V1 | V3 | 0xf0");
        Expect(proxy.toString(), IBaz.kInterfaceName + "@Proxy");
    }
    {
        // Ensure that native parcel is cleared even if the corresponding
        // Java object isn't GC'd.
        ArrayList<Integer> data4K = new ArrayList<>(1024);
        for (int i = 0; i < 1024; i++) {
            data4K.add(i);
        }
        for (int i = 0; i < 1024; i++) {
            // kernel binder buffer, and will fail.
            try {
                proxy.mapThisVector(data4K);
            } catch (RemoteException ex) {
                throw new RuntimeException("Failed at call #" + Integer.toString(i), ex);
            }
        }
    }
    {
        // TestArrays
        IBase.LotsOfPrimitiveArrays in = new IBase.LotsOfPrimitiveArrays();
        for (int i = 0; i < 128; ++i) {
            in.byte1[i] = (byte) i;
            in.boolean1[i] = (i & 4) != 0;
            in.double1[i] = i;
        }
        int m = 0;
        for (int i = 0; i < 8; ++i) {
            for (int j = 0; j < 128; ++j, ++m) {
                in.byte2[i][j] = (byte) m;
                in.boolean2[i][j] = (m & 4) != 0;
                in.double2[i][j] = m;
            }
        }
        m = 0;
        for (int i = 0; i < 8; ++i) {
            for (int j = 0; j < 16; ++j) {
                for (int k = 0; k < 128; ++k, ++m) {
                    in.byte3[i][j][k] = (byte) m;
                    in.boolean3[i][j][k] = (m & 4) != 0;
                    in.double3[i][j][k] = m;
                }
            }
        }
        IBase.LotsOfPrimitiveArrays out = proxy.testArrays(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testByteVecs
        ArrayList<byte[]> in = new ArrayList<byte[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            byte[] elem = new byte[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = (byte) k;
            }
            in.add(elem);
        }
        ArrayList<byte[]> out = proxy.testByteVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testBooleanVecs
        ArrayList<boolean[]> in = new ArrayList<boolean[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            boolean[] elem = new boolean[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = (k & 4) != 0;
            }
            in.add(elem);
        }
        ArrayList<boolean[]> out = proxy.testBooleanVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testDoubleVecs
        ArrayList<double[]> in = new ArrayList<double[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            double[] elem = new double[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = k;
            }
            in.add(elem);
        }
        ArrayList<double[]> out = proxy.testDoubleVecs(in);
        ExpectTrue(in.equals(out));
    }
    // --- DEATH RECIPIENT TESTING ---
    // This must always be done last, since it will kill the native server process
    HidlDeathRecipient recipient1 = new HidlDeathRecipient();
    HidlDeathRecipient recipient2 = new HidlDeathRecipient();
    final int cookie1 = 0x1481;
    final int cookie2 = 0x1482;
    ExpectTrue(proxy.linkToDeath(recipient1, cookie1));
    ExpectTrue(proxy.linkToDeath(recipient2, cookie2));
    ExpectTrue(proxy.unlinkToDeath(recipient2));
    try {
        proxy.dieNow();
    } catch (RemoteException e) {
    // Expected
    }
    ExpectTrue(recipient1.waitUntilServiceDied(2000));
    ExpectTrue(!recipient2.waitUntilServiceDied(2000));
    ExpectTrue(recipient1.cookieMatches(cookie1));
    Log.d(TAG, "OK, exiting");
}
#method_after
private void client() throws RemoteException {
    ExpectDeepEq(null, null);
    ExpectDeepNe(null, new String());
    ExpectDeepNe(new String(), null);
    ExpectDeepEq(new String(), new String());
    ExpectDeepEq("hey", "hey");
    ExpectDeepEq(new int[] { 1, 2 }, new int[] { 1, 2 });
    ExpectDeepNe(new int[] { 1, 2 }, new int[] { 1, 3 });
    ExpectDeepNe(new int[] { 1, 2 }, new int[] { 1, 2, 3 });
    ExpectDeepEq(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 4 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 5 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2, 3 }, { 4, 5, 6 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 4, 5 } });
    ExpectDeepEq(new Integer[] { 1, 2 }, new Integer[] { 1, 2 });
    ExpectDeepNe(new Integer[] { 1, 2 }, new Integer[] { 1, 3 });
    ExpectDeepNe(new Integer[] { 1, 2 }, new Integer[] { 1, 2, 3 });
    ExpectDeepEq(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 4 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 5 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2, 3 }, { 4, 5, 6 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 4, 5 } });
    ExpectDeepEq(new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(1, 2)));
    ExpectDeepNe(new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(1, 2, 3)));
    ExpectDeepEq(new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })), new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })));
    ExpectDeepNe(new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })), new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 5 })));
    ExpectDeepEq(new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })), new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })));
    ExpectDeepNe(new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })), new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 5 })));
    ExpectDeepEq(new ArrayList[] { new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(3, 4)) }, new ArrayList[] { new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(3, 4)) });
    {
        // Test proper exceptions are thrown
        try {
            IBase proxy = IBase.getService("this-doesn't-exist");
        } catch (Exception e) {
            ExpectTrue(e instanceof NoSuchElementException);
        }
    }
    {
        // Test access through base interface binder.
        IBase baseProxy = IBase.getService("baz");
        baseProxy.someBaseMethod();
        IBaz bazProxy = IBaz.castFrom(baseProxy);
        ExpectTrue(bazProxy != null);
        // IQuux is completely unrelated to IBase/IBaz, so the following
        // should fail, i.e. return null.
        IQuux quuxProxy = IQuux.castFrom(baseProxy);
        ExpectTrue(quuxProxy == null);
    }
    {
        // Test waiting API
        IBase baseProxyA = IBaz.getService("baz", true);
        ExpectTrue(baseProxyA != null);
        IBase baseProxyB = IBaz.getService("baz", false);
        ExpectTrue(baseProxyB != null);
    }
    IBaz proxy = IBaz.getService("baz");
    proxy.someBaseMethod();
    {
        Expect(proxy.interfaceDescriptor(), IBaz.kInterfaceName);
    }
    {
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        IBase.Foo result = proxy.someOtherBaseMethod(foo);
        ExpectTrue(result.equals(foo));
    }
    {
        IBase.Foo[] inputArray = new IBase.Foo[2];
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputArray[0] = foo;
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputArray[1] = foo;
        IBase.Foo[] expectedOutputArray = new IBase.Foo[2];
        expectedOutputArray[0] = inputArray[1];
        expectedOutputArray[1] = inputArray[0];
        IBase.Foo[] outputArray = proxy.someMethodWithFooArrays(inputArray);
        ExpectTrue(java.util.Objects.deepEquals(outputArray, expectedOutputArray));
    }
    {
        ArrayList<IBase.Foo> inputVec = new ArrayList<IBase.Foo>();
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputVec.add(foo);
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputVec.add(foo);
        ArrayList<IBase.Foo> expectedOutputVec = new ArrayList<IBase.Foo>();
        expectedOutputVec.add(inputVec.get(1));
        expectedOutputVec.add(inputVec.get(0));
        ArrayList<IBase.Foo> outputVec = proxy.someMethodWithFooVectors(inputVec);
        ExpectTrue(java.util.Objects.deepEquals(outputVec, expectedOutputVec));
    }
    {
        IBase.VectorOfArray in = new IBase.VectorOfArray();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.addresses.add(mac);
        }
        IBase.VectorOfArray expectedOut = new IBase.VectorOfArray();
        int n = in.addresses.size();
        for (int i = 0; i < n; ++i) {
            expectedOut.addresses.add(in.addresses.get(n - 1 - i));
        }
        IBase.VectorOfArray out = proxy.someMethodWithVectorOfArray(in);
        ExpectTrue(out.equals(expectedOut));
    }
    {
        ArrayList<byte[]> in = new ArrayList<byte[]>();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.add(mac);
        }
        ArrayList<byte[]> expectedOut = new ArrayList<byte[]>();
        int n = in.size();
        for (int i = 0; i < n; ++i) {
            expectedOut.add(in.get(n - 1 - i));
        }
        ArrayList<byte[]> out = proxy.someMethodTakingAVectorOfArray(in);
        ExpectTrue(out.size() == expectedOut.size());
        for (int i = 0; i < n; ++i) {
            ExpectTrue(java.util.Objects.deepEquals(out.get(i), expectedOut.get(i)));
        }
    }
    {
        IBase.StringMatrix5x3 in = new IBase.StringMatrix5x3();
        IBase.StringMatrix3x5 expectedOut = new IBase.StringMatrix3x5();
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in.s[i][j] = numberToEnglish(3 * i + j + 1);
                expectedOut.s[j][i] = in.s[i][j];
            }
        }
        IBase.StringMatrix3x5 out = proxy.transpose(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        ExpectTrue(out.equals(expectedOut));
    }
    {
        String[][] in = new String[5][3];
        String[][] expectedOut = new String[3][5];
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in[i][j] = numberToEnglish(3 * i + j + 1);
                expectedOut[j][i] = in[i][j];
            }
        }
        String[][] out = proxy.transpose2(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        ExpectTrue(java.util.Arrays.deepEquals(out, expectedOut));
    }
    ExpectTrue(proxy.someBoolMethod(true) == false);
    {
        boolean[] someBoolArray = new boolean[3];
        someBoolArray[0] = true;
        someBoolArray[1] = false;
        someBoolArray[2] = true;
        boolean[] resultArray = proxy.someBoolArrayMethod(someBoolArray);
        ExpectTrue(resultArray[0] == false);
        ExpectTrue(resultArray[1] == true);
        ExpectTrue(resultArray[2] == false);
        ArrayList<Boolean> someBoolVec = new ArrayList<Boolean>();
        someBoolVec.add(true);
        someBoolVec.add(false);
        someBoolVec.add(true);
        ArrayList<Boolean> resultVec = proxy.someBoolVectorMethod(someBoolVec);
        ExpectTrue(resultVec.get(0) == false);
        ExpectTrue(resultVec.get(1) == true);
        ExpectTrue(resultVec.get(2) == false);
    }
    proxy.doThis(1.0f);
    ExpectTrue(proxy.doThatAndReturnSomething(1) == 666);
    ExpectTrue(proxy.doQuiteABit(1, 2L, 3.0f, 4.0) == 666.5);
    {
        int[] paramArray = new int[15];
        int[] expectedOutArray = new int[32];
        ArrayList<Integer> paramVec = new ArrayList<Integer>();
        ArrayList<Integer> expectedOutVec = new ArrayList<Integer>();
        for (int i = 0; i < paramArray.length; ++i) {
            paramArray[i] = i;
            paramVec.add(i);
            expectedOutArray[i] = 2 * i;
            expectedOutArray[15 + i] = i;
            expectedOutVec.add(2 * i);
        }
        expectedOutArray[30] = 1;
        expectedOutArray[31] = 2;
        int[] outArray = proxy.doSomethingElse(paramArray);
        ExpectTrue(java.util.Objects.deepEquals(outArray, expectedOutArray));
        ArrayList<Integer> outVec = proxy.mapThisVector(paramVec);
        java.util.Objects.equals(outVec, expectedOutVec);
    }
    Expect(proxy.doStuffAndReturnAString(), "Hello, world!");
    BazCallback cb = new BazCallback();
    ExpectTrue(!cb.wasCalled());
    proxy.callMe(cb);
    ExpectTrue(cb.wasCalled());
    ExpectTrue(proxy.useAnEnum(IBaz.SomeEnum.goober) == -64);
    {
        String[] stringArray = new String[3];
        stringArray[0] = "one";
        stringArray[1] = "two";
        stringArray[2] = "three";
        String[] expectedOutArray = new String[2];
        expectedOutArray[0] = "Hello";
        expectedOutArray[1] = "World";
        String[] outArray = proxy.haveSomeStrings(stringArray);
        ExpectTrue(java.util.Arrays.deepEquals(outArray, expectedOutArray));
        ArrayList<String> stringVec = new ArrayList<String>();
        stringVec.add("one");
        stringVec.add("two");
        stringVec.add("three");
        ArrayList<String> expectedOutVec = new ArrayList<String>();
        expectedOutVec.add("Hello");
        expectedOutVec.add("World");
        ExpectTrue(expectedOutVec.equals(proxy.haveAStringVec(stringVec)));
    }
    proxy.returnABunchOfStrings(new IBaz.returnABunchOfStringsCallback() {

        @Override
        public void onValues(String a, String b, String c) {
            Expect(a, "Eins");
            Expect(b, "Zwei");
            Expect(c, "Drei");
        }
    });
    proxy.returnABunchOfStrings((a, b, c) -> Expect(a + b + c, "EinsZweiDrei"));
    proxy.callMeLater(new BazCallback());
    System.gc();
    proxy.iAmFreeNow();
    {
        IBaz.T t1 = new IBaz.T();
        IBaz.T t2 = new IBaz.T();
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 3; j++) {
                t1.matrix5x3[i][j] = t2.matrix5x3[i][j] = (i + 1) * (j + 1);
            }
        }
        ExpectTrue(t1.equals(t2));
        ExpectTrue(t1.hashCode() == t2.hashCode());
        t2.matrix5x3[4][2] = -60;
        ExpectTrue(!t1.equals(t2));
    }
    ArrayList<NestedStruct> structs = proxy.getNestedStructs();
    ExpectTrue(structs.size() == 5);
    ExpectTrue(structs.get(1).matrices.size() == 6);
    {
        IBaz.Everything e = new IBaz.Everything();
        Expect(e.toString(), "{.number = 0, .anotherNumber = 0, .s = , " + ".vs = [], .multidimArray = [[null, null], [null, null]], " + ".sArray = [null, null, null], .anotherStruct = {.first = , .last = }, .bf = }");
        e.s = "string!";
        e.number = 127;
        e.anotherNumber = 100;
        e.vs.addAll(Arrays.asList("One", "Two", "Three"));
        for (int i = 0; i < e.multidimArray.length; i++) for (int j = 0; j < e.multidimArray[i].length; j++) e.multidimArray[i][j] = Integer.toString(i) + Integer.toString(j);
        e.bf = IBaz.BitField.VALL;
        e.anotherStruct.first = "James";
        e.anotherStruct.last = "Bond";
        Expect(e.toString(), "{.number = 127, .anotherNumber = 100, .s = string!, " + ".vs = [One, Two, Three], .multidimArray = [[00, 01], [10, 11]], " + ".sArray = [null, null, null], .anotherStruct = {.first = James, .last = Bond}, " + ".bf = V0 | V1 | V2 | V3 | VALL}");
        Expect(IBaz.BitField.toString(IBaz.BitField.VALL), "VALL");
        Expect(IBaz.BitField.toString((byte) (IBaz.BitField.V0 | IBaz.BitField.V2)), "0x5");
        Expect(IBaz.BitField.dumpBitfield(IBaz.BitField.VALL), "V0 | V1 | V2 | V3 | VALL");
        Expect(IBaz.BitField.dumpBitfield((byte) (IBaz.BitField.V1 | IBaz.BitField.V3 | 0xF0)), "V1 | V3 | 0xf0");
        Expect(proxy.toString(), IBaz.kInterfaceName + "@Proxy");
    }
    {
        // Ensure that native parcel is cleared even if the corresponding
        // Java object isn't GC'd.
        ArrayList<Integer> data4K = new ArrayList<>(1024);
        for (int i = 0; i < 1024; i++) {
            data4K.add(i);
        }
        for (int i = 0; i < 1024; i++) {
            // kernel binder buffer, and will fail.
            try {
                proxy.mapThisVector(data4K);
            } catch (RemoteException ex) {
                throw new RuntimeException("Failed at call #" + Integer.toString(i), ex);
            }
        }
    }
    {
        // TestArrays
        IBase.LotsOfPrimitiveArrays in = new IBase.LotsOfPrimitiveArrays();
        for (int i = 0; i < 128; ++i) {
            in.byte1[i] = (byte) i;
            in.boolean1[i] = (i & 4) != 0;
            in.double1[i] = i;
        }
        int m = 0;
        for (int i = 0; i < 8; ++i) {
            for (int j = 0; j < 128; ++j, ++m) {
                in.byte2[i][j] = (byte) m;
                in.boolean2[i][j] = (m & 4) != 0;
                in.double2[i][j] = m;
            }
        }
        m = 0;
        for (int i = 0; i < 8; ++i) {
            for (int j = 0; j < 16; ++j) {
                for (int k = 0; k < 128; ++k, ++m) {
                    in.byte3[i][j][k] = (byte) m;
                    in.boolean3[i][j][k] = (m & 4) != 0;
                    in.double3[i][j][k] = m;
                }
            }
        }
        IBase.LotsOfPrimitiveArrays out = proxy.testArrays(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testByteVecs
        ArrayList<byte[]> in = new ArrayList<byte[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            byte[] elem = new byte[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = (byte) k;
            }
            in.add(elem);
        }
        ArrayList<byte[]> out = proxy.testByteVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testBooleanVecs
        ArrayList<boolean[]> in = new ArrayList<boolean[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            boolean[] elem = new boolean[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = (k & 4) != 0;
            }
            in.add(elem);
        }
        ArrayList<boolean[]> out = proxy.testBooleanVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testDoubleVecs
        ArrayList<double[]> in = new ArrayList<double[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            double[] elem = new double[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = k;
            }
            in.add(elem);
        }
        ArrayList<double[]> out = proxy.testDoubleVecs(in);
        ExpectTrue(in.equals(out));
    }
    // --- DEATH RECIPIENT TESTING ---
    // This must always be done last, since it will kill the native server process
    HidlDeathRecipient recipient1 = new HidlDeathRecipient();
    HidlDeathRecipient recipient2 = new HidlDeathRecipient();
    final int cookie1 = 0x1481;
    final int cookie2 = 0x1482;
    ExpectTrue(proxy.linkToDeath(recipient1, cookie1));
    ExpectTrue(proxy.linkToDeath(recipient2, cookie2));
    ExpectTrue(proxy.unlinkToDeath(recipient2));
    try {
        proxy.dieNow();
    } catch (RemoteException e) {
    // Expected
    }
    ExpectTrue(recipient1.waitUntilServiceDied(2000));
    ExpectTrue(!recipient2.waitUntilServiceDied(2000));
    ExpectTrue(recipient1.cookieMatches(cookie1));
    Log.d(TAG, "OK, exiting");
}
#end_block

#method_before
private void sign(DataSource inputApk, DataSink outputApkOut, DataSource outputApkIn) throws IOException, ApkFormatException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
    // Step 1. Find input APK's main ZIP sections
    ApkUtils.ZipSections inputZipSections;
    try {
        inputZipSections = ApkUtils.findZipSections(inputApk);
    } catch (ZipFormatException e) {
        throw new ApkFormatException("Malformed APK: not a ZIP archive", e);
    }
    long inputApkSigningBlockOffset = -1;
    DataSource inputApkSigningBlock = null;
    try {
        Pair<DataSource, Long> apkSigningBlockAndOffset = V2SchemeVerifier.findApkSigningBlock(inputApk, inputZipSections);
        inputApkSigningBlock = apkSigningBlockAndOffset.getFirst();
        inputApkSigningBlockOffset = apkSigningBlockAndOffset.getSecond();
    } catch (V2SchemeVerifier.SignatureNotFoundException e) {
    // Input APK does not contain an APK Signing Block. That's OK. APKs are not required to
    // contain this block. It's only needed if the APK is signed using APK Signature Scheme
    // v2.
    }
    DataSource inputApkLfhSection = inputApk.slice(0, (inputApkSigningBlockOffset != -1) ? inputApkSigningBlockOffset : inputZipSections.getZipCentralDirectoryOffset());
    // Step 2. Parse the input APK's ZIP Central Directory
    ByteBuffer inputCd = getZipCentralDirectory(inputApk, inputZipSections);
    List<CentralDirectoryRecord> inputCdRecords = parseZipCentralDirectory(inputCd, inputZipSections);
    // Step 3. Obtain a signer engine instance
    ApkSignerEngine signerEngine;
    if (mSignerEngine != null) {
        // Use the provided signer engine
        signerEngine = mSignerEngine;
    } else {
        // Construct a signer engine from the provided parameters
        int minSdkVersion;
        if (mMinSdkVersion != null) {
            // No need to extract minSdkVersion from the APK's AndroidManifest.xml
            minSdkVersion = mMinSdkVersion;
        } else {
            // Need to extract minSdkVersion from the APK's AndroidManifest.xml
            minSdkVersion = getMinSdkVersionFromApk(inputCdRecords, inputApkLfhSection);
        }
        List<DefaultApkSignerEngine.SignerConfig> engineSignerConfigs = new ArrayList<>(mSignerConfigs.size());
        for (SignerConfig signerConfig : mSignerConfigs) {
            engineSignerConfigs.add(new DefaultApkSignerEngine.SignerConfig.Builder(signerConfig.getName(), signerConfig.getPrivateKey(), signerConfig.getCertificates()).build());
        }
        DefaultApkSignerEngine.Builder signerEngineBuilder = new DefaultApkSignerEngine.Builder(engineSignerConfigs, minSdkVersion).setV1SigningEnabled(mV1SigningEnabled).setV2SigningEnabled(mV2SigningEnabled).setOtherSignersSignaturesPreserved(mOtherSignersSignaturesPreserved);
        if (mCreatedBy != null) {
            signerEngineBuilder.setCreatedBy(mCreatedBy);
        }
        signerEngine = signerEngineBuilder.build();
    }
    // Step 4. Provide the signer engine with the input APK's APK Signing Block (if any)
    if (inputApkSigningBlock != null) {
        signerEngine.inputApkSigningBlock(inputApkSigningBlock);
    }
    // Step 5. Iterate over input APK's entries and output the Local File Header + data of those
    // entries which need to be output. Entries are iterated in the order in which their Local
    // File Header records are stored in the file. This is to achieve better data locality in
    // case Central Directory entries are in the wrong order.
    List<CentralDirectoryRecord> inputCdRecordsSortedByLfhOffset = new ArrayList<>(inputCdRecords);
    Collections.sort(inputCdRecordsSortedByLfhOffset, CentralDirectoryRecord.BY_LOCAL_FILE_HEADER_OFFSET_COMPARATOR);
    int lastModifiedDateForNewEntries = -1;
    int lastModifiedTimeForNewEntries = -1;
    long inputOffset = 0;
    long outputOffset = 0;
    Map<String, CentralDirectoryRecord> outputCdRecordsByName = new HashMap<>(inputCdRecords.size());
    for (final CentralDirectoryRecord inputCdRecord : inputCdRecordsSortedByLfhOffset) {
        String entryName = inputCdRecord.getName();
        ApkSignerEngine.InputJarEntryInstructions entryInstructions = signerEngine.inputJarEntry(entryName);
        boolean shouldOutput;
        switch(entryInstructions.getOutputPolicy()) {
            case OUTPUT:
                shouldOutput = true;
                break;
            case OUTPUT_BY_ENGINE:
            case SKIP:
                shouldOutput = false;
                break;
            default:
                throw new RuntimeException("Unknown output policy: " + entryInstructions.getOutputPolicy());
        }
        long inputLocalFileHeaderStartOffset = inputCdRecord.getLocalFileHeaderOffset();
        if (inputLocalFileHeaderStartOffset > inputOffset) {
            // Unprocessed data in input starting at inputOffset and ending and the start of
            // this record's LFH. We output this data verbatim because this signer is supposed
            // to preserve as much of input as possible.
            long chunkSize = inputLocalFileHeaderStartOffset - inputOffset;
            inputApkLfhSection.feed(inputOffset, chunkSize, outputApkOut);
            outputOffset += chunkSize;
            inputOffset = inputLocalFileHeaderStartOffset;
        }
        LocalFileRecord inputLocalFileRecord;
        try {
            inputLocalFileRecord = LocalFileRecord.getRecord(inputApkLfhSection, inputCdRecord, inputApkLfhSection.size());
        } catch (ZipFormatException e) {
            throw new ApkFormatException("Malformed ZIP entry: " + inputCdRecord.getName(), e);
        }
        inputOffset += inputLocalFileRecord.getSize();
        ApkSignerEngine.InspectJarEntryRequest inspectEntryRequest = entryInstructions.getInspectJarEntryRequest();
        if (inspectEntryRequest != null) {
            fulfillInspectInputJarEntryRequest(inputApkLfhSection, inputLocalFileRecord, inspectEntryRequest);
        }
        if (shouldOutput) {
            // Find the max value of last modified, to be used for new entries added by the
            // signer.
            int lastModifiedDate = inputCdRecord.getLastModificationDate();
            int lastModifiedTime = inputCdRecord.getLastModificationTime();
            if ((lastModifiedDateForNewEntries == -1) || (lastModifiedDate > lastModifiedDateForNewEntries) || ((lastModifiedDate == lastModifiedDateForNewEntries) && (lastModifiedTime > lastModifiedTimeForNewEntries))) {
                lastModifiedDateForNewEntries = lastModifiedDate;
                lastModifiedTimeForNewEntries = lastModifiedTime;
            }
            inspectEntryRequest = signerEngine.outputJarEntry(entryName);
            if (inspectEntryRequest != null) {
                fulfillInspectInputJarEntryRequest(inputApkLfhSection, inputLocalFileRecord, inspectEntryRequest);
            }
            // Output entry's Local File Header + data
            long outputLocalFileHeaderOffset = outputOffset;
            long outputLocalFileRecordSize = outputInputJarEntryLfhRecordPreservingDataAlignment(inputApkLfhSection, inputLocalFileRecord, outputApkOut, outputLocalFileHeaderOffset);
            outputOffset += outputLocalFileRecordSize;
            // Enqueue entry's Central Directory record for output
            CentralDirectoryRecord outputCdRecord;
            if (outputLocalFileHeaderOffset == inputLocalFileRecord.getStartOffsetInArchive()) {
                outputCdRecord = inputCdRecord;
            } else {
                outputCdRecord = inputCdRecord.createWithModifiedLocalFileHeaderOffset(outputLocalFileHeaderOffset);
            }
            outputCdRecordsByName.put(entryName, outputCdRecord);
        }
    }
    long inputLfhSectionSize = inputApkLfhSection.size();
    if (inputOffset < inputLfhSectionSize) {
        // Unprocessed data in input starting at inputOffset and ending and the end of the input
        // APK's LFH section. We output this data verbatim because this signer is supposed
        // to preserve as much of input as possible.
        long chunkSize = inputLfhSectionSize - inputOffset;
        inputApkLfhSection.feed(inputOffset, chunkSize, outputApkOut);
        outputOffset += chunkSize;
        inputOffset = inputLfhSectionSize;
    }
    // Step 6. Sort output APK's Central Directory records in the order in which they should
    // appear in the output
    List<CentralDirectoryRecord> outputCdRecords = new ArrayList<>(inputCdRecords.size() + 10);
    for (CentralDirectoryRecord inputCdRecord : inputCdRecords) {
        String entryName = inputCdRecord.getName();
        CentralDirectoryRecord outputCdRecord = outputCdRecordsByName.get(entryName);
        if (outputCdRecord != null) {
            outputCdRecords.add(outputCdRecord);
        }
    }
    // Step 7. Generate and output JAR signatures, if necessary. This may output more Local File
    // Header + data entries and add to the list of output Central Directory records.
    ApkSignerEngine.OutputJarSignatureRequest outputJarSignatureRequest = signerEngine.outputJarEntries();
    if (outputJarSignatureRequest != null) {
        if (lastModifiedDateForNewEntries == -1) {
            // Jan 1 2009 (DOS)
            lastModifiedDateForNewEntries = 0x3a21;
            lastModifiedTimeForNewEntries = 0;
        }
        for (ApkSignerEngine.OutputJarSignatureRequest.JarEntry entry : outputJarSignatureRequest.getAdditionalJarEntries()) {
            String entryName = entry.getName();
            byte[] uncompressedData = entry.getData();
            ZipUtils.DeflateResult deflateResult = ZipUtils.deflate(ByteBuffer.wrap(uncompressedData));
            byte[] compressedData = deflateResult.output;
            long uncompressedDataCrc32 = deflateResult.inputCrc32;
            ApkSignerEngine.InspectJarEntryRequest inspectEntryRequest = signerEngine.outputJarEntry(entryName);
            if (inspectEntryRequest != null) {
                inspectEntryRequest.getDataSink().consume(uncompressedData, 0, uncompressedData.length);
                inspectEntryRequest.done();
            }
            long localFileHeaderOffset = outputOffset;
            outputOffset += LocalFileRecord.outputRecordWithDeflateCompressedData(entryName, lastModifiedTimeForNewEntries, lastModifiedDateForNewEntries, compressedData, uncompressedDataCrc32, uncompressedData.length, outputApkOut);
            outputCdRecords.add(CentralDirectoryRecord.createWithDeflateCompressedData(entryName, lastModifiedTimeForNewEntries, lastModifiedDateForNewEntries, uncompressedDataCrc32, compressedData.length, uncompressedData.length, localFileHeaderOffset));
        }
        outputJarSignatureRequest.done();
    }
    // Step 8. Construct output ZIP Central Directory in an in-memory buffer
    long outputCentralDirSizeBytes = 0;
    for (CentralDirectoryRecord record : outputCdRecords) {
        outputCentralDirSizeBytes += record.getSize();
    }
    if (outputCentralDirSizeBytes > Integer.MAX_VALUE) {
        throw new IOException("Output ZIP Central Directory too large: " + outputCentralDirSizeBytes + " bytes");
    }
    ByteBuffer outputCentralDir = ByteBuffer.allocate((int) outputCentralDirSizeBytes);
    for (CentralDirectoryRecord record : outputCdRecords) {
        record.copyTo(outputCentralDir);
    }
    outputCentralDir.flip();
    DataSource outputCentralDirDataSource = new ByteBufferDataSource(outputCentralDir);
    long outputCentralDirStartOffset = outputOffset;
    int outputCentralDirRecordCount = outputCdRecords.size();
    // Step 9. Construct output ZIP End of Central Directory record in an in-memory buffer
    ByteBuffer outputEocd = EocdRecord.createWithModifiedCentralDirectoryInfo(inputZipSections.getZipEndOfCentralDirectory(), outputCentralDirRecordCount, outputCentralDirDataSource.size(), outputCentralDirStartOffset);
    // Step 10. Generate and output APK Signature Scheme v2 signatures, if necessary. This may
    // insert an APK Signing Block just before the output's ZIP Central Directory
    Pair<ApkSignerEngine.OutputApkSigningBlockRequest, Integer> request = signerEngine.outputZipSections2(outputApkIn, outputCentralDirDataSource, DataSources.asDataSource(outputEocd));
    ApkSignerEngine.OutputApkSigningBlockRequest outputApkSigingBlockRequest = request.getFirst();
    if (outputApkSigingBlockRequest != null) {
        int padding = request.getSecond();
        outputApkOut.consume(ByteBuffer.allocate(padding));
        byte[] outputApkSigningBlock = outputApkSigingBlockRequest.getApkSigningBlock();
        outputApkOut.consume(outputApkSigningBlock, 0, outputApkSigningBlock.length);
        ZipUtils.setZipEocdCentralDirectoryOffset(outputEocd, outputCentralDirStartOffset + padding + outputApkSigningBlock.length);
        outputApkSigingBlockRequest.done();
    }
    // Step 11. Output ZIP Central Directory and ZIP End of Central Directory
    outputCentralDirDataSource.feed(0, outputCentralDirDataSource.size(), outputApkOut);
    outputApkOut.consume(outputEocd);
    signerEngine.outputDone();
}
#method_after
private void sign(DataSource inputApk, DataSink outputApkOut, DataSource outputApkIn) throws IOException, ApkFormatException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
    // Step 1. Find input APK's main ZIP sections
    ApkUtils.ZipSections inputZipSections;
    try {
        inputZipSections = ApkUtils.findZipSections(inputApk);
    } catch (ZipFormatException e) {
        throw new ApkFormatException("Malformed APK: not a ZIP archive", e);
    }
    long inputApkSigningBlockOffset = -1;
    DataSource inputApkSigningBlock = null;
    try {
        Pair<DataSource, Long> apkSigningBlockAndOffset = V2SchemeVerifier.findApkSigningBlock(inputApk, inputZipSections);
        inputApkSigningBlock = apkSigningBlockAndOffset.getFirst();
        inputApkSigningBlockOffset = apkSigningBlockAndOffset.getSecond();
    } catch (V2SchemeVerifier.SignatureNotFoundException e) {
    // Input APK does not contain an APK Signing Block. That's OK. APKs are not required to
    // contain this block. It's only needed if the APK is signed using APK Signature Scheme
    // v2.
    }
    DataSource inputApkLfhSection = inputApk.slice(0, (inputApkSigningBlockOffset != -1) ? inputApkSigningBlockOffset : inputZipSections.getZipCentralDirectoryOffset());
    // Step 2. Parse the input APK's ZIP Central Directory
    ByteBuffer inputCd = getZipCentralDirectory(inputApk, inputZipSections);
    List<CentralDirectoryRecord> inputCdRecords = parseZipCentralDirectory(inputCd, inputZipSections);
    // Step 3. Obtain a signer engine instance
    ApkSignerEngine signerEngine;
    if (mSignerEngine != null) {
        // Use the provided signer engine
        signerEngine = mSignerEngine;
    } else {
        // Construct a signer engine from the provided parameters
        int minSdkVersion;
        if (mMinSdkVersion != null) {
            // No need to extract minSdkVersion from the APK's AndroidManifest.xml
            minSdkVersion = mMinSdkVersion;
        } else {
            // Need to extract minSdkVersion from the APK's AndroidManifest.xml
            minSdkVersion = getMinSdkVersionFromApk(inputCdRecords, inputApkLfhSection);
        }
        List<DefaultApkSignerEngine.SignerConfig> engineSignerConfigs = new ArrayList<>(mSignerConfigs.size());
        for (SignerConfig signerConfig : mSignerConfigs) {
            engineSignerConfigs.add(new DefaultApkSignerEngine.SignerConfig.Builder(signerConfig.getName(), signerConfig.getPrivateKey(), signerConfig.getCertificates()).build());
        }
        DefaultApkSignerEngine.Builder signerEngineBuilder = new DefaultApkSignerEngine.Builder(engineSignerConfigs, minSdkVersion).setV1SigningEnabled(mV1SigningEnabled).setV2SigningEnabled(mV2SigningEnabled).setOtherSignersSignaturesPreserved(mOtherSignersSignaturesPreserved);
        if (mCreatedBy != null) {
            signerEngineBuilder.setCreatedBy(mCreatedBy);
        }
        signerEngine = signerEngineBuilder.build();
    }
    // Step 4. Provide the signer engine with the input APK's APK Signing Block (if any)
    if (inputApkSigningBlock != null) {
        signerEngine.inputApkSigningBlock(inputApkSigningBlock);
    }
    // Step 5. Iterate over input APK's entries and output the Local File Header + data of those
    // entries which need to be output. Entries are iterated in the order in which their Local
    // File Header records are stored in the file. This is to achieve better data locality in
    // case Central Directory entries are in the wrong order.
    List<CentralDirectoryRecord> inputCdRecordsSortedByLfhOffset = new ArrayList<>(inputCdRecords);
    Collections.sort(inputCdRecordsSortedByLfhOffset, CentralDirectoryRecord.BY_LOCAL_FILE_HEADER_OFFSET_COMPARATOR);
    int lastModifiedDateForNewEntries = -1;
    int lastModifiedTimeForNewEntries = -1;
    long inputOffset = 0;
    long outputOffset = 0;
    Map<String, CentralDirectoryRecord> outputCdRecordsByName = new HashMap<>(inputCdRecords.size());
    for (final CentralDirectoryRecord inputCdRecord : inputCdRecordsSortedByLfhOffset) {
        String entryName = inputCdRecord.getName();
        ApkSignerEngine.InputJarEntryInstructions entryInstructions = signerEngine.inputJarEntry(entryName);
        boolean shouldOutput;
        switch(entryInstructions.getOutputPolicy()) {
            case OUTPUT:
                shouldOutput = true;
                break;
            case OUTPUT_BY_ENGINE:
            case SKIP:
                shouldOutput = false;
                break;
            default:
                throw new RuntimeException("Unknown output policy: " + entryInstructions.getOutputPolicy());
        }
        long inputLocalFileHeaderStartOffset = inputCdRecord.getLocalFileHeaderOffset();
        if (inputLocalFileHeaderStartOffset > inputOffset) {
            // Unprocessed data in input starting at inputOffset and ending and the start of
            // this record's LFH. We output this data verbatim because this signer is supposed
            // to preserve as much of input as possible.
            long chunkSize = inputLocalFileHeaderStartOffset - inputOffset;
            inputApkLfhSection.feed(inputOffset, chunkSize, outputApkOut);
            outputOffset += chunkSize;
            inputOffset = inputLocalFileHeaderStartOffset;
        }
        LocalFileRecord inputLocalFileRecord;
        try {
            inputLocalFileRecord = LocalFileRecord.getRecord(inputApkLfhSection, inputCdRecord, inputApkLfhSection.size());
        } catch (ZipFormatException e) {
            throw new ApkFormatException("Malformed ZIP entry: " + inputCdRecord.getName(), e);
        }
        inputOffset += inputLocalFileRecord.getSize();
        ApkSignerEngine.InspectJarEntryRequest inspectEntryRequest = entryInstructions.getInspectJarEntryRequest();
        if (inspectEntryRequest != null) {
            fulfillInspectInputJarEntryRequest(inputApkLfhSection, inputLocalFileRecord, inspectEntryRequest);
        }
        if (shouldOutput) {
            // Find the max value of last modified, to be used for new entries added by the
            // signer.
            int lastModifiedDate = inputCdRecord.getLastModificationDate();
            int lastModifiedTime = inputCdRecord.getLastModificationTime();
            if ((lastModifiedDateForNewEntries == -1) || (lastModifiedDate > lastModifiedDateForNewEntries) || ((lastModifiedDate == lastModifiedDateForNewEntries) && (lastModifiedTime > lastModifiedTimeForNewEntries))) {
                lastModifiedDateForNewEntries = lastModifiedDate;
                lastModifiedTimeForNewEntries = lastModifiedTime;
            }
            inspectEntryRequest = signerEngine.outputJarEntry(entryName);
            if (inspectEntryRequest != null) {
                fulfillInspectInputJarEntryRequest(inputApkLfhSection, inputLocalFileRecord, inspectEntryRequest);
            }
            // Output entry's Local File Header + data
            long outputLocalFileHeaderOffset = outputOffset;
            long outputLocalFileRecordSize = outputInputJarEntryLfhRecordPreservingDataAlignment(inputApkLfhSection, inputLocalFileRecord, outputApkOut, outputLocalFileHeaderOffset);
            outputOffset += outputLocalFileRecordSize;
            // Enqueue entry's Central Directory record for output
            CentralDirectoryRecord outputCdRecord;
            if (outputLocalFileHeaderOffset == inputLocalFileRecord.getStartOffsetInArchive()) {
                outputCdRecord = inputCdRecord;
            } else {
                outputCdRecord = inputCdRecord.createWithModifiedLocalFileHeaderOffset(outputLocalFileHeaderOffset);
            }
            outputCdRecordsByName.put(entryName, outputCdRecord);
        }
    }
    long inputLfhSectionSize = inputApkLfhSection.size();
    if (inputOffset < inputLfhSectionSize) {
        // Unprocessed data in input starting at inputOffset and ending and the end of the input
        // APK's LFH section. We output this data verbatim because this signer is supposed
        // to preserve as much of input as possible.
        long chunkSize = inputLfhSectionSize - inputOffset;
        inputApkLfhSection.feed(inputOffset, chunkSize, outputApkOut);
        outputOffset += chunkSize;
        inputOffset = inputLfhSectionSize;
    }
    // Step 6. Sort output APK's Central Directory records in the order in which they should
    // appear in the output
    List<CentralDirectoryRecord> outputCdRecords = new ArrayList<>(inputCdRecords.size() + 10);
    for (CentralDirectoryRecord inputCdRecord : inputCdRecords) {
        String entryName = inputCdRecord.getName();
        CentralDirectoryRecord outputCdRecord = outputCdRecordsByName.get(entryName);
        if (outputCdRecord != null) {
            outputCdRecords.add(outputCdRecord);
        }
    }
    // Step 7. Generate and output JAR signatures, if necessary. This may output more Local File
    // Header + data entries and add to the list of output Central Directory records.
    ApkSignerEngine.OutputJarSignatureRequest outputJarSignatureRequest = signerEngine.outputJarEntries();
    if (outputJarSignatureRequest != null) {
        if (lastModifiedDateForNewEntries == -1) {
            // Jan 1 2009 (DOS)
            lastModifiedDateForNewEntries = 0x3a21;
            lastModifiedTimeForNewEntries = 0;
        }
        for (ApkSignerEngine.OutputJarSignatureRequest.JarEntry entry : outputJarSignatureRequest.getAdditionalJarEntries()) {
            String entryName = entry.getName();
            byte[] uncompressedData = entry.getData();
            ZipUtils.DeflateResult deflateResult = ZipUtils.deflate(ByteBuffer.wrap(uncompressedData));
            byte[] compressedData = deflateResult.output;
            long uncompressedDataCrc32 = deflateResult.inputCrc32;
            ApkSignerEngine.InspectJarEntryRequest inspectEntryRequest = signerEngine.outputJarEntry(entryName);
            if (inspectEntryRequest != null) {
                inspectEntryRequest.getDataSink().consume(uncompressedData, 0, uncompressedData.length);
                inspectEntryRequest.done();
            }
            long localFileHeaderOffset = outputOffset;
            outputOffset += LocalFileRecord.outputRecordWithDeflateCompressedData(entryName, lastModifiedTimeForNewEntries, lastModifiedDateForNewEntries, compressedData, uncompressedDataCrc32, uncompressedData.length, outputApkOut);
            outputCdRecords.add(CentralDirectoryRecord.createWithDeflateCompressedData(entryName, lastModifiedTimeForNewEntries, lastModifiedDateForNewEntries, uncompressedDataCrc32, compressedData.length, uncompressedData.length, localFileHeaderOffset));
        }
        outputJarSignatureRequest.done();
    }
    // Step 8. Construct output ZIP Central Directory in an in-memory buffer
    long outputCentralDirSizeBytes = 0;
    for (CentralDirectoryRecord record : outputCdRecords) {
        outputCentralDirSizeBytes += record.getSize();
    }
    if (outputCentralDirSizeBytes > Integer.MAX_VALUE) {
        throw new IOException("Output ZIP Central Directory too large: " + outputCentralDirSizeBytes + " bytes");
    }
    ByteBuffer outputCentralDir = ByteBuffer.allocate((int) outputCentralDirSizeBytes);
    for (CentralDirectoryRecord record : outputCdRecords) {
        record.copyTo(outputCentralDir);
    }
    outputCentralDir.flip();
    DataSource outputCentralDirDataSource = new ByteBufferDataSource(outputCentralDir);
    long outputCentralDirStartOffset = outputOffset;
    int outputCentralDirRecordCount = outputCdRecords.size();
    // Step 9. Construct output ZIP End of Central Directory record in an in-memory buffer
    ByteBuffer outputEocd = EocdRecord.createWithModifiedCentralDirectoryInfo(inputZipSections.getZipEndOfCentralDirectory(), outputCentralDirRecordCount, outputCentralDirDataSource.size(), outputCentralDirStartOffset);
    // Step 10. Generate and output APK Signature Scheme v2 signatures, if necessary. This may
    // insert an APK Signing Block just before the output's ZIP Central Directory
    ApkSignerEngine.OutputApkSigningBlockRequest2 outputApkSigningBlockRequest = signerEngine.outputZipSections2(outputApkIn, outputCentralDirDataSource, DataSources.asDataSource(outputEocd));
    if (outputApkSigningBlockRequest != null) {
        int padding = outputApkSigningBlockRequest.getPaddingSizeBeforeApkSigningBlock();
        outputApkOut.consume(ByteBuffer.allocate(padding));
        byte[] outputApkSigningBlock = outputApkSigningBlockRequest.getApkSigningBlock();
        outputApkOut.consume(outputApkSigningBlock, 0, outputApkSigningBlock.length);
        ZipUtils.setZipEocdCentralDirectoryOffset(outputEocd, outputCentralDirStartOffset + padding + outputApkSigningBlock.length);
        outputApkSigningBlockRequest.done();
    }
    // Step 11. Output ZIP Central Directory and ZIP End of Central Directory
    outputCentralDirDataSource.feed(0, outputCentralDirDataSource.size(), outputApkOut);
    outputApkOut.consume(outputEocd);
    signerEngine.outputDone();
}
#end_block

#method_before
public ApkSigner build() {
    return new ApkSigner(mSignerConfigs, mMinSdkVersion, mV1SigningEnabled, mV2SigningEnabled, mOtherSignersSignaturesPreserved, mCreatedBy, mSignerEngine, mInputApkFile, mInputApkDataSource, mOutputApkFile, mOutputApkDataSink, mOutputApkDataSource);
}
#method_after
public SignerConfig build() {
    return new SignerConfig(mName, mPrivateKey, mCertificates);
}
#end_block

#method_before
@Override
public OutputApkSigningBlockRequest outputZipSections(DataSource zipEntries, DataSource zipCentralDirectory, DataSource zipEocd) throws IOException, InvalidKeyException, SignatureException, NoSuchAlgorithmException {
    checkNotClosed();
    checkV1SigningDoneIfEnabled();
    if (!mV2SigningEnabled) {
        return null;
    }
    invalidateV2Signature();
    byte[] apkSigningBlock = V2SchemeSigner.generateApkSigningBlock(zipEntries, zipCentralDirectory, zipEocd, mV2SignerConfigs);
    mAddV2SignatureRequest = new OutputApkSigningBlockRequestImpl(apkSigningBlock);
    return mAddV2SignatureRequest;
}
#method_after
@Override
public OutputApkSigningBlockRequest outputZipSections(DataSource zipEntries, DataSource zipCentralDirectory, DataSource zipEocd) throws IOException, InvalidKeyException, SignatureException, NoSuchAlgorithmException {
    return outputZipSectionsInternal(zipEntries, zipCentralDirectory, zipEocd, false);
}
#end_block

#method_before
@Override
public Pair<OutputApkSigningBlockRequest, Integer> outputZipSections2(DataSource zipEntries, DataSource zipCentralDirectory, DataSource zipEocd) throws IOException, InvalidKeyException, SignatureException, NoSuchAlgorithmException {
    // Extra padding to ensure APK Signing Block will start from page boundary.
    int padSizeBeforeCentralDir = 0;
    if (zipEntries.size() % ANDROID_COMMON_PAGE_ALIGNMENT_BYTES != 0) {
        padSizeBeforeCentralDir = (int) (ANDROID_COMMON_PAGE_ALIGNMENT_BYTES - zipEntries.size() % ANDROID_COMMON_PAGE_ALIGNMENT_BYTES);
    }
    return Pair.of(outputZipSections(zipEntries, zipCentralDirectory, zipEocd), padSizeBeforeCentralDir);
}
#method_after
@Override
public OutputApkSigningBlockRequest2 outputZipSections2(DataSource zipEntries, DataSource zipCentralDirectory, DataSource zipEocd) throws IOException, InvalidKeyException, SignatureException, NoSuchAlgorithmException {
    return outputZipSectionsInternal(zipEntries, zipCentralDirectory, zipEocd, true);
}
#end_block

#method_before
public DefaultApkSignerEngine build() throws InvalidKeyException {
    return new DefaultApkSignerEngine(mSignerConfigs, mMinSdkVersion, mV1SigningEnabled, mV2SigningEnabled, mOtherSignersSignaturesPreserved, mCreatedBy);
}
#method_after
public SignerConfig build() {
    return new SignerConfig(mName, mPrivateKey, mCertificates);
}
#end_block

#method_before
private static byte[] generateApkSigningBlock(byte[] apkSignatureSchemeV2Block) {
    // FORMAT:
    // uint64:  size (excluding this field)
    // repeated ID-value pairs:
    // uint64:           size (excluding this field)
    // uint32:           ID
    // (size - 4) bytes: value
    // (extra dummy ID-value for padding to make block size a multiple of 4096 bytes)
    // uint64:  size (same as the one above)
    // uint128: magic
    int resultSize = // size
    8 + 8 + 4 + // v2Block as ID-value pair
    apkSignatureSchemeV2Block.length + // size
    8 + // magic
    16;
    ByteBuffer paddingPair = null;
    if (resultSize % ANDROID_COMMON_PAGE_ALIGNMENT_BYTES != 0) {
        int padding = ANDROID_COMMON_PAGE_ALIGNMENT_BYTES - (resultSize % ANDROID_COMMON_PAGE_ALIGNMENT_BYTES);
        if (padding < 12) {
            // minimum size of an ID-value pair
            padding += ANDROID_COMMON_PAGE_ALIGNMENT_BYTES;
        }
        paddingPair = ByteBuffer.allocate(padding).order(ByteOrder.LITTLE_ENDIAN);
        paddingPair.putLong(padding - 8);
        paddingPair.putInt(VERITY_PADDING_BLOCK_ID);
        paddingPair.rewind();
        resultSize += padding;
    }
    ByteBuffer result = ByteBuffer.allocate(resultSize);
    result.order(ByteOrder.LITTLE_ENDIAN);
    long blockSizeFieldValue = resultSize - 8;
    result.putLong(blockSizeFieldValue);
    long pairSizeFieldValue = 4 + apkSignatureSchemeV2Block.length;
    result.putLong(pairSizeFieldValue);
    result.putInt(APK_SIGNATURE_SCHEME_V2_BLOCK_ID);
    result.put(apkSignatureSchemeV2Block);
    if (paddingPair != null) {
        result.put(paddingPair);
    }
    result.putLong(blockSizeFieldValue);
    result.put(APK_SIGNING_BLOCK_MAGIC);
    return result.array();
}
#method_after
public static Pair<byte[], Integer> generateApkSigningBlock(DataSource beforeCentralDir, DataSource centralDir, DataSource eocd, List<SignerConfig> signerConfigs, boolean apkSigningBlockPaddingSupported) throws IOException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
    if (signerConfigs.isEmpty()) {
        throw new IllegalArgumentException("No signer configs provided. At least one is required");
    }
    // Figure out which digest(s) to use for APK contents.
    Set<ContentDigestAlgorithm> contentDigestAlgorithms = new HashSet<>(1);
    for (SignerConfig signerConfig : signerConfigs) {
        for (SignatureAlgorithm signatureAlgorithm : signerConfig.signatureAlgorithms) {
            contentDigestAlgorithms.add(signatureAlgorithm.getContentDigestAlgorithm());
        }
    }
    // Ensure APK Signing Block starts from page boundary.
    int padSizeBeforeSigningBlock = 0;
    if (apkSigningBlockPaddingSupported && (beforeCentralDir.size() % ANDROID_COMMON_PAGE_ALIGNMENT_BYTES != 0)) {
        padSizeBeforeSigningBlock = (int) (ANDROID_COMMON_PAGE_ALIGNMENT_BYTES - beforeCentralDir.size() % ANDROID_COMMON_PAGE_ALIGNMENT_BYTES);
        beforeCentralDir = new ChainedDataSource(beforeCentralDir, DataSources.asDataSource(ByteBuffer.allocate(padSizeBeforeSigningBlock)));
    }
    // Ensure that, when digesting, ZIP End of Central Directory record's Central Directory
    // offset field is treated as pointing to the offset at which the APK Signing Block will
    // start.
    long centralDirOffsetForDigesting = beforeCentralDir.size();
    ByteBuffer eocdBuf = ByteBuffer.allocate((int) eocd.size());
    eocdBuf.order(ByteOrder.LITTLE_ENDIAN);
    eocd.copyTo(0, (int) eocd.size(), eocdBuf);
    eocdBuf.flip();
    ZipUtils.setZipEocdCentralDirectoryOffset(eocdBuf, centralDirOffsetForDigesting);
    // Compute digests of APK contents.
    // digest algorithm ID -> digest
    Map<ContentDigestAlgorithm, byte[]> contentDigests;
    try {
        contentDigests = computeContentDigests(contentDigestAlgorithms, new DataSource[] { beforeCentralDir, centralDir, DataSources.asDataSource(eocdBuf) });
    } catch (IOException e) {
        throw new IOException("Failed to read APK being signed", e);
    } catch (DigestException e) {
        throw new SignatureException("Failed to compute digests of APK", e);
    }
    // Sign the digests and wrap the signatures and signer info into an APK Signing Block.
    return Pair.of(generateApkSigningBlock(signerConfigs, contentDigests), padSizeBeforeSigningBlock);
}
#end_block

#method_before
SignerInfo verify(PKCS7 block, InputStream inputStream) throws NoSuchAlgorithmException, SignatureException, IOException {
    try {
        ContentInfo content = block.getContentInfo();
        if (inputStream == null) {
            inputStream = new ByteArrayInputStream(content.getContentBytes());
        }
        String digestAlgname = getDigestAlgorithmId().getName();
        InputStream dataSigned;
        // digest and compare it with the digest of data
        if (authenticatedAttributes == null) {
            dataSigned = inputStream;
        } else {
            // first, check content type
            ObjectIdentifier contentType = (ObjectIdentifier) authenticatedAttributes.getAttributeValue(PKCS9Attribute.CONTENT_TYPE_OID);
            if (contentType == null || !contentType.equals((Object) content.contentType))
                // contentType does not match, bad SignerInfo
                return null;
            // now, check message digest
            byte[] messageDigest = (byte[]) authenticatedAttributes.getAttributeValue(PKCS9Attribute.MESSAGE_DIGEST_OID);
            if (// fail if there is no message digest
            messageDigest == null)
                return null;
            // check that algorithm is not restricted
            if (!JAR_DISABLED_CHECK.permits(DIGEST_PRIMITIVE_SET, digestAlgname, null)) {
                throw new SignatureException("Digest check failed. " + "Disabled algorithm used: " + digestAlgname);
            }
            MessageDigest md = MessageDigest.getInstance(digestAlgname);
            byte[] buffer = new byte[4096];
            int read = 0;
            while ((read = inputStream.read(buffer)) != -1) {
                md.update(buffer, 0, read);
            }
            byte[] computedMessageDigest = md.digest();
            if (messageDigest.length != computedMessageDigest.length)
                return null;
            for (int i = 0; i < messageDigest.length; i++) {
                if (messageDigest[i] != computedMessageDigest[i])
                    return null;
            }
            // message digest attribute matched
            // digest of original data
            // the data actually signed is the DER encoding of
            // the authenticated attributes (tagged with
            // the "SET OF" tag, not 0xA0).
            dataSigned = new ByteArrayInputStream(authenticatedAttributes.getDerEncoding());
        }
        // put together digest algorithm and encryption algorithm
        // to form signing algorithm
        String encryptionAlgname = getDigestEncryptionAlgorithmId().getName();
        // Workaround: sometimes the encryptionAlgname is actually
        // a signature name
        String tmp = AlgorithmId.getEncAlgFromSigAlg(encryptionAlgname);
        if (tmp != null)
            encryptionAlgname = tmp;
        String algname = AlgorithmId.makeSigAlg(digestAlgname, encryptionAlgname);
        // check that algorithm is not restricted
        if (!JAR_DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, algname, null)) {
            throw new SignatureException("Signature check failed. " + "Disabled algorithm used: " + algname);
        }
        X509Certificate cert = getCertificate(block);
        PublicKey key = cert.getPublicKey();
        if (cert == null) {
            return null;
        }
        // check if the public key is restricted
        if (!JAR_DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
            throw new SignatureException("Public key check failed. " + "Disabled key used: " + KeyUtil.getKeySize(key) + " bit " + key.getAlgorithm());
        }
        if (cert.hasUnsupportedCriticalExtension()) {
            throw new SignatureException("Certificate has unsupported " + "critical extension(s)");
        }
        // Make sure that if the usage of the key in the certificate is
        // restricted, it can be used for digital signatures.
        // XXX We may want to check for additional extensions in the
        // future.
        boolean[] keyUsageBits = cert.getKeyUsage();
        if (keyUsageBits != null) {
            KeyUsageExtension keyUsage;
            try {
                // We don't care whether or not this extension was marked
                // critical in the certificate.
                // We're interested only in its value (i.e., the bits set)
                // and treat the extension as critical.
                keyUsage = new KeyUsageExtension(keyUsageBits);
            } catch (IOException ioe) {
                throw new SignatureException("Failed to parse keyUsage " + "extension");
            }
            boolean digSigAllowed = keyUsage.get(KeyUsageExtension.DIGITAL_SIGNATURE).booleanValue();
            boolean nonRepuAllowed = keyUsage.get(KeyUsageExtension.NON_REPUDIATION).booleanValue();
            if (!digSigAllowed && !nonRepuAllowed) {
                throw new SignatureException("Key usage restricted: " + "cannot be used for " + "digital signatures");
            }
        }
        Signature sig = Signature.getInstance(algname);
        sig.initVerify(key);
        byte[] buffer = new byte[4096];
        int read = 0;
        while ((read = dataSigned.read(buffer)) != -1) {
            sig.update(buffer, 0, read);
        }
        if (sig.verify(encryptedDigest)) {
            return this;
        }
    } catch (IOException e) {
        throw new SignatureException("IO error verifying signature:\n" + e.getMessage());
    } catch (InvalidKeyException e) {
        throw new SignatureException("InvalidKey: " + e.getMessage());
    }
    return null;
}
#method_after
SignerInfo verify(PKCS7 block, InputStream inputStream) throws NoSuchAlgorithmException, SignatureException, IOException {
    try {
        ContentInfo content = block.getContentInfo();
        // BEGIN Android-changed: Our implementation uses InputStream instead of byte[].
        if (inputStream == null) {
            inputStream = new ByteArrayInputStream(content.getContentBytes());
        }
        // END Android-changed: Our implementation uses InputStream instead of byte[].
        String digestAlgname = getDigestAlgorithmId().getName();
        // Android-changed: Our implementation uses InputStream instead of byte[].
        // byte[] dataSigned;
        InputStream dataSigned;
        // digest and compare it with the digest of data
        if (authenticatedAttributes == null) {
            // Android-changed: Our implementation uses InputStream instead of byte[].
            // dataSigned = data;
            dataSigned = inputStream;
        } else {
            // first, check content type
            ObjectIdentifier contentType = (ObjectIdentifier) authenticatedAttributes.getAttributeValue(PKCS9Attribute.CONTENT_TYPE_OID);
            if (contentType == null || !contentType.equals((Object) content.contentType))
                // contentType does not match, bad SignerInfo
                return null;
            // now, check message digest
            byte[] messageDigest = (byte[]) authenticatedAttributes.getAttributeValue(PKCS9Attribute.MESSAGE_DIGEST_OID);
            if (// fail if there is no message digest
            messageDigest == null)
                return null;
            // check that algorithm is not restricted
            if (!JAR_DISABLED_CHECK.permits(DIGEST_PRIMITIVE_SET, digestAlgname, null)) {
                throw new SignatureException("Digest check failed. " + "Disabled algorithm used: " + digestAlgname);
            }
            MessageDigest md = MessageDigest.getInstance(digestAlgname);
            // BEGIN Android-changed: Our implementation uses InputStream instead of byte[].
            byte[] buffer = new byte[4096];
            int read = 0;
            while ((read = inputStream.read(buffer)) != -1) {
                md.update(buffer, 0, read);
            }
            byte[] computedMessageDigest = md.digest();
            if (messageDigest.length != computedMessageDigest.length)
                return null;
            for (int i = 0; i < messageDigest.length; i++) {
                if (messageDigest[i] != computedMessageDigest[i])
                    return null;
            }
            // message digest attribute matched
            // digest of original data
            // the data actually signed is the DER encoding of
            // the authenticated attributes (tagged with
            // the "SET OF" tag, not 0xA0).
            // Android-changed: Our implementation uses InputStream instead of byte[].
            // dataSigned = authenticatedAttributes.getDerEncoding();
            dataSigned = new ByteArrayInputStream(authenticatedAttributes.getDerEncoding());
        }
        // put together digest algorithm and encryption algorithm
        // to form signing algorithm
        String encryptionAlgname = getDigestEncryptionAlgorithmId().getName();
        // Workaround: sometimes the encryptionAlgname is actually
        // a signature name
        String tmp = AlgorithmId.getEncAlgFromSigAlg(encryptionAlgname);
        if (tmp != null)
            encryptionAlgname = tmp;
        String algname = AlgorithmId.makeSigAlg(digestAlgname, encryptionAlgname);
        // check that algorithm is not restricted
        if (!JAR_DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, algname, null)) {
            throw new SignatureException("Signature check failed. " + "Disabled algorithm used: " + algname);
        }
        X509Certificate cert = getCertificate(block);
        PublicKey key = cert.getPublicKey();
        if (cert == null) {
            return null;
        }
        // check if the public key is restricted
        if (!JAR_DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
            throw new SignatureException("Public key check failed. " + "Disabled key used: " + KeyUtil.getKeySize(key) + " bit " + key.getAlgorithm());
        }
        if (cert.hasUnsupportedCriticalExtension()) {
            throw new SignatureException("Certificate has unsupported " + "critical extension(s)");
        }
        // Make sure that if the usage of the key in the certificate is
        // restricted, it can be used for digital signatures.
        // XXX We may want to check for additional extensions in the
        // future.
        boolean[] keyUsageBits = cert.getKeyUsage();
        if (keyUsageBits != null) {
            KeyUsageExtension keyUsage;
            try {
                // We don't care whether or not this extension was marked
                // critical in the certificate.
                // We're interested only in its value (i.e., the bits set)
                // and treat the extension as critical.
                keyUsage = new KeyUsageExtension(keyUsageBits);
            } catch (IOException ioe) {
                throw new SignatureException("Failed to parse keyUsage " + "extension");
            }
            boolean digSigAllowed = keyUsage.get(KeyUsageExtension.DIGITAL_SIGNATURE).booleanValue();
            boolean nonRepuAllowed = keyUsage.get(KeyUsageExtension.NON_REPUDIATION).booleanValue();
            if (!digSigAllowed && !nonRepuAllowed) {
                throw new SignatureException("Key usage restricted: " + "cannot be used for " + "digital signatures");
            }
        }
        Signature sig = Signature.getInstance(algname);
        sig.initVerify(key);
        // BEGIN Android-changed: Our implementation uses InputStream instead of byte[].
        byte[] buffer = new byte[4096];
        int read = 0;
        while ((read = dataSigned.read(buffer)) != -1) {
            sig.update(buffer, 0, read);
        }
        // END Android-changed: Our implementation uses InputStream instead of byte[].
        if (sig.verify(encryptedDigest)) {
            return this;
        }
    } catch (IOException e) {
        throw new SignatureException("IO error verifying signature:\n" + e.getMessage());
    } catch (InvalidKeyException e) {
        throw new SignatureException("InvalidKey: " + e.getMessage());
    }
    return null;
}
#end_block

#method_before
// END Android-changed: Add InputStream overload.
SignerInfo verify(PKCS7 block) throws NoSuchAlgorithmException, SignatureException {
    // Was: return verify(block, null);
    return verify(block, (byte[]) null);
}
#method_after
SignerInfo verify(PKCS7 block) throws NoSuchAlgorithmException, SignatureException {
    // return verify(block, null);
    return verify(block, (byte[]) null);
}
#end_block

#method_before
@Override
public String toString() {
    return "SimRecords: " + super.toString() + " mVmConfig" + mVmConfig + " mSpnOverride=" + "mSpnOverride" + " callForwardingEnabled=" + mCallForwardingStatus + " spnState=" + mSpnState + " mCphsInfo=" + mCphsInfo + " mCspPlmnEnabled=" + mCspPlmnEnabled + " efMWIS=" + mEfMWIS + " efCPHS_MWI=" + mEfCPHS_MWI + " mEfCff=" + mEfCff + " mEfCfis=" + mEfCfis + " getOperatorNumeric=" + getOperatorNumeric();
}
#method_after
@Override
public String toString() {
    return "SimRecords: " + super.toString() + " mVmConfig" + mVmConfig + " mSpnOverride=" + mSpnOverride + " callForwardingEnabled=" + mCallForwardingStatus + " spnState=" + mSpnState + " mCphsInfo=" + mCphsInfo + " mCspPlmnEnabled=" + mCspPlmnEnabled + " efMWIS=" + mEfMWIS + " efCPHS_MWI=" + mEfCPHS_MWI + " mEfCff=" + mEfCff + " mEfCfis=" + mEfCfis + " getOperatorNumeric=" + getOperatorNumeric();
}
#end_block

#method_before
@Override
public void dispose() {
    if (DBG)
        log("Disposing SIMRecords this=" + this);
    // Unregister for all events
    mCi.unregisterForIccRefresh(this);
    mCi.unSetOnSmsOnSim(this);
    mParentApp.unregisterForReady(this);
    mParentApp.unregisterForLocked(this);
    resetRecords();
    super.dispose();
}
#method_after
@Override
public void dispose() {
    if (DBG)
        log("Disposing SIMRecords this=" + this);
    // Unregister for all events
    mCi.unregisterForIccRefresh(this);
    mCi.unSetOnSmsOnSim(this);
    mParentApp.unregisterForReady(this);
    mParentApp.unregisterForLocked(this);
    mContext.unregisterReceiver(mReceiver);
    resetRecords();
    super.dispose();
}
#end_block

#method_before
@Override
public String getMsisdnNumber() {
    return mMsisdn;
}
#method_after
// ***** Public Methods
@Override
public String getMsisdnNumber() {
    return mMsisdn;
}
#end_block

#method_before
// Validate data is !null and the MSP (Multiple Subscriber Profile)
private boolean validEfCfis(byte[] data) {
    return ((data != null) && (data[0] >= 1) && (data[0] <= 4));
}
#method_after
private boolean validEfCfis(byte[] data) {
    if (data != null) {
        if (data[0] < 1 || data[0] > 4) {
            // The MSP (Multiple Subscriber Profile) byte should be between
            // 1 and 4 according to ETSI TS 131 102 v11.3.0 section 4.2.64.
            logw("MSP byte: " + data[0] + " is not between 1 and 4", null);
        }
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public void setVoiceCallForwardingFlag(int line, boolean enable, String dialNumber) {
    // only line 1 is supported
    if (line != 1)
        return;
    mCallForwardingStatus = enable ? CALL_FORWARDING_STATUS_ENABLED : CALL_FORWARDING_STATUS_DISABLED;
    mRecordsEventsRegistrants.notifyResult(EVENT_CFI);
    try {
        if (validEfCfis(mEfCfis)) {
            // lsb is of byte f1 is voice status
            if (enable) {
                mEfCfis[1] |= 1;
            } else {
                mEfCfis[1] &= 0xfe;
            }
            log("setVoiceCallForwardingFlag: enable=" + enable + " mEfCfis=" + IccUtils.bytesToHexString(mEfCfis));
            // Spec reference for EF_CFIS contents, TS 51.011 section 10.3.46.
            if (enable && !TextUtils.isEmpty(dialNumber)) {
                logv("EF_CFIS: updating cf number, " + Rlog.pii(LOG_TAG, dialNumber));
                byte[] bcdNumber = PhoneNumberUtils.numberToCalledPartyBCD(dialNumber);
                System.arraycopy(bcdNumber, 0, mEfCfis, CFIS_TON_NPI_OFFSET, bcdNumber.length);
                mEfCfis[CFIS_BCD_NUMBER_LENGTH_OFFSET] = (byte) (bcdNumber.length);
                mEfCfis[CFIS_ADN_CAPABILITY_ID_OFFSET] = (byte) 0xFF;
                mEfCfis[CFIS_ADN_EXTENSION_ID_OFFSET] = (byte) 0xFF;
            }
            mFh.updateEFLinearFixed(EF_CFIS, 1, mEfCfis, null, obtainMessage(EVENT_UPDATE_DONE, EF_CFIS));
        } else {
            log("setVoiceCallForwardingFlag: ignoring enable=" + enable + " invalid mEfCfis=" + IccUtils.bytesToHexString(mEfCfis));
        }
        if (mEfCff != null) {
            if (enable) {
                mEfCff[0] = (byte) ((mEfCff[0] & CFF_LINE1_RESET) | CFF_UNCONDITIONAL_ACTIVE);
            } else {
                mEfCff[0] = (byte) ((mEfCff[0] & CFF_LINE1_RESET) | CFF_UNCONDITIONAL_DEACTIVE);
            }
            mFh.updateEFTransparent(EF_CFF_CPHS, mEfCff, obtainMessage(EVENT_UPDATE_DONE, EF_CFF_CPHS));
        }
    } catch (ArrayIndexOutOfBoundsException ex) {
        logw("Error saving call forwarding flag to SIM. " + "Probably malformed SIM record", ex);
    }
}
#method_after
@Override
public void setVoiceCallForwardingFlag(int line, boolean enable, String dialNumber) {
    // only line 1 is supported
    if (line != 1)
        return;
    mCallForwardingStatus = enable ? CALL_FORWARDING_STATUS_ENABLED : CALL_FORWARDING_STATUS_DISABLED;
    mRecordsEventsRegistrants.notifyResult(EVENT_CFI);
    try {
        if (validEfCfis(mEfCfis)) {
            // lsb is of byte f1 is voice status
            if (enable) {
                mEfCfis[1] |= 1;
            } else {
                mEfCfis[1] &= 0xfe;
            }
            log("setVoiceCallForwardingFlag: enable=" + enable + " mEfCfis=" + IccUtils.bytesToHexString(mEfCfis));
            // Spec reference for EF_CFIS contents, TS 51.011 section 10.3.46.
            if (enable && !TextUtils.isEmpty(dialNumber)) {
                logv("EF_CFIS: updating cf number, " + Rlog.pii(LOG_TAG, dialNumber));
                byte[] bcdNumber = PhoneNumberUtils.numberToCalledPartyBCD(dialNumber, PhoneNumberUtils.BCD_EXTENDED_TYPE_EF_ADN);
                System.arraycopy(bcdNumber, 0, mEfCfis, CFIS_TON_NPI_OFFSET, bcdNumber.length);
                mEfCfis[CFIS_BCD_NUMBER_LENGTH_OFFSET] = (byte) (bcdNumber.length);
                mEfCfis[CFIS_ADN_CAPABILITY_ID_OFFSET] = (byte) 0xFF;
                mEfCfis[CFIS_ADN_EXTENSION_ID_OFFSET] = (byte) 0xFF;
            }
            mFh.updateEFLinearFixed(EF_CFIS, 1, mEfCfis, null, obtainMessage(EVENT_UPDATE_DONE, EF_CFIS));
        } else {
            log("setVoiceCallForwardingFlag: ignoring enable=" + enable + " invalid mEfCfis=" + IccUtils.bytesToHexString(mEfCfis));
        }
        if (mEfCff != null) {
            if (enable) {
                mEfCff[0] = (byte) ((mEfCff[0] & CFF_LINE1_RESET) | CFF_UNCONDITIONAL_ACTIVE);
            } else {
                mEfCff[0] = (byte) ((mEfCff[0] & CFF_LINE1_RESET) | CFF_UNCONDITIONAL_DEACTIVE);
            }
            mFh.updateEFTransparent(EF_CFF_CPHS, mEfCff, obtainMessage(EVENT_UPDATE_DONE, EF_CFF_CPHS));
        }
    } catch (ArrayIndexOutOfBoundsException ex) {
        logw("Error saving call forwarding flag to SIM. " + "Probably malformed SIM record", ex);
    }
}
#end_block

#method_before
@Override
public String getOperatorNumeric() {
    if (mImsi == null) {
        log("getOperatorNumeric: IMSI == null");
        return null;
    }
    if (mMncLength == UNINITIALIZED || mMncLength == UNKNOWN) {
        log("getSIMOperatorNumeric: bad mncLength");
        return null;
    }
    // length of mcc = 3 (TS 23.003 Section 2.2)
    return mImsi.substring(0, 3 + mMncLength);
}
#method_after
@Override
public String getOperatorNumeric() {
    String imsi = getIMSI();
    if (imsi == null) {
        log("getOperatorNumeric: IMSI == null");
        return null;
    }
    if (mMncLength == UNINITIALIZED || mMncLength == UNKNOWN) {
        log("getSIMOperatorNumeric: bad mncLength");
        return null;
    }
    // length of mcc = 3 (TS 23.003 Section 2.2)
    if (imsi.length() >= 3 + mMncLength) {
        return imsi.substring(0, 3 + mMncLength);
    } else {
        return null;
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    AdnRecord adn;
    byte[] data;
    boolean isRecordLoadResponse = false;
    if (mDestroyed.get()) {
        loge("Received message " + msg + "[" + msg.what + "] " + " while being destroyed. Ignoring.");
        return;
    }
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            case EVENT_APP_LOCKED:
                onLocked();
                break;
            /* IO events */
            case EVENT_GET_IMSI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception querying IMSI, Exception:" + ar.exception);
                    break;
                }
                mImsi = (String) ar.result;
                // than 15 (and usually 15).
                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
                    loge("invalid IMSI " + mImsi);
                    mImsi = null;
                }
                log("IMSI: mMncLength=" + mMncLength);
                log("IMSI: " + mImsi.substring(0, 6) + Rlog.pii(LOG_TAG, mImsi.substring(6)));
                if (((mMncLength == UNKNOWN) || (mMncLength == 2)) && ((mImsi != null) && (mImsi.length() >= 6))) {
                    String mccmncCode = mImsi.substring(0, 6);
                    for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                        if (mccmnc.equals(mccmncCode)) {
                            mMncLength = 3;
                            log("IMSI: setting1 mMncLength=" + mMncLength);
                            break;
                        }
                    }
                }
                if (mMncLength == UNKNOWN) {
                    // guess using the mcc
                    try {
                        int mcc = Integer.parseInt(mImsi.substring(0, 3));
                        mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                        log("setting2 mMncLength=" + mMncLength);
                    } catch (NumberFormatException e) {
                        mMncLength = UNKNOWN;
                        loge("Corrupt IMSI! setting3 mMncLength=" + mMncLength);
                    }
                }
                if (mMncLength != UNKNOWN && mMncLength != UNINITIALIZED) {
                    log("update mccmnc=" + mImsi.substring(0, 3 + mMncLength));
                    // finally have both the imsi and the mncLength and
                    // can parse the imsi properly
                    MccTable.updateMccMncConfiguration(mContext, mImsi.substring(0, 3 + mMncLength), false);
                }
                mImsiReadyRegistrants.notifyRegistrants();
                break;
            case EVENT_GET_MBI_DONE:
                boolean isValidMbdn;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                isValidMbdn = false;
                if (ar.exception == null) {
                    // Refer TS 51.011 Section 10.3.44 for content details
                    log("EF_MBI: " + IccUtils.bytesToHexString(data));
                    // Voice mail record number stored first
                    mMailboxIndex = data[0] & 0xff;
                    // check if dailing numbe id valid
                    if (mMailboxIndex != 0 && mMailboxIndex != 0xff) {
                        log("Got valid mailbox number for MBDN");
                        isValidMbdn = true;
                    }
                }
                // one more record to load
                mRecordsToLoad += 1;
                if (isValidMbdn) {
                    // Note: MBDN was not included in NUM_OF_SIM_RECORDS_LOADED
                    new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6, mMailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
                } else {
                    // If this EF not present, try mailbox as in CPHS standard
                    // CPHS (CPHS4_2.WW6) is a european standard.
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                }
                break;
            case EVENT_GET_CPHS_MAILBOX_DONE:
            case EVENT_GET_MBDN_DONE:
                // Resetting the voice mail number and voice mail tag to null
                // as these should be updated from the data read from EF_MBDN.
                // If they are not reset, incase of invalid data/exception these
                // variables are retaining their previous values and are
                // causing invalid voice mailbox info display to user.
                mVoiceMailNum = null;
                mVoiceMailTag = null;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF" + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? "[MAILBOX]" : "[MBDN]"));
                    if (msg.what == EVENT_GET_MBDN_DONE) {
                        // load CPHS on fail...
                        // FIXME right now, only load line1's CPHS voice mail entry
                        mRecordsToLoad += 1;
                        new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    }
                    break;
                }
                adn = (AdnRecord) ar.result;
                log("VM: " + adn + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? " EF[MAILBOX]" : " EF[MBDN]"));
                if (adn.isEmpty() && msg.what == EVENT_GET_MBDN_DONE) {
                    // Bug #645770 fall back to CPHS
                    // FIXME should use SST to decide
                    // FIXME right now, only load line1's CPHS voice mail entry
                    mRecordsToLoad += 1;
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    break;
                }
                mVoiceMailNum = adn.getNumber();
                mVoiceMailTag = adn.getAlphaTag();
                break;
            case EVENT_GET_MSISDN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF[MSISDN]");
                    break;
                }
                adn = (AdnRecord) ar.result;
                mMsisdn = adn.getNumber();
                mMsisdnTag = adn.getAlphaTag();
                log("MSISDN: " + /*mMsisdn*/
                Rlog.pii(LOG_TAG, mMsisdn));
                break;
            case EVENT_SET_MSISDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mMsisdn = mNewMsisdn;
                    mMsisdnTag = mNewMsisdnTag;
                    log("Success to update EF[MSISDN]");
                }
                if (ar.userObj != null) {
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_GET_MWIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_MWIS : " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG)
                        log("EVENT_GET_MWIS_DONE exception = " + ar.exception);
                    break;
                }
                if ((data[0] & 0xff) == 0xff) {
                    if (DBG)
                        log("SIMRecords: Uninitialized record MWIS");
                    break;
                }
                mEfMWIS = data;
                break;
            case EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_CPHS_MWI: " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG) {
                        log("EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE exception = " + ar.exception);
                    }
                    break;
                }
                mEfCPHS_MWI = data;
                break;
            case EVENT_GET_ICCID_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mIccId = IccUtils.bcdToString(data, 0, data.length);
                mFullIccId = IccUtils.bchToString(data, 0, data.length);
                log("iccid: " + SubscriptionInfo.givePrintableIccid(mFullIccId));
                break;
            case EVENT_GET_AD_DONE:
                try {
                    isRecordLoadResponse = true;
                    ar = (AsyncResult) msg.obj;
                    data = (byte[]) ar.result;
                    if (ar.exception != null) {
                        break;
                    }
                    log("EF_AD: " + IccUtils.bytesToHexString(data));
                    if (data.length < 3) {
                        log("Corrupt AD data on SIM");
                        break;
                    }
                    if (data.length == 3) {
                        log("MNC length not present in EF_AD");
                        break;
                    }
                    mMncLength = data[3] & 0xf;
                    log("setting4 mMncLength=" + mMncLength);
                    if (mMncLength == 0xf) {
                        mMncLength = UNKNOWN;
                        log("setting5 mMncLength=" + mMncLength);
                    } else if (mMncLength != 2 && mMncLength != 3) {
                        mMncLength = UNINITIALIZED;
                        log("setting5 mMncLength=" + mMncLength);
                    }
                } finally {
                    if (((mMncLength == UNINITIALIZED) || (mMncLength == UNKNOWN) || (mMncLength == 2)) && ((mImsi != null) && (mImsi.length() >= 6))) {
                        String mccmncCode = mImsi.substring(0, 6);
                        log("mccmncCode=" + mccmncCode);
                        for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                            if (mccmnc.equals(mccmncCode)) {
                                mMncLength = 3;
                                log("setting6 mMncLength=" + mMncLength);
                                break;
                            }
                        }
                    }
                    if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
                        if (mImsi != null) {
                            try {
                                int mcc = Integer.parseInt(mImsi.substring(0, 3));
                                mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                                log("setting7 mMncLength=" + mMncLength);
                            } catch (NumberFormatException e) {
                                mMncLength = UNKNOWN;
                                loge("Corrupt IMSI! setting8 mMncLength=" + mMncLength);
                            }
                        } else {
                            // Indicate we got this info, but it didn't contain the length.
                            mMncLength = UNKNOWN;
                            log("MNC length not present in EF_AD setting9 " + "mMncLength=" + mMncLength);
                        }
                    }
                    if (mImsi != null && mMncLength != UNKNOWN) {
                        // finally have both imsi and the length of the mnc and can parse
                        // the imsi properly
                        log("update mccmnc=" + mImsi.substring(0, 3 + mMncLength));
                        MccTable.updateMccMncConfiguration(mContext, mImsi.substring(0, 3 + mMncLength), false);
                    }
                }
                break;
            case EVENT_GET_SPN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                getSpnFsm(false, ar);
                break;
            case EVENT_GET_CFF_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCff = null;
                } else {
                    log("EF_CFF_CPHS: " + IccUtils.bytesToHexString(data));
                    mEfCff = data;
                }
                break;
            case EVENT_GET_SPDI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                parseEfSpdi(data);
                break;
            case EVENT_UPDATE_DONE:
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    logw("update failed. ", ar.exception);
                }
                break;
            case EVENT_GET_PNN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                SimTlv tlv = new SimTlv(data, 0, data.length);
                for (; tlv.isValidObject(); tlv.nextObject()) {
                    if (tlv.getTag() == TAG_FULL_NETWORK_NAME) {
                        mPnnHomeName = IccUtils.networkNameToString(tlv.getData(), 0, tlv.getData().length);
                        break;
                    }
                }
                break;
            case EVENT_GET_ALL_SMS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                handleSmses((ArrayList<byte[]>) ar.result);
                break;
            case EVENT_MARK_SMS_READ_DONE:
                Rlog.i("ENF", "marked read: sms " + msg.arg1);
                break;
            case EVENT_SMS_ON_SIM:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                Integer index = (Integer) ar.result;
                if (ar.exception != null || index == null) {
                    loge("Error on SMS_ON_SIM with exp " + ar.exception + " index " + index);
                } else {
                    log("READ EF_SMS RECORD index=" + index);
                    mFh.loadEFLinearFixed(EF_SMS, index, obtainMessage(EVENT_GET_SMS_DONE));
                }
                break;
            case EVENT_GET_SMS_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    handleSms((byte[]) ar.result);
                } else {
                    loge("Error on GET_SMS with exp " + ar.exception);
                }
                break;
            case EVENT_GET_SST_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mUsimServiceTable = new UsimServiceTable(data);
                if (DBG)
                    log("SST: " + mUsimServiceTable);
                break;
            case EVENT_GET_INFO_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                mCphsInfo = (byte[]) ar.result;
                if (DBG)
                    log("iCPHS: " + IccUtils.bytesToHexString(mCphsInfo));
                break;
            case EVENT_SET_MBDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("EVENT_SET_MBDN_DONE ex:" + ar.exception);
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                }
                if (isCphsMailboxEnabled()) {
                    adn = new AdnRecord(mVoiceMailTag, mVoiceMailNum);
                    Message onCphsCompleted = (Message) ar.userObj;
                    /* write to cphs mailbox whenever it is available but
                        * we only need notify caller once if both updating are
                        * successful.
                        *
                        * so if set_mbdn successful, notify caller here and set
                        * onCphsCompleted to null
                        */
                    if (ar.exception == null && ar.userObj != null) {
                        AsyncResult.forMessage(((Message) ar.userObj)).exception = null;
                        ((Message) ar.userObj).sendToTarget();
                        if (DBG)
                            log("Callback with MBDN successful.");
                        onCphsCompleted = null;
                    }
                    new AdnRecordLoader(mFh).updateEF(adn, EF_MAILBOX_CPHS, EF_EXT1, 1, null, obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE, onCphsCompleted));
                } else {
                    if (ar.userObj != null) {
                        CarrierConfigManager configLoader = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
                        if (ar.exception != null && configLoader != null && configLoader.getConfig().getBoolean(CarrierConfigManager.KEY_EDITABLE_VOICEMAIL_NUMBER_BOOL)) {
                            // GsmCdmaPhone will store vm number on device
                            // when IccVmNotSupportedException occurred
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = new IccVmNotSupportedException("Update SIM voice mailbox error");
                        } else {
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                        }
                        ((Message) ar.userObj).sendToTarget();
                    }
                }
                break;
            case EVENT_SET_CPHS_MAILBOX_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                } else {
                    if (DBG)
                        log("Set CPHS MailBox with exception: " + ar.exception);
                }
                if (ar.userObj != null) {
                    if (DBG)
                        log("Callback with CPHS MB successful.");
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_SIM_REFRESH:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("Sim REFRESH with exception: " + ar.exception);
                if (ar.exception == null) {
                    handleSimRefresh((IccRefreshResponse) ar.result);
                }
                break;
            case EVENT_GET_CFIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCfis = null;
                } else {
                    log("EF_CFIS: " + IccUtils.bytesToHexString(data));
                    mEfCfis = data;
                }
                break;
            case EVENT_GET_CSP_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception in fetching EF_CSP data " + ar.exception);
                    break;
                }
                data = (byte[]) ar.result;
                log("EF_CSP: " + IccUtils.bytesToHexString(data));
                handleEfCspData(data);
                break;
            case EVENT_GET_GID1_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID1 " + ar.exception);
                    mGid1 = null;
                    break;
                }
                mGid1 = IccUtils.bytesToHexString(data);
                log("GID1: " + mGid1);
                break;
            case EVENT_GET_GID2_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID2 " + ar.exception);
                    mGid2 = null;
                    break;
                }
                mGid2 = IccUtils.bytesToHexString(data);
                log("GID2: " + mGid2);
                break;
            case EVENT_GET_PLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting User PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mPlmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("PlmnActRecords=" + Arrays.toString(mPlmnActRecords));
                }
                break;
            case EVENT_GET_OPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Operator PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mOplmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("OplmnActRecord[]=" + Arrays.toString(mOplmnActRecords));
                }
                break;
            case EVENT_GET_HPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Home PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mHplmnActRecords = PlmnActRecord.getRecords(data);
                    log("HplmnActRecord[]=" + Arrays.toString(mHplmnActRecords));
                }
                break;
            case EVENT_GET_EHPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Equivalent Home PLMNs: " + ar.exception);
                    break;
                } else {
                    mEhplmns = parseBcdPlmnList(data, "Equivalent Home");
                }
                break;
            case EVENT_GET_FPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Forbidden PLMNs: " + ar.exception);
                    break;
                } else {
                    mFplmns = parseBcdPlmnList(data, "Forbidden");
                }
                if (msg.arg1 == HANDLER_ACTION_SEND_RESPONSE) {
                    if (VDBG)
                        logv("getForbiddenPlmns(): send async response");
                    isRecordLoadResponse = false;
                    Message response = retrievePendingResponseMessage(msg.arg2);
                    if (response != null) {
                        AsyncResult.forMessage(response, Arrays.copyOf(mFplmns, mFplmns.length), null);
                        response.sendToTarget();
                    } else {
                        loge("Failed to retrieve a response message for FPLMN");
                        break;
                    }
                }
                break;
            case EVENT_CARRIER_CONFIG_CHANGED:
                handleCarrierNameOverride();
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        logw("Exception parsing SIM record", exc);
    } finally {
        // Count up record load responses even if they are fails
        if (isRecordLoadResponse) {
            onRecordLoaded();
        }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    AdnRecord adn;
    byte[] data;
    boolean isRecordLoadResponse = false;
    if (mDestroyed.get()) {
        loge("Received message " + msg + "[" + msg.what + "] " + " while being destroyed. Ignoring.");
        return;
    }
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            case EVENT_APP_LOCKED:
                onLocked();
                break;
            /* IO events */
            case EVENT_GET_IMSI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception querying IMSI, Exception:" + ar.exception);
                    break;
                }
                mImsi = (String) ar.result;
                // than 15 (and usually 15).
                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
                    loge("invalid IMSI " + mImsi);
                    mImsi = null;
                }
                log("IMSI: mMncLength=" + mMncLength);
                if (mImsi != null && mImsi.length() >= 6) {
                    log("IMSI: " + mImsi.substring(0, 6) + Rlog.pii(LOG_TAG, mImsi.substring(6)));
                }
                String imsi = getIMSI();
                if (((mMncLength == UNKNOWN) || (mMncLength == 2)) && ((imsi != null) && (imsi.length() >= 6))) {
                    String mccmncCode = imsi.substring(0, 6);
                    for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                        if (mccmnc.equals(mccmncCode)) {
                            mMncLength = 3;
                            log("IMSI: setting1 mMncLength=" + mMncLength);
                            break;
                        }
                    }
                }
                if (mMncLength == UNKNOWN) {
                    // guess using the mcc
                    try {
                        int mcc = Integer.parseInt(imsi.substring(0, 3));
                        mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                        log("setting2 mMncLength=" + mMncLength);
                    } catch (NumberFormatException e) {
                        mMncLength = UNKNOWN;
                        loge("Corrupt IMSI! setting3 mMncLength=" + mMncLength);
                    }
                }
                if (mMncLength != UNKNOWN && mMncLength != UNINITIALIZED && imsi.length() >= 3 + mMncLength) {
                    log("update mccmnc=" + imsi.substring(0, 3 + mMncLength));
                    // finally have both the imsi and the mncLength and
                    // can parse the imsi properly
                    MccTable.updateMccMncConfiguration(mContext, imsi.substring(0, 3 + mMncLength), false);
                }
                mImsiReadyRegistrants.notifyRegistrants();
                break;
            case EVENT_GET_MBI_DONE:
                boolean isValidMbdn;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                isValidMbdn = false;
                if (ar.exception == null) {
                    // Refer TS 51.011 Section 10.3.44 for content details
                    log("EF_MBI: " + IccUtils.bytesToHexString(data));
                    // Voice mail record number stored first
                    mMailboxIndex = data[0] & 0xff;
                    // check if dailing numbe id valid
                    if (mMailboxIndex != 0 && mMailboxIndex != 0xff) {
                        log("Got valid mailbox number for MBDN");
                        isValidMbdn = true;
                    }
                }
                // one more record to load
                mRecordsToLoad += 1;
                if (isValidMbdn) {
                    // Note: MBDN was not included in NUM_OF_SIM_RECORDS_LOADED
                    new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6, mMailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
                } else {
                    // If this EF not present, try mailbox as in CPHS standard
                    // CPHS (CPHS4_2.WW6) is a european standard.
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                }
                break;
            case EVENT_GET_CPHS_MAILBOX_DONE:
            case EVENT_GET_MBDN_DONE:
                // Resetting the voice mail number and voice mail tag to null
                // as these should be updated from the data read from EF_MBDN.
                // If they are not reset, incase of invalid data/exception these
                // variables are retaining their previous values and are
                // causing invalid voice mailbox info display to user.
                mVoiceMailNum = null;
                mVoiceMailTag = null;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF" + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? "[MAILBOX]" : "[MBDN]"));
                    if (msg.what == EVENT_GET_MBDN_DONE) {
                        // load CPHS on fail...
                        // FIXME right now, only load line1's CPHS voice mail entry
                        mRecordsToLoad += 1;
                        new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    }
                    break;
                }
                adn = (AdnRecord) ar.result;
                log("VM: " + adn + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? " EF[MAILBOX]" : " EF[MBDN]"));
                if (adn.isEmpty() && msg.what == EVENT_GET_MBDN_DONE) {
                    // Bug #645770 fall back to CPHS
                    // FIXME should use SST to decide
                    // FIXME right now, only load line1's CPHS voice mail entry
                    mRecordsToLoad += 1;
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    break;
                }
                mVoiceMailNum = adn.getNumber();
                mVoiceMailTag = adn.getAlphaTag();
                break;
            case EVENT_GET_MSISDN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF[MSISDN]");
                    break;
                }
                adn = (AdnRecord) ar.result;
                mMsisdn = adn.getNumber();
                mMsisdnTag = adn.getAlphaTag();
                log("MSISDN: " + /*mMsisdn*/
                Rlog.pii(LOG_TAG, mMsisdn));
                break;
            case EVENT_SET_MSISDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mMsisdn = mNewMsisdn;
                    mMsisdnTag = mNewMsisdnTag;
                    log("Success to update EF[MSISDN]");
                }
                if (ar.userObj != null) {
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_GET_MWIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_MWIS : " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG)
                        log("EVENT_GET_MWIS_DONE exception = " + ar.exception);
                    break;
                }
                if ((data[0] & 0xff) == 0xff) {
                    if (DBG)
                        log("SIMRecords: Uninitialized record MWIS");
                    break;
                }
                mEfMWIS = data;
                break;
            case EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_CPHS_MWI: " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG) {
                        log("EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE exception = " + ar.exception);
                    }
                    break;
                }
                mEfCPHS_MWI = data;
                break;
            case EVENT_GET_ICCID_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mIccId = IccUtils.bcdToString(data, 0, data.length);
                mFullIccId = IccUtils.bchToString(data, 0, data.length);
                log("iccid: " + SubscriptionInfo.givePrintableIccid(mFullIccId));
                break;
            case EVENT_GET_AD_DONE:
                try {
                    isRecordLoadResponse = true;
                    if (mCarrierTestOverride.isInTestMode() && getIMSI() != null) {
                        imsi = getIMSI();
                        try {
                            int mcc = Integer.parseInt(imsi.substring(0, 3));
                            mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                            log("[TestMode] mMncLength=" + mMncLength);
                        } catch (NumberFormatException e) {
                            mMncLength = UNKNOWN;
                            loge("[TestMode] Corrupt IMSI! mMncLength=" + mMncLength);
                        }
                    } else {
                        ar = (AsyncResult) msg.obj;
                        data = (byte[]) ar.result;
                        if (ar.exception != null) {
                            break;
                        }
                        log("EF_AD: " + IccUtils.bytesToHexString(data));
                        if (data.length < 3) {
                            log("Corrupt AD data on SIM");
                            break;
                        }
                        if (data.length == 3) {
                            log("MNC length not present in EF_AD");
                            break;
                        }
                        mMncLength = data[3] & 0xf;
                        log("setting4 mMncLength=" + mMncLength);
                    }
                    if (mMncLength == 0xf) {
                        mMncLength = UNKNOWN;
                        log("setting5 mMncLength=" + mMncLength);
                    } else if (mMncLength != 2 && mMncLength != 3) {
                        mMncLength = UNINITIALIZED;
                        log("setting5 mMncLength=" + mMncLength);
                    }
                } finally {
                    // IMSI could be a value reading from Sim or a fake IMSI if in the test mode
                    imsi = getIMSI();
                    if (((mMncLength == UNINITIALIZED) || (mMncLength == UNKNOWN) || (mMncLength == 2)) && ((imsi != null) && (imsi.length() >= 6))) {
                        String mccmncCode = imsi.substring(0, 6);
                        log("mccmncCode=" + mccmncCode);
                        for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                            if (mccmnc.equals(mccmncCode)) {
                                mMncLength = 3;
                                log("setting6 mMncLength=" + mMncLength);
                                break;
                            }
                        }
                    }
                    if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
                        if (imsi != null) {
                            try {
                                int mcc = Integer.parseInt(imsi.substring(0, 3));
                                mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                                log("setting7 mMncLength=" + mMncLength);
                            } catch (NumberFormatException e) {
                                mMncLength = UNKNOWN;
                                loge("Corrupt IMSI! setting8 mMncLength=" + mMncLength);
                            }
                        } else {
                            // Indicate we got this info, but it didn't contain the length.
                            mMncLength = UNKNOWN;
                            log("MNC length not present in EF_AD setting9 " + "mMncLength=" + mMncLength);
                        }
                    }
                    if (imsi != null && mMncLength != UNKNOWN && imsi.length() >= 3 + mMncLength) {
                        // finally have both imsi and the length of the mnc and can parse
                        // the imsi properly
                        log("update mccmnc=" + imsi.substring(0, 3 + mMncLength));
                        MccTable.updateMccMncConfiguration(mContext, imsi.substring(0, 3 + mMncLength), false);
                    }
                }
                break;
            case EVENT_GET_SPN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                getSpnFsm(false, ar);
                break;
            case EVENT_GET_CFF_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCff = null;
                } else {
                    log("EF_CFF_CPHS: " + IccUtils.bytesToHexString(data));
                    mEfCff = data;
                }
                break;
            case EVENT_GET_SPDI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                parseEfSpdi(data);
                break;
            case EVENT_UPDATE_DONE:
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    logw("update failed. ", ar.exception);
                }
                break;
            case EVENT_GET_PNN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                SimTlv tlv = new SimTlv(data, 0, data.length);
                for (; tlv.isValidObject(); tlv.nextObject()) {
                    if (tlv.getTag() == TAG_FULL_NETWORK_NAME) {
                        mPnnHomeName = IccUtils.networkNameToString(tlv.getData(), 0, tlv.getData().length);
                        break;
                    }
                }
                break;
            case EVENT_GET_ALL_SMS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                handleSmses((ArrayList<byte[]>) ar.result);
                break;
            case EVENT_MARK_SMS_READ_DONE:
                Rlog.i("ENF", "marked read: sms " + msg.arg1);
                break;
            case EVENT_SMS_ON_SIM:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                Integer index = (Integer) ar.result;
                if (ar.exception != null || index == null) {
                    loge("Error on SMS_ON_SIM with exp " + ar.exception + " index " + index);
                } else {
                    log("READ EF_SMS RECORD index=" + index);
                    mFh.loadEFLinearFixed(EF_SMS, index, obtainMessage(EVENT_GET_SMS_DONE));
                }
                break;
            case EVENT_GET_SMS_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    handleSms((byte[]) ar.result);
                } else {
                    loge("Error on GET_SMS with exp " + ar.exception);
                }
                break;
            case EVENT_GET_SST_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mUsimServiceTable = new UsimServiceTable(data);
                if (DBG)
                    log("SST: " + mUsimServiceTable);
                break;
            case EVENT_GET_INFO_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                mCphsInfo = (byte[]) ar.result;
                if (DBG)
                    log("iCPHS: " + IccUtils.bytesToHexString(mCphsInfo));
                break;
            case EVENT_SET_MBDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("EVENT_SET_MBDN_DONE ex:" + ar.exception);
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                }
                if (isCphsMailboxEnabled()) {
                    adn = new AdnRecord(mVoiceMailTag, mVoiceMailNum);
                    Message onCphsCompleted = (Message) ar.userObj;
                    /* write to cphs mailbox whenever it is available but
                        * we only need notify caller once if both updating are
                        * successful.
                        *
                        * so if set_mbdn successful, notify caller here and set
                        * onCphsCompleted to null
                        */
                    if (ar.exception == null && ar.userObj != null) {
                        AsyncResult.forMessage(((Message) ar.userObj)).exception = null;
                        ((Message) ar.userObj).sendToTarget();
                        if (DBG)
                            log("Callback with MBDN successful.");
                        onCphsCompleted = null;
                    }
                    new AdnRecordLoader(mFh).updateEF(adn, EF_MAILBOX_CPHS, EF_EXT1, 1, null, obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE, onCphsCompleted));
                } else {
                    if (ar.userObj != null) {
                        CarrierConfigManager configLoader = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
                        if (ar.exception != null && configLoader != null && configLoader.getConfig().getBoolean(CarrierConfigManager.KEY_EDITABLE_VOICEMAIL_NUMBER_BOOL)) {
                            // GsmCdmaPhone will store vm number on device
                            // when IccVmNotSupportedException occurred
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = new IccVmNotSupportedException("Update SIM voice mailbox error");
                        } else {
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                        }
                        ((Message) ar.userObj).sendToTarget();
                    }
                }
                break;
            case EVENT_SET_CPHS_MAILBOX_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                } else {
                    if (DBG)
                        log("Set CPHS MailBox with exception: " + ar.exception);
                }
                if (ar.userObj != null) {
                    if (DBG)
                        log("Callback with CPHS MB successful.");
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_SIM_REFRESH:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("Sim REFRESH with exception: " + ar.exception);
                if (ar.exception == null) {
                    handleSimRefresh((IccRefreshResponse) ar.result);
                }
                break;
            case EVENT_GET_CFIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCfis = null;
                } else {
                    log("EF_CFIS: " + IccUtils.bytesToHexString(data));
                    mEfCfis = data;
                }
                break;
            case EVENT_GET_CSP_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception in fetching EF_CSP data " + ar.exception);
                    break;
                }
                data = (byte[]) ar.result;
                log("EF_CSP: " + IccUtils.bytesToHexString(data));
                handleEfCspData(data);
                break;
            case EVENT_GET_GID1_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID1 " + ar.exception);
                    mGid1 = null;
                    break;
                }
                mGid1 = IccUtils.bytesToHexString(data);
                log("GID1: " + mGid1);
                break;
            case EVENT_GET_GID2_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID2 " + ar.exception);
                    mGid2 = null;
                    break;
                }
                mGid2 = IccUtils.bytesToHexString(data);
                log("GID2: " + mGid2);
                break;
            case EVENT_GET_PLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting User PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mPlmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("PlmnActRecords=" + Arrays.toString(mPlmnActRecords));
                }
                break;
            case EVENT_GET_OPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Operator PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mOplmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("OplmnActRecord[]=" + Arrays.toString(mOplmnActRecords));
                }
                break;
            case EVENT_GET_HPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Home PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mHplmnActRecords = PlmnActRecord.getRecords(data);
                    log("HplmnActRecord[]=" + Arrays.toString(mHplmnActRecords));
                }
                break;
            case EVENT_GET_EHPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Equivalent Home PLMNs: " + ar.exception);
                    break;
                } else {
                    mEhplmns = parseBcdPlmnList(data, "Equivalent Home");
                }
                break;
            case EVENT_GET_FPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Forbidden PLMNs: " + ar.exception);
                    break;
                } else {
                    mFplmns = parseBcdPlmnList(data, "Forbidden");
                }
                if (msg.arg1 == HANDLER_ACTION_SEND_RESPONSE) {
                    if (VDBG)
                        logv("getForbiddenPlmns(): send async response");
                    isRecordLoadResponse = false;
                    Message response = retrievePendingResponseMessage(msg.arg2);
                    if (response != null) {
                        AsyncResult.forMessage(response, Arrays.copyOf(mFplmns, mFplmns.length), null);
                        response.sendToTarget();
                    } else {
                        loge("Failed to retrieve a response message for FPLMN");
                        break;
                    }
                }
                break;
            case EVENT_CARRIER_CONFIG_CHANGED:
                handleCarrierNameOverride();
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        logw("Exception parsing SIM record", exc);
    } finally {
        // Count up record load responses even if they are fails
        if (isRecordLoadResponse) {
            onRecordLoaded();
        }
    }
}
#end_block

#method_before
private void handleSimRefresh(IccRefreshResponse refreshResponse) {
    if (refreshResponse == null) {
        if (DBG)
            log("handleSimRefresh received without input");
        return;
    }
    if (refreshResponse.aid != null && !refreshResponse.aid.equals(mParentApp.getAid())) {
        // This is for different app. Ignore.
        return;
    }
    switch(refreshResponse.refreshResult) {
        case IccRefreshResponse.REFRESH_RESULT_FILE_UPDATE:
            if (DBG)
                log("handleSimRefresh with SIM_FILE_UPDATED");
            handleFileUpdate(refreshResponse.efId);
            break;
        case IccRefreshResponse.REFRESH_RESULT_INIT:
            if (DBG)
                log("handleSimRefresh with SIM_REFRESH_INIT");
            // need to reload all files (that we care about)
            onIccRefreshInit();
            break;
        case IccRefreshResponse.REFRESH_RESULT_RESET:
            // Refresh reset is handled by the UiccCard object.
            if (DBG)
                log("handleSimRefresh with SIM_REFRESH_RESET");
            break;
        default:
            // unknown refresh operation
            if (DBG)
                log("handleSimRefresh with unknown operation");
            break;
    }
}
#method_after
private void handleSimRefresh(IccRefreshResponse refreshResponse) {
    if (refreshResponse == null) {
        if (DBG)
            log("handleSimRefresh received without input");
        return;
    }
    if (!TextUtils.isEmpty(refreshResponse.aid) && !refreshResponse.aid.equals(mParentApp.getAid())) {
        // This is for different app. Ignore.
        return;
    }
    switch(refreshResponse.refreshResult) {
        case IccRefreshResponse.REFRESH_RESULT_FILE_UPDATE:
            if (DBG)
                log("handleSimRefresh with SIM_FILE_UPDATED");
            handleFileUpdate(refreshResponse.efId);
            break;
        case IccRefreshResponse.REFRESH_RESULT_INIT:
            if (DBG)
                log("handleSimRefresh with SIM_REFRESH_INIT");
            // need to reload all files (that we care about)
            onIccRefreshInit();
            break;
        case IccRefreshResponse.REFRESH_RESULT_RESET:
            // Refresh reset is handled by the UiccCard object.
            if (DBG)
                log("handleSimRefresh with SIM_REFRESH_RESET");
            break;
        default:
            // unknown refresh operation
            if (DBG)
                log("handleSimRefresh with unknown operation");
            break;
    }
}
#end_block

#method_before
@Override
protected void onAllRecordsLoaded() {
    if (DBG)
        log("record load complete");
    Resources resource = Resources.getSystem();
    if (resource.getBoolean(com.android.internal.R.bool.config_use_sim_language_file)) {
        setSimLanguage(mEfLi, mEfPl);
    } else {
        if (DBG)
            log("Not using EF LI/EF PL");
    }
    setVoiceCallForwardingFlagFromSimRecords();
    if (mParentApp.getState() == AppState.APPSTATE_PIN || mParentApp.getState() == AppState.APPSTATE_PUK) {
        // reset recordsRequested, since sim is not loaded really
        mRecordsRequested = false;
        // lock state, only update language
        return;
    }
    // Some fields require more than one SIM record to set
    String operator = getOperatorNumeric();
    if (!TextUtils.isEmpty(operator)) {
        log("onAllRecordsLoaded set 'gsm.sim.operator.numeric' to operator='" + operator + "'");
        log("update icc_operator_numeric=" + operator);
        mTelephonyManager.setSimOperatorNumericForPhone(mParentApp.getPhoneId(), operator);
        final SubscriptionController subController = SubscriptionController.getInstance();
        subController.setMccMnc(operator, subController.getDefaultSubId());
    } else {
        log("onAllRecordsLoaded empty 'gsm.sim.operator.numeric' skipping");
    }
    if (!TextUtils.isEmpty(mImsi)) {
        log("onAllRecordsLoaded set mcc imsi" + (VDBG ? ("=" + mImsi) : ""));
        mTelephonyManager.setSimCountryIsoForPhone(mParentApp.getPhoneId(), MccTable.countryCodeForMcc(Integer.parseInt(mImsi.substring(0, 3))));
    } else {
        log("onAllRecordsLoaded empty imsi skipping setting mcc");
    }
    setVoiceMailByCountry(operator);
    mRecordsLoadedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
}
#method_after
@Override
protected void onAllRecordsLoaded() {
    if (DBG)
        log("record load complete");
    Resources resource = Resources.getSystem();
    if (resource.getBoolean(com.android.internal.R.bool.config_use_sim_language_file)) {
        setSimLanguage(mEfLi, mEfPl);
    } else {
        if (DBG)
            log("Not using EF LI/EF PL");
    }
    setVoiceCallForwardingFlagFromSimRecords();
    if (mParentApp.getState() == AppState.APPSTATE_PIN || mParentApp.getState() == AppState.APPSTATE_PUK) {
        // reset recordsRequested, since sim is not loaded really
        mRecordsRequested = false;
        // lock state, only update language
        return;
    }
    // Some fields require more than one SIM record to set
    String operator = getOperatorNumeric();
    if (!TextUtils.isEmpty(operator)) {
        log("onAllRecordsLoaded set 'gsm.sim.operator.numeric' to operator='" + operator + "'");
        mTelephonyManager.setSimOperatorNumericForPhone(mParentApp.getPhoneId(), operator);
    } else {
        log("onAllRecordsLoaded empty 'gsm.sim.operator.numeric' skipping");
    }
    String imsi = getIMSI();
    if (!TextUtils.isEmpty(imsi) && imsi.length() >= 3) {
        log("onAllRecordsLoaded set mcc imsi" + (VDBG ? ("=" + imsi) : ""));
        mTelephonyManager.setSimCountryIsoForPhone(mParentApp.getPhoneId(), MccTable.countryCodeForMcc(Integer.parseInt(imsi.substring(0, 3))));
    } else {
        log("onAllRecordsLoaded empty imsi skipping setting mcc");
    }
    setVoiceMailByCountry(operator);
    mRecordsLoadedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
}
#end_block

#method_before
// ***** Private methods
private void handleCarrierNameOverride() {
    CarrierConfigManager configLoader = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configLoader != null && configLoader.getConfig().getBoolean(CarrierConfigManager.KEY_CARRIER_NAME_OVERRIDE_BOOL)) {
        String carrierName = configLoader.getConfig().getString(CarrierConfigManager.KEY_CARRIER_NAME_STRING);
        setServiceProviderName(carrierName);
        mTelephonyManager.setSimOperatorNameForPhone(mParentApp.getPhoneId(), carrierName);
    } else {
        setSpnFromConfig(getOperatorNumeric());
    }
    setDisplayName();
}
#method_after
// ***** Private methods
private void handleCarrierNameOverride() {
    CarrierConfigManager configLoader = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configLoader != null && configLoader.getConfig().getBoolean(CarrierConfigManager.KEY_CARRIER_NAME_OVERRIDE_BOOL)) {
        String carrierName = configLoader.getConfig().getString(CarrierConfigManager.KEY_CARRIER_NAME_STRING);
        setServiceProviderName(carrierName);
        mTelephonyManager.setSimOperatorNameForPhone(mParentApp.getPhoneId(), carrierName);
    } else {
        setSpnFromConfig(getOperatorNumeric());
    }
    /* update display name with carrier override */
    setDisplayName();
}
#end_block

#method_before
private void parseEfSpdi(byte[] data) {
    SimTlv tlv = new SimTlv(data, 0, data.length);
    byte[] plmnEntries = null;
    for (; tlv.isValidObject(); tlv.nextObject()) {
        // Skip SPDI tag, if existant
        if (tlv.getTag() == TAG_SPDI) {
            tlv = new SimTlv(tlv.getData(), 0, tlv.getData().length);
        }
        // There should only be one TAG_SPDI_PLMN_LIST
        if (tlv.getTag() == TAG_SPDI_PLMN_LIST) {
            plmnEntries = tlv.getData();
            break;
        }
    }
    if (plmnEntries == null) {
        return;
    }
    mSpdiNetworks = new ArrayList<String>(plmnEntries.length / 3);
    for (int i = 0; i + 2 < plmnEntries.length; i += 3) {
        String plmnCode;
        plmnCode = IccUtils.bcdToString(plmnEntries, i, 3);
        // Valid operator codes are 5 or 6 digits
        if (plmnCode.length() >= 5) {
            log("EF_SPDI network: " + plmnCode);
            mSpdiNetworks.add(plmnCode);
        }
    }
}
#method_after
private void parseEfSpdi(byte[] data) {
    SimTlv tlv = new SimTlv(data, 0, data.length);
    byte[] plmnEntries = null;
    for (; tlv.isValidObject(); tlv.nextObject()) {
        // Skip SPDI tag, if existant
        if (tlv.getTag() == TAG_SPDI) {
            tlv = new SimTlv(tlv.getData(), 0, tlv.getData().length);
        }
        // There should only be one TAG_SPDI_PLMN_LIST
        if (tlv.getTag() == TAG_SPDI_PLMN_LIST) {
            plmnEntries = tlv.getData();
            break;
        }
    }
    if (plmnEntries == null) {
        return;
    }
    mSpdiNetworks = new ArrayList<String>(plmnEntries.length / 3);
    for (int i = 0; i + 2 < plmnEntries.length; i += 3) {
        String plmnCode;
        plmnCode = IccUtils.bcdPlmnToString(plmnEntries, i);
        // Valid operator codes are 5 or 6 digits
        if (plmnCode != null && plmnCode.length() >= 5) {
            log("EF_SPDI network: " + plmnCode);
            mSpdiNetworks.add(plmnCode);
        }
    }
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("SIMRecords: " + this);
    pw.println(" extends:");
    super.dump(fd, pw, args);
    pw.println(" mVmConfig=" + mVmConfig);
    pw.println(" mSpnOverride=" + mSpnOverride);
    pw.println(" mCallForwardingStatus=" + mCallForwardingStatus);
    pw.println(" mSpnState=" + mSpnState);
    pw.println(" mCphsInfo=" + mCphsInfo);
    pw.println(" mCspPlmnEnabled=" + mCspPlmnEnabled);
    pw.println(" mEfMWIS[]=" + Arrays.toString(mEfMWIS));
    pw.println(" mEfCPHS_MWI[]=" + Arrays.toString(mEfCPHS_MWI));
    pw.println(" mEfCff[]=" + Arrays.toString(mEfCff));
    pw.println(" mEfCfis[]=" + Arrays.toString(mEfCfis));
    pw.println(" mSpnDisplayCondition=" + mSpnDisplayCondition);
    pw.println(" mSpdiNetworks[]=" + mSpdiNetworks);
    pw.println(" mPnnHomeName=" + mPnnHomeName);
    pw.println(" mUsimServiceTable=" + mUsimServiceTable);
    pw.println(" mGid1=" + mGid1);
    pw.println(" mGid2=" + mGid2);
    pw.println(" mPlmnActRecords[]=" + Arrays.toString(mPlmnActRecords));
    pw.println(" mOplmnActRecords[]=" + Arrays.toString(mOplmnActRecords));
    pw.println(" mHplmnActRecords[]=" + Arrays.toString(mHplmnActRecords));
    pw.println(" mFplmns[]=" + Arrays.toString(mFplmns));
    pw.println(" mEhplmns[]=" + Arrays.toString(mEhplmns));
    pw.flush();
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("SIMRecords: " + this);
    pw.println(" extends:");
    super.dump(fd, pw, args);
    pw.println(" mVmConfig=" + mVmConfig);
    pw.println(" mSpnOverride=" + mSpnOverride);
    pw.println(" mCallForwardingStatus=" + mCallForwardingStatus);
    pw.println(" mSpnState=" + mSpnState);
    pw.println(" mCphsInfo=" + mCphsInfo);
    pw.println(" mCspPlmnEnabled=" + mCspPlmnEnabled);
    pw.println(" mEfMWIS[]=" + Arrays.toString(mEfMWIS));
    pw.println(" mEfCPHS_MWI[]=" + Arrays.toString(mEfCPHS_MWI));
    pw.println(" mEfCff[]=" + Arrays.toString(mEfCff));
    pw.println(" mEfCfis[]=" + Arrays.toString(mEfCfis));
    pw.println(" mSpnDisplayCondition=" + mSpnDisplayCondition);
    pw.println(" mSpdiNetworks[]=" + mSpdiNetworks);
    pw.println(" mPnnHomeName=" + mPnnHomeName);
    pw.println(" mUsimServiceTable=" + mUsimServiceTable);
    pw.println(" mGid1=" + mGid1);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeGid1=" + ((mFakeGid1 != null) ? mFakeGid1 : "null"));
    }
    pw.println(" mGid2=" + mGid2);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeGid2=" + ((mFakeGid2 != null) ? mFakeGid2 : "null"));
    }
    pw.println(" mPlmnActRecords[]=" + Arrays.toString(mPlmnActRecords));
    pw.println(" mOplmnActRecords[]=" + Arrays.toString(mOplmnActRecords));
    pw.println(" mHplmnActRecords[]=" + Arrays.toString(mHplmnActRecords));
    pw.println(" mFplmns[]=" + Arrays.toString(mFplmns));
    pw.println(" mEhplmns[]=" + Arrays.toString(mEhplmns));
    pw.flush();
}
#end_block

#method_before
private int readBytes(byte[] b, int off, int len) throws IOException {
    // Android-changed: Implement on top of low-level API, not directly natively.
    ioTracker.trackIo(len, IoTracker.Mode.READ);
    return IoBridge.read(fd, b, off, len);
}
#method_after
private int readBytes(byte[] b, int off, int len) throws IOException {
    // Android-changed: Implement on top of libcore os API.
    ioTracker.trackIo(len, IoTracker.Mode.READ);
    return IoBridge.read(fd, b, off, len);
}
#end_block

#method_before
// 'Write' primitives
public void write(int b) throws IOException {
    // Android-changed: Implement on top of low-level API, not directly natively.
    // write0(b);
    scratch[0] = (byte) (b & 0xff);
    write(scratch, 0, 1);
}
#method_after
// 'Write' primitives
public void write(int b) throws IOException {
    // BEGIN Android-changed: Implement on top of libcore os API.
    // write0(b);
    scratch[0] = (byte) (b & 0xff);
    write(scratch, 0, 1);
// END Android-changed: Implement on top of libcore os API.
}
#end_block

#method_before
private void writeBytes(byte[] b, int off, int len) throws IOException {
    // Android-changed: Implement on top of low-level API, not directly natively.
    ioTracker.trackIo(len, IoTracker.Mode.WRITE);
    IoBridge.write(fd, b, off, len);
    // if we are in "rws" mode, attempt to sync file+metadata
    maybeSync();
}
#method_after
private void writeBytes(byte[] b, int off, int len) throws IOException {
    // BEGIN Android-changed: Implement on top of libcore os API.
    ioTracker.trackIo(len, IoTracker.Mode.WRITE);
    IoBridge.write(fd, b, off, len);
    maybeSync();
// END Android-changed: Implement on top of libcore os API.
}
#end_block

#method_before
// 'Random access' stuff
public long getFilePointer() throws IOException {
    // Android-changed: Implement on top of low-level API, not directly natively.
    try {
        return Libcore.os.lseek(fd, 0L, SEEK_CUR);
    } catch (ErrnoException errnoException) {
        throw errnoException.rethrowAsIOException();
    }
}
#method_after
// 'Random access' stuff
public long getFilePointer() throws IOException {
    // BEGIN Android-changed: Implement on top of libcore os API.
    try {
        return Libcore.os.lseek(fd, 0L, SEEK_CUR);
    } catch (ErrnoException errnoException) {
        throw errnoException.rethrowAsIOException();
    }
// END Android-changed: Implement on top of libcore os API.
}
#end_block

#method_before
public void seek(long pos) throws IOException {
    if (pos < 0) {
        // throw new IOException("Negative seek offset");
        throw new IOException("offset < 0: " + pos);
    } else {
        // seek0(pos);
        try {
            Libcore.os.lseek(fd, pos, SEEK_SET);
            ioTracker.reset();
        } catch (ErrnoException errnoException) {
            throw errnoException.rethrowAsIOException();
        }
    }
}
#method_after
public void seek(long pos) throws IOException {
    if (pos < 0) {
        // throw new IOException("Negative seek offset");
        throw new IOException("offset < 0: " + pos);
    } else {
        // seek0(pos);
        try {
            Libcore.os.lseek(fd, pos, SEEK_SET);
            ioTracker.reset();
        } catch (ErrnoException errnoException) {
            throw errnoException.rethrowAsIOException();
        }
    // END Android-changed: Implement on top of libcore os API.
    }
}
#end_block

#method_before
public long length() throws IOException {
    // Android-changed: Implement on top of low-level API, not directly natively.
    try {
        return Libcore.os.fstat(fd).st_size;
    } catch (ErrnoException errnoException) {
        throw errnoException.rethrowAsIOException();
    }
}
#method_after
public long length() throws IOException {
    // BEGIN Android-changed: Implement on top of libcore os API.
    try {
        return Libcore.os.fstat(fd).st_size;
    } catch (ErrnoException errnoException) {
        throw errnoException.rethrowAsIOException();
    }
// END Android-changed: Implement on top of libcore os API.
}
#end_block

#method_before
public void setLength(long newLength) throws IOException {
    // BEGIN Android-changed: Implement on top of low-level API, not directly natively.
    if (newLength < 0) {
        throw new IllegalArgumentException("newLength < 0");
    }
    try {
        Libcore.os.ftruncate(fd, newLength);
    } catch (ErrnoException errnoException) {
        throw errnoException.rethrowAsIOException();
    }
    long filePointer = getFilePointer();
    if (filePointer > newLength) {
        seek(newLength);
    }
    // if we are in "rw[sd]" mode, attempt to sync file and maybe metadata
    maybeSync();
// END Android-changed: Implement on top of low-level API, not directly natively.
}
#method_after
public void setLength(long newLength) throws IOException {
    // BEGIN Android-changed: Implement on top of libcore os API.
    if (newLength < 0) {
        throw new IllegalArgumentException("newLength < 0");
    }
    try {
        Libcore.os.ftruncate(fd, newLength);
    } catch (ErrnoException errnoException) {
        throw errnoException.rethrowAsIOException();
    }
    long filePointer = getFilePointer();
    if (filePointer > newLength) {
        seek(newLength);
    }
    maybeSync();
// END Android-changed: Implement on top of libcore os API.
}
#end_block

#method_before
public void close() throws IOException {
    guard.close();
    synchronized (closeLock) {
        if (closed) {
            return;
        }
        closed = true;
    }
    // BEGIN Android-changed: Implement on top of low-level API, not directly natively.
    if (channel != null && channel.isOpen()) {
        channel.close();
    }
    IoBridge.closeAndSignalBlockedThreads(fd);
// END Android-changed: Implement on top of low-level API, not directly natively.
}
#method_after
public void close() throws IOException {
    guard.close();
    synchronized (closeLock) {
        if (closed) {
            return;
        }
        closed = true;
    }
    // BEGIN Android-changed: Implement on top of libcore os API.
    if (channel != null && channel.isOpen()) {
        channel.close();
    }
    IoBridge.closeAndSignalBlockedThreads(fd);
// END Android-changed: Implement on top of libcore os API.
}
#end_block

#method_before
public static GsmMmiCode newFromDialString(String dialString, GsmCdmaPhone phone, UiccCardApplication app, ResultReceiver wrappedCallback) {
    Matcher m;
    GsmMmiCode ret = null;
    m = sPatternSuppService.matcher(dialString);
    // Is this formatted like a standard supplementary service code?
    if (m.matches()) {
        ret = new GsmMmiCode(phone, app);
        ret.mPoundString = makeEmptyNull(m.group(MATCH_GROUP_POUND_STRING));
        ret.mAction = makeEmptyNull(m.group(MATCH_GROUP_ACTION));
        ret.mSc = makeEmptyNull(m.group(MATCH_GROUP_SERVICE_CODE));
        ret.mSia = makeEmptyNull(m.group(MATCH_GROUP_SIA));
        ret.mSib = makeEmptyNull(m.group(MATCH_GROUP_SIB));
        ret.mSic = makeEmptyNull(m.group(MATCH_GROUP_SIC));
        ret.mPwd = makeEmptyNull(m.group(MATCH_GROUP_PWD_CONFIRM));
        ret.mDialingNumber = makeEmptyNull(m.group(MATCH_GROUP_DIALING_NUMBER));
        ret.mCallbackReceiver = wrappedCallback;
        if (ret.mDialingNumber != null && ret.mDialingNumber.endsWith("#") && dialString.endsWith("#")) {
            // According to TS 22.030 6.5.2 "Structure of the MMI",
            // the dialing number should not ending with #.
            // The dialing number ending # is treated as unique USSD,
            // eg, *400#16 digit number# to recharge the prepaid card
            // in India operator(Mumbai MTNL)
            ret = new GsmMmiCode(phone, app);
            ret.mPoundString = dialString;
        } else if (ret.isFacToDial()) {
            // It checks whether it is FAC to dial as a normally call.
            ret = null;
        }
    } else if (dialString.endsWith("#")) {
        // TS 22.030 sec 6.5.3.2
        // "Entry of any characters defined in the 3GPP TS 23.038 [8] Default Alphabet
        // (up to the maximum defined in 3GPP TS 24.080 [10]), followed by #SEND".
        ret = new GsmMmiCode(phone, app);
        ret.mPoundString = dialString;
    } else if (isTwoDigitShortCode(phone.getContext(), dialString)) {
        // Is a country-specific exception to short codes as defined in TS 22.030, 6.5.3.2
        ret = null;
    } else if (isShortCode(dialString, phone)) {
        // this may be a short code, as defined in TS 22.030, 6.5.3.2
        ret = new GsmMmiCode(phone, app);
        ret.mDialingNumber = dialString;
    }
    return ret;
}
#method_after
public static GsmMmiCode newFromDialString(String dialString, GsmCdmaPhone phone, UiccCardApplication app, ResultReceiver wrappedCallback) {
    Matcher m;
    GsmMmiCode ret = null;
    if (phone.getServiceState().getVoiceRoaming() && phone.supportsConversionOfCdmaCallerIdMmiCodesWhileRoaming()) {
        /* The CDMA MMI coded dialString will be converted to a 3GPP MMI Coded dialString
               so that it can be processed by the matcher and code below
             */
        dialString = convertCdmaMmiCodesTo3gppMmiCodes(dialString);
    }
    m = sPatternSuppService.matcher(dialString);
    // Is this formatted like a standard supplementary service code?
    if (m.matches()) {
        ret = new GsmMmiCode(phone, app);
        ret.mPoundString = makeEmptyNull(m.group(MATCH_GROUP_POUND_STRING));
        ret.mAction = makeEmptyNull(m.group(MATCH_GROUP_ACTION));
        ret.mSc = makeEmptyNull(m.group(MATCH_GROUP_SERVICE_CODE));
        ret.mSia = makeEmptyNull(m.group(MATCH_GROUP_SIA));
        ret.mSib = makeEmptyNull(m.group(MATCH_GROUP_SIB));
        ret.mSic = makeEmptyNull(m.group(MATCH_GROUP_SIC));
        ret.mPwd = makeEmptyNull(m.group(MATCH_GROUP_PWD_CONFIRM));
        ret.mDialingNumber = makeEmptyNull(m.group(MATCH_GROUP_DIALING_NUMBER));
        ret.mCallbackReceiver = wrappedCallback;
        if (ret.mDialingNumber != null && ret.mDialingNumber.endsWith("#") && dialString.endsWith("#")) {
            // According to TS 22.030 6.5.2 "Structure of the MMI",
            // the dialing number should not ending with #.
            // The dialing number ending # is treated as unique USSD,
            // eg, *400#16 digit number# to recharge the prepaid card
            // in India operator(Mumbai MTNL)
            ret = new GsmMmiCode(phone, app);
            ret.mPoundString = dialString;
        } else if (ret.isFacToDial()) {
            // This is a FAC (feature access code) to dial as a normal call.
            ret = null;
        }
    } else if (dialString.endsWith("#")) {
        // TS 22.030 sec 6.5.3.2
        // "Entry of any characters defined in the 3GPP TS 23.038 [8] Default Alphabet
        // (up to the maximum defined in 3GPP TS 24.080 [10]), followed by #SEND".
        ret = new GsmMmiCode(phone, app);
        ret.mPoundString = dialString;
    } else if (isTwoDigitShortCode(phone.getContext(), dialString)) {
        // Is a country-specific exception to short codes as defined in TS 22.030, 6.5.3.2
        ret = null;
    } else if (isShortCode(dialString, phone)) {
        // this may be a short code, as defined in TS 22.030, 6.5.3.2
        ret = new GsmMmiCode(phone, app);
        ret.mDialingNumber = dialString;
    }
    return ret;
}
#end_block

#method_before
private boolean isFacToDial() {
    CarrierConfigManager configManager = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    PersistableBundle b = configManager.getConfigForSubId(mPhone.getSubId());
    String[] dialFacList = b.getStringArray(CarrierConfigManager.KEY_ENABLE_DIAL_FAC_STRING_ARRAY);
    if (!ArrayUtils.isEmpty(dialFacList)) {
        for (String fac : dialFacList) {
            if (fac.equals(mSc)) {
                return true;
            }
        }
    }
    return false;
}
#method_after
private boolean isFacToDial() {
    CarrierConfigManager configManager = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    PersistableBundle b = configManager.getConfigForSubId(mPhone.getSubId());
    if (b != null) {
        String[] dialFacList = b.getStringArray(CarrierConfigManager.KEY_FEATURE_ACCESS_CODES_STRING_ARRAY);
        if (!ArrayUtils.isEmpty(dialFacList)) {
            for (String fac : dialFacList) {
                if (fac.equals(mSc)) {
                    return true;
                }
            }
        }
    }
    return false;
}
#end_block

#method_before
// The logic here is aimed solely at confirming that a CarrierConfig exists
// and affirms that entitlement checks are not required.
// 
// TODO: find a better way to express this, or alter the checking process
private boolean carrierConfigAffirmsEntitlementCheckNotRequired() {
    // Check carrier config for entitlement checks
    final CarrierConfigManager configManager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager == null)
        return false;
    final PersistableBundle carrierConfig = configManager.getConfig();
    if (carrierConfig == null)
        return false;
    // We do have a CarrierConfigManager and it has a config.
    final boolean isEntitlementCheckRequired = carrierConfig.getBoolean(CarrierConfigManager.KEY_REQUIRE_ENTITLEMENT_CHECKS_BOOL);
    return !isEntitlementCheckRequired;
}
#method_after
// The logic here is aimed solely at confirming that a CarrierConfig exists
// and affirms that entitlement checks are not required.
// 
// TODO: find a better way to express this, or alter the checking process
private boolean carrierConfigAffirmsEntitlementCheckNotRequired() {
    // Check carrier config for entitlement checks
    final CarrierConfigManager configManager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager == null)
        return false;
    final PersistableBundle carrierConfig = configManager.getConfig();
    if (carrierConfig == null)
        return false;
    // A CarrierConfigManager was found and it has a config.
    final boolean isEntitlementCheckRequired = carrierConfig.getBoolean(CarrierConfigManager.KEY_REQUIRE_ENTITLEMENT_CHECKS_BOOL);
    return !isEntitlementCheckRequired;
}
#end_block

#method_before
@Override
public void onReceive(Context content, Intent intent) {
    final String action = intent.getAction();
    if (action == null)
        return;
    if (action.equals(UsbManager.ACTION_USB_STATE)) {
        handleUsbAction(intent);
    } else if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
        handleConnectivityAction(intent);
    } else if (action.equals(WifiManager.WIFI_AP_STATE_CHANGED_ACTION)) {
        handleWifiApAction(intent);
    } else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        updateConfiguration();
    }
}
#method_after
@Override
public void onReceive(Context content, Intent intent) {
    final String action = intent.getAction();
    if (action == null)
        return;
    if (action.equals(UsbManager.ACTION_USB_STATE)) {
        handleUsbAction(intent);
    } else if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
        handleConnectivityAction(intent);
    } else if (action.equals(WifiManager.WIFI_AP_STATE_CHANGED_ACTION)) {
        handleWifiApAction(intent);
    } else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        mLog.log("OBSERVED configuration changed");
        updateConfiguration();
    }
}
#end_block

#method_before
@Test
public void generateVerityTreeRootHashFromDummyDataSource() throws Exception {
    // This sample was taken from src/test/resources/com/android/apksig/original.apk.
    byte[] sampleEoCDFromDisk = new byte[] { 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x06, 0x00, 0x79, 0x01, 0x00, 0x00, 0x30, 0x16, 0x00, 0x00, 0x00, 0x00 };
    VerityTreeBuilder builder = new VerityTreeBuilder(null);
    byte[] rootHash = builder.generateVerityTreeRootHash(// before APK Signing Block
    DataSources.asDataSource(ByteBuffer.allocate(4096)), makeStringDataSource("this is central directory (fake data)"), DataSources.asDataSource(ByteBuffer.wrap(sampleEoCDFromDisk)));
    assertEquals("db4176e0d6c3660a7072d9f7ae0053ba16a4a29df348627c79e1d786cf6c2931", HexEncoding.encode(rootHash));
}
#method_after
@Test
public void generateVerityTreeRootHashFromDummyDataSource() throws Exception {
    // This sample was taken from src/test/resources/com/android/apksig/original.apk.
    byte[] sampleEoCDFromDisk = new byte[] { 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x06, 0x00, 0x79, 0x01, 0x00, 0x00, 0x30, 0x16, 0x00, 0x00, 0x00, 0x00 };
    VerityTreeBuilder builder = new VerityTreeBuilder(null);
    byte[] rootHash = builder.generateVerityTreeRootHash(// before APK Signing Block
    DataSources.asDataSource(ByteBuffer.allocate(4096)), makeStringDataSource("this is central directory (fake data)"), DataSources.asDataSource(ByteBuffer.wrap(sampleEoCDFromDisk)));
    assertEquals("7ddb07e6a24ed786ec6edd19cb4f823fb1d657a81ba531e93fe70fdf5b9988ba", HexEncoding.encode(rootHash));
}
#end_block

#method_before
@Test
public void feedAllPossibleRanges() throws Exception {
    for (int begin = 0; begin < mChain.size(); begin++) {
        for (int end = begin + 1; end < mChain.size(); end++) {
            int size = end - begin;
            ReadableDataSink sink = DataSinks.newInMemoryDataSink(size);
            mChain.feed(begin, size, sink);
            assertArrayEquals("1234567890".substring(begin, end).getBytes(), sink.getByteBuffer(0, size).array());
        }
    }
}
#method_after
@Test
public void feedAllPossibleRanges() throws Exception {
    for (int begin = 0; begin < mChain.size(); begin++) {
        for (int end = begin + 1; end < mChain.size(); end++) {
            int size = end - begin;
            ReadableDataSink sink = DataSinks.newInMemoryDataSink(size);
            mChain.feed(begin, size, sink);
            assertByteBufferEquals(ByteBuffer.wrap("1234567890".substring(begin, end).getBytes()), sink.getByteBuffer(0, size));
        }
    }
}
#end_block

#method_before
@Test
public void getByteBufferFromAllPossibleRanges() throws Exception {
    for (int begin = 0; begin < mChain.size(); begin++) {
        for (int end = begin + 1; end < mChain.size(); end++) {
            int size = end - begin;
            ByteBuffer buffer = mChain.getByteBuffer(begin, size);
            assertArrayEquals("1234567890".substring(begin, end).getBytes(), buffer.array());
        }
    }
}
#method_after
@Test
public void getByteBufferFromAllPossibleRanges() throws Exception {
    for (int begin = 0; begin < mChain.size(); begin++) {
        for (int end = begin + 1; end < mChain.size(); end++) {
            int size = end - begin;
            ByteBuffer buffer = mChain.getByteBuffer(begin, size);
            assertByteBufferEquals(ByteBuffer.wrap("1234567890".substring(begin, end).getBytes()), buffer);
        }
    }
}
#end_block

#method_before
@Test
public void copyTo() throws Exception {
    for (int begin = 0; begin < mChain.size(); begin++) {
        for (int end = begin + 1; end < mChain.size(); end++) {
            int size = end - begin;
            ByteBuffer buffer = ByteBuffer.allocate(size);
            mChain.copyTo(begin, size, buffer);
            assertArrayEquals("1234567890".substring(begin, end).getBytes(), buffer.array());
        }
    }
}
#method_after
@Test
public void copyTo() throws Exception {
    for (int begin = 0; begin < mChain.size(); begin++) {
        for (int end = begin + 1; end < mChain.size(); end++) {
            int size = end - begin;
            ByteBuffer buffer = ByteBuffer.allocate(size);
            mChain.copyTo(begin, size, buffer);
            assertEquals(size, buffer.position());
            buffer.rewind();
            assertByteBufferEquals(ByteBuffer.wrap("1234567890".substring(begin, end).getBytes()), buffer);
        }
    }
}
#end_block

#method_before
@Override
public void feed(long offset, long size, DataSink sink) throws IOException {
    if (offset + size > mTotalSize) {
        throw new IndexOutOfBoundsException("Requested more than available");
    }
    ByteBuffer buffer = null;
    for (DataSource src : mSources) {
        // Offset is beyond the current source. Skip.
        if (offset >= src.size()) {
            offset -= src.size();
            continue;
        }
        // If the remaining is enough, finish it.
        long remaining = src.size() - offset;
        if (remaining >= size) {
            // then feed them at once.
            if (buffer != null) {
                if (offset != 0) {
                    throw new IllegalStateException("Cannot skip continuous data");
                }
                src.copyTo(offset, Math.toIntExact(size), buffer);
                break;
            }
            // If everything is within the current source, just consume the slice.
            sink.consume(src.getByteBuffer(offset, Math.toIntExact(size)));
            return;
        }
        // still feed the sink at once.
        if (buffer == null) {
            buffer = ByteBuffer.allocate(Math.toIntExact(size));
        }
        src.copyTo(offset, Math.toIntExact(remaining), buffer);
        size -= remaining;
        offset = 0;
    }
    if (buffer != null) {
        buffer.rewind();
        sink.consume(buffer);
    }
}
#method_after
@Override
public void feed(long offset, long size, DataSink sink) throws IOException {
    if (offset + size > mTotalSize) {
        throw new IndexOutOfBoundsException("Requested more than available");
    }
    for (DataSource src : mSources) {
        // Offset is beyond the current source. Skip.
        if (offset >= src.size()) {
            offset -= src.size();
            continue;
        }
        // If the remaining is enough, finish it.
        long remaining = src.size() - offset;
        if (remaining >= size) {
            src.feed(offset, size, sink);
            break;
        }
        // If the remaining is not enough, consume all.
        src.feed(offset, remaining, sink);
        size -= remaining;
        offset = 0;
    }
}
#end_block

#method_before
@Override
public ByteBuffer getByteBuffer(long offset, int size) throws IOException {
    if (offset + size > mTotalSize) {
        throw new IndexOutOfBoundsException("Requested more than available");
    }
    ReadableDataSink sink = DataSinks.newInMemoryDataSink(size);
    feed(offset, size, sink);
    return sink.getByteBuffer(0, size);
}
#method_after
@Override
public ByteBuffer getByteBuffer(long offset, int size) throws IOException {
    if (offset + size > mTotalSize) {
        throw new IndexOutOfBoundsException("Requested more than available");
    }
    // Skip to the first DataSource we need.
    Pair<Integer, Long> firstSource = locateDataSource(offset);
    int i = firstSource.getFirst();
    offset = firstSource.getSecond();
    // Return the current source's ByteBuffer if it fits.
    if (offset + size <= mSources[i].size()) {
        return mSources[i].getByteBuffer(offset, size);
    }
    // Otherwise, read into a new buffer.
    ByteBuffer buffer = ByteBuffer.allocate(size);
    for (; i < mSources.length && buffer.hasRemaining(); i++) {
        long sizeToCopy = Math.min(mSources[i].size() - offset, buffer.remaining());
        mSources[i].copyTo(offset, Math.toIntExact(sizeToCopy), buffer);
        // may not be zero for the first source, but reset after that.
        offset = 0;
    }
    buffer.rewind();
    return buffer;
}
#end_block

#method_before
@Override
public DataSource slice(long offset, long size) {
    throw new UnsupportedOperationException("Not implemented");
}
#method_after
@Override
public DataSource slice(long offset, long size) {
    // Find the first slice.
    Pair<Integer, Long> firstSource = locateDataSource(offset);
    int beginIndex = firstSource.getFirst();
    long beginLocalOffset = firstSource.getSecond();
    DataSource beginSource = mSources[beginIndex];
    if (beginLocalOffset + size <= beginSource.size()) {
        return beginSource.slice(beginLocalOffset, size);
    }
    // Add the first slice to chaining, followed by the middle full slices, then the last.
    ArrayList<DataSource> sources = new ArrayList<>();
    sources.add(beginSource.slice(beginLocalOffset, beginSource.size() - beginLocalOffset));
    Pair<Integer, Long> lastSource = locateDataSource(offset + size);
    int endIndex = lastSource.getFirst();
    long endLocalOffset = lastSource.getSecond();
    for (int i = beginIndex + 1; i < endIndex - 1; i++) {
        sources.add(mSources[i]);
    }
    sources.add(mSources[endIndex].slice(0, endLocalOffset));
    return new ChainedDataSource(sources.toArray(new DataSource[0]));
}
#end_block

#method_before
public byte[] generateVerityTreeRootHash(DataSource beforeApkSigningBlock, DataSource centralDir, DataSource eocd) throws IOException {
    if (beforeApkSigningBlock.size() % CHUNK_SIZE != 0) {
        throw new IllegalStateException("APK Signing Block is not page aligned");
    }
    DataSource modifiedEocd = DataSources.asDataSource(EocdRecord.createWithCentralDirectoryFieldHidden(eocd.getByteBuffer(0, (int) eocd.size())));
    return generateVerityTreeRootHash(new ChainedDataSource(beforeApkSigningBlock, centralDir, modifiedEocd));
}
#method_after
public byte[] generateVerityTreeRootHash(DataSource beforeApkSigningBlock, DataSource centralDir, DataSource eocd) throws IOException {
    if (beforeApkSigningBlock.size() % CHUNK_SIZE != 0) {
        throw new IllegalStateException("APK Signing Block size not a multiple of " + CHUNK_SIZE + ": " + beforeApkSigningBlock.size());
    }
    // Ensure that, when digesting, ZIP End of Central Directory record's Central Directory
    // offset field is treated as pointing to the offset at which the APK Signing Block will
    // start.
    long centralDirOffsetForDigesting = beforeApkSigningBlock.size();
    ByteBuffer eocdBuf = ByteBuffer.allocate((int) eocd.size());
    eocdBuf.order(ByteOrder.LITTLE_ENDIAN);
    eocd.copyTo(0, (int) eocd.size(), eocdBuf);
    eocdBuf.flip();
    ZipUtils.setZipEocdCentralDirectoryOffset(eocdBuf, centralDirOffsetForDigesting);
    return generateVerityTreeRootHash(new ChainedDataSource(beforeApkSigningBlock, centralDir, DataSources.asDataSource(eocdBuf)));
}
#end_block

#method_before
public void reset() {
    mReport = "";
    mReportValid = false;
    Log.d(TAG, "reset");
}
#method_after
public void reset() {
    mReport = "";
    mReportValid = false;
}
#end_block

#method_before
public void calculateAndReportScore(WifiInfo wifiInfo, NetworkAgent networkAgent, int aggressiveHandover, WifiMetrics wifiMetrics) {
    int score;
    if (aggressiveHandover == 0) {
        // Use the old method
        updateScoringState(wifiInfo, aggressiveHandover);
        score = calculateScore(wifiInfo, aggressiveHandover);
    } else {
        score = scorer(wifiInfo);
    }
    // sanitize boundaries
    if (score > NetworkAgent.WIFI_BASE_SCORE) {
        score = NetworkAgent.WIFI_BASE_SCORE;
    }
    if (score < 0) {
        score = 0;
    }
    // report score
    if (score != wifiInfo.score) {
        if (mVerboseLoggingEnabled) {
            Log.d(TAG, " report new wifi score " + score);
        }
        wifiInfo.score = score;
        if (networkAgent != null) {
            networkAgent.sendNetworkScore(score);
        }
    }
    mReport = String.format(" score=%d", score);
    mReportValid = true;
    wifiMetrics.incrementWifiScoreCount(score);
}
#method_after
public void calculateAndReportScore(WifiInfo wifiInfo, NetworkAgent networkAgent, int aggressiveHandover, WifiMetrics wifiMetrics) {
    int score;
    if (aggressiveHandover == 0) {
        // Use the old method
        updateScoringState(wifiInfo, aggressiveHandover);
        score = calculateScore(wifiInfo, aggressiveHandover);
    } else {
        score = calculateAlternativeScore(wifiInfo);
    }
    // sanitize boundaries
    if (score > NetworkAgent.WIFI_BASE_SCORE) {
        score = NetworkAgent.WIFI_BASE_SCORE;
    }
    if (score < 0) {
        score = 0;
    }
    // report score
    if (score != wifiInfo.score) {
        if (mVerboseLoggingEnabled) {
            Log.d(TAG, " report new wifi score " + score);
        }
        wifiInfo.score = score;
        if (networkAgent != null) {
            networkAgent.sendNetworkScore(score);
        }
    }
    mReport = String.format(" score=%d", score);
    mReportValid = true;
    wifiMetrics.incrementWifiScoreCount(score);
}
#end_block

#method_before
// BEGIN Android-removed: Reimplement provider selection.
// See android-note.
/*
    // Provider attribute name for supported chaining mode
    private final static String ATTR_MODE = "SupportedModes";
    // Provider attribute name for supported padding names
    private final static String ATTR_PAD  = "SupportedPaddings";

    // constants indicating whether the provider supports
    // a given mode or padding
    private final static int S_NO    = 0;       // does not support
    private final static int S_MAYBE = 1;       // unable to determine
    private final static int S_YES   = 2;       // does support

    /**
     * Nested class to deal with modes and paddings.
     *
    private static class Transform {
        // transform string to lookup in the provider
        final String transform;
        // the mode/padding suffix in upper case. for example, if the algorithm
        // to lookup is "DES/CBC/PKCS5Padding" suffix is "/CBC/PKCS5PADDING"
        // if loopup is "DES", suffix is the empty string
        // needed because aliases prevent straight transform.equals()
        final String suffix;
        // value to pass to setMode() or null if no such call required
        final String mode;
        // value to pass to setPadding() or null if no such call required
        final String pad;
        Transform(String alg, String suffix, String mode, String pad) {
            this.transform = alg + suffix;
            this.suffix = suffix.toUpperCase(Locale.ENGLISH);
            this.mode = mode;
            this.pad = pad;
        }
        // set mode and padding for the given SPI
        void setModePadding(CipherSpi spi) throws NoSuchAlgorithmException,
                NoSuchPaddingException {
            if (mode != null) {
                spi.engineSetMode(mode);
            }
            if (pad != null) {
                spi.engineSetPadding(pad);
            }
        }
        // check whether the given services supports the mode and
        // padding described by this Transform
        int supportsModePadding(Service s) {
            int smode = supportsMode(s);
            if (smode == S_NO) {
                return smode;
            }
            int spad = supportsPadding(s);
            // our constants are defined so that Math.min() is a tri-valued AND
            return Math.min(smode, spad);
        }

        // separate methods for mode and padding
        // called directly by Cipher only to throw the correct exception
        int supportsMode(Service s) {
            return supports(s, ATTR_MODE, mode);
        }
        int supportsPadding(Service s) {
            return supports(s, ATTR_PAD, pad);
        }

        private static int supports(Service s, String attrName, String value) {
            if (value == null) {
                return S_YES;
            }
            String regexp = s.getAttribute(attrName);
            if (regexp == null) {
                return S_MAYBE;
            }
            return matches(regexp, value) ? S_YES : S_NO;
        }

        // ConcurrentMap<String,Pattern> for previously compiled patterns
        private final static ConcurrentMap<String, Pattern> patternCache =
            new ConcurrentHashMap<String, Pattern>();

        private static boolean matches(String regexp, String str) {
            Pattern pattern = patternCache.get(regexp);
            if (pattern == null) {
                pattern = Pattern.compile(regexp);
                patternCache.putIfAbsent(regexp, pattern);
            }
            return pattern.matcher(str.toUpperCase(Locale.ENGLISH)).matches();
        }

    }

    private static List<Transform> getTransforms(String transformation)
            throws NoSuchAlgorithmException {
        String[] parts = tokenizeTransformation(transformation);

        String alg = parts[0];
        String mode = parts[1];
        String pad = parts[2];
        if ((mode != null) && (mode.length() == 0)) {
            mode = null;
        }
        if ((pad != null) && (pad.length() == 0)) {
            pad = null;
        }

        if ((mode == null) && (pad == null)) {
            // DES
            Transform tr = new Transform(alg, "", null, null);
            return Collections.singletonList(tr);
        } else { // if ((mode != null) && (pad != null)) {
            // DES/CBC/PKCS5Padding
            List<Transform> list = new ArrayList<>(4);
            list.add(new Transform(alg, "/" + mode + "/" + pad, null, null));
            list.add(new Transform(alg, "/" + mode, null, pad));
            list.add(new Transform(alg, "//" + pad, mode, null));
            list.add(new Transform(alg, "", mode, pad));
            return list;
        }
    }

    // get the transform matching the specified service
    private static Transform getTransform(Service s,
                                          List<Transform> transforms) {
        String alg = s.getAlgorithm().toUpperCase(Locale.ENGLISH);
        for (Transform tr : transforms) {
            if (alg.endsWith(tr.suffix)) {
                return tr;
            }
        }
        return null;
    }
    */
// END Android-removed: Reimplement provider selection.
public static final Cipher getInstance(String transformation) throws NoSuchAlgorithmException, NoSuchPaddingException {
    return createCipher(transformation, null);
}
#method_after
// BEGIN Android-removed: Reimplement provider selection.
// See note at top of class.
/*
    // Provider attribute name for supported chaining mode
    private final static String ATTR_MODE = "SupportedModes";
    // Provider attribute name for supported padding names
    private final static String ATTR_PAD  = "SupportedPaddings";

    // constants indicating whether the provider supports
    // a given mode or padding
    private final static int S_NO    = 0;       // does not support
    private final static int S_MAYBE = 1;       // unable to determine
    private final static int S_YES   = 2;       // does support

    /**
     * Nested class to deal with modes and paddings.
     *
    private static class Transform {
        // transform string to lookup in the provider
        final String transform;
        // the mode/padding suffix in upper case. for example, if the algorithm
        // to lookup is "DES/CBC/PKCS5Padding" suffix is "/CBC/PKCS5PADDING"
        // if loopup is "DES", suffix is the empty string
        // needed because aliases prevent straight transform.equals()
        final String suffix;
        // value to pass to setMode() or null if no such call required
        final String mode;
        // value to pass to setPadding() or null if no such call required
        final String pad;
        Transform(String alg, String suffix, String mode, String pad) {
            this.transform = alg + suffix;
            this.suffix = suffix.toUpperCase(Locale.ENGLISH);
            this.mode = mode;
            this.pad = pad;
        }
        // set mode and padding for the given SPI
        void setModePadding(CipherSpi spi) throws NoSuchAlgorithmException,
                NoSuchPaddingException {
            if (mode != null) {
                spi.engineSetMode(mode);
            }
            if (pad != null) {
                spi.engineSetPadding(pad);
            }
        }
        // check whether the given services supports the mode and
        // padding described by this Transform
        int supportsModePadding(Service s) {
            int smode = supportsMode(s);
            if (smode == S_NO) {
                return smode;
            }
            int spad = supportsPadding(s);
            // our constants are defined so that Math.min() is a tri-valued AND
            return Math.min(smode, spad);
        }

        // separate methods for mode and padding
        // called directly by Cipher only to throw the correct exception
        int supportsMode(Service s) {
            return supports(s, ATTR_MODE, mode);
        }
        int supportsPadding(Service s) {
            return supports(s, ATTR_PAD, pad);
        }

        private static int supports(Service s, String attrName, String value) {
            if (value == null) {
                return S_YES;
            }
            String regexp = s.getAttribute(attrName);
            if (regexp == null) {
                return S_MAYBE;
            }
            return matches(regexp, value) ? S_YES : S_NO;
        }

        // ConcurrentMap<String,Pattern> for previously compiled patterns
        private final static ConcurrentMap<String, Pattern> patternCache =
            new ConcurrentHashMap<String, Pattern>();

        private static boolean matches(String regexp, String str) {
            Pattern pattern = patternCache.get(regexp);
            if (pattern == null) {
                pattern = Pattern.compile(regexp);
                patternCache.putIfAbsent(regexp, pattern);
            }
            return pattern.matcher(str.toUpperCase(Locale.ENGLISH)).matches();
        }

    }

    private static List<Transform> getTransforms(String transformation)
            throws NoSuchAlgorithmException {
        String[] parts = tokenizeTransformation(transformation);

        String alg = parts[0];
        String mode = parts[1];
        String pad = parts[2];
        if ((mode != null) && (mode.length() == 0)) {
            mode = null;
        }
        if ((pad != null) && (pad.length() == 0)) {
            pad = null;
        }

        if ((mode == null) && (pad == null)) {
            // DES
            Transform tr = new Transform(alg, "", null, null);
            return Collections.singletonList(tr);
        } else { // if ((mode != null) && (pad != null)) {
            // DES/CBC/PKCS5Padding
            List<Transform> list = new ArrayList<>(4);
            list.add(new Transform(alg, "/" + mode + "/" + pad, null, null));
            list.add(new Transform(alg, "/" + mode, null, pad));
            list.add(new Transform(alg, "//" + pad, mode, null));
            list.add(new Transform(alg, "", mode, pad));
            return list;
        }
    }

    // get the transform matching the specified service
    private static Transform getTransform(Service s,
                                          List<Transform> transforms) {
        String alg = s.getAlgorithm().toUpperCase(Locale.ENGLISH);
        for (Transform tr : transforms) {
            if (alg.endsWith(tr.suffix)) {
                return tr;
            }
        }
        return null;
    }
    */
// END Android-removed: Reimplement provider selection.
public static final Cipher getInstance(String transformation) throws NoSuchAlgorithmException, NoSuchPaddingException {
    return createCipher(transformation, null);
}
#end_block

#method_before
// BEGIN Android-added: Bulk of the new provider implementation.
// See android-note.
public CipherSpi getCurrentSpi() {
    return spi;
}
#method_after
// BEGIN Android-added: Bulk of the new provider implementation.
// See note at top of class.
public CipherSpi getCurrentSpi() {
    return spi;
}
#end_block

#method_before
public boolean getProfileProxy(Context context, BluetoothProfile.ServiceListener listener, int profile) {
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP_CLIENT) {
        BluetoothMapClient mapClient = new BluetoothMapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_HOST) {
        BluetoothInputHost iHost = new BluetoothInputHost(context, listener);
        return true;
    } else {
        return false;
    }
}
#method_after
public boolean getProfileProxy(Context context, BluetoothProfile.ServiceListener listener, int profile) {
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_HOST) {
        BluetoothHidHost iDev = new BluetoothHidHost(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP_CLIENT) {
        BluetoothMapClient mapClient = new BluetoothMapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_DEVICE) {
        BluetoothHidDevice hidDevice = new BluetoothHidDevice(context, listener);
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
public void closeProfileProxy(int profile, BluetoothProfile proxy) {
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
        case BluetoothProfile.MAP_CLIENT:
            BluetoothMapClient mapClient = (BluetoothMapClient) proxy;
            mapClient.close();
            break;
        case BluetoothProfile.INPUT_HOST:
            BluetoothInputHost iHost = (BluetoothInputHost) proxy;
            iHost.close();
            break;
    }
}
#method_after
public void closeProfileProxy(int profile, BluetoothProfile proxy) {
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.HID_HOST:
            BluetoothHidHost iDev = (BluetoothHidHost) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
        case BluetoothProfile.MAP_CLIENT:
            BluetoothMapClient mapClient = (BluetoothMapClient) proxy;
            mapClient.close();
            break;
        case BluetoothProfile.HID_DEVICE:
            BluetoothHidDevice hidDevice = (BluetoothHidDevice) proxy;
            hidDevice.close();
            break;
    }
}
#end_block

#method_before
private MethodHandle findAccessor(Field field, Class<?> refc, Class<?> fieldType, int kind, boolean performAccessChecks) throws IllegalAccessException {
    if (performAccessChecks) {
        checkAccess(refc, field.getDeclaringClass(), field.getModifiers(), field.getName());
    }
    final boolean isStaticKind = kind == MethodHandle.SGET || kind == MethodHandle.SPUT;
    final int modifiers = field.getModifiers();
    if (Modifier.isStatic(modifiers) != isStaticKind) {
        String reason = "Field " + field + " is " + (isStaticKind ? "not " : "") + "static";
        throw new IllegalAccessException(reason);
    }
    final boolean isSetterKind = kind == MethodHandle.IPUT || kind == MethodHandle.SPUT;
    if (Modifier.isFinal(modifiers) && isSetterKind && !field.isAccessible()) {
        throw new IllegalAccessException("Field " + field + " is final");
    }
    final MethodType methodType;
    switch(kind) {
        case MethodHandle.SGET:
            methodType = MethodType.methodType(fieldType);
            break;
        case MethodHandle.SPUT:
            methodType = MethodType.methodType(void.class, fieldType);
            break;
        case MethodHandle.IGET:
            methodType = MethodType.methodType(fieldType, refc);
            break;
        case MethodHandle.IPUT:
            methodType = MethodType.methodType(void.class, refc, fieldType);
            break;
        default:
            throw new IllegalArgumentException("Invalid kind " + kind);
    }
    return new MethodHandleImpl(field.getArtField(), kind, methodType);
}
#method_after
private MethodHandle findAccessor(Field field, Class<?> refc, Class<?> fieldType, int kind, boolean performAccessChecks) throws IllegalAccessException {
    if (performAccessChecks) {
        checkAccess(refc, field.getDeclaringClass(), field.getModifiers(), field.getName());
    }
    final boolean isStaticKind = kind == MethodHandle.SGET || kind == MethodHandle.SPUT;
    final int modifiers = field.getModifiers();
    if (Modifier.isStatic(modifiers) != isStaticKind) {
        String reason = "Field " + field + " is " + (isStaticKind ? "not " : "") + "static";
        throw new IllegalAccessException(reason);
    }
    if (performAccessChecks) {
        final boolean isSetterKind = kind == MethodHandle.IPUT || kind == MethodHandle.SPUT;
        if (isSetterKind && Modifier.isFinal(modifiers)) {
            throw new IllegalAccessException("Field " + field + " is final");
        }
    }
    final MethodType methodType;
    switch(kind) {
        case MethodHandle.SGET:
            methodType = MethodType.methodType(fieldType);
            break;
        case MethodHandle.SPUT:
            methodType = MethodType.methodType(void.class, fieldType);
            break;
        case MethodHandle.IGET:
            methodType = MethodType.methodType(fieldType, refc);
            break;
        case MethodHandle.IPUT:
            methodType = MethodType.methodType(void.class, refc, fieldType);
            break;
        default:
            throw new IllegalArgumentException("Invalid kind " + kind);
    }
    return new MethodHandleImpl(field.getArtField(), kind, methodType);
}
#end_block

#method_before
private Result verify(DataSource apk) throws IOException, ApkFormatException, NoSuchAlgorithmException {
    if (mMinSdkVersion != null) {
        if (mMinSdkVersion < 0) {
            throw new IllegalArgumentException("minSdkVersion must not be negative: " + mMinSdkVersion);
        }
        if ((mMinSdkVersion != null) && (mMinSdkVersion > mMaxSdkVersion)) {
            throw new IllegalArgumentException("minSdkVersion (" + mMinSdkVersion + ") > maxSdkVersion (" + mMaxSdkVersion + ")");
        }
    }
    int maxSdkVersion = mMaxSdkVersion;
    ApkUtils.ZipSections zipSections;
    try {
        zipSections = ApkUtils.findZipSections(apk);
    } catch (ZipFormatException e) {
        throw new ApkFormatException("Malformed APK: not a ZIP archive", e);
    }
    Result result = new Result();
    // Android N and newer attempts to verify APK Signature Scheme v2 signature of the APK.
    // If the signature is not found, it falls back to JAR signature verification. If the
    // signature is found but does not verify, the APK is rejected.
    Set<Integer> foundApkSigSchemeIds;
    if (maxSdkVersion >= AndroidSdkVersion.N) {
        foundApkSigSchemeIds = new HashSet<>(1);
        try {
            V2SchemeVerifier.Result v2Result = V2SchemeVerifier.verify(apk, zipSections, maxSdkVersion);
            foundApkSigSchemeIds.add(APK_SIGNATURE_SCHEME_V2_ID);
            result.mergeFrom(v2Result);
        } catch (V2SchemeVerifier.SignatureNotFoundException ignored) {
        }
        if (result.containsErrors()) {
            return result;
        }
    } else {
        foundApkSigSchemeIds = Collections.emptySet();
    }
    ByteBuffer androidManifest = null;
    int minSdkVersion;
    if (mMinSdkVersion != null) {
        // No need to obtain minSdkVersion from the APK's AndroidManifest.xml
        minSdkVersion = mMinSdkVersion;
    } else {
        // Need to obtain minSdkVersion from the APK's AndroidManifest.xml
        if (androidManifest == null) {
            androidManifest = getAndroidManifestFromApk(apk, zipSections);
        }
        minSdkVersion = ApkUtils.getMinSdkVersionFromBinaryAndroidManifest(androidManifest.slice());
        if (minSdkVersion > mMaxSdkVersion) {
            throw new IllegalArgumentException("minSdkVersion from APK (" + minSdkVersion + ") > maxSdkVersion (" + mMaxSdkVersion + ")");
        }
    }
    // are signed using APK Signature Scheme v2 or newer.
    if (maxSdkVersion >= AndroidSdkVersion.O) {
        if (androidManifest == null) {
            androidManifest = getAndroidManifestFromApk(apk, zipSections);
        }
        int targetSandboxVersion = getTargetSandboxVersionFromBinaryAndroidManifest(androidManifest.slice());
        if (targetSandboxVersion > 1) {
            if (foundApkSigSchemeIds.isEmpty()) {
                result.addError(Issue.NO_SIG_FOR_TARGET_SANDBOX_VERSION, targetSandboxVersion);
            }
        }
    }
    // scheme) signatures were found.
    if ((minSdkVersion < AndroidSdkVersion.N) || (foundApkSigSchemeIds.isEmpty())) {
        V1SchemeVerifier.Result v1Result = V1SchemeVerifier.verify(apk, zipSections, SUPPORTED_APK_SIG_SCHEME_NAMES, foundApkSigSchemeIds, minSdkVersion, maxSdkVersion);
        result.mergeFrom(v1Result);
    }
    if (result.containsErrors()) {
        return result;
    }
    // signatures verified.
    if ((result.isVerifiedUsingV1Scheme()) && (result.isVerifiedUsingV2Scheme())) {
        ArrayList<Result.V1SchemeSignerInfo> v1Signers = new ArrayList<>(result.getV1SchemeSigners());
        ArrayList<Result.V2SchemeSignerInfo> v2Signers = new ArrayList<>(result.getV2SchemeSigners());
        ArrayList<ByteArray> v1SignerCerts = new ArrayList<>();
        ArrayList<ByteArray> v2SignerCerts = new ArrayList<>();
        for (Result.V1SchemeSignerInfo signer : v1Signers) {
            try {
                v1SignerCerts.add(new ByteArray(signer.getCertificate().getEncoded()));
            } catch (CertificateEncodingException e) {
                throw new RuntimeException("Failed to encode JAR signer " + signer.getName() + " certs", e);
            }
        }
        for (Result.V2SchemeSignerInfo signer : v2Signers) {
            try {
                v2SignerCerts.add(new ByteArray(signer.getCertificate().getEncoded()));
            } catch (CertificateEncodingException e) {
                throw new RuntimeException("Failed to encode APK Signature Scheme v2 signer (index: " + signer.getIndex() + ") certs", e);
            }
        }
        for (int i = 0; i < v1SignerCerts.size(); i++) {
            ByteArray v1Cert = v1SignerCerts.get(i);
            if (!v2SignerCerts.contains(v1Cert)) {
                Result.V1SchemeSignerInfo v1Signer = v1Signers.get(i);
                v1Signer.addError(Issue.V2_SIG_MISSING);
                break;
            }
        }
        for (int i = 0; i < v2SignerCerts.size(); i++) {
            ByteArray v2Cert = v2SignerCerts.get(i);
            if (!v1SignerCerts.contains(v2Cert)) {
                Result.V2SchemeSignerInfo v2Signer = v2Signers.get(i);
                v2Signer.addError(Issue.JAR_SIG_MISSING);
                break;
            }
        }
    }
    if (result.containsErrors()) {
        return result;
    }
    // Verified
    result.setVerified();
    if (result.isVerifiedUsingV2Scheme()) {
        for (Result.V2SchemeSignerInfo signerInfo : result.getV2SchemeSigners()) {
            result.addSignerCertificate(signerInfo.getCertificate());
        }
    } else if (result.isVerifiedUsingV1Scheme()) {
        for (Result.V1SchemeSignerInfo signerInfo : result.getV1SchemeSigners()) {
            result.addSignerCertificate(signerInfo.getCertificate());
        }
    } else {
        throw new RuntimeException("APK considered verified, but has not verified using either v1 or v2 schemes");
    }
    return result;
}
#method_after
private Result verify(DataSource apk) throws IOException, ApkFormatException, NoSuchAlgorithmException {
    if (mMinSdkVersion != null) {
        if (mMinSdkVersion < 0) {
            throw new IllegalArgumentException("minSdkVersion must not be negative: " + mMinSdkVersion);
        }
        if ((mMinSdkVersion != null) && (mMinSdkVersion > mMaxSdkVersion)) {
            throw new IllegalArgumentException("minSdkVersion (" + mMinSdkVersion + ") > maxSdkVersion (" + mMaxSdkVersion + ")");
        }
    }
    int maxSdkVersion = mMaxSdkVersion;
    ApkUtils.ZipSections zipSections;
    try {
        zipSections = ApkUtils.findZipSections(apk);
    } catch (ZipFormatException e) {
        throw new ApkFormatException("Malformed APK: not a ZIP archive", e);
    }
    ByteBuffer androidManifest = null;
    int minSdkVersion;
    if (mMinSdkVersion != null) {
        // No need to obtain minSdkVersion from the APK's AndroidManifest.xml
        minSdkVersion = mMinSdkVersion;
    } else {
        // Need to obtain minSdkVersion from the APK's AndroidManifest.xml
        if (androidManifest == null) {
            androidManifest = getAndroidManifestFromApk(apk, zipSections);
        }
        minSdkVersion = ApkUtils.getMinSdkVersionFromBinaryAndroidManifest(androidManifest.slice());
        if (minSdkVersion > mMaxSdkVersion) {
            throw new IllegalArgumentException("minSdkVersion from APK (" + minSdkVersion + ") > maxSdkVersion (" + mMaxSdkVersion + ")");
        }
    }
    Result result = new Result();
    // Android N and newer attempts to verify APK Signature Scheme v2 signature of the APK.
    // If the signature is not found, it falls back to JAR signature verification. If the
    // signature is found but does not verify, the APK is rejected.
    Set<Integer> foundApkSigSchemeIds;
    if (maxSdkVersion >= AndroidSdkVersion.N) {
        foundApkSigSchemeIds = new HashSet<>(1);
        try {
            V2SchemeVerifier.Result v2Result = V2SchemeVerifier.verify(apk, zipSections, Math.max(minSdkVersion, AndroidSdkVersion.N), maxSdkVersion);
            foundApkSigSchemeIds.add(APK_SIGNATURE_SCHEME_V2_ID);
            result.mergeFrom(v2Result);
        } catch (V2SchemeVerifier.SignatureNotFoundException ignored) {
        }
        if (result.containsErrors()) {
            return result;
        }
    } else {
        foundApkSigSchemeIds = Collections.emptySet();
    }
    // are signed using APK Signature Scheme v2 or newer.
    if (maxSdkVersion >= AndroidSdkVersion.O) {
        if (androidManifest == null) {
            androidManifest = getAndroidManifestFromApk(apk, zipSections);
        }
        int targetSandboxVersion = getTargetSandboxVersionFromBinaryAndroidManifest(androidManifest.slice());
        if (targetSandboxVersion > 1) {
            if (foundApkSigSchemeIds.isEmpty()) {
                result.addError(Issue.NO_SIG_FOR_TARGET_SANDBOX_VERSION, targetSandboxVersion);
            }
        }
    }
    // scheme) signatures were found.
    if ((minSdkVersion < AndroidSdkVersion.N) || (foundApkSigSchemeIds.isEmpty())) {
        V1SchemeVerifier.Result v1Result = V1SchemeVerifier.verify(apk, zipSections, SUPPORTED_APK_SIG_SCHEME_NAMES, foundApkSigSchemeIds, minSdkVersion, maxSdkVersion);
        result.mergeFrom(v1Result);
    }
    if (result.containsErrors()) {
        return result;
    }
    // signatures verified.
    if ((result.isVerifiedUsingV1Scheme()) && (result.isVerifiedUsingV2Scheme())) {
        ArrayList<Result.V1SchemeSignerInfo> v1Signers = new ArrayList<>(result.getV1SchemeSigners());
        ArrayList<Result.V2SchemeSignerInfo> v2Signers = new ArrayList<>(result.getV2SchemeSigners());
        ArrayList<ByteArray> v1SignerCerts = new ArrayList<>();
        ArrayList<ByteArray> v2SignerCerts = new ArrayList<>();
        for (Result.V1SchemeSignerInfo signer : v1Signers) {
            try {
                v1SignerCerts.add(new ByteArray(signer.getCertificate().getEncoded()));
            } catch (CertificateEncodingException e) {
                throw new RuntimeException("Failed to encode JAR signer " + signer.getName() + " certs", e);
            }
        }
        for (Result.V2SchemeSignerInfo signer : v2Signers) {
            try {
                v2SignerCerts.add(new ByteArray(signer.getCertificate().getEncoded()));
            } catch (CertificateEncodingException e) {
                throw new RuntimeException("Failed to encode APK Signature Scheme v2 signer (index: " + signer.getIndex() + ") certs", e);
            }
        }
        for (int i = 0; i < v1SignerCerts.size(); i++) {
            ByteArray v1Cert = v1SignerCerts.get(i);
            if (!v2SignerCerts.contains(v1Cert)) {
                Result.V1SchemeSignerInfo v1Signer = v1Signers.get(i);
                v1Signer.addError(Issue.V2_SIG_MISSING);
                break;
            }
        }
        for (int i = 0; i < v2SignerCerts.size(); i++) {
            ByteArray v2Cert = v2SignerCerts.get(i);
            if (!v1SignerCerts.contains(v2Cert)) {
                Result.V2SchemeSignerInfo v2Signer = v2Signers.get(i);
                v2Signer.addError(Issue.JAR_SIG_MISSING);
                break;
            }
        }
    }
    if (result.containsErrors()) {
        return result;
    }
    // Verified
    result.setVerified();
    if (result.isVerifiedUsingV2Scheme()) {
        for (Result.V2SchemeSignerInfo signerInfo : result.getV2SchemeSigners()) {
            result.addSignerCertificate(signerInfo.getCertificate());
        }
    } else if (result.isVerifiedUsingV1Scheme()) {
        for (Result.V1SchemeSignerInfo signerInfo : result.getV1SchemeSigners()) {
            result.addSignerCertificate(signerInfo.getCertificate());
        }
    } else {
        throw new RuntimeException("APK considered verified, but has not verified using either v1 or v2 schemes");
    }
    return result;
}
#end_block

#method_before
private static void verify(DataSource beforeApkSigningBlock, ByteBuffer apkSignatureSchemeV2Block, DataSource centralDir, ByteBuffer eocd, int maxSdkVersion, Result result) throws IOException, NoSuchAlgorithmException {
    Set<ContentDigestAlgorithm> contentDigestsToVerify = new HashSet<>(1);
    parseSigners(apkSignatureSchemeV2Block, contentDigestsToVerify, maxSdkVersion, result);
    if (result.containsErrors()) {
        return;
    }
    verifyIntegrity(beforeApkSigningBlock, centralDir, eocd, contentDigestsToVerify, maxSdkVersion, result);
    if (!result.containsErrors()) {
        result.verified = true;
    }
}
#method_after
public static Result verify(DataSource apk, ApkUtils.ZipSections zipSections, int minSdkVersion, int maxSdkVersion) throws IOException, ApkFormatException, NoSuchAlgorithmException, SignatureNotFoundException {
    Result result = new Result();
    SignatureInfo signatureInfo = findSignature(apk, zipSections, result);
    DataSource beforeApkSigningBlock = apk.slice(0, signatureInfo.apkSigningBlockOffset);
    DataSource centralDir = apk.slice(signatureInfo.centralDirOffset, signatureInfo.eocdOffset - signatureInfo.centralDirOffset);
    ByteBuffer eocd = signatureInfo.eocd;
    verify(beforeApkSigningBlock, signatureInfo.signatureBlock, centralDir, eocd, minSdkVersion, maxSdkVersion, result);
    return result;
}
#end_block

#method_before
private static void parseSigners(ByteBuffer apkSignatureSchemeV2Block, Set<ContentDigestAlgorithm> contentDigestsToVerify, int maxSdkVersion, Result result) throws NoSuchAlgorithmException {
    ByteBuffer signers;
    try {
        signers = getLengthPrefixedSlice(apkSignatureSchemeV2Block);
    } catch (ApkFormatException e) {
        result.addError(Issue.V2_SIG_MALFORMED_SIGNERS);
        return;
    }
    if (!signers.hasRemaining()) {
        result.addError(Issue.V2_SIG_NO_SIGNERS);
        return;
    }
    CertificateFactory certFactory;
    try {
        certFactory = CertificateFactory.getInstance("X.509");
    } catch (CertificateException e) {
        throw new RuntimeException("Failed to obtain X.509 CertificateFactory", e);
    }
    int signerCount = 0;
    while (signers.hasRemaining()) {
        int signerIndex = signerCount;
        signerCount++;
        Result.SignerInfo signerInfo = new Result.SignerInfo();
        signerInfo.index = signerIndex;
        result.signers.add(signerInfo);
        try {
            ByteBuffer signer = getLengthPrefixedSlice(signers);
            parseSigner(signer, certFactory, signerInfo, contentDigestsToVerify, maxSdkVersion);
        } catch (ApkFormatException | BufferUnderflowException e) {
            signerInfo.addError(Issue.V2_SIG_MALFORMED_SIGNER);
            return;
        }
    }
}
#method_after
private static void parseSigners(ByteBuffer apkSignatureSchemeV2Block, Set<ContentDigestAlgorithm> contentDigestsToVerify, int minSdkVersion, int maxSdkVersion, Result result) throws NoSuchAlgorithmException, SignatureNotFoundException {
    ByteBuffer signers;
    try {
        signers = getLengthPrefixedSlice(apkSignatureSchemeV2Block);
    } catch (ApkFormatException e) {
        result.addError(Issue.V2_SIG_MALFORMED_SIGNERS);
        return;
    }
    if (!signers.hasRemaining()) {
        result.addError(Issue.V2_SIG_NO_SIGNERS);
        return;
    }
    CertificateFactory certFactory;
    try {
        certFactory = CertificateFactory.getInstance("X.509");
    } catch (CertificateException e) {
        throw new RuntimeException("Failed to obtain X.509 CertificateFactory", e);
    }
    int signerCount = 0;
    while (signers.hasRemaining()) {
        int signerIndex = signerCount;
        signerCount++;
        Result.SignerInfo signerInfo = new Result.SignerInfo();
        signerInfo.index = signerIndex;
        result.signers.add(signerInfo);
        try {
            ByteBuffer signer = getLengthPrefixedSlice(signers);
            parseSigner(signer, certFactory, signerInfo, contentDigestsToVerify, minSdkVersion, maxSdkVersion);
        } catch (ApkFormatException | BufferUnderflowException e) {
            signerInfo.addError(Issue.V2_SIG_MALFORMED_SIGNER);
            return;
        }
    }
}
#end_block

#method_before
private static void parseSigner(ByteBuffer signerBlock, CertificateFactory certFactory, Result.SignerInfo result, Set<ContentDigestAlgorithm> contentDigestsToVerify, int maxSdkVersion) throws ApkFormatException, NoSuchAlgorithmException {
    ByteBuffer signedData = getLengthPrefixedSlice(signerBlock);
    byte[] signedDataBytes = new byte[signedData.remaining()];
    signedData.get(signedDataBytes);
    signedData.flip();
    result.signedData = signedDataBytes;
    ByteBuffer signatures = getLengthPrefixedSlice(signerBlock);
    byte[] publicKeyBytes = readLengthPrefixedByteArray(signerBlock);
    // Parse the signatures block and identify supported signatures
    int signatureCount = 0;
    List<SupportedSignature> supportedSignatures = new ArrayList<>(1);
    while (signatures.hasRemaining()) {
        signatureCount++;
        try {
            ByteBuffer signature = getLengthPrefixedSlice(signatures);
            int sigAlgorithmId = signature.getInt();
            byte[] sigBytes = readLengthPrefixedByteArray(signature);
            result.signatures.add(new Result.SignerInfo.Signature(sigAlgorithmId, sigBytes));
            SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.findById(sigAlgorithmId);
            if (signatureAlgorithm == null) {
                result.addWarning(Issue.V2_SIG_UNKNOWN_SIG_ALGORITHM, sigAlgorithmId);
                continue;
            }
            supportedSignatures.add(new SupportedSignature(signatureAlgorithm, sigBytes));
        } catch (ApkFormatException | BufferUnderflowException e) {
            result.addError(Issue.V2_SIG_MALFORMED_SIGNATURE, signatureCount);
            return;
        }
    }
    if (result.signatures.isEmpty()) {
        result.addError(Issue.V2_SIG_NO_SIGNATURES);
        return;
    }
    // Verify signatures over signed-data block using the public key
    Collection<SupportedSignature> signaturesToVerify = getSignaturesToVerify(supportedSignatures, maxSdkVersion);
    if (signaturesToVerify.isEmpty()) {
        result.addError(Issue.V2_SIG_NO_SUPPORTED_SIGNATURES);
        return;
    }
    for (SupportedSignature signature : signaturesToVerify) {
        SignatureAlgorithm signatureAlgorithm = signature.algorithm;
        String jcaSignatureAlgorithm = signatureAlgorithm.getJcaSignatureAlgorithmAndParams().getFirst();
        AlgorithmParameterSpec jcaSignatureAlgorithmParams = signatureAlgorithm.getJcaSignatureAlgorithmAndParams().getSecond();
        String keyAlgorithm = signatureAlgorithm.getJcaKeyAlgorithm();
        PublicKey publicKey;
        try {
            publicKey = KeyFactory.getInstance(keyAlgorithm).generatePublic(new X509EncodedKeySpec(publicKeyBytes));
        } catch (Exception e) {
            result.addError(Issue.V2_SIG_MALFORMED_PUBLIC_KEY, e);
            return;
        }
        try {
            Signature sig = Signature.getInstance(jcaSignatureAlgorithm);
            sig.initVerify(publicKey);
            if (jcaSignatureAlgorithmParams != null) {
                sig.setParameter(jcaSignatureAlgorithmParams);
            }
            signedData.position(0);
            sig.update(signedData);
            byte[] sigBytes = signature.signature;
            if (!sig.verify(sigBytes)) {
                result.addError(Issue.V2_SIG_DID_NOT_VERIFY, signatureAlgorithm);
                return;
            }
            result.verifiedSignatures.put(signatureAlgorithm, sigBytes);
            contentDigestsToVerify.add(signatureAlgorithm.getContentDigestAlgorithm());
        } catch (InvalidKeyException | InvalidAlgorithmParameterException | SignatureException e) {
            result.addError(Issue.V2_SIG_VERIFY_EXCEPTION, signatureAlgorithm, e);
            return;
        }
    }
    // At least one signature over signedData has verified. We can now parse signed-data.
    signedData.position(0);
    ByteBuffer digests = getLengthPrefixedSlice(signedData);
    ByteBuffer certificates = getLengthPrefixedSlice(signedData);
    ByteBuffer additionalAttributes = getLengthPrefixedSlice(signedData);
    // Parse the certificates block
    int certificateIndex = -1;
    while (certificates.hasRemaining()) {
        certificateIndex++;
        byte[] encodedCert = readLengthPrefixedByteArray(certificates);
        X509Certificate certificate;
        try {
            certificate = (X509Certificate) certFactory.generateCertificate(new ByteArrayInputStream(encodedCert));
        } catch (CertificateException e) {
            result.addError(Issue.V2_SIG_MALFORMED_CERTIFICATE, certificateIndex, certificateIndex + 1, e);
            return;
        }
        // Wrap the cert so that the result's getEncoded returns exactly the original encoded
        // form. Without this, getEncoded may return a different form from what was stored in
        // the signature. This is because some X509Certificate(Factory) implementations
        // re-encode certificates.
        certificate = new GuaranteedEncodedFormX509Certificate(certificate, encodedCert);
        result.certs.add(certificate);
    }
    if (result.certs.isEmpty()) {
        result.addError(Issue.V2_SIG_NO_CERTIFICATES);
        return;
    }
    X509Certificate mainCertificate = result.certs.get(0);
    byte[] certificatePublicKeyBytes = mainCertificate.getPublicKey().getEncoded();
    if (!Arrays.equals(publicKeyBytes, certificatePublicKeyBytes)) {
        result.addError(Issue.V2_SIG_PUBLIC_KEY_MISMATCH_BETWEEN_CERTIFICATE_AND_SIGNATURES_RECORD, toHex(certificatePublicKeyBytes), toHex(publicKeyBytes));
        return;
    }
    // Parse the digests block
    int digestCount = 0;
    while (digests.hasRemaining()) {
        digestCount++;
        try {
            ByteBuffer digest = getLengthPrefixedSlice(digests);
            int sigAlgorithmId = digest.getInt();
            byte[] digestBytes = readLengthPrefixedByteArray(digest);
            result.contentDigests.add(new Result.SignerInfo.ContentDigest(sigAlgorithmId, digestBytes));
        } catch (ApkFormatException | BufferUnderflowException e) {
            result.addError(Issue.V2_SIG_MALFORMED_DIGEST, digestCount);
            return;
        }
    }
    List<Integer> sigAlgsFromSignaturesRecord = new ArrayList<>(result.signatures.size());
    for (Result.SignerInfo.Signature signature : result.signatures) {
        sigAlgsFromSignaturesRecord.add(signature.getAlgorithmId());
    }
    List<Integer> sigAlgsFromDigestsRecord = new ArrayList<>(result.contentDigests.size());
    for (Result.SignerInfo.ContentDigest digest : result.contentDigests) {
        sigAlgsFromDigestsRecord.add(digest.getSignatureAlgorithmId());
    }
    if (!sigAlgsFromSignaturesRecord.equals(sigAlgsFromDigestsRecord)) {
        result.addError(Issue.V2_SIG_SIG_ALG_MISMATCH_BETWEEN_SIGNATURES_AND_DIGESTS_RECORDS, sigAlgsFromSignaturesRecord, sigAlgsFromDigestsRecord);
        return;
    }
    // Parse the additional attributes block.
    int additionalAttributeCount = 0;
    while (additionalAttributes.hasRemaining()) {
        additionalAttributeCount++;
        try {
            ByteBuffer attribute = getLengthPrefixedSlice(additionalAttributes);
            int id = attribute.getInt();
            byte[] value = readLengthPrefixedByteArray(attribute);
            result.additionalAttributes.add(new Result.SignerInfo.AdditionalAttribute(id, value));
            result.addWarning(Issue.V2_SIG_UNKNOWN_ADDITIONAL_ATTRIBUTE, id);
        } catch (ApkFormatException | BufferUnderflowException e) {
            result.addError(Issue.V2_SIG_MALFORMED_ADDITIONAL_ATTRIBUTE, additionalAttributeCount);
            return;
        }
    }
}
#method_after
private static void parseSigner(ByteBuffer signerBlock, CertificateFactory certFactory, Result.SignerInfo result, Set<ContentDigestAlgorithm> contentDigestsToVerify, int minSdkVersion, int maxSdkVersion) throws ApkFormatException, NoSuchAlgorithmException {
    ByteBuffer signedData = getLengthPrefixedSlice(signerBlock);
    byte[] signedDataBytes = new byte[signedData.remaining()];
    signedData.get(signedDataBytes);
    signedData.flip();
    result.signedData = signedDataBytes;
    ByteBuffer signatures = getLengthPrefixedSlice(signerBlock);
    byte[] publicKeyBytes = readLengthPrefixedByteArray(signerBlock);
    // Parse the signatures block and identify supported signatures
    int signatureCount = 0;
    List<SupportedSignature> supportedSignatures = new ArrayList<>(1);
    while (signatures.hasRemaining()) {
        signatureCount++;
        try {
            ByteBuffer signature = getLengthPrefixedSlice(signatures);
            int sigAlgorithmId = signature.getInt();
            byte[] sigBytes = readLengthPrefixedByteArray(signature);
            result.signatures.add(new Result.SignerInfo.Signature(sigAlgorithmId, sigBytes));
            SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.findById(sigAlgorithmId);
            if (signatureAlgorithm == null) {
                result.addWarning(Issue.V2_SIG_UNKNOWN_SIG_ALGORITHM, sigAlgorithmId);
                continue;
            }
            supportedSignatures.add(new SupportedSignature(signatureAlgorithm, sigBytes));
        } catch (ApkFormatException | BufferUnderflowException e) {
            result.addError(Issue.V2_SIG_MALFORMED_SIGNATURE, signatureCount);
            return;
        }
    }
    if (result.signatures.isEmpty()) {
        result.addError(Issue.V2_SIG_NO_SIGNATURES);
        return;
    }
    // Verify signatures over signed-data block using the public key
    List<SupportedSignature> signaturesToVerify = null;
    try {
        signaturesToVerify = getSignaturesToVerify(supportedSignatures, minSdkVersion, maxSdkVersion);
    } catch (NoSupportedSignaturesException e) {
        result.addError(Issue.V2_SIG_NO_SUPPORTED_SIGNATURES);
        return;
    }
    for (SupportedSignature signature : signaturesToVerify) {
        SignatureAlgorithm signatureAlgorithm = signature.algorithm;
        String jcaSignatureAlgorithm = signatureAlgorithm.getJcaSignatureAlgorithmAndParams().getFirst();
        AlgorithmParameterSpec jcaSignatureAlgorithmParams = signatureAlgorithm.getJcaSignatureAlgorithmAndParams().getSecond();
        String keyAlgorithm = signatureAlgorithm.getJcaKeyAlgorithm();
        PublicKey publicKey;
        try {
            publicKey = KeyFactory.getInstance(keyAlgorithm).generatePublic(new X509EncodedKeySpec(publicKeyBytes));
        } catch (Exception e) {
            result.addError(Issue.V2_SIG_MALFORMED_PUBLIC_KEY, e);
            return;
        }
        try {
            Signature sig = Signature.getInstance(jcaSignatureAlgorithm);
            sig.initVerify(publicKey);
            if (jcaSignatureAlgorithmParams != null) {
                sig.setParameter(jcaSignatureAlgorithmParams);
            }
            signedData.position(0);
            sig.update(signedData);
            byte[] sigBytes = signature.signature;
            if (!sig.verify(sigBytes)) {
                result.addError(Issue.V2_SIG_DID_NOT_VERIFY, signatureAlgorithm);
                return;
            }
            result.verifiedSignatures.put(signatureAlgorithm, sigBytes);
            contentDigestsToVerify.add(signatureAlgorithm.getContentDigestAlgorithm());
        } catch (InvalidKeyException | InvalidAlgorithmParameterException | SignatureException e) {
            result.addError(Issue.V2_SIG_VERIFY_EXCEPTION, signatureAlgorithm, e);
            return;
        }
    }
    // At least one signature over signedData has verified. We can now parse signed-data.
    signedData.position(0);
    ByteBuffer digests = getLengthPrefixedSlice(signedData);
    ByteBuffer certificates = getLengthPrefixedSlice(signedData);
    ByteBuffer additionalAttributes = getLengthPrefixedSlice(signedData);
    // Parse the certificates block
    int certificateIndex = -1;
    while (certificates.hasRemaining()) {
        certificateIndex++;
        byte[] encodedCert = readLengthPrefixedByteArray(certificates);
        X509Certificate certificate;
        try {
            certificate = (X509Certificate) certFactory.generateCertificate(new ByteArrayInputStream(encodedCert));
        } catch (CertificateException e) {
            result.addError(Issue.V2_SIG_MALFORMED_CERTIFICATE, certificateIndex, certificateIndex + 1, e);
            return;
        }
        // Wrap the cert so that the result's getEncoded returns exactly the original encoded
        // form. Without this, getEncoded may return a different form from what was stored in
        // the signature. This is because some X509Certificate(Factory) implementations
        // re-encode certificates.
        certificate = new GuaranteedEncodedFormX509Certificate(certificate, encodedCert);
        result.certs.add(certificate);
    }
    if (result.certs.isEmpty()) {
        result.addError(Issue.V2_SIG_NO_CERTIFICATES);
        return;
    }
    X509Certificate mainCertificate = result.certs.get(0);
    byte[] certificatePublicKeyBytes = mainCertificate.getPublicKey().getEncoded();
    if (!Arrays.equals(publicKeyBytes, certificatePublicKeyBytes)) {
        result.addError(Issue.V2_SIG_PUBLIC_KEY_MISMATCH_BETWEEN_CERTIFICATE_AND_SIGNATURES_RECORD, toHex(certificatePublicKeyBytes), toHex(publicKeyBytes));
        return;
    }
    // Parse the digests block
    int digestCount = 0;
    while (digests.hasRemaining()) {
        digestCount++;
        try {
            ByteBuffer digest = getLengthPrefixedSlice(digests);
            int sigAlgorithmId = digest.getInt();
            byte[] digestBytes = readLengthPrefixedByteArray(digest);
            result.contentDigests.add(new Result.SignerInfo.ContentDigest(sigAlgorithmId, digestBytes));
        } catch (ApkFormatException | BufferUnderflowException e) {
            result.addError(Issue.V2_SIG_MALFORMED_DIGEST, digestCount);
            return;
        }
    }
    List<Integer> sigAlgsFromSignaturesRecord = new ArrayList<>(result.signatures.size());
    for (Result.SignerInfo.Signature signature : result.signatures) {
        sigAlgsFromSignaturesRecord.add(signature.getAlgorithmId());
    }
    List<Integer> sigAlgsFromDigestsRecord = new ArrayList<>(result.contentDigests.size());
    for (Result.SignerInfo.ContentDigest digest : result.contentDigests) {
        sigAlgsFromDigestsRecord.add(digest.getSignatureAlgorithmId());
    }
    if (!sigAlgsFromSignaturesRecord.equals(sigAlgsFromDigestsRecord)) {
        result.addError(Issue.V2_SIG_SIG_ALG_MISMATCH_BETWEEN_SIGNATURES_AND_DIGESTS_RECORDS, sigAlgsFromSignaturesRecord, sigAlgsFromDigestsRecord);
        return;
    }
    // Parse the additional attributes block.
    int additionalAttributeCount = 0;
    while (additionalAttributes.hasRemaining()) {
        additionalAttributeCount++;
        try {
            ByteBuffer attribute = getLengthPrefixedSlice(additionalAttributes);
            int id = attribute.getInt();
            byte[] value = readLengthPrefixedByteArray(attribute);
            result.additionalAttributes.add(new Result.SignerInfo.AdditionalAttribute(id, value));
            result.addWarning(Issue.V2_SIG_UNKNOWN_ADDITIONAL_ATTRIBUTE, id);
        } catch (ApkFormatException | BufferUnderflowException e) {
            result.addError(Issue.V2_SIG_MALFORMED_ADDITIONAL_ATTRIBUTE, additionalAttributeCount);
            return;
        }
    }
}
#end_block

#method_before
private static Collection<SupportedSignature> getSignaturesToVerify(List<SupportedSignature> signatures, int maxSdkVersion) {
    // Only verify signatures under maxSdkVersion.
    signatures = signatures.stream().filter(s -> s.algorithm.getMinSdkVersion() <= maxSdkVersion).collect(Collectors.toList());
    // Pick the signature with the strongest algorithm at all interested SDK version, to mimic
    // Android's behavior on those versions.
    Map<Integer, SupportedSignature> bestSigAlgorithmOnSdkVersion = new HashMap<>();
    for (SupportedSignature sig : signatures) {
        SignatureAlgorithm sigAlgorithm = sig.algorithm;
        SupportedSignature candidate = bestSigAlgorithmOnSdkVersion.get(sigAlgorithm.getMinSdkVersion());
        if ((candidate == null) || (compareSignatureAlgorithm(sigAlgorithm, candidate.algorithm) > 0)) {
            bestSigAlgorithmOnSdkVersion.put(sigAlgorithm.getMinSdkVersion(), new SupportedSignature(sigAlgorithm, sig.signature));
        }
    }
    if (bestSigAlgorithmOnSdkVersion.isEmpty()) {
        return Collections.emptyList();
    } else {
        return bestSigAlgorithmOnSdkVersion.values();
    }
}
#method_after
private static List<SupportedSignature> getSignaturesToVerify(List<SupportedSignature> signatures, int minSdkVersion, int maxSdkVersion) throws NoSupportedSignaturesException {
    // Pick the signature with the strongest algorithm at all required SDK versions, to mimic
    // Android's behavior on those versions.
    // 
    // Here we assume that, once introduced, a signature algorithm continues to be supported in
    // all future Android versions. We also assume that the better-than relationship between
    // algorithms is exactly the same on all Android platform versions (except that older
    // platforms might support fewer algorithms). If these assumption are no longer true, the
    // logic here will need to change accordingly.
    Map<Integer, SupportedSignature> bestSigAlgorithmOnSdkVersion = new HashMap<>();
    int minProvidedSignaturesVersion = Integer.MAX_VALUE;
    for (SupportedSignature sig : signatures) {
        SignatureAlgorithm sigAlgorithm = sig.algorithm;
        int sigMinSdkVersion = sigAlgorithm.getMinSdkVersion();
        if (sigMinSdkVersion > maxSdkVersion) {
            continue;
        }
        if (sigMinSdkVersion < minProvidedSignaturesVersion) {
            minProvidedSignaturesVersion = sigMinSdkVersion;
        }
        SupportedSignature candidate = bestSigAlgorithmOnSdkVersion.get(sigMinSdkVersion);
        if ((candidate == null) || (compareSignatureAlgorithm(sigAlgorithm, candidate.algorithm) > 0)) {
            bestSigAlgorithmOnSdkVersion.put(sigMinSdkVersion, sig);
        }
    }
    // Must have some supported signature algorithms for minSdkVersion.
    if (minSdkVersion < minProvidedSignaturesVersion) {
        throw new NoSupportedSignaturesException("Minimum provided signature version " + minProvidedSignaturesVersion + " < minSdkVersion " + minSdkVersion);
    }
    if (bestSigAlgorithmOnSdkVersion.isEmpty()) {
        throw new NoSupportedSignaturesException("No supported signature");
    }
    return bestSigAlgorithmOnSdkVersion.values().stream().sorted((sig1, sig2) -> Integer.compare(sig1.algorithm.getId(), sig2.algorithm.getId())).collect(Collectors.toList());
}
#end_block

#method_before
private static void verifyIntegrity(DataSource beforeApkSigningBlock, DataSource centralDir, ByteBuffer eocd, Set<ContentDigestAlgorithm> contentDigestAlgorithms, int maxSdkVersion, Result result) throws IOException, NoSuchAlgorithmException {
    if (contentDigestAlgorithms.isEmpty()) {
        // is verified, meaning at least one content digest is known.
        throw new RuntimeException("No content digests found");
    }
    // For the purposes of verifying integrity, ZIP End of Central Directory (EoCD) must be
    // treated as though its Central Directory offset points to the start of APK Signing Block.
    // We thus modify the EoCD accordingly.
    ByteBuffer modifiedEocd = ByteBuffer.allocate(eocd.remaining());
    modifiedEocd.order(ByteOrder.LITTLE_ENDIAN);
    modifiedEocd.put(eocd);
    modifiedEocd.flip();
    ZipUtils.setZipEocdCentralDirectoryOffset(modifiedEocd, beforeApkSigningBlock.size());
    Map<ContentDigestAlgorithm, byte[]> actualContentDigests;
    try {
        actualContentDigests = V2SchemeSigner.computeContentDigests(contentDigestAlgorithms, new DataSource[] { beforeApkSigningBlock, centralDir, new ByteBufferDataSource(modifiedEocd) });
    } catch (DigestException e) {
        throw new RuntimeException("Failed to compute content digests", e);
    }
    if (!contentDigestAlgorithms.equals(actualContentDigests.keySet())) {
        throw new RuntimeException("Mismatch between sets of requested and computed content digests" + " . Requested: " + contentDigestAlgorithms + ", computed: " + actualContentDigests.keySet());
    }
    // in signer blocks.
    for (Result.SignerInfo signerInfo : result.signers) {
        for (Result.SignerInfo.ContentDigest expected : signerInfo.contentDigests) {
            SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.findById(expected.getSignatureAlgorithmId());
            if (signatureAlgorithm == null) {
                continue;
            }
            ContentDigestAlgorithm contentDigestAlgorithm = signatureAlgorithm.getContentDigestAlgorithm();
            byte[] expectedDigest = expected.getValue();
            byte[] actualDigest = actualContentDigests.get(contentDigestAlgorithm);
            if (!Arrays.equals(expectedDigest, actualDigest)) {
                signerInfo.addError(Issue.V2_SIG_APK_DIGEST_DID_NOT_VERIFY, contentDigestAlgorithm, toHex(expectedDigest), toHex(actualDigest));
                continue;
            }
            signerInfo.verifiedContentDigests.put(contentDigestAlgorithm, actualDigest);
        }
    }
}
#method_after
private static void verifyIntegrity(DataSource beforeApkSigningBlock, DataSource centralDir, ByteBuffer eocd, Set<ContentDigestAlgorithm> contentDigestAlgorithms, Result result) throws IOException, NoSuchAlgorithmException {
    if (contentDigestAlgorithms.isEmpty()) {
        // is verified, meaning at least one content digest is known.
        throw new RuntimeException("No content digests found");
    }
    // For the purposes of verifying integrity, ZIP End of Central Directory (EoCD) must be
    // treated as though its Central Directory offset points to the start of APK Signing Block.
    // We thus modify the EoCD accordingly.
    ByteBuffer modifiedEocd = ByteBuffer.allocate(eocd.remaining());
    modifiedEocd.order(ByteOrder.LITTLE_ENDIAN);
    modifiedEocd.put(eocd);
    modifiedEocd.flip();
    ZipUtils.setZipEocdCentralDirectoryOffset(modifiedEocd, beforeApkSigningBlock.size());
    Map<ContentDigestAlgorithm, byte[]> actualContentDigests;
    try {
        actualContentDigests = V2SchemeSigner.computeContentDigests(contentDigestAlgorithms, new DataSource[] { beforeApkSigningBlock, centralDir, new ByteBufferDataSource(modifiedEocd) });
    } catch (DigestException e) {
        throw new RuntimeException("Failed to compute content digests", e);
    }
    if (!contentDigestAlgorithms.equals(actualContentDigests.keySet())) {
        throw new RuntimeException("Mismatch between sets of requested and computed content digests" + " . Requested: " + contentDigestAlgorithms + ", computed: " + actualContentDigests.keySet());
    }
    // in signer blocks.
    for (Result.SignerInfo signerInfo : result.signers) {
        for (Result.SignerInfo.ContentDigest expected : signerInfo.contentDigests) {
            SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.findById(expected.getSignatureAlgorithmId());
            if (signatureAlgorithm == null) {
                continue;
            }
            ContentDigestAlgorithm contentDigestAlgorithm = signatureAlgorithm.getContentDigestAlgorithm();
            byte[] expectedDigest = expected.getValue();
            byte[] actualDigest = actualContentDigests.get(contentDigestAlgorithm);
            if (!Arrays.equals(expectedDigest, actualDigest)) {
                signerInfo.addError(Issue.V2_SIG_APK_DIGEST_DID_NOT_VERIFY, contentDigestAlgorithm, toHex(expectedDigest), toHex(actualDigest));
                continue;
            }
            signerInfo.verifiedContentDigests.put(contentDigestAlgorithm, actualDigest);
        }
    }
}
#end_block

#method_before
private void sign(DataSource inputApk, DataSink outputApkOut, DataSource outputApkIn) throws IOException, ApkFormatException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
    // Step 1. Find input APK's main ZIP sections
    ApkUtils.ZipSections inputZipSections;
    try {
        inputZipSections = ApkUtils.findZipSections(inputApk);
    } catch (ZipFormatException e) {
        throw new ApkFormatException("Malformed APK: not a ZIP archive", e);
    }
    long inputApkSigningBlockOffset = -1;
    DataSource inputApkSigningBlock = null;
    try {
        Pair<DataSource, Long> apkSigningBlockAndOffset = V2SchemeVerifier.findApkSigningBlock(inputApk, inputZipSections);
        inputApkSigningBlock = apkSigningBlockAndOffset.getFirst();
        inputApkSigningBlockOffset = apkSigningBlockAndOffset.getSecond();
    } catch (V2SchemeVerifier.SignatureNotFoundException e) {
    // Input APK does not contain an APK Signing Block. That's OK. APKs are not required to
    // contain this block. It's only needed if the APK is signed using APK Signature Scheme
    // v2.
    }
    DataSource inputApkLfhSection = inputApk.slice(0, (inputApkSigningBlockOffset != -1) ? inputApkSigningBlockOffset : inputZipSections.getZipCentralDirectoryOffset());
    // Step 2. Parse the input APK's ZIP Central Directory
    ByteBuffer inputCd = getZipCentralDirectory(inputApk, inputZipSections);
    List<CentralDirectoryRecord> inputCdRecords = parseZipCentralDirectory(inputCd, inputZipSections);
    // Step 3. Obtain a signer engine instance
    ApkSignerEngine signerEngine;
    if (mSignerEngine != null) {
        // Use the provided signer engine
        signerEngine = mSignerEngine;
    } else {
        // Construct a signer engine from the provided parameters
        int minSdkVersion;
        if (mMinSdkVersion != null) {
            // No need to extract minSdkVersion from the APK's AndroidManifest.xml
            minSdkVersion = mMinSdkVersion;
        } else {
            // Need to extract minSdkVersion from the APK's AndroidManifest.xml
            minSdkVersion = getMinSdkVersionFromApk(inputCdRecords, inputApkLfhSection);
        }
        List<DefaultApkSignerEngine.SignerConfig> engineSignerConfigs = new ArrayList<>(mSignerConfigs.size());
        for (SignerConfig signerConfig : mSignerConfigs) {
            engineSignerConfigs.add(new DefaultApkSignerEngine.SignerConfig.Builder(signerConfig.getName(), signerConfig.getPrivateKey(), signerConfig.getCertificates()).build());
        }
        DefaultApkSignerEngine.Builder signerEngineBuilder = new DefaultApkSignerEngine.Builder(engineSignerConfigs, minSdkVersion).setV1SigningEnabled(mV1SigningEnabled).setV2SigningEnabled(mV2SigningEnabled).setOtherSignersSignaturesPreserved(mOtherSignersSignaturesPreserved);
        if (mCreatedBy != null) {
            signerEngineBuilder.setCreatedBy(mCreatedBy);
        }
        signerEngine = signerEngineBuilder.build();
    }
    // Step 4. Provide the signer engine with the input APK's APK Signing Block (if any)
    if (inputApkSigningBlock != null) {
        signerEngine.inputApkSigningBlock(inputApkSigningBlock);
    }
    // Step 5. Iterate over input APK's entries and output the Local File Header + data of those
    // entries which need to be output. Entries are iterated in the order in which their Local
    // File Header records are stored in the file. This is to achieve better data locality in
    // case Central Directory entries are in the wrong order.
    List<CentralDirectoryRecord> inputCdRecordsSortedByLfhOffset = new ArrayList<>(inputCdRecords);
    Collections.sort(inputCdRecordsSortedByLfhOffset, CentralDirectoryRecord.BY_LOCAL_FILE_HEADER_OFFSET_COMPARATOR);
    int lastModifiedDateForNewEntries = -1;
    int lastModifiedTimeForNewEntries = -1;
    long inputOffset = 0;
    long outputOffset = 0;
    Map<String, CentralDirectoryRecord> outputCdRecordsByName = new HashMap<>(inputCdRecords.size());
    for (final CentralDirectoryRecord inputCdRecord : inputCdRecordsSortedByLfhOffset) {
        String entryName = inputCdRecord.getName();
        ApkSignerEngine.InputJarEntryInstructions entryInstructions = signerEngine.inputJarEntry(entryName);
        boolean shouldOutput;
        switch(entryInstructions.getOutputPolicy()) {
            case OUTPUT:
                shouldOutput = true;
                break;
            case OUTPUT_BY_ENGINE:
            case SKIP:
                shouldOutput = false;
                break;
            default:
                throw new RuntimeException("Unknown output policy: " + entryInstructions.getOutputPolicy());
        }
        long inputLocalFileHeaderStartOffset = inputCdRecord.getLocalFileHeaderOffset();
        if (inputLocalFileHeaderStartOffset > inputOffset) {
            // Unprocessed data in input starting at inputOffset and ending and the start of
            // this record's LFH. We output this data verbatim because this signer is supposed
            // to preserve as much of input as possible.
            long chunkSize = inputLocalFileHeaderStartOffset - inputOffset;
            inputApkLfhSection.feed(inputOffset, chunkSize, outputApkOut);
            outputOffset += chunkSize;
            inputOffset = inputLocalFileHeaderStartOffset;
        }
        LocalFileRecord inputLocalFileRecord;
        try {
            inputLocalFileRecord = LocalFileRecord.getRecord(inputApkLfhSection, inputCdRecord, inputApkLfhSection.size());
        } catch (ZipFormatException e) {
            throw new ApkFormatException("Malformed ZIP entry: " + inputCdRecord.getName(), e);
        }
        inputOffset += inputLocalFileRecord.getSize();
        ApkSignerEngine.InspectJarEntryRequest inspectEntryRequest = entryInstructions.getInspectJarEntryRequest();
        if (inspectEntryRequest != null) {
            fulfillInspectInputJarEntryRequest(inputApkLfhSection, inputLocalFileRecord, inspectEntryRequest);
        }
        if (shouldOutput) {
            // Find the max value of last modified, to be used for new entries added by the
            // signer.
            int lastModifiedDate = inputCdRecord.getLastModificationDate();
            int lastModifiedTime = inputCdRecord.getLastModificationTime();
            if ((lastModifiedDateForNewEntries == -1) || (lastModifiedDate > lastModifiedDateForNewEntries) || ((lastModifiedDate == lastModifiedDateForNewEntries) && (lastModifiedTime > lastModifiedTimeForNewEntries))) {
                lastModifiedDateForNewEntries = lastModifiedDate;
                lastModifiedTimeForNewEntries = lastModifiedTime;
            }
            inspectEntryRequest = signerEngine.outputJarEntry(entryName);
            if (inspectEntryRequest != null) {
                fulfillInspectInputJarEntryRequest(inputApkLfhSection, inputLocalFileRecord, inspectEntryRequest);
            }
            // Output entry's Local File Header + data
            long outputLocalFileHeaderOffset = outputOffset;
            long outputLocalFileRecordSize = outputInputJarEntryLfhRecordPreservingDataAlignment(inputApkLfhSection, inputLocalFileRecord, outputApkOut, outputLocalFileHeaderOffset);
            outputOffset += outputLocalFileRecordSize;
            // Enqueue entry's Central Directory record for output
            CentralDirectoryRecord outputCdRecord;
            if (outputLocalFileHeaderOffset == inputLocalFileRecord.getStartOffsetInArchive()) {
                outputCdRecord = inputCdRecord;
            } else {
                outputCdRecord = inputCdRecord.createWithModifiedLocalFileHeaderOffset(outputLocalFileHeaderOffset);
            }
            outputCdRecordsByName.put(entryName, outputCdRecord);
        }
    }
    long inputLfhSectionSize = inputApkLfhSection.size();
    if (inputOffset < inputLfhSectionSize) {
        // Unprocessed data in input starting at inputOffset and ending and the end of the input
        // APK's LFH section. We output this data verbatim because this signer is supposed
        // to preserve as much of input as possible.
        long chunkSize = inputLfhSectionSize - inputOffset;
        inputApkLfhSection.feed(inputOffset, chunkSize, outputApkOut);
        outputOffset += chunkSize;
        inputOffset = inputLfhSectionSize;
    }
    // Step 6. Sort output APK's Central Directory records in the order in which they should
    // appear in the output
    List<CentralDirectoryRecord> outputCdRecords = new ArrayList<>(inputCdRecords.size() + 10);
    for (CentralDirectoryRecord inputCdRecord : inputCdRecords) {
        String entryName = inputCdRecord.getName();
        CentralDirectoryRecord outputCdRecord = outputCdRecordsByName.get(entryName);
        if (outputCdRecord != null) {
            outputCdRecords.add(outputCdRecord);
        }
    }
    // Step 7. Generate and output JAR signatures, if necessary. This may output more Local File
    // Header + data entries and add to the list of output Central Directory records.
    ApkSignerEngine.OutputJarSignatureRequest outputJarSignatureRequest = signerEngine.outputJarEntries();
    if (outputJarSignatureRequest != null) {
        if (lastModifiedDateForNewEntries == -1) {
            // Jan 1 2009 (DOS)
            lastModifiedDateForNewEntries = 0x3a21;
            lastModifiedTimeForNewEntries = 0;
        }
        for (ApkSignerEngine.OutputJarSignatureRequest.JarEntry entry : outputJarSignatureRequest.getAdditionalJarEntries()) {
            String entryName = entry.getName();
            byte[] uncompressedData = entry.getData();
            ZipUtils.DeflateResult deflateResult = ZipUtils.deflate(ByteBuffer.wrap(uncompressedData));
            byte[] compressedData = deflateResult.output;
            long uncompressedDataCrc32 = deflateResult.inputCrc32;
            ApkSignerEngine.InspectJarEntryRequest inspectEntryRequest = signerEngine.outputJarEntry(entryName);
            if (inspectEntryRequest != null) {
                inspectEntryRequest.getDataSink().consume(uncompressedData, 0, uncompressedData.length);
                inspectEntryRequest.done();
            }
            long localFileHeaderOffset = outputOffset;
            outputOffset += LocalFileRecord.outputRecordWithDeflateCompressedData(entryName, lastModifiedTimeForNewEntries, lastModifiedDateForNewEntries, compressedData, uncompressedDataCrc32, uncompressedData.length, outputApkOut);
            outputCdRecords.add(CentralDirectoryRecord.createWithDeflateCompressedData(entryName, lastModifiedTimeForNewEntries, lastModifiedDateForNewEntries, uncompressedDataCrc32, compressedData.length, uncompressedData.length, localFileHeaderOffset));
        }
        outputJarSignatureRequest.done();
    }
    // Step 8. Generate padding to complete 4 KB page so that the APK Signing Block will be 4 KB
    // aligned.
    long padSize = LINUX_COMMON_PAGE_ALIGNMENT_BYTES - outputOffset % LINUX_COMMON_PAGE_ALIGNMENT_BYTES;
    outputApkOut.consume(ByteBuffer.allocate((int) padSize));
    outputOffset += padSize;
    // Step 9. Construct output ZIP Central Directory in an in-memory buffer
    long outputCentralDirSizeBytes = 0;
    for (CentralDirectoryRecord record : outputCdRecords) {
        outputCentralDirSizeBytes += record.getSize();
    }
    if (outputCentralDirSizeBytes > Integer.MAX_VALUE) {
        throw new IOException("Output ZIP Central Directory too large: " + outputCentralDirSizeBytes + " bytes");
    }
    ByteBuffer outputCentralDir = ByteBuffer.allocate((int) outputCentralDirSizeBytes);
    for (CentralDirectoryRecord record : outputCdRecords) {
        record.copyTo(outputCentralDir);
    }
    outputCentralDir.flip();
    DataSource outputCentralDirDataSource = new ByteBufferDataSource(outputCentralDir);
    long outputCentralDirStartOffset = outputOffset;
    int outputCentralDirRecordCount = outputCdRecords.size();
    // Step 10. Construct output ZIP End of Central Directory record in an in-memory buffer
    ByteBuffer outputEocd = EocdRecord.createWithModifiedCentralDirectoryInfo(inputZipSections.getZipEndOfCentralDirectory(), outputCentralDirRecordCount, outputCentralDirDataSource.size(), outputCentralDirStartOffset);
    // Step 11. Generate and output APK Signature Scheme v2 signatures, if necessary. This may
    // insert an APK Signing Block just before the output's ZIP Central Directory
    ApkSignerEngine.OutputApkSigningBlockRequest outputApkSigingBlockRequest = signerEngine.outputZipSections(outputApkIn, outputCentralDirDataSource, DataSources.asDataSource(outputEocd));
    if (outputApkSigingBlockRequest != null) {
        byte[] outputApkSigningBlock = outputApkSigingBlockRequest.getApkSigningBlock();
        outputApkOut.consume(outputApkSigningBlock, 0, outputApkSigningBlock.length);
        ZipUtils.setZipEocdCentralDirectoryOffset(outputEocd, outputCentralDirStartOffset + outputApkSigningBlock.length);
        outputApkSigingBlockRequest.done();
    }
    // Step 12. Output ZIP Central Directory and ZIP End of Central Directory
    outputCentralDirDataSource.feed(0, outputCentralDirDataSource.size(), outputApkOut);
    outputApkOut.consume(outputEocd);
    signerEngine.outputDone();
}
#method_after
private void sign(DataSource inputApk, DataSink outputApkOut, DataSource outputApkIn) throws IOException, ApkFormatException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
    // Step 1. Find input APK's main ZIP sections
    ApkUtils.ZipSections inputZipSections;
    try {
        inputZipSections = ApkUtils.findZipSections(inputApk);
    } catch (ZipFormatException e) {
        throw new ApkFormatException("Malformed APK: not a ZIP archive", e);
    }
    long inputApkSigningBlockOffset = -1;
    DataSource inputApkSigningBlock = null;
    try {
        Pair<DataSource, Long> apkSigningBlockAndOffset = V2SchemeVerifier.findApkSigningBlock(inputApk, inputZipSections);
        inputApkSigningBlock = apkSigningBlockAndOffset.getFirst();
        inputApkSigningBlockOffset = apkSigningBlockAndOffset.getSecond();
    } catch (V2SchemeVerifier.SignatureNotFoundException e) {
    // Input APK does not contain an APK Signing Block. That's OK. APKs are not required to
    // contain this block. It's only needed if the APK is signed using APK Signature Scheme
    // v2.
    }
    DataSource inputApkLfhSection = inputApk.slice(0, (inputApkSigningBlockOffset != -1) ? inputApkSigningBlockOffset : inputZipSections.getZipCentralDirectoryOffset());
    // Step 2. Parse the input APK's ZIP Central Directory
    ByteBuffer inputCd = getZipCentralDirectory(inputApk, inputZipSections);
    List<CentralDirectoryRecord> inputCdRecords = parseZipCentralDirectory(inputCd, inputZipSections);
    // Step 3. Obtain a signer engine instance
    ApkSignerEngine signerEngine;
    if (mSignerEngine != null) {
        // Use the provided signer engine
        signerEngine = mSignerEngine;
    } else {
        // Construct a signer engine from the provided parameters
        int minSdkVersion;
        if (mMinSdkVersion != null) {
            // No need to extract minSdkVersion from the APK's AndroidManifest.xml
            minSdkVersion = mMinSdkVersion;
        } else {
            // Need to extract minSdkVersion from the APK's AndroidManifest.xml
            minSdkVersion = getMinSdkVersionFromApk(inputCdRecords, inputApkLfhSection);
        }
        List<DefaultApkSignerEngine.SignerConfig> engineSignerConfigs = new ArrayList<>(mSignerConfigs.size());
        for (SignerConfig signerConfig : mSignerConfigs) {
            engineSignerConfigs.add(new DefaultApkSignerEngine.SignerConfig.Builder(signerConfig.getName(), signerConfig.getPrivateKey(), signerConfig.getCertificates()).build());
        }
        DefaultApkSignerEngine.Builder signerEngineBuilder = new DefaultApkSignerEngine.Builder(engineSignerConfigs, minSdkVersion).setV1SigningEnabled(mV1SigningEnabled).setV2SigningEnabled(mV2SigningEnabled).setOtherSignersSignaturesPreserved(mOtherSignersSignaturesPreserved);
        if (mCreatedBy != null) {
            signerEngineBuilder.setCreatedBy(mCreatedBy);
        }
        signerEngine = signerEngineBuilder.build();
    }
    // Step 4. Provide the signer engine with the input APK's APK Signing Block (if any)
    if (inputApkSigningBlock != null) {
        signerEngine.inputApkSigningBlock(inputApkSigningBlock);
    }
    // Step 5. Iterate over input APK's entries and output the Local File Header + data of those
    // entries which need to be output. Entries are iterated in the order in which their Local
    // File Header records are stored in the file. This is to achieve better data locality in
    // case Central Directory entries are in the wrong order.
    List<CentralDirectoryRecord> inputCdRecordsSortedByLfhOffset = new ArrayList<>(inputCdRecords);
    Collections.sort(inputCdRecordsSortedByLfhOffset, CentralDirectoryRecord.BY_LOCAL_FILE_HEADER_OFFSET_COMPARATOR);
    int lastModifiedDateForNewEntries = -1;
    int lastModifiedTimeForNewEntries = -1;
    long inputOffset = 0;
    long outputOffset = 0;
    Map<String, CentralDirectoryRecord> outputCdRecordsByName = new HashMap<>(inputCdRecords.size());
    for (final CentralDirectoryRecord inputCdRecord : inputCdRecordsSortedByLfhOffset) {
        String entryName = inputCdRecord.getName();
        ApkSignerEngine.InputJarEntryInstructions entryInstructions = signerEngine.inputJarEntry(entryName);
        boolean shouldOutput;
        switch(entryInstructions.getOutputPolicy()) {
            case OUTPUT:
                shouldOutput = true;
                break;
            case OUTPUT_BY_ENGINE:
            case SKIP:
                shouldOutput = false;
                break;
            default:
                throw new RuntimeException("Unknown output policy: " + entryInstructions.getOutputPolicy());
        }
        long inputLocalFileHeaderStartOffset = inputCdRecord.getLocalFileHeaderOffset();
        if (inputLocalFileHeaderStartOffset > inputOffset) {
            // Unprocessed data in input starting at inputOffset and ending and the start of
            // this record's LFH. We output this data verbatim because this signer is supposed
            // to preserve as much of input as possible.
            long chunkSize = inputLocalFileHeaderStartOffset - inputOffset;
            inputApkLfhSection.feed(inputOffset, chunkSize, outputApkOut);
            outputOffset += chunkSize;
            inputOffset = inputLocalFileHeaderStartOffset;
        }
        LocalFileRecord inputLocalFileRecord;
        try {
            inputLocalFileRecord = LocalFileRecord.getRecord(inputApkLfhSection, inputCdRecord, inputApkLfhSection.size());
        } catch (ZipFormatException e) {
            throw new ApkFormatException("Malformed ZIP entry: " + inputCdRecord.getName(), e);
        }
        inputOffset += inputLocalFileRecord.getSize();
        ApkSignerEngine.InspectJarEntryRequest inspectEntryRequest = entryInstructions.getInspectJarEntryRequest();
        if (inspectEntryRequest != null) {
            fulfillInspectInputJarEntryRequest(inputApkLfhSection, inputLocalFileRecord, inspectEntryRequest);
        }
        if (shouldOutput) {
            // Find the max value of last modified, to be used for new entries added by the
            // signer.
            int lastModifiedDate = inputCdRecord.getLastModificationDate();
            int lastModifiedTime = inputCdRecord.getLastModificationTime();
            if ((lastModifiedDateForNewEntries == -1) || (lastModifiedDate > lastModifiedDateForNewEntries) || ((lastModifiedDate == lastModifiedDateForNewEntries) && (lastModifiedTime > lastModifiedTimeForNewEntries))) {
                lastModifiedDateForNewEntries = lastModifiedDate;
                lastModifiedTimeForNewEntries = lastModifiedTime;
            }
            inspectEntryRequest = signerEngine.outputJarEntry(entryName);
            if (inspectEntryRequest != null) {
                fulfillInspectInputJarEntryRequest(inputApkLfhSection, inputLocalFileRecord, inspectEntryRequest);
            }
            // Output entry's Local File Header + data
            long outputLocalFileHeaderOffset = outputOffset;
            long outputLocalFileRecordSize = outputInputJarEntryLfhRecordPreservingDataAlignment(inputApkLfhSection, inputLocalFileRecord, outputApkOut, outputLocalFileHeaderOffset);
            outputOffset += outputLocalFileRecordSize;
            // Enqueue entry's Central Directory record for output
            CentralDirectoryRecord outputCdRecord;
            if (outputLocalFileHeaderOffset == inputLocalFileRecord.getStartOffsetInArchive()) {
                outputCdRecord = inputCdRecord;
            } else {
                outputCdRecord = inputCdRecord.createWithModifiedLocalFileHeaderOffset(outputLocalFileHeaderOffset);
            }
            outputCdRecordsByName.put(entryName, outputCdRecord);
        }
    }
    long inputLfhSectionSize = inputApkLfhSection.size();
    if (inputOffset < inputLfhSectionSize) {
        // Unprocessed data in input starting at inputOffset and ending and the end of the input
        // APK's LFH section. We output this data verbatim because this signer is supposed
        // to preserve as much of input as possible.
        long chunkSize = inputLfhSectionSize - inputOffset;
        inputApkLfhSection.feed(inputOffset, chunkSize, outputApkOut);
        outputOffset += chunkSize;
        inputOffset = inputLfhSectionSize;
    }
    // Step 6. Sort output APK's Central Directory records in the order in which they should
    // appear in the output
    List<CentralDirectoryRecord> outputCdRecords = new ArrayList<>(inputCdRecords.size() + 10);
    for (CentralDirectoryRecord inputCdRecord : inputCdRecords) {
        String entryName = inputCdRecord.getName();
        CentralDirectoryRecord outputCdRecord = outputCdRecordsByName.get(entryName);
        if (outputCdRecord != null) {
            outputCdRecords.add(outputCdRecord);
        }
    }
    // Step 7. Generate and output JAR signatures, if necessary. This may output more Local File
    // Header + data entries and add to the list of output Central Directory records.
    ApkSignerEngine.OutputJarSignatureRequest outputJarSignatureRequest = signerEngine.outputJarEntries();
    if (outputJarSignatureRequest != null) {
        if (lastModifiedDateForNewEntries == -1) {
            // Jan 1 2009 (DOS)
            lastModifiedDateForNewEntries = 0x3a21;
            lastModifiedTimeForNewEntries = 0;
        }
        for (ApkSignerEngine.OutputJarSignatureRequest.JarEntry entry : outputJarSignatureRequest.getAdditionalJarEntries()) {
            String entryName = entry.getName();
            byte[] uncompressedData = entry.getData();
            ZipUtils.DeflateResult deflateResult = ZipUtils.deflate(ByteBuffer.wrap(uncompressedData));
            byte[] compressedData = deflateResult.output;
            long uncompressedDataCrc32 = deflateResult.inputCrc32;
            ApkSignerEngine.InspectJarEntryRequest inspectEntryRequest = signerEngine.outputJarEntry(entryName);
            if (inspectEntryRequest != null) {
                inspectEntryRequest.getDataSink().consume(uncompressedData, 0, uncompressedData.length);
                inspectEntryRequest.done();
            }
            long localFileHeaderOffset = outputOffset;
            outputOffset += LocalFileRecord.outputRecordWithDeflateCompressedData(entryName, lastModifiedTimeForNewEntries, lastModifiedDateForNewEntries, compressedData, uncompressedDataCrc32, uncompressedData.length, outputApkOut);
            outputCdRecords.add(CentralDirectoryRecord.createWithDeflateCompressedData(entryName, lastModifiedTimeForNewEntries, lastModifiedDateForNewEntries, uncompressedDataCrc32, compressedData.length, uncompressedData.length, localFileHeaderOffset));
        }
        outputJarSignatureRequest.done();
    }
    // aligned.
    if (outputOffset % ANDROID_COMMON_PAGE_ALIGNMENT_BYTES != 0) {
        long apkSigningBlockPadSize = ANDROID_COMMON_PAGE_ALIGNMENT_BYTES - outputOffset % ANDROID_COMMON_PAGE_ALIGNMENT_BYTES;
        outputApkOut.consume(ByteBuffer.allocate((int) apkSigningBlockPadSize));
        outputOffset += apkSigningBlockPadSize;
    }
    // Step 9. Construct output ZIP Central Directory in an in-memory buffer
    long outputCentralDirSizeBytes = 0;
    for (CentralDirectoryRecord record : outputCdRecords) {
        outputCentralDirSizeBytes += record.getSize();
    }
    if (outputCentralDirSizeBytes > Integer.MAX_VALUE) {
        throw new IOException("Output ZIP Central Directory too large: " + outputCentralDirSizeBytes + " bytes");
    }
    ByteBuffer outputCentralDir = ByteBuffer.allocate((int) outputCentralDirSizeBytes);
    for (CentralDirectoryRecord record : outputCdRecords) {
        record.copyTo(outputCentralDir);
    }
    outputCentralDir.flip();
    DataSource outputCentralDirDataSource = new ByteBufferDataSource(outputCentralDir);
    long outputCentralDirStartOffset = outputOffset;
    int outputCentralDirRecordCount = outputCdRecords.size();
    // Step 10. Construct output ZIP End of Central Directory record in an in-memory buffer
    ByteBuffer outputEocd = EocdRecord.createWithModifiedCentralDirectoryInfo(inputZipSections.getZipEndOfCentralDirectory(), outputCentralDirRecordCount, outputCentralDirDataSource.size(), outputCentralDirStartOffset);
    // Step 11. Generate and output APK Signature Scheme v2 signatures, if necessary. This may
    // insert an APK Signing Block just before the output's ZIP Central Directory
    ApkSignerEngine.OutputApkSigningBlockRequest outputApkSigingBlockRequest = signerEngine.outputZipSections(outputApkIn, outputCentralDirDataSource, DataSources.asDataSource(outputEocd));
    if (outputApkSigingBlockRequest != null) {
        byte[] outputApkSigningBlock = outputApkSigingBlockRequest.getApkSigningBlock();
        outputApkOut.consume(outputApkSigningBlock, 0, outputApkSigningBlock.length);
        ZipUtils.setZipEocdCentralDirectoryOffset(outputEocd, outputCentralDirStartOffset + outputApkSigningBlock.length);
        outputApkSigingBlockRequest.done();
    }
    // Step 12. Output ZIP Central Directory and ZIP End of Central Directory
    outputCentralDirDataSource.feed(0, outputCentralDirDataSource.size(), outputApkOut);
    outputApkOut.consume(outputEocd);
    signerEngine.outputDone();
}
#end_block

#method_before
private static int getInputJarEntryDataAlignmentMultiple(LocalFileRecord entry) {
    if (entry.isDataCompressed()) {
        // Compressed entries don't need to be aligned
        return 1;
    }
    // Attempt to obtain the alignment multiple from the entry's extra field.
    ByteBuffer extra = entry.getExtra();
    if (extra.hasRemaining()) {
        extra.order(ByteOrder.LITTLE_ENDIAN);
        // * 'size' bytes: payload
        while (extra.remaining() >= 4) {
            short headerId = extra.getShort();
            int dataSize = ZipUtils.getUnsignedInt16(extra);
            if (dataSize > extra.remaining()) {
                // Malformed field -- insufficient input remaining
                break;
            }
            if (headerId != ALIGNMENT_ZIP_EXTRA_DATA_FIELD_HEADER_ID) {
                // Skip this field
                extra.position(extra.position() + dataSize);
                continue;
            }
            // the extra field
            if (dataSize < 2) {
                // Malformed
                break;
            }
            return ZipUtils.getUnsignedInt16(extra);
        }
    }
    // Fall back to filename-based defaults
    return (entry.getName().endsWith(".so")) ? LINUX_COMMON_PAGE_ALIGNMENT_BYTES : 4;
}
#method_after
private static int getInputJarEntryDataAlignmentMultiple(LocalFileRecord entry) {
    if (entry.isDataCompressed()) {
        // Compressed entries don't need to be aligned
        return 1;
    }
    // Attempt to obtain the alignment multiple from the entry's extra field.
    ByteBuffer extra = entry.getExtra();
    if (extra.hasRemaining()) {
        extra.order(ByteOrder.LITTLE_ENDIAN);
        // * 'size' bytes: payload
        while (extra.remaining() >= 4) {
            short headerId = extra.getShort();
            int dataSize = ZipUtils.getUnsignedInt16(extra);
            if (dataSize > extra.remaining()) {
                // Malformed field -- insufficient input remaining
                break;
            }
            if (headerId != ALIGNMENT_ZIP_EXTRA_DATA_FIELD_HEADER_ID) {
                // Skip this field
                extra.position(extra.position() + dataSize);
                continue;
            }
            // the extra field
            if (dataSize < 2) {
                // Malformed
                break;
            }
            return ZipUtils.getUnsignedInt16(extra);
        }
    }
    // Fall back to filename-based defaults
    return (entry.getName().endsWith(".so")) ? ANDROID_COMMON_PAGE_ALIGNMENT_BYTES : 4;
}
#end_block

#method_before
public ApkSigner build() {
    return new ApkSigner(mSignerConfigs, mMinSdkVersion, mV1SigningEnabled, mV2SigningEnabled, mOtherSignersSignaturesPreserved, mCreatedBy, mSignerEngine, mInputApkFile, mInputApkDataSource, mOutputApkFile, mOutputApkDataSink, mOutputApkDataSource);
}
#method_after
public SignerConfig build() {
    return new SignerConfig(mName, mPrivateKey, mCertificates);
}
#end_block

#method_before
private static byte[] generateApkSigningBlock(byte[] apkSignatureSchemeV2Block) {
    // FORMAT:
    // uint64:  size (excluding this field)
    // repeated ID-value pairs:
    // uint64:           size (excluding this field)
    // uint32:           ID
    // (size - 4) bytes: value
    // (4096 - total size of other fields % 4096) bytes: padding
    // uint64:  size (same as the one above)
    // uint128: magic
    int resultSize = // size
    8 + 8 + 4 + // v2Block as ID-value pair
    apkSignatureSchemeV2Block.length + // size
    8 + // magic
    16;
    int padding = 4096 - (resultSize % 4096);
    resultSize += padding;
    ByteBuffer result = ByteBuffer.allocate(resultSize);
    result.order(ByteOrder.LITTLE_ENDIAN);
    long blockSizeFieldValue = resultSize - 8;
    result.putLong(blockSizeFieldValue);
    long pairSizeFieldValue = 4 + apkSignatureSchemeV2Block.length;
    result.putLong(pairSizeFieldValue);
    result.putInt(APK_SIGNATURE_SCHEME_V2_BLOCK_ID);
    result.put(apkSignatureSchemeV2Block);
    result.put(ByteBuffer.allocate(padding));
    result.putLong(blockSizeFieldValue);
    result.put(APK_SIGNING_BLOCK_MAGIC);
    return result.array();
}
#method_after
private static byte[] generateApkSigningBlock(byte[] apkSignatureSchemeV2Block) {
    // FORMAT:
    // uint64:  size (excluding this field)
    // repeated ID-value pairs:
    // uint64:           size (excluding this field)
    // uint32:           ID
    // (size - 4) bytes: value
    // (extra dummy ID-value for padding to make block size a multiple of 4096 bytes)
    // uint64:  size (same as the one above)
    // uint128: magic
    int resultSize = // size
    8 + 8 + 4 + // v2Block as ID-value pair
    apkSignatureSchemeV2Block.length + // size
    8 + // magic
    16;
    ByteBuffer paddingPair = null;
    if (resultSize % ANDROID_COMMON_PAGE_ALIGNMENT_BYTES != 0) {
        int padding = ANDROID_COMMON_PAGE_ALIGNMENT_BYTES - (resultSize % ANDROID_COMMON_PAGE_ALIGNMENT_BYTES);
        if (padding < 12) {
            // minimum size of an ID-value pair
            padding += ANDROID_COMMON_PAGE_ALIGNMENT_BYTES;
        }
        paddingPair = ByteBuffer.allocate(padding).order(ByteOrder.LITTLE_ENDIAN);
        paddingPair.putLong(padding - 8);
        paddingPair.putInt(VERITY_PADDING_BLOCK_ID);
        paddingPair.rewind();
        resultSize += padding;
    }
    ByteBuffer result = ByteBuffer.allocate(resultSize);
    result.order(ByteOrder.LITTLE_ENDIAN);
    long blockSizeFieldValue = resultSize - 8;
    result.putLong(blockSizeFieldValue);
    long pairSizeFieldValue = 4 + apkSignatureSchemeV2Block.length;
    result.putLong(pairSizeFieldValue);
    result.putInt(APK_SIGNATURE_SCHEME_V2_BLOCK_ID);
    result.put(apkSignatureSchemeV2Block);
    if (paddingPair != null) {
        result.put(paddingPair);
    }
    result.putLong(blockSizeFieldValue);
    result.put(APK_SIGNING_BLOCK_MAGIC);
    return result.array();
}
#end_block

#method_before
@Override
public Builder withoutIPv4() {
    return (Builder) super.withoutIPv4();
}
#method_after
@Override
public Builder withoutIPv4() {
    super.withoutIPv4();
    return this;
}
#end_block

#method_before
@Override
public Builder withoutIPv6() {
    return (Builder) super.withoutIPv6();
}
#method_after
@Override
public Builder withoutIPv6() {
    super.withoutIPv6();
    return this;
}
#end_block

#method_before
@Override
public Builder withoutIpReachabilityMonitor() {
    return (Builder) super.withoutIpReachabilityMonitor();
}
#method_after
@Override
public Builder withoutIpReachabilityMonitor() {
    super.withoutIpReachabilityMonitor();
    return this;
}
#end_block

#method_before
@Override
public Builder withPreDhcpAction() {
    return (Builder) super.withPreDhcpAction();
}
#method_after
@Override
public Builder withPreDhcpAction() {
    super.withPreDhcpAction();
    return this;
}
#end_block

#method_before
@Override
public Builder withPreDhcpAction(int dhcpActionTimeoutMs) {
    return (Builder) super.withPreDhcpAction(dhcpActionTimeoutMs);
}
#method_after
@Override
public Builder withPreDhcpAction(int dhcpActionTimeoutMs) {
    super.withPreDhcpAction(dhcpActionTimeoutMs);
    return this;
}
#end_block

#method_before
public Builder withInitialConfiguration(InitialConfiguration initialConfig) {
    return (Builder) super.withInitialConfiguration((IpClient.InitialConfiguration) initialConfig);
}
#method_after
public Builder withInitialConfiguration(InitialConfiguration initialConfig) {
    super.withInitialConfiguration((IpClient.InitialConfiguration) initialConfig);
    return this;
}
#end_block

#method_before
@Override
public Builder withStaticConfiguration(StaticIpConfiguration staticConfig) {
    return (Builder) super.withStaticConfiguration(staticConfig);
}
#method_after
@Override
public Builder withStaticConfiguration(StaticIpConfiguration staticConfig) {
    super.withStaticConfiguration(staticConfig);
    return this;
}
#end_block

#method_before
@Override
public Builder withApfCapabilities(ApfCapabilities apfCapabilities) {
    return (Builder) super.withApfCapabilities(apfCapabilities);
}
#method_after
@Override
public Builder withApfCapabilities(ApfCapabilities apfCapabilities) {
    super.withApfCapabilities(apfCapabilities);
    return this;
}
#end_block

#method_before
@Override
public Builder withProvisioningTimeoutMs(int timeoutMs) {
    return (Builder) super.withProvisioningTimeoutMs(timeoutMs);
}
#method_after
@Override
public Builder withProvisioningTimeoutMs(int timeoutMs) {
    super.withProvisioningTimeoutMs(timeoutMs);
    return this;
}
#end_block

#method_before
@Override
public Builder withIPv6AddrGenModeEUI64() {
    return (Builder) super.withIPv6AddrGenModeEUI64();
}
#method_after
@Override
public Builder withIPv6AddrGenModeEUI64() {
    super.withIPv6AddrGenModeEUI64();
    return this;
}
#end_block

#method_before
@Override
public Builder withIPv6AddrGenModeStablePrivacy() {
    return (Builder) super.withIPv6AddrGenModeStablePrivacy();
}
#method_after
@Override
public Builder withIPv6AddrGenModeStablePrivacy() {
    super.withIPv6AddrGenModeStablePrivacy();
    return this;
}
#end_block

#method_before
@Override
public Builder withNetwork(Network network) {
    return (Builder) super.withNetwork(network);
}
#method_after
@Override
public Builder withNetwork(Network network) {
    super.withNetwork(network);
    return this;
}
#end_block

#method_before
@Override
public Builder withDisplayName(String displayName) {
    return (Builder) super.withDisplayName(displayName);
}
#method_after
@Override
public Builder withDisplayName(String displayName) {
    super.withDisplayName(displayName);
    return this;
}
#end_block

#method_before
@Override
public void onResult(Bundle result) {
    Bundle.setDefusable(result, true);
    if (result != null && result.containsKey(AccountManager.KEY_BOOLEAN_RESULT) && !result.containsKey(AccountManager.KEY_INTENT)) {
        final boolean removalAllowed = result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT);
        if (removalAllowed) {
            removeAccountInternal(mAccounts, mAccount, getCallingUid());
        }
        IAccountManagerResponse response = getResponseAndClose();
        if (response != null) {
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, getClass().getSimpleName() + " calling onResult() on response " + response);
            }
            try {
                response.onResult(result);
            } catch (RemoteException e) {
                Log.w(TAG, e.getMessage());
            }
        }
    }
    super.onResult(result);
}
#method_after
@Override
public void onResult(Bundle result) {
    Bundle.setDefusable(result, true);
    if (result != null && result.containsKey(AccountManager.KEY_BOOLEAN_RESULT) && !result.containsKey(AccountManager.KEY_INTENT)) {
        final boolean removalAllowed = result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT);
        if (removalAllowed) {
            removeAccountInternal(mAccounts, mAccount, getCallingUid());
        }
        IAccountManagerResponse response = getResponseAndClose();
        if (response != null) {
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, getClass().getSimpleName() + " calling onResult() on response " + response);
            }
            try {
                response.onResult(result);
            } catch (RemoteException e) {
                Slog.e(TAG, "Error calling onResult()", e);
            }
        }
    }
    super.onResult(result);
}
#end_block

#method_before
private int parsePinPukErrorResult(AsyncResult ar) {
    Integer result = (Integer) ar.result;
    if (result == null) {
        return -1;
    } else {
        int attemptsRemaining = result;
        log("parsePinPukErrorResult: attemptsRemaining=" + attemptsRemaining);
        return attemptsRemaining;
    }
}
#method_after
private int parsePinPukErrorResult(AsyncResult ar) {
    int[] result = (int[]) ar.result;
    if (result == null) {
        return -1;
    } else {
        int length = result.length;
        int attemptsRemaining = -1;
        if (length > 0) {
            attemptsRemaining = result[0];
        }
        log("parsePinPukErrorResult: attemptsRemaining=" + attemptsRemaining);
        return attemptsRemaining;
    }
}
#end_block

#method_before
@SystemApi
public void updateConfigForPhoneId(int phoneId, String simState) {
    try {
        ICarrierConfigLoader loader = getICarrierConfigLoader();
        if (loader == null) {
            Rlog.w(TAG, "Error updating config for phoneId=" + phoneId + " ICarrierConfigLoader is null");
            return;
        }
        loader.updateConfigForPhoneId(phoneId, simState);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "Error updating config for phoneId=" + phoneId + ": " + ex.toString());
    }
}
#method_after
@SystemApi
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void updateConfigForPhoneId(int phoneId, String simState) {
    try {
        ICarrierConfigLoader loader = getICarrierConfigLoader();
        if (loader == null) {
            Rlog.w(TAG, "Error updating config for phoneId=" + phoneId + " ICarrierConfigLoader is null");
            return;
        }
        loader.updateConfigForPhoneId(phoneId, simState);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "Error updating config for phoneId=" + phoneId + ": " + ex.toString());
    }
}
#end_block

#method_before
@NonNull
@SystemApi
public static PersistableBundle getDefaultConfig() {
    return new PersistableBundle(sDefaults);
}
#method_after
@NonNull
@SystemApi
@SuppressLint("Doclava125")
public static PersistableBundle getDefaultConfig() {
    return new PersistableBundle(sDefaults);
}
#end_block

#method_before
// END Android-changed: Avoid use of removed Class.getPrimitiveClass method.
public static String toString(long i, int radix) {
    if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)
        radix = 10;
    if (radix == 10)
        return toString(i);
    char[] buf = new char[65];
    int charPos = 64;
    boolean negative = (i < 0);
    if (!negative) {
        i = -i;
    }
    while (i <= -radix) {
        buf[charPos--] = Integer.digits[(int) (-(i % radix))];
        i = i / radix;
    }
    buf[charPos] = Integer.digits[(int) (-i)];
    if (negative) {
        buf[--charPos] = '-';
    }
    return new String(buf, charPos, (65 - charPos));
}
#method_after
public static String toString(long i, int radix) {
    if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)
        radix = 10;
    if (radix == 10)
        return toString(i);
    char[] buf = new char[65];
    int charPos = 64;
    boolean negative = (i < 0);
    if (!negative) {
        i = -i;
    }
    while (i <= -radix) {
        buf[charPos--] = Integer.digits[(int) (-(i % radix))];
        i = i / radix;
    }
    buf[charPos] = Integer.digits[(int) (-i)];
    if (negative) {
        buf[--charPos] = '-';
    }
    return new String(buf, charPos, (65 - charPos));
}
#end_block

#method_before
// END Android-changed: Avoid use of removed Class.getPrimitiveClass method.
public static String toString(double d) {
    return FloatingDecimal.toJavaFormatString(d);
}
#method_after
public static String toString(double d) {
    return FloatingDecimal.toJavaFormatString(d);
}
#end_block

#method_before
// END Android-changed: Avoid use of removed Class.getPrimitiveClass method.
public static String toString(byte b) {
    return Integer.toString((int) b, 10);
}
#method_after
public static String toString(byte b) {
    return Integer.toString((int) b, 10);
}
#end_block

#method_before
public static int parseInt(String s, int radix) throws NumberFormatException {
    if (s == null) {
        throw new NumberFormatException("null");
    }
    if (radix < Character.MIN_RADIX) {
        throw new NumberFormatException("radix " + radix + " less than Character.MIN_RADIX");
    }
    if (radix > Character.MAX_RADIX) {
        throw new NumberFormatException("radix " + radix + " greater than Character.MAX_RADIX");
    }
    int result = 0;
    boolean negative = false;
    int i = 0, len = s.length();
    int limit = -Integer.MAX_VALUE;
    int multmin;
    int digit;
    if (len > 0) {
        char firstChar = s.charAt(0);
        if (firstChar < '0') {
            // Possible leading "+" or "-"
            if (firstChar == '-') {
                negative = true;
                limit = Integer.MIN_VALUE;
            } else if (firstChar != '+')
                throw NumberFormatException.forInputString(s);
            if (// Cannot have lone "+" or "-"
            len == 1)
                throw NumberFormatException.forInputString(s);
            i++;
        }
        multmin = limit / radix;
        while (i < len) {
            // Accumulating negatively avoids surprises near MAX_VALUE
            digit = Character.digit(s.charAt(i++), radix);
            if (digit < 0) {
                throw NumberFormatException.forInputString(s);
            }
            if (result < multmin) {
                throw NumberFormatException.forInputString(s);
            }
            result *= radix;
            if (result < limit + digit) {
                throw NumberFormatException.forInputString(s);
            }
            result -= digit;
        }
    } else {
        throw NumberFormatException.forInputString(s);
    }
    return negative ? result : -result;
}
#method_after
public static int parseInt(String s, int radix) throws NumberFormatException {
    if (s == null) {
        // Android-changed: Improve exception message for parseInt.
        throw new NumberFormatException("s == null");
    }
    if (radix < Character.MIN_RADIX) {
        throw new NumberFormatException("radix " + radix + " less than Character.MIN_RADIX");
    }
    if (radix > Character.MAX_RADIX) {
        throw new NumberFormatException("radix " + radix + " greater than Character.MAX_RADIX");
    }
    int result = 0;
    boolean negative = false;
    int i = 0, len = s.length();
    int limit = -Integer.MAX_VALUE;
    int multmin;
    int digit;
    if (len > 0) {
        char firstChar = s.charAt(0);
        if (firstChar < '0') {
            // Possible leading "+" or "-"
            if (firstChar == '-') {
                negative = true;
                limit = Integer.MIN_VALUE;
            } else if (firstChar != '+')
                throw NumberFormatException.forInputString(s);
            if (// Cannot have lone "+" or "-"
            len == 1)
                throw NumberFormatException.forInputString(s);
            i++;
        }
        multmin = limit / radix;
        while (i < len) {
            // Accumulating negatively avoids surprises near MAX_VALUE
            digit = Character.digit(s.charAt(i++), radix);
            if (digit < 0) {
                throw NumberFormatException.forInputString(s);
            }
            if (result < multmin) {
                throw NumberFormatException.forInputString(s);
            }
            result *= radix;
            if (result < limit + digit) {
                throw NumberFormatException.forInputString(s);
            }
            result -= digit;
        }
    } else {
        throw NumberFormatException.forInputString(s);
    }
    return negative ? result : -result;
}
#end_block

#method_before
// END Android-changed: Avoid use of removed Class.getPrimitiveClass method.
public static String toString(short s) {
    return Integer.toString((int) s, 10);
}
#method_after
public static String toString(short s) {
    return Integer.toString((int) s, 10);
}
#end_block

#method_before
// END Android-changed: Avoid use of removed Class.getPrimitiveClass method.
public static String toString(float f) {
    return FloatingDecimal.toJavaFormatString(f);
}
#method_after
public static String toString(float f) {
    return FloatingDecimal.toJavaFormatString(f);
}
#end_block

#method_before
@Override
public Entity toEntity() {
    Entity branchEntity = new Entity(this.key);
    return branchEntity;
}
#method_after
@Override
public Entity toEntity() {
    return new Entity(this.key);
}
#end_block

#method_before
public static BranchEntity fromEntity(Entity e) {
    if (!e.getKind().equals(KIND) || e.getKey().getName() == null) {
        logger.log(Level.WARNING, "Missing test attributes in entity: " + e.toString());
        return null;
    }
    String branchName = e.getKey().getName();
    return new BranchEntity(branchName);
}
#method_after
public static BranchEntity fromEntity(Entity e) {
    if (!e.getKind().equals(KIND) || e.getKey().getName() == null) {
        logger.log(Level.WARNING, "Missing branch attributes in entity: " + e.toString());
        return null;
    }
    String branchName = e.getKey().getName();
    return new BranchEntity(branchName);
}
#end_block

#method_before
@Override
public Entity toEntity() {
    Entity targetEntity = new Entity(this.key);
    return targetEntity;
}
#method_after
@Override
public Entity toEntity() {
    return new Entity(this.key);
}
#end_block

#method_before
public static BuildTargetEntity fromEntity(Entity e) {
    if (!e.getKind().equals(KIND) || e.getKey().getName() == null) {
        logger.log(Level.WARNING, "Missing test attributes in entity: " + e.toString());
        return null;
    }
    String targetName = e.getKey().getName();
    return new BuildTargetEntity(targetName);
}
#method_after
public static BuildTargetEntity fromEntity(Entity e) {
    if (!e.getKind().equals(KIND) || e.getKey().getName() == null) {
        logger.log(Level.WARNING, "Missing build target attributes in entity: " + e.toString());
        return null;
    }
    String targetName = e.getKey().getName();
    return new BuildTargetEntity(targetName);
}
#end_block

#method_before
private MethodHandle findAccessor(Field field, Class<?> refc, Class<?> type, int kind, boolean performAccessChecks) throws IllegalAccessException {
    final boolean isStaticKind = kind == MethodHandle.SGET || kind == MethodHandle.SPUT;
    final boolean isSetterKind = kind == MethodHandle.IPUT || kind == MethodHandle.SPUT;
    commonFieldChecks(field, refc, type, isStaticKind, isSetterKind, performAccessChecks);
    final MethodType methodType;
    switch(kind) {
        case MethodHandle.SGET:
            methodType = MethodType.methodType(type);
            break;
        case MethodHandle.SPUT:
            methodType = MethodType.methodType(void.class, type);
            break;
        case MethodHandle.IGET:
            methodType = MethodType.methodType(type, refc);
            break;
        case MethodHandle.IPUT:
            methodType = MethodType.methodType(void.class, refc, type);
            break;
        default:
            throw new IllegalArgumentException("Invalid kind " + kind);
    }
    return new MethodHandleImpl(field.getArtField(), kind, methodType);
}
#method_after
private MethodHandle findAccessor(Field field, Class<?> refc, Class<?> type, int kind, boolean performAccessChecks) throws IllegalAccessException {
    final boolean isSetterKind = kind == MethodHandle.IPUT || kind == MethodHandle.SPUT;
    final boolean isStaticKind = kind == MethodHandle.SGET || kind == MethodHandle.SPUT;
    commonFieldChecks(field, refc, type, isStaticKind, performAccessChecks);
    if (performAccessChecks) {
        final int modifiers = field.getModifiers();
        if (isSetterKind && Modifier.isFinal(modifiers)) {
            throw new IllegalAccessException("Field " + field + " is final");
        }
    }
    final MethodType methodType;
    switch(kind) {
        case MethodHandle.SGET:
            methodType = MethodType.methodType(type);
            break;
        case MethodHandle.SPUT:
            methodType = MethodType.methodType(void.class, type);
            break;
        case MethodHandle.IGET:
            methodType = MethodType.methodType(type, refc);
            break;
        case MethodHandle.IPUT:
            methodType = MethodType.methodType(void.class, refc, type);
            break;
        default:
            throw new IllegalArgumentException("Invalid kind " + kind);
    }
    return new MethodHandleImpl(field.getArtField(), kind, methodType);
}
#end_block

#method_before
// BEGIN Android-changed: OpenJDK 9+181 VarHandle API factory method for bring up purposes.
public VarHandle findVarHandle(Class<?> recv, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
    final Field field = findFieldOfType(recv, name, type);
    commonFieldChecks(field, recv, type, false, /* isStatic */
    false, /* isSetter */
    true);
    return FieldVarHandle.create(field);
}
#method_after
// BEGIN Android-changed: OpenJDK 9+181 VarHandle API factory method.
public VarHandle findVarHandle(Class<?> recv, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
    final Field field = findFieldOfType(recv, name, type);
    final boolean isStatic = false;
    final boolean performAccessChecks = true;
    commonFieldChecks(field, recv, type, isStatic, performAccessChecks);
    return FieldVarHandle.create(field);
}
#end_block

#method_before
// END Android-changed: OpenJDK 9+181 VarHandle API factory method for bring up purposes.
private Field findFieldOfType(final Class<?> refc, String name, Class<?> type) throws NoSuchFieldException {
    Field field = null;
    // Search refc and super classes for the field.
    for (Class<?> cls = refc; cls != null; cls = cls.getSuperclass()) {
        try {
            field = cls.getDeclaredField(name);
            break;
        } catch (NoSuchFieldException e) {
        }
    }
    if (field == null) {
        // Force failure citing refc.
        field = refc.getDeclaredField(name);
    }
    final Class<?> fieldType = field.getType();
    if (fieldType != type) {
        throw new NoSuchFieldException("Field has wrong type: " + fieldType + " != " + type);
    }
    return field;
}
#method_after
// END Android-changed: OpenJDK 9+181 VarHandle API factory method.
private Field findFieldOfType(final Class<?> refc, String name, Class<?> type) throws NoSuchFieldException {
    Field field = null;
    // Search refc and super classes for the field.
    for (Class<?> cls = refc; cls != null; cls = cls.getSuperclass()) {
        try {
            field = cls.getDeclaredField(name);
            break;
        } catch (NoSuchFieldException e) {
        }
    }
    if (field == null) {
        // Force failure citing refc.
        field = refc.getDeclaredField(name);
    }
    final Class<?> fieldType = field.getType();
    if (fieldType != type) {
        throw new NoSuchFieldException(name);
    }
    return field;
}
#end_block

#method_before
private void commonFieldChecks(Field field, Class<?> refc, Class<?> type, boolean isStatic, boolean isSetter, boolean performAccessChecks) throws IllegalAccessException {
    if (performAccessChecks) {
        checkAccess(refc, field.getDeclaringClass(), field.getModifiers(), field.getName());
    }
    final int modifiers = field.getModifiers();
    if (Modifier.isStatic(modifiers) != isStatic) {
        String reason = "Field " + field + " is " + (isStatic ? "not " : "") + "static";
        throw new IllegalAccessException(reason);
    }
    if (Modifier.isFinal(modifiers) && isSetter) {
        throw new IllegalAccessException("Field " + field + " is final");
    }
}
#method_after
private void commonFieldChecks(Field field, Class<?> refc, Class<?> type, boolean isStatic, boolean performAccessChecks) throws IllegalAccessException {
    final int modifiers = field.getModifiers();
    if (performAccessChecks) {
        checkAccess(refc, field.getDeclaringClass(), modifiers, field.getName());
    }
    if (Modifier.isStatic(modifiers) != isStatic) {
        String reason = "Field " + field + " is " + (isStatic ? "not " : "") + "static";
        throw new IllegalAccessException(reason);
    }
}
#end_block

#method_before
// BEGIN Android-changed: OpenJDK 9+181 VarHandle API factory method for bring up purposes.
public VarHandle findStaticVarHandle(Class<?> decl, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
    final Field field = findFieldOfType(decl, name, type);
    commonFieldChecks(field, decl, type, true, /* isStatic */
    false, /* isSetter */
    true);
    return FieldVarHandle.create(field);
}
#method_after
// BEGIN Android-changed: OpenJDK 9+181 VarHandle API factory method.
public VarHandle findStaticVarHandle(Class<?> decl, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
    final Field field = findFieldOfType(decl, name, type);
    final boolean isStatic = true;
    final boolean performAccessChecks = true;
    commonFieldChecks(field, decl, type, isStatic, performAccessChecks);
    return FieldVarHandle.create(field);
}
#end_block

#method_before
// END Android-changed: OpenJDK 9+181 VarHandle API factory method for bring up purposes.
public MethodHandle bind(Object receiver, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
    MethodHandle handle = findVirtual(receiver.getClass(), name, type);
    MethodHandle adapter = handle.bindTo(receiver);
    MethodType adapterType = adapter.type();
    if (handle.isVarargsCollector()) {
        adapter = adapter.asVarargsCollector(adapterType.parameterType(adapterType.parameterCount() - 1));
    }
    return adapter;
}
#method_after
// END Android-changed: OpenJDK 9+181 VarHandle API factory method.
public MethodHandle bind(Object receiver, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
    MethodHandle handle = findVirtual(receiver.getClass(), name, type);
    MethodHandle adapter = handle.bindTo(receiver);
    MethodType adapterType = adapter.type();
    if (handle.isVarargsCollector()) {
        adapter = adapter.asVarargsCollector(adapterType.parameterType(adapterType.parameterCount() - 1));
    }
    return adapter;
}
#end_block

#method_before
// BEGIN Android-changed: OpenJDK 9+181 VarHandle API factory method for bring up purposes.
public VarHandle unreflectVarHandle(Field f) throws IllegalAccessException {
    commonFieldChecks(f, f.getDeclaringClass(), f.getType(), Modifier.isStatic(f.getModifiers()), false, /* isSetter */
    true);
    return FieldVarHandle.create(f);
}
#method_after
// BEGIN Android-changed: OpenJDK 9+181 VarHandle API factory method.
public VarHandle unreflectVarHandle(Field f) throws IllegalAccessException {
    final boolean isStatic = Modifier.isStatic(f.getModifiers());
    final boolean performAccessChecks = true;
    commonFieldChecks(f, f.getDeclaringClass(), f.getType(), isStatic, performAccessChecks);
    return FieldVarHandle.create(f);
}
#end_block

#method_before
// END Android-changed: OpenJDK 9+181 VarHandle API factory method for bring up purposes.
public MethodHandleInfo revealDirect(MethodHandle target) {
    MethodHandleImpl directTarget = getMethodHandleImpl(target);
    MethodHandleInfo info = directTarget.reveal();
    try {
        checkAccess(lookupClass(), info.getDeclaringClass(), info.getModifiers(), info.getName());
    } catch (IllegalAccessException exception) {
        throw new IllegalArgumentException("Unable to access memeber.", exception);
    }
    return info;
}
#method_after
// END Android-changed: OpenJDK 9+181 VarHandle API factory method.
public MethodHandleInfo revealDirect(MethodHandle target) {
    MethodHandleImpl directTarget = getMethodHandleImpl(target);
    MethodHandleInfo info = directTarget.reveal();
    try {
        checkAccess(lookupClass(), info.getDeclaringClass(), info.getModifiers(), info.getName());
    } catch (IllegalAccessException exception) {
        throw new IllegalArgumentException("Unable to access memeber.", exception);
    }
    return info;
}
#end_block

#method_before
// End Android-added: method to check if a class is an array.
public static MethodHandle arrayElementGetter(Class<?> arrayClass) throws IllegalArgumentException {
    checkClassIsArray(arrayClass);
    final Class<?> componentType = arrayClass.getComponentType();
    if (componentType.isPrimitive()) {
        try {
            return Lookup.PUBLIC_LOOKUP.findStatic(MethodHandles.class, "arrayElementGetter", MethodType.methodType(componentType, arrayClass, int.class));
        } catch (NoSuchMethodException | IllegalAccessException exception) {
            throw new AssertionError(exception);
        }
    }
    return new Transformers.ReferenceArrayElementGetter(arrayClass);
}
#method_after
// END Android-added: method to check if a class is an array.
public static MethodHandle arrayElementGetter(Class<?> arrayClass) throws IllegalArgumentException {
    checkClassIsArray(arrayClass);
    final Class<?> componentType = arrayClass.getComponentType();
    if (componentType.isPrimitive()) {
        try {
            return Lookup.PUBLIC_LOOKUP.findStatic(MethodHandles.class, "arrayElementGetter", MethodType.methodType(componentType, arrayClass, int.class));
        } catch (NoSuchMethodException | IllegalAccessException exception) {
            throw new AssertionError(exception);
        }
    }
    return new Transformers.ReferenceArrayElementGetter(arrayClass);
}
#end_block

#method_before
// BEGIN Android-changed: OpenJDK 9+181 VarHandle API factory methods for bring up purposes.
public static VarHandle arrayElementVarHandle(Class<?> arrayClass) throws IllegalArgumentException {
    checkClassIsArray(arrayClass);
    return ArrayElementVarHandle.create(arrayClass);
}
#method_after
// BEGIN Android-changed: OpenJDK 9+181 VarHandle API factory methods.
public static VarHandle arrayElementVarHandle(Class<?> arrayClass) throws IllegalArgumentException {
    checkClassIsArray(arrayClass);
    return ArrayElementVarHandle.create(arrayClass);
}
#end_block

#method_before
// END Android-changed: OpenJDK 9+181 VarHandle API factory methods for bring up purposes.
// / method handle invocation (reflective style)
static public MethodHandle spreadInvoker(MethodType type, int leadingArgCount) {
    if (leadingArgCount < 0 || leadingArgCount > type.parameterCount())
        throw newIllegalArgumentException("bad argument count", leadingArgCount);
    MethodHandle invoker = MethodHandles.invoker(type);
    int spreadArgCount = type.parameterCount() - leadingArgCount;
    invoker = invoker.asSpreader(Object[].class, spreadArgCount);
    return invoker;
}
#method_after
// END Android-changed: OpenJDK 9+181 VarHandle API factory methods.
// / method handle invocation (reflective style)
static public MethodHandle spreadInvoker(MethodType type, int leadingArgCount) {
    if (leadingArgCount < 0 || leadingArgCount > type.parameterCount())
        throw newIllegalArgumentException("bad argument count", leadingArgCount);
    MethodHandle invoker = MethodHandles.invoker(type);
    int spreadArgCount = type.parameterCount() - leadingArgCount;
    invoker = invoker.asSpreader(Object[].class, spreadArgCount);
    return invoker;
}
#end_block

#method_before
// BEGIN Android-removed: AccessDescriptor not used in Android implementation.
/*
    static final class AccessDescriptor {
        final MethodType symbolicMethodTypeErased;
        final MethodType symbolicMethodTypeInvoker;
        final Class<?> returnType;
        final int type;
        final int mode;

        public AccessDescriptor(MethodType symbolicMethodType, int type, int mode) {
            this.symbolicMethodTypeErased = symbolicMethodType.erase();
            this.symbolicMethodTypeInvoker = symbolicMethodType.insertParameterTypes(0, VarHandle.class);
            this.returnType = symbolicMethodType.returnType();
            this.type = type;
            this.mode = mode;
        }
    }
    */
// END Android-removed: AccessDescriptor not used in Android implementation.
public final Class<?> varType() {
    // Android-changed: use accessInfo.
    return accessInfo.varType();
}
#method_after
// BEGIN Android-removed: AccessDescriptor not used in Android implementation.
/*
    static final class AccessDescriptor {
        final MethodType symbolicMethodTypeErased;
        final MethodType symbolicMethodTypeInvoker;
        final Class<?> returnType;
        final int type;
        final int mode;

        public AccessDescriptor(MethodType symbolicMethodType, int type, int mode) {
            this.symbolicMethodTypeErased = symbolicMethodType.erase();
            this.symbolicMethodTypeInvoker = symbolicMethodType.insertParameterTypes(0, VarHandle.class);
            this.returnType = symbolicMethodType.returnType();
            this.type = type;
            this.mode = mode;
        }
    }
    */
// END Android-removed: AccessDescriptor not used in Android implementation.
public final Class<?> varType() {
    // Android-added: return instance field.
    return varType;
}
#end_block

#method_before
public final List<Class<?>> coordinateTypes() {
    // Android-changed: use accessInfo.
    return accessInfo.coordinateTypes();
}
#method_after
public final List<Class<?>> coordinateTypes() {
    // Android-added: return instance field.
    return coordinateTypes;
}
#end_block

#method_before
public final MethodType accessModeType(AccessMode accessMode) {
    // Android-added: use accessInfo here.
    return accessInfo.accessModeType(accessMode);
}
#method_after
public final MethodType accessModeType(AccessMode accessMode) {
    // Android-added: alternative implementation.
    switch(coordinateTypes.size()) {
        case 0:
            return accessMode.at.accessModeType(null, varType);
        case 1:
            return accessMode.at.accessModeType(coordinateTypes.get(0), varType);
        case 2:
            return accessMode.at.accessModeType(coordinateTypes.get(0), varType, coordinateTypes.get(1));
        default:
            throw new InternalError("bad coordinateTypes: " + coordinateTypes);
    }
}
#end_block

#method_before
// Android-removed: Not part of the Android implementation.
// abstract MethodType accessModeTypeUncached(AccessMode accessMode);
public final boolean isAccessModeSupported(AccessMode accessMode) {
    // Android-added: use AccessInfo.
    return accessInfo.isAccessModeSupported(accessMode);
}
#method_after
// Android-removed: Not part of the Android implementation.
// abstract MethodType accessModeTypeUncached(AccessMode accessMode);
public final boolean isAccessModeSupported(AccessMode accessMode) {
    // Android-removed: Refers to unused field vform.
    // return AccessMode.getMemberName(accessMode.ordinal(), vform) != null;
    // Android-added: use accessModesBitsMask field.
    final int testBit = 1 << accessMode.ordinal();
    return (accessModesBitMask & testBit) == testBit;
}
#end_block

#method_before
public final MethodHandle toMethodHandle(AccessMode accessMode) {
    // Android-added: plain implementation.
    return MethodHandles.varHandleInvoker(accessMode, accessModeType(accessMode)).bindTo(this);
}
#method_after
public final MethodHandle toMethodHandle(AccessMode accessMode) {
    // Android-added: basic implementation following description in javadoc for this method.
    return MethodHandles.varHandleInvoker(accessMode, accessModeType(accessMode)).bindTo(this);
}
#end_block

#method_before
public static void main(String[] args) {
    Main a = new Main();
    System.out.println("=== Fields ===");
    report(vz);
    report(vb);
    report(vc);
    report(vs);
    report(vi);
    report(vj);
    report(vd);
    report(vo);
    System.out.println("=== Final Fields ===");
    report(vfz);
    report(vfb);
    report(vfc);
    report(vfs);
    report(vfi);
    report(vfj);
    report(vfd);
    report(vfo);
    report(vfss);
    System.out.println("=== Static Fields ===");
    report(vsz);
    report(vsb);
    report(vsc);
    report(vss);
    report(vsi);
    report(vsj);
    report(vsf);
    report(vsd);
    report(vso);
    System.out.println("=== Array Element ===");
    report(vaz);
    report(vab);
    report(vac);
    report(vas);
    report(vai);
    report(vaj);
    report(vaf);
    report(vad);
    report(vao);
    System.out.println("=== Byte Array View ===");
    report(vbaz);
    report(vbab);
    report(vbac);
    report(vbas);
    report(vbai);
    report(vbaj);
    report(vbaf);
    report(vbad);
    report(vbao);
    System.out.println("=== Byte Buffer View ===");
    report(vbbz);
    report(vbbb);
    report(vbbc);
    report(vbbs);
    report(vbbi);
    report(vbbj);
    report(vbbf);
    report(vbbd);
    report(vbbo);
    // Checks on names, types, access
    LookupCheckA.run();
    LookupCheckB.run();
    LookupCheckC.run();
    UnreflectCheck.run();
}
#method_after
public static void main(String[] args) {
    checkAccessModes();
    checkInstantiatedVarHandles();
    LookupCheckA.run();
    LookupCheckB.run();
    LookupCheckC.run();
    UnreflectCheck.run();
}
#end_block

#method_before
private boolean updateCurrentController(int addrId, int browseId) {
    boolean registerRsp = true;
    updateNewIds(addrId, browseId);
    MediaController newController = null;
    MediaPlayerInfo info = getAddressedPlayerInfo();
    if (info != null)
        newController = info.getMediaController();
    if (DEBUG)
        Log.d(TAG, "updateCurrentController: " + mMediaController + " to " + newController);
    synchronized (this) {
        if (mMediaController == null || (!mMediaController.equals(newController))) {
            if (mMediaController != null) {
                mMediaController.unregisterCallback(mMediaControllerCb);
            }
            mMediaController = newController;
            if (mMediaController != null) {
                mMediaController.registerCallback(mMediaControllerCb, mHandler);
                mAddressedMediaPlayer.updateNowPlayingList(mMediaController);
            } else {
                mAddressedMediaPlayer.updateNowPlayingList(null);
                registerRsp = false;
            }
        }
    }
    updateCurrentMediaState();
    return registerRsp;
}
#method_after
private boolean updateCurrentController(int addrId, int browseId) {
    boolean registerRsp = true;
    updateNewIds(addrId, browseId);
    MediaController newController = null;
    MediaPlayerInfo info = getAddressedPlayerInfo();
    if (info != null)
        newController = info.getMediaController();
    if (DEBUG)
        Log.d(TAG, "updateCurrentController: " + mMediaController + " to " + newController);
    synchronized (this) {
        if (mMediaController == null || (!mMediaController.equals(newController))) {
            if (mMediaController != null) {
                mMediaController.unregisterCallback(mMediaControllerCb);
            }
            mMediaController = newController;
            if (mMediaController != null) {
                mMediaController.registerCallback(mMediaControllerCb, mHandler);
            } else {
                registerRsp = false;
            }
        }
    }
    updateCurrentMediaState();
    return registerRsp;
}
#end_block

#method_before
@Before
public void setUp() {
    resetLatch();
    mLocalSocket = null;
    mLocalSockName = null;
    mLastRecvBuf = null;
    mExited = false;
    mReceiver = new BlockingSocketReader() {

        @Override
        protected FileDescriptor createSocket() {
            FileDescriptor s = null;
            try {
                s = Os.socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
                Os.bind(s, LOOPBACK6, 0);
                mLocalSockName = (InetSocketAddress) Os.getsockname(s);
                Os.setsockoptTimeval(s, SOL_SOCKET, SO_SNDTIMEO, TIMEO);
            } catch (ErrnoException | SocketException e) {
                closeSocket(s);
                fail();
                return null;
            }
            mLocalSocket = s;
            return s;
        }

        @Override
        protected void handlePacket(byte[] recvbuf, int length) {
            mLastRecvBuf = Arrays.copyOf(recvbuf, length);
            mLatch.countDown();
        }

        @Override
        protected void onExit() {
            mExited = true;
            mLatch.countDown();
        }
    };
}
#method_after
@Before
public void setUp() {
    resetLatch();
    mLocalSocket = null;
    mLocalSockName = null;
    mLastRecvBuf = null;
    mStopped = false;
    mHandlerThread = new HandlerThread(BlockingSocketReaderTest.class.getSimpleName());
    mHandlerThread.start();
}
#end_block

#method_before
@After
public void tearDown() {
    if (mReceiver != null)
        mReceiver.stop();
    mReceiver = null;
}
#method_after
@After
public void tearDown() throws Exception {
    if (mReceiver != null) {
        mHandlerThread.getThreadHandler().post(() -> {
            mReceiver.stop();
        });
        waitForActivity();
    }
    mReceiver = null;
    mHandlerThread.quit();
    mHandlerThread = null;
}
#end_block

#method_before
void waitForActivity() throws Exception {
    assertTrue(mLatch.await(500, TimeUnit.MILLISECONDS));
    resetLatch();
}
#method_after
void waitForActivity() throws Exception {
    try {
        mLatch.await(1000, TimeUnit.MILLISECONDS);
    } finally {
        resetLatch();
    }
}
#end_block

#method_before
@Test
public void testBasicWorking() throws Exception {
    assertTrue(mReceiver.start());
    assertTrue(mLocalSockName != null);
    assertEquals(LOOPBACK6, mLocalSockName.getAddress());
    assertTrue(0 < mLocalSockName.getPort());
    assertTrue(mLocalSocket != null);
    assertFalse(mExited);
    final byte[] one = "one 1".getBytes("UTF-8");
    sendPacket(one);
    waitForActivity();
    assertEquals(1, mReceiver.numPacketsReceived());
    assertTrue(Arrays.equals(one, mLastRecvBuf));
    assertFalse(mExited);
    final byte[] two = "two 2".getBytes("UTF-8");
    sendPacket(two);
    waitForActivity();
    assertEquals(2, mReceiver.numPacketsReceived());
    assertTrue(Arrays.equals(two, mLastRecvBuf));
    assertFalse(mExited);
    mReceiver.stop();
    waitForActivity();
    assertEquals(2, mReceiver.numPacketsReceived());
    assertTrue(Arrays.equals(two, mLastRecvBuf));
    assertTrue(mExited);
}
#method_after
@Test
public void testBasicWorking() throws Exception {
    final Handler h = mHandlerThread.getThreadHandler();
    mReceiver = new UdpLoopbackReader(h);
    h.post(() -> {
        mReceiver.start();
    });
    waitForActivity();
    assertTrue(mLocalSockName != null);
    assertEquals(LOOPBACK6, mLocalSockName.getAddress());
    assertTrue(0 < mLocalSockName.getPort());
    assertTrue(mLocalSocket != null);
    assertFalse(mStopped);
    final byte[] one = "one 1".getBytes("UTF-8");
    sendPacket(one);
    waitForActivity();
    assertEquals(1, mReceiver.numPacketsReceived());
    assertTrue(Arrays.equals(one, mLastRecvBuf));
    assertFalse(mStopped);
    final byte[] two = "two 2".getBytes("UTF-8");
    sendPacket(two);
    waitForActivity();
    assertEquals(2, mReceiver.numPacketsReceived());
    assertTrue(Arrays.equals(two, mLastRecvBuf));
    assertFalse(mStopped);
    mReceiver.stop();
    waitForActivity();
    assertEquals(2, mReceiver.numPacketsReceived());
    assertTrue(Arrays.equals(two, mLastRecvBuf));
    assertTrue(mStopped);
    mReceiver = null;
}
#end_block

#method_before
private void socketWrite(byte[] b, int off, int len) throws IOException {
    if (len <= 0 || off < 0 || len > b.length - off) {
        if (len == 0) {
            return;
        }
        throw new ArrayIndexOutOfBoundsException("len == " + len + " off == " + off + " buffer length == " + b.length);
    }
    FileDescriptor fd = impl.acquireFD();
    try {
        // Android-changed: Check BlockGuard policy in socketWrite.
        BlockGuard.getThreadPolicy().onNetwork();
        socketWrite0(fd, b, off, len);
    } catch (SocketException se) {
        if (se instanceof sun.net.ConnectionResetException) {
            impl.setConnectionResetPending();
            se = new SocketException("Connection reset");
        }
        if (impl.isClosedOrPending()) {
            throw new SocketException("Socket closed");
        } else {
            throw se;
        }
    } finally {
        impl.releaseFD();
    }
}
#method_after
private void socketWrite(byte[] b, int off, int len) throws IOException {
    if (len <= 0 || off < 0 || len > b.length - off) {
        if (len == 0) {
            return;
        }
        throw new ArrayIndexOutOfBoundsException("len == " + len + " off == " + off + " buffer length == " + b.length);
    }
    FileDescriptor fd = impl.acquireFD();
    try {
        // Android-added: Check BlockGuard policy in socketWrite.
        BlockGuard.getThreadPolicy().onNetwork();
        socketWrite0(fd, b, off, len);
    } catch (SocketException se) {
        if (se instanceof sun.net.ConnectionResetException) {
            impl.setConnectionResetPending();
            se = new SocketException("Connection reset");
        }
        if (impl.isClosedOrPending()) {
            throw new SocketException("Socket closed");
        } else {
            throw se;
        }
    } finally {
        impl.releaseFD();
    }
}
#end_block

#method_before
int read(byte[] b, int off, int length, int timeout) throws IOException {
    int n;
    // EOF already encountered
    if (eof) {
        return -1;
    }
    // connection reset
    if (impl.isConnectionReset()) {
        throw new SocketException("Connection reset");
    }
    // bounds check
    if (length <= 0 || off < 0 || length > b.length - off) {
        if (length == 0) {
            return 0;
        }
        throw new ArrayIndexOutOfBoundsException("length == " + length + " off == " + off + " buffer length == " + b.length);
    }
    boolean gotReset = false;
    // acquire file descriptor and do the read
    FileDescriptor fd = impl.acquireFD();
    try {
        // Android-changed: Check BlockGuard policy in read().
        BlockGuard.getThreadPolicy().onNetwork();
        n = socketRead(fd, b, off, length, timeout);
        if (n > 0) {
            return n;
        }
    } catch (ConnectionResetException rstExc) {
        gotReset = true;
    } finally {
        impl.releaseFD();
    }
    /*
         * We receive a "connection reset" but there may be bytes still
         * buffered on the socket
         */
    if (gotReset) {
        impl.setConnectionResetPending();
        impl.acquireFD();
        try {
            n = socketRead(fd, b, off, length, timeout);
            if (n > 0) {
                return n;
            }
        } catch (ConnectionResetException rstExc) {
        } finally {
            impl.releaseFD();
        }
    }
    /*
         * If we get here we are at EOF, the socket has been closed,
         * or the connection has been reset.
         */
    if (impl.isClosedOrPending()) {
        throw new SocketException("Socket closed");
    }
    if (impl.isConnectionResetPending()) {
        impl.setConnectionReset();
    }
    if (impl.isConnectionReset()) {
        throw new SocketException("Connection reset");
    }
    eof = true;
    return -1;
}
#method_after
int read(byte[] b, int off, int length, int timeout) throws IOException {
    int n;
    // EOF already encountered
    if (eof) {
        return -1;
    }
    // connection reset
    if (impl.isConnectionReset()) {
        throw new SocketException("Connection reset");
    }
    // bounds check
    if (length <= 0 || off < 0 || length > b.length - off) {
        if (length == 0) {
            return 0;
        }
        throw new ArrayIndexOutOfBoundsException("length == " + length + " off == " + off + " buffer length == " + b.length);
    }
    boolean gotReset = false;
    // acquire file descriptor and do the read
    FileDescriptor fd = impl.acquireFD();
    try {
        // Android-added: Check BlockGuard policy in read().
        BlockGuard.getThreadPolicy().onNetwork();
        n = socketRead(fd, b, off, length, timeout);
        if (n > 0) {
            return n;
        }
    } catch (ConnectionResetException rstExc) {
        gotReset = true;
    } finally {
        impl.releaseFD();
    }
    /*
         * We receive a "connection reset" but there may be bytes still
         * buffered on the socket
         */
    if (gotReset) {
        impl.setConnectionResetPending();
        impl.acquireFD();
        try {
            n = socketRead(fd, b, off, length, timeout);
            if (n > 0) {
                return n;
            }
        } catch (ConnectionResetException rstExc) {
        } finally {
            impl.releaseFD();
        }
    }
    /*
         * If we get here we are at EOF, the socket has been closed,
         * or the connection has been reset.
         */
    if (impl.isClosedOrPending()) {
        throw new SocketException("Socket closed");
    }
    if (impl.isConnectionResetPending()) {
        impl.setConnectionReset();
    }
    if (impl.isConnectionReset()) {
        throw new SocketException("Connection reset");
    }
    eof = true;
    return -1;
}
#end_block

#method_before
@Override
protected void connect(SocketAddress endpoint, int timeout) throws IOException {
    final long deadlineMillis;
    if (timeout == 0) {
        deadlineMillis = 0L;
    } else {
        long finish = System.currentTimeMillis() + timeout;
        deadlineMillis = finish < 0 ? Long.MAX_VALUE : finish;
    }
    SecurityManager security = System.getSecurityManager();
    if (endpoint == null || !(endpoint instanceof InetSocketAddress))
        throw new IllegalArgumentException("Unsupported address type");
    InetSocketAddress epoint = (InetSocketAddress) endpoint;
    if (security != null) {
        if (epoint.isUnresolved())
            security.checkConnect(epoint.getHostName(), epoint.getPort());
        else
            security.checkConnect(epoint.getAddress().getHostAddress(), epoint.getPort());
    }
    if (server == null) {
        // Android-removed: Logic to establish proxy connection based on default ProxySelector
        /*
             * Removed code that tried to establish proxy connection if
             * ProxySelector#getDefault() is not null.
             * This was never the case in previous android releases, was causing
             * issues and therefore was removed.
             */
        /*
            // This is the general case
            // server is not null only when the socket was created with a
            // specified proxy in which case it does bypass the ProxySelector
            ProxySelector sel = java.security.AccessController.doPrivileged(
                new java.security.PrivilegedAction<ProxySelector>() {
                    public ProxySelector run() {
                            return ProxySelector.getDefault();
                        }
                    });
            if (sel == null) {
                /*
                 * No default proxySelector --> direct connection
                 *
                super.connect(epoint, remainingMillis(deadlineMillis));
                return;
            }
            URI uri;
            // Use getHostString() to avoid reverse lookups
            String host = epoint.getHostString();
            // IPv6 litteral?
            if (epoint.getAddress() instanceof Inet6Address &&
                (!host.startsWith("[")) && (host.indexOf(":") >= 0)) {
                host = "[" + host + "]";
            }
            try {
                uri = new URI("socket://" + ParseUtil.encodePath(host) + ":"+ epoint.getPort());
            } catch (URISyntaxException e) {
                // This shouldn't happen
                assert false : e;
                uri = null;
            }
            Proxy p = null;
            IOException savedExc = null;
            java.util.Iterator<Proxy> iProxy = null;
            iProxy = sel.select(uri).iterator();
            if (iProxy == null || !(iProxy.hasNext())) {
                super.connect(epoint, remainingMillis(deadlineMillis));
                return;
            }
            while (iProxy.hasNext()) {
                p = iProxy.next();
                if (p == null || p.type() != Proxy.Type.SOCKS) {
                    super.connect(epoint, remainingMillis(deadlineMillis));
                    return;
                }

                if (!(p.address() instanceof InetSocketAddress))
                    throw new SocketException("Unknown address type for proxy: " + p);
                // Use getHostString() to avoid reverse lookups
                server = ((InetSocketAddress) p.address()).getHostString();
                serverPort = ((InetSocketAddress) p.address()).getPort();
                if (p instanceof SocksProxy) {
                    if (((SocksProxy)p).protocolVersion() == 4) {
                        useV4 = true;
                    }
                }

                // Connects to the SOCKS server
                try {
                    privilegedConnect(server, serverPort, remainingMillis(deadlineMillis));
                    // Worked, let's get outta here
                    break;
                } catch (IOException e) {
                    // Ooops, let's notify the ProxySelector
                    sel.connectFailed(uri,p.address(),e);
                    server = null;
                    serverPort = -1;
                    savedExc = e;
                    // Will continue the while loop and try the next proxy
                }
            }

            /*
             * If server is still null at this point, none of the proxy
             * worked
             *
            if (server == null) {
                throw new SocketException("Can't connect to SOCKS proxy:"
                                          + savedExc.getMessage());
            }
             */
        super.connect(epoint, remainingMillis(deadlineMillis));
        return;
    } else {
        // Connects to the SOCKS server
        try {
            privilegedConnect(server, serverPort, remainingMillis(deadlineMillis));
        } catch (IOException e) {
            throw new SocketException(e.getMessage());
        }
    }
    // cmdIn & cmdOut were initialized during the privilegedConnect() call
    BufferedOutputStream out = new BufferedOutputStream(cmdOut, 512);
    InputStream in = cmdIn;
    if (useV4) {
        // DOMAIN type of addresses (unresolved addresses here)
        if (epoint.isUnresolved())
            throw new UnknownHostException(epoint.toString());
        connectV4(in, out, epoint, deadlineMillis);
        return;
    }
    // This is SOCKS V5
    out.write(PROTO_VERS);
    out.write(2);
    out.write(NO_AUTH);
    out.write(USER_PASSW);
    out.flush();
    byte[] data = new byte[2];
    int i = readSocksReply(in, data, deadlineMillis);
    if (i != 2 || ((int) data[0]) != PROTO_VERS) {
        // DOMAIN type of addresses (unresolved addresses here)
        if (epoint.isUnresolved())
            throw new UnknownHostException(epoint.toString());
        connectV4(in, out, epoint, deadlineMillis);
        return;
    }
    if (((int) data[1]) == NO_METHODS)
        throw new SocketException("SOCKS : No acceptable methods");
    if (!authenticate(data[1], in, out, deadlineMillis)) {
        throw new SocketException("SOCKS : authentication failed");
    }
    out.write(PROTO_VERS);
    out.write(CONNECT);
    out.write(0);
    /* Test for IPV4/IPV6/Unresolved */
    if (epoint.isUnresolved()) {
        out.write(DOMAIN_NAME);
        out.write(epoint.getHostName().length());
        try {
            out.write(epoint.getHostName().getBytes("ISO-8859-1"));
        } catch (java.io.UnsupportedEncodingException uee) {
            assert false;
        }
        out.write((epoint.getPort() >> 8) & 0xff);
        out.write((epoint.getPort() >> 0) & 0xff);
    } else if (epoint.getAddress() instanceof Inet6Address) {
        out.write(IPV6);
        out.write(epoint.getAddress().getAddress());
        out.write((epoint.getPort() >> 8) & 0xff);
        out.write((epoint.getPort() >> 0) & 0xff);
    } else {
        out.write(IPV4);
        out.write(epoint.getAddress().getAddress());
        out.write((epoint.getPort() >> 8) & 0xff);
        out.write((epoint.getPort() >> 0) & 0xff);
    }
    out.flush();
    data = new byte[4];
    i = readSocksReply(in, data, deadlineMillis);
    if (i != 4)
        throw new SocketException("Reply from SOCKS server has bad length");
    SocketException ex = null;
    int len;
    byte[] addr;
    switch(data[1]) {
        case REQUEST_OK:
            // success!
            switch(data[3]) {
                case IPV4:
                    addr = new byte[4];
                    i = readSocksReply(in, addr, deadlineMillis);
                    if (i != 4)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    data = new byte[2];
                    i = readSocksReply(in, data, deadlineMillis);
                    if (i != 2)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    break;
                case DOMAIN_NAME:
                    len = data[1];
                    byte[] host = new byte[len];
                    i = readSocksReply(in, host, deadlineMillis);
                    if (i != len)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    data = new byte[2];
                    i = readSocksReply(in, data, deadlineMillis);
                    if (i != 2)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    break;
                case IPV6:
                    len = data[1];
                    addr = new byte[len];
                    i = readSocksReply(in, addr, deadlineMillis);
                    if (i != len)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    data = new byte[2];
                    i = readSocksReply(in, data, deadlineMillis);
                    if (i != 2)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    break;
                default:
                    ex = new SocketException("Reply from SOCKS server contains wrong code");
                    break;
            }
            break;
        case GENERAL_FAILURE:
            ex = new SocketException("SOCKS server general failure");
            break;
        case NOT_ALLOWED:
            ex = new SocketException("SOCKS: Connection not allowed by ruleset");
            break;
        case NET_UNREACHABLE:
            ex = new SocketException("SOCKS: Network unreachable");
            break;
        case HOST_UNREACHABLE:
            ex = new SocketException("SOCKS: Host unreachable");
            break;
        case CONN_REFUSED:
            ex = new SocketException("SOCKS: Connection refused");
            break;
        case TTL_EXPIRED:
            ex = new SocketException("SOCKS: TTL expired");
            break;
        case CMD_NOT_SUPPORTED:
            ex = new SocketException("SOCKS: Command not supported");
            break;
        case ADDR_TYPE_NOT_SUP:
            ex = new SocketException("SOCKS: address type not supported");
            break;
    }
    if (ex != null) {
        in.close();
        out.close();
        throw ex;
    }
    external_address = epoint;
}
#method_after
@Override
protected void connect(SocketAddress endpoint, int timeout) throws IOException {
    final long deadlineMillis;
    if (timeout == 0) {
        deadlineMillis = 0L;
    } else {
        long finish = System.currentTimeMillis() + timeout;
        deadlineMillis = finish < 0 ? Long.MAX_VALUE : finish;
    }
    SecurityManager security = System.getSecurityManager();
    if (endpoint == null || !(endpoint instanceof InetSocketAddress))
        throw new IllegalArgumentException("Unsupported address type");
    InetSocketAddress epoint = (InetSocketAddress) endpoint;
    if (security != null) {
        if (epoint.isUnresolved())
            security.checkConnect(epoint.getHostName(), epoint.getPort());
        else
            security.checkConnect(epoint.getAddress().getHostAddress(), epoint.getPort());
    }
    if (server == null) {
        // Android-removed: Logic to establish proxy connection based on default ProxySelector.
        // Removed code that tried to establish proxy connection if ProxySelector#getDefault()
        // is not null. This was never the case in previous Android releases, was causing
        // issues and therefore was removed.
        /*
            // This is the general case
            // server is not null only when the socket was created with a
            // specified proxy in which case it does bypass the ProxySelector
            ProxySelector sel = java.security.AccessController.doPrivileged(
                new java.security.PrivilegedAction<ProxySelector>() {
                    public ProxySelector run() {
                            return ProxySelector.getDefault();
                        }
                    });
            if (sel == null) {
                /*
                 * No default proxySelector --> direct connection
                 *
                super.connect(epoint, remainingMillis(deadlineMillis));
                return;
            }
            URI uri;
            // Use getHostString() to avoid reverse lookups
            String host = epoint.getHostString();
            // IPv6 litteral?
            if (epoint.getAddress() instanceof Inet6Address &&
                (!host.startsWith("[")) && (host.indexOf(":") >= 0)) {
                host = "[" + host + "]";
            }
            try {
                uri = new URI("socket://" + ParseUtil.encodePath(host) + ":"+ epoint.getPort());
            } catch (URISyntaxException e) {
                // This shouldn't happen
                assert false : e;
                uri = null;
            }
            Proxy p = null;
            IOException savedExc = null;
            java.util.Iterator<Proxy> iProxy = null;
            iProxy = sel.select(uri).iterator();
            if (iProxy == null || !(iProxy.hasNext())) {
                super.connect(epoint, remainingMillis(deadlineMillis));
                return;
            }
            while (iProxy.hasNext()) {
                p = iProxy.next();
                if (p == null || p.type() != Proxy.Type.SOCKS) {
                    super.connect(epoint, remainingMillis(deadlineMillis));
                    return;
                }

                if (!(p.address() instanceof InetSocketAddress))
                    throw new SocketException("Unknown address type for proxy: " + p);
                // Use getHostString() to avoid reverse lookups
                server = ((InetSocketAddress) p.address()).getHostString();
                serverPort = ((InetSocketAddress) p.address()).getPort();
                if (p instanceof SocksProxy) {
                    if (((SocksProxy)p).protocolVersion() == 4) {
                        useV4 = true;
                    }
                }

                // Connects to the SOCKS server
                try {
                    privilegedConnect(server, serverPort, remainingMillis(deadlineMillis));
                    // Worked, let's get outta here
                    break;
                } catch (IOException e) {
                    // Ooops, let's notify the ProxySelector
                    sel.connectFailed(uri,p.address(),e);
                    server = null;
                    serverPort = -1;
                    savedExc = e;
                    // Will continue the while loop and try the next proxy
                }
            }

            /*
             * If server is still null at this point, none of the proxy
             * worked
             *
            if (server == null) {
                throw new SocketException("Can't connect to SOCKS proxy:"
                                          + savedExc.getMessage());
            }
             */
        super.connect(epoint, remainingMillis(deadlineMillis));
        return;
    } else {
        // Connects to the SOCKS server
        try {
            privilegedConnect(server, serverPort, remainingMillis(deadlineMillis));
        } catch (IOException e) {
            throw new SocketException(e.getMessage());
        }
    }
    // cmdIn & cmdOut were initialized during the privilegedConnect() call
    BufferedOutputStream out = new BufferedOutputStream(cmdOut, 512);
    InputStream in = cmdIn;
    if (useV4) {
        // DOMAIN type of addresses (unresolved addresses here)
        if (epoint.isUnresolved())
            throw new UnknownHostException(epoint.toString());
        connectV4(in, out, epoint, deadlineMillis);
        return;
    }
    // This is SOCKS V5
    out.write(PROTO_VERS);
    out.write(2);
    out.write(NO_AUTH);
    out.write(USER_PASSW);
    out.flush();
    byte[] data = new byte[2];
    int i = readSocksReply(in, data, deadlineMillis);
    if (i != 2 || ((int) data[0]) != PROTO_VERS) {
        // DOMAIN type of addresses (unresolved addresses here)
        if (epoint.isUnresolved())
            throw new UnknownHostException(epoint.toString());
        connectV4(in, out, epoint, deadlineMillis);
        return;
    }
    if (((int) data[1]) == NO_METHODS)
        throw new SocketException("SOCKS : No acceptable methods");
    if (!authenticate(data[1], in, out, deadlineMillis)) {
        throw new SocketException("SOCKS : authentication failed");
    }
    out.write(PROTO_VERS);
    out.write(CONNECT);
    out.write(0);
    /* Test for IPV4/IPV6/Unresolved */
    if (epoint.isUnresolved()) {
        out.write(DOMAIN_NAME);
        out.write(epoint.getHostName().length());
        try {
            out.write(epoint.getHostName().getBytes("ISO-8859-1"));
        } catch (java.io.UnsupportedEncodingException uee) {
            assert false;
        }
        out.write((epoint.getPort() >> 8) & 0xff);
        out.write((epoint.getPort() >> 0) & 0xff);
    } else if (epoint.getAddress() instanceof Inet6Address) {
        out.write(IPV6);
        out.write(epoint.getAddress().getAddress());
        out.write((epoint.getPort() >> 8) & 0xff);
        out.write((epoint.getPort() >> 0) & 0xff);
    } else {
        out.write(IPV4);
        out.write(epoint.getAddress().getAddress());
        out.write((epoint.getPort() >> 8) & 0xff);
        out.write((epoint.getPort() >> 0) & 0xff);
    }
    out.flush();
    data = new byte[4];
    i = readSocksReply(in, data, deadlineMillis);
    if (i != 4)
        throw new SocketException("Reply from SOCKS server has bad length");
    SocketException ex = null;
    int len;
    byte[] addr;
    switch(data[1]) {
        case REQUEST_OK:
            // success!
            switch(data[3]) {
                case IPV4:
                    addr = new byte[4];
                    i = readSocksReply(in, addr, deadlineMillis);
                    if (i != 4)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    data = new byte[2];
                    i = readSocksReply(in, data, deadlineMillis);
                    if (i != 2)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    break;
                case DOMAIN_NAME:
                    len = data[1];
                    byte[] host = new byte[len];
                    i = readSocksReply(in, host, deadlineMillis);
                    if (i != len)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    data = new byte[2];
                    i = readSocksReply(in, data, deadlineMillis);
                    if (i != 2)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    break;
                case IPV6:
                    len = data[1];
                    addr = new byte[len];
                    i = readSocksReply(in, addr, deadlineMillis);
                    if (i != len)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    data = new byte[2];
                    i = readSocksReply(in, data, deadlineMillis);
                    if (i != 2)
                        throw new SocketException("Reply from SOCKS server badly formatted");
                    break;
                default:
                    ex = new SocketException("Reply from SOCKS server contains wrong code");
                    break;
            }
            break;
        case GENERAL_FAILURE:
            ex = new SocketException("SOCKS server general failure");
            break;
        case NOT_ALLOWED:
            ex = new SocketException("SOCKS: Connection not allowed by ruleset");
            break;
        case NET_UNREACHABLE:
            ex = new SocketException("SOCKS: Network unreachable");
            break;
        case HOST_UNREACHABLE:
            ex = new SocketException("SOCKS: Host unreachable");
            break;
        case CONN_REFUSED:
            ex = new SocketException("SOCKS: Connection refused");
            break;
        case TTL_EXPIRED:
            ex = new SocketException("SOCKS: TTL expired");
            break;
        case CMD_NOT_SUPPORTED:
            ex = new SocketException("SOCKS: Command not supported");
            break;
        case ADDR_TYPE_NOT_SUP:
            ex = new SocketException("SOCKS: address type not supported");
            break;
    }
    if (ex != null) {
        in.close();
        out.close();
        throw ex;
    }
    external_address = epoint;
}
#end_block

#method_before
@Override
public String toString() {
    return new StringJoiner(", ", getClass().getSimpleName() + "{", "}").add("mEnableIPv4: " + mEnableIPv4).add("mEnableIPv6: " + mEnableIPv6).add("mUsingIpReachabilityMonitor: " + mUsingIpReachabilityMonitor).add("mRequestedPreDhcpActionMs: " + mRequestedPreDhcpActionMs).add("mInitialConfig: " + mInitialConfig).add("mStaticIpConfig: " + mStaticIpConfig).add("mApfCapabilities: " + mApfCapabilities).add("mProvisioningTimeoutMs: " + mProvisioningTimeoutMs).add("mIPv6AddrGenMode: " + mIPv6AddrGenMode).toString();
}
#method_after
@Override
public String toString() {
    return new StringJoiner(", ", getClass().getSimpleName() + "{", "}").add("mEnableIPv4: " + mEnableIPv4).add("mEnableIPv6: " + mEnableIPv6).add("mUsingIpReachabilityMonitor: " + mUsingIpReachabilityMonitor).add("mRequestedPreDhcpActionMs: " + mRequestedPreDhcpActionMs).add("mInitialConfig: " + mInitialConfig).add("mStaticIpConfig: " + mStaticIpConfig).add("mApfCapabilities: " + mApfCapabilities).add("mProvisioningTimeoutMs: " + mProvisioningTimeoutMs).add("mIPv6AddrGenMode: " + mIPv6AddrGenMode).add("mNetwork: " + mNetwork).add("mDisplayName: " + mDisplayName).toString();
}
#end_block

#method_before
@Override
public void enter() {
    // Get the Configuration for ApfFilter from Context
    final boolean filter802_3Frames = mContext.getResources().getBoolean(R.bool.config_apfDrop802_3Frames);
    final int[] ethTypeBlackList = mContext.getResources().getIntArray(R.array.config_apfEthTypeBlackList);
    mApfFilter = ApfFilter.maybeCreate(mConfiguration.mApfCapabilities, mNetworkInterface, mCallback, mMulticastFiltering, filter802_3Frames, ethTypeBlackList);
    // rest of this IP configuration startup.
    if (mApfFilter == null) {
        mCallback.setFallbackMulticastFilter(mMulticastFiltering);
    }
    mPacketTracker = createPacketTracker();
    if (mPacketTracker != null)
        mPacketTracker.start(mConfiguration.mDisplayName);
    mNetwork = null;
    if (mConfiguration.mEnableIPv6 && !startIPv6()) {
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_STARTING_IPV6);
        transitionTo(mStoppingState);
        return;
    }
    if (mConfiguration.mEnableIPv4 && !startIPv4()) {
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_STARTING_IPV4);
        transitionTo(mStoppingState);
        return;
    }
    final InitialConfiguration config = mConfiguration.mInitialConfig;
    if ((config != null) && !applyInitialConfig(config)) {
        // TODO introduce a new IpManagerEvent constant to distinguish this error case.
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_INVALID_PROVISIONING);
        transitionTo(mStoppingState);
        return;
    }
    if (mConfiguration.mUsingIpReachabilityMonitor && !startIpReachabilityMonitor()) {
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_STARTING_IPREACHABILITYMONITOR);
        transitionTo(mStoppingState);
        return;
    }
}
#method_after
@Override
public void enter() {
    // Get the Configuration for ApfFilter from Context
    final boolean filter802_3Frames = mContext.getResources().getBoolean(R.bool.config_apfDrop802_3Frames);
    final int[] ethTypeBlackList = mContext.getResources().getIntArray(R.array.config_apfEthTypeBlackList);
    mApfFilter = ApfFilter.maybeCreate(mConfiguration.mApfCapabilities, mNetworkInterface, mCallback, mMulticastFiltering, filter802_3Frames, ethTypeBlackList);
    // rest of this IP configuration startup.
    if (mApfFilter == null) {
        mCallback.setFallbackMulticastFilter(mMulticastFiltering);
    }
    mPacketTracker = createPacketTracker();
    if (mPacketTracker != null)
        mPacketTracker.start(mConfiguration.mDisplayName);
    if (mConfiguration.mEnableIPv6 && !startIPv6()) {
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_STARTING_IPV6);
        transitionTo(mStoppingState);
        return;
    }
    if (mConfiguration.mEnableIPv4 && !startIPv4()) {
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_STARTING_IPV4);
        transitionTo(mStoppingState);
        return;
    }
    final InitialConfiguration config = mConfiguration.mInitialConfig;
    if ((config != null) && !applyInitialConfig(config)) {
        // TODO introduce a new IpManagerEvent constant to distinguish this error case.
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_INVALID_PROVISIONING);
        transitionTo(mStoppingState);
        return;
    }
    if (mConfiguration.mUsingIpReachabilityMonitor && !startIpReachabilityMonitor()) {
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_STARTING_IPREACHABILITYMONITOR);
        transitionTo(mStoppingState);
        return;
    }
}
#end_block

#method_before
@Override
public void exit() {
    stopDhcpAction();
    if (mIpReachabilityMonitor != null) {
        mIpReachabilityMonitor.stop();
        mIpReachabilityMonitor = null;
    }
    if (mDhcpClient != null) {
        mDhcpClient.sendMessage(DhcpClient.CMD_STOP_DHCP);
        mDhcpClient.doQuit();
    }
    mNetwork = null;
    if (mPacketTracker != null) {
        mPacketTracker.stop();
        mPacketTracker = null;
    }
    if (mApfFilter != null) {
        mApfFilter.shutdown();
        mApfFilter = null;
    }
    resetLinkProperties();
}
#method_after
@Override
public void exit() {
    stopDhcpAction();
    if (mIpReachabilityMonitor != null) {
        mIpReachabilityMonitor.stop();
        mIpReachabilityMonitor = null;
    }
    if (mDhcpClient != null) {
        mDhcpClient.sendMessage(DhcpClient.CMD_STOP_DHCP);
        mDhcpClient.doQuit();
    }
    if (mPacketTracker != null) {
        mPacketTracker.stop();
        mPacketTracker = null;
    }
    if (mApfFilter != null) {
        mApfFilter.shutdown();
        mApfFilter = null;
    }
    resetLinkProperties();
}
#end_block

#method_before
@Override
public boolean processMessage(Message msg) {
    switch(msg.what) {
        case CMD_STOP:
            transitionTo(mStoppingState);
            break;
        case CMD_START:
            logError("ALERT: START received in StartedState. Please fix caller.");
            break;
        case CMD_CONFIRM:
            // roams.
            if (mIpReachabilityMonitor != null) {
                mIpReachabilityMonitor.probeAll();
            }
            break;
        case EVENT_PRE_DHCP_ACTION_COMPLETE:
            // a static IP configuration.
            if (mDhcpClient != null) {
                mDhcpClient.sendMessage(DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE);
            }
            break;
        case EVENT_NETLINK_LINKPROPERTIES_CHANGED:
            if (!handleLinkPropertiesUpdate(SEND_CALLBACKS)) {
                transitionTo(mStoppingState);
            }
            break;
        case CMD_UPDATE_TCP_BUFFER_SIZES:
            mTcpBufferSizes = (String) msg.obj;
            // This cannot possibly change provisioning state.
            handleLinkPropertiesUpdate(SEND_CALLBACKS);
            break;
        case CMD_UPDATE_HTTP_PROXY:
            mHttpProxy = (ProxyInfo) msg.obj;
            // This cannot possibly change provisioning state.
            handleLinkPropertiesUpdate(SEND_CALLBACKS);
            break;
        case CMD_SET_MULTICAST_FILTER:
            {
                mMulticastFiltering = (boolean) msg.obj;
                if (mApfFilter != null) {
                    mApfFilter.setMulticastFilter(mMulticastFiltering);
                } else {
                    mCallback.setFallbackMulticastFilter(mMulticastFiltering);
                }
                break;
            }
        case CMD_SET_NETWORK:
            {
                final Network network = new Network((int) msg.obj);
                if (mNetwork != null && mNetwork != network) {
                    mLog.e("Changing networks while running is BAD (tm)");
                }
                mNetwork = network;
                break;
            }
        case EVENT_DHCPACTION_TIMEOUT:
            stopDhcpAction();
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            if (mConfiguration.mRequestedPreDhcpActionMs > 0) {
                ensureDhcpAction();
            } else {
                sendMessage(EVENT_PRE_DHCP_ACTION_COMPLETE);
            }
            break;
        case DhcpClient.CMD_CLEAR_LINKADDRESS:
            mInterfaceCtrl.clearIPv4Address();
            break;
        case DhcpClient.CMD_CONFIGURE_LINKADDRESS:
            {
                final LinkAddress ipAddress = (LinkAddress) msg.obj;
                if (mInterfaceCtrl.setIPv4Address(ipAddress)) {
                    mDhcpClient.sendMessage(DhcpClient.EVENT_LINKADDRESS_CONFIGURED);
                } else {
                    logError("Failed to set IPv4 address.");
                    dispatchCallback(ProvisioningChange.LOST_PROVISIONING, new LinkProperties(mLinkProperties));
                    transitionTo(mStoppingState);
                }
                break;
            }
        // condition is now governed by the provisioning timeout.
        case DhcpClient.CMD_POST_DHCP_ACTION:
            stopDhcpAction();
            switch(msg.arg1) {
                case DhcpClient.DHCP_SUCCESS:
                    handleIPv4Success((DhcpResults) msg.obj);
                    break;
                case DhcpClient.DHCP_FAILURE:
                    handleIPv4Failure();
                    break;
                default:
                    logError("Unknown CMD_POST_DHCP_ACTION status: %s", msg.arg1);
            }
            break;
        case DhcpClient.CMD_ON_QUIT:
            // DHCPv4 quit early for some reason.
            logError("Unexpected CMD_ON_QUIT.");
            mDhcpClient = null;
            break;
        default:
            return NOT_HANDLED;
    }
    mMsgStateLogger.handled(this, getCurrentState());
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message msg) {
    switch(msg.what) {
        case CMD_STOP:
            transitionTo(mStoppingState);
            break;
        case CMD_START:
            logError("ALERT: START received in StartedState. Please fix caller.");
            break;
        case CMD_CONFIRM:
            // roams.
            if (mIpReachabilityMonitor != null) {
                mIpReachabilityMonitor.probeAll();
            }
            break;
        case EVENT_PRE_DHCP_ACTION_COMPLETE:
            // a static IP configuration.
            if (mDhcpClient != null) {
                mDhcpClient.sendMessage(DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE);
            }
            break;
        case EVENT_NETLINK_LINKPROPERTIES_CHANGED:
            if (!handleLinkPropertiesUpdate(SEND_CALLBACKS)) {
                transitionTo(mStoppingState);
            }
            break;
        case CMD_UPDATE_TCP_BUFFER_SIZES:
            mTcpBufferSizes = (String) msg.obj;
            // This cannot possibly change provisioning state.
            handleLinkPropertiesUpdate(SEND_CALLBACKS);
            break;
        case CMD_UPDATE_HTTP_PROXY:
            mHttpProxy = (ProxyInfo) msg.obj;
            // This cannot possibly change provisioning state.
            handleLinkPropertiesUpdate(SEND_CALLBACKS);
            break;
        case CMD_SET_MULTICAST_FILTER:
            {
                mMulticastFiltering = (boolean) msg.obj;
                if (mApfFilter != null) {
                    mApfFilter.setMulticastFilter(mMulticastFiltering);
                } else {
                    mCallback.setFallbackMulticastFilter(mMulticastFiltering);
                }
                break;
            }
        case EVENT_DHCPACTION_TIMEOUT:
            stopDhcpAction();
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            if (mConfiguration.mRequestedPreDhcpActionMs > 0) {
                ensureDhcpAction();
            } else {
                sendMessage(EVENT_PRE_DHCP_ACTION_COMPLETE);
            }
            break;
        case DhcpClient.CMD_CLEAR_LINKADDRESS:
            mInterfaceCtrl.clearIPv4Address();
            break;
        case DhcpClient.CMD_CONFIGURE_LINKADDRESS:
            {
                final LinkAddress ipAddress = (LinkAddress) msg.obj;
                if (mInterfaceCtrl.setIPv4Address(ipAddress)) {
                    mDhcpClient.sendMessage(DhcpClient.EVENT_LINKADDRESS_CONFIGURED);
                } else {
                    logError("Failed to set IPv4 address.");
                    dispatchCallback(ProvisioningChange.LOST_PROVISIONING, new LinkProperties(mLinkProperties));
                    transitionTo(mStoppingState);
                }
                break;
            }
        // condition is now governed by the provisioning timeout.
        case DhcpClient.CMD_POST_DHCP_ACTION:
            stopDhcpAction();
            switch(msg.arg1) {
                case DhcpClient.DHCP_SUCCESS:
                    handleIPv4Success((DhcpResults) msg.obj);
                    break;
                case DhcpClient.DHCP_FAILURE:
                    handleIPv4Failure();
                    break;
                default:
                    logError("Unknown CMD_POST_DHCP_ACTION status: %s", msg.arg1);
            }
            break;
        case DhcpClient.CMD_ON_QUIT:
            // DHCPv4 quit early for some reason.
            logError("Unexpected CMD_ON_QUIT.");
            mDhcpClient = null;
            break;
        default:
            return NOT_HANDLED;
    }
    mMsgStateLogger.handled(this, getCurrentState());
    return HANDLED;
}
#end_block

