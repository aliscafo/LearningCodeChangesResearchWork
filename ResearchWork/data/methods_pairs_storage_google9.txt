957
#method_before
private boolean loadCommitData() throws OrmException, RepositoryNotFoundException, IOException, MissingObjectException, IncorrectObjectTypeException {
    PatchSet.Id psId = change().currentPatchSetId();
    PatchSet ps = db.patchSets().get(psId);
    if (ps == null) {
        return false;
    }
    String sha1 = ps.getRevision().get();
    try (Repository repo = repoManager.openRepository(change().getProject());
        RevWalk walk = new RevWalk(repo)) {
        RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
        commitMessage = c.getFullMessage();
        commitFooters = c.getFooterLines();
    }
    return true;
}
#method_after
private boolean loadCommitData() throws OrmException, RepositoryNotFoundException, IOException, MissingObjectException, IncorrectObjectTypeException {
    PatchSet ps = currentPatchSet();
    if (ps == null) {
        return false;
    }
    String sha1 = ps.getRevision().get();
    try (Repository repo = repoManager.openRepository(change().getProject());
        RevWalk walk = new RevWalk(repo)) {
        RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
        commitMessage = c.getFullMessage();
        commitFooters = c.getFooterLines();
    }
    return true;
}
#end_block

#method_before
@SuppressWarnings("deprecation")
static Predicate<ChangeData> create(Schema<ChangeData> schema, Collection<Account.Id> ids) throws QueryParseException {
    if (schema == null || schema.hasField(ChangeField.LEGACY_REVIEWED)) {
        throw new QueryParseException("Only is:reviewed is supported");
    }
    checkSchema(schema);
    List<Predicate<ChangeData>> predicates = new ArrayList<>();
    for (Account.Id id : ids) {
        predicates.add(new IsReviewedPredicate(Integer.toString(id.get())));
    }
    return Predicate.or(predicates);
}
#method_after
@SuppressWarnings("deprecation")
static Predicate<ChangeData> create(Schema<ChangeData> schema, Collection<Account.Id> ids) throws QueryParseException {
    if (schema == null || schema.hasField(ChangeField.LEGACY_REVIEWED)) {
        throw new QueryParseException("Only is:reviewed is supported");
    }
    checkSchema(schema);
    List<Predicate<ChangeData>> predicates = new ArrayList<>(ids.size());
    for (Account.Id id : ids) {
        predicates.add(new IsReviewedPredicate(id));
    }
    return Predicate.or(predicates);
}
#end_block

#method_before
@Override
public boolean match(ChangeData cd) throws OrmException {
    Set<Account.Id> reviewedBy = cd.reviewedBy();
    return !reviewedBy.isEmpty() ? reviewedBy.contains(id) : id == null;
}
#method_after
@Override
public boolean match(ChangeData cd) throws OrmException {
    Set<Account.Id> reviewedBy = cd.reviewedBy();
    return !reviewedBy.isEmpty() ? reviewedBy.contains(id) : id == NOT_REVIEWED;
}
#end_block

#method_before
protected void assertBadQuery(QueryRequest query) throws Exception {
    try {
        query.get();
        fail("expected BadRequestException for query: " + query);
    } catch (BadRequestException e) {
    // Expected.
    }
}
#method_after
protected void assertBadQuery(QueryRequest query) throws Exception {
    exception.expect(BadRequestException.class);
    query.get();
}
#end_block

#method_before
private void assertNotOwner(String ref, ProjectControl u) {
    assertThat(u.controlForRef(ref).isOwner()).named("NOT OWN " + ref).isFalse();
}
#method_after
private void assertNotOwner(ProjectControl u) {
    assertThat(u.isOwner()).named("not owner").isFalse();
}
#end_block

#method_before
@Test
public void testBranchDelegation1() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    ProjectControl uDev = util.user(local, DEVS);
    assertThat(uDev.isOwner()).named("not owner").isFalse();
    assertThat(uDev.isOwnerAnyRef()).named("owns ref").isTrue();
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
}
#method_after
@Test
public void testBranchDelegation1() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    ProjectControl uDev = util.user(local, DEVS);
    assertNotOwner(uDev);
    assertOwnerAnyRef(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
}
#end_block

#method_before
@Test
public void testBranchDelegation2() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    allow(local, OWNER, fixers, "refs/heads/x/y/*");
    doNotInherit(local, OWNER, "refs/heads/x/y/*");
    ProjectControl uDev = util.user(local, DEVS);
    assertThat(uDev.isOwner()).named("not owner").isFalse();
    assertThat(uDev.isOwnerAnyRef()).named("owns ref").isTrue();
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
    ProjectControl uFix = util.user(local, fixers);
    assertThat(uFix.isOwner()).isFalse();
    assertThat(uFix.isOwnerAnyRef()).isTrue();
    assertOwner("refs/heads/x/y/*", uFix);
    assertOwner("refs/heads/x/y/bar", uFix);
    assertNotOwner("refs/heads/x/*", uFix);
    assertNotOwner("refs/heads/x/y", uFix);
    assertNotOwner("refs/*", uFix);
    assertNotOwner("refs/heads/master", uFix);
}
#method_after
@Test
public void testBranchDelegation2() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    allow(local, OWNER, fixers, "refs/heads/x/y/*");
    doNotInherit(local, OWNER, "refs/heads/x/y/*");
    ProjectControl uDev = util.user(local, DEVS);
    assertNotOwner(uDev);
    assertOwnerAnyRef(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
    ProjectControl uFix = util.user(local, fixers);
    assertNotOwner(uFix);
    assertOwnerAnyRef(uFix);
    assertOwner("refs/heads/x/y/*", uFix);
    assertOwner("refs/heads/x/y/bar", uFix);
    assertNotOwner("refs/heads/x/*", uFix);
    assertNotOwner("refs/heads/x/y", uFix);
    assertNotOwner("refs/*", uFix);
    assertNotOwner("refs/heads/master", uFix);
}
#end_block

#method_before
@Test
public void getVersion() throws Exception {
    String version = gApi.config().server().getVersion();
    Truth.assertThat(version).is(Version.getVersion());
}
#method_after
@Test
public void getVersion() throws Exception {
    assertThat(gApi.config().server().getVersion()).isEqualTo(Version.getVersion());
}
#end_block

#method_before
private List<ChangeData> getChangesByTopic(String topic) {
    try {
        List<ChangeData> ret = Lists.newArrayList();
        for (ChangeData c : queryProvider.get().byTopicOpen(topic)) {
            if (topic.equals(c.change().getTopic())) {
                ret.add(c);
            }
        }
        return ret;
    } catch (OrmException e) {
        throw new OrmRuntimeException(e);
    }
}
#method_after
private List<ChangeData> getChangesByTopic(String topic) {
    try {
        return queryProvider.get().byExactTopicOpen(topic);
    } catch (OrmException e) {
        throw new OrmRuntimeException(e);
    }
}
#end_block

#method_before
private Change insertPatchSet(ChangeEdit edit, Change change, Repository repo, RevWalk rw, PatchSet basePatchSet, RevCommit squashed) throws NoSuchChangeException, InvalidChangeOperationException, OrmException, IOException {
    PatchSet ps = new PatchSet(ChangeUtil.nextPatchSetId(change.currentPatchSetId()));
    ps.setRevision(new RevId(ObjectId.toString(squashed)));
    ps.setUploader(edit.getUser().getAccountId());
    ps.setCreatedOn(TimeUtil.nowTs());
    RevCommit parent = rw.parseCommit(ObjectId.fromString(basePatchSet.getRevision().get()));
    boolean commitMessageOnly = parent.getTree().equals(squashed.getTree());
    String message = String.format("Patch Set %d: ", ps.getPatchSetId());
    if (commitMessageOnly) {
        message += "Commit message was edited";
    } else {
        message += String.format("Published edit on patch set %d", basePatchSet.getPatchSetId());
    }
    PatchSetInserter insr = patchSetInserterFactory.create(repo, rw, changeControlFactory.controlFor(change, edit.getUser()), squashed);
    return insr.setPatchSet(ps).setDraft(change.getStatus() == Status.DRAFT || basePatchSet.isDraft()).setMessage(message).insert();
}
#method_after
private Change insertPatchSet(ChangeEdit edit, Change change, Repository repo, RevWalk rw, PatchSet basePatchSet, RevCommit squashed) throws NoSuchChangeException, InvalidChangeOperationException, OrmException, IOException {
    PatchSet ps = new PatchSet(ChangeUtil.nextPatchSetId(change.currentPatchSetId()));
    ps.setRevision(new RevId(ObjectId.toString(squashed)));
    ps.setUploader(edit.getUser().getAccountId());
    ps.setCreatedOn(TimeUtil.nowTs());
    StringBuilder message = new StringBuilder("Patch set ").append(ps.getPatchSetId()).append(": ");
    ChangeKind kind = changeKindCache.getChangeKind(db.get(), change, ps);
    if (kind == ChangeKind.NO_CODE_CHANGE) {
        message.append("Commit message was updated.");
    } else {
        message.append("Published edit on patch set ").append(basePatchSet.getPatchSetId()).append(".");
    }
    PatchSetInserter inserter = patchSetInserterFactory.create(repo, rw, changeControlFactory.controlFor(change, edit.getUser()), squashed);
    return inserter.setPatchSet(ps).setDraft(change.getStatus() == Status.DRAFT || basePatchSet.isDraft()).setMessage(message.toString()).insert();
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    db = reviewDbProvider.open();
    changeId = newChange(admin.getIdent());
    ps = getCurrentPatchSet(changeId);
    amendChange(admin.getIdent(), changeId);
    change = getChange(changeId);
    assertThat(ps).isNotNull();
    changeId2 = newChange2(admin.getIdent());
    change2 = getChange(changeId2);
    assertThat(change2).isNotNull();
    ps2 = getCurrentPatchSet(changeId2);
    assertThat(ps2).isNotNull();
    final long clockStepMs = MILLISECONDS.convert(1, SECONDS);
    final AtomicLong clockMs = new AtomicLong(new DateTime(2009, 9, 30, 17, 0, 0).getMillis());
    DateTimeUtils.setCurrentMillisProvider(new MillisProvider() {

        @Override
        public long getMillis() {
            return clockMs.getAndAdd(clockStepMs);
        }
    });
}
#method_after
@Before
public void setUp() throws Exception {
    db = reviewDbProvider.open();
    changeId = newChange(admin.getIdent());
    ps = getCurrentPatchSet(changeId);
    amendChange(admin.getIdent(), changeId);
    change = getChange(changeId);
    assertThat(ps).isNotNull();
    changeId2 = newChange2(admin.getIdent());
    change2 = getChange(changeId2);
    assertThat(change2).isNotNull();
    ps2 = getCurrentPatchSet(changeId2);
    assertThat(ps2).isNotNull();
}
#end_block

#method_before
@After
public void cleanup() {
    DateTimeUtils.setCurrentMillisSystem();
    db.close();
}
#method_after
@After
public void cleanup() {
    db.close();
}
#end_block

#method_before
@Test
public void publishEdit() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.publish(editUtil.byChange(change).get());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Uploaded patch set 3: Published edit on patch set 2."));
}
#method_after
@Test
public void publishEdit() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.publish(editUtil.byChange(change).get());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch set 3: Published edit on patch set 2."));
}
#end_block

#method_before
@Test
public void publishEditRest() throws Exception {
    PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId);
    assertThat(modifier.createEdit(change, oldCurrentPatchSet)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = adminSession.post(urlPublish());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
    PatchSet newCurrentPatchSet = getCurrentPatchSet(changeId);
    assertThat(newCurrentPatchSet.getId()).isNotEqualTo(oldCurrentPatchSet.getId());
}
#method_after
@Test
public void publishEditRest() throws Exception {
    PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId);
    assertThat(modifier.createEdit(change, oldCurrentPatchSet)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = adminSession.post(urlPublish());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
    PatchSet newCurrentPatchSet = getCurrentPatchSet(changeId);
    assertThat(newCurrentPatchSet.getId()).isNotEqualTo(oldCurrentPatchSet.getId());
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch set 3: Published edit on patch set 2."));
}
#end_block

#method_before
@Test
public void updateMessage() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    String msg = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
    editUtil.publish(edit.get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
}
#method_after
@Test
public void updateMessage() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    String msg = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
    editUtil.publish(edit.get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch set 3: Commit message was updated."));
}
#end_block

#method_before
@Test
public void updateMessageRest() throws Exception {
    assertThat(adminSession.get(urlEditMessage()).getStatusCode()).isEqualTo(SC_NOT_FOUND);
    EditMessage.Input in = new EditMessage.Input();
    in.message = String.format("New commit message\n\n" + CONTENT_NEW2_STR + "\n\nChange-Id: %s", change.getKey());
    assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    RestResponse r = adminSession.getJsonAccept(urlEditMessage());
    assertThat(r.getStatusCode()).isEqualTo(SC_OK);
    assertThat(readContentFromJson(r)).isEqualTo(in.message);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    in.message = String.format("New commit message2\n\nChange-Id: %s", change.getKey());
    assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
}
#method_after
@Test
public void updateMessageRest() throws Exception {
    assertThat(adminSession.get(urlEditMessage()).getStatusCode()).isEqualTo(SC_NOT_FOUND);
    EditMessage.Input in = new EditMessage.Input();
    in.message = String.format("New commit message\n\n" + CONTENT_NEW2_STR + "\n\nChange-Id: %s", change.getKey());
    assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    RestResponse r = adminSession.getJsonAccept(urlEditMessage());
    assertThat(r.getStatusCode()).isEqualTo(SC_OK);
    assertThat(readContentFromJson(r)).isEqualTo(in.message);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    in.message = String.format("New commit message2\n\nChange-Id: %s", change.getKey());
    assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    editUtil.publish(edit.get());
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch set 3: Commit message was updated."));
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, AproposCommand.class);
    command(gerrit, BanCommitCommand.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("git-upload-archive").to(Commands.key(git, "upload-archive"));
    command(git, "upload-archive").to(UploadArchive.class);
    command("suexec").to(SuExec.class);
    listener().to(ShowCaches.StartupListener.class);
    // The following commands can only be ran on a server in Master mode
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, AdminQueryShell.class);
    if (!slaveMode) {
        command("git-receive-pack").to(Commands.key(git, "receive-pack"));
        command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
        command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
        command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    }
    command(gerrit, Receive.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, ReviewCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, SetMembersCommand.class);
    command(gerrit, CreateBranchCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, CreateAccountCommand.class);
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
}
#method_after
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName logging = Commands.named(gerrit, "logging");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, AproposCommand.class);
    command(gerrit, BanCommitCommand.class);
    command(gerrit, CloseConnection.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("git-upload-archive").to(Commands.key(git, "upload-archive"));
    command(git, "upload-archive").to(UploadArchive.class);
    command("suexec").to(SuExec.class);
    listener().to(ShowCaches.StartupListener.class);
    // The following commands can only be run on a server in Master mode
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, SetHeadCommand.class);
    command(gerrit, AdminQueryShell.class);
    if (slaveMode) {
        command("git-receive-pack").to(NotSupportedInSlaveModeFailureCommand.class);
        command("gerrit-receive-pack").to(NotSupportedInSlaveModeFailureCommand.class);
        command(git, "receive-pack").to(NotSupportedInSlaveModeFailureCommand.class);
        command(gerrit, "test-submit").to(NotSupportedInSlaveModeFailureCommand.class);
    } else {
        command("git-receive-pack").to(Commands.key(git, "receive-pack"));
        command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
        command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
        command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    }
    command(gerrit, Receive.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, ReviewCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, SetMembersCommand.class);
    command(gerrit, CreateBranchCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, CreateAccountCommand.class);
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
    command(logging).toProvider(new DispatchCommandProvider(logging));
    command(logging, SetLoggingLevelCommand.class);
    command(logging, ListLoggingLevelCommand.class);
    alias(logging, "ls", ListLoggingLevelCommand.class);
    alias(logging, "set", SetLoggingLevelCommand.class);
}
#end_block

#method_before
protected void readArguments() throws IOException, Failure {
    final String arg_cmd = "argument ";
    List<String> args = Lists.newArrayList();
    // Read arguments in Pkt-Line format
    PacketLineIn packetIn = new PacketLineIn(in);
    for (; ; ) {
        String s = packetIn.readString();
        if (s == PacketLineIn.END)
            break;
        if (!s.startsWith(arg_cmd)) {
            throw new Failure(1, "fatal: 'argument' token or flush expected");
        }
        String[] parts = s.substring(arg_cmd.length()).split("=", 2);
        for (String p : parts) args.add(p);
    }
    try {
        // Parse them into the 'm_options' field
        CmdLineParser parser = new CmdLineParser(m_options);
        parser.parseArgument(args);
    } catch (CmdLineException e) {
        throw new Failure(2, "fatal: unable to parse arguments, " + e);
    }
}
#method_after
protected void readArguments() throws IOException, Failure {
    String argCmd = "argument ";
    List<String> args = Lists.newArrayList();
    // Read arguments in Pkt-Line format
    PacketLineIn packetIn = new PacketLineIn(in);
    for (; ; ) {
        String s = packetIn.readString();
        if (s == PacketLineIn.END) {
            break;
        }
        if (!s.startsWith(argCmd)) {
            throw new Failure(1, "fatal: 'argument' token or flush expected");
        }
        String[] parts = s.substring(argCmd.length()).split("=", 2);
        for (String p : parts) {
            args.add(p);
        }
    }
    try {
        // Parse them into the 'options' field
        CmdLineParser parser = new CmdLineParser(options);
        parser.parseArgument(args);
        if (options.path == null || Arrays.asList(".").equals(options.path)) {
            options.path = Collections.emptyList();
        }
    } catch (CmdLineException e) {
        throw new Failure(2, "fatal: unable to parse arguments, " + e);
    }
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    PacketLineOut packetOut = new PacketLineOut(out);
    packetOut.setFlushOnEnd(true);
    packetOut.writeString("ACK");
    packetOut.end();
    try {
        // Parse Git arguments
        readArguments();
        // Verify the user has permissions to read the specified reference
        if (!projectControl.allRefsAreVisible()) {
            throw new Failure(4, "fatal: upload-archive not permitted on this server");
        }
        // Find out the object to get from the specified reference and requested path
        ObjectId treeId = repo.resolve(m_options.treeIsh);
        if (treeId.equals(ObjectId.zeroId())) {
            throw new Failure(5, "fatal: reference not found");
        }
        // Build the archive
        final String format = m_options.format;
        final boolean wasFormatRegistered = registerArchiveFormat(format);
        try {
            // The archive is sent in DATA sideband channel
            SideBandOutputStream sidebandOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, SideBandOutputStream.MAX_BUF, out);
            new ArchiveCommand(repo).setFormat(format).setTree(treeId).setPaths((m_options.path == null ? Collections.emptyList() : m_options.path).toArray(new String[0])).setPrefix(m_options.prefix).setOutputStream(sidebandOut).call();
            sidebandOut.flush();
            sidebandOut.close();
        } catch (GitAPIException e) {
            throw new Failure(6, "fatal: git api exception, " + e);
        } finally {
            if (wasFormatRegistered)
                unregisterArchiveFormat(format);
        }
    } catch (Failure f) {
        // Report the error in ERROR sideband channel
        SideBandOutputStream sidebandError = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.MAX_BUF, out);
        sidebandError.write(f.getMessage().getBytes());
        sidebandError.flush();
        sidebandError.close();
        throw f;
    } finally {
        // In any case, cleanly close the packetOut channel
        packetOut.end();
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    PacketLineOut packetOut = new PacketLineOut(out);
    packetOut.setFlushOnEnd(true);
    packetOut.writeString("ACK");
    packetOut.end();
    try {
        // Parse Git arguments
        readArguments();
        ArchiveFormat f = allowedFormats.getExtensions().get("." + options.format);
        if (f == null) {
            throw new Failure(3, "fatal: upload-archive not permitted");
        }
        // Find out the object to get from the specified reference and paths
        ObjectId treeId = repo.resolve(options.treeIsh);
        if (treeId.equals(ObjectId.zeroId())) {
            throw new Failure(4, "fatal: reference not found");
        }
        // Verify the user has permissions to read the specified reference
        if (!projectControl.allRefsAreVisible() && !canRead(treeId)) {
            throw new Failure(5, "fatal: cannot perform upload-archive operation");
        }
        try {
            // The archive is sent in DATA sideband channel
            SideBandOutputStream sidebandOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, SideBandOutputStream.MAX_BUF, out);
            new ArchiveCommand(repo).setFormat(f.name()).setFormatOptions(getFormatOptions(f)).setTree(treeId).setPaths(options.path.toArray(new String[0])).setPrefix(options.prefix).setOutputStream(sidebandOut).call();
            sidebandOut.flush();
            sidebandOut.close();
        } catch (GitAPIException e) {
            throw new Failure(7, "fatal: git api exception, " + e);
        }
    } catch (Failure f) {
        // Report the error in ERROR sideband channel
        SideBandOutputStream sidebandError = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.MAX_BUF, out);
        sidebandError.write(f.getMessage().getBytes(UTF_8));
        sidebandError.flush();
        sidebandError.close();
        throw f;
    } finally {
        // In any case, cleanly close the packetOut channel
        packetOut.end();
    }
}
#end_block

#method_before
private List<TopMenu.MenuItem> my(VersionedAccountPreferences v, Repository allUsers) {
    List<TopMenu.MenuItem> my = my(v);
    if (my.isEmpty() && !v.isDefaults()) {
        try {
            VersionedAccountPreferences d = VersionedAccountPreferences.forDefault();
            d.load(allUsers);
            my = my(d);
        } catch (ConfigInvalidException | IOException e) {
            log.warn("cannot read default preferences", e);
        }
    }
    if (my.isEmpty()) {
        my.add(new TopMenu.MenuItem("Changes", "#/dashboard/self", null));
        my.add(new TopMenu.MenuItem("Drafts", "#/q/owner:self+is:draft", null));
        my.add(new TopMenu.MenuItem("Draft Comments", "#/q/has:draft", null));
        my.add(new TopMenu.MenuItem("Change Edits", "#/q/has:edit", null));
        my.add(new TopMenu.MenuItem("Watched Changes", "#/q/is:watched+is:open", null));
        my.add(new TopMenu.MenuItem("Starred Changes", "#/q/is:starred", null));
        my.add(new TopMenu.MenuItem("Groups", "#/groups/self", null));
    }
    return my;
}
#method_after
private List<TopMenu.MenuItem> my(VersionedAccountPreferences v, Repository allUsers) {
    List<TopMenu.MenuItem> my = my(v);
    if (my.isEmpty() && !v.isDefaults()) {
        try {
            VersionedAccountPreferences d = VersionedAccountPreferences.forDefault();
            d.load(allUsers);
            my = my(d);
        } catch (ConfigInvalidException | IOException e) {
            log.warn("cannot read default preferences", e);
        }
    }
    if (my.isEmpty()) {
        my.add(new TopMenu.MenuItem("Changes", "#/dashboard/self", null));
        my.add(new TopMenu.MenuItem("Drafts", "#/q/owner:self+is:draft", null));
        my.add(new TopMenu.MenuItem("Draft Comments", "#/q/has:draft", null));
        my.add(new TopMenu.MenuItem("Edits", "#/q/has:edit", null));
        my.add(new TopMenu.MenuItem("Watched Changes", "#/q/is:watched+is:open", null));
        my.add(new TopMenu.MenuItem("Starred Changes", "#/q/is:starred", null));
        my.add(new TopMenu.MenuItem("Groups", "#/groups/self", null));
    }
    return my;
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, changeDataFactory, fillArgs, plcUtil, accountResolver, groupBackend, allProjectsName, patchListCache, repoManager, projectCache, listChildProjects, indexes, submitStrategyFactory, conflictsCache, trackingFooters, allowsDrafts);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, changeDataFactory, fillArgs, plcUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, indexes, submitStrategyFactory, conflictsCache, trackingFooters, allowsDrafts);
}
#end_block

#method_before
@Override
public boolean match(ChangeData cd) throws OrmException {
    for (Account.Id accountId : cd.editsByUser()) {
        if (accountId.equals(id)) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean match(ChangeData cd) throws OrmException {
    return cd.editsByUser().contains(id);
}
#end_block

#method_before
public static void ensureAllPatchSetsLoaded(Iterable<ChangeData> changes) throws OrmException {
    for (ChangeData cd : changes) {
        cd.patches();
    }
}
#method_after
public static void ensureAllPatchSetsLoaded(Iterable<ChangeData> changes) throws OrmException {
    for (ChangeData cd : changes) {
        cd.patchSets();
    }
}
#end_block

#method_before
public static void ensureCurrentPatchSetLoaded(Iterable<ChangeData> changes) throws OrmException {
    Map<PatchSet.Id, ChangeData> missing = Maps.newHashMap();
    for (ChangeData cd : changes) {
        if (cd.currentPatchSet == null && cd.patches == null) {
            missing.put(cd.change().currentPatchSetId(), cd);
        }
    }
    if (!missing.isEmpty()) {
        ReviewDb db = missing.values().iterator().next().db;
        for (PatchSet ps : db.patchSets().get(missing.keySet())) {
            ChangeData cd = missing.get(ps.getId());
            cd.currentPatchSet = ps;
        }
    }
}
#method_after
public static void ensureCurrentPatchSetLoaded(Iterable<ChangeData> changes) throws OrmException {
    Map<PatchSet.Id, ChangeData> missing = Maps.newHashMap();
    for (ChangeData cd : changes) {
        if (cd.currentPatchSet == null && cd.patchSets == null) {
            missing.put(cd.change().currentPatchSetId(), cd);
        }
    }
    if (!missing.isEmpty()) {
        ReviewDb db = missing.values().iterator().next().db;
        for (PatchSet ps : db.patchSets().get(missing.keySet())) {
            ChangeData cd = missing.get(ps.getId());
            cd.currentPatchSet = ps;
        }
    }
}
#end_block

#method_before
static ChangeData createForTest(Change.Id id, int currentPatchSetId) {
    ChangeData cd = new ChangeData(null, null, null, null, null, null, null, null, null, null, null, null, null, null, id);
    cd.currentPatchSet = new PatchSet(new PatchSet.Id(id, currentPatchSetId));
    return cd;
}
#method_after
public static ChangeData createForTest(Change.Id id, int currentPatchSetId) {
    ChangeData cd = new ChangeData(null, null, null, null, null, null, null, null, null, null, null, null, null, id);
    cd.currentPatchSet = new PatchSet(new PatchSet.Id(id, currentPatchSetId));
    return cd;
}
#end_block

#method_before
public PatchSet currentPatchSet() throws OrmException {
    if (currentPatchSet == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        for (PatchSet p : patches()) {
            if (p.getId().equals(c.currentPatchSetId())) {
                currentPatchSet = p;
                return p;
            }
        }
    }
    return currentPatchSet;
}
#method_after
public PatchSet currentPatchSet() throws OrmException {
    if (currentPatchSet == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        for (PatchSet p : patchSets()) {
            if (p.getId().equals(c.currentPatchSetId())) {
                currentPatchSet = p;
                return p;
            }
        }
    }
    return currentPatchSet;
}
#end_block

#method_before
public Set<Account.Id> editsByUser() throws OrmException {
    if (editsByUser == null) {
        Change c = change();
        if (c == null) {
            return Collections.emptySet();
        }
        try {
            editsByUser = editUtils.accountsByChange(c);
        } catch (IOException e) {
            throw new OrmException(e);
        }
    }
    return editsByUser;
}
#method_after
public Set<Account.Id> editsByUser() throws OrmException {
    if (editsByUser == null) {
        Change c = change();
        if (c == null) {
            return Collections.emptySet();
        }
        editsByUser = new HashSet<>();
        Change.Id id = change.getId();
        try (Repository repo = repoManager.openRepository(change.getProject())) {
            for (String ref : repo.getRefDatabase().getRefs(RefNames.REFS_USERS).keySet()) {
                if (Change.Id.fromEditRefPart(ref).equals(id)) {
                    editsByUser.add(Account.Id.fromRefPart(ref));
                }
            }
        } catch (IOException e) {
            throw new OrmException(e);
        }
    }
    return editsByUser;
}
#end_block

#method_before
public static String refsUsers(Account.Id accountId) {
    StringBuilder r = new StringBuilder();
    r.append(REFS_USER);
    int account = accountId.get();
    int m = account % 100;
    if (m < 10) {
        r.append('0');
    }
    r.append(m);
    r.append('/');
    r.append(account);
    return r.toString();
}
#method_after
public static String refsUsers(Account.Id accountId) {
    StringBuilder r = new StringBuilder();
    r.append(REFS_USERS);
    int account = accountId.get();
    int m = account % 100;
    if (m < 10) {
        r.append('0');
    }
    r.append(m);
    r.append('/');
    r.append(account);
    return r.toString();
}
#end_block

#method_before
public void publish(ChangeEdit edit) throws AuthException, NoSuchChangeException, IOException, InvalidChangeOperationException, OrmException, ResourceConflictException {
    Change change = edit.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject());
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter()) {
        PatchSet basePatchSet = edit.getBasePatchSet();
        if (!basePatchSet.getId().equals(change.currentPatchSetId())) {
            throw new ResourceConflictException("only edit for current patch set can be published");
        }
        insertPatchSet(edit, change, repo, rw, basePatchSet, squashEdit(rw, inserter, edit.getEditCommit(), basePatchSet));
        // TODO(davido): This should happen in the same BatchRefUpdate.
        deleteRef(repo, edit);
        // The answer to the question "why it doesn't hurt to reload the change?"
        // is let as an exercise to the reader.
        indexer.index(changeDataFactory.create(db.get(), change.getId()));
    }
}
#method_after
public void publish(ChangeEdit edit) throws AuthException, NoSuchChangeException, IOException, InvalidChangeOperationException, OrmException, ResourceConflictException {
    Change change = edit.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject());
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter()) {
        PatchSet basePatchSet = edit.getBasePatchSet();
        if (!basePatchSet.getId().equals(change.currentPatchSetId())) {
            throw new ResourceConflictException("only edit for current patch set can be published");
        }
        Change updatedChange = insertPatchSet(edit, change, repo, rw, basePatchSet, squashEdit(rw, inserter, edit.getEditCommit(), basePatchSet));
        // TODO(davido): This should happen in the same BatchRefUpdate.
        deleteRef(repo, edit);
        indexer.index(db.get(), updatedChange);
    }
}
#end_block

#method_before
private void insertPatchSet(ChangeEdit edit, Change change, Repository repo, RevWalk rw, PatchSet basePatchSet, RevCommit squashed) throws NoSuchChangeException, InvalidChangeOperationException, OrmException, IOException {
    PatchSet ps = new PatchSet(ChangeUtil.nextPatchSetId(change.currentPatchSetId()));
    ps.setRevision(new RevId(ObjectId.toString(squashed)));
    ps.setUploader(edit.getUser().getAccountId());
    ps.setCreatedOn(TimeUtil.nowTs());
    PatchSetInserter insr = patchSetInserterFactory.create(repo, rw, changeControlFactory.controlFor(change, edit.getUser()), squashed);
    insr.setPatchSet(ps).setDraft(change.getStatus() == Status.DRAFT || basePatchSet.isDraft()).setMessage(String.format("Patch Set %d: Published edit on patch set %d", ps.getPatchSetId(), basePatchSet.getPatchSetId())).insert();
}
#method_after
private Change insertPatchSet(ChangeEdit edit, Change change, Repository repo, RevWalk rw, PatchSet basePatchSet, RevCommit squashed) throws NoSuchChangeException, InvalidChangeOperationException, OrmException, IOException {
    PatchSet ps = new PatchSet(ChangeUtil.nextPatchSetId(change.currentPatchSetId()));
    ps.setRevision(new RevId(ObjectId.toString(squashed)));
    ps.setUploader(edit.getUser().getAccountId());
    ps.setCreatedOn(TimeUtil.nowTs());
    PatchSetInserter insr = patchSetInserterFactory.create(repo, rw, changeControlFactory.controlFor(change, edit.getUser()), squashed);
    return insr.setPatchSet(ps).setDraft(change.getStatus() == Status.DRAFT || basePatchSet.isDraft()).setMessage(String.format("Patch Set %d: Published edit on patch set %d", ps.getPatchSetId(), basePatchSet.getPatchSetId())).insert();
}
#end_block

#method_before
void replay() throws IOException, OrmException, NoSuchAccountException, NoSuchChangeException, RestApiException, ValidationException {
    List<ChangeInfo> changes = api.queryChanges(srcProject.get());
    pm.beginTask("Replay Changes", changes.size());
    RevWalk rw = new RevWalk(repo);
    for (ChangeInfo c : changes) {
        try {
            replayChange(rw, c);
        } catch (Exception e) {
            log.error(String.format("Failed to replay change %s.", Url.decode(c.id)), e);
            throw e;
        }
        pm.update(1);
    }
    pm.endTask();
}
#method_after
void replay() throws IOException, OrmException, NoSuchAccountException, NoSuchChangeException, RestApiException, ValidationException {
    List<ChangeInfo> changes = api.queryChanges(srcProject.get());
    pm.beginTask("Replay Changes", changes.size());
    try (RevWalk rw = new RevWalk(repo)) {
        for (ChangeInfo c : changes) {
            try {
                replayChange(rw, c);
            } catch (Exception e) {
                log.error(String.format("Failed to replay change %s.", Url.decode(c.id)), e);
                throw e;
            }
            pm.update(1);
        }
    }
    pm.endTask();
}
#end_block

#method_before
@Override
protected void onLoad() {
    if (!loaded) {
        ChangeApi.includedIn(changeId.get(), new AsyncCallback<IncludedInInfo>() {

            @Override
            public void onSuccess(IncludedInInfo r) {
                branches.setInnerSafeHtml(formatList(r.branches()));
                tags.setInnerSafeHtml(formatList(r.tags()));
                for (String t : r.systemTypes()) {
                    appendRow(t, r.system(t));
                }
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#method_after
@Override
protected void onLoad() {
    if (!loaded) {
        ChangeApi.includedIn(changeId.get(), new AsyncCallback<IncludedInInfo>() {

            @Override
            public void onSuccess(IncludedInInfo r) {
                branches.setInnerSafeHtml(formatList(r.branches()));
                tags.setInnerSafeHtml(formatList(r.tags()));
                for (String n : r.externalNames()) {
                    JsArrayString external = r.external(n);
                    if (external.length() > 0) {
                        appendRow(n, external);
                    }
                }
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#end_block

#method_before
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws BadRequestException, ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = rsrc.getControl();
    PatchSet ps = db.get().patchSets().get(ctl.getChange().currentPatchSetId());
    Project.NameKey project = ctl.getProject().getNameKey();
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        rw.setRetainBody(false);
        RevCommit rev;
        try {
            rev = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        } catch (IncorrectObjectTypeException err) {
            throw new BadRequestException(err.getMessage());
        } catch (MissingObjectException err) {
            throw new ResourceConflictException(err.getMessage());
        }
        IncludedInDetail d = IncludedInResolver.resolve(r, rw, rev);
        Map<String, Collection<String>> systems = new HashMap<>();
        for (DynamicMap.Entry<com.google.gerrit.extensions.config.IncludedIn> i : includedIn) {
            systems.put(i.getExportName(), i.getProvider().get().getIncludedIn(project.get(), rev.name(), d.getTags(), d.getBranches()));
        }
        return new IncludedInInfo(d, systems);
    }
}
#method_after
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws BadRequestException, ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = rsrc.getControl();
    PatchSet ps = db.get().patchSets().get(ctl.getChange().currentPatchSetId());
    Project.NameKey project = ctl.getProject().getNameKey();
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        rw.setRetainBody(false);
        RevCommit rev;
        try {
            rev = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        } catch (IncorrectObjectTypeException err) {
            throw new BadRequestException(err.getMessage());
        } catch (MissingObjectException err) {
            throw new ResourceConflictException(err.getMessage());
        }
        IncludedInDetail d = IncludedInResolver.resolve(r, rw, rev);
        Map<String, Collection<String>> external = new HashMap<>();
        for (DynamicMap.Entry<ExternalIncludedIn> i : includedIn) {
            external.put(i.getExportName(), i.getProvider().get().getIncludedIn(project.get(), rev.name(), d.getTags(), d.getBranches()));
        }
        return new IncludedInInfo(d, (!external.isEmpty() ? external : null));
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), IncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ReplicationQueue.class).in(Scopes.SINGLETON);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), HeadUpdatedListener.class).to(ReplicationQueue.class);
    bind(OnStartStop.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(OnStartStop.class);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(ReplicationLogFile.class);
    bind(CredentialsFactory.class).to(AutoReloadSecureCredentialsFactoryDecorator.class).in(Scopes.SINGLETON);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(START_REPLICATION)).to(StartReplicationCapability.class);
    install(new FactoryModuleBuilder().build(PushAll.Factory.class));
    install(new FactoryModuleBuilder().build(RemoteSiteUser.Factory.class));
    bind(ReplicationConfig.class).to(AutoReloadConfigDecorator.class);
    EventTypes.registerClass(new RefReplicatedEvent(null, null, null, SUCCEEDED));
    EventTypes.registerClass(new RefReplicationDoneEvent(null, null, 0));
    bind(ReplicationStateListener.class).to(ReplicationStateLogger.class);
}
#method_after
@Override
protected void configure() {
    bind(ReplicationQueue.class).in(Scopes.SINGLETON);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), HeadUpdatedListener.class).to(ReplicationQueue.class);
    bind(OnStartStop.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(OnStartStop.class);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(ReplicationLogFile.class);
    bind(CredentialsFactory.class).to(AutoReloadSecureCredentialsFactoryDecorator.class).in(Scopes.SINGLETON);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(START_REPLICATION)).to(StartReplicationCapability.class);
    install(new FactoryModuleBuilder().build(PushAll.Factory.class));
    install(new FactoryModuleBuilder().build(RemoteSiteUser.Factory.class));
    bind(ReplicationConfig.class).to(AutoReloadConfigDecorator.class);
    bind(ReplicationStateListener.class).to(ReplicationStateLogger.class);
    EventTypes.registerClass(new RefReplicatedEvent(null, null, null, SUCCEEDED));
    EventTypes.registerClass(new RefReplicationDoneEvent(null, null, 0));
}
#end_block

#method_before
private List<Destination> allDestinations() throws ConfigInvalidException, IOException {
    if (!config.getFile().exists()) {
        log.warn("Config file " + config.getFile() + "does not exist; not replicating");
        return Collections.emptyList();
    }
    if (config.getFile().length() == 0) {
        log.info("Config file " + config.getFile() + " is empty; not replicating");
        return Collections.emptyList();
    }
    try {
        config.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", config.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", config.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = config.getBoolean("gerrit", "replicateOnStartup", true);
    defaultForceUpdate = config.getBoolean("gerrit", "defaultForceUpdate", false);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(config)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(defaultForceUpdate));
        }
        Destination destination = new Destination(injector, c, config, replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend, statLog);
        if (!destination.isSingleProjectMatch()) {
            for (URIish u : c.getURIs()) {
                if (u.getPath() == null || !u.getPath().contains("${name}")) {
                    throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, config.getFile()));
                }
            }
        }
        dest.add(destination);
    }
    return dest.build();
}
#method_after
private List<Destination> allDestinations() throws ConfigInvalidException, IOException {
    if (!config.getFile().exists()) {
        log.warn("Config file " + config.getFile() + "does not exist; not replicating");
        return Collections.emptyList();
    }
    if (config.getFile().length() == 0) {
        log.info("Config file " + config.getFile() + " is empty; not replicating");
        return Collections.emptyList();
    }
    try {
        config.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", config.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", config.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = config.getBoolean("gerrit", "replicateOnStartup", true);
    defaultForceUpdate = config.getBoolean("gerrit", "defaultForceUpdate", false);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(config)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(defaultForceUpdate));
        }
        Destination destination = new Destination(injector, c, config, replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend, stateLog);
        if (!destination.isSingleProjectMatch()) {
            for (URIish u : c.getURIs()) {
                if (u.getPath() == null || !u.getPath().contains("${name}")) {
                    throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, config.getFile()));
                }
            }
        }
        dest.add(destination);
    }
    return dest.build();
}
#end_block

#method_before
public List<CommentInfo> getComments(RevisionResource rsrc) throws OrmException {
    return commentJson.get().setFillAccounts(includeAuthorInfo()).format2(listComments(rsrc));
}
#method_after
public List<CommentInfo> getComments(RevisionResource rsrc) throws OrmException {
    return commentJson.get().setFillAccounts(includeAuthorInfo()).formatAsList(listComments(rsrc));
}
#end_block

#method_before
@Test
public void comments() throws Exception {
    PushOneCommit.Result r = createChange();
    CommentInput in = new CommentInput();
    in.line = 1;
    in.message = "nit: trailing whitespace";
    in.path = FILE_NAME;
    ReviewInput reviewInput = new ReviewInput();
    Map<String, List<CommentInput>> comments = new HashMap<>();
    comments.put(FILE_NAME, Collections.singletonList(in));
    reviewInput.comments = comments;
    reviewInput.message = "comment test";
    gApi.changes().id(r.getChangeId()).current().review(reviewInput);
    Map<String, List<CommentInfo>> out = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).comments();
    assertThat(out).hasSize(1);
    CommentInfo comment = Iterables.getOnlyElement(out.get(FILE_NAME));
    assertThat(comment.message).isEqualTo(in.message);
    assertThat(comment.author.email).isEqualTo(admin.email);
    assertThat(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).comment(comment.id).get().message).isEqualTo(in.message);
}
#method_after
@Test
public void comments() throws Exception {
    PushOneCommit.Result r = createChange();
    CommentInput in = new CommentInput();
    in.line = 1;
    in.message = "nit: trailing whitespace";
    in.path = FILE_NAME;
    ReviewInput reviewInput = new ReviewInput();
    Map<String, List<CommentInput>> comments = new HashMap<>();
    comments.put(FILE_NAME, Collections.singletonList(in));
    reviewInput.comments = comments;
    reviewInput.message = "comment test";
    gApi.changes().id(r.getChangeId()).current().review(reviewInput);
    Map<String, List<CommentInfo>> out = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).comments();
    assertThat(out).hasSize(1);
    CommentInfo comment = Iterables.getOnlyElement(out.get(FILE_NAME));
    assertThat(comment.message).isEqualTo(in.message);
    assertThat(comment.author.email).isEqualTo(admin.email);
    assertThat(comment.path).isNull();
    List<CommentInfo> list = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).commentsAsList();
    assertThat(list).hasSize(1);
    CommentInfo comment2 = list.get(0);
    assertThat(comment2.path).isEqualTo(FILE_NAME);
    assertThat(comment2.line).isEqualTo(comment.line);
    assertThat(comment2.message).isEqualTo(comment.message);
    assertThat(comment2.author.email).isEqualTo(comment.author.email);
    assertThat(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).comment(comment.id).get().message).isEqualTo(in.message);
}
#end_block

#method_before
public AMQP.BasicProperties getBasicProperties() {
    if (headers == null) {
        headers = new HashMap<>();
        for (Section section : properties.getSections()) {
            for (Field f : section.getClass().getFields()) {
                if (f.isAnnotationPresent(MessageHeader.class)) {
                    MessageHeader mh = f.getAnnotation(MessageHeader.class);
                    try {
                        switch(f.getType().getSimpleName()) {
                            case "String":
                                headers.put(mh.value(), f.get(section).toString());
                                break;
                            case "Integer":
                                headers.put(mh.value(), f.getInt(section));
                                break;
                            case "Long":
                                headers.put(mh.value(), f.getLong(section));
                                break;
                            case "Boolean":
                                headers.put(mh.value(), f.getBoolean(section));
                                break;
                            default:
                                break;
                        }
                    } catch (Exception ex) {
                        LOGGER.info(ex.getMessage());
                    }
                }
            }
        }
    }
    return new AMQP.BasicProperties.Builder().appId(EVENT_APPID).contentEncoding(CharEncoding.UTF_8).contentType(CONTENT_TYPE_JSON).deliveryMode(message.deliveryMode).priority(message.priority).headers(headers).timestamp(new Date(TimeUtil.nowMs())).build();
}
#method_after
public AMQP.BasicProperties getBasicProperties() {
    return new AMQP.BasicProperties.Builder().appId(EVENT_APPID).contentEncoding(CharEncoding.UTF_8).contentType(CONTENT_TYPE_JSON).deliveryMode(message.deliveryMode).priority(message.priority).headers(headers).timestamp(new Date(TimeUtil.nowMs())).build();
}
#end_block

#method_before
void reloadRevisionActions(NativeMap<ActionInfo> actions) {
    if (!Gerrit.isSignedIn()) {
        return;
    }
    boolean canSubmit = actions.containsKey("submit");
    if (canSubmit) {
        ActionInfo action = actions.get("submit");
        submit.setTitle(action.title());
        submit.setEnabled(action.enabled());
        submit.setHTML(new SafeHtmlBuilder().openDiv().append(action.label()).closeDiv());
        submit.setEnabled(action.enabled());
    }
    submit.setVisible(canSubmit);
    a2b(actions, "cherrypick", cherrypick);
    a2b(actions, "rebase", rebase);
    // The rebase button on change screen is always enabled.
    // It the the "Rebase" button in the RebaseDialog that might be disabled.
    rebaseParentNotCurrent = rebase.isEnabled();
    if (rebase.isVisible()) {
        rebase.setEnabled(true);
    }
    RevisionInfo revInfo = changeInfo.revision(revision);
    for (String id : filterNonCore(actions)) {
        add(new ActionButton(changeInfo, revInfo, actions.get(id)));
    }
}
#method_after
void reloadRevisionActions(NativeMap<ActionInfo> actions) {
    if (!Gerrit.isSignedIn()) {
        return;
    }
    boolean canSubmit = actions.containsKey("submit");
    if (canSubmit) {
        ActionInfo action = actions.get("submit");
        submit.setTitle(action.title());
        submit.setEnabled(action.enabled());
        submit.setHTML(new SafeHtmlBuilder().openDiv().append(action.label()).closeDiv());
        submit.setEnabled(action.enabled());
    }
    submit.setVisible(canSubmit);
    a2b(actions, "cherrypick", cherrypick);
    a2b(actions, "rebase", rebase);
    // The rebase button on change screen is always enabled.
    // It is the "Rebase" button in the RebaseDialog that might be disabled.
    rebaseParentNotCurrent = rebase.isEnabled();
    if (rebase.isVisible()) {
        rebase.setEnabled(true);
    }
    RevisionInfo revInfo = changeInfo.revision(revision);
    for (String id : filterNonCore(actions)) {
        add(new ActionButton(changeInfo, revInfo, actions.get(id)));
    }
}
#end_block

#method_before
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorPanel, authorNameEmail, authorDate, change);
    formatLink(commit.committer(), committerPanel, committerNameEmail, committerDate, change);
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    setWebLinks(change, revision, revInfo);
    if (revInfo.commit().parents().length() > 1) {
        mergeCommit.setVisible(true);
    }
    setParents(change.project(), revInfo.commit().parents());
    setParentNotCurrent(false);
}
#method_after
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorPanel, authorNameEmail, authorDate, change);
    formatLink(commit.committer(), committerPanel, committerNameEmail, committerDate, change);
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    setWebLinks(change, revision, revInfo);
    if (revInfo.commit().parents().length() > 1) {
        mergeCommit.setVisible(true);
    }
    setParents(change.project(), revInfo.commit().parents());
}
#end_block

#method_before
@Override
protected void onLoad() {
    commentsPanel.setVisible(false);
    post.setEnabled(false);
    ChangeApi.drafts(psId.getParentKey().get()).get(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            attachComments(result);
            displayComments(result);
            post.setEnabled(true);
        }

        @Override
        public void onFailure(Throwable caught) {
            post.setEnabled(true);
        }
    });
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            message.setFocus(true);
        }
    });
    Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

        @Override
        public boolean execute() {
            String t = message.getText();
            if (t != null) {
                message.setCursorPos(t.length());
            }
            return false;
        }
    }, 0);
}
#method_after
@Override
protected void onLoad() {
    commentsPanel.setVisible(false);
    post.setEnabled(false);
    ChangeApi.drafts(psId.getParentKey().get()).get(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            displayComments(result);
            post.setEnabled(true);
        }

        @Override
        public void onFailure(Throwable caught) {
            post.setEnabled(true);
        }
    });
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            message.setFocus(true);
        }
    });
    Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

        @Override
        public boolean execute() {
            String t = message.getText();
            if (t != null) {
                message.setCursorPos(t.length());
            }
            return false;
        }
    }, 0);
}
#end_block

#method_before
private void postReview() {
    in.message(message.getText().trim());
    in.drafts(DraftHandling.PUBLISH_ALL_REVISIONS);
    in.prePost();
    ChangeApi.revision(psId.getParentKey().get(), revision).view("review").post(in, new GerritCallback<ReviewInput>() {

        @Override
        public void onSuccess(ReviewInput result) {
            Gerrit.display(PageLinks.toChange(psId.getParentKey(), String.valueOf(psId.get())));
        }
    });
    hide();
}
#method_after
private void postReview() {
    in.message(message.getText().trim());
    // Don't send any comments in the request; just publish everything, even if
    // e.g. a draft was modified in another tab since we last looked it up.
    in.drafts(DraftHandling.PUBLISH_ALL_REVISIONS);
    in.prePost();
    ChangeApi.revision(psId.getParentKey().get(), revision).view("review").post(in, new GerritCallback<ReviewInput>() {

        @Override
        public void onSuccess(ReviewInput result) {
            Gerrit.display(PageLinks.toChange(psId.getParentKey(), String.valueOf(psId.get())));
        }
    });
    hide();
}
#end_block

#method_before
private List<NativeMap<JsArray<CommentInfo>>> loadComments(RevisionInfo rev, CallbackGroup group) {
    final int id = rev._number();
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    ChangeApi.comments(changeId.get()).get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            NativeMap<JsArray<CommentInfo>> filtered = NativeMap.create();
            for (String k : result.keySet()) {
                JsArray<CommentInfo> allRevisions = result.get(k);
                JsArray<CommentInfo> thisRevision = JsArray.createArray().cast();
                for (int i = 0; i < allRevisions.length(); i++) {
                    CommentInfo c = allRevisions.get(i);
                    if (!c.has_patch_set() || c.patch_set() == id) {
                        thisRevision.push(c);
                    }
                }
                filtered.put(k, thisRevision);
            }
            // Only count comments for the current revision in the file table, but
            // include all comments in the history table below.
            r.add(filtered);
            history.addComments(result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#method_after
private List<NativeMap<JsArray<CommentInfo>>> loadComments(final RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    // TODO(dborowitz): Could eliminate this call by adding an option to include
    // inline comments in the change detail.
    ChangeApi.comments(changeId.get()).get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            // Return value is used for populating the file table, so only count
            // comments for the current revision. Still include all comments in
            // the history table.
            r.add(filterForRevision(result, rev._number()));
            history.addComments(result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    threads = ThreadLimiter.limitThreads(dbInjector, threads);
    cfg = dbInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    checkNotSlaveMode();
    disableLuceneAutomaticCommit();
    if (version == null) {
        version = ChangeSchemas.getLatest().getVersion();
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    index = sysInjector.getInstance(IndexCollection.class).getSearchIndex();
    int result = 0;
    try {
        index.markReady(false);
        index.deleteAll();
        result = indexAll();
        index.markReady(true);
    } catch (Exception e) {
        throw die(e.getMessage(), e);
    }
    sysManager.stop();
    dbManager.stop();
    return result;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    threads = ThreadLimiter.limitThreads(dbInjector, threads);
    checkNotSlaveMode();
    disableLuceneAutomaticCommit();
    if (version == null) {
        version = ChangeSchemas.getLatest().getVersion();
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    index = sysInjector.getInstance(IndexCollection.class).getSearchIndex();
    int result = 0;
    try {
        index.markReady(false);
        index.deleteAll();
        result = indexAll();
        index.markReady(true);
    } catch (Exception e) {
        throw die(e.getMessage(), e);
    }
    sysManager.stop();
    dbManager.stop();
    return result;
}
#end_block

#method_before
private void checkNotSlaveMode() throws Die {
    if (cfg.getBoolean("container", "slave", false)) {
        throw die("Cannot run reindex in slave mode");
    }
}
#method_after
private void checkNotSlaveMode() throws Die {
    Config cfg = dbInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    if (cfg.getBoolean("container", "slave", false)) {
        throw die("Cannot run reindex in slave mode");
    }
}
#end_block

#method_before
public PatchSetInserter setMessage(ChangeMessage changeMessage) throws OrmException {
    this.changeMessage = changeMessage;
    return this;
}
#method_after
public PatchSetInserter setMessage(ChangeMessage changeMessage) {
    this.changeMessage = changeMessage;
    return this;
}
#end_block

#method_before
public Change insert() throws InvalidChangeOperationException, OrmException, IOException, NoSuchChangeException {
    init();
    validate();
    Change c = ctl.getChange();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), c.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(c.getProject(), ru);
    final PatchSet.Id currentPatchSetId = c.currentPatchSetId();
    ChangeUpdate update = updateFactory.create(ctl, patchSet.getCreatedOn());
    db.changes().beginTransaction(c.getId());
    try {
        if (!db.changes().get(c.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", c.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        SetMultimap<ReviewerState, Account.Id> oldReviewers = sendMail ? approvalsUtil.getReviewers(db, ctl.getNotes()) : null;
        updatedChange = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", c.getId()));
        }
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        if (copyLabels) {
            approvalCopier.copy(db, ctl, patchSet);
        }
        db.commit();
        if (messageIsForChange()) {
            update.commit();
        }
        if (!messageIsForChange()) {
            commitMessageNotForChange(updatedChange);
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
                cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
    }
    return updatedChange;
}
#method_after
public Change insert() throws InvalidChangeOperationException, OrmException, IOException, NoSuchChangeException {
    init();
    validate();
    Change c = ctl.getChange();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), c.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(c.getProject(), ru);
    final PatchSet.Id currentPatchSetId = c.currentPatchSetId();
    ChangeUpdate update = updateFactory.create(ctl, patchSet.getCreatedOn());
    db.changes().beginTransaction(c.getId());
    try {
        if (!db.changes().get(c.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", c.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        SetMultimap<ReviewerState, Account.Id> oldReviewers = sendMail ? approvalsUtil.getReviewers(db, ctl.getNotes()) : null;
        updatedChange = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", c.getId()));
        }
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        if (copyLabels) {
            approvalCopier.copy(db, ctl, patchSet);
        }
        db.commit();
        if (messageIsForChange()) {
            update.commit();
        }
        if (!messageIsForChange()) {
            commitMessageNotForChange(updatedChange);
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
                cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
    }
    return updatedChange;
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    Futures.transform(executor.submit(new GetChanges(event)), new AsyncFunction<List<Change>, List<Void>>() {

        @Override
        public ListenableFuture<List<Void>> apply(List<Change> changes) {
            List<ListenableFuture<Void>> result = Lists.newArrayListWithCapacity(changes.size());
            for (Change c : changes) {
                result.add(executor.submit(new Index(c)));
            }
            return Futures.allAsList(result);
        }
    });
}
#method_after
@Override
public void onGitReferenceUpdated(final Event event) {
    Futures.transform(executor.submit(new GetChanges(event)), new AsyncFunction<List<Change>, List<Void>>() {

        @Override
        public ListenableFuture<List<Void>> apply(List<Change> changes) {
            List<ListenableFuture<Void>> result = Lists.newArrayListWithCapacity(changes.size());
            for (Change c : changes) {
                result.add(executor.submit(new Index(event, c)));
            }
            return Futures.allAsList(result);
        }
    });
}
#end_block

#method_before
@Override
public final V call() throws Exception {
    try {
        db = schemaFactory.open();
        return impl();
    } catch (Exception e) {
        log.error("Failed to reindex changes after ref update", e);
        throw e;
    } finally {
        if (db != null) {
            db.close();
        }
    }
}
#method_after
@Override
public final V call() throws Exception {
    try {
        db = schemaFactory.open();
        return impl();
    } catch (Exception e) {
        log.error("Failed to reindex changes after " + event, e);
        throw e;
    } finally {
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
@Before
public void createTempDirectory() throws Exception {
    sitePath = TempFileUtil.createTempDirectory().toPath();
}
#method_after
@Before
public void createTempDirectory() throws Exception {
    sitePath = TempFileUtil.createTempDirectory();
}
#end_block

#method_before
private void initSite() throws Exception {
    runGerrit("init", "-d", sitePath.toString(), "--batch", "--no-auto-start", "--skip-plugins", "--show-stack-trace");
}
#method_after
private void initSite() throws Exception {
    runGerrit("init", "-d", sitePath.getPath(), "--batch", "--no-auto-start", "--skip-plugins", "--show-stack-trace");
}
#end_block

#method_before
@Option(name = "--disable-httpd", usage = "Disable the internal HTTP daemon")
void setDisableHttpd(final boolean arg) {
    httpd = false;
}
#method_after
@Option(name = "--disable-httpd", usage = "Disable the internal HTTP daemon")
void setDisableHttpd(@SuppressWarnings("unused") boolean arg) {
    httpd = false;
}
#end_block

#method_before
@Option(name = "--disable-sshd", usage = "Disable the internal SSH daemon")
void setDisableSshd(final boolean arg) {
    sshd = false;
}
#method_after
@Option(name = "--disable-sshd", usage = "Disable the internal SSH daemon")
void setDisableSshd(@SuppressWarnings("unused") boolean arg) {
    sshd = false;
}
#end_block

#method_before
@Override
public int run() throws Exception {
    if (doInit) {
        try {
            new Init(getSitePath()).run();
        } catch (Exception e) {
            throw die("Init failed", e);
        }
    }
    mustHaveValidSite();
    Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void uncaughtException(Thread t, Throwable e) {
            log.error("Thread " + t.getName() + " threw exception", e);
        }
    });
    if (runId != null) {
        runFile = new File(new File(getSitePath(), "logs"), "gerrit.run");
    }
    if (httpd == null) {
        httpd = !slave;
    }
    if (!httpd && !sshd) {
        throw die("No services enabled, nothing to do");
    }
    if (slave && httpd) {
        throw die("Cannot combine --slave and --enable-httpd");
    }
    manager.add(GarbageCollectionLogFile.start(getSitePath()));
    if (consoleLog) {
    } else {
        manager.add(ErrorLogFile.start(getSitePath()));
    }
    try {
        start();
        RuntimeShutdown.add(new Runnable() {

            @Override
            public void run() {
                log.info("caught shutdown, cleaning up");
                if (runId != null) {
                    runFile.delete();
                }
                manager.stop();
            }
        });
        log.info("Gerrit Code Review " + myVersion() + " ready");
        if (runId != null) {
            try {
                runFile.createNewFile();
                runFile.setReadable(true, false);
                FileOutputStream out = new FileOutputStream(runFile);
                try {
                    out.write((runId + "\n").getBytes("UTF-8"));
                } finally {
                    out.close();
                }
            } catch (IOException err) {
                log.warn("Cannot write --run-id to " + runFile, err);
            }
        }
        if (serverStarted != null) {
            serverStarted.run();
        }
        if (inspector) {
            JythonShell shell = new JythonShell();
            shell.set("m", manager);
            shell.set("ds", dbInjector.getInstance(DataSourceProvider.class));
            shell.set("schk", dbInjector.getInstance(SchemaVersionCheck.class));
            shell.set("d", this);
            shell.run();
        } else {
            RuntimeShutdown.waitFor();
        }
        return 0;
    } catch (Throwable err) {
        log.error("Unable to start daemon", err);
        return 1;
    }
}
#method_after
@Override
public int run() throws Exception {
    if (doInit) {
        try {
            new Init(getSitePath()).run();
        } catch (Exception e) {
            throw die("Init failed", e);
        }
    }
    mustHaveValidSite();
    Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void uncaughtException(Thread t, Throwable e) {
            log.error("Thread " + t.getName() + " threw exception", e);
        }
    });
    if (runId != null) {
        runFile = new File(new File(getSitePath(), "logs"), "gerrit.run");
    }
    if (httpd == null) {
        httpd = !slave;
    }
    if (!httpd && !sshd) {
        throw die("No services enabled, nothing to do");
    }
    manager.add(GarbageCollectionLogFile.start(getSitePath()));
    if (consoleLog) {
    } else {
        manager.add(ErrorLogFile.start(getSitePath()));
    }
    try {
        start();
        RuntimeShutdown.add(new Runnable() {

            @Override
            public void run() {
                log.info("caught shutdown, cleaning up");
                if (runId != null) {
                    runFile.delete();
                }
                manager.stop();
            }
        });
        log.info("Gerrit Code Review " + myVersion() + " ready");
        if (runId != null) {
            try {
                runFile.createNewFile();
                runFile.setReadable(true, false);
                FileOutputStream out = new FileOutputStream(runFile);
                try {
                    out.write((runId + "\n").getBytes("UTF-8"));
                } finally {
                    out.close();
                }
            } catch (IOException err) {
                log.warn("Cannot write --run-id to " + runFile, err);
            }
        }
        if (serverStarted != null) {
            serverStarted.run();
        }
        if (inspector) {
            JythonShell shell = new JythonShell();
            shell.set("m", manager);
            shell.set("ds", dbInjector.getInstance(DataSourceProvider.class));
            shell.set("schk", dbInjector.getInstance(SchemaVersionCheck.class));
            shell.set("d", this);
            shell.run();
        } else {
            RuntimeShutdown.waitFor();
        }
        return 0;
    } catch (Throwable err) {
        log.error("Unable to start daemon", err);
        return 1;
    }
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(createIndexModule());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(headless));
            if (test) {
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(createIndexModule());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(headless, slave));
            if (test) {
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(false));
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(false, false));
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = refControl.getProjectControl().controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = refControl.getProjectControl().getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, change, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (hashtags != null && hashtags.size() > 0) {
        try {
            HashtagsInput input = new HashtagsInput();
            input.add = hashtags;
            hashtagsUtil.setHashtags(ctl, input, false, false);
        } catch (ValidationException | AuthException e) {
            log.error("Cannot add hashtags to change " + change.getId(), e);
        }
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    if (!messageIsForChange()) {
        commitMessageNotForChange();
    }
    if (sendMail) {
        try {
            CreateChangeSender cm = createChangeSenderFactory.create(change);
            cm.setFrom(change.getOwner());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.addReviewers(reviewers);
            cm.addExtraCC(extraCC);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new change " + change.getId(), err);
        }
    }
    f.checkedGet();
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
        if (hashtags != null && hashtags.size() > 0) {
            hooks.doHashtagsChangedHook(change, accountCache.get(change.getOwner()).getAccount(), hashtags, null, hashtags, db);
        }
    }
    return change;
}
#method_after
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = refControl.getProjectControl().controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = refControl.getProjectControl().getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (hashtags != null && hashtags.size() > 0) {
        try {
            HashtagsInput input = new HashtagsInput();
            input.add = hashtags;
            hashtagsUtil.setHashtags(ctl, input, false, false);
        } catch (ValidationException | AuthException e) {
            log.error("Cannot add hashtags to change " + change.getId(), e);
        }
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    if (!messageIsForChange()) {
        commitMessageNotForChange();
    }
    if (sendMail) {
        try {
            CreateChangeSender cm = createChangeSenderFactory.create(change);
            cm.setFrom(change.getOwner());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.addReviewers(reviewers);
            cm.addExtraCC(extraCC);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new change " + change.getId(), err);
        }
    }
    f.checkedGet();
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
        if (hashtags != null && hashtags.size() > 0) {
            hooks.doHashtagsChangedHook(change, accountCache.get(change.getOwner()).getAccount(), hashtags, null, hashtags, db);
        }
    }
    return change;
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            try {
                if (c.getType() == UPDATE) {
                    // otherwise known as a fast-forward
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                }
                if (isHead(c) || isConfig(c)) {
                    switch(c.getType()) {
                        case CREATE:
                        case UPDATE:
                        case UPDATE_NONFASTFORWARD:
                            autoCloseChanges(c);
                            break;
                        case DELETE:
                            break;
                    }
                }
                if (isConfig(c)) {
                    projectCache.evict(project);
                    ProjectState ps = projectCache.get(project.getNameKey());
                    // 
                    repoManager.setProjectDescription(// 
                    project.getNameKey(), ps.getProject().getDescription());
                }
                if (!MagicBranch.isMagicBranch(c.getRefName())) {
                    // We only fire gitRefUpdated for direct refs updates.
                    // Events for change refs are fired when they are created.
                    // 
                    gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
                }
            } catch (NoSuchChangeException e) {
                c.setResult(REJECTED_OTHER_REASON, "No such change: " + e.getMessage());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.maxBatchChanges;
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.maxBatchChanges;
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.destChanges.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
        Set<String> hashtags = magicBranch.getHashtags();
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, change, changeCtl, approvals);
        recipients.add(oldRecipients);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
        Set<String> hashtags = magicBranch.getHashtags();
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, changeCtl, approvals);
        recipients.add(oldRecipients);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    if (validCommits.contains(c)) {
        return true;
    }
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c);
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) {
    if (validCommits.contains(c)) {
        return true;
    }
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c);
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) throws NoSuchChangeException {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change.Id> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByKey(branch);
                }
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // Update superproject gitlinks if required.
        subOpFactory.create(branch, newTip, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>(), currentUser.getAccount()).update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByKey(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // Update superproject gitlinks if required.
        subOpFactory.create(branch, newTip, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>(), currentUser.getAccount()).update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private SetMultimap<ObjectId, Ref> changeRefsById() throws IOException {
    if (refsById == null) {
        refsById = HashMultimap.create();
        for (Ref r : refsByChange().values()) {
            refsById.put(r.getObjectId(), r);
        }
    }
    return refsById;
}
#method_after
private SetMultimap<ObjectId, Ref> changeRefsById() {
    if (refsById == null) {
        refsById = HashMultimap.create();
        for (Ref r : refsByChange().values()) {
            refsById.put(r.getObjectId(), r);
        }
    }
    return refsById;
}
#end_block

#method_before
private Map<Change.Key, Change.Id> openChangesByKey(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<>();
    for (Change c : db.changes().byBranchOpenAll(branch)) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#method_after
private Map<Change.Key, Change> openChangesByKey(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change> r = new HashMap<>();
    for (Change c : db.changes().byBranchOpenAll(branch)) {
        r.put(c.getKey(), c);
    }
    return r;
}
#end_block

#method_before
public List<List<ChangeInfo>> formatQueryResults(List<QueryResult> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    Iterable<ChangeData> all = FluentIterable.from(in).transformAndConcat(new Function<QueryResult, List<ChangeData>>() {

        @Override
        public List<ChangeData> apply(QueryResult in) {
            return in.changes();
        }
    });
    ChangeData.ensureChangeLoaded(all);
    if (has(ALL_REVISIONS)) {
        ChangeData.ensureAllPatchSetsLoaded(all);
    } else if (has(CURRENT_REVISION)) {
        ChangeData.ensureCurrentPatchSetLoaded(all);
    }
    Set<Change.Id> reviewed = Sets.newHashSet();
    if (has(REVIEWED)) {
        reviewed = loadReviewed(all);
    }
    ChangeData.ensureCurrentApprovalsLoaded(all);
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    Map<Change.Id, ChangeInfo> out = Maps.newHashMap();
    for (QueryResult r : in) {
        List<ChangeInfo> infos = toChangeInfo(out, r.changes(), reviewed);
        if (r.moreChanges()) {
            infos.get(infos.size() - 1)._moreChanges = true;
        }
        res.add(infos);
    }
    accountLoader.fill();
    return res;
}
#method_after
public List<List<ChangeInfo>> formatQueryResults(List<QueryResult> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    Iterable<ChangeData> all = FluentIterable.from(in).transformAndConcat(new Function<QueryResult, List<ChangeData>>() {

        @Override
        public List<ChangeData> apply(QueryResult in) {
            return in.changes();
        }
    });
    ChangeData.ensureChangeLoaded(all);
    if (has(ALL_REVISIONS)) {
        ChangeData.ensureAllPatchSetsLoaded(all);
    } else if (has(CURRENT_REVISION) || has(MESSAGES)) {
        ChangeData.ensureCurrentPatchSetLoaded(all);
    }
    Set<Change.Id> reviewed = Sets.newHashSet();
    if (has(REVIEWED)) {
        reviewed = loadReviewed(all);
    }
    ChangeData.ensureCurrentApprovalsLoaded(all);
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    Map<Change.Id, ChangeInfo> out = Maps.newHashMap();
    for (QueryResult r : in) {
        List<ChangeInfo> infos = toChangeInfo(out, r.changes(), reviewed);
        if (r.moreChanges()) {
            infos.get(infos.size() - 1)._moreChanges = true;
        }
        res.add(infos);
    }
    accountLoader.fill();
    return res;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    if (cd.getSubmitRecords() != null) {
        return cd.getSubmitRecords();
    }
    PatchSet ps = cd.currentPatchSet();
    if (ps == null) {
        return ImmutableList.of();
    }
    cd.setSubmitRecords(new SubmitRuleEvaluator(cd).setPatchSet(ps).setFastEvalLabels(true).setAllowDraft(true).evaluate());
    return cd.getSubmitRecords();
}
#method_after
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    if (cd.getSubmitRecords() != null) {
        return cd.getSubmitRecords();
    }
    cd.setSubmitRecords(new SubmitRuleEvaluator(cd).setFastEvalLabels(true).setAllowDraft(true).evaluate());
    return cd.getSubmitRecords();
}
#end_block

#method_before
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    atrScope.disableDb();
    assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(ListChangesOption.LABELS).withOption(ListChangesOption.DETAILED_ACCOUNTS).get()).hasSize(2);
}
#method_after
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    // Identified user may async get stars from DB.
    setApiUserAnonymous();
    atrScope.disableDb();
    assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(ListChangesOption.LABELS).withOption(ListChangesOption.DETAILED_ACCOUNTS).get()).hasSize(2);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> query(String name) throws QueryParseException {
    AllUsersName allUsers = args.allUsersName.get();
    try {
        Repository git = args.repoManager.openRepository(allUsers);
        try {
            VersionedAccountQueries q = VersionedAccountQueries.forUser(self());
            q.load(git);
            String query = q.getQueryList().getQuery(name);
            if (query != null) {
                return parse(query);
            }
        } finally {
            git.close();
        }
    } catch (RepositoryNotFoundException e) {
        throw new QueryParseException("Unknown named query (no " + allUsers.get() + " repo): " + name, e);
    } catch (IOException e) {
        throw new QueryParseException("Error parsing named query: " + name, e);
    } catch (ConfigInvalidException e) {
        throw new QueryParseException("Error parsing named query: " + name, e);
    }
    throw new QueryParseException("Unknown named query: " + name);
}
#method_after
@Operator
public Predicate<ChangeData> query(String name) throws QueryParseException {
    AllUsersName allUsers = args.allUsersName.get();
    try (Repository git = args.repoManager.openRepository(allUsers)) {
        VersionedAccountQueries q = VersionedAccountQueries.forUser(self());
        q.load(git);
        String query = q.getQueryList().getQuery(name);
        if (query != null) {
            return parse(query);
        }
    } catch (RepositoryNotFoundException e) {
        throw new QueryParseException("Unknown named query (no " + allUsers.get() + " repo): " + name, e);
    } catch (IOException | ConfigInvalidException e) {
        throw new QueryParseException("Error parsing named query: " + name, e);
    }
    throw new QueryParseException("Unknown named query: " + name);
}
#end_block

#method_before
@Test
public void testParseSimple() {
    try {
        QueryList ql = QueryList.parse(F_SIMPLE, null);
        assertTrue(Q_P.equals(ql.getQuery(N_FOO)));
        assertTrue(Q_B.equals(ql.getQuery(N_BAR)));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testParseSimple() throws Exception {
    QueryList ql = QueryList.parse(F_SIMPLE, null);
    assertThat(ql.getQuery(N_FOO)).isEqualTo(Q_P);
    assertThat(ql.getQuery(N_BAR)).isEqualTo(Q_B);
}
#end_block

#method_before
@Test
public void testParseWHeader() {
    try {
        QueryList ql = QueryList.parse(HEADER + F_SIMPLE, null);
        assertTrue(Q_P.equals(ql.getQuery(N_FOO)));
        assertTrue(Q_B.equals(ql.getQuery(N_BAR)));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testParseWHeader() throws Exception {
    QueryList ql = QueryList.parse(HEADER + F_SIMPLE, null);
    assertThat(ql.getQuery(N_FOO)).isEqualTo(Q_P);
    assertThat(ql.getQuery(N_BAR)).isEqualTo(Q_B);
}
#end_block

#method_before
@Test
public void testParseWComments() {
    try {
        QueryList ql = QueryList.parse(C1 + F_SIMPLE + C2, null);
        assertTrue(Q_P.equals(ql.getQuery(N_FOO)));
        assertTrue(Q_B.equals(ql.getQuery(N_BAR)));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testParseWComments() throws Exception {
    QueryList ql = QueryList.parse(C1 + F_SIMPLE + C2, null);
    assertThat(ql.getQuery(N_FOO)).isEqualTo(Q_P);
    assertThat(ql.getQuery(N_BAR)).isEqualTo(Q_B);
}
#end_block

#method_before
@Test
public void testParseFooComment() {
    try {
        QueryList ql = QueryList.parse("#" + L_FOO + L_BAR, null);
        assertTrue(null == ql.getQuery(N_FOO));
        assertTrue(Q_B.equals(ql.getQuery(N_BAR)));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testParseFooComment() throws Exception {
    QueryList ql = QueryList.parse("#" + L_FOO + L_BAR, null);
    assertThat(ql.getQuery(N_FOO)).isNull();
    assertThat(ql.getQuery(N_BAR)).isEqualTo(Q_B);
}
#end_block

#method_before
@Test
public void testParsePaddedFronts() {
    try {
        QueryList ql = QueryList.parse(F_PAD_F, null);
        assertTrue(Q_P.equals(ql.getQuery(N_FOO)));
        assertTrue(Q_B.equals(ql.getQuery(N_BAR)));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testParsePaddedFronts() throws Exception {
    QueryList ql = QueryList.parse(F_PAD_F, null);
    assertThat(ql.getQuery(N_FOO)).isEqualTo(Q_P);
    assertThat(ql.getQuery(N_BAR)).isEqualTo(Q_B);
}
#end_block

#method_before
@Test
public void testParsePaddedEnds() {
    try {
        QueryList ql = QueryList.parse(F_PAD_E, null);
        assertTrue(Q_P.equals(ql.getQuery(N_FOO)));
        assertTrue(Q_B.equals(ql.getQuery(N_BAR)));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testParsePaddedEnds() throws Exception {
    QueryList ql = QueryList.parse(F_PAD_E, null);
    assertThat(ql.getQuery(N_FOO)).isEqualTo(Q_P);
    assertThat(ql.getQuery(N_BAR)).isEqualTo(Q_B);
}
#end_block

#method_before
@Test
public void testParseComplex() {
    try {
        QueryList ql = QueryList.parse(L_COMPLEX, null);
        assertTrue(Q_COMPLEX.equals(ql.getQuery(N_FOO)));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testParseComplex() throws Exception {
    QueryList ql = QueryList.parse(L_COMPLEX, null);
    assertThat(ql.getQuery(N_FOO)).isEqualTo(Q_COMPLEX);
}
#end_block

#method_before
@Test
public void testParseBad() {
    try {
        QueryList ql = QueryList.parse(L_BAD, null);
        assertTrue(false);
    } catch (Exception e) {
        assertTrue(true);
    }
}
#method_after
@Test(expected = IOException.class)
public void testParseBad() throws Exception {
    ValidationError.Sink sink = createNiceMock(ValidationError.Sink.class);
    replay(sink);
    QueryList.parse(L_BAD, sink);
}
#end_block

#method_before
@Test
public void testAsText() {
    String text = HEADER + "#\n" + F_PROPER;
    try {
        QueryList ql = QueryList.parse(F_SIMPLE, null);
        String asText = ql.asText();
        assertTrue(text.equals(asText));
        ql = QueryList.parse(asText, null);
        asText = ql.asText();
        assertTrue(text.equals(asText));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testAsText() throws Exception {
    String expectedText = HEADER + "#\n" + F_PROPER;
    QueryList ql = QueryList.parse(F_SIMPLE, null);
    String asText = ql.asText();
    assertThat(asText).isEqualTo(expectedText);
    ql = QueryList.parse(asText, null);
    asText = ql.asText();
    assertThat(asText).isEqualTo(expectedText);
}
#end_block

#method_before
void set(ChangeInfo info) {
    canEdit = info.has_actions() && info.actions().containsKey("hashtags") && info.actions().get("hashtags").enabled();
    this.changeId = info.legacy_id();
    display(info);
    openForm.setVisible(canEdit);
}
#method_after
void set(ChangeInfo info) {
    canEdit = info.has_actions() && info.actions().containsKey("hashtags");
    this.changeId = info.legacy_id();
    display(info);
    openForm.setVisible(canEdit);
}
#end_block

#method_before
@Override
public int run() throws Exception {
    if (doInit) {
        try {
            new Init(getSitePath()).run();
        } catch (Exception e) {
            throw die("Init failed", e);
        }
    }
    mustHaveValidSite();
    Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void uncaughtException(Thread t, Throwable e) {
            log.error("Thread " + t.getName() + " threw exception", e);
        }
    });
    if (runId != null) {
        runFile = getSitePath().resolve("logs").resolve("gerrit.run");
    }
    if (httpd == null) {
        httpd = !slave;
    }
    if (!httpd && !sshd) {
        throw die("No services enabled, nothing to do");
    }
    setupInjectors();
    if (!consoleLog) {
        manager.add(ErrorLogFile.start(getSitePath(), cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class))));
    }
    try {
        start();
        RuntimeShutdown.add(new Runnable() {

            @Override
            public void run() {
                log.info("caught shutdown, cleaning up");
                if (runId != null) {
                    try {
                        Files.delete(runFile);
                    } catch (IOException err) {
                        log.warn("failed to delete " + runFile, err);
                    }
                }
                manager.stop();
            }
        });
        log.info("Gerrit Code Review " + myVersion() + " ready");
        if (runId != null) {
            try {
                Files.write(runFile, (runId + "\n").getBytes(UTF_8));
                runFile.toFile().setReadable(true, false);
            } catch (IOException err) {
                log.warn("Cannot write --run-id to " + runFile, err);
            }
        }
        if (serverStarted != null) {
            serverStarted.run();
        }
        if (inspector) {
            JythonShell shell = new JythonShell();
            shell.set("m", manager);
            shell.set("ds", dbInjector.getInstance(DataSourceProvider.class));
            shell.set("schk", dbInjector.getInstance(SchemaVersionCheck.class));
            shell.set("d", this);
            shell.run();
        } else {
            RuntimeShutdown.waitFor();
        }
        return 0;
    } catch (Throwable err) {
        log.error("Unable to start daemon", err);
        return 1;
    }
}
#method_after
@Override
public int run() throws Exception {
    if (doInit) {
        try {
            new Init(getSitePath()).run();
        } catch (Exception e) {
            throw die("Init failed", e);
        }
    }
    mustHaveValidSite();
    Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void uncaughtException(Thread t, Throwable e) {
            log.error("Thread " + t.getName() + " threw exception", e);
        }
    });
    if (runId != null) {
        runFile = getSitePath().resolve("logs").resolve("gerrit.run");
    }
    if (httpd == null) {
        httpd = !slave;
    }
    if (!httpd && !sshd) {
        throw die("No services enabled, nothing to do");
    }
    try {
        start();
        RuntimeShutdown.add(new Runnable() {

            @Override
            public void run() {
                log.info("caught shutdown, cleaning up");
                if (runId != null) {
                    try {
                        Files.delete(runFile);
                    } catch (IOException err) {
                        log.warn("failed to delete " + runFile, err);
                    }
                }
                manager.stop();
            }
        });
        log.info("Gerrit Code Review " + myVersion() + " ready");
        if (runId != null) {
            try {
                Files.write(runFile, (runId + "\n").getBytes(UTF_8));
                runFile.toFile().setReadable(true, false);
            } catch (IOException err) {
                log.warn("Cannot write --run-id to " + runFile, err);
            }
        }
        if (serverStarted != null) {
            serverStarted.run();
        }
        if (inspector) {
            JythonShell shell = new JythonShell();
            shell.set("m", manager);
            shell.set("ds", dbInjector.getInstance(DataSourceProvider.class));
            shell.set("schk", dbInjector.getInstance(SchemaVersionCheck.class));
            shell.set("d", this);
            shell.run();
        } else {
            RuntimeShutdown.waitFor();
        }
        return 0;
    } catch (Throwable err) {
        log.error("Unable to start daemon", err);
        return 1;
    }
}
#end_block

#method_before
@VisibleForTesting
public void start() {
    sshd &= !sshdOff();
    if (sshd) {
        initSshd();
    }
    if (MoreObjects.firstNonNull(httpd, true)) {
        initHttpd();
    }
    manager.start();
}
#method_after
@VisibleForTesting
public void start() throws IOException {
    if (dbInjector == null) {
        dbInjector = createDbInjector(MULTI_USER);
    }
    cfgInjector = createCfgInjector();
    sysInjector = createSysInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setDbCfgInjector(dbInjector, cfgInjector);
    manager.add(dbInjector, cfgInjector, sysInjector);
    if (!consoleLog) {
        manager.add(ErrorLogFile.start(getSitePath(), cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class))));
    }
    sshd &= !sshdOff();
    if (sshd) {
        initSshd();
    }
    if (MoreObjects.firstNonNull(httpd, true)) {
        initHttpd();
    }
    manager.start();
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(createIndexModule());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(headless, slave));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new ChangeCacheImplModule(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(createIndexModule());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(headless, slave));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public void onProjectDeleted(Event event) {
    Project.NameKey p = new NameKey(event.getProjectName());
    repoSizeCache.remove(p);
    pushCounts.remove(p);
    fetchCounts.remove(p);
}
#method_after
@Override
public void onProjectDeleted(Event event) {
    repoSizeCache.evict(new Project.NameKey(event.getProjectName()));
}
#end_block

#method_before
@Test
public void testName() throws Exception {
    RepoSizeCache repoSizeCache = createMock(RepoSizeCache.class);
    Project.NameKey p = new Project.NameKey(MY_PROJECT);
    repoSizeCache.remove(p);
    PersistentCounter fetchCounts = createMock(PersistentCounter.class);
    fetchCounts.remove(p);
    PersistentCounter pushCounts = createMock(PersistentCounter.class);
    pushCounts.remove(p);
    DeletionListener classUnderTest = new DeletionListener(repoSizeCache, fetchCounts, pushCounts);
    replay(repoSizeCache, fetchCounts, pushCounts);
    ProjectDeletedListener.Event event = new ProjectDeletedListener.Event() {

        @Override
        public String getProjectName() {
            return MY_PROJECT;
        }
    };
    classUnderTest.onProjectDeleted(event);
    verify(repoSizeCache, fetchCounts, pushCounts);
}
#method_after
@Test
public void testName() throws Exception {
    RepoSizeCache repoSizeCache = createMock(RepoSizeCache.class);
    Project.NameKey p = new Project.NameKey(MY_PROJECT);
    repoSizeCache.evict(p);
    DeletionListener classUnderTest = new DeletionListener(repoSizeCache);
    replay(repoSizeCache);
    ProjectDeletedListener.Event event = new ProjectDeletedListener.Event() {

        @Override
        public String getProjectName() {
            return MY_PROJECT;
        }
    };
    classUnderTest.onProjectDeleted(event);
    verify(repoSizeCache);
}
#end_block

#method_before
@Override
protected void configure() {
    DynamicSet.bind(binder(), ProjectCreationValidationListener.class).to(MaxRepositoriesQuotaValidator.class);
    DynamicSet.bind(binder(), ReceivePackInitializer.class).to(MaxRepositorySizeQuota.class);
    DynamicSet.bind(binder(), PostReceiveHook.class).to(MaxRepositorySizeQuota.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(DeletionListener.class);
    DynamicSet.bind(binder(), PostReceiveHook.class).to(FetchAndPushListener.class);
    DynamicSet.bind(binder(), PreUploadHook.class).to(FetchAndPushListener.class);
    DynamicSet.setOf(binder(), UsageDataEventCreator.class);
    install(MaxRepositorySizeQuota.module());
    install(PersistentCounter.module());
    install(new RestApiModule() {

        @Override
        protected void configure() {
            get(PROJECT_KIND, "quota").to(GetQuota.class);
        }
    });
    bind(Publisher.class).in(Scopes.SINGLETON);
    bind(PublisherScheduler.class).in(Scopes.SINGLETON);
    bind(ProjectNameResolver.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(PublisherScheduler.class);
}
#method_after
@Override
protected void configure() {
    DynamicSet.bind(binder(), ProjectCreationValidationListener.class).to(MaxRepositoriesQuotaValidator.class);
    DynamicSet.bind(binder(), ReceivePackInitializer.class).to(MaxRepositorySizeQuota.class);
    DynamicSet.bind(binder(), PostReceiveHook.class).to(MaxRepositorySizeQuota.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(DeletionListener.class);
    DynamicSet.setOf(binder(), UsageDataEventCreator.class);
    install(MaxRepositorySizeQuota.module());
    install(new RestApiModule() {

        @Override
        protected void configure() {
            get(PROJECT_KIND, "quota").to(GetQuota.class);
        }
    });
    bind(Publisher.class).in(Scopes.SINGLETON);
    bind(PublisherScheduler.class).in(Scopes.SINGLETON);
    bind(ProjectNameResolver.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(PublisherScheduler.class);
}
#end_block

#method_before
private AccountSshKey readSshKey(Account.Id id) throws IOException {
    String defaultPublicSshKeyFile = System.getProperty("user.home") + File.separator + ".ssh" + File.separator + "id_rsa.pub";
    if (!Files.exists(Paths.get(defaultPublicSshKeyFile))) {
        defaultPublicSshKeyFile = "";
    }
    String publicSshKeyFile = ui.readString(defaultPublicSshKeyFile, "public SSH key file");
    return !Strings.isNullOrEmpty(publicSshKeyFile) ? createSshKey(id, publicSshKeyFile) : null;
}
#method_after
private AccountSshKey readSshKey(Account.Id id) throws IOException {
    String defaultPublicSshKeyFile = "";
    Path defaultPublicSshKeyPath = Paths.get(System.getProperty("user.home"), ".ssh", "id_rsa.pub");
    if (Files.exists(defaultPublicSshKeyPath)) {
        defaultPublicSshKeyFile = defaultPublicSshKeyPath.toString();
    }
    String publicSshKeyFile = ui.readString(defaultPublicSshKeyFile, "public SSH key file");
    return !Strings.isNullOrEmpty(publicSshKeyFile) ? createSshKey(id, publicSshKeyFile) : null;
}
#end_block

#method_before
public final Runnable wrap(final Runnable runnable) {
    final Callable<Object> wrapped = wrap(Executors.callable(runnable));
    if (runnable instanceof ProjectRunnable) {
        return new ProjectRunnable() {

            @Override
            public void run() {
                try {
                    wrapped.call();
                } catch (RuntimeException e) {
                    throw e;
                } catch (Exception e) {
                    // Not possible.
                    throw new RuntimeException(e);
                }
            }

            @Override
            public NameKey getProjectNameKey() {
                return ((ProjectRunnable) runnable).getProjectNameKey();
            }

            @Override
            public String getRemoteName() {
                return ((ProjectRunnable) runnable).getRemoteName();
            }

            @Override
            public boolean hasCustomizedPrint() {
                return ((ProjectRunnable) runnable).hasCustomizedPrint();
            }

            @Override
            public String toString() {
                return runnable.toString();
            }
        };
    } else {
        return new Runnable() {

            @Override
            public void run() {
                try {
                    wrapped.call();
                } catch (RuntimeException e) {
                    throw e;
                } catch (Exception e) {
                    // Not possible.
                    throw new RuntimeException(e);
                }
            }

            @Override
            public String toString() {
                return runnable.toString();
            }
        };
    }
}
#method_after
public final <T> Callable<T> wrap(final Callable<T> callable) {
    final Callable<T> wrapped = wrapImpl(new Callable<T>() {

        @Override
        public T call() throws Exception {
            RequestCleanup cleanup = scope.scope(Key.get(RequestCleanup.class), new Provider<RequestCleanup>() {

                @Override
                public RequestCleanup get() {
                    return new RequestCleanup();
                }
            }).get();
            try {
                return callable.call();
            } finally {
                cleanup.run();
            }
        }
    });
    return new Callable<T>() {

        @Override
        public T call() throws Exception {
            return wrapped.call();
        }

        @Override
        public String toString() {
            return callable.toString();
        }
    };
}
#end_block

#method_before
@Override
public Context get() {
    return getContext();
}
#method_after
@Override
public Context get() {
    return requireContext();
}
#end_block

#method_before
@Override
public SshSession get() {
    return getContext().getSession();
}
#method_after
@Override
public SshSession get() {
    return requireContext().getSession();
}
#end_block

#method_before
private static Term intTerm(String name, int value) {
    BytesRef bytes = new BytesRef(NumericUtils.BUF_SIZE_INT);
    BytesRefBuilder builder = new BytesRefBuilder();
    builder.append(bytes);
    NumericUtils.intToPrefixCodedBytes(value, 0, builder);
    return new Term(name, bytes);
}
#method_after
private static Term intTerm(String name, int value) {
    BytesRefBuilder builder = new BytesRefBuilder();
    NumericUtils.intToPrefixCodedBytes(value, 0, builder);
    return new Term(name, builder.get());
}
#end_block

#method_before
private void testGetGroup(String url, AccountGroup expectedGroup) throws IOException {
    RestResponse r = session.get(url);
    GroupInfo group = newGson().fromJson(r.getReader(), new TypeToken<GroupInfo>() {
    }.getType());
    assertGroupInfo(expectedGroup, group);
}
#method_after
private void testGetGroup(String url, AccountGroup expectedGroup) throws IOException {
    RestResponse r = session.get(url);
    GroupInfo group = newGson().fromJson(r.getReader(), GroupInfo.class);
    assertGroupInfo(expectedGroup, group);
}
#end_block

#method_before
@Test
public void messagesNotReturnedByDefault() throws GitAPIException, IOException {
    String changeId = createChange();
    postMessage(changeId, "Some nits need to be fixed.");
    com.google.gerrit.server.change.ChangeJson.ChangeInfo c = getChange(changeId);
    assertNull(c.messages);
}
#method_after
@Test
public void messagesNotReturnedByDefault() throws GitAPIException, IOException {
    String changeId = createChange();
    postMessage(changeId, "Some nits need to be fixed.");
    ChangeInfo c = getChange(changeId);
    assertNull(c.messages);
}
#end_block

#method_before
@Test
public void defaultMessage() throws GitAPIException, IOException {
    String changeId = createChange();
    com.google.gerrit.server.change.ChangeJson.ChangeInfo c = getChangeWithMessages(changeId);
    assertNotNull(c.messages);
    assertEquals(1, c.messages.size());
    assertEquals("Uploaded patch set 1.", c.messages.iterator().next().message);
}
#method_after
@Test
public void defaultMessage() throws GitAPIException, IOException {
    String changeId = createChange();
    ChangeInfo c = getChangeWithMessages(changeId);
    assertNotNull(c.messages);
    assertEquals(1, c.messages.size());
    assertEquals("Uploaded patch set 1.", c.messages.iterator().next().message);
}
#end_block

#method_before
@Test
public void messagesReturnedInChronologicalOrder() throws GitAPIException, IOException {
    String changeId = createChange();
    String firstMessage = "Some nits need to be fixed.";
    postMessage(changeId, firstMessage);
    String secondMessage = "I like this feature.";
    postMessage(changeId, secondMessage);
    com.google.gerrit.server.change.ChangeJson.ChangeInfo c = getChangeWithMessages(changeId);
    assertNotNull(c.messages);
    assertEquals(3, c.messages.size());
    Iterator<ChangeJson.ChangeMessageInfo> it = c.messages.iterator();
    assertEquals("Uploaded patch set 1.", it.next().message);
    assertMessage(firstMessage, it.next().message);
    assertMessage(secondMessage, it.next().message);
}
#method_after
@Test
public void messagesReturnedInChronologicalOrder() throws GitAPIException, IOException {
    String changeId = createChange();
    String firstMessage = "Some nits need to be fixed.";
    postMessage(changeId, firstMessage);
    String secondMessage = "I like this feature.";
    postMessage(changeId, secondMessage);
    ChangeInfo c = getChangeWithMessages(changeId);
    assertNotNull(c.messages);
    assertEquals(3, c.messages.size());
    Iterator<ChangeMessageInfo> it = c.messages.iterator();
    assertEquals("Uploaded patch set 1.", it.next().message);
    assertMessage(firstMessage, it.next().message);
    assertMessage(secondMessage, it.next().message);
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, cd, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if ((has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) && userProvider.get().isIdentifiedUser()) {
        actionJsonProvider.get().addChangeActions(out, cd);
        // todo: why do we need to treat followup specially here?
        if (userProvider.get().isIdentifiedUser() && in.getStatus().isOpen()) {
            UiAction.Description descr = new UiAction.Description();
            PrivateInternals_UiActionDescription.setId(descr, "followup");
            PrivateInternals_UiActionDescription.setMethod(descr, "POST");
            descr.setTitle("Create follow-up change");
            out.actions.put(descr.getId(), new ActionInfo(descr));
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, cd, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in, cd.change().getProject(), has(WEB_LINKS));
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJsonProvider.get().addRevisionActions(out, new RevisionResource(new ChangeResource(ctl), in));
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = plcUtil.draftByPatchSetAuthor(db.get(), in.getId(), user.getAccountId(), ctl.getNotes()).iterator().hasNext() ? true : null;
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in, cd.change().getProject(), has(WEB_LINKS));
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(new ChangeResource(ctl), in));
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = plcUtil.draftByPatchSetAuthor(db.get(), in.getId(), user.getAccountId(), ctl.getNotes()).iterator().hasNext() ? true : null;
    }
    return out;
}
#end_block

#method_before
public ChangeInfo addChangeActions(ChangeInfo to, ChangeData cd) throws OrmException {
    to.actions = toActionMap(cd);
    return to;
}
#method_after
public ChangeInfo addChangeActions(ChangeInfo to, ChangeControl ctl) {
    to.actions = toActionMap(ctl);
    return to;
}
#end_block

#method_before
private Map<String, ActionInfo> toActionMap(RevisionResource rsrc) {
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    if (userProvider.get().isIdentifiedUser()) {
        for (UiAction.Description d : UiActions.from(revisions, rsrc, userProvider)) {
            out.put(d.getId(), new ActionInfo(d));
        }
    }
    return out;
}
#method_after
private Map<String, ActionInfo> toActionMap(ChangeControl ctl) {
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    if (!ctl.getCurrentUser().isIdentifiedUser()) {
        return out;
    }
    Provider<CurrentUser> userProvider = Providers.of(ctl.getCurrentUser());
    for (UiAction.Description d : UiActions.from(changeViews, new ChangeResource(ctl), userProvider)) {
        out.put(d.getId(), new ActionInfo(d));
    }
    // TODO(sbeller): why do we need to treat followup specially here?
    if (ctl.getChange().getStatus().isOpen()) {
        UiAction.Description descr = new UiAction.Description();
        PrivateInternals_UiActionDescription.setId(descr, "followup");
        PrivateInternals_UiActionDescription.setMethod(descr, "POST");
        descr.setTitle("Create follow-up change");
        out.put(descr.getId(), new ActionInfo(descr));
    }
    return out;
}
#end_block

#method_before
private Map<String, ActionInfo> toActionMap(RevisionResource rsrc) {
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    if (userProvider.get().isIdentifiedUser()) {
        for (UiAction.Description d : UiActions.from(revisions, rsrc, userProvider)) {
            out.put(d.getId(), new ActionInfo(d));
        }
    }
    return out;
}
#method_after
private Map<String, ActionInfo> toActionMap(RevisionResource rsrc) {
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    if (rsrc.getControl().getCurrentUser().isIdentifiedUser()) {
        Provider<CurrentUser> userProvider = Providers.of(rsrc.getControl().getCurrentUser());
        for (UiAction.Description d : UiActions.from(revisions, rsrc, userProvider)) {
            out.put(d.getId(), new ActionInfo(d));
        }
    }
    return out;
}
#end_block

#method_before
@Override
protected String getRefName() {
    return ChangeNoteUtil.changeRefName(change.getId());
}
#method_after
@Override
protected String getRefName() {
    return ChangeNoteUtil.changeRefName(getChangeId());
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Parser parser = new Parser(change, rev, walk, repoManager);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessages = parser.buildMessages();
        commentsForBase = ImmutableListMultimap.copyOf(parser.commentsForBase);
        commentsForPS = ImmutableListMultimap.copyOf(parser.commentsForPs);
        noteMap = parser.commentNoteMap;
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } catch (ParseException e1) {
        // TODO(yyonas): figure out how to handle this exception
        throw new IOException(e1);
    } finally {
        walk.release();
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Change change = getChange();
        Parser parser = new Parser(change, rev, walk, repoManager);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessages = parser.buildMessages();
        commentsForBase = ImmutableListMultimap.copyOf(parser.commentsForBase);
        commentsForPS = ImmutableListMultimap.copyOf(parser.commentsForPs);
        noteMap = parser.commentNoteMap;
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } catch (ParseException e1) {
        // TODO(yyonas): figure out how to handle this exception
        throw new IOException(e1);
    } finally {
        walk.release();
    }
}
#end_block

#method_before
public static NoteMap parseCommentsFromNotes(Repository repo, String refName, RevWalk walk, Change.Id changeId, Multimap<PatchSet.Id, PatchLineComment> commentsForBase, Multimap<PatchSet.Id, PatchLineComment> commentsForPs) throws IOException, ConfigInvalidException {
    Ref ref = repo.getRef(refName);
    NoteMap noteMap = null;
    Iterator<Note> notes = null;
    if (ref != null) {
        RevCommit commit = walk.parseCommit(ref.getObjectId());
        noteMap = NoteMap.read(walk.getObjectReader(), commit);
        notes = noteMap.iterator();
    } else {
        return null;
    }
    while (notes.hasNext()) {
        Note next = notes.next();
        byte[] bytes = walk.getObjectReader().open(next.getData(), Constants.OBJ_BLOB).getBytes();
        List<PatchLineComment> result = parseNote(bytes, changeId);
        if ((result == null) || (result.isEmpty())) {
            continue;
        }
        PatchSet.Id psId = result.get(0).getKey().getParentKey().getParentKey();
        short side = result.get(0).getSide();
        if (side == 0) {
            commentsForBase.putAll(psId, result);
        } else {
            commentsForPs.putAll(psId, result);
        }
    }
    return noteMap;
}
#method_after
public static NoteMap parseCommentsFromNotes(Repository repo, String refName, RevWalk walk, Change.Id changeId, Multimap<PatchSet.Id, PatchLineComment> commentsForBase, Multimap<PatchSet.Id, PatchLineComment> commentsForPs) throws IOException, ConfigInvalidException {
    Ref ref = repo.getRef(refName);
    if (ref == null) {
        return null;
    }
    RevCommit commit = walk.parseCommit(ref.getObjectId());
    NoteMap noteMap = NoteMap.read(walk.getObjectReader(), commit);
    for (Note note : noteMap) {
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        List<PatchLineComment> result = parseNote(bytes, changeId);
        if ((result == null) || (result.isEmpty())) {
            continue;
        }
        PatchSet.Id psId = result.get(0).getKey().getParentKey().getParentKey();
        short side = result.get(0).getSide();
        if (side == 0) {
            commentsForBase.putAll(psId, result);
        } else {
            commentsForPs.putAll(psId, result);
        }
    }
    return noteMap;
}
#end_block

#method_before
void print(PrintWriter out) {
    seen.clear();
    collisions.clear();
    for (RelationModel r : rels) {
        for (ColumnModel c : r.getColumns()) {
            if (c.isNested()) {
                String type = getShortClassName(c);
                if (seen.contains(type)) {
                    collisions.add(type);
                } else {
                    seen.add(type);
                }
            }
        }
    }
    seen.clear();
    for (RelationModel r : rels) {
        generateMessage(r.getPrimaryKey().getField(), out, true);
    }
    for (RelationModel r : rels) {
        generateMessage(r, out);
    }
    out.print("message Any" + schemaName + "PrimaryKey {\n");
    for (RelationModel r : sortRelations(rels)) {
        ColumnModel pk = r.getPrimaryKey().getField();
        out.print("\toptional " + getType(pk) + " " + r.getRelationName().toLowerCase() + " = " + r.getRelationID() + ";\n");
    }
    out.print("}\n");
    out.print("message Any" + schemaName + " {\n");
    for (RelationModel r : sortRelations(rels)) {
        out.print("\toptional " + getMessageName(r) + " " + r.getRelationName().toLowerCase() + " = " + r.getRelationID() + ";\n");
    }
    out.print("}\n");
}
#method_after
void print(PrintWriter out) {
    seen.clear();
    collisions.clear();
    for (RelationModel r : rels) {
        for (ColumnModel c : r.getColumns()) {
            if (c.isNested()) {
                String type = getShortClassName(c);
                if (seen.contains(type)) {
                    collisions.add(type);
                } else {
                    seen.add(type);
                }
            }
        }
    }
    seen.clear();
    for (RelationModel r : rels) {
        generateMessage(r.getPrimaryKey().getField(), out, true);
    }
    for (RelationModel r : rels) {
        generateMessage(r, out);
    }
    out.print("message Any" + schemaName + "PrimaryKey {\n");
    for (RelationModel r : sortRelations(rels)) {
        ColumnModel pk = r.getPrimaryKey().getField();
        out.print("\toptional " + getType(pk) + " " + r.getRelationName().toLowerCase() + " = " + r.getRelationID() + ";\n");
    }
    out.print("}\n");
    out.print("\n");
    out.print("message Any" + schemaName + " {\n");
    for (RelationModel r : sortRelations(rels)) {
        out.print("\toptional " + getMessageName(r) + " " + r.getRelationName().toLowerCase() + " = " + r.getRelationID() + ";\n");
    }
    out.print("}\n");
}
#end_block

#method_before
@Override
public Response<DiffInfo> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException, AuthException, InvalidChangeOperationException, IOException {
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
    }
    AccountDiffPreference prefs = new AccountDiffPreference(new Account.Id(0));
    prefs.setIgnoreWhitespace(ignoreWhitespace.whitespace);
    prefs.setContext(context);
    prefs.setIntralineDifference(intraline);
    try {
        PatchScriptFactory psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet != null ? basePatchSet.getId() : null, resource.getPatchKey().getParentKey(), prefs);
        psf.setLoadHistory(false);
        psf.setLoadComments(context != AccountDiffPreference.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %s; want %s", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %s; want %s", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        DiffInfo result = new DiffInfo();
        result.commitIdA = content.commitIdA;
        result.commitIdB = content.commitIdB;
        // TODO referring to the parent commit by refs/changes/12/60012/1^1
        // will likely not work for inline edits
        String revA = basePatchSet != null ? basePatchSet.getRefName() : resource.getRevision().getPatchSet().getRefName() + "^1";
        String revB = resource.getRevision().getEdit().isPresent() ? resource.getRevision().getEdit().get().getRefName() : resource.getRevision().getPatchSet().getRefName();
        FluentIterable<DiffWebLinkInfo> links = webLinks.getDiffLinks(state.getProject().getName(), resource.getPatchKey().getParentKey().getParentKey().get(), basePatchSet != null ? basePatchSet.getId().get() : null, revA, MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName()), resource.getPatchKey().getParentKey().get(), revB, ps.getNewName());
        result.webLinks = links.isEmpty() ? null : links.toList();
        if (!webLinksOnly) {
            if (ps.isBinary()) {
                result.binary = true;
            }
            if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
                result.metaA = new FileMeta();
                result.metaA.name = MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName());
                result.metaA.contentType = FileContentUtil.resolveContentType(state, result.metaA.name, ps.getFileModeA(), ps.getMimeTypeA());
                result.metaA.lines = ps.getA().size();
                result.metaA.webLinks = getFileWebLinks(state.getProject(), revA, result.metaA.name);
            }
            if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
                result.metaB = new FileMeta();
                result.metaB.name = ps.getNewName();
                result.metaB.contentType = FileContentUtil.resolveContentType(state, result.metaB.name, ps.getFileModeB(), ps.getMimeTypeB());
                result.metaB.lines = ps.getB().size();
                result.metaB.webLinks = getFileWebLinks(state.getProject(), revB, result.metaB.name);
            }
            if (intraline) {
                if (ps.hasIntralineTimeout()) {
                    result.intralineStatus = IntraLineStatus.TIMEOUT;
                } else if (ps.hasIntralineFailure()) {
                    result.intralineStatus = IntraLineStatus.FAILURE;
                } else {
                    result.intralineStatus = IntraLineStatus.OK;
                }
            }
            result.changeType = CHANGE_TYPE.get(ps.getChangeType());
            if (result.changeType == null) {
                throw new IllegalStateException("unknown change type: " + ps.getChangeType());
            }
            if (ps.getPatchHeader().size() > 0) {
                result.diffHeader = ps.getPatchHeader();
            }
            result.content = content.lines;
        }
        Response<DiffInfo> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
@Override
public Response<DiffInfo> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException, AuthException, InvalidChangeOperationException, IOException {
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
    }
    AccountDiffPreference prefs = new AccountDiffPreference(new Account.Id(0));
    prefs.setIgnoreWhitespace(ignoreWhitespace.whitespace);
    prefs.setContext(context);
    prefs.setIntralineDifference(intraline);
    try {
        PatchScriptFactory psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet != null ? basePatchSet.getId() : null, resource.getPatchKey().getParentKey(), prefs);
        psf.setLoadHistory(false);
        psf.setLoadComments(context != AccountDiffPreference.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %s; want %s", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %s; want %s", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        DiffInfo result = new DiffInfo();
        // TODO referring to the parent commit by refs/changes/12/60012/1^1
        // will likely not work for inline edits
        String revA = basePatchSet != null ? basePatchSet.getRefName() : resource.getRevision().getPatchSet().getRefName() + "^1";
        String revB = resource.getRevision().getEdit().isPresent() ? resource.getRevision().getEdit().get().getRefName() : resource.getRevision().getPatchSet().getRefName();
        FluentIterable<DiffWebLinkInfo> links = webLinks.getDiffLinks(state.getProject().getName(), resource.getPatchKey().getParentKey().getParentKey().get(), basePatchSet != null ? basePatchSet.getId().get() : null, revA, MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName()), resource.getPatchKey().getParentKey().get(), revB, ps.getNewName());
        result.webLinks = links.isEmpty() ? null : links.toList();
        if (!webLinksOnly) {
            if (ps.isBinary()) {
                result.binary = true;
            }
            if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
                result.metaA = new FileMeta();
                result.metaA.name = MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName());
                result.metaA.contentType = FileContentUtil.resolveContentType(state, result.metaA.name, ps.getFileModeA(), ps.getMimeTypeA());
                result.metaA.lines = ps.getA().size();
                result.metaA.webLinks = getFileWebLinks(state.getProject(), revA, result.metaA.name);
                result.metaA.commitId = content.commitIdA;
            }
            if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
                result.metaB = new FileMeta();
                result.metaB.name = ps.getNewName();
                result.metaB.contentType = FileContentUtil.resolveContentType(state, result.metaB.name, ps.getFileModeB(), ps.getMimeTypeB());
                result.metaB.lines = ps.getB().size();
                result.metaB.webLinks = getFileWebLinks(state.getProject(), revB, result.metaB.name);
                result.metaB.commitId = content.commitIdB;
            }
            if (intraline) {
                if (ps.hasIntralineTimeout()) {
                    result.intralineStatus = IntraLineStatus.TIMEOUT;
                } else if (ps.hasIntralineFailure()) {
                    result.intralineStatus = IntraLineStatus.FAILURE;
                } else {
                    result.intralineStatus = IntraLineStatus.OK;
                }
            }
            result.changeType = CHANGE_TYPE.get(ps.getChangeType());
            if (result.changeType == null) {
                throw new IllegalStateException("unknown change type: " + ps.getChangeType());
            }
            if (ps.getPatchHeader().size() > 0) {
                result.diffHeader = ps.getPatchHeader();
            }
            result.content = content.lines;
        }
        Response<DiffInfo> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
private PatchScript build(final PatchListEntry content, final CommentDetail comments, final List<Patch> history) throws IOException {
    boolean intralineDifferenceIsPossible = true;
    boolean intralineFailure = false;
    boolean intralineTimeout = false;
    a.path = oldName(content);
    b.path = newName(content);
    a.resolve(null, aId);
    b.resolve(a, bId);
    edits = new ArrayList<>(content.getEdits());
    if (!isModify(content)) {
        intralineDifferenceIsPossible = false;
    } else if (diffPrefs.isIntralineDifference()) {
        IntraLineDiff d = patchListCache.getIntraLineDiff(new IntraLineDiffKey(a.id, a.src, b.id, b.src, edits, projectKey, bId, b.path, diffPrefs.getIgnoreWhitespace() != Whitespace.IGNORE_NONE));
        if (d != null) {
            switch(d.getStatus()) {
                case EDIT_LIST:
                    edits = new ArrayList<>(d.getEdits());
                    break;
                case DISABLED:
                    intralineDifferenceIsPossible = false;
                    break;
                case ERROR:
                    intralineDifferenceIsPossible = false;
                    intralineFailure = true;
                    break;
                case TIMEOUT:
                    intralineDifferenceIsPossible = false;
                    intralineTimeout = true;
                    break;
            }
        } else {
            intralineDifferenceIsPossible = false;
            intralineFailure = true;
        }
    }
    if (comments != null) {
        ensureCommentsVisible(comments);
    }
    boolean hugeFile = false;
    if (a.mode == FileMode.GITLINK || b.mode == FileMode.GITLINK) {
    // Do nothing
    } else if (a.src == b.src && a.size() <= context && content.getEdits().isEmpty()) {
        // 
        for (int i = 0; i < a.size(); i++) {
            a.addLine(i);
        }
        edits = new ArrayList<>(1);
        edits.add(new Edit(a.size(), a.size()));
    } else {
        if (BIG_FILE < Math.max(a.size(), b.size())) {
            // IF the file is really large, we disable things to avoid choking
            // the browser client.
            // 
            hugeFile = true;
        }
        // In order to expand the skipped common lines or syntax highlight the
        // file properly we need to give the client the complete file contents.
        // So force our context temporarily to the complete file size.
        // 
        context = MAX_CONTEXT;
        packContent(diffPrefs.getIgnoreWhitespace() != Whitespace.IGNORE_NONE);
    }
    return new PatchScript(change.getKey(), content.getChangeType(), content.getOldName(), content.getNewName(), a.fileMode, b.fileMode, content.getHeaderLines(), diffPrefs, a.dst, b.dst, edits, a.displayMethod, b.displayMethod, a.mimeType.toString(), b.mimeType.toString(), comments, history, hugeFile, intralineDifferenceIsPossible, intralineFailure, intralineTimeout, content.getPatchType() == Patch.PatchType.BINARY, aId.getName(), bId.getName());
}
#method_after
private PatchScript build(final PatchListEntry content, final CommentDetail comments, final List<Patch> history) throws IOException {
    boolean intralineDifferenceIsPossible = true;
    boolean intralineFailure = false;
    boolean intralineTimeout = false;
    a.path = oldName(content);
    b.path = newName(content);
    a.resolve(null, aId);
    b.resolve(a, bId);
    edits = new ArrayList<>(content.getEdits());
    if (!isModify(content)) {
        intralineDifferenceIsPossible = false;
    } else if (diffPrefs.isIntralineDifference()) {
        IntraLineDiff d = patchListCache.getIntraLineDiff(new IntraLineDiffKey(a.id, a.src, b.id, b.src, edits, projectKey, bId, b.path, diffPrefs.getIgnoreWhitespace() != Whitespace.IGNORE_NONE));
        if (d != null) {
            switch(d.getStatus()) {
                case EDIT_LIST:
                    edits = new ArrayList<>(d.getEdits());
                    break;
                case DISABLED:
                    intralineDifferenceIsPossible = false;
                    break;
                case ERROR:
                    intralineDifferenceIsPossible = false;
                    intralineFailure = true;
                    break;
                case TIMEOUT:
                    intralineDifferenceIsPossible = false;
                    intralineTimeout = true;
                    break;
            }
        } else {
            intralineDifferenceIsPossible = false;
            intralineFailure = true;
        }
    }
    if (comments != null) {
        ensureCommentsVisible(comments);
    }
    boolean hugeFile = false;
    if (a.mode == FileMode.GITLINK || b.mode == FileMode.GITLINK) {
    // Do nothing
    } else if (a.src == b.src && a.size() <= context && content.getEdits().isEmpty()) {
        // 
        for (int i = 0; i < a.size(); i++) {
            a.addLine(i);
        }
        edits = new ArrayList<>(1);
        edits.add(new Edit(a.size(), a.size()));
    } else {
        if (BIG_FILE < Math.max(a.size(), b.size())) {
            // IF the file is really large, we disable things to avoid choking
            // the browser client.
            // 
            hugeFile = true;
        }
        // In order to expand the skipped common lines or syntax highlight the
        // file properly we need to give the client the complete file contents.
        // So force our context temporarily to the complete file size.
        // 
        context = MAX_CONTEXT;
        packContent(diffPrefs.getIgnoreWhitespace() != Whitespace.IGNORE_NONE);
    }
    return new PatchScript(change.getKey(), content.getChangeType(), content.getOldName(), content.getNewName(), a.fileMode, b.fileMode, content.getHeaderLines(), diffPrefs, a.dst, b.dst, edits, a.displayMethod, b.displayMethod, a.mimeType.toString(), b.mimeType.toString(), comments, history, hugeFile, intralineDifferenceIsPossible, intralineFailure, intralineTimeout, content.getPatchType() == Patch.PatchType.BINARY, aId == null ? null : aId.getName(), bId == null ? null : bId.getName());
}
#end_block

#method_before
protected ClassLoader getClassLoader() {
    return getClass().getClassLoader();
}
#method_after
@Override
protected ClassLoader getClassLoader() {
    return getClass().getClassLoader();
}
#end_block

#method_before
@Test
public void commitFooters() throws Exception {
    LabelType verified = category("Verified", value(1, "Failed"), value(0, "No score"), value(-1, "Passes"));
    LabelType custom1 = category("Custom1", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    LabelType custom2 = category("Custom2", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    cfg.getLabelSections().put(custom1.getName(), verified);
    cfg.getLabelSections().put(custom2.getName(), verified);
    String heads = "refs/heads/*";
    AccountGroup.UUID anon = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel("Verified"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom1"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom2"), -1, 1, anon, heads);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r1 = createChange();
    r1.assertOkStatus();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new content", r1.getChangeId()).to("refs/for/master");
    r2.assertOkStatus();
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.label("Verified", 1);
    in.label("Custom1", -1);
    in.label("Custom2", 1);
    gApi.changes().id(r2.getChangeId()).current().review(in);
    EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
    ChangeInfo actual = gApi.changes().id(r2.getChangeId()).get(options);
    assertThat(actual.revisions).hasSize(2);
    // No footers except on latest patch set.
    assertThat(actual.revisions.get(r1.getCommit().getName()).commitWithFooters).isNull();
    String expected = SUBJECT + "\n" + "\n" + "Change-Id: " + r2.getChangeId() + "\n" + "Reviewed-on: http://localhost:0/" + r2.getChange().getId() + "\n" + "Reviewed-by: Administrator <admin@example.com>\n" + "Custom2: Administrator <admin@example.com>\n" + "Tested-by: Administrator <admin@example.com>\n";
    assertThat(actual.revisions.get(r2.getCommit().getName()).commitWithFooters).isEqualTo(expected);
}
#method_after
@Test
public void commitFooters() throws Exception {
    LabelType verified = category("Verified", value(1, "Failed"), value(0, "No score"), value(-1, "Passes"));
    LabelType custom1 = category("Custom1", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    LabelType custom2 = category("Custom2", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    cfg.getLabelSections().put(custom1.getName(), verified);
    cfg.getLabelSections().put(custom2.getName(), verified);
    String heads = "refs/heads/*";
    AccountGroup.UUID anon = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel("Verified"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom1"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom2"), -1, 1, anon, heads);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r1 = createChange();
    r1.assertOkStatus();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new content", r1.getChangeId()).to("refs/for/master");
    r2.assertOkStatus();
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.label("Verified", 1);
    in.label("Custom1", -1);
    in.label("Custom2", 1);
    gApi.changes().id(r2.getChangeId()).current().review(in);
    EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
    ChangeInfo actual = gApi.changes().id(r2.getChangeId()).get(options);
    assertThat(actual.revisions).hasSize(2);
    // No footers except on latest patch set.
    assertThat(actual.revisions.get(r1.getCommit().getName()).commitWithFooters).isNull();
    String expected = SUBJECT + "\n" + "\n" + "Change-Id: " + r2.getChangeId() + "\n" + "Reviewed-on: " + canonicalWebUrl.get() + r2.getChange().getId() + "\n" + "Reviewed-by: Administrator <admin@example.com>\n" + "Custom2: Administrator <admin@example.com>\n" + "Tested-by: Administrator <admin@example.com>\n";
    assertThat(actual.revisions.get(r2.getCommit().getName()).commitWithFooters).isEqualTo(expected);
}
#end_block

#method_before
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    try {
        accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
        Set<Change.Id> reviewed = Sets.newHashSet();
        if (has(REVIEWED)) {
            reviewed = loadReviewed(Collections.singleton(cd));
        }
        ChangeInfo res = toChangeInfo(cd, reviewed, limitToPsId);
        accountLoader.fill();
        return res;
    } catch (OrmException | RuntimeException e) {
        if (!has(CHECK)) {
            throw e;
        }
        return checkOnly(cd);
    }
}
#method_after
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    try {
        accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
        Set<Change.Id> reviewed = Sets.newHashSet();
        if (has(REVIEWED)) {
            reviewed = loadReviewed(Collections.singleton(cd));
        }
        ChangeInfo res = toChangeInfo(cd, reviewed, limitToPsId);
        accountLoader.fill();
        return res;
    } catch (PatchListNotAvailableException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.propagateIfPossible(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#end_block

#method_before
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes, Set<Change.Id> reviewed) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, reviewed, Optional.<PatchSet.Id>absent());
            } catch (OrmException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#method_after
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes, Set<Change.Id> reviewed) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, reviewed, Optional.<PatchSet.Id>absent());
            } catch (PatchListNotAvailableException | OrmException | IOException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeControl ctl, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    Map<String, RevisionInfo> res = Maps.newLinkedHashMap();
    for (PatchSet in : map.values()) {
        if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
            res.put(in.getRevision().get(), toRevisionInfo(ctl, in));
        }
    }
    return res;
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, Map<PatchSet.Id, PatchSet> map) throws PatchListNotAvailableException, OrmException, IOException {
    Map<String, RevisionInfo> res = Maps.newLinkedHashMap();
    for (PatchSet in : map.values()) {
        if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
            res.put(in.getRevision().get(), toRevisionInfo(ctl, in));
        }
    }
    return res;
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, PatchSet in) throws OrmException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS));
            }
            if (addFooters) {
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCherryPickCommitMessage(commit, ctl, in.getId());
            }
        } catch (IOException e) {
            throw new OrmException(e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(c, in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            throw new OrmException(e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(new ChangeResource(ctl, rebaseChange), in));
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = plcUtil.draftByPatchSetAuthor(db.get(), in.getId(), user.getAccountId(), ctl.getNotes()).iterator().hasNext() ? true : null;
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS));
            }
            if (addFooters) {
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCherryPickCommitMessage(commit, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(new ChangeResource(ctl, rebaseChange), in));
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = plcUtil.draftByPatchSetAuthor(db.get(), in.getId(), user.getAccountId(), ctl.getNotes()).iterator().hasNext() ? true : null;
    }
    return out;
}
#end_block

#method_before
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks) throws OrmException {
    Project.NameKey project = ctl.getChange().getProject();
    CommitInfo info = new CommitInfo();
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    if (addLinks) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links.toList();
    }
    try {
        for (RevCommit parent : commit.getParents()) {
            rw.parseBody(parent);
            CommitInfo i = new CommitInfo();
            i.commit = parent.name();
            i.subject = parent.getShortMessage();
            if (addLinks) {
                FluentIterable<WebLinkInfo> parentLinks = webLinks.getPatchSetLinks(project, parent.name());
                i.webLinks = parentLinks.isEmpty() ? null : parentLinks.toList();
            }
            info.parents.add(i);
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
    return info;
}
#method_after
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks) throws IOException {
    Project.NameKey project = ctl.getChange().getProject();
    CommitInfo info = new CommitInfo();
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links.toList();
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            FluentIterable<WebLinkInfo> parentLinks = webLinks.getPatchSetLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks.toList();
        }
        info.parents.add(i);
    }
    return info;
}
#end_block

#method_before
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    try {
        accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
        Set<Change.Id> reviewed = Sets.newHashSet();
        if (has(REVIEWED)) {
            reviewed = loadReviewed(Collections.singleton(cd));
        }
        ChangeInfo res = toChangeInfo(cd, reviewed, limitToPsId);
        accountLoader.fill();
        return res;
    } catch (OrmException | RuntimeException e) {
        if (!has(CHECK)) {
            throw e;
        }
        return checkOnly(cd);
    }
}
#method_after
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    try {
        accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
        Set<Change.Id> reviewed = Sets.newHashSet();
        if (has(REVIEWED)) {
            reviewed = loadReviewed(Collections.singleton(cd));
        }
        ChangeInfo res = toChangeInfo(cd, reviewed, limitToPsId);
        accountLoader.fill();
        return res;
    } catch (PatchListNotAvailableException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.propagateIfPossible(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#end_block

#method_before
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes, Set<Change.Id> reviewed) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, reviewed, Optional.<PatchSet.Id>absent());
            } catch (OrmException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#method_after
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes, Set<Change.Id> reviewed) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, reviewed, Optional.<PatchSet.Id>absent());
            } catch (PatchListNotAvailableException | OrmException | IOException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeControl ctl, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    Map<String, RevisionInfo> res = Maps.newLinkedHashMap();
    for (PatchSet in : map.values()) {
        if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
            res.put(in.getRevision().get(), toRevisionInfo(ctl, in));
        }
    }
    return res;
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, Map<PatchSet.Id, PatchSet> map) throws PatchListNotAvailableException, OrmException, IOException {
    Map<String, RevisionInfo> res = Maps.newLinkedHashMap();
    for (PatchSet in : map.values()) {
        if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
            res.put(in.getRevision().get(), toRevisionInfo(ctl, in));
        }
    }
    return res;
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, PatchSet in) throws OrmException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    if (setCommit) {
        Project.NameKey project = c.getProject();
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS));
        } catch (IOException e) {
            throw new OrmException(e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(c, in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            throw new OrmException(e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(new ChangeResource(ctl, rebaseChange), in));
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = plcUtil.draftByPatchSetAuthor(db.get(), in.getId(), user.getAccountId(), ctl.getNotes()).iterator().hasNext() ? true : null;
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    if (setCommit) {
        Project.NameKey project = c.getProject();
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS));
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(new ChangeResource(ctl, rebaseChange), in));
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = plcUtil.draftByPatchSetAuthor(db.get(), in.getId(), user.getAccountId(), ctl.getNotes()).iterator().hasNext() ? true : null;
    }
    return out;
}
#end_block

#method_before
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks) throws OrmException {
    Project.NameKey project = ctl.getChange().getProject();
    CommitInfo info = new CommitInfo();
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    if (addLinks) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links.toList();
    }
    try {
        for (RevCommit parent : commit.getParents()) {
            rw.parseBody(parent);
            CommitInfo i = new CommitInfo();
            i.commit = parent.name();
            i.subject = parent.getShortMessage();
            if (addLinks) {
                FluentIterable<WebLinkInfo> parentLinks = webLinks.getPatchSetLinks(project, parent.name());
                i.webLinks = parentLinks.isEmpty() ? null : parentLinks.toList();
            }
            info.parents.add(i);
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
    return info;
}
#method_after
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks) throws IOException {
    Project.NameKey project = ctl.getChange().getProject();
    CommitInfo info = new CommitInfo();
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links.toList();
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            FluentIterable<WebLinkInfo> parentLinks = webLinks.getPatchSetLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks.toList();
        }
        info.parents.add(i);
    }
    return info;
}
#end_block

#method_before
@Override
public Response<CommitInfo> apply(RevisionResource rsrc) throws OrmException, IOException {
    Project.NameKey p = rsrc.getChange().getProject();
    try (Repository repo = repoManager.openRepository(p);
        RevWalk rw = new RevWalk(repo)) {
        String rev = rsrc.getPatchSet().getRevision().get();
        RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
        rw.parseBody(commit);
        Response<CommitInfo> r = Response.ok(json.toCommit(rsrc.getControl(), rw, commit, addLinks));
        if (rsrc.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    }
}
#method_after
@Override
public Response<CommitInfo> apply(RevisionResource rsrc) throws IOException {
    Project.NameKey p = rsrc.getChange().getProject();
    try (Repository repo = repoManager.openRepository(p);
        RevWalk rw = new RevWalk(repo)) {
        String rev = rsrc.getPatchSet().getRevision().get();
        RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
        rw.parseBody(commit);
        Response<CommitInfo> r = Response.ok(json.toCommit(rsrc.getControl(), rw, commit, addLinks));
        if (rsrc.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    }
}
#end_block

#method_before
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws AuthException, BadRequestException, UnprocessableEntityException, OrmException, IOException {
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.get().changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.get().changes().get(revision.getChange().getId());
        ChangeUtil.updated(change);
        timestamp = change.getLastUpdatedOn();
        ChangeUpdate update = updateFactory.create(revision.getControl(), timestamp);
        update.setPatchSetId(revision.getPatchSet().getId());
        dirty |= insertComments(revision, update, input.comments, input.drafts);
        dirty |= updateLabels(revision, update, input.labels);
        dirty |= insertMessage(revision, input.message, update);
        if (dirty) {
            db.get().changes().update(Collections.singleton(change));
            db.get().commit();
        }
        update.commit();
    } finally {
        db.get().rollback();
    }
    CheckedFuture<?, IOException> indexWrite;
    if (dirty) {
        indexWrite = indexer.indexAsync(change.getId());
    } else {
        indexWrite = Futures.<Void, IOException>immediateCheckedFuture(null);
    }
    if (message != null && input.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
    }
    Output output = new Output();
    output.labels = input.labels;
    indexWrite.checkedGet();
    if (message != null) {
        fireCommentAddedHook(revision);
    }
    return output;
}
#method_after
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws AuthException, BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException {
    return apply(revision, input, TimeUtil.nowTs());
}
#end_block

#method_before
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws AuthException, BadRequestException, UnprocessableEntityException, OrmException, IOException {
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.get().changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.get().changes().get(revision.getChange().getId());
        ChangeUtil.updated(change);
        timestamp = change.getLastUpdatedOn();
        ChangeUpdate update = updateFactory.create(revision.getControl(), timestamp);
        update.setPatchSetId(revision.getPatchSet().getId());
        dirty |= insertComments(revision, update, input.comments, input.drafts);
        dirty |= updateLabels(revision, update, input.labels);
        dirty |= insertMessage(revision, input.message, update);
        if (dirty) {
            db.get().changes().update(Collections.singleton(change));
            db.get().commit();
        }
        update.commit();
    } finally {
        db.get().rollback();
    }
    CheckedFuture<?, IOException> indexWrite;
    if (dirty) {
        indexWrite = indexer.indexAsync(change.getId());
    } else {
        indexWrite = Futures.<Void, IOException>immediateCheckedFuture(null);
    }
    if (message != null && input.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
    }
    Output output = new Output();
    output.labels = input.labels;
    indexWrite.checkedGet();
    if (message != null) {
        fireCommentAddedHook(revision);
    }
    return output;
}
#method_after
public Output apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws AuthException, BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException {
    timestamp = ts;
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.get().changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.get().changes().get(revision.getChange().getId());
        if (change.getLastUpdatedOn().before(timestamp)) {
            change.setLastUpdatedOn(timestamp);
        }
        ChangeUpdate update = updateFactory.create(revision.getControl(), timestamp);
        update.setPatchSetId(revision.getPatchSet().getId());
        dirty |= insertComments(revision, update, input.comments, input.drafts);
        dirty |= updateLabels(revision, update, input.labels);
        dirty |= insertMessage(revision, input.message, update);
        if (dirty) {
            db.get().changes().update(Collections.singleton(change));
            db.get().commit();
        }
        update.commit();
    } finally {
        db.get().rollback();
    }
    if (dirty) {
        indexer.index(db.get(), change);
    }
    if (message != null && input.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
    }
    Output output = new Output();
    output.labels = input.labels;
    if (message != null) {
        fireCommentAddedHook(revision);
    }
    return output;
}
#end_block

#method_before
private void checkComments(RevisionResource revision, Map<String, List<CommentInput>> in) throws BadRequestException, OrmException {
    Iterator<Map.Entry<String, List<CommentInput>>> mapItr = in.entrySet().iterator();
    Set<String> filePaths = Sets.newHashSet(changeDataFactory.create(db.get(), revision.getControl()).filePaths(revision.getPatchSet()));
    while (mapItr.hasNext()) {
        Map.Entry<String, List<CommentInput>> ent = mapItr.next();
        String path = ent.getKey();
        if (!filePaths.contains(path) && !Patch.COMMIT_MSG.equals(path)) {
            throw new BadRequestException(String.format("file %s not found in revision %s", path, revision.getChange().currentPatchSetId()));
        }
        List<CommentInput> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        Iterator<CommentInput> listItr = list.iterator();
        while (listItr.hasNext()) {
            CommentInput c = listItr.next();
            if (c == null) {
                listItr.remove();
                continue;
            }
            if (c.line < 0) {
                throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
            }
            c.message = Strings.nullToEmpty(c.message).trim();
            if (c.message.isEmpty()) {
                listItr.remove();
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#method_after
private void checkComments(RevisionResource revision, Map<String, List<CommentInput>> in) throws BadRequestException, OrmException {
    Iterator<Map.Entry<String, List<CommentInput>>> mapItr = in.entrySet().iterator();
    Set<String> filePaths = Sets.newHashSet(changeDataFactory.create(db.get(), revision.getControl()).filePaths(revision.getPatchSet()));
    while (mapItr.hasNext()) {
        Map.Entry<String, List<CommentInput>> ent = mapItr.next();
        String path = ent.getKey();
        if (!filePaths.contains(path) && !Patch.COMMIT_MSG.equals(path)) {
            throw new BadRequestException(String.format("file %s not found in revision %s", path, revision.getChange().currentPatchSetId()));
        }
        List<CommentInput> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        Iterator<CommentInput> listItr = list.iterator();
        while (listItr.hasNext()) {
            CommentInput c = listItr.next();
            if (c == null) {
                listItr.remove();
                continue;
            }
            if (c.line != null && c.line < 0) {
                throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
            }
            c.message = Strings.nullToEmpty(c.message).trim();
            if (c.message.isEmpty()) {
                listItr.remove();
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#end_block

#method_before
private boolean insertComments(RevisionResource rsrc, ChangeUpdate update, Map<String, List<CommentInput>> in, DraftHandling draftsHandling) throws OrmException {
    if (in == null) {
        in = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!in.isEmpty() || draftsHandling != DraftHandling.KEEP) {
        if (draftsHandling == DraftHandling.PUBLISH_FOR_ALL_REVISIONS) {
            drafts = scanDraftCommentsChange(rsrc);
        } else {
            drafts = scanDraftComments(rsrc);
        }
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    for (Map.Entry<String, List<CommentInput>> ent : in.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), path), ChangeUtil.messageUUID(db.get())), c.line, rsrc.getAccountId(), parent, timestamp);
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(timestamp);
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
            e.setMessage(c.message);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            ups.add(e);
        }
    }
    switch(MoreObjects.firstNonNull(draftsHandling, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
        case PUBLISH_FOR_ALL_REVISIONS:
            for (PatchLineComment e : drafts.values()) {
                e.setStatus(PatchLineComment.Status.PUBLISHED);
                e.setWrittenOn(timestamp);
                setCommentRevId(e, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
                ups.add(e);
            }
            break;
    }
    plcUtil.deleteComments(db.get(), update, del);
    plcUtil.upsertComments(db.get(), update, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean insertComments(RevisionResource rsrc, ChangeUpdate update, Map<String, List<CommentInput>> in, DraftHandling draftsHandling) throws OrmException {
    if (in == null) {
        in = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!in.isEmpty() || draftsHandling != DraftHandling.KEEP) {
        if (draftsHandling == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(rsrc);
        } else {
            drafts = patchSetDrafts(rsrc);
        }
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    for (Map.Entry<String, List<CommentInput>> ent : in.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), path), ChangeUtil.messageUUID(db.get())), c.line != null ? c.line : 0, rsrc.getAccountId(), parent, timestamp);
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(timestamp);
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
            e.setMessage(c.message);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            ups.add(e);
        }
    }
    switch(MoreObjects.firstNonNull(draftsHandling, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
        case PUBLISH_ALL_REVISIONS:
            for (PatchLineComment e : drafts.values()) {
                e.setStatus(PatchLineComment.Status.PUBLISHED);
                e.setWrittenOn(timestamp);
                setCommentRevId(e, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
                ups.add(e);
            }
            break;
    }
    plcUtil.deleteComments(db.get(), update, del);
    plcUtil.upsertComments(db.get(), update, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private void addLabelDelta(String name, short value) {
    labelDelta.add(new LabelVote(name, value).format());
}
#method_after
private void addLabelDelta(String name, short value) {
    labelDelta.add(LabelVote.create(name, value).format());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountLoader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteFile.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountLoader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteFile.Factory.class);
        }
    });
}
#end_block

#method_before
@Override
public RestView<RevisionResource> list() throws AuthException {
    checkIdentifiedUser();
    return list;
}
#method_after
@Override
public ListRevisionDrafts list() throws AuthException {
    checkIdentifiedUser();
    return list;
}
#end_block

#method_before
@Override
public Response<CommentInfo> apply(DraftCommentResource rsrc, DraftInput in) throws BadRequestException, OrmException, IOException {
    PatchLineComment c = rsrc.getComment();
    ChangeUpdate update = updateFactory.create(rsrc.getControl());
    if (in == null || in.message == null || in.message.trim().isEmpty()) {
        return delete.apply(rsrc, null);
    } else if (in.id != null && !rsrc.getId().equals(in.id)) {
        throw new BadRequestException("id must match URL");
    } else if (in.line != null && in.line < 0) {
        throw new BadRequestException("line must be >= 0");
    } else if (in.line != null && in.range != null && in.line != in.range.endLine) {
        throw new BadRequestException("range endLine must be on the same line as the comment");
    }
    if (in.path != null && !in.path.equals(c.getKey().getParentKey().getFileName())) {
        // Updating the path alters the primary key, which isn't possible.
        // Delete then recreate the comment instead of an update.
        plcUtil.deleteComments(db.get(), update, Collections.singleton(c));
        c = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), in.path), c.getKey().get()), c.getLine(), rsrc.getAuthorId(), c.getParentUuid(), TimeUtil.nowTs());
        getRevId(c, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
        plcUtil.insertComments(db.get(), update, Collections.singleton(update(c, in)));
    } else {
        if (c.getRevId() == null) {
            getRevId(c, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
        }
        plcUtil.updateComments(db.get(), update, Collections.singleton(update(c, in)));
    }
    update.commit();
    return Response.ok(commentJson.format(c, false));
}
#method_after
@Override
public Response<CommentInfo> apply(DraftCommentResource rsrc, DraftInput in) throws BadRequestException, OrmException, IOException {
    PatchLineComment c = rsrc.getComment();
    ChangeUpdate update = updateFactory.create(rsrc.getControl());
    if (in == null || in.message == null || in.message.trim().isEmpty()) {
        return delete.apply(rsrc, null);
    } else if (in.id != null && !rsrc.getId().equals(in.id)) {
        throw new BadRequestException("id must match URL");
    } else if (in.line != null && in.line < 0) {
        throw new BadRequestException("line must be >= 0");
    } else if (in.line != null && in.range != null && in.line != in.range.endLine) {
        throw new BadRequestException("range endLine must be on the same line as the comment");
    }
    if (in.path != null && !in.path.equals(c.getKey().getParentKey().getFileName())) {
        // Updating the path alters the primary key, which isn't possible.
        // Delete then recreate the comment instead of an update.
        plcUtil.deleteComments(db.get(), update, Collections.singleton(c));
        c = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), in.path), c.getKey().get()), c.getLine(), rsrc.getAuthorId(), c.getParentUuid(), TimeUtil.nowTs());
        setCommentRevId(c, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
        plcUtil.insertComments(db.get(), update, Collections.singleton(update(c, in)));
    } else {
        if (c.getRevId() == null) {
            setCommentRevId(c, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
        }
        plcUtil.updateComments(db.get(), update, Collections.singleton(update(c, in)));
    }
    update.commit();
    return Response.ok(commentJson.format(c, false));
}
#end_block

#method_before
@Test
public void testListComments() throws Exception {
    // test ListComments for patch set 1
    assertListComments(revRes1, ImmutableMap.of("FileOne.txt", Lists.newArrayList(plc3, plc1, plc2)));
    // test ListComments for patch set 2
    assertListComments(revRes2, Collections.<String, ArrayList<PatchLineComment>>emptyMap());
}
#method_after
@Test
public void testListComments() throws Exception {
    // test ListComments for patch set 1
    assertListComments(revRes1, ImmutableMap.of("FileOne.txt", Lists.newArrayList(plc3, plc1, plc2)));
    // test ListComments for patch set 2
    assertListComments(revRes2, Collections.<String, List<PatchLineComment>>emptyMap());
}
#end_block

#method_before
@Test
public void testListDrafts() throws Exception {
    // test ListDrafts for patch set 1
    assertListDrafts(revRes1, Collections.<String, ArrayList<PatchLineComment>>emptyMap());
    // test ListDrafts for patch set 2
    assertListDrafts(revRes2, ImmutableMap.of("FileOne.txt", Lists.newArrayList(plc4, plc5)));
}
#method_after
@Test
public void testListDrafts() throws Exception {
    // test ListDrafts for patch set 1
    assertListDrafts(revRes1, Collections.<String, List<PatchLineComment>>emptyMap());
    // test ListDrafts for patch set 2
    assertListDrafts(revRes2, ImmutableMap.of("FileOne.txt", Lists.newArrayList(plc4, plc5)));
}
#end_block

#method_before
@Test
public void testPatchLineCommentsUtilByCommentStatus() throws OrmException {
    List<PatchLineComment> publishedActual = plcUtil.publishedByChange(db, revRes2.getNotes());
    List<PatchLineComment> draftActual = plcUtil.draftByChange(db, revRes2.getNotes());
    List<PatchLineComment> publishedExpected = Lists.newArrayList(plc1, plc2, plc3);
    List<PatchLineComment> draftExpected = Lists.newArrayList(plc4, plc5);
    assertThat(publishedActual.size()).isEqualTo(publishedExpected.size());
    assertThat(draftActual.size()).isEqualTo(draftExpected.size());
    assertThat(publishedActual).isEqualTo(publishedExpected);
    assertThat(draftActual).isEqualTo(draftExpected);
}
#method_after
@Test
public void testPatchLineCommentsUtilByCommentStatus() throws OrmException {
    assertThat(plcUtil.publishedByChange(db, revRes2.getNotes())).containsExactly(plc1, plc2, plc3).inOrder();
    assertThat(plcUtil.draftByChange(db, revRes2.getNotes())).containsExactly(plc4, plc5).inOrder();
}
#end_block

#method_before
private void assertListComments(RevisionResource res, Map<String, ArrayList<PatchLineComment>> expected) throws Exception {
    RestReadView<RevisionResource> listView = (RestReadView<RevisionResource>) comments.list();
    @SuppressWarnings("unchecked")
    Map<String, List<CommentInfo>> actual = (Map<String, List<CommentInfo>>) listView.apply(res);
    assertThat(actual).isNotNull();
    assertThat(actual.size()).isEqualTo(expected.size());
    assertThat(actual.keySet()).isEqualTo(expected.keySet());
    for (Map.Entry<String, ArrayList<PatchLineComment>> entry : expected.entrySet()) {
        List<PatchLineComment> expectedComments = entry.getValue();
        List<CommentInfo> actualComments = actual.get(entry.getKey());
        assertThat(actualComments).isNotNull();
        assertThat(actualComments.size()).isEqualTo(expectedComments.size());
        for (int i = 0; i < expectedComments.size(); i++) {
            assertComment(expectedComments.get(i), actualComments.get(i), true);
        }
    }
}
#method_after
private void assertListComments(RevisionResource res, Map<String, ? extends List<PatchLineComment>> expected) throws Exception {
    assertCommentMap(comments.list().apply(res), expected, true);
}
#end_block

#method_before
private void assertListDrafts(RevisionResource res, Map<String, ArrayList<PatchLineComment>> expected) throws Exception {
    RestReadView<RevisionResource> listView = (RestReadView<RevisionResource>) drafts.list();
    @SuppressWarnings("unchecked")
    Map<String, List<CommentInfo>> actual = (Map<String, List<CommentInfo>>) listView.apply(res);
    assertThat(actual).isNotNull();
    assertThat(actual.size()).isEqualTo(expected.size());
    assertThat(actual.keySet()).isEqualTo(expected.keySet());
    for (Map.Entry<String, ArrayList<PatchLineComment>> entry : expected.entrySet()) {
        List<PatchLineComment> expectedComments = entry.getValue();
        List<CommentInfo> actualComments = actual.get(entry.getKey());
        assertThat(actualComments).isNotNull();
        assertThat(actualComments.size()).isEqualTo(expectedComments.size());
        for (int i = 0; i < expectedComments.size(); i++) {
            assertComment(expectedComments.get(i), actualComments.get(i), false);
        }
    }
}
#method_after
private void assertListDrafts(RevisionResource res, Map<String, ? extends List<PatchLineComment>> expected) throws Exception {
    assertCommentMap(drafts.list().apply(res), expected, false);
}
#end_block

#method_before
private boolean insertComments(RevisionResource rsrc, ChangeUpdate update, Map<String, List<CommentInput>> in, DraftHandling draftsHandling) throws OrmException {
    if (in == null) {
        in = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!in.isEmpty() || draftsHandling != DraftHandling.KEEP) {
        drafts = scanDraftComments(rsrc);
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    for (Map.Entry<String, List<CommentInput>> ent : in.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), path), ChangeUtil.messageUUID(db.get())), c.line != null ? c.line : 0, rsrc.getAccountId(), parent, timestamp);
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(timestamp);
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            getRevId(e, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
            e.setMessage(c.message);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            ups.add(e);
        }
    }
    switch(MoreObjects.firstNonNull(draftsHandling, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
            for (PatchLineComment e : drafts.values()) {
                e.setStatus(PatchLineComment.Status.PUBLISHED);
                e.setWrittenOn(timestamp);
                getRevId(e, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
                ups.add(e);
            }
            break;
    }
    plcUtil.deleteComments(db.get(), update, del);
    plcUtil.upsertComments(db.get(), update, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean insertComments(RevisionResource rsrc, ChangeUpdate update, Map<String, List<CommentInput>> in, DraftHandling draftsHandling) throws OrmException {
    if (in == null) {
        in = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!in.isEmpty() || draftsHandling != DraftHandling.KEEP) {
        drafts = scanDraftComments(rsrc);
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    for (Map.Entry<String, List<CommentInput>> ent : in.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), path), ChangeUtil.messageUUID(db.get())), c.line != null ? c.line : 0, rsrc.getAccountId(), parent, timestamp);
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(timestamp);
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
            e.setMessage(c.message);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            ups.add(e);
        }
    }
    switch(MoreObjects.firstNonNull(draftsHandling, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
            for (PatchLineComment e : drafts.values()) {
                e.setStatus(PatchLineComment.Status.PUBLISHED);
                e.setWrittenOn(timestamp);
                setCommentRevId(e, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
                ups.add(e);
            }
            break;
    }
    plcUtil.deleteComments(db.get(), update, del);
    plcUtil.upsertComments(db.get(), update, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
public static NoteMap parseCommentsFromNotes(Repository repo, String refName, RevWalk walk, Change.Id changeId, Multimap<RevId, PatchLineComment> comments, Status status) throws IOException, ConfigInvalidException {
    Ref ref = repo.getRef(refName);
    if (ref == null) {
        return null;
    }
    ObjectReader reader = walk.getObjectReader();
    RevCommit commit = walk.parseCommit(ref.getObjectId());
    NoteMap noteMap = NoteMap.read(reader, commit);
    for (Note note : noteMap) {
        byte[] bytes = reader.open(note.getData(), OBJ_BLOB).getCachedBytes(MAX_NOTE_SZ);
        List<PatchLineComment> result = parseNote(bytes, changeId, status);
        if (result == null || result.isEmpty()) {
            continue;
        }
        // TODO(dborowitz): Need to fil
        comments.putAll(new RevId(note.name()), result);
    }
    return noteMap;
}
#method_after
public static NoteMap parseCommentsFromNotes(Repository repo, String refName, RevWalk walk, Change.Id changeId, Multimap<RevId, PatchLineComment> comments, Status status) throws IOException, ConfigInvalidException {
    Ref ref = repo.getRef(refName);
    if (ref == null) {
        return null;
    }
    ObjectReader reader = walk.getObjectReader();
    RevCommit commit = walk.parseCommit(ref.getObjectId());
    NoteMap noteMap = NoteMap.read(reader, commit);
    for (Note note : noteMap) {
        byte[] bytes = reader.open(note.getData(), OBJ_BLOB).getCachedBytes(MAX_NOTE_SZ);
        List<PatchLineComment> result = parseNote(bytes, changeId, status);
        if (result == null || result.isEmpty()) {
            continue;
        }
        comments.putAll(new RevId(note.name()), result);
    }
    return noteMap;
}
#end_block

#method_before
public void writeCommentsToNoteMap(NoteMap noteMap, ListMultimap<RevId, PatchLineComment> allComments, ObjectInserter inserter) throws IOException {
    for (Map.Entry<RevId, Collection<PatchLineComment>> e : allComments.asMap().entrySet()) {
        List<PatchLineComment> comments = (List<PatchLineComment>) e.getValue();
        ObjectId commit = ObjectId.fromString(e.getKey().get());
        if (comments.isEmpty()) {
            noteMap.remove(commit);
            continue;
        }
        Collections.sort(comments, ChangeNotes.PLC_ORDER);
        // We allow comments for multiple commits to be written in the same
        // update, even though the rest of the metadata update is associated with
        // a single patch set.
        noteMap.set(commit, inserter.insert(OBJ_BLOB, buildNote(comments)));
    }
}
#method_after
public void writeCommentsToNoteMap(NoteMap noteMap, Map<RevId, List<PatchLineComment>> allComments, ObjectInserter inserter) throws IOException {
    for (Map.Entry<RevId, List<PatchLineComment>> e : allComments.entrySet()) {
        List<PatchLineComment> comments = e.getValue();
        ObjectId commit = ObjectId.fromString(e.getKey().get());
        if (comments.isEmpty()) {
            noteMap.remove(commit);
            continue;
        }
        Collections.sort(comments, ChangeNotes.PLC_ORDER);
        // We allow comments for multiple commits to be written in the same
        // update, even though the rest of the metadata update is associated with
        // a single patch set.
        noteMap.set(commit, inserter.insert(OBJ_BLOB, buildNote(comments)));
    }
}
#end_block

#method_before
@Test
public void patchLineCommentMultipleDraftsSameSidePublishOne() throws OrmException, IOException {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range1 = new CommentRange(1, 1, 2, 2);
    CommentRange range2 = new CommentRange(2, 2, 3, 3);
    String filename = "filename1";
    short side = (short) 1;
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    // Write two drafts on the same side of one patch set.
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    PatchLineComment comment1 = newComment(psId, filename, uuid1, range1, range1.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.DRAFT);
    PatchLineComment comment2 = newComment(psId, filename, uuid2, range2, range2.getEndLine(), otherUser, null, now, "other on ps1", side, rev, Status.DRAFT);
    update.insertComment(comment1);
    update.insertComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactly(ImmutableMultimap.of(new RevId(rev), comment1, new RevId(rev), comment2)).inOrder();
    assertThat(notes.getComments()).isEmpty();
    // Publish first draft.
    update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    comment1.setStatus(Status.PUBLISHED);
    update.updateComment(comment1);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactly(ImmutableMultimap.of(new RevId(rev), comment2));
    assertThat(notes.getComments()).containsExactly(ImmutableMultimap.of(new RevId(rev), comment1));
}
#method_after
@Test
public void patchLineCommentMultipleDraftsSameSidePublishOne() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range1 = new CommentRange(1, 1, 2, 2);
    CommentRange range2 = new CommentRange(2, 2, 3, 3);
    String filename = "filename1";
    short side = (short) 1;
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    // Write two drafts on the same side of one patch set.
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    PatchLineComment comment1 = newComment(psId, filename, uuid1, range1, range1.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.DRAFT);
    PatchLineComment comment2 = newComment(psId, filename, uuid2, range2, range2.getEndLine(), otherUser, null, now, "other on ps1", side, rev, Status.DRAFT);
    update.insertComment(comment1);
    update.insertComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactly(ImmutableMultimap.of(new RevId(rev), comment1, new RevId(rev), comment2)).inOrder();
    assertThat(notes.getComments()).isEmpty();
    // Publish first draft.
    update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    comment1.setStatus(Status.PUBLISHED);
    update.updateComment(comment1);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactly(ImmutableMultimap.of(new RevId(rev), comment2));
    assertThat(notes.getComments()).containsExactly(ImmutableMultimap.of(new RevId(rev), comment1));
}
#end_block

#method_before
@Test
public void patchLineCommentsMultipleDraftsBothSidesPublishAll() throws OrmException, IOException {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range1 = new CommentRange(1, 1, 2, 2);
    CommentRange range2 = new CommentRange(2, 2, 3, 3);
    String filename = "filename1";
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    // Write two drafts, one on each side of the patchset.
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    PatchLineComment baseComment = newComment(psId, filename, uuid1, range1, range1.getEndLine(), otherUser, null, now, "comment on base", (short) 0, rev1, Status.DRAFT);
    PatchLineComment psComment = newComment(psId, filename, uuid2, range2, range2.getEndLine(), otherUser, null, now, "comment on ps", (short) 1, rev2, Status.DRAFT);
    update.insertComment(baseComment);
    update.insertComment(psComment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactly(ImmutableMultimap.of(new RevId(rev1), baseComment, new RevId(rev2), psComment));
    assertThat(notes.getComments()).isEmpty();
    // Publish both comments.
    update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    baseComment.setStatus(Status.PUBLISHED);
    psComment.setStatus(Status.PUBLISHED);
    update.updateComment(baseComment);
    update.updateComment(psComment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getComments()).containsExactly(ImmutableMultimap.of(new RevId(rev1), baseComment, new RevId(rev2), psComment));
}
#method_after
@Test
public void patchLineCommentsMultipleDraftsBothSidesPublishAll() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range1 = new CommentRange(1, 1, 2, 2);
    CommentRange range2 = new CommentRange(2, 2, 3, 3);
    String filename = "filename1";
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    // Write two drafts, one on each side of the patchset.
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    PatchLineComment baseComment = newComment(psId, filename, uuid1, range1, range1.getEndLine(), otherUser, null, now, "comment on base", (short) 0, rev1, Status.DRAFT);
    PatchLineComment psComment = newComment(psId, filename, uuid2, range2, range2.getEndLine(), otherUser, null, now, "comment on ps", (short) 1, rev2, Status.DRAFT);
    update.insertComment(baseComment);
    update.insertComment(psComment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactly(ImmutableMultimap.of(new RevId(rev1), baseComment, new RevId(rev2), psComment));
    assertThat(notes.getComments()).isEmpty();
    // Publish both comments.
    update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    baseComment.setStatus(Status.PUBLISHED);
    psComment.setStatus(Status.PUBLISHED);
    update.updateComment(baseComment);
    update.updateComment(psComment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getComments()).containsExactly(ImmutableMultimap.of(new RevId(rev1), baseComment, new RevId(rev2), psComment));
}
#end_block

#method_before
private void verifyComment(PatchLineComment c) {
    // TODO(dborowitz): Eliminate these checks to support publishing comments
    // for all patch sets.
    checkArgument(psId != null, "setPatchSetId must be called first");
    checkArgument(getCommentPsId(c).equals(psId), "Comment on %s doesn't match previous patch set %s", getCommentPsId(c), psId);
    checkArgument(c.getRevId() != null);
    checkArgument(c.getStatus() == Status.PUBLISHED, "Cannot add a draft comment to a ChangeUpdate. Use a ChangeDraftUpdate" + " for draft comments");
    checkArgument(c.getAuthor().equals(getUser().getAccountId()), "The author for the following comment does not match the author of" + " this ChangeDraftUpdate (%s): %s", getUser().getAccountId(), c);
}
#method_after
private void verifyComment(PatchLineComment c) {
    checkArgument(psId != null, "setPatchSetId must be called first");
    checkArgument(getCommentPsId(c).equals(psId), "Comment on %s doesn't match previous patch set %s", getCommentPsId(c), psId);
    checkArgument(c.getRevId() != null);
    checkArgument(c.getStatus() == Status.PUBLISHED, "Cannot add a draft comment to a ChangeUpdate. Use a ChangeDraftUpdate" + " for draft comments");
    checkArgument(c.getAuthor().equals(getUser().getAccountId()), "The author for the following comment does not match the author of" + " this ChangeDraftUpdate (%s): %s", getUser().getAccountId(), c);
}
#end_block

#method_before
private ObjectId storeCommentsInNotes() throws OrmException, IOException {
    ChangeNotes notes = ctl.getNotes().load();
    NoteMap noteMap = notes.getNoteMap();
    if (noteMap == null) {
        noteMap = NoteMap.newEmptyMap();
    }
    if (comments.isEmpty()) {
        return null;
    }
    ListMultimap<RevId, PatchLineComment> allComments = ArrayListMultimap.create(notes.getComments());
    for (PatchLineComment c : comments) {
        allComments.put(c.getRevId(), c);
    }
    commentsUtil.writeCommentsToNoteMap(noteMap, allComments, inserter);
    return noteMap.writeTree(inserter);
}
#method_after
private ObjectId storeCommentsInNotes() throws OrmException, IOException {
    ChangeNotes notes = ctl.getNotes().load();
    NoteMap noteMap = notes.getNoteMap();
    if (noteMap == null) {
        noteMap = NoteMap.newEmptyMap();
    }
    if (comments.isEmpty()) {
        return null;
    }
    Map<RevId, List<PatchLineComment>> allComments = Maps.newHashMap();
    for (Map.Entry<RevId, Collection<PatchLineComment>> e : notes.getComments().asMap().entrySet()) {
        List<PatchLineComment> comments = new ArrayList<>();
        for (PatchLineComment c : e.getValue()) {
            comments.add(c);
        }
        allComments.put(e.getKey(), comments);
    }
    for (PatchLineComment c : comments) {
        addCommentToMap(allComments, c);
    }
    commentsUtil.writeCommentsToNoteMap(noteMap, allComments, inserter);
    return noteMap.writeTree(inserter);
}
#end_block

#method_before
private ObjectId storeCommentsInNotes(AtomicBoolean removedAllComments) throws OrmException, IOException {
    if (isEmpty()) {
        return null;
    }
    NoteMap noteMap = draftNotes.load().getNoteMap();
    if (noteMap == null) {
        noteMap = NoteMap.newEmptyMap();
    }
    // TODO(dborowitz): if (comments.isEmpty()) return null as in ChangeUpdate?
    ListMultimap<RevId, PatchLineComment> allComments = ArrayListMultimap.create();
    Set<PatchLineComment.Key> deleteKeys = Sets.newHashSetWithExpectedSize(deleteComments.size());
    for (PatchLineComment c : deleteComments) {
        deleteKeys.add(c.getKey());
    }
    for (PatchLineComment c : upsertComments) {
        allComments.put(c.getRevId(), c);
    }
    PLC: for (Map.Entry<RevId, PatchLineComment> e : draftNotes.getComments().entries()) {
        RevId rev = e.getKey();
        PatchLineComment.Key plcKey = e.getValue().getKey();
        if (deleteKeys.contains(plcKey)) {
            continue;
        }
        // needing to convert to/from a Table.
        for (PatchLineComment updated : allComments.get(rev)) {
            if (updated.getKey().equals(plcKey)) {
                continue PLC;
            }
        }
        allComments.put(e.getKey(), e.getValue());
    }
    // TODO(dborowitz): Optimization: remove unchanged RevIds from the map.
    commentsUtil.writeCommentsToNoteMap(noteMap, allComments, inserter);
    removedAllComments.set(allComments.isEmpty());
    return noteMap.writeTree(inserter);
}
#method_after
private ObjectId storeCommentsInNotes(AtomicBoolean removedAllComments) throws OrmException, IOException {
    if (isEmpty()) {
        return null;
    }
    NoteMap noteMap = draftNotes.load().getNoteMap();
    if (noteMap == null) {
        noteMap = NoteMap.newEmptyMap();
    }
    Map<RevId, List<PatchLineComment>> allComments = new HashMap<>();
    boolean hasComments = false;
    int n = deleteComments.size() + upsertComments.size();
    Set<RevId> updatedRevs = Sets.newHashSetWithExpectedSize(n);
    Set<PatchLineComment.Key> updatedKeys = Sets.newHashSetWithExpectedSize(n);
    for (PatchLineComment c : deleteComments) {
        allComments.put(c.getRevId(), new ArrayList<PatchLineComment>());
        updatedRevs.add(c.getRevId());
        updatedKeys.add(c.getKey());
    }
    for (PatchLineComment c : upsertComments) {
        hasComments = true;
        addCommentToMap(allComments, c);
        updatedRevs.add(c.getRevId());
        updatedKeys.add(c.getKey());
    }
    // Re-add old comments for updated revisions so the new note contents
    // includes both old and new comments merged in the right order.
    // 
    // writeCommentsToNoteMap doesn't touch notes for SHA-1s that are not
    // mentioned in the input map, so by omitting comments for those revisions,
    // we avoid the work of having to re-serialize identical comment data for
    // those revisions.
    ListMultimap<RevId, PatchLineComment> existing = draftNotes.getComments();
    for (Map.Entry<RevId, PatchLineComment> e : existing.entries()) {
        PatchLineComment c = e.getValue();
        if (updatedRevs.contains(c.getRevId()) && !updatedKeys.contains(c.getKey())) {
            hasComments = true;
            addCommentToMap(allComments, e.getValue());
        }
    }
    // If we touched every revision and there are no comments left, set the flag
    // for the caller to delete the entire ref.
    boolean touchedAllRevs = updatedRevs.equals(existing.keySet());
    if (touchedAllRevs && !hasComments) {
        removedAllComments.set(touchedAllRevs && !hasComments);
        return null;
    }
    commentsUtil.writeCommentsToNoteMap(noteMap, allComments, inserter);
    return noteMap.writeTree(inserter);
}
#end_block

#method_before
@Override
public void writeCommit(BatchMetaDataUpdate batch) throws OrmException, IOException {
    CommitBuilder builder = new CommitBuilder();
    if (migration.writeChanges()) {
        AtomicBoolean removedAllComments = new AtomicBoolean();
        ObjectId treeId = storeCommentsInNotes(removedAllComments);
        if (treeId != null) {
            if (removedAllComments.get()) {
                batch.removeRef(getRefName());
            } else {
                builder.setTreeId(treeId);
                batch.write(builder);
            }
        }
    }
}
#method_after
@Override
public void writeCommit(BatchMetaDataUpdate batch) throws OrmException, IOException {
    CommitBuilder builder = new CommitBuilder();
    if (migration.writeChanges()) {
        AtomicBoolean removedAllComments = new AtomicBoolean();
        ObjectId treeId = storeCommentsInNotes(removedAllComments);
        if (removedAllComments.get()) {
            batch.removeRef(getRefName());
        } else if (treeId != null) {
            builder.setTreeId(treeId);
            batch.write(builder);
        }
    }
}
#end_block

#method_before
@Test
public void testSubscriptionToDifferentBranches() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    pushChangeTo(subRepo, "master");
    createSubscription(superRepo, "master", "subscribed-to-project", "foo-1");
    pushChangeTo(subRepo, "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "foo-1");
    pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
}
#method_after
@Test
public void testSubscriptionToDifferentBranches() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    createSubscription(superRepo, "master", "subscribed-to-project", "foo");
    ObjectId subFoo = pushChangeTo(subRepo, "foo");
    pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subFoo);
}
#end_block

#method_before
private ObjectId pushChangeTo(TestRepository<?> repo, String branch, String message) throws Exception {
    repo.branch("HEAD").commit().insertChangeId().message(message).add("a.txt", "a contents").create();
    repo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/" + branch)).call();
    return repo.getRepository().resolve("HEAD");
}
#method_after
private ObjectId pushChangeTo(TestRepository<?> repo, String branch, String message) throws Exception {
    ObjectId ret = repo.branch("HEAD").commit().insertChangeId().message(message).add("a.txt", "a contents: " + contentCounter.addAndGet(1)).create();
    repo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/" + branch)).call();
    return ret;
}
#end_block

#method_before
protected ObjectId pushChangeTo(TestRepository<?> repo, String branch) throws Exception {
    return pushChangeTo(repo, branch, "some change");
}
#method_after
private ObjectId pushChangeTo(TestRepository<?> repo, String branch) throws Exception {
    return pushChangeTo(repo, branch, "some change");
}
#end_block

#method_before
private void deleteAllSubscriptions(TestRepository<?> repo, String branch) throws Exception {
    repo.git().fetch().setRemote("origin").call();
    repo.reset("refs/remotes/origin/" + branch);
    // Just remove the contents of the file,
    // use deleteGitModulesFile if you want to remove the whole file
    repo.branch("HEAD").commit().insertChangeId().message("delete contents in .gitmodules").add(".gitmodules", "").create();
    repo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/" + branch)).call();
    ObjectId expectedId = repo.getRepository().resolve("HEAD");
    ObjectId actualId = repo.git().fetch().setRemote("origin").call().getAdvertisedRef("refs/heads/master").getObjectId();
    assertThat(actualId).isEqualTo(expectedId);
}
#method_after
private void deleteAllSubscriptions(TestRepository<?> repo, String branch) throws Exception {
    repo.git().fetch().setRemote("origin").call();
    repo.reset("refs/remotes/origin/" + branch);
    ObjectId expectedId = repo.branch("HEAD").commit().insertChangeId().message("delete contents in .gitmodules").add(".gitmodules", // Just remove the contents of the file!
    "").create();
    repo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/" + branch)).call();
    ObjectId actualId = repo.git().fetch().setRemote("origin").call().getAdvertisedRef("refs/heads/master").getObjectId();
    assertThat(actualId).isEqualTo(expectedId);
}
#end_block

#method_before
private void deleteGitModulesFile(TestRepository<?> repo, String branch) throws Exception {
    repo.git().fetch().setRemote("origin").call();
    repo.reset("refs/remotes/origin/" + branch);
    repo.branch("HEAD").commit().insertChangeId().message("delete .gitmodules").rm(".gitmodules").create();
    repo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/" + branch)).call();
    ObjectId expectedId = repo.getRepository().resolve("HEAD");
    ObjectId actualId = repo.git().fetch().setRemote("origin").call().getAdvertisedRef("refs/heads/master").getObjectId();
    assertThat(actualId).isEqualTo(expectedId);
}
#method_after
private void deleteGitModulesFile(TestRepository<?> repo, String branch) throws Exception {
    repo.git().fetch().setRemote("origin").call();
    repo.reset("refs/remotes/origin/" + branch);
    ObjectId expectedId = repo.branch("HEAD").commit().insertChangeId().message("delete .gitmodules").rm(".gitmodules").create();
    repo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/" + branch)).call();
    ObjectId actualId = repo.git().fetch().setRemote("origin").call().getAdvertisedRef("refs/heads/master").getObjectId();
    assertThat(actualId).isEqualTo(expectedId);
}
#end_block

#method_before
private SubmoduleSubscription parse(final String id) {
    final String url = bbc.getString("submodule", id, "url");
    final String path = bbc.getString("submodule", id, "path");
    String branch = bbc.getString("submodule", id, "branch");
    try {
        if (url != null && url.length() > 0 && path != null && path.length() > 0 && branch != null && branch.length() > 0) {
            // All required fields filled.
            boolean urlIsRelative = url.startsWith("../");
            String server = null;
            if (!urlIsRelative) {
                // It is actually an URI. It could be ssh://localhost/project-a.
                server = new URI(url).getHost();
            }
            if ((urlIsRelative) || (server != null && server.equalsIgnoreCase(thisServer))) {
                // Subscription really related to this running server.
                if (branch.equals(".")) {
                    branch = superProjectBranch.get();
                }
                final String urlExtractedPath = new URI(url).getPath();
                String projectName;
                int fromIndex = urlExtractedPath.length() - 1;
                while (fromIndex > 0) {
                    fromIndex = urlExtractedPath.lastIndexOf('/', fromIndex - 1);
                    projectName = urlExtractedPath.substring(fromIndex + 1);
                    if (projectName.endsWith(Constants.DOT_GIT_EXT)) {
                        projectName = // 
                        projectName.substring(// 
                        0, projectName.length() - Constants.DOT_GIT_EXT.length());
                    }
                    if (repoManager.list().contains(new Project.NameKey(projectName))) {
                        return new SubmoduleSubscription(superProjectBranch, new Branch.NameKey(new Project.NameKey(projectName), branch), path);
                    }
                }
            }
        }
    } catch (URISyntaxException e) {
    // Error in url syntax (in fact it is uri syntax)
    }
    return null;
}
#method_after
private SubmoduleSubscription parse(final String id) {
    final String url = bbc.getString("submodule", id, "url");
    final String path = bbc.getString("submodule", id, "path");
    String branch = bbc.getString("submodule", id, "branch");
    try {
        if (url != null && url.length() > 0 && path != null && path.length() > 0 && branch != null && branch.length() > 0) {
            // All required fields filled.
            boolean urlIsRelative = url.startsWith("../");
            String server = null;
            if (!urlIsRelative) {
                // It is actually an URI. It could be ssh://localhost/project-a.
                server = new URI(url).getHost();
            }
            if ((urlIsRelative) || (server != null && server.equalsIgnoreCase(thisServer))) {
                // Subscription really related to this running server.
                if (branch.equals(".")) {
                    branch = superProjectBranch.get();
                }
                final String urlExtractedPath = new URI(url).getPath();
                String projectName;
                int fromIndex = urlExtractedPath.length() - 1;
                while (fromIndex > 0) {
                    fromIndex = urlExtractedPath.lastIndexOf('/', fromIndex - 1);
                    projectName = urlExtractedPath.substring(fromIndex + 1);
                    if (projectName.endsWith(Constants.DOT_GIT_EXT)) {
                        projectName = // 
                        projectName.substring(// 
                        0, projectName.length() - Constants.DOT_GIT_EXT.length());
                    }
                    Project.NameKey projectKey = new Project.NameKey(projectName);
                    if (projectCache.get(projectKey) != null) {
                        return new SubmoduleSubscription(superProjectBranch, new Branch.NameKey(projectKey, branch), path);
                    }
                }
            }
        }
    } catch (URISyntaxException e) {
    // Error in url syntax (in fact it is uri syntax)
    }
    return null;
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    try {
        boolean visible = threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
        if (!visible) {
            return;
        }
    } catch (NoSuchProjectException err) {
        wrappedLog.error(String.format("source project %s not available", project), err, state);
        return;
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (pending) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                wrappedLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && GitRepositoryManager.REF_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                wrappedLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (pending) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.addPushCount(1);
        e.addState(ref, state);
    }
}
#method_after
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    try {
        boolean visible = threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
        if (!visible) {
            return;
        }
    } catch (NoSuchProjectException err) {
        wrappedLog.error(String.format("source project %s not available", project), err, state);
        return;
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (pending) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                wrappedLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && GitRepositoryManager.REF_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                wrappedLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (pending) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount();
        e.addState(ref, state);
    }
}
#end_block

#method_before
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (!remoteNameStyle.equals("slash")) {
                ReplicationQueue.log.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name);
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#method_after
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (!remoteNameStyle.equals("slash")) {
                ReplicationQueue.log.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch());
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#end_block

#method_before
@Override
public void run() {
    try {
        for (Project.NameKey nameKey : projectCache.all()) {
            replication.scheduleFullSync(nameKey, urlMatch, state);
        }
    } catch (Exception e) {
        wrappedLog.error("Cannot enumerate known projects", e, state);
    }
    state.allTaskScheduled();
}
#method_after
@Override
public void run() {
    try {
        for (Project.NameKey nameKey : projectCache.all()) {
            replication.scheduleFullSync(nameKey, urlMatch, state);
        }
    } catch (Exception e) {
        wrappedLog.error("Cannot enumerate known projects", e, state);
    }
    state.markAllPushTasksScheduled();
}
#end_block

#method_before
public boolean hasPushTask() {
    taskLock.lock();
    try {
        if (totalPushCount == 0) {
            return false;
        }
    } finally {
        taskLock.unlock();
    }
    return true;
}
#method_after
public boolean hasPushTask() {
    return totalPushTasksCount != 0;
}
#end_block

#method_before
public void notifyRefReplicated(String project, String ref, URIish uri, RefPushResult status) {
    pushProcessing.onOneNodeReplicated(project, ref, uri, status);
    taskLock.lock();
    try {
        finishedPushCount++;
        if (!allScheduled) {
            return;
        }
        if (finishedPushCount < totalPushCount) {
            return;
        }
    } finally {
        taskLock.unlock();
    }
    pushProcessing.onAllNodesReplicated();
    if (type == ReplicationType.COMMAND) {
        allTaskFinished.countDown();
    }
}
#method_after
public void notifyRefReplicated(String project, String ref, URIish uri, RefPushResult status) {
    pushResultProcessing.onOneNodeReplicated(project, ref, uri, status);
    countingLock.lock();
    try {
        finishedPushTasksCount++;
        if (!allScheduled) {
            return;
        }
        if (finishedPushTasksCount < totalPushTasksCount) {
            return;
        }
    } finally {
        countingLock.unlock();
    }
    doAllPushTasksCompleted();
}
#end_block

#method_before
public void waitForReplication() {
    taskLock.lock();
    try {
        if (finishedPushCount == totalPushCount) {
            return;
        }
    } finally {
        taskLock.unlock();
    }
    try {
        allTaskFinished.await();
    } catch (InterruptedException e) {
        log.error("It is interrupted while waiting replication to be completed");
        ;
    }
}
#method_after
public void waitForReplication() throws InterruptedException {
    allPushTasksFinished.await();
}
#end_block

#method_before
public void writeStdOut(final String message) {
    pushProcessing.writeStdOut(message);
}
#method_after
public void writeStdOut(final String message) {
    pushResultProcessing.writeStdOut(message);
}
#end_block

#method_before
public void writeStdErr(final String message) {
    pushProcessing.writeStdErr(message);
}
#method_after
public void writeStdErr(final String message) {
    pushResultProcessing.writeStdErr(message);
}
#end_block

#method_before
@Override
public void start() {
    queue.start();
    if (srvInfo.getState() == ServerInformation.State.STARTUP && queue.replicateAllOnPluginStart) {
        ReplicationState state = new ReplicationState(ReplicationType.START_UP);
        pushAllFuture.set(pushAll.create(null, state).schedule(30, TimeUnit.SECONDS));
    }
}
#method_after
@Override
public void start() {
    queue.start();
    if (srvInfo.getState() == ServerInformation.State.STARTUP && queue.replicateAllOnPluginStart) {
        ReplicationState state = new ReplicationState(ReplicationType.STARTUP);
        pushAllFuture.set(pushAll.create(null, state).schedule(30, TimeUnit.SECONDS));
    }
}
#end_block

#method_before
@Override
protected void run() throws Failure {
    if (all && projectNames.size() > 0) {
        throw new UnloggedFailure(1, "error: cannot combine --all and PROJECT");
    }
    ReplicationState state = new ReplicationState(this, ReplicationType.COMMAND);
    Future<?> future = null;
    if (all) {
        future = pushAllFactory.create(urlMatch, state).schedule(0, TimeUnit.SECONDS);
    } else {
        for (String name : projectNames) {
            Project.NameKey key = new Project.NameKey(name);
            if (projectCache.get(key) != null) {
                replication.scheduleFullSync(key, urlMatch, state);
            } else {
                writeStdErrSync("error: '" + name + "': not a Gerrit project");
            }
        }
        state.allTaskScheduled();
    }
    if (wait) {
        if (future != null) {
            try {
                future.get();
            } catch (InterruptedException e) {
                log.warn("Thread is interrupted while waiting for PushAll operation to finish", e);
            } catch (ExecutionException e) {
                log.warn("An excetion is thrown in PushAll operation", e);
            }
        }
        if (state.hasPushTask()) {
            state.waitForReplication();
        } else {
            writeStdOutSync("All things is up-to-date, no need to replicate!");
        }
    }
}
#method_after
@Override
protected void run() throws Failure {
    if (all && projectNames.size() > 0) {
        throw new UnloggedFailure(1, "error: cannot combine --all and PROJECT");
    }
    ReplicationState state = new ReplicationState(ReplicationType.COMMAND, this);
    Future<?> future = null;
    if (all) {
        future = pushAllFactory.create(urlMatch, state).schedule(0, TimeUnit.SECONDS);
    } else {
        for (String name : projectNames) {
            Project.NameKey key = new Project.NameKey(name);
            if (projectCache.get(key) != null) {
                replication.scheduleFullSync(key, urlMatch, state);
            } else {
                writeStdErrSync("error: '" + name + "': not a Gerrit project");
            }
        }
        state.markAllPushTasksScheduled();
    }
    if (wait) {
        if (future != null) {
            try {
                future.get();
            } catch (InterruptedException e) {
                wrappedLog.error("Thread was interrupted while waiting for PushAll operation to finish", e, state);
                return;
            } catch (ExecutionException e) {
                wrappedLog.error("An exception was thrown in PushAll operation", e, state);
                return;
            }
        }
        if (state.hasPushTask()) {
            try {
                state.waitForReplication();
            } catch (InterruptedException e) {
                writeStdErrSync("We are interrupted while waiting replication to complete");
            }
        } else {
            writeStdOutSync("Nothing to replicate");
        }
    }
}
#end_block

#method_before
public void writeStdOutSync(final String message) {
    synchronized (stdout) {
        stdout.println(message);
        stdout.flush();
    }
}
#method_after
public void writeStdOutSync(final String message) {
    if (wait) {
        synchronized (stdout) {
            stdout.println(message);
            stdout.flush();
        }
    }
}
#end_block

#method_before
public void writeStdErrSync(final String message) {
    synchronized (stderr) {
        stderr.println(message);
        stderr.flush();
    }
}
#method_after
public void writeStdErrSync(final String message) {
    if (wait) {
        synchronized (stderr) {
            stderr.println(message);
            stderr.flush();
        }
    }
}
#end_block

#method_before
static String replaceName(String in, String name) {
    String key = "${name}";
    int n = in.indexOf(key);
    if (0 <= n) {
        return in.substring(0, n) + name + in.substring(n + key.length());
    }
    return null;
}
#method_after
static String replaceName(String in, String name, boolean keyIsOptional) {
    String key = "${name}";
    int n = in.indexOf(key);
    if (0 <= n) {
        return in.substring(0, n) + name + in.substring(n + key.length());
    }
    if (keyIsOptional) {
        return in;
    }
    return null;
}
#end_block

#method_before
void scheduleFullSync(final Project.NameKey project, final String urlMatch, ReplicationState state) {
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    for (Destination cfg : configs) {
        for (URIish uri : cfg.getURIs(project, urlMatch)) {
            cfg.schedule(project, PushOne.ALL_REFS, uri, state);
        }
    }
}
#method_after
void scheduleFullSync(final Project.NameKey project, final String urlMatch, ReplicationState state) {
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    for (Destination cfg : configs) {
        if (cfg.wouldPushProject(project)) {
            for (URIish uri : cfg.getURIs(project, urlMatch)) {
                cfg.schedule(project, PushOne.ALL_REFS, uri, state);
            }
        }
    }
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(ReplicationType.GIT_UPDATED);
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (GitReferenceUpdatedListener.Update u : event.getUpdates()) {
        for (Destination cfg : configs) {
            if (cfg.wouldPushRef(u.getRefName())) {
                for (URIish uri : cfg.getURIs(project, null)) {
                    cfg.schedule(project, u.getRefName(), uri, state);
                }
            }
        }
    }
    state.allTaskScheduled();
}
#method_after
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(ReplicationType.GIT_UPDATED);
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (GitReferenceUpdatedListener.Update u : event.getUpdates()) {
        for (Destination cfg : configs) {
            if (cfg.wouldPushProject(project) && cfg.wouldPushRef(u.getRefName())) {
                for (URIish uri : cfg.getURIs(project, null)) {
                    cfg.schedule(project, u.getRefName(), uri, state);
                }
            }
        }
    }
    state.markAllPushTasksScheduled();
}
#end_block

#method_before
private List<Destination> allDestinations(File cfgPath) throws ConfigInvalidException, IOException {
    FileBasedConfig cfg = new FileBasedConfig(cfgPath, FS.DETECTED);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (cfg.getFile().length() == 0) {
        log.info("Empty " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", cfg.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", cfg.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = cfg.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, cfg.getFile()));
            }
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        dest.add(new Destination(injector, c, cfg, database, replicationUserFactory, internalUserFactory, gitRepositoryManager, groupBackend));
    }
    return dest.build();
}
#method_after
private List<Destination> allDestinations(File cfgPath) throws ConfigInvalidException, IOException {
    FileBasedConfig cfg = new FileBasedConfig(cfgPath, FS.DETECTED);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (cfg.getFile().length() == 0) {
        log.info("Empty " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", cfg.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", cfg.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = cfg.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        Destination destination = new Destination(injector, c, cfg, database, replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend);
        if (!destination.isSingleProjectMatch()) {
            for (URIish u : c.getURIs()) {
                if (u.getPath() == null || !u.getPath().contains("${name}")) {
                    throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, cfg.getFile()));
                }
            }
        }
        dest.add(destination);
    }
    return dest.build();
}
#end_block

#method_before
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    if (configs.isEmpty()) {
        return;
    }
    if (!running) {
        log.error("Replication plugin did not finish startup before event");
        return;
    }
    Project.NameKey projectName = new Project.NameKey(event.getProjectName());
    for (Destination config : configs) {
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            if (Strings.isNullOrEmpty(url)) {
                continue;
            }
            URIish uri;
            try {
                uri = new URIish(url);
            } catch (URISyntaxException e) {
                log.warn(String.format("adminURL '%s' is invalid: %s", url, e.getMessage()));
                continue;
            }
            String path = replaceName(uri.getPath(), projectName.get());
            if (path == null) {
                log.warn(String.format("adminURL %s does not contain ${name}", uri));
                continue;
            }
            uri = uri.setPath(path);
            if (!isSSH(uri)) {
                log.warn(String.format("adminURL '%s' is invalid: only SSH is supported", uri));
                continue;
            }
            createProject(uri, event.getHeadName());
            adminURLUsed = true;
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                createProject(uri, event.getHeadName());
            }
        }
    }
}
#method_after
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    if (configs.isEmpty()) {
        return;
    }
    if (!running) {
        log.error("Replication plugin did not finish startup before event");
        return;
    }
    Project.NameKey projectName = new Project.NameKey(event.getProjectName());
    for (Destination config : configs) {
        if (!config.wouldPushProject(projectName)) {
            continue;
        }
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            if (Strings.isNullOrEmpty(url)) {
                continue;
            }
            URIish uri;
            try {
                uri = new URIish(url);
            } catch (URISyntaxException e) {
                log.warn(String.format("adminURL '%s' is invalid: %s", url, e.getMessage()));
                continue;
            }
            String path = replaceName(uri.getPath(), projectName.get(), config.isSingleProjectMatch());
            if (path == null) {
                log.warn(String.format("adminURL %s does not contain ${name}", uri));
                continue;
            }
            uri = uri.setPath(path);
            if (!isSSH(uri)) {
                log.warn(String.format("adminURL '%s' is invalid: only SSH is supported", uri));
                continue;
            }
            createProject(uri, event.getHeadName());
            adminURLUsed = true;
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                createProject(uri, event.getHeadName());
            }
        }
    }
}
#end_block

#method_before
private void runPushOperation() {
    // Lock the queue, and remove ourselves, so we can't be modified once
    // we start replication (instead a new instance, with the same URI, is
    // created and scheduled for a future point in time.)
    // 
    pool.notifyStarting(this);
    // since the canceled flag would be set locking the queue.
    if (!canceled) {
        try {
            git = gitManager.openRepository(projectName);
            runImpl();
        } catch (RepositoryNotFoundException e) {
            wrappedLog.error("Cannot replicate " + projectName + "; " + e.getMessage(), getStatesAsArray());
        } catch (NoRemoteRepositoryException e) {
            wrappedLog.error("Cannot replicate to " + uri + "; repository not found", getStatesAsArray());
        } catch (NotSupportedException e) {
            wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
        } catch (TransportException e) {
            Throwable cause = e.getCause();
            if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
                log.error("Cannot replicate to " + uri + ": " + cause.getMessage());
            } else {
                log.error("Cannot replicate to " + uri, e);
            }
            // The remote push operation should be retried.
            pool.reschedule(this);
        } catch (IOException e) {
            wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
        } catch (RuntimeException e) {
            wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
        } catch (Error e) {
            wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
        } finally {
            if (git != null) {
                git.close();
            }
        }
    }
}
#method_after
private void runPushOperation() {
    // Lock the queue, and remove ourselves, so we can't be modified once
    // we start replication (instead a new instance, with the same URI, is
    // created and scheduled for a future point in time.)
    // 
    pool.notifyStarting(this);
    // since the canceled flag would be set locking the queue.
    if (!canceled) {
        try {
            git = gitManager.openRepository(projectName);
            runImpl();
        } catch (RepositoryNotFoundException e) {
            wrappedLog.error("Cannot replicate " + projectName + "; " + e.getMessage(), getStatesAsArray());
        } catch (RemoteRepositoryException e) {
            log.error("Cannot replicate " + projectName + "; " + e.getMessage());
        } catch (NoRemoteRepositoryException e) {
            wrappedLog.error("Cannot replicate to " + uri + "; repository not found", getStatesAsArray());
        } catch (NotSupportedException e) {
            wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
        } catch (TransportException e) {
            Throwable cause = e.getCause();
            if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
                log.error("Cannot replicate to " + uri + ": " + cause.getMessage());
            } else {
                log.error("Cannot replicate to " + uri, e);
            }
            // The remote push operation should be retried.
            pool.reschedule(this);
        } catch (IOException e) {
            wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
        } catch (RuntimeException e) {
            wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
        } catch (Error e) {
            wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
        } finally {
            if (git != null) {
                git.close();
            }
        }
    }
}
#end_block

#method_before
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = Maps.newHashMap();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        ReviewDb db;
        try {
            db = schema.open();
        } catch (OrmException e) {
            wrappedLog.error("Cannot read database to replicate to " + projectName, e, getStatesAsArray());
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(tagCache, git, pc, db, true).filter(local, true);
        } finally {
            db.close();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#method_after
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = Maps.newHashMap();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        ReviewDb db;
        try {
            db = schema.open();
        } catch (OrmException e) {
            wrappedLog.error("Cannot read database to replicate to " + projectName, e, getStatesAsArray());
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(tagCache, changeCache, git, pc, db, true).filter(local, true);
        } finally {
            db.close();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable() {

        {
            keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadSearch()) {

                @Override
                public void onKeyPress(final KeyPressEvent event) {
                    Gerrit.display(getToken());
                }
            });
        }
    };
    table.addStyleName(Gerrit.RESOURCES.css().accountDashboard());
    outgoing = new ChangeTable.Section();
    incoming = new ChangeTable.Section();
    closed = new ChangeTable.Section();
    outgoing.setTitleWidget(new InlineHyperlink(Util.C.outgoingReviews(), PageLinks.toChangeQuery("is:open owner:self")));
    incoming.setTitleWidget(new InlineHyperlink(Util.C.incomingReviews(), PageLinks.toChangeQuery("is:open reviewer:self -owner:self")));
    incoming.setHighlightUnreviewed(mine);
    closed.setTitleWidget(new InlineHyperlink(Util.C.recentlyClosed(), PageLinks.toChangeQuery("is:closed (owner:self OR reviewer:self)")));
    table.addSection(outgoing);
    table.addSection(incoming);
    table.addSection(closed);
    add(table);
    table.setSavePointerId("owner:" + ownerId);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable() {

        {
            keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadSearch()) {

                @Override
                public void onKeyPress(final KeyPressEvent event) {
                    Gerrit.display(getToken());
                }
            });
        }
    };
    table.addStyleName(Gerrit.RESOURCES.css().accountDashboard());
    outgoing = new ChangeTable.Section();
    incoming = new ChangeTable.Section();
    closed = new ChangeTable.Section();
    String who = mine ? "self" : ownerId.toString();
    outgoing.setTitleWidget(new InlineHyperlink(Util.C.outgoingReviews(), PageLinks.toChangeQuery(queryOutGoing(who))));
    incoming.setTitleWidget(new InlineHyperlink(Util.C.incomingReviews(), PageLinks.toChangeQuery(queryInComing(who))));
    incoming.setHighlightUnreviewed(mine);
    closed.setTitleWidget(new InlineHyperlink(Util.C.recentlyClosed(), PageLinks.toChangeQuery(queryClosed(who))));
    table.addSection(outgoing);
    table.addSection(incoming);
    table.addSection(closed);
    add(table);
    table.setSavePointerId("owner:" + ownerId);
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    String who = mine ? "self" : ownerId.toString();
    ChangeList.query(new ScreenLoadCallback<JsArray<ChangeList>>(this) {

        @Override
        protected void preDisplay(JsArray<ChangeList> result) {
            display(result);
        }
    }, mine ? EnumSet.of(ListChangesOption.REVIEWED) : EnumSet.noneOf(ListChangesOption.class), "is:open owner:" + who, "is:open reviewer:" + who + " -owner:" + who, "is:closed (owner:" + who + " OR reviewer:" + who + ") -age:4w limit:10");
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    String who = mine ? "self" : ownerId.toString();
    ChangeList.query(new ScreenLoadCallback<JsArray<ChangeList>>(this) {

        @Override
        protected void preDisplay(JsArray<ChangeList> result) {
            display(result);
        }
    }, mine ? EnumSet.of(ListChangesOption.REVIEWED) : EnumSet.noneOf(ListChangesOption.class), queryOutGoing(who), queryInComing(who), queryClosed(who) + " -age:4w limit:10");
}
#end_block

#method_before
@Test
public void testProjectCreation() throws Exception {
    Project.NameKey projectA = new Project.NameKey("projectA");
    repoManager.createRepository(projectA);
    assertThat(repoManager.openRepository(projectA)).isNotNull();
    assertThat((Iterable<?>) repoManager.list()).containsExactly(projectA);
}
#method_after
@Test
public void testProjectCreation() throws Exception {
    Project.NameKey projectA = new Project.NameKey("projectA");
    try (Repository repo = repoManager.createRepository(projectA)) {
        assertThat(repo).isNotNull();
    }
    try (Repository repo = repoManager.openRepository(projectA)) {
        assertThat(repo).isNotNull();
    }
    assertThat((Iterable<?>) repoManager.list()).containsExactly(projectA);
}
#end_block

#method_before
@Test
public void testOpenRepositoryCreatedDirectlyOnDisk() throws Exception {
    createRepository(repoManager.getBasePath(), "projectA");
    Project.NameKey projectA = new Project.NameKey("projectA");
    assertThat(repoManager.openRepository(projectA)).isNotNull();
    assertThat((Iterable<?>) repoManager.list()).containsExactly(projectA);
}
#method_after
@Test
public void testOpenRepositoryCreatedDirectlyOnDisk() throws Exception {
    createRepository(repoManager.getBasePath(), "projectA");
    Project.NameKey projectA = new Project.NameKey("projectA");
    try (Repository repo = repoManager.openRepository(projectA)) {
        assertThat(repo).isNotNull();
    }
    assertThat((Iterable<?>) repoManager.list()).containsExactly(projectA);
}
#end_block

#method_before
@Test
public void testGetSetProjectDescription() throws Exception {
    Project.NameKey projectA = new Project.NameKey("projectA");
    repoManager.createRepository(projectA);
    assertThat(repoManager.getProjectDescription(projectA)).isNull();
    repoManager.setProjectDescription(projectA, "projectA description");
    assertThat(repoManager.getProjectDescription(projectA)).isEqualTo("projectA description");
    repoManager.setProjectDescription(projectA, "");
    assertThat(repoManager.getProjectDescription(projectA)).isNull();
}
#method_after
@Test
public void testGetSetProjectDescription() throws Exception {
    Project.NameKey projectA = new Project.NameKey("projectA");
    try (Repository repo = repoManager.createRepository(projectA)) {
        assertThat(repo).isNotNull();
    }
    assertThat(repoManager.getProjectDescription(projectA)).isNull();
    repoManager.setProjectDescription(projectA, "projectA description");
    assertThat(repoManager.getProjectDescription(projectA)).isEqualTo("projectA description");
    repoManager.setProjectDescription(projectA, "");
    assertThat(repoManager.getProjectDescription(projectA)).isNull();
}
#end_block

#method_before
private void createRepository(Path directory, String projectName) throws IOException {
    String n = projectName + Constants.DOT_GIT_EXT;
    FileKey loc = FileKey.exact(directory.resolve(n).toFile(), FS.DETECTED);
    Repository db = RepositoryCache.open(loc, false);
    try {
        db.create(true);
    } finally {
        db.close();
    }
}
#method_after
private void createRepository(Path directory, String projectName) throws IOException {
    String n = projectName + Constants.DOT_GIT_EXT;
    FileKey loc = FileKey.exact(directory.resolve(n).toFile(), FS.DETECTED);
    try (Repository db = RepositoryCache.open(loc, false)) {
        db.create(true);
    }
}
#end_block

#method_before
void replay(GerritApi api) throws IOException, OrmException, NoSuchAccountException, BadRequestException {
    List<RevisionInfo> revisions = new ArrayList<>(changeInfo.revisions.values());
    sortRevisionInfoByNumber(revisions);
    List<PatchSet> patchSets = new ArrayList<>();
    db.changes().beginTransaction(change.getId());
    try {
        PatchSetInfo info = null;
        for (RevisionInfo r : revisions) {
            if (r.draft != null && r.draft) {
                // no import of draft patch sets
                continue;
            }
            PatchSet ps = new PatchSet(new PatchSet.Id(change.getId(), r._number));
            String newRef = ps.getId().toRefName();
            ObjectId newId = repo.resolve(newRef);
            String origRef = imported(r.ref);
            ObjectId id = repo.resolve(origRef);
            if (id == null) {
                continue;
            }
            RevCommit commit = rw.parseCommit(id);
            if (newId != null) {
                RevCommit newCommit = rw.parseCommit(newId);
                if (newCommit.equals(commit)) {
                    // already replayed
                    continue;
                } else {
                    // a patch set with the same number was created both in the source
                    // and in the target system
                    log.warn(String.format("[%s] Project %s was modified in target system: " + "Skip replay revision for patch set %s.", pluginName, change.getProject().get(), ps.getId().toString()));
                    continue;
                }
            }
            patchSets.add(ps);
            ps.setUploader(accountUtil.resolveUser(api, r.uploader));
            ps.setCreatedOn(r.created);
            ps.setRevision(new RevId(commit.name()));
            ps.setDraft(r.draft != null && r.draft);
            info = patchSetInfoFactory.get(commit, ps.getId());
            if (changeInfo.currentRevision.equals(info.getRevId())) {
                change.setCurrentPatchSet(info);
            }
            ChangeUtil.insertAncestors(db, ps.getId(), commit);
            updateRef(repo, ps);
        }
        if (change.currentPatchSetId() == null) {
            log.warn(String.format("[%s] Current revision %s of change %s not found." + " Setting last revision %s as current patch set.", pluginName, changeInfo.currentRevision, changeInfo.id, info.getRevId()));
            change.setCurrentPatchSet(info);
        }
        db.patchSets().insert(patchSets);
        db.commit();
    } finally {
        db.rollback();
    }
}
#method_after
void replay(GerritApi api) throws IOException, OrmException, NoSuchAccountException, BadRequestException {
    List<RevisionInfo> revisions = new ArrayList<>(changeInfo.revisions.values());
    sortRevisionInfoByNumber(revisions);
    List<PatchSet> patchSets = new ArrayList<>();
    db.changes().beginTransaction(change.getId());
    try {
        PatchSetInfo info = null;
        for (RevisionInfo r : revisions) {
            if (r.draft != null && r.draft) {
                // no import of draft patch sets
                continue;
            }
            PatchSet ps = new PatchSet(new PatchSet.Id(change.getId(), r._number));
            String newRef = ps.getId().toRefName();
            ObjectId newId = repo.resolve(newRef);
            String origRef = imported(r.ref);
            ObjectId id = repo.resolve(origRef);
            if (id == null) {
                continue;
            }
            RevCommit commit = rw.parseCommit(id);
            if (newId != null) {
                RevCommit newCommit = rw.parseCommit(newId);
                if (newCommit.equals(commit)) {
                    // already replayed
                    continue;
                } else {
                    // a patch set with the same number was created both in the source
                    // and in the target system
                    log.warn(String.format("[%s] Project %s was modified in target system: " + "Skip replay revision for patch set %s.", pluginName, change.getProject().get(), ps.getId().toString()));
                    continue;
                }
            }
            patchSets.add(ps);
            ps.setUploader(accountUtil.resolveUser(api, r.uploader));
            ps.setCreatedOn(r.created);
            ps.setRevision(new RevId(commit.name()));
            ps.setDraft(r.draft != null && r.draft);
            info = patchSetInfoFactory.get(commit, ps.getId());
            if (changeInfo.currentRevision.equals(info.getRevId())) {
                change.setCurrentPatchSet(info);
            }
            ChangeUtil.insertAncestors(db, ps.getId(), commit);
            updateRef(repo, ps);
        }
        if (change.currentPatchSetId() == null) {
            log.warn(String.format("[%s] Current revision %s of change %s not found." + " Setting lastest revision %s as current patch set.", pluginName, changeInfo.currentRevision, changeInfo.id, info.getRevId()));
            change.setCurrentPatchSet(info);
        }
        db.patchSets().insert(patchSets);
        db.commit();
    } finally {
        db.rollback();
    }
}
#end_block

#method_before
public void update() throws SubmoduleException {
    try {
        schema = schemaFactory.open();
        updateSubmoduleSubscriptions();
        updateSuperProjects(destBranch, rw, mergeTip.getId().toObjectId(), null);
    } catch (OrmException e) {
        throw new SubmoduleException("Cannot open database", e);
    } finally {
        if (schema != null) {
            schema.close();
            schema = null;
        }
    }
}
#method_after
public void update() throws SubmoduleException {
    try {
        schema = schemaFactory.open();
        updateSubmoduleSubscriptions();
        updateSuperProjects(destBranch, rw, mergeTip.getId().toObjectId(), null);
    } catch (OrmException | IOException e) {
        throw new SubmoduleException("Cannot open database", e);
    } finally {
        if (schema != null) {
            schema.close();
            schema = null;
        }
    }
}
#end_block

#method_before
private void updateSuperProjects(final Branch.NameKey updatedBranch, RevWalk myRw, final ObjectId mergedCommit, final String msg) throws SubmoduleException {
    try {
        final List<SubmoduleSubscription> subscribers = schema.submoduleSubscriptions().bySubmodule(updatedBranch).toList();
        if (!subscribers.isEmpty()) {
            // Initialize the message buffer
            StringBuilder sb = new StringBuilder();
            if (msg != null) {
                sb.append(msg);
            } else {
                // The first updatedBranch on a cascade event of automatic
                // updates of repos is added to updatedSubscribers set so
                // if we face a situation having
                // submodule-a(master)-->super(master)-->submodule-a(master),
                // it will be detected we have a circular subscription
                // when updateSuperProjects is called having as updatedBranch
                // the super(master) value.
                updatedSubscribers.add(updatedBranch);
                for (final Change chg : submitted) {
                    final CodeReviewCommit c = commits.get(chg.getId());
                    if (c != null && (c.getStatusCode() == CommitMergeStatus.CLEAN_MERGE || c.getStatusCode() == CommitMergeStatus.CLEAN_PICK || c.getStatusCode() == CommitMergeStatus.CLEAN_REBASE)) {
                        sb.append("\n").append(c.getFullMessage());
                    }
                }
            }
            // update subscribers of this module
            List<SubmoduleSubscription> incorrectSubscriptions = Lists.newLinkedList();
            for (final SubmoduleSubscription s : subscribers) {
                try {
                    if (!updatedSubscribers.add(s.getSuperProject())) {
                        log.error("Possible circular subscription involving " + s);
                    } else {
                        Map<Branch.NameKey, ObjectId> modules = new HashMap<>(1);
                        modules.put(updatedBranch, mergedCommit);
                        Map<Branch.NameKey, String> paths = new HashMap<>(1);
                        paths.put(updatedBranch, s.getPath());
                        updateGitlinks(s.getSuperProject(), myRw, modules, paths, sb.toString());
                    }
                } catch (SubmoduleException e) {
                    log.warn("Cannot update gitlinks for " + s + " due to " + e.getMessage());
                    incorrectSubscriptions.add(s);
                } catch (Exception e) {
                    log.error("Cannot update gitlinks for " + s, e);
                }
            }
            if (!incorrectSubscriptions.isEmpty()) {
                try {
                    schema.submoduleSubscriptions().delete(incorrectSubscriptions);
                    log.info("Deleted incorrect submodule subscription(s) " + incorrectSubscriptions);
                } catch (OrmException e) {
                    log.error("Cannot delete submodule subscription(s) " + incorrectSubscriptions, e);
                }
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#method_after
private void updateSuperProjects(final Branch.NameKey updatedBranch, RevWalk myRw, final ObjectId mergedCommit, final String msg) throws SubmoduleException, IOException {
    try {
        final List<SubmoduleSubscription> subscribers = schema.submoduleSubscriptions().bySubmodule(updatedBranch).toList();
        if (!subscribers.isEmpty()) {
            // Initialize the message buffer
            StringBuilder sb = new StringBuilder();
            if (msg != null) {
                sb.append(msg);
            } else {
                // The first updatedBranch on a cascade event of automatic
                // updates of repos is added to updatedSubscribers set so
                // if we face a situation having
                // submodule-a(master)-->super(master)-->submodule-a(master),
                // it will be detected we have a circular subscription
                // when updateSuperProjects is called having as updatedBranch
                // the super(master) value.
                updatedSubscribers.add(updatedBranch);
                for (final Change chg : submitted) {
                    final CodeReviewCommit c = commits.get(chg.getId());
                    if (c != null && (c.getStatusCode() == CommitMergeStatus.CLEAN_MERGE || c.getStatusCode() == CommitMergeStatus.CLEAN_PICK || c.getStatusCode() == CommitMergeStatus.CLEAN_REBASE)) {
                        myRw.parseBody(c);
                        sb.append("\n").append(c.getFullMessage());
                    }
                }
            }
            // update subscribers of this module
            List<SubmoduleSubscription> incorrectSubscriptions = Lists.newLinkedList();
            for (final SubmoduleSubscription s : subscribers) {
                try {
                    if (!updatedSubscribers.add(s.getSuperProject())) {
                        log.error("Possible circular subscription involving " + s);
                    } else {
                        Map<Branch.NameKey, ObjectId> modules = new HashMap<>(1);
                        modules.put(updatedBranch, mergedCommit);
                        Map<Branch.NameKey, String> paths = new HashMap<>(1);
                        paths.put(updatedBranch, s.getPath());
                        updateGitlinks(s.getSuperProject(), myRw, modules, paths, sb.toString());
                    }
                } catch (SubmoduleException e) {
                    log.warn("Cannot update gitlinks for " + s + " due to " + e.getMessage());
                    incorrectSubscriptions.add(s);
                } catch (Exception e) {
                    log.error("Cannot update gitlinks for " + s, e);
                }
            }
            if (!incorrectSubscriptions.isEmpty()) {
                try {
                    schema.submoduleSubscriptions().delete(incorrectSubscriptions);
                    log.info("Deleted incorrect submodule subscription(s) " + incorrectSubscriptions);
                } catch (OrmException e) {
                    log.error("Cannot delete submodule subscription(s) " + incorrectSubscriptions, e);
                }
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#end_block

#method_before
public void update() throws SubmoduleException {
    try {
        schema = schemaFactory.open();
        updateSubmoduleSubscriptions();
        updateSuperProjects(destBranch, rw, mergeTip.getId().toObjectId(), null);
    } catch (OrmException e) {
        throw new SubmoduleException("Cannot open database", e);
    } finally {
        if (schema != null) {
            schema.close();
            schema = null;
        }
    }
}
#method_after
public void update() throws SubmoduleException {
    try {
        schema = schemaFactory.open();
        updateSubmoduleSubscriptions();
        updateSuperProjects(destBranch, rw, mergeTip.getId().toObjectId(), null);
    } catch (OrmException | IOException e) {
        throw new SubmoduleException("Cannot open database", e);
    } finally {
        if (schema != null) {
            schema.close();
            schema = null;
        }
    }
}
#end_block

#method_before
private void updateSubmoduleSubscriptions() throws SubmoduleException {
    if (urlProvider.get() == null) {
        logAndThrowSubmoduleException("Cannot establish canonical web url used to access gerrit." + " It should be provided in gerrit.config file.");
    }
    try {
        final TreeWalk tw = TreeWalk.forPath(db, GIT_MODULES, mergeTip.getTree());
        if (tw != null && (FileMode.REGULAR_FILE.equals(tw.getRawMode(0)) || FileMode.EXECUTABLE_FILE.equals(tw.getRawMode(0)))) {
            BlobBasedConfig bbc = new BlobBasedConfig(null, db, mergeTip, GIT_MODULES);
            final String thisServer = new URI(urlProvider.get()).getHost();
            final Branch.NameKey target = new Branch.NameKey(new Project.NameKey(destProject.getName()), destBranch.get());
            final Set<SubmoduleSubscription> oldSubscriptions = new HashSet<>(schema.submoduleSubscriptions().bySuperProject(destBranch).toList());
            final List<SubmoduleSubscription> newSubscriptions = new SubmoduleSectionParser(bbc, thisServer, target, repoManager).parseAllSections();
            final Set<SubmoduleSubscription> alreadySubscribeds = new HashSet<>();
            for (SubmoduleSubscription s : newSubscriptions) {
                if (oldSubscriptions.contains(s)) {
                    alreadySubscribeds.add(s);
                }
            }
            oldSubscriptions.removeAll(newSubscriptions);
            newSubscriptions.removeAll(alreadySubscribeds);
            if (!oldSubscriptions.isEmpty()) {
                schema.submoduleSubscriptions().delete(oldSubscriptions);
            }
            schema.submoduleSubscriptions().insert(newSubscriptions);
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Database problem at update of subscriptions table from " + GIT_MODULES + " file.", e);
    } catch (ConfigInvalidException e) {
        logAndThrowSubmoduleException("Problem at update of subscriptions table: " + GIT_MODULES + " config file is invalid.", e);
    } catch (IOException e) {
        logAndThrowSubmoduleException("Problem at update of subscriptions table from " + GIT_MODULES + ".", e);
    } catch (URISyntaxException e) {
        logAndThrowSubmoduleException("Incorrect gerrit canonical web url provided in gerrit.config file.", e);
    }
}
#method_after
private void updateSubmoduleSubscriptions() throws SubmoduleException {
    if (urlProvider.get() == null) {
        logAndThrowSubmoduleException("Cannot establish canonical web url used to access gerrit." + " It should be provided in gerrit.config file.");
    }
    try {
        final TreeWalk tw = TreeWalk.forPath(db, GIT_MODULES, mergeTip.getTree());
        if (tw != null && (FileMode.REGULAR_FILE.equals(tw.getRawMode(0)) || FileMode.EXECUTABLE_FILE.equals(tw.getRawMode(0)))) {
            BlobBasedConfig bbc = new BlobBasedConfig(null, db, mergeTip, GIT_MODULES);
            final String thisServer = new URI(urlProvider.get()).getHost();
            final Branch.NameKey target = new Branch.NameKey(new Project.NameKey(destProject.getName()), destBranch.get());
            final Set<SubmoduleSubscription> oldSubscriptions = new HashSet<>(schema.submoduleSubscriptions().bySuperProject(destBranch).toList());
            List<SubmoduleSubscription> newSubscriptions = subSecParserFactory.create(bbc, thisServer, target).parseAllSections();
            final Set<SubmoduleSubscription> alreadySubscribeds = new HashSet<>();
            for (SubmoduleSubscription s : newSubscriptions) {
                if (oldSubscriptions.contains(s)) {
                    alreadySubscribeds.add(s);
                }
            }
            oldSubscriptions.removeAll(newSubscriptions);
            newSubscriptions.removeAll(alreadySubscribeds);
            if (!oldSubscriptions.isEmpty()) {
                schema.submoduleSubscriptions().delete(oldSubscriptions);
            }
            schema.submoduleSubscriptions().insert(newSubscriptions);
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Database problem at update of subscriptions table from " + GIT_MODULES + " file.", e);
    } catch (ConfigInvalidException e) {
        logAndThrowSubmoduleException("Problem at update of subscriptions table: " + GIT_MODULES + " config file is invalid.", e);
    } catch (IOException e) {
        logAndThrowSubmoduleException("Problem at update of subscriptions table from " + GIT_MODULES + ".", e);
    } catch (URISyntaxException e) {
        logAndThrowSubmoduleException("Incorrect gerrit canonical web url provided in gerrit.config file.", e);
    }
}
#end_block

#method_before
private void updateSuperProjects(final Branch.NameKey updatedBranch, RevWalk myRw, final ObjectId mergedCommit, final String msg) throws SubmoduleException {
    try {
        final List<SubmoduleSubscription> subscribers = schema.submoduleSubscriptions().bySubmodule(updatedBranch).toList();
        if (!subscribers.isEmpty()) {
            // Initialize the message buffer
            StringBuilder sb = new StringBuilder();
            if (msg != null) {
                sb.append(msg);
            } else {
                // The first updatedBranch on a cascade event of automatic
                // updates of repos is added to updatedSubscribers set so
                // if we face a situation having
                // submodule-a(master)-->super(master)-->submodule-a(master),
                // it will be detected we have a circular subscription
                // when updateSuperProjects is called having as updatedBranch
                // the super(master) value.
                updatedSubscribers.add(updatedBranch);
                for (final Change chg : submitted) {
                    final CodeReviewCommit c = commits.get(chg.getId());
                    if (c != null && (c.getStatusCode() == CommitMergeStatus.CLEAN_MERGE || c.getStatusCode() == CommitMergeStatus.CLEAN_PICK || c.getStatusCode() == CommitMergeStatus.CLEAN_REBASE)) {
                        try {
                            sb.append("\n").append(c.getFullMessage());
                        } catch (NullPointerException e) {
                            sb.append("\n").append("NPE");
                        }
                    }
                }
            }
            // update subscribers of this module
            List<SubmoduleSubscription> incorrectSubscriptions = Lists.newLinkedList();
            for (final SubmoduleSubscription s : subscribers) {
                try {
                    if (!updatedSubscribers.add(s.getSuperProject())) {
                        log.error("Possible circular subscription involving " + s);
                    } else {
                        Map<Branch.NameKey, ObjectId> modules = new HashMap<>(1);
                        modules.put(updatedBranch, mergedCommit);
                        Map<Branch.NameKey, String> paths = new HashMap<>(1);
                        paths.put(updatedBranch, s.getPath());
                        updateGitlinks(s.getSuperProject(), myRw, modules, paths, sb.toString());
                    }
                } catch (SubmoduleException e) {
                    log.warn("Cannot update gitlinks for " + s + " due to " + e.getMessage());
                    incorrectSubscriptions.add(s);
                } catch (Exception e) {
                    log.error("Cannot update gitlinks for " + s, e);
                }
            }
            if (!incorrectSubscriptions.isEmpty()) {
                try {
                    schema.submoduleSubscriptions().delete(incorrectSubscriptions);
                    log.info("Deleted incorrect submodule subscription(s) " + incorrectSubscriptions);
                } catch (OrmException e) {
                    log.error("Cannot delete submodule subscription(s) " + incorrectSubscriptions, e);
                }
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#method_after
private void updateSuperProjects(final Branch.NameKey updatedBranch, RevWalk myRw, final ObjectId mergedCommit, final String msg) throws SubmoduleException, IOException {
    try {
        final List<SubmoduleSubscription> subscribers = schema.submoduleSubscriptions().bySubmodule(updatedBranch).toList();
        if (!subscribers.isEmpty()) {
            // Initialize the message buffer
            StringBuilder sb = new StringBuilder();
            if (msg != null) {
                sb.append(msg);
            } else {
                // The first updatedBranch on a cascade event of automatic
                // updates of repos is added to updatedSubscribers set so
                // if we face a situation having
                // submodule-a(master)-->super(master)-->submodule-a(master),
                // it will be detected we have a circular subscription
                // when updateSuperProjects is called having as updatedBranch
                // the super(master) value.
                updatedSubscribers.add(updatedBranch);
                for (final Change chg : submitted) {
                    final CodeReviewCommit c = commits.get(chg.getId());
                    if (c != null && (c.getStatusCode() == CommitMergeStatus.CLEAN_MERGE || c.getStatusCode() == CommitMergeStatus.CLEAN_PICK || c.getStatusCode() == CommitMergeStatus.CLEAN_REBASE)) {
                        myRw.parseBody(c);
                        sb.append("\n").append(c.getFullMessage());
                    }
                }
            }
            // update subscribers of this module
            List<SubmoduleSubscription> incorrectSubscriptions = Lists.newLinkedList();
            for (final SubmoduleSubscription s : subscribers) {
                try {
                    if (!updatedSubscribers.add(s.getSuperProject())) {
                        log.error("Possible circular subscription involving " + s);
                    } else {
                        Map<Branch.NameKey, ObjectId> modules = new HashMap<>(1);
                        modules.put(updatedBranch, mergedCommit);
                        Map<Branch.NameKey, String> paths = new HashMap<>(1);
                        paths.put(updatedBranch, s.getPath());
                        updateGitlinks(s.getSuperProject(), myRw, modules, paths, sb.toString());
                    }
                } catch (SubmoduleException e) {
                    log.warn("Cannot update gitlinks for " + s + " due to " + e.getMessage());
                    incorrectSubscriptions.add(s);
                } catch (Exception e) {
                    log.error("Cannot update gitlinks for " + s, e);
                }
            }
            if (!incorrectSubscriptions.isEmpty()) {
                try {
                    schema.submoduleSubscriptions().delete(incorrectSubscriptions);
                    log.info("Deleted incorrect submodule subscription(s) " + incorrectSubscriptions);
                } catch (OrmException e) {
                    log.error("Cannot delete submodule subscription(s) " + incorrectSubscriptions, e);
                }
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#end_block

#method_before
private void updateGitlinks(final Branch.NameKey subscriber, RevWalk myRw, final Map<Branch.NameKey, ObjectId> modules, final Map<Branch.NameKey, String> paths, final String msg) throws SubmoduleException {
    PersonIdent author = null;
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append("Updated " + subscriber.getParentKey().get());
    Repository pdb = null;
    RevWalk recRw = null;
    try {
        boolean sameAuthorForAll = true;
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            RevCommit c = myRw.parseCommit(me.getValue());
            if (c == null) {
                continue;
            }
            msgbuf.append("\nProject: ");
            msgbuf.append(me.getKey().getParentKey().get());
            msgbuf.append("  ").append(me.getValue().getName());
            msgbuf.append("\n");
            if (modules.size() == 1) {
                if (!Strings.isNullOrEmpty(msg)) {
                    msgbuf.append(msg);
                } else {
                    msgbuf.append("\n");
                    msgbuf.append(c.getFullMessage());
                }
            } else {
                msgbuf.append(c.getShortMessage());
            }
            msgbuf.append("\n");
            if (author == null) {
                author = c.getAuthorIdent();
            } else if (!author.equals(c.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
        }
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            ed.add(new PathEdit(paths.get(me.getKey())) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(me.getValue().copy());
                }
            });
        }
        ed.finish();
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        final CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        recRw = new RevWalk(pdb);
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(subscriber, recRw, commitId, msgbuf.toString());
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (recRw != null) {
            recRw.release();
        }
        if (pdb != null) {
            pdb.close();
        }
    }
}
#method_after
private void updateGitlinks(final Branch.NameKey subscriber, RevWalk myRw, final Map<Branch.NameKey, ObjectId> modules, final Map<Branch.NameKey, String> paths, final String msg) throws SubmoduleException {
    PersonIdent author = null;
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append("Updated ").append(subscriber.getParentKey().get()).append('\n');
    Repository pdb = null;
    RevWalk recRw = null;
    try {
        boolean sameAuthorForAll = true;
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            RevCommit c = myRw.parseCommit(me.getValue());
            if (c == null) {
                continue;
            }
            msgbuf.append("\nProject: ");
            msgbuf.append(me.getKey().getParentKey().get());
            msgbuf.append("  ").append(me.getValue().getName());
            msgbuf.append("\n");
            if (modules.size() == 1) {
                if (!Strings.isNullOrEmpty(msg)) {
                    msgbuf.append(msg);
                } else {
                    msgbuf.append("\n");
                    msgbuf.append(c.getFullMessage());
                }
            } else {
                msgbuf.append(c.getShortMessage());
            }
            msgbuf.append("\n");
            if (author == null) {
                author = c.getAuthorIdent();
            } else if (!author.equals(c.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
        }
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            ed.add(new PathEdit(paths.get(me.getKey())) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(me.getValue().copy());
                }
            });
        }
        ed.finish();
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        final CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        recRw = new RevWalk(pdb);
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(subscriber, recRw, commitId, msgbuf.toString());
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (recRw != null) {
            recRw.close();
        }
        if (pdb != null) {
            pdb.close();
        }
    }
}
#end_block

#method_before
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final RevWalk rw = new RevWalk(pdb);
    try {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    } finally {
        rw.release();
    }
}
#method_after
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    try (RevWalk rw = new RevWalk(pdb)) {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(SearchingChangeCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(SearchingChangeCacheImpl.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Test
public void testDefaultSubmitTypeWhenNotConfigured() {
    assertEquals(SubmitType.MERGE_IF_NECESSARY, repoCfg.getDefaultSubmitType(new NameKey("someProject")));
}
#method_after
@Test
public void testDefaultSubmitTypeWhenNotConfigured() {
    assertThat(repoCfg.getDefaultSubmitType(new NameKey("someProject"))).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
}
#end_block

#method_before
@Test
public void testDefaultSubmitTypeForStarFilter() {
    configureDefaultSubmitType("*", SubmitType.CHERRY_PICK);
    assertEquals(SubmitType.CHERRY_PICK, repoCfg.getDefaultSubmitType(new NameKey("someProject")));
    configureDefaultSubmitType("*", SubmitType.FAST_FORWARD_ONLY);
    assertEquals(SubmitType.FAST_FORWARD_ONLY, repoCfg.getDefaultSubmitType(new NameKey("someProject")));
    configureDefaultSubmitType("*", SubmitType.REBASE_IF_NECESSARY);
    assertEquals(SubmitType.REBASE_IF_NECESSARY, repoCfg.getDefaultSubmitType(new NameKey("someProject")));
}
#method_after
@Test
public void testDefaultSubmitTypeForStarFilter() {
    configureDefaultSubmitType("*", SubmitType.CHERRY_PICK);
    assertThat(repoCfg.getDefaultSubmitType(new NameKey("someProject"))).isEqualTo(SubmitType.CHERRY_PICK);
    configureDefaultSubmitType("*", SubmitType.FAST_FORWARD_ONLY);
    assertThat(repoCfg.getDefaultSubmitType(new NameKey("someProject"))).isEqualTo(SubmitType.FAST_FORWARD_ONLY);
    configureDefaultSubmitType("*", SubmitType.REBASE_IF_NECESSARY);
    assertThat(repoCfg.getDefaultSubmitType(new NameKey("someProject"))).isEqualTo(SubmitType.REBASE_IF_NECESSARY);
}
#end_block

#method_before
@Test
public void testDefaultSubmitTypeForSpecificFilter() {
    configureDefaultSubmitType("someProject", SubmitType.CHERRY_PICK);
    assertEquals(SubmitType.MERGE_IF_NECESSARY, repoCfg.getDefaultSubmitType(new NameKey("someOtherProject")));
    assertEquals(SubmitType.CHERRY_PICK, repoCfg.getDefaultSubmitType(new NameKey("someProject")));
}
#method_after
@Test
public void testDefaultSubmitTypeForSpecificFilter() {
    configureDefaultSubmitType("someProject", SubmitType.CHERRY_PICK);
    assertThat(repoCfg.getDefaultSubmitType(new NameKey("someOtherProject"))).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    assertThat(repoCfg.getDefaultSubmitType(new NameKey("someProject"))).isEqualTo(SubmitType.CHERRY_PICK);
}
#end_block

#method_before
@Test
public void testDefaultSubmitTypeForStartWithFilter() {
    configureDefaultSubmitType("somePath/somePath/*", SubmitType.REBASE_IF_NECESSARY);
    configureDefaultSubmitType("somePath/*", SubmitType.CHERRY_PICK);
    configureDefaultSubmitType("*", SubmitType.MERGE_ALWAYS);
    assertEquals(SubmitType.MERGE_ALWAYS, repoCfg.getDefaultSubmitType(new NameKey("someProject")));
    assertEquals(SubmitType.CHERRY_PICK, repoCfg.getDefaultSubmitType(new NameKey("somePath/someProject")));
    assertEquals(SubmitType.REBASE_IF_NECESSARY, repoCfg.getDefaultSubmitType(new NameKey("somePath/somePath/someProject")));
}
#method_after
@Test
public void testDefaultSubmitTypeForStartWithFilter() {
    configureDefaultSubmitType("somePath/somePath/*", SubmitType.REBASE_IF_NECESSARY);
    configureDefaultSubmitType("somePath/*", SubmitType.CHERRY_PICK);
    configureDefaultSubmitType("*", SubmitType.MERGE_ALWAYS);
    assertThat(repoCfg.getDefaultSubmitType(new NameKey("someProject"))).isEqualTo(SubmitType.MERGE_ALWAYS);
    assertThat(repoCfg.getDefaultSubmitType(new NameKey("somePath/someProject"))).isEqualTo(SubmitType.CHERRY_PICK);
    assertThat(repoCfg.getDefaultSubmitType(new NameKey("somePath/somePath/someProject"))).isEqualTo(SubmitType.REBASE_IF_NECESSARY);
}
#end_block

#method_before
@Test
public void testOwnerGroupsWhenNotConfigured() {
    assertArrayEquals(new String[] {}, repoCfg.getOwnerGroups(new NameKey("someProject")));
}
#method_after
@Test
public void testOwnerGroupsWhenNotConfigured() {
    assertThat(repoCfg.getOwnerGroups(new NameKey("someProject"))).isEqualTo(new String[] {});
}
#end_block

#method_before
@Test
public void testOwnerGroupsForStarFilter() {
    String[] ownerGroups = new String[] { "group1", "group2" };
    configureOwnerGroups("*", Lists.newArrayList(ownerGroups));
    assertArrayEquals(ownerGroups, repoCfg.getOwnerGroups(new NameKey("someProject")));
}
#method_after
@Test
public void testOwnerGroupsForStarFilter() {
    String[] ownerGroups = new String[] { "group1", "group2" };
    configureOwnerGroups("*", Lists.newArrayList(ownerGroups));
    assertThat(repoCfg.getOwnerGroups(new NameKey("someProject"))).isEqualTo(ownerGroups);
}
#end_block

#method_before
@Test
public void testOwnerGroupsForSpecificFilter() {
    String[] ownerGroups = new String[] { "group1", "group2" };
    configureOwnerGroups("someProject", Lists.newArrayList(ownerGroups));
    assertArrayEquals(new String[] {}, repoCfg.getOwnerGroups(new NameKey("someOtherProject")));
    assertArrayEquals(ownerGroups, repoCfg.getOwnerGroups(new NameKey("someProject")));
}
#method_after
@Test
public void testOwnerGroupsForSpecificFilter() {
    String[] ownerGroups = new String[] { "group1", "group2" };
    configureOwnerGroups("someProject", Lists.newArrayList(ownerGroups));
    assertThat(repoCfg.getOwnerGroups(new NameKey("someOtherProject"))).isEqualTo(new String[] {});
    assertThat(repoCfg.getOwnerGroups(new NameKey("someProject"))).isEqualTo(ownerGroups);
}
#end_block

#method_before
@Test
public void testOwnerGroupsForStartWithFilter() {
    String[] ownerGroups1 = new String[] { "group1" };
    String[] ownerGroups2 = new String[] { "group2" };
    String[] ownerGroups3 = new String[] { "group3" };
    configureOwnerGroups("*", Lists.newArrayList(ownerGroups1));
    configureOwnerGroups("somePath/*", Lists.newArrayList(ownerGroups2));
    configureOwnerGroups("somePath/somePath/*", Lists.newArrayList(ownerGroups3));
    assertArrayEquals(ownerGroups1, repoCfg.getOwnerGroups(new NameKey("someProject")));
    assertArrayEquals(ownerGroups2, repoCfg.getOwnerGroups(new NameKey("somePath/someProject")));
    assertArrayEquals(ownerGroups3, repoCfg.getOwnerGroups(new NameKey("somePath/somePath/someProject")));
}
#method_after
@Test
public void testOwnerGroupsForStartWithFilter() {
    String[] ownerGroups1 = new String[] { "group1" };
    String[] ownerGroups2 = new String[] { "group2" };
    String[] ownerGroups3 = new String[] { "group3" };
    configureOwnerGroups("*", Lists.newArrayList(ownerGroups1));
    configureOwnerGroups("somePath/*", Lists.newArrayList(ownerGroups2));
    configureOwnerGroups("somePath/somePath/*", Lists.newArrayList(ownerGroups3));
    assertThat(repoCfg.getOwnerGroups(new NameKey("someProject"))).isEqualTo(ownerGroups1);
    assertThat(repoCfg.getOwnerGroups(new NameKey("somePath/someProject"))).isEqualTo(ownerGroups2);
    assertThat(repoCfg.getOwnerGroups(new NameKey("somePath/somePath/someProject"))).isEqualTo(ownerGroups3);
}
#end_block

#method_before
private static Predicate<ChangeData> topic(String topic) {
    return new TopicPredicate(schema(args.indexes), topic);
}
#method_after
private Predicate<ChangeData> topic(String topic) {
    return new TopicPredicate(schema(indexes), topic);
}
#end_block

#method_before
private void updateGitlinks(final Branch.NameKey subscriber, RevWalk myRw, final Map<Branch.NameKey, ObjectId> modules, final Map<Branch.NameKey, String> paths, final String msg) throws SubmoduleException {
    PersonIdent author = null;
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append("Updated " + subscriber.getParentKey().get() + "\n");
    Repository pdb = null;
    RevWalk recRw = null;
    try {
        boolean sameAuthorForAll = true;
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            RevCommit c = myRw.parseCommit(me.getValue());
            if (c == null) {
                continue;
            }
            msgbuf.append("\nProject: ");
            msgbuf.append(me.getKey().getParentKey().get());
            msgbuf.append("  ").append(me.getValue().getName());
            msgbuf.append("\n");
            if (modules.size() == 1) {
                if (!Strings.isNullOrEmpty(msg)) {
                    msgbuf.append(msg);
                } else {
                    msgbuf.append("\n");
                    msgbuf.append(c.getFullMessage());
                }
            } else {
                msgbuf.append(c.getShortMessage());
            }
            msgbuf.append("\n");
            if (author == null) {
                author = c.getAuthorIdent();
            } else if (!author.equals(c.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
        }
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            ed.add(new PathEdit(paths.get(me.getKey())) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(me.getValue().copy());
                }
            });
        }
        ed.finish();
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        final CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        recRw = new RevWalk(pdb);
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(subscriber, recRw, commitId, msgbuf.toString());
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (recRw != null) {
            recRw.close();
        }
        if (pdb != null) {
            pdb.close();
        }
    }
}
#method_after
private void updateGitlinks(final Branch.NameKey subscriber, RevWalk myRw, final Map<Branch.NameKey, ObjectId> modules, final Map<Branch.NameKey, String> paths, final String msg) throws SubmoduleException {
    PersonIdent author = null;
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append("Updated ").append(subscriber.getParentKey().get()).append('\n');
    Repository pdb = null;
    RevWalk recRw = null;
    try {
        boolean sameAuthorForAll = true;
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            RevCommit c = myRw.parseCommit(me.getValue());
            if (c == null) {
                continue;
            }
            msgbuf.append("\nProject: ");
            msgbuf.append(me.getKey().getParentKey().get());
            msgbuf.append("  ").append(me.getValue().getName());
            msgbuf.append("\n");
            if (modules.size() == 1) {
                if (!Strings.isNullOrEmpty(msg)) {
                    msgbuf.append(msg);
                } else {
                    msgbuf.append("\n");
                    msgbuf.append(c.getFullMessage());
                }
            } else {
                msgbuf.append(c.getShortMessage());
            }
            msgbuf.append("\n");
            if (author == null) {
                author = c.getAuthorIdent();
            } else if (!author.equals(c.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
        }
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            ed.add(new PathEdit(paths.get(me.getKey())) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(me.getValue().copy());
                }
            });
        }
        ed.finish();
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        final CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        recRw = new RevWalk(pdb);
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(subscriber, recRw, commitId, msgbuf.toString());
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (recRw != null) {
            recRw.close();
        }
        if (pdb != null) {
            pdb.close();
        }
    }
}
#end_block

#method_before
@Override
protected void run() throws OrmException, IOException, UnloggedFailure, ValidationException, GitAPIException, NoSuchChangeException, NoSuchAccountException {
    ImportProject.Input input = new ImportProject.Input();
    input.from = url;
    input.name = name;
    input.user = user;
    input.pass = readPassword();
    if (!Strings.isNullOrEmpty(parent)) {
        input.parent = parent;
    }
    try {
        ImportProject importer = importProjectFactory.create(new Project.NameKey(project));
        if (!quiet) {
            importer.setErr(stderr);
        }
        ImportStatistic stats = importer.apply(new ConfigResource(), input);
        stdout.print("Created Changes: " + stats.numChangesCreated + "\n");
    } catch (RestApiException e) {
        throw die(e.getMessage());
    }
}
#method_after
@Override
protected void run() throws OrmException, IOException, UnloggedFailure, ValidationException, GitAPIException, NoSuchChangeException, NoSuchAccountException {
    ImportProject.Input input = new ImportProject.Input();
    input.from = url;
    input.name = name;
    input.user = user;
    input.pass = PasswordUtil.readPassword(in, pass);
    if (!Strings.isNullOrEmpty(parent)) {
        input.parent = parent;
    }
    try {
        ImportProject importer = importProjectFactory.create(new Project.NameKey(project));
        if (!quiet) {
            importer.setErr(stderr);
        }
        ImportStatistic stats = importer.apply(new ConfigResource(), input);
        stdout.print("Created Changes: " + stats.numChangesCreated + "\n");
    } catch (RestApiException e) {
        throw die(e.getMessage());
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    try {
        ImportProjectResource rsrc = projects.parse(project);
        if (!quiet) {
            resume.setErr(stderr);
        }
        ResumeProjectImport.Input input = new ResumeProjectImport.Input();
        input.user = user;
        input.pass = readPassword();
        input.force = force;
        ResumeImportStatistic stats = resume.apply(rsrc, input);
        stdout.print("Created Changes: " + stats.numChangesCreated + "\n");
        stdout.print("Updated Changes: " + stats.numChangesUpdated + "\n");
    } catch (RestApiException e) {
        throw die(e.getMessage());
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    try {
        ImportProjectResource rsrc = projects.parse(project);
        if (!quiet) {
            resume.setErr(stderr);
        }
        ResumeProjectImport.Input input = new ResumeProjectImport.Input();
        input.user = user;
        input.pass = PasswordUtil.readPassword(in, pass);
        input.force = force;
        ResumeImportStatistic stats = resume.apply(rsrc, input);
        stdout.print("Created Changes: " + stats.numChangesCreated + "\n");
        stdout.print("Updated Changes: " + stats.numChangesUpdated + "\n");
    } catch (RestApiException e) {
        throw die(e.getMessage());
    }
}
#end_block

#method_before
private RevWalk verifyConnected(final Repository repo, final ObjectId revid) throws InvalidRevisionException {
    try {
        final ObjectWalk rw = new ObjectWalk(repo);
        try {
            rw.markStart(rw.parseCommit(revid));
        } catch (IncorrectObjectTypeException err) {
            throw new InvalidRevisionException();
        }
        RefDatabase refDb = repo.getRefDatabase();
        for (Ref r : Iterables.concat(refDb.getRefs(Constants.R_HEADS).values(), refDb.getRefs(Constants.R_TAGS).values())) {
            try {
                rw.markUninteresting(rw.parseAny(r.getObjectId()));
            } catch (MissingObjectException err) {
                continue;
            }
        }
        rw.checkConnectivity();
        return rw;
    } catch (IncorrectObjectTypeException err) {
        throw new InvalidRevisionException();
    } catch (MissingObjectException err) {
        throw new InvalidRevisionException();
    } catch (IOException err) {
        log.error("Repository \"" + repo.getDirectory() + "\" may be corrupt; suggest running git fsck", err);
        throw new InvalidRevisionException();
    }
}
#method_after
private RevWalk verifyConnected(final Repository repo, final ObjectId revid) throws InvalidRevisionException {
    try {
        final ObjectWalk rw = new ObjectWalk(repo);
        try {
            rw.markStart(rw.parseCommit(revid));
        } catch (IncorrectObjectTypeException err) {
            throw new InvalidRevisionException();
        }
        RefDatabase refDb = repo.getRefDatabase();
        Iterable<Ref> refs = Iterables.concat(refDb.getRefs(Constants.R_HEADS).values(), refDb.getRefs(Constants.R_TAGS).values());
        Ref rc = refDb.getRef(RefNames.REFS_CONFIG);
        if (rc != null) {
            refs = Iterables.concat(refs, Collections.singleton(rc));
        }
        for (Ref r : refs) {
            try {
                rw.markUninteresting(rw.parseAny(r.getObjectId()));
            } catch (MissingObjectException err) {
                continue;
            }
        }
        rw.checkConnectivity();
        return rw;
    } catch (IncorrectObjectTypeException err) {
        throw new InvalidRevisionException();
    } catch (MissingObjectException err) {
        throw new InvalidRevisionException();
    } catch (IOException err) {
        log.error("Repository \"" + repo.getDirectory() + "\" may be corrupt; suggest running git fsck", err);
        throw new InvalidRevisionException();
    }
}
#end_block

#method_before
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException {
    boolean link = req.getParameter("link") != null;
    String id = Strings.nullToEmpty(req.getParameter("id")).trim();
    if (id.isEmpty()) {
        sendForm(req, res, link, null);
        return;
    }
    if (!id.startsWith("http://") && !id.startsWith("https://")) {
        id = "http://" + id;
    }
    if ((ssoUrl != null && !ssoUrl.equals(id)) || !impl.isAllowedOpenID(id)) {
        sendForm(req, res, link, "OpenID provider not permitted by site policy.");
        return;
    }
    boolean remember = "1".equals(req.getParameter("rememberme"));
    String token = LoginUrlToken.getToken(req);
    SignInMode mode;
    if (link) {
        mode = SignInMode.LINK_IDENTIY;
    } else if (PageLinks.REGISTER.equals(token)) {
        mode = SignInMode.REGISTER;
        token = PageLinks.MINE;
    } else {
        mode = SignInMode.SIGN_IN;
    }
    OAuthServiceProvider oauthProvider = lookupOAuthServiceProvider(id);
    if (oauthProvider == null) {
        discover(req, res, link, id, remember, token, mode);
    } else {
        OAuthSessionOverOpenID oauthSession = oauthSessionProvider.get();
        if ((isGerritLogin(req) || oauthSession.isOAuthFinal(req)) && !oauthSession.isLoggedIn()) {
            oauthSession.setServiceProvider(oauthProvider);
            oauthSession.login(req, res, oauthProvider);
        }
    }
}
#method_after
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException {
    boolean link = req.getParameter("link") != null;
    String id = Strings.nullToEmpty(req.getParameter("id")).trim();
    if (id.isEmpty()) {
        sendForm(req, res, link, null);
        return;
    }
    if (!id.startsWith("http://") && !id.startsWith("https://")) {
        id = "http://" + id;
    }
    if ((ssoUrl != null && !ssoUrl.equals(id)) || !impl.isAllowedOpenID(id)) {
        sendForm(req, res, link, "OpenID provider not permitted by site policy.");
        return;
    }
    boolean remember = "1".equals(req.getParameter("rememberme"));
    String token = LoginUrlToken.getToken(req);
    SignInMode mode;
    if (link) {
        mode = SignInMode.LINK_IDENTIY;
    } else if (PageLinks.REGISTER.equals(token)) {
        mode = SignInMode.REGISTER;
        token = PageLinks.MINE;
    } else {
        mode = SignInMode.SIGN_IN;
    }
    OAuthServiceProvider oauthProvider = lookupOAuthServiceProvider(id);
    if (oauthProvider == null) {
        discover(req, res, link, id, remember, token, mode);
    } else {
        OAuthSessionOverOpenID oauthSession = oauthSessionProvider.get();
        if (!currentUserProvider.get().isIdentifiedUser() && oauthSession.isLoggedIn()) {
            oauthSession.logout();
        }
        if ((isGerritLogin(req) || oauthSession.isOAuthFinal(req)) && !oauthSession.isLoggedIn()) {
            oauthSession.setServiceProvider(oauthProvider);
            oauthSession.login(req, res, oauthProvider);
        }
    }
}
#end_block

#method_before
private void pickSSOServiceProvider() throws ServletException {
    SortedSet<String> plugins = oauthServiceProviders.plugins();
    if (plugins.isEmpty()) {
        throw new ServletException("OAuth service provider wasn't installed");
    }
    if (plugins.size() == 1) {
        SortedMap<String, Provider<OAuthServiceProvider>> services = oauthServiceProviders.byPlugin(Iterables.getOnlyElement(plugins));
        if (services.size() == 1) {
            ssoProvider = Iterables.getOnlyElement(services.values()).get();
        }
    }
}
#method_after
private void pickSSOServiceProvider() throws ServletException {
    SortedSet<String> plugins = oauthServiceProviders.plugins();
    if (plugins.size() == 1) {
        SortedMap<String, Provider<OAuthServiceProvider>> services = oauthServiceProviders.byPlugin(Iterables.getOnlyElement(plugins));
        if (services.size() == 1) {
            ssoProvider = Iterables.getOnlyElement(services.values()).get();
        }
    }
}
#end_block

#method_before
boolean login(HttpServletRequest request, HttpServletResponse response, OAuthServiceProvider oauth) throws IOException {
    if (isLoggedIn()) {
        return true;
    }
    log.debug("Login " + this);
    if (isOAuthFinal(request)) {
        if (!checkState(request)) {
            response.sendError(HttpServletResponse.SC_NOT_FOUND);
            return false;
        }
        log.debug("Login-Retrieve-User " + this);
        token = oauth.getAccessToken(null, new OAuthVerifier(request.getParameter("code")));
        user = oauth.getUserInfo(token);
        if (isLoggedIn()) {
            log.debug("Login-SUCCESS " + this);
            authenticateAndRedirect(response);
            return true;
        } else {
            response.sendError(SC_UNAUTHORIZED);
            return false;
        }
    } else {
        log.debug("Login-PHASE1 " + this);
        redirectUrl = request.getRequestURI();
        response.sendRedirect(oauth.getAuthorizationUrl(null) + "&state=" + state);
        return false;
    }
}
#method_after
boolean login(HttpServletRequest request, HttpServletResponse response, OAuthServiceProvider oauth) throws IOException {
    if (isLoggedIn()) {
        return true;
    }
    log.debug("Login " + this);
    if (isOAuthFinal(request)) {
        if (!checkState(request)) {
            response.sendError(HttpServletResponse.SC_NOT_FOUND);
            return false;
        }
        log.debug("Login-Retrieve-User " + this);
        token = oauth.getAccessToken(new OAuthVerifier(request.getParameter("code")));
        user = oauth.getUserInfo(token);
        if (isLoggedIn()) {
            log.debug("Login-SUCCESS " + this);
            authenticateAndRedirect(request, response);
            return true;
        } else {
            response.sendError(SC_UNAUTHORIZED);
            return false;
        }
    } else {
        log.debug("Login-PHASE1 " + this);
        redirectToken = LoginUrlToken.getToken(request);
        response.sendRedirect(oauth.getAuthorizationUrl() + "&state=" + state);
        return false;
    }
}
#end_block

#method_before
private void authenticateAndRedirect(HttpServletResponse rsp) throws IOException {
    com.google.gerrit.server.account.AuthRequest areq = new com.google.gerrit.server.account.AuthRequest(user.getExternalId());
    AuthResult arsp = null;
    try {
        String claimedIdentifier = user.getClaimedIdentity();
        Account.Id actualId = accountManager.lookup(user.getExternalId());
        if (!Strings.isNullOrEmpty(claimedIdentifier)) {
            Account.Id claimedId = accountManager.lookup(claimedIdentifier);
            if (claimedId != null && actualId != null) {
                if (claimedId.equals(actualId)) {
                // Both link to the same account, that's what we expected.
                } else {
                    // This is (for now) a fatal error. There are two records
                    // for what might be the same user.
                    // 
                    log.error("OAuth accounts disagree over user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier + "\n" + "  Delgate ID: " + actualId + " is " + user.getExternalId());
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            } else if (claimedId != null && actualId == null) {
                // 
                try {
                    accountManager.link(claimedId, areq);
                } catch (OrmException e) {
                    log.error("Cannot link: " + user.getExternalId() + " to user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier);
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            }
        }
        areq.setUserName(user.getUserName());
        areq.setEmailAddress(user.getEmailAddress());
        areq.setDisplayName(user.getDisplayName());
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    webSession.get().login(arsp, true);
    String suffix = redirectUrl.substring(GERRIT_LOGIN.length() + 1);
    suffix = URLDecoder.decode(suffix, StandardCharsets.UTF_8.name());
    rsp.sendRedirect(suffix);
}
#method_after
private void authenticateAndRedirect(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    com.google.gerrit.server.account.AuthRequest areq = new com.google.gerrit.server.account.AuthRequest(user.getExternalId());
    AuthResult arsp = null;
    try {
        String claimedIdentifier = user.getClaimedIdentity();
        Account.Id actualId = accountManager.lookup(user.getExternalId());
        if (!Strings.isNullOrEmpty(claimedIdentifier)) {
            Account.Id claimedId = accountManager.lookup(claimedIdentifier);
            if (claimedId != null && actualId != null) {
                if (claimedId.equals(actualId)) {
                // Both link to the same account, that's what we expected.
                } else {
                    // This is (for now) a fatal error. There are two records
                    // for what might be the same user.
                    // 
                    log.error("OAuth accounts disagree over user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier + "\n" + "  Delgate ID: " + actualId + " is " + user.getExternalId());
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            } else if (claimedId != null && actualId == null) {
                // 
                try {
                    accountManager.link(claimedId, areq);
                } catch (OrmException e) {
                    log.error("Cannot link: " + user.getExternalId() + " to user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier);
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            }
        }
        areq.setUserName(user.getUserName());
        areq.setEmailAddress(user.getEmailAddress());
        areq.setDisplayName(user.getDisplayName());
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    webSession.get().login(arsp, true);
    StringBuilder rdr = new StringBuilder(urlProvider.get(req));
    rdr.append(Url.decode(redirectToken));
    rsp.sendRedirect(rdr.toString());
}
#end_block

#method_before
void logout() {
    token = null;
    user = null;
    redirectUrl = null;
    serviceProvider = null;
}
#method_after
void logout() {
    token = null;
    user = null;
    redirectToken = null;
    serviceProvider = null;
}
#end_block

#method_before
public Optional<ChangeEdit> byChange(Change change, IdentifiedUser user) throws IOException {
    try (Repository repo = gitManager.openRepository(change.getProject())) {
        String editRefPrefix = RefNames.editRefPrefix(user.getAccountId(), change.getId());
        Map<String, Ref> refs = repo.getRefDatabase().getRefs(editRefPrefix);
        if (refs.isEmpty()) {
            return Optional.absent();
        }
        // TODO(davido): Rather than failing when we encounter the corrupt state
        // where there is more than one ref, we could silently delete all but the
        // current one.
        Ref ref = Iterables.getOnlyElement(refs.values());
        try (RevWalk rw = new RevWalk(repo)) {
            RevCommit commit = rw.parseCommit(ref.getObjectId());
            PatchSet basePs = getBasePatchSet(change, ref);
            return Optional.of(new ChangeEdit(user, change, ref, commit, basePs));
        }
    }
}
#method_after
public Optional<ChangeEdit> byChange(Change change, IdentifiedUser user) throws IOException {
    try (Repository repo = gitManager.openRepository(change.getProject())) {
        String editRefPrefix = RefNames.refsEditPrefix(user.getAccountId(), change.getId());
        Map<String, Ref> refs = repo.getRefDatabase().getRefs(editRefPrefix);
        if (refs.isEmpty()) {
            return Optional.absent();
        }
        // TODO(davido): Rather than failing when we encounter the corrupt state
        // where there is more than one ref, we could silently delete all but the
        // current one.
        Ref ref = Iterables.getOnlyElement(refs.values());
        try (RevWalk rw = new RevWalk(repo)) {
            RevCommit commit = rw.parseCommit(ref.getObjectId());
            PatchSet basePs = getBasePatchSet(change, ref);
            return Optional.of(new ChangeEdit(user, change, ref, commit, basePs));
        }
    }
}
#end_block

#method_before
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, RefNames.editRefName(currentUser.getAccountId(), change.getId(), newPatchSet.getId()));
}
#method_after
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, RefNames.refsEdit(currentUser.getAccountId(), change.getId(), newPatchSet.getId()));
}
#end_block

#method_before
public RefUpdate.Result createEdit(Change change, PatchSet ps) throws AuthException, IOException, ResourceConflictException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    String refPrefix = RefNames.editRefPrefix(me.getAccountId(), change.getId());
    try (Repository repo = gitManager.openRepository(change.getProject())) {
        Map<String, Ref> refs = repo.getRefDatabase().getRefs(refPrefix);
        if (!refs.isEmpty()) {
            throw new ResourceConflictException("edit already exists");
        }
        try (RevWalk rw = new RevWalk(repo)) {
            ObjectId revision = ObjectId.fromString(ps.getRevision().get());
            String editRefName = RefNames.editRefName(me.getAccountId(), change.getId(), ps.getId());
            return update(repo, me, editRefName, rw, ObjectId.zeroId(), revision);
        }
    }
}
#method_after
public RefUpdate.Result createEdit(Change change, PatchSet ps) throws AuthException, IOException, ResourceConflictException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    String refPrefix = RefNames.refsEditPrefix(me.getAccountId(), change.getId());
    try (Repository repo = gitManager.openRepository(change.getProject())) {
        Map<String, Ref> refs = repo.getRefDatabase().getRefs(refPrefix);
        if (!refs.isEmpty()) {
            throw new ResourceConflictException("edit already exists");
        }
        try (RevWalk rw = new RevWalk(repo)) {
            ObjectId revision = ObjectId.fromString(ps.getRevision().get());
            String editRefName = RefNames.refsEdit(me.getAccountId(), change.getId(), ps.getId());
            return update(repo, me, editRefName, rw, ObjectId.zeroId(), revision);
        }
    }
}
#end_block

#method_before
public void rebaseEdit(ChangeEdit edit, PatchSet current) throws AuthException, ResourceConflictException, InvalidChangeOperationException, IOException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    Change change = edit.getChange();
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    String refName = RefNames.editRefName(me.getAccountId(), change.getId(), current.getId());
    try (Repository repo = gitManager.openRepository(change.getProject());
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter()) {
        BatchRefUpdate ru = repo.getRefDatabase().newBatchUpdate();
        RevCommit editCommit = edit.getEditCommit();
        if (editCommit.getParentCount() == 0) {
            throw new InvalidChangeOperationException("Rebase edit against root commit not supported");
        }
        RevCommit tip = rw.parseCommit(ObjectId.fromString(current.getRevision().get()));
        ThreeWayMerger m = MergeStrategy.RESOLVE.newMerger(repo, true);
        m.setObjectInserter(inserter);
        m.setBase(ObjectId.fromString(edit.getBasePatchSet().getRevision().get()));
        if (m.merge(tip, editCommit)) {
            ObjectId tree = m.getResultTreeId();
            CommitBuilder commit = new CommitBuilder();
            commit.setTreeId(tree);
            for (int i = 0; i < tip.getParentCount(); i++) {
                commit.addParentId(tip.getParent(i));
            }
            commit.setAuthor(editCommit.getAuthorIdent());
            commit.setCommitter(new PersonIdent(editCommit.getCommitterIdent(), TimeUtil.nowTs()));
            commit.setMessage(editCommit.getFullMessage());
            ObjectId newEdit = inserter.insert(commit);
            inserter.flush();
            ru.addCommand(new ReceiveCommand(ObjectId.zeroId(), newEdit, refName));
            ru.addCommand(new ReceiveCommand(edit.getRef().getObjectId(), ObjectId.zeroId(), edit.getRefName()));
            ru.execute(rw, NullProgressMonitor.INSTANCE);
            for (ReceiveCommand cmd : ru.getCommands()) {
                if (cmd.getResult() != ReceiveCommand.Result.OK) {
                    throw new IOException("failed: " + cmd);
                }
            }
        } else {
            // TODO(davido): Allow to resolve conflicts inline
            throw new ResourceConflictException("merge conflict");
        }
    }
}
#method_after
public void rebaseEdit(ChangeEdit edit, PatchSet current) throws AuthException, ResourceConflictException, InvalidChangeOperationException, IOException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    Change change = edit.getChange();
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    String refName = RefNames.refsEdit(me.getAccountId(), change.getId(), current.getId());
    try (Repository repo = gitManager.openRepository(change.getProject());
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter()) {
        BatchRefUpdate ru = repo.getRefDatabase().newBatchUpdate();
        RevCommit editCommit = edit.getEditCommit();
        if (editCommit.getParentCount() == 0) {
            throw new InvalidChangeOperationException("Rebase edit against root commit not supported");
        }
        RevCommit tip = rw.parseCommit(ObjectId.fromString(current.getRevision().get()));
        ThreeWayMerger m = MergeStrategy.RESOLVE.newMerger(repo, true);
        m.setObjectInserter(inserter);
        m.setBase(ObjectId.fromString(edit.getBasePatchSet().getRevision().get()));
        if (m.merge(tip, editCommit)) {
            ObjectId tree = m.getResultTreeId();
            CommitBuilder commit = new CommitBuilder();
            commit.setTreeId(tree);
            for (int i = 0; i < tip.getParentCount(); i++) {
                commit.addParentId(tip.getParent(i));
            }
            commit.setAuthor(editCommit.getAuthorIdent());
            commit.setCommitter(new PersonIdent(editCommit.getCommitterIdent(), TimeUtil.nowTs()));
            commit.setMessage(editCommit.getFullMessage());
            ObjectId newEdit = inserter.insert(commit);
            inserter.flush();
            ru.addCommand(new ReceiveCommand(ObjectId.zeroId(), newEdit, refName));
            ru.addCommand(new ReceiveCommand(edit.getRef().getObjectId(), ObjectId.zeroId(), edit.getRefName()));
            ru.execute(rw, NullProgressMonitor.INSTANCE);
            for (ReceiveCommand cmd : ru.getCommands()) {
                if (cmd.getResult() != ReceiveCommand.Result.OK) {
                    throw new IOException("failed: " + cmd);
                }
            }
        } else {
            // TODO(davido): Allow to resolve conflicts inline
            throw new ResourceConflictException("merge conflict");
        }
    }
}
#end_block

#method_before
@Test
public void changeEditRef() throws Exception {
    Account.Id accountId = new Account.Id(1000042);
    Change.Id changeId = new Change.Id(56414);
    PatchSet.Id psId = new PatchSet.Id(changeId, 50);
    String refName = RefNames.editRefName(accountId, changeId, psId);
    assertEquals("refs/users/42/1000042/edit-56414/50", refName);
}
#method_after
@Test
public void changeEditRef() throws Exception {
    Account.Id accountId = new Account.Id(1000042);
    Change.Id changeId = new Change.Id(56414);
    PatchSet.Id psId = new PatchSet.Id(changeId, 50);
    String refName = RefNames.refsEdit(accountId, changeId, psId);
    assertEquals("refs/users/42/1000042/edit-56414/50", refName);
}
#end_block

#method_before
public String getRefName() {
    return RefNames.editRefName(user.getAccountId(), change.getId(), basePatchSet.getId());
}
#method_after
public String getRefName() {
    return RefNames.refsEdit(user.getAccountId(), change.getId(), basePatchSet.getId());
}
#end_block

#method_before
private PrologEnvironment getPrologEnvironment(CurrentUser user) throws RuleEvalException {
    checkState(patchSet != null, "getPrologEnvironment() called before initPatchSet()");
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (rule == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new ByteArrayInputStream(rule.getBytes(UTF_8)));
        }
    } catch (CompileException err) {
        String msg;
        if (rule == null && control.getProjectControl().isOwner()) {
            msg = String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage());
        } else if (rule != null) {
            msg = err.getMessage();
        } else {
            msg = String.format("Cannot load rules.pl for %s", getProjectName());
        }
        throw new RuleEvalException(msg, err);
    }
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.PATCH_SET, patchSet);
    env.set(StoredValues.CHANGE_CONTROL, control);
    if (user != null) {
        env.set(StoredValues.CURRENT_USER, user);
    }
    return env;
}
#method_after
private PrologEnvironment getPrologEnvironment(CurrentUser user) throws RuleEvalException {
    checkState(patchSet != null, "getPrologEnvironment() called before initPatchSet()");
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (rule == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new StringReader(rule));
        }
    } catch (CompileException err) {
        String msg;
        if (rule == null && control.getProjectControl().isOwner()) {
            msg = String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage());
        } else if (rule != null) {
            msg = err.getMessage();
        } else {
            msg = String.format("Cannot load rules.pl for %s", getProjectName());
        }
        throw new RuleEvalException(msg, err);
    }
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.PATCH_SET, patchSet);
    env.set(StoredValues.CHANGE_CONTROL, control);
    if (user != null) {
        env.set(StoredValues.CURRENT_USER, user);
    }
    return env;
}
#end_block

#method_before
boolean login(HttpServletRequest request, HttpServletResponse response, OAuthServiceProvider oauth) throws IOException {
    if (isLoggedIn()) {
        return true;
    }
    log.debug("Login " + this);
    if (isOAuthFinal(request)) {
        if (!checkState(request)) {
            response.sendError(HttpServletResponse.SC_NOT_FOUND);
            return false;
        }
        log.debug("Login-Retrieve-User " + this);
        token = oauth.getAccessToken(new OAuthVerifier(request.getParameter("code")));
        user = oauth.getUserInfo(token);
        if (isLoggedIn()) {
            log.debug("Login-SUCCESS " + this);
            authenticateAndRedirect(request, response);
            return true;
        } else {
            response.sendError(SC_UNAUTHORIZED);
            return false;
        }
    } else {
        log.debug("Login-PHASE1 " + this);
        redirectToken = request.getRequestURI();
        // We are here in content of filter.
        // Due to this Jetty bug:
        // https://bz.apache.org/bugzilla/show_bug.cgi?id=28323
        // we cannot use LoginUrlToken.getToken() method,
        // because it relies on getPathInfo() and it is always null here.
        redirectToken = redirectToken.substring(request.getContextPath().length());
        response.sendRedirect(oauth.getAuthorizationUrl() + "&state=" + state);
        return false;
    }
}
#method_after
boolean login(HttpServletRequest request, HttpServletResponse response, OAuthServiceProvider oauth) throws IOException {
    if (isLoggedIn()) {
        return true;
    }
    log.debug("Login " + this);
    if (isOAuthFinal(request)) {
        if (!checkState(request)) {
            response.sendError(HttpServletResponse.SC_NOT_FOUND);
            return false;
        }
        log.debug("Login-Retrieve-User " + this);
        token = oauth.getAccessToken(new OAuthVerifier(request.getParameter("code")));
        user = oauth.getUserInfo(token);
        if (isLoggedIn()) {
            log.debug("Login-SUCCESS " + this);
            authenticateAndRedirect(request, response);
            return true;
        } else {
            response.sendError(SC_UNAUTHORIZED);
            return false;
        }
    } else {
        log.debug("Login-PHASE1 " + this);
        redirectToken = request.getRequestURI();
        // We are here in content of filter.
        // Due to this Jetty limitation:
        // https://bz.apache.org/bugzilla/show_bug.cgi?id=28323
        // we cannot use LoginUrlToken.getToken() method,
        // because it relies on getPathInfo() and it is always null here.
        redirectToken = redirectToken.substring(request.getContextPath().length());
        response.sendRedirect(oauth.getAuthorizationUrl() + "&state=" + state);
        return false;
    }
}
#end_block

#method_before
public TestAccount get(String username) {
    TestAccount account = accounts.get(username);
    checkArgument(account != null, "No TestAccount created for %s", username);
    return account;
}
#method_after
public TestAccount get(String username) {
    return checkNotNull(accounts.get(username), "No TestAccount created for %s", username);
}
#end_block

#method_before
@Override
public Boolean load(EntryKey key) throws NoSuchProjectException, MergeException, IOException {
    checkArgument(key.load != null, "Key cannot be loaded: %s", key);
    if (key.into.equals(ObjectId.zeroId())) {
        // Assume yes on new branch.
        return true;
    }
    try {
        RefDatabase refDatabase = key.load.repo.getRefDatabase();
        Map<String, Ref> heads = refDatabase.getRefs(Constants.R_HEADS);
        Map<String, Ref> tags = refDatabase.getRefs(Constants.R_TAGS);
        RevWalk rw = CodeReviewCommit.newRevWalk(key.load.repo);
        try {
            RevFlag canMerge = rw.newFlag("CAN_MERGE");
            CodeReviewCommit rev = parse(rw, key.commit);
            rev.add(canMerge);
            CodeReviewCommit tip = parse(rw, key.into);
            Set<RevCommit> accepted = alreadyAccepted(rw, heads.values(), tags.values());
            accepted.add(tip);
            accepted.addAll(Arrays.asList(rev.getParents()));
            return submitStrategyFactory.create(key.submitType, key.load.db, key.load.repo, rw, null, /*inserter*/
            canMerge, accepted, key.load.dest).dryRun(tip, rev);
        } finally {
            rw.release();
        }
    } finally {
        key.load = null;
    }
}
#method_after
@Override
public Boolean load(EntryKey key) throws NoSuchProjectException, MergeException, IOException {
    checkArgument(key.load != null, "Key cannot be loaded: %s", key);
    if (key.into.equals(ObjectId.zeroId())) {
        // Assume yes on new branch.
        return true;
    }
    try {
        RefDatabase refDatabase = key.load.repo.getRefDatabase();
        Iterable<Ref> refs = Iterables.concat(refDatabase.getRefs(Constants.R_HEADS).values(), refDatabase.getRefs(Constants.R_TAGS).values());
        try (RevWalk rw = CodeReviewCommit.newRevWalk(key.load.repo)) {
            RevFlag canMerge = rw.newFlag("CAN_MERGE");
            CodeReviewCommit rev = parse(rw, key.commit);
            rev.add(canMerge);
            CodeReviewCommit tip = parse(rw, key.into);
            Set<RevCommit> accepted = alreadyAccepted(rw, refs);
            accepted.add(tip);
            accepted.addAll(Arrays.asList(rev.getParents()));
            return submitStrategyFactory.create(key.submitType, key.load.db, key.load.repo, rw, null, /*inserter*/
            canMerge, accepted, key.load.dest).dryRun(tip, rev);
        }
    } finally {
        key.load = null;
    }
}
#end_block

#method_before
private static Set<RevCommit> alreadyAccepted(RevWalk rw, Collection<Ref> heads, Collection<Ref> tags) throws MissingObjectException, IOException {
    Set<RevCommit> accepted = Sets.newHashSet();
    addAlreadyAccepted(rw, heads, accepted);
    addAlreadyAccepted(rw, tags, accepted);
    return accepted;
}
#method_after
private static Set<RevCommit> alreadyAccepted(RevWalk rw, Iterable<Ref> refs) throws MissingObjectException, IOException {
    Set<RevCommit> accepted = Sets.newHashSet();
    for (Ref r : refs) {
        try {
            accepted.add(rw.parseCommit(r.getObjectId()));
        } catch (IncorrectObjectTypeException nonCommit) {
        // Not a commit? Skip over it.
        }
    }
    return accepted;
}
#end_block

#method_before
@Override
public boolean getIfPresent(ObjectId commit, Ref intoRef, SubmitType submitType, String mergeStrategy) {
    return cache.getIfPresent(new EntryKey(commit, toId(intoRef), submitType, mergeStrategy));
}
#method_after
@Override
public Boolean getIfPresent(ObjectId commit, Ref intoRef, SubmitType submitType, String mergeStrategy) {
    return cache.getIfPresent(new EntryKey(commit, toId(intoRef), submitType, mergeStrategy));
}
#end_block

#method_before
@Override
public ProjectApi create(ProjectInput in) throws RestApiException {
    try {
        if (name == null) {
            throw new ResourceConflictException("Project already exists");
        }
        if (in.name != null && !name.equals(in.name)) {
            throw new BadRequestException("name must match input.name");
        }
        checkRequiresCapability(user, null, CreateProject.class);
        createProjectFactory.get().create(name).apply(TopLevelResource.INSTANCE, in);
        return projectApi.create(projects.parse(name));
    } catch (BadRequestException | UnprocessableEntityException | ResourceNotFoundException | IOException | ConfigInvalidException e) {
        throw new RestApiException("Cannot create project: " + e.getMessage(), e);
    }
}
#method_after
@Override
public ProjectApi create(ProjectInput in) throws RestApiException {
    try {
        if (name == null) {
            throw new ResourceConflictException("Project already exists");
        }
        if (in.name != null && !name.equals(in.name)) {
            throw new BadRequestException("name must match input.name");
        }
        checkRequiresCapability(user, null, CreateProject.class);
        createProjectFactory.get().create(name).apply(TopLevelResource.INSTANCE, in);
        return projectApi.create(projects.parse(name));
    } catch (IOException | ConfigInvalidException e) {
        throw new RestApiException("Cannot create project: " + e.getMessage(), e);
    }
}
#end_block

#method_before
private FileHeader toFileHeader(PatchListKey key, final DiffFormatter diffFormatter, final DiffEntry diffEntry) throws IOException {
    Future<FileHeader> result = diffExecutor.submit(new Callable<FileHeader>() {

        @Override
        public FileHeader call() throws IOException {
            return diffFormatter.toFileHeader(diffEntry);
        }
    });
    try {
        return result.get(timeoutMillis, TimeUnit.MILLISECONDS);
    } catch (InterruptedException | TimeoutException e) {
        log.warn(timeoutMillis + " ms timeout reached for Diff loader" + " in project " + key.projectKey.get() + " on commit " + key.getNewId() + " on path " + diffEntry.getNewPath() + " comparing " + diffEntry.getOldId() + ".." + diffEntry.getNewId());
        result.cancel(true);
        return toFileHeaderWithoutMyersDiff(diffFormatter, diffEntry);
    } catch (ExecutionException e) {
        // If there was an error computing the result, carry it
        // up to the caller so the cache knows this key is invalid.
        Throwables.propagateIfInstanceOf(e.getCause(), IOException.class);
        throw new IOException(e.getMessage(), e.getCause());
    }
}
#method_after
private FileHeader toFileHeader(PatchListKey key, final DiffFormatter diffFormatter, final DiffEntry diffEntry) throws IOException {
    Future<FileHeader> result = diffExecutor.submit(new Callable<FileHeader>() {

        @Override
        public FileHeader call() throws IOException {
            return diffFormatter.toFileHeader(diffEntry);
        }
    });
    try {
        return result.get(timeoutMillis, TimeUnit.MILLISECONDS);
    } catch (InterruptedException | TimeoutException e) {
        log.warn(timeoutMillis + " ms timeout reached for Diff loader" + " in project " + key.projectKey.get() + " on commit " + key.getNewId().name() + " on path " + diffEntry.getNewPath() + " comparing " + diffEntry.getOldId().name() + ".." + diffEntry.getNewId().name());
        result.cancel(true);
        return toFileHeaderWithoutMyersDiff(diffFormatter, diffEntry);
    } catch (ExecutionException e) {
        // If there was an error computing the result, carry it
        // up to the caller so the cache knows this key is invalid.
        Throwables.propagateIfInstanceOf(e.getCause(), IOException.class);
        throw new IOException(e.getMessage(), e.getCause());
    }
}
#end_block

#method_before
@Override
public synchronized void stop() {
    if (daemonAcceptor != null) {
        try {
            daemonAcceptor.dispose();
            log.info("Stopped Gerrit SSHD");
        } finally {
            daemonAcceptor = null;
        }
    }
}
#method_after
@Override
public synchronized void stop() {
    if (daemonAcceptor != null) {
        try {
            daemonAcceptor.close(true).await();
            log.info("Stopped Gerrit SSHD");
        } catch (InterruptedException e) {
            log.warn("Exception caught while closing", e);
        } finally {
            daemonAcceptor = null;
        }
    }
}
#end_block

#method_before
@Override
public int random(int arg0) {
    // TODO Auto-generated method stub
    return 0;
}
#method_after
@Override
public int random(int n) {
    // TODO Auto-generated method stub
    return 0;
}
#end_block

#method_before
static GerritServer start(Config cfg, boolean memory, boolean enableHttpd) throws Exception {
    final CyclicBarrier serverStarted = new CyclicBarrier(2);
    final Daemon daemon = new Daemon(new Runnable() {

        public void run() {
            try {
                serverStarted.await();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } catch (BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
        }
    });
    ExecutorService daemonService = null;
    if (memory) {
        mergeTestConfig(cfg);
        cfg.setBoolean("httpd", null, "requestLog", false);
        cfg.setBoolean("sshd", null, "requestLog", false);
        cfg.setBoolean("index", "lucene", "testInmemory", true);
        cfg.setString("gitweb", null, "cgi", "");
        daemon.setEnableHttpd(enableHttpd);
        daemon.setLuceneModule(new LuceneIndexModule(ChangeSchemas.getLatest().getVersion(), Runtime.getRuntime().availableProcessors(), null));
        daemon.setDatabaseForTesting(ImmutableList.<Module>of(new InMemoryTestingDatabaseModule(cfg)));
        daemon.start();
    } else {
        final File site = initSite(cfg);
        daemonService = Executors.newSingleThreadExecutor();
        daemonService.submit(new Callable<Void>() {

            public Void call() throws Exception {
                int rc = daemon.main(new String[] { "-d", site.getPath(), "--headless" });
                if (rc != 0) {
                    System.out.println("Failed to start Gerrit daemon. Check " + site.getPath() + "/logs/error_log");
                    serverStarted.reset();
                }
                return null;
            }
        });
        serverStarted.await();
        System.out.println("Gerrit Server Started");
    }
    Injector i = createTestInjector(daemon);
    return new GerritServer(i, daemon, daemonService);
}
#method_after
static GerritServer start(Description desc, Config baseConfig) throws Exception {
    Config cfg = desc.buildConfig(baseConfig);
    Logger.getLogger("com.google.gerrit").setLevel(Level.DEBUG);
    final CyclicBarrier serverStarted = new CyclicBarrier(2);
    final Daemon daemon = new Daemon(new Runnable() {

        @Override
        public void run() {
            try {
                serverStarted.await();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } catch (BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
        }
    });
    final File site;
    ExecutorService daemonService = null;
    if (desc.memory()) {
        site = null;
        mergeTestConfig(cfg);
        cfg.setBoolean("httpd", null, "requestLog", false);
        cfg.setBoolean("sshd", null, "requestLog", false);
        cfg.setBoolean("index", "lucene", "testInmemory", true);
        cfg.setString("gitweb", null, "cgi", "");
        daemon.setEnableHttpd(desc.httpd());
        daemon.setLuceneModule(new LuceneIndexModule(ChangeSchemas.getLatest().getVersion(), 0, null));
        daemon.setDatabaseForTesting(ImmutableList.<Module>of(new InMemoryTestingDatabaseModule(cfg)));
        daemon.start();
    } else {
        site = initSite(cfg);
        daemonService = Executors.newSingleThreadExecutor();
        daemonService.submit(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                int rc = daemon.main(new String[] { "-d", site.getPath(), "--headless" });
                if (rc != 0) {
                    System.out.println("Failed to start Gerrit daemon. Check " + site.getPath() + "/logs/error_log");
                    serverStarted.reset();
                }
                return null;
            }
        });
        serverStarted.await();
        System.out.println("Gerrit Server Started");
    }
    Injector i = createTestInjector(daemon);
    return new GerritServer(desc, i, daemon, daemonService);
}
#end_block

#method_before
private static void mergeTestConfig(Config cfg) throws IOException {
    String forceEphemeralPort = String.format("%s:0", getLocalHost().getHostName());
    String url = "http://" + forceEphemeralPort + "/";
    cfg.setString("gerrit", null, "canonicalWebUrl", url);
    cfg.setString("httpd", null, "listenUrl", url);
    cfg.setString("sshd", null, "listenAddress", forceEphemeralPort);
    cfg.setString("cache", null, "directory", null);
    cfg.setString("gerrit", null, "basePath", "git");
    cfg.setBoolean("sendemail", null, "enable", false);
    cfg.setInt("cache", "projects", "checkFrequency", 0);
    cfg.setInt("plugins", null, "checkFrequency", 0);
}
#method_after
private static void mergeTestConfig(Config cfg) {
    String forceEphemeralPort = String.format("%s:0", getLocalHost().getHostName());
    String url = "http://" + forceEphemeralPort + "/";
    cfg.setString("gerrit", null, "canonicalWebUrl", url);
    cfg.setString("httpd", null, "listenUrl", url);
    cfg.setString("sshd", null, "listenAddress", forceEphemeralPort);
    cfg.setBoolean("sshd", null, "testUseInsecureRandom", true);
    cfg.setString("cache", null, "directory", null);
    cfg.setString("gerrit", null, "basePath", "git");
    cfg.setBoolean("sendemail", null, "enable", false);
    cfg.setInt("cache", "projects", "checkFrequency", 0);
    cfg.setInt("plugins", null, "checkFrequency", 0);
    cfg.setInt("sshd", null, "threads", 1);
    cfg.setInt("sshd", null, "commandStartThreads", 1);
    cfg.setInt("receive", null, "threadPoolSize", 1);
    cfg.setInt("index", null, "threads", 1);
}
#end_block

#method_before
private static InetAddress getLocalHost() throws UnknownHostException {
    return InetAddress.getLoopbackAddress();
}
#method_after
private static InetAddress getLocalHost() {
    return InetAddress.getLoopbackAddress();
}
#end_block

#method_before
private void beforeTest(Config cfg, boolean hasCustomConfig, boolean memory, boolean enableHttpd) throws Exception {
    if (hasCustomConfig) {
        server = GerritServer.start(cfg, memory, enableHttpd);
    } else {
        if (commonServer == null) {
            commonServer = GerritServer.start(cfg, memory, enableHttpd);
        }
        server = commonServer;
    }
    server.getTestInjector().injectMembers(this);
    admin = accounts.admin();
    user = accounts.user();
    adminSession = new RestSession(server, admin);
    userSession = new RestSession(server, user);
    initSsh(admin);
    db = reviewDbProvider.open();
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    sshSession = ctx.getSession();
    project = new Project.NameKey("p");
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
}
#method_after
private void beforeTest(Description description) throws Exception {
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    if (classDesc.equals(methodDesc)) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    admin = accounts.admin();
    user = accounts.user();
    adminSession = new RestSession(server, admin);
    userSession = new RestSession(server, user);
    initSsh(admin);
    db = reviewDbProvider.open();
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    sshSession = ctx.getSession();
    sshSession.open();
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, sshSession);
}
#end_block

#method_before
private void afterTest(boolean hasCustomConfig) throws Exception {
    db.close();
    sshSession.close();
    if (hasCustomConfig) {
        server.stop();
    } else {
        server.clearAllData();
    }
}
#method_after
private void afterTest() throws Exception {
    db.close();
    sshSession.close();
    if (server != commonServer) {
        server.stop();
    }
}
#end_block

#method_before
protected PushOneCommit.Result createChange() throws GitAPIException, IOException {
    PushOneCommit push = pushFactory.create(db, admin.getIdent());
    return push.to(git, "refs/for/master");
}
#method_after
protected PushOneCommit.Result createChange() throws Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo);
    return push.to("refs/for/master");
}
#end_block

#method_before
protected PushOneCommit.Result amendChange(String changeId) throws GitAPIException, IOException {
    Collections.shuffle(RANDOM);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), PushOneCommit.SUBJECT, PushOneCommit.FILE_NAME, new String(Chars.toArray(RANDOM)), changeId);
    return push.to(git, "refs/for/master");
}
#method_after
protected PushOneCommit.Result amendChange(String changeId) throws Exception {
    return amendChange(changeId, "refs/for/master");
}
#end_block

#method_before
protected PushOneCommit.Result amendChange(String changeId) throws GitAPIException, IOException {
    Collections.shuffle(RANDOM);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), PushOneCommit.SUBJECT, PushOneCommit.FILE_NAME, new String(Chars.toArray(RANDOM)), changeId);
    return push.to(git, "refs/for/master");
}
#method_after
protected PushOneCommit.Result amendChange(String changeId, String ref) throws Exception {
    Collections.shuffle(RANDOM);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, PushOneCommit.FILE_NAME, new String(Chars.toArray(RANDOM)), changeId);
    return push.to(ref);
}
#end_block

#method_before
protected ChangeInfo get(String id, ListChangesOption... options) throws RestApiException {
    EnumSet<ListChangesOption> s = EnumSet.noneOf(ListChangesOption.class);
    s.addAll(Arrays.asList(options));
    return gApi.changes().id(id).get(s);
}
#method_after
protected ChangeInfo get(String id, ListChangesOption... options) throws RestApiException {
    return gApi.changes().id(id).get(Sets.newEnumSet(Arrays.asList(options), ListChangesOption.class));
}
#end_block

#method_before
static GerritServer start(Description desc, Config baseConfig) throws Exception {
    Config cfg = desc.buildConfig(baseConfig);
    Logger.getLogger("com.google.gerrit").setLevel(Level.DEBUG);
    final CyclicBarrier serverStarted = new CyclicBarrier(2);
    final Daemon daemon = new Daemon(new Runnable() {

        @Override
        public void run() {
            try {
                serverStarted.await();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } catch (BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
        }
    });
    final File site;
    ExecutorService daemonService = null;
    if (desc.memory()) {
        site = null;
        mergeTestConfig(cfg);
        cfg.setBoolean("httpd", null, "requestLog", false);
        cfg.setBoolean("sshd", null, "requestLog", false);
        cfg.setBoolean("index", "lucene", "testInmemory", true);
        cfg.setString("gitweb", null, "cgi", "");
        daemon.setEnableHttpd(desc.httpd());
        daemon.setLuceneModule(new LuceneIndexModule(ChangeSchemas.getLatest().getVersion(), 0, null));
        daemon.setDatabaseForTesting(ImmutableList.<Module>of(new InMemoryTestingDatabaseModule(cfg)));
        daemon.start();
    } else {
        site = initSite(cfg);
        daemonService = Executors.newSingleThreadExecutor();
        daemonService.submit(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                int rc = daemon.main(new String[] { "-d", site.getPath(), "--headless" });
                if (rc != 0) {
                    System.out.println("Failed to start Gerrit daemon. Check " + site.getPath() + "/logs/error_log");
                    serverStarted.reset();
                }
                return null;
            }
        });
        serverStarted.await();
        System.out.println("Gerrit Server Started");
    }
    Injector i = createTestInjector(daemon);
    return new GerritServer(desc, i, daemon, daemonService);
}
#method_after
static GerritServer start(Config cfg, boolean memory, boolean enableHttpd) throws Exception {
    Logger.getLogger("com.google.gerrit").setLevel(Level.DEBUG);
    final CyclicBarrier serverStarted = new CyclicBarrier(2);
    final Daemon daemon = new Daemon(new Runnable() {

        @Override
        public void run() {
            try {
                serverStarted.await();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } catch (BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
        }
    });
    final File site;
    ExecutorService daemonService = null;
    if (memory) {
        site = null;
        mergeTestConfig(cfg);
        cfg.setBoolean("httpd", null, "requestLog", false);
        cfg.setBoolean("sshd", null, "requestLog", false);
        cfg.setBoolean("index", "lucene", "testInmemory", true);
        cfg.setString("gitweb", null, "cgi", "");
        daemon.setEnableHttpd(enableHttpd);
        daemon.setLuceneModule(new LuceneIndexModule(ChangeSchemas.getLatest().getVersion(), 0, null));
        daemon.setDatabaseForTesting(ImmutableList.<Module>of(new InMemoryTestingDatabaseModule(cfg)));
        daemon.start();
    } else {
        site = initSite(cfg);
        daemonService = Executors.newSingleThreadExecutor();
        daemonService.submit(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                int rc = daemon.main(new String[] { "-d", site.getPath(), "--headless" });
                if (rc != 0) {
                    System.out.println("Failed to start Gerrit daemon. Check " + site.getPath() + "/logs/error_log");
                    serverStarted.reset();
                }
                return null;
            }
        });
        serverStarted.await();
        System.out.println("Gerrit Server Started");
    }
    Injector i = createTestInjector(daemon);
    return new GerritServer(i, daemon, daemonService);
}
#end_block

#method_before
private static void mergeTestConfig(Config cfg) {
    String forceEphemeralPort = String.format("%s:0", getLocalHost().getHostName());
    String url = "http://" + forceEphemeralPort + "/";
    cfg.setString("gerrit", null, "canonicalWebUrl", url);
    cfg.setString("httpd", null, "listenUrl", url);
    cfg.setString("sshd", null, "listenAddress", forceEphemeralPort);
    cfg.setBoolean("sshd", null, "testUseInsecureRandom", true);
    cfg.setString("cache", null, "directory", null);
    cfg.setString("gerrit", null, "basePath", "git");
    cfg.setBoolean("sendemail", null, "enable", false);
    cfg.setInt("cache", "projects", "checkFrequency", 0);
    cfg.setInt("plugins", null, "checkFrequency", 0);
    cfg.setInt("sshd", null, "threads", 1);
    cfg.setInt("sshd", null, "commandStartThreads", 1);
    cfg.setInt("receive", null, "threadPoolSize", 1);
    cfg.setInt("index", null, "threads", 2);
}
#method_after
private static void mergeTestConfig(Config cfg) {
    String forceEphemeralPort = String.format("%s:0", getLocalHost().getHostName());
    String url = "http://" + forceEphemeralPort + "/";
    cfg.setString("gerrit", null, "canonicalWebUrl", url);
    cfg.setString("httpd", null, "listenUrl", url);
    cfg.setString("sshd", null, "listenAddress", forceEphemeralPort);
    cfg.setBoolean("sshd", null, "testUseInsecureRandom", true);
    cfg.setString("cache", null, "directory", null);
    cfg.setString("gerrit", null, "basePath", "git");
    cfg.setBoolean("sendemail", null, "enable", false);
    cfg.setInt("cache", "projects", "checkFrequency", 0);
    cfg.setInt("plugins", null, "checkFrequency", 0);
    cfg.setInt("sshd", null, "threads", 1);
    cfg.setInt("sshd", null, "commandStartThreads", 1);
    cfg.setInt("receive", null, "threadPoolSize", 1);
    cfg.setInt("index", null, "threads", 1);
}
#end_block

#method_before
@Override
public void start() {
    try {
        ds = new BasicDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(path);
        ds.setUsername(username);
        ds.setPassword(password);
        Connection conn = ds.getConnection();
        StringBuilder query = new StringBuilder();
        query.append(format("CREATE TABLE IF NOT EXISTS %s(", TABLE_NAME));
        if (ds.getDriverClassName().contains("postgresql")) {
            query.append(format("%s SERIAL PRIMARY KEY,", PRIMARY_ENTRY));
        } else {
            query.append(format("%s INT AUTO_INCREMENT PRIMARY KEY,", PRIMARY_ENTRY));
        }
        query.append(format("%s VARCHAR(255),", PROJECT_ENTRY));
        query.append(format("%s TIMESTAMP DEFAULT NOW(),", DATE_ENTRY));
        query.append(format("%s TEXT)", EVENT_ENTRY));
        Statement stat = conn.createStatement();
        try {
            stat.execute(query.toString());
        } finally {
            closeStatement(stat);
            closeConnection(conn);
        }
    } catch (SQLException e) {
        throw new RuntimeException("Cannot start the database", e);
    }
    removeOldEntries();
}
#method_after
@Override
public void start() {
    try {
        sqlClient.createDBIfNotCreated();
    } catch (SQLException e) {
        throw new RuntimeException("Cannot start the database", e);
    }
    removeOldEvents();
}
#end_block

#method_before
@Override
public void stop() {
    try {
        ds.close();
    } catch (SQLException e) {
        throw new RuntimeException("Cannot close datasource ", e);
    }
}
#method_after
@Override
public void stop() {
    try {
        sqlClient.close();
    } catch (SQLException e) {
        throw new RuntimeException("Cannot close datasource ", e);
    }
}
#end_block

#method_before
@Override
public List<String> queryChangeEvents(String query) throws MalformedQueryException {
    List<String> events = new ArrayList<>();
    Connection conn = null;
    Statement stat = null;
    ResultSet rs = null;
    try {
        conn = ds.getConnection();
        stat = conn.createStatement();
        try {
            Project.NameKey project = null;
            rs = stat.executeQuery(query);
            while (rs.next()) {
                try {
                    project = new Project.NameKey(rs.getString(PROJECT_ENTRY));
                    if (projectControlFactory.controlFor(project, userProvider.get()).isVisible()) {
                        events.add(rs.getString(EVENT_ENTRY));
                    }
                } catch (NoSuchProjectException e) {
                    log.warn("Database contains a non-existing project, " + project.get() + ", removing project from database", e);
                    removeProjectEntries(project.get());
                } catch (IOException e) {
                    log.warn("Cannot get project visibility info for " + project.get() + " from cache", e);
                }
            }
        } catch (SQLException e) {
            throw new MalformedQueryException(e);
        }
    } catch (SQLException e) {
        throw new RuntimeException("Cannot query database", e);
    } finally {
        closeResultSet(rs);
        closeStatement(stat);
        closeConnection(conn);
    }
    return events;
}
#method_after
@Override
public List<String> queryChangeEvents(String query) throws MalformedQueryException {
    List<String> events = new ArrayList<>();
    Project.NameKey project = null;
    for (Entry<String, Collection<String>> entry : sqlClient.getEvents(query).asMap().entrySet()) {
        try {
            project = new Project.NameKey(entry.getKey());
            if (projectControlFactory.controlFor(project, userProvider.get()).isVisible()) {
                events.addAll(entry.getValue());
            }
        } catch (NoSuchProjectException e) {
            log.warn("Database contains a non-existing project, " + project.get() + ", removing project from database", e);
            removeProjectEvents(project.get());
        } catch (IOException e) {
            log.warn("Cannot get project visibility info for " + project.get() + " from cache", e);
        }
    }
    return events;
}
#end_block

#method_before
@Override
public void storeEvent(ProjectEvent event) {
    Project.NameKey projectName = event.getProjectNameKey();
    if (projectName == null) {
        return;
    }
    String json = gson.toJson(event);
    int failedConnections = 0;
    boolean done = false;
    while (!done) {
        try {
            Connection conn = ds.getConnection();
            Statement stat = conn.createStatement();
            try {
                stat.execute(format("INSERT INTO %s(%s, %s, %s) ", TABLE_NAME, PROJECT_ENTRY, DATE_ENTRY, EVENT_ENTRY) + format("VALUES('%s', '%s', '%s')", projectName.get(), new Timestamp(event.eventCreatedOn * 1000L), json));
                done = true;
            } finally {
                closeStatement(stat);
                closeConnection(conn);
            }
        } catch (SQLException e) {
            log.warn("Cannot store ChangeEvent for: " + projectName.get() + "\n" + e.toString());
            if (e.getCause() instanceof ConnectException || e.toString().contains("terminating connection")) {
                if (failedConnections < maxTries) {
                    failedConnections++;
                    log.info("Retrying store event");
                    try {
                        Thread.sleep(waitTime);
                    } catch (InterruptedException e1) {
                        continue;
                    }
                } else {
                    log.error("Failed to store event " + maxTries + " times");
                    done = true;
                }
            } else {
                done = true;
            }
        }
    }
}
#method_after
@Override
public void storeEvent(ProjectEvent event) {
    Project.NameKey projectName = event.getProjectNameKey();
    if (projectName == null) {
        return;
    }
    int failedConnections = 0;
    boolean done = false;
    while (!done) {
        done = true;
        try {
            sqlClient.storeEvent(event);
        } catch (SQLException e) {
            log.warn("Cannot store ChangeEvent for: " + projectName.get(), e);
            if (e.getCause() instanceof ConnectException || e.getMessage().contains("terminating connection")) {
                if (maxTries == 0) {
                } else if (failedConnections < maxTries - 1) {
                    failedConnections++;
                    done = false;
                    log.info("Retrying store event");
                    try {
                        Thread.sleep(waitTime);
                    } catch (InterruptedException e1) {
                        continue;
                    }
                } else {
                    log.error("Failed to store event " + maxTries + " times");
                }
            }
        }
    }
}
#end_block

#method_before
@Option(name = "--limit", aliases = { "-n" }, metaVar = "CNT", usage = "maximum number of reviewers to list")
public void setLimit(int l) {
    this.limit = l <= 0 ? MAX : Math.min(l, MAX);
}
#method_after
@Option(name = "--limit", aliases = { "-n" }, metaVar = "CNT", usage = "maximum number of reviewers to list")
public void setLimit(int l) {
    this.limit = l <= 0 ? maxSuggestedReviewers : Math.min(l, maxSuggestedReviewers);
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws BadRequestException, OrmException, IOException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (!suggestAccounts || query.length() < suggestFrom) {
        return Collections.emptyList();
    }
    VisibilityControl visibilityControl = getVisibility(rsrc);
    List<AccountInfo> suggestedAccounts;
    if (useFullTextSearch) {
        suggestedAccounts = suggestAccountFullSearch(visibilityControl);
    } else {
        suggestedAccounts = suggestAccount(visibilityControl);
    }
    accountLoaderFactory.create(true).fill(suggestedAccounts);
    List<SuggestedReviewerInfo> reviewer = Lists.newArrayList();
    for (AccountInfo a : suggestedAccounts) {
        reviewer.add(new SuggestedReviewerInfo(a));
    }
    Project p = rsrc.getControl().getProject();
    for (GroupReference g : suggestAccountGroup(rsrc.getControl().getProjectControl())) {
        if (suggestGroupAsReviewer(p, g, visibilityControl)) {
            GroupBaseInfo info = new GroupBaseInfo();
            info.id = Url.encode(g.getUUID().get());
            info.name = g.getName();
            reviewer.add(new SuggestedReviewerInfo(info));
        }
    }
    Collections.sort(reviewer);
    if (reviewer.size() <= limit) {
        return reviewer;
    } else {
        return reviewer.subList(0, limit);
    }
}
#method_after
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws BadRequestException, OrmException, IOException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (!suggestAccounts || query.length() < suggestFrom) {
        return Collections.emptyList();
    }
    VisibilityControl visibilityControl = getVisibility(rsrc);
    List<AccountInfo> suggestedAccounts;
    if (useFullTextSearch) {
        suggestedAccounts = suggestAccountFullTextSearch(visibilityControl);
    } else {
        suggestedAccounts = suggestAccount(visibilityControl);
    }
    accountLoaderFactory.create(true).fill(suggestedAccounts);
    List<SuggestedReviewerInfo> reviewer = Lists.newArrayList();
    for (AccountInfo a : suggestedAccounts) {
        reviewer.add(new SuggestedReviewerInfo(a));
    }
    Project p = rsrc.getControl().getProject();
    for (GroupReference g : suggestAccountGroup(rsrc.getControl().getProjectControl())) {
        if (suggestGroupAsReviewer(p, g, visibilityControl)) {
            GroupBaseInfo info = new GroupBaseInfo();
            info.id = Url.encode(g.getUUID().get());
            info.name = g.getName();
            reviewer.add(new SuggestedReviewerInfo(info));
        }
    }
    Collections.sort(reviewer);
    if (reviewer.size() <= limit) {
        return reviewer;
    } else {
        return reviewer.subList(0, limit);
    }
}
#end_block

#method_before
private String getSortValue() {
    return account != null ? Objects.firstNonNull(account.email, Strings.nullToEmpty(account.name)) : Strings.nullToEmpty(group.name);
}
#method_after
private String getSortValue() {
    return account != null ? MoreObjects.firstNonNull(account.email, Strings.nullToEmpty(account.name)) : Strings.nullToEmpty(group.name);
}
#end_block

#method_before
private void authenticateAndRedirect(HttpServletResponse rsp) throws IOException {
    com.google.gerrit.server.account.AuthRequest areq = new com.google.gerrit.server.account.AuthRequest(user.getExternalId());
    AuthResult arsp = null;
    try {
        String claimedIdentifier = user.getClaimedIdentity();
        Account.Id actualId = accountManager.lookup(user.getExternalId());
        if (!Strings.isNullOrEmpty(claimedIdentifier)) {
            Account.Id claimedId = accountManager.lookup(claimedIdentifier);
            if (claimedId != null && actualId != null) {
                if (claimedId.equals(actualId)) {
                    // Both link to the same account, that's what we expected.
                    log.debug("OAuth2: claimed identity equals actual id");
                } else {
                    // This is (for now) a fatal error. There are two records
                    // for what might be the same user.
                    // 
                    log.error("OAuth accounts disagree over user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier + "\n" + "  Delgate ID: " + actualId + " is " + user.getExternalId());
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            } else if (claimedId != null && actualId == null) {
                // Claimed account already exists: link to it.
                // 
                log.debug("OAuth2: linking claimed identity to {}", claimedId.toString());
                try {
                    accountManager.link(claimedId, areq);
                } catch (OrmException e) {
                    log.error("Cannot link: " + user.getExternalId() + " to user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier);
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            }
        } else {
            log.debug("OAuth2: claimed identity is empty");
        }
        areq.setUserName(user.getUserName());
        areq.setEmailAddress(user.getEmailAddress());
        areq.setDisplayName(user.getDisplayName());
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    webSession.get().login(arsp, true);
    String suffix = redirectUrl.substring(OAuthWebFilter.GERRIT_LOGIN.length() + 1);
    suffix = URLDecoder.decode(suffix, StandardCharsets.UTF_8.name());
    rsp.sendRedirect(suffix);
}
#method_after
private void authenticateAndRedirect(HttpServletResponse rsp) throws IOException {
    com.google.gerrit.server.account.AuthRequest areq = new com.google.gerrit.server.account.AuthRequest(user.getExternalId());
    AuthResult arsp;
    try {
        String claimedIdentifier = user.getClaimedIdentity();
        Account.Id actualId = accountManager.lookup(user.getExternalId());
        if (!Strings.isNullOrEmpty(claimedIdentifier)) {
            Account.Id claimedId = accountManager.lookup(claimedIdentifier);
            if (claimedId != null && actualId != null) {
                if (claimedId.equals(actualId)) {
                    // Both link to the same account, that's what we expected.
                    log.debug("OAuth2: claimed identity equals current id");
                } else {
                    // This is (for now) a fatal error. There are two records
                    // for what might be the same user.
                    // 
                    log.error("OAuth accounts disagree over user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier + "\n" + "  Delgate ID: " + actualId + " is " + user.getExternalId());
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            } else if (claimedId != null && actualId == null) {
                // Claimed account already exists: link to it.
                // 
                log.info("OAuth2: linking claimed identity to {}", claimedId.toString());
                try {
                    accountManager.link(claimedId, areq);
                } catch (OrmException e) {
                    log.error("Cannot link: " + user.getExternalId() + " to user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier);
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            }
        } else {
            log.debug("OAuth2: claimed identity is empty");
        }
        areq.setUserName(user.getUserName());
        areq.setEmailAddress(user.getEmailAddress());
        areq.setDisplayName(user.getDisplayName());
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    webSession.get().login(arsp, true);
    String suffix = redirectUrl.substring(OAuthWebFilter.GERRIT_LOGIN.length() + 1);
    suffix = URLDecoder.decode(suffix, StandardCharsets.UTF_8.name());
    rsp.sendRedirect(suffix);
}
#end_block

#method_before
private void authenticateAndRedirect(HttpServletResponse rsp) throws IOException {
    com.google.gerrit.server.account.AuthRequest areq = new com.google.gerrit.server.account.AuthRequest(user.getExternalId());
    AuthResult arsp = null;
    try {
        String claimedIdentifier = user.getClaimedIdentity();
        Account.Id actualId = accountManager.lookup(user.getExternalId());
        if (!Strings.isNullOrEmpty(claimedIdentifier)) {
            Account.Id claimedId = accountManager.lookup(claimedIdentifier);
            if (claimedId != null && actualId != null) {
                if (claimedId.equals(actualId)) {
                // Both link to the same account, that's what we expected.
                } else {
                    // This is (for now) a fatal error. There are two records
                    // for what might be the same user.
                    // 
                    log.error("OAuth accounts disagree over user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier + "\n" + "  Delgate ID: " + actualId + " is " + user.getExternalId());
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            } else if (claimedId != null && actualId == null) {
                // 
                try {
                    accountManager.link(claimedId, areq);
                } catch (OrmException e) {
                    log.error("Cannot link: " + user.getExternalId() + " to user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier);
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            }
        }
        areq.setUserName(user.getUserName());
        areq.setEmailAddress(user.getEmailAddress());
        areq.setDisplayName(user.getDisplayName());
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    webSession.get().login(arsp, true);
    String suffix = redirectUrl.substring(OAuthWebFilter.GERRIT_LOGIN.length() + 1);
    suffix = URLDecoder.decode(suffix, StandardCharsets.UTF_8.name());
    rsp.sendRedirect(suffix);
}
#method_after
private void authenticateAndRedirect(HttpServletResponse rsp) throws IOException {
    com.google.gerrit.server.account.AuthRequest areq = new com.google.gerrit.server.account.AuthRequest(user.getExternalId());
    AuthResult arsp;
    try {
        String claimedIdentifier = user.getClaimedIdentity();
        Account.Id actualId = accountManager.lookup(user.getExternalId());
        if (!Strings.isNullOrEmpty(claimedIdentifier)) {
            Account.Id claimedId = accountManager.lookup(claimedIdentifier);
            if (claimedId != null && actualId != null) {
                if (claimedId.equals(actualId)) {
                // Both link to the same account, that's what we expected.
                } else {
                    // This is (for now) a fatal error. There are two records
                    // for what might be the same user.
                    // 
                    log.error("OAuth accounts disagree over user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier + "\n" + "  Delgate ID: " + actualId + " is " + user.getExternalId());
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            } else if (claimedId != null && actualId == null) {
                // 
                try {
                    accountManager.link(claimedId, areq);
                } catch (OrmException e) {
                    log.error("Cannot link: " + user.getExternalId() + " to user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier);
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            }
        }
        areq.setUserName(user.getUserName());
        areq.setEmailAddress(user.getEmailAddress());
        areq.setDisplayName(user.getDisplayName());
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    webSession.get().login(arsp, true);
    String suffix = redirectUrl.substring(OAuthWebFilter.GERRIT_LOGIN.length() + 1);
    suffix = URLDecoder.decode(suffix, StandardCharsets.UTF_8.name());
    rsp.sendRedirect(suffix);
}
#end_block

#method_before
private Injector createDbInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sitePath != null) {
        Module sitePathModule = new AbstractModule() {

            @Override
            protected void configure() {
                bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            }
        };
        modules.add(sitePathModule);
        Module configModule = new GerritServerConfigModule();
        modules.add(configModule);
        Injector cfgInjector = Guice.createInjector(sitePathModule, configModule);
        Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String dbType = cfg.getString("database", null, "type");
        final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(DataSourceType.class).toInstance(dst);
                bind(DataSourceProvider.Context.class).toInstance(DataSourceProvider.Context.MULTI_USER);
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(DataSourceProvider.class).in(SINGLETON);
                listener().to(DataSourceProvider.class);
            }
        });
    } else {
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
                listener().to(ReviewDbDataSourceProvider.class);
            }
        });
    }
    modules.add(new DatabaseModule());
    modules.add(new AbstractModule() {

        @Override
        public void configure() {
            String secureStoreClassName = GerritServerConfigModule.getSecureStoreClassName(cfgInjector);
            bind(String.class).annotatedWith(SecureStoreClassName.class).toProvider(Providers.of(secureStoreClassName));
        }
    });
    return Guice.createInjector(PRODUCTION, modules);
}
#method_after
private Injector createDbInjector() {
    final List<Module> modules = new ArrayList<>();
    AbstractModule secureStore = createSecureStoreModule();
    if (sitePath != null) {
        Module sitePathModule = new AbstractModule() {

            @Override
            protected void configure() {
                bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            }
        };
        modules.add(sitePathModule);
        Module configModule = new GerritServerConfigModule();
        modules.add(configModule);
        Injector cfgInjector = Guice.createInjector(sitePathModule, configModule, secureStore);
        Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String dbType = cfg.getString("database", null, "type");
        final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule, secureStore).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(DataSourceType.class).toInstance(dst);
                bind(DataSourceProvider.Context.class).toInstance(DataSourceProvider.Context.MULTI_USER);
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(DataSourceProvider.class).in(SINGLETON);
                listener().to(DataSourceProvider.class);
            }
        });
    } else {
        modules.add(secureStore);
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
                listener().to(ReviewDbDataSourceProvider.class);
            }
        });
    }
    modules.add(new DatabaseModule());
    return Guice.createInjector(PRODUCTION, modules);
}
#end_block

#method_before
public static String getSecureStoreClassName(Injector injector) {
    Config cfg = injector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    String className = cfg.getString("gerrit", null, "secureStoreClass");
    return className != null ? className : DefaultSecureStore.class.getName();
}
#method_after
public static String getSecureStoreClassName(final File sitePath) {
    if (sitePath != null) {
        return getSecureStoreFromGerritConfig(sitePath);
    }
    String secureStoreProperty = System.getProperty("gerrit.secure_store_class");
    return nullToDefault(secureStoreProperty);
}
#end_block

#method_before
@Override
public PatchList load(final PatchListKey key) throws Exception {
    final Repository repo = repoManager.openRepository(key.projectKey);
    try {
        return readPatchList(key, repo);
    } finally {
        repo.close();
    }
}
#method_after
@Override
public PatchList load(final PatchListKey key) throws IOException, PatchListNotAvailableException {
    final Repository repo = repoManager.openRepository(key.projectKey);
    try {
        return readPatchList(key, repo);
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws Exception {
    final RawTextComparator cmp = comparatorFor(key.getWhitespace());
    final ObjectReader reader = repo.newObjectReader();
    try {
        final RevWalk rw = new RevWalk(reader);
        final RevCommit b = rw.parseCommit(key.getNewId());
        final RevObject a = aFor(key, repo, rw, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is a merge commit, compared to its ancestor.
            // 
            final PatchListEntry[] entries = new PatchListEntry[1];
            entries[0] = newCommitMessage(cmp, repo, reader, null, b);
            return new PatchList(a, b, true, entries);
        }
        final boolean againstParent = b.getParentCount() > 0 && b.getParent(0) == a;
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        df.setRepository(repo);
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = df.scan(aTree, bTree);
        Set<String> paths = key.getOldId() != null ? FluentIterable.from(patchListCache.get(new PatchListKey(key.projectKey, null, key.getNewId(), key.getWhitespace())).getPatches()).transform(new Function<PatchListEntry, String>() {

            @Override
            public String apply(PatchListEntry entry) {
                return entry.getNewName();
            }
        }).toSet() : null;
        int cnt = diffEntries.size();
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(// 
        cmp, // 
        repo, // 
        reader, againstParent ? null : aCommit, b));
        for (int i = 0; i < cnt; i++) {
            DiffEntry diffEntry = diffEntries.get(i);
            if (paths == null || paths.contains(diffEntry.getNewPath()) || paths.contains(diffEntry.getOldPath())) {
                FileHeader fh = toFileHeader(key, df, diffEntry);
                entries.add(newEntry(aTree, fh));
            }
        }
        return new PatchList(a, b, againstParent, entries.toArray(new PatchListEntry[entries.size()]));
    } finally {
        reader.release();
    }
}
#method_after
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException, PatchListNotAvailableException {
    final RawTextComparator cmp = comparatorFor(key.getWhitespace());
    final ObjectReader reader = repo.newObjectReader();
    try {
        final RevWalk rw = new RevWalk(reader);
        final RevCommit b = rw.parseCommit(key.getNewId());
        final RevObject a = aFor(key, repo, rw, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is a merge commit, compared to its ancestor.
            // 
            final PatchListEntry[] entries = new PatchListEntry[1];
            entries[0] = newCommitMessage(cmp, repo, reader, null, b);
            return new PatchList(a, b, true, entries);
        }
        final boolean againstParent = b.getParentCount() > 0 && b.getParent(0) == a;
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        df.setRepository(repo);
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = df.scan(aTree, bTree);
        Set<String> paths = key.getOldId() != null ? FluentIterable.from(patchListCache.get(new PatchListKey(key.projectKey, null, key.getNewId(), key.getWhitespace())).getPatches()).transform(new Function<PatchListEntry, String>() {

            @Override
            public String apply(PatchListEntry entry) {
                return entry.getNewName();
            }
        }).toSet() : null;
        int cnt = diffEntries.size();
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(// 
        cmp, // 
        repo, // 
        reader, againstParent ? null : aCommit, b));
        for (int i = 0; i < cnt; i++) {
            DiffEntry diffEntry = diffEntries.get(i);
            if (paths == null || paths.contains(diffEntry.getNewPath()) || paths.contains(diffEntry.getOldPath())) {
                FileHeader fh = toFileHeader(key, df, diffEntry);
                entries.add(newEntry(aTree, fh));
            }
        }
        return new PatchList(a, b, againstParent, entries.toArray(new PatchListEntry[entries.size()]));
    } finally {
        reader.release();
    }
}
#end_block

#method_before
private FileHeader toFileHeader(PatchListKey key, DiffFormatter diffFormatter, DiffEntry diffEntry) throws Exception {
    DiffWorkerPool.Worker worker = workerPool.acquire();
    DiffWorkerPool.Worker.Result r;
    r = worker.toFileHeaderWithTimeout(key, diffFormatter, diffEntry, timeoutMillis);
    if (r == DiffWorkerPool.Worker.Result.TIMEOUT) {
        // Don't keep this thread. We have to murder it unsafely, which
        // means its unable to be reused in the future. Return a result produced
        // by HistogramDiff without the usage of MyersDiff.
        // 
        HistogramDiff histogramDiff = new HistogramDiff();
        histogramDiff.setFallbackAlgorithm(null);
        diffFormatter.setDiffAlgorithm(histogramDiff);
        return diffFormatter.toFileHeader(diffEntry);
    }
    workerPool.release(worker);
    if (r.error != null) {
        // 
        throw r.error;
    }
    return r.fileHeader;
}
#method_after
private FileHeader toFileHeader(PatchListKey key, final DiffFormatter diffFormatter, final DiffEntry diffEntry) throws IOException {
    Future<FileHeader> result = diffExecutor.submit(new Callable<FileHeader>() {

        @Override
        public FileHeader call() throws IOException {
            return diffFormatter.toFileHeader(diffEntry);
        }
    });
    try {
        return result.get(timeoutMillis, TimeUnit.MILLISECONDS);
    } catch (InterruptedException | TimeoutException e) {
        log.warn(timeoutMillis + " ms timeout reached for Diff loader" + " in project " + key.projectKey.get() + " on commit " + key.getNewId().name() + " on path " + diffEntry.getNewPath() + " comparing " + diffEntry.getOldId().name() + ".." + diffEntry.getNewId().name());
        result.cancel(true);
        return toFileHeaderWithoutMyersDiff(diffFormatter, diffEntry);
    } catch (ExecutionException e) {
        // If there was an error computing the result, carry it
        // up to the caller so the cache knows this key is invalid.
        Throwables.propagateIfInstanceOf(e.getCause(), IOException.class);
        throw new IOException(e.getMessage(), e.getCause());
    }
}
#end_block

#method_before
private static RevObject aFor(final PatchListKey key, final Repository repo, final RevWalk rw, final RevCommit b) throws IOException {
    if (key.getOldId() != null) {
        return rw.parseAny(key.getOldId());
    }
    switch(b.getParentCount()) {
        case 0:
            return rw.parseAny(emptyTree(repo));
        case 1:
            {
                RevCommit r = b.getParent(0);
                rw.parseBody(r);
                return r;
            }
        case 2:
            return automerge(repo, rw, b);
        default:
            // TODO(sop) handle an octopus merge.
            return null;
    }
}
#method_after
private RevObject aFor(final PatchListKey key, final Repository repo, final RevWalk rw, final RevCommit b) throws IOException {
    if (key.getOldId() != null) {
        return rw.parseAny(key.getOldId());
    }
    switch(b.getParentCount()) {
        case 0:
            return rw.parseAny(emptyTree(repo));
        case 1:
            {
                RevCommit r = b.getParent(0);
                rw.parseBody(r);
                return r;
            }
        case 2:
            return automerge(repo, rw, b, mergeStrategy);
        default:
            // TODO(sop) handle an octopus merge.
            return null;
    }
}
#end_block

#method_before
public static RevTree automerge(Repository repo, RevWalk rw, RevCommit b, boolean save) throws IOException {
    String hash = b.name();
    String refName = RefNames.REFS_CACHE_AUTOMERGE + hash.substring(0, 2) + "/" + hash.substring(2);
    Ref ref = repo.getRef(refName);
    if (ref != null && ref.getObjectId() != null) {
        return rw.parseTree(ref.getObjectId());
    }
    ObjectId treeId;
    ResolveMerger m = (ResolveMerger) MergeStrategy.RESOLVE.newMerger(repo, true);
    final ObjectInserter ins = repo.newObjectInserter();
    try {
        DirCache dc = DirCache.newInCore();
        m.setDirCache(dc);
        m.setObjectInserter(new ObjectInserter.Filter() {

            @Override
            protected ObjectInserter delegate() {
                return ins;
            }

            @Override
            public void flush() {
            }

            @Override
            public void release() {
            }
        });
        boolean couldMerge;
        try {
            couldMerge = m.merge(b.getParents());
        } catch (IOException e) {
            // It is not safe to continue further down in this method as throwing
            // an exception most likely means that the merge tree was not created
            // and m.getMergeResults() is empty. This would mean that all paths are
            // unmerged and Gerrit UI would show all paths in the patch list.
            log.warn("Error attempting automerge " + refName, e);
            return null;
        }
        if (couldMerge) {
            treeId = m.getResultTreeId();
        } else {
            RevCommit ours = b.getParent(0);
            RevCommit theirs = b.getParent(1);
            rw.parseBody(ours);
            rw.parseBody(theirs);
            String oursMsg = ours.getShortMessage();
            String theirsMsg = theirs.getShortMessage();
            String oursName = String.format("HEAD   (%s %s)", ours.abbreviate(6).name(), oursMsg.substring(0, Math.min(oursMsg.length(), 60)));
            String theirsName = String.format("BRANCH (%s %s)", theirs.abbreviate(6).name(), theirsMsg.substring(0, Math.min(theirsMsg.length(), 60)));
            MergeFormatter fmt = new MergeFormatter();
            Map<String, MergeResult<? extends Sequence>> r = m.getMergeResults();
            Map<String, ObjectId> resolved = new HashMap<>();
            for (Map.Entry<String, MergeResult<? extends Sequence>> entry : r.entrySet()) {
                MergeResult<? extends Sequence> p = entry.getValue();
                TemporaryBuffer buf = new TemporaryBuffer.LocalFile(10 * 1024 * 1024);
                try {
                    fmt.formatMerge(buf, p, "BASE", oursName, theirsName, "UTF-8");
                    buf.close();
                    InputStream in = buf.openInputStream();
                    try {
                        resolved.put(entry.getKey(), ins.insert(Constants.OBJ_BLOB, buf.length(), in));
                    } finally {
                        in.close();
                    }
                } finally {
                    buf.destroy();
                }
            }
            DirCacheBuilder builder = dc.builder();
            int cnt = dc.getEntryCount();
            for (int i = 0; i < cnt; ) {
                DirCacheEntry entry = dc.getEntry(i);
                if (entry.getStage() == 0) {
                    builder.add(entry);
                    i++;
                    continue;
                }
                int next = dc.nextEntry(i);
                String path = entry.getPathString();
                DirCacheEntry res = new DirCacheEntry(path);
                if (resolved.containsKey(path)) {
                    // For a file with content merge conflict that we produced a result
                    // above on, collapse the file down to a single stage 0 with just
                    // the blob content, and a randomly selected mode (the lowest stage,
                    // which should be the merge base, or ours).
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(resolved.get(path));
                } else if (next == i + 1) {
                    // If there is exactly one stage present, shouldn't be a conflict...
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else if (next == i + 2) {
                    // Two stages suggests a delete/modify conflict. Pick the higher
                    // stage as the automatic result.
                    entry = dc.getEntry(i + 1);
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else {
                    // 3 stage conflict, no resolve above
                    // Punt on the 3-stage conflict and show the base, for now.
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                }
                builder.add(res);
                i = next;
            }
            builder.finish();
            treeId = dc.writeTree(ins);
        }
        ins.flush();
    } finally {
        ins.release();
    }
    if (save) {
        RefUpdate update = repo.updateRef(refName);
        update.setNewObjectId(treeId);
        update.disableRefLog();
        update.forceUpdate();
    }
    return rw.parseTree(treeId);
}
#method_after
public static RevTree automerge(Repository repo, RevWalk rw, RevCommit b, ThreeWayMergeStrategy mergeStrategy) throws IOException {
    return automerge(repo, rw, b, mergeStrategy, true);
}
#end_block

#method_before
private FileHeader toFileHeader(PatchListKey key, final DiffFormatter diffFormatter, final DiffEntry diffEntry) throws IOException {
    Future<FileHeader> result = diffExecutor.submit(new Callable<FileHeader>() {

        @Override
        public FileHeader call() throws IOException {
            return diffFormatter.toFileHeader(diffEntry);
        }
    });
    FileHeader fileHeader;
    try {
        fileHeader = result.get(timeoutMillis, TimeUnit.MILLISECONDS);
    } catch (InterruptedException | TimeoutException e) {
        log.warn(timeoutMillis + " ms timeout reached for Diff loader" + " in project " + key.projectKey.get() + " on commit " + key.getNewId() + " on path " + diffEntry.getNewPath() + " comparing " + diffEntry.getOldId() + ".." + diffEntry.getNewId());
        result.cancel(true);
        return toFileHeaderWithoutMyersDiff(diffFormatter, diffEntry);
    } catch (ExecutionException e) {
        // If there was an error computing the result, carry it
        // up to the caller so the cache knows this key is invalid.
        Throwable cause = e.getCause();
        if (cause instanceof IOException) {
            throw (IOException) cause;
        } else {
            throw new IOException(e.getMessage(), cause);
        }
    }
    return fileHeader;
}
#method_after
private FileHeader toFileHeader(PatchListKey key, final DiffFormatter diffFormatter, final DiffEntry diffEntry) throws IOException {
    Future<FileHeader> result = diffExecutor.submit(new Callable<FileHeader>() {

        @Override
        public FileHeader call() throws IOException {
            return diffFormatter.toFileHeader(diffEntry);
        }
    });
    try {
        return result.get(timeoutMillis, TimeUnit.MILLISECONDS);
    } catch (InterruptedException | TimeoutException e) {
        log.warn(timeoutMillis + " ms timeout reached for Diff loader" + " in project " + key.projectKey.get() + " on commit " + key.getNewId() + " on path " + diffEntry.getNewPath() + " comparing " + diffEntry.getOldId() + ".." + diffEntry.getNewId());
        result.cancel(true);
        return toFileHeaderWithoutMyersDiff(diffFormatter, diffEntry);
    } catch (ExecutionException e) {
        // If there was an error computing the result, carry it
        // up to the caller so the cache knows this key is invalid.
        Throwables.propagateIfInstanceOf(e.getCause(), IOException.class);
        throw new IOException(e.getMessage(), e.getCause());
    }
}
#end_block

#method_before
@Override
public boolean match(ChangeData cd) throws OrmException {
    for (ChangeMessage m : cd.messages()) {
        if (m.getAuthor().equals(id)) {
            return true;
        }
    }
    for (PatchLineComment c : cd.publishedComments()) {
        if (c.getAuthor().equals(id)) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean match(ChangeData cd) throws OrmException {
    for (ChangeMessage m : cd.messages()) {
        if (Objects.equals(m.getAuthor(), id)) {
            return true;
        }
    }
    for (PatchLineComment c : cd.publishedComments()) {
        if (Objects.equals(c.getAuthor(), id)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void renderRow(SafeHtmlBuilder sb) {
    sb.openDiv().setStyleName(RelatedChanges.R.css().row());
    sb.openSpan().setStyleName(RelatedChanges.R.css().pointer());
    sb.append(POINTER_HTML);
    sb.closeSpan();
    sb.openSpan().setStyleName(RelatedChanges.R.css().subject());
    String url = url();
    if (url != null) {
        sb.openAnchor().setAttribute("href", url);
        if (url.startsWith("#")) {
            sb.setAttribute("onclick", OPEN);
        }
        if (showProjects) {
            sb.append(info.project()).append(": ");
        }
        if (showBranches) {
            sb.append(info.branch()).append(": ");
        }
        sb.append(info.commit().subject());
        sb.closeAnchor();
    } else {
        sb.append(info.commit().subject());
    }
    sb.closeSpan();
    sb.openSpan();
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && (!info.has_change_number() || !info.has_revision_number())) {
        sb.setStyleName(RelatedChanges.R.css().gitweb());
        sb.setAttribute("title", gw.getLinkName());
        sb.append('\u25CF');
    } else if (notConnected) {
        sb.setStyleName(RelatedChanges.R.css().indirect());
        sb.setAttribute("title", Resources.C.indirectAncestor());
        sb.append('~');
    } else if (info.has_current_revision_number() && info.has_revision_number() && info._current_revision_number() != info._revision_number()) {
        sb.setStyleName(RelatedChanges.R.css().notCurrent());
        sb.setAttribute("title", Util.C.notCurrent());
        sb.append('\u25CF');
    } else if (Change.Status.MERGED == info.status()) {
        sb.setStyleName(RelatedChanges.R.css().merged());
        sb.setAttribute("title", Resources.C.merged());
        sb.append('\u25CF');
    } else if (Change.Status.ABANDONED == info.status()) {
        sb.setStyleName(RelatedChanges.R.css().abandoned());
        sb.setAttribute("title", Resources.C.abandoned());
        sb.append('\u25CF');
    } else {
        sb.setStyleName(RelatedChanges.R.css().current());
    }
    sb.closeSpan();
    sb.closeDiv();
}
#method_after
private void renderRow(SafeHtmlBuilder sb) {
    sb.openDiv().setStyleName(RelatedChanges.R.css().row());
    sb.openSpan().setStyleName(RelatedChanges.R.css().pointer());
    sb.append(POINTER_HTML);
    sb.closeSpan();
    sb.openSpan().setStyleName(RelatedChanges.R.css().subject());
    String url = url();
    if (url != null) {
        sb.openAnchor().setAttribute("href", url);
        if (url.startsWith("#")) {
            sb.setAttribute("onclick", OPEN);
        }
        if (showProjects) {
            sb.append(info.project()).append(": ");
        }
        if (showBranches) {
            sb.append(info.branch()).append(": ");
        }
        sb.append(info.commit().subject());
        sb.closeAnchor();
    } else {
        sb.append(info.commit().subject());
    }
    sb.closeSpan();
    sb.openSpan();
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && (!info.has_change_number() || !info.has_revision_number())) {
        sb.setStyleName(RelatedChanges.R.css().gitweb());
        sb.setAttribute("title", gw.getLinkName());
        sb.append('\u25CF');
    } else if (notConnected) {
        sb.setStyleName(RelatedChanges.R.css().indirect());
        sb.setAttribute("title", Resources.C.indirectAncestor());
        sb.append('~');
    } else if (info.has_current_revision_number() && info.has_revision_number() && info._current_revision_number() != info._revision_number()) {
        sb.setStyleName(RelatedChanges.R.css().notCurrent());
        sb.setAttribute("title", Util.C.notCurrent());
        sb.append('\u25CF');
    } else {
        sb.setStyleName(RelatedChanges.R.css().current());
    }
    sb.closeSpan();
    sb.closeDiv();
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    try {
        if (!suggestParent) {
            if (projectName == null) {
                throw new UnloggedFailure(1, "fatal: Project name is required.");
            }
            ProjectInput input = new ProjectInput();
            input.name = projectName;
            if (ownerIds != null) {
                input.owners = Lists.transform(ownerIds, new Function<AccountGroup.UUID, String>() {

                    @Override
                    public String apply(AccountGroup.UUID uuid) {
                        return uuid.get();
                    }
                });
            }
            if (newParent != null) {
                input.parent = newParent.getProject().getName();
            }
            input.permissionsOnly = permissionsOnly;
            input.description = projectDescription;
            input.submitType = submitType;
            input.useContributorAgreements = contributorAgreements;
            input.useSignedOffBy = signedOffBy;
            input.useContentMerge = contentMerge;
            input.requireChangeId = requireChangeID;
            input.createNewChangeForAllNotInTarget = createNewChangeForAllNotInTarget;
            input.branches = branch;
            input.createEmptyCommit = createEmptyCommit;
            input.maxObjectSizeLimit = maxObjectSizeLimit;
            if (pluginConfigValues != null) {
                input.pluginConfigValues = parsePluginConfigValues(pluginConfigValues);
            }
            gApi.projects().name(projectName).create(input);
        } else {
            List<Project.NameKey> parentCandidates = suggestParentCandidates.getNameKeys();
            for (Project.NameKey parent : parentCandidates) {
                stdout.print(parent + "\n");
            }
        }
    } catch (RestApiException | NoSuchProjectException err) {
        throw new UnloggedFailure(1, "fatal: " + err.getMessage(), err);
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    try {
        if (!suggestParent) {
            if (projectName == null) {
                throw new UnloggedFailure(1, "fatal: Project name is required.");
            }
            ProjectInput input = new ProjectInput();
            input.name = projectName;
            if (ownerIds != null) {
                input.owners = Lists.transform(ownerIds, new Function<AccountGroup.UUID, String>() {

                    @Override
                    public String apply(AccountGroup.UUID uuid) {
                        return uuid.get();
                    }
                });
            }
            if (newParent != null) {
                input.parent = newParent.getProject().getName();
            }
            input.permissionsOnly = permissionsOnly;
            input.description = projectDescription;
            input.submitType = submitType;
            input.useContributorAgreements = contributorAgreements;
            input.useSignedOffBy = signedOffBy;
            input.useContentMerge = contentMerge;
            input.requireChangeId = requireChangeID;
            input.createNewChangeForAllNotInTarget = createNewChangeForAllNotInTarget;
            input.branches = branch;
            input.createEmptyCommit = createEmptyCommit;
            input.maxObjectSizeLimit = maxObjectSizeLimit;
            if (pluginConfigValues != null) {
                input.pluginConfigValues = parsePluginConfigValues(pluginConfigValues);
            }
            gApi.projects().create(input);
        } else {
            List<Project.NameKey> parentCandidates = suggestParentCandidates.getNameKeys();
            for (Project.NameKey parent : parentCandidates) {
                stdout.print(parent + "\n");
            }
        }
    } catch (RestApiException | NoSuchProjectException err) {
        throw new UnloggedFailure(1, "fatal: " + err.getMessage(), err);
    }
}
#end_block

#method_before
public static void replyJson(@Nullable HttpServletRequest req, HttpServletResponse res, Multimap<String, String> config, Object result) throws IOException {
    TemporaryBuffer.Heap buf = heap(Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    replyBinaryResult(req, res, asBinaryResult(buf).setContentType(JSON_TYPE).setCharacterEncoding(UTF_8.name()));
}
#method_after
public static void replyJson(@Nullable HttpServletRequest req, HttpServletResponse res, Multimap<String, String> config, Object result) throws IOException {
    TemporaryBuffer.Heap buf = heap(HEAP_EST_SIZE, Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    replyBinaryResult(req, res, asBinaryResult(buf).setContentType(JSON_TYPE).setCharacterEncoding(UTF_8.name()));
}
#end_block

#method_before
private static BinaryResult stackJsonString(HttpServletResponse res, final BinaryResult src) throws IOException {
    TemporaryBuffer.Heap buf = heap(Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    try (Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
        JsonWriter json = new JsonWriter(w)) {
        json.setLenient(true);
        json.setHtmlSafe(true);
        json.value(src.asString());
        w.write('\n');
    }
    res.setHeader("X-FYI-Content-Encoding", "json");
    res.setHeader("X-FYI-Content-Type", src.getContentType());
    return asBinaryResult(buf).setContentType(JSON_TYPE).setCharacterEncoding(UTF_8.name());
}
#method_after
private static BinaryResult stackJsonString(HttpServletResponse res, final BinaryResult src) throws IOException {
    TemporaryBuffer.Heap buf = heap(HEAP_EST_SIZE, Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    try (Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
        JsonWriter json = new JsonWriter(w)) {
        json.setLenient(true);
        json.setHtmlSafe(true);
        json.value(src.asString());
        w.write('\n');
    }
    res.setHeader("X-FYI-Content-Encoding", "json");
    res.setHeader("X-FYI-Content-Type", src.getContentType());
    return asBinaryResult(buf).setContentType(JSON_TYPE).setCharacterEncoding(UTF_8.name());
}
#end_block

#method_before
private static BinaryResult base64(BinaryResult bin) throws IOException {
    int max = 4 * IntMath.divide((int) bin.getContentLength(), 3, CEILING);
    TemporaryBuffer.Heap buf = heap(max);
    OutputStream encoded = BaseEncoding.base64().encodingStream(new OutputStreamWriter(buf, ISO_8859_1));
    bin.writeTo(encoded);
    encoded.close();
    return asBinaryResult(buf);
}
#method_after
private static BinaryResult base64(BinaryResult bin) throws IOException {
    int maxSize = base64MaxSize(bin.getContentLength());
    int estSize = Math.min(base64MaxSize(HEAP_EST_SIZE), maxSize);
    TemporaryBuffer.Heap buf = heap(estSize, maxSize);
    OutputStream encoded = BaseEncoding.base64().encodingStream(new OutputStreamWriter(buf, ISO_8859_1));
    bin.writeTo(encoded);
    encoded.close();
    return asBinaryResult(buf);
}
#end_block

#method_before
private static BinaryResult compress(BinaryResult bin) throws IOException {
    TemporaryBuffer.Heap buf = heap(20 << 20);
    GZIPOutputStream gz = new GZIPOutputStream(buf);
    bin.writeTo(gz);
    gz.close();
    return asBinaryResult(buf).setContentType(bin.getContentType());
}
#method_after
private static BinaryResult compress(BinaryResult bin) throws IOException {
    TemporaryBuffer.Heap buf = heap(HEAP_EST_SIZE, 20 << 20);
    GZIPOutputStream gz = new GZIPOutputStream(buf);
    bin.writeTo(gz);
    gz.close();
    return asBinaryResult(buf).setContentType(bin.getContentType());
}
#end_block

#method_before
private static Heap heap(int max) {
    return new TemporaryBuffer.Heap(max);
}
#method_after
private static Heap heap(int est, int max) {
    return new TemporaryBuffer.Heap(est, max);
}
#end_block

#method_before
public GarbageCollectionResult run(List<Project.NameKey> projectNames, PrintWriter writer) {
    return run(projectNames, gcConfig.getAggressive(), writer);
}
#method_after
public GarbageCollectionResult run(List<Project.NameKey> projectNames, PrintWriter writer) {
    return run(projectNames, gcConfig.isAggressive(), writer);
}
#end_block

#method_before
private static void logGcConfiguration(Project.NameKey projectName, Repository repo, boolean aggressive) {
    StringBuilder b = new StringBuilder();
    Config cfg = repo.getConfig();
    b.append("gc.aggressive=" + aggressive + "; ");
    b.append(formatConfigValues(cfg, ConfigConstants.CONFIG_GC_SECTION, null));
    for (String subsection : cfg.getSubsections(ConfigConstants.CONFIG_GC_SECTION)) {
        b.append(formatConfigValues(cfg, ConfigConstants.CONFIG_GC_SECTION, subsection));
    }
    if (b.length() == 0) {
        b.append("no set");
    }
    logGcInfo(projectName, "gc config: " + b.toString());
    logGcInfo(projectName, "pack config: " + (new PackConfig(repo)).toString());
}
#method_after
private static void logGcConfiguration(Project.NameKey projectName, Repository repo, boolean aggressive) {
    StringBuilder b = new StringBuilder();
    Config cfg = repo.getConfig();
    b.append("gc.aggressive=").append(aggressive).append("; ");
    b.append(formatConfigValues(cfg, ConfigConstants.CONFIG_GC_SECTION, null));
    for (String subsection : cfg.getSubsections(ConfigConstants.CONFIG_GC_SECTION)) {
        b.append(formatConfigValues(cfg, ConfigConstants.CONFIG_GC_SECTION, subsection));
    }
    if (b.length() == 0) {
        b.append("no set");
    }
    logGcInfo(projectName, "gc config: " + b.toString());
    logGcInfo(projectName, "pack config: " + (new PackConfig(repo)).toString());
}
#end_block

#method_before
private boolean isDescendantOf(Change.Id child, RevId ancestor) throws OrmException {
    ReviewDb db = dbProvider.get();
    ArrayList<RevId> parents = new ArrayList<RevId>();
    parents.add(ancestor);
    while (!parents.isEmpty()) {
        RevId parent = parents.remove(0);
        // get direct descendants of change
        for (PatchSetAncestor desc : db.patchSetAncestors().descendantsOf(parent)) {
            PatchSet descPatchSet = db.patchSets().get(desc.getPatchSet());
            Change.Id descChangeId = descPatchSet.getId().getParentKey();
            if (child.equals(descChangeId)) {
                PatchSet.Id descCurrentPatchSetId = db.changes().get(descChangeId).currentPatchSetId();
                // its only bad if the descendant patch set is current
                return descPatchSet.getId().equals(descCurrentPatchSetId);
            } else {
                // process indirect descendants as well
                parents.add(descPatchSet.getRevision());
            }
        }
    }
    return false;
}
#method_after
private boolean isDescendantOf(Change.Id child, RevId ancestor) throws OrmException {
    ReviewDb db = dbProvider.get();
    ArrayList<RevId> parents = new ArrayList<>();
    parents.add(ancestor);
    while (!parents.isEmpty()) {
        RevId parent = parents.remove(0);
        // get direct descendants of change
        for (PatchSetAncestor desc : db.patchSetAncestors().descendantsOf(parent)) {
            PatchSet descPatchSet = db.patchSets().get(desc.getPatchSet());
            Change.Id descChangeId = descPatchSet.getId().getParentKey();
            if (child.equals(descChangeId)) {
                PatchSet.Id descCurrentPatchSetId = db.changes().get(descChangeId).currentPatchSetId();
                // it's only bad if the descendant patch set is current
                return descPatchSet.getId().equals(descCurrentPatchSetId);
            } else {
                // process indirect descendants as well
                parents.add(descPatchSet.getRevision());
            }
        }
    }
    return false;
}
#end_block

#method_before
@Override
public int hashCode() {
    return val.hashCode();
}
#method_after
@Override
public int hashCode() {
    return System.identityHashCode(this);
}
#end_block

#method_before
private void initOnce() {
    if (pcl == null)
        pcl = new PrologClassLoader();
    if (internalDB == null)
        internalDB = new InternalDatabase();
    if (streamManager == null)
        streamManager = new HashtableOfTerm();
}
#method_after
private void initOnce() {
    if (pcl == null)
        pcl = new PrologClassLoader();
    if (internalDB == null)
        internalDB = new InternalDatabase();
    if (streamManager == null)
        streamManager = new HashtableOfTerm(7);
}
#end_block

#method_before
public Operation jtry9(Operation p, Operation next) {
    return jtry(p, next, new ChoicePointFrame.S8(this));
}
#method_after
public Operation jtry9(Operation p, Operation next) {
    return jtry(p, next, new ChoicePointFrame.S9(this));
}
#end_block

#method_before
public Operation jtry10(Operation p, Operation next) {
    return jtry(p, next, new ChoicePointFrame.S8(this));
}
#method_after
public Operation jtry10(Operation p, Operation next) {
    return jtry(p, next, new ChoicePointFrame.S10(this));
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    if (problemsForSubmittingChanges(Arrays.asList(cd), resource.getUser()) != null) {
        visible = false;
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    boolean enabled;
    try {
        enabled = mergeableProvider.get().apply(resource).mergeable;
    } catch (AuthException | ResourceConflictException | BadRequestException | OrmException | IOException e) {
        throw new OrmRuntimeException("Could not determine mergability", e);
    }
    List<ChangeData> changesByTopic = null;
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic)) {
        changesByTopic = getChangesByTopic(topic);
    }
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic) && changesByTopic.size() > 1) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        String topicProblems = problemsForSubmittingChanges(changesByTopic, resource.getUser());
        if (topicProblems != null) {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(topicProblems).setVisible(true).setEnabled(false);
        } else {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(enabled);
        }
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true).setEnabled(enabled);
    }
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    if (problemsForSubmittingChanges(Arrays.asList(cd), resource.getUser()) != null) {
        visible = false;
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    boolean enabled;
    try {
        enabled = mergeableProvider.get().apply(resource).mergeable;
    } catch (RestApiException | OrmException | IOException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    List<ChangeData> changesByTopic = null;
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic)) {
        changesByTopic = getChangesByTopic(topic);
    }
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic) && changesByTopic.size() > 1) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        String topicProblems = problemsForSubmittingChanges(changesByTopic, resource.getUser());
        if (topicProblems != null) {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(topicProblems).setVisible(true).setEnabled(false);
        } else {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(enabled);
        }
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true).setEnabled(enabled);
    }
}
#end_block

#method_before
private TreeSet<Entry<String, Path>> jarsFirstSortedPluginsSet(Map<String, Path> activePlugins) {
    final PathMatcher jarMatcher = FileSystems.getDefault().getPathMatcher("glob:*.jar");
    TreeSet<Entry<String, Path>> sortedPlugins = Sets.newTreeSet(new Comparator<Entry<String, Path>>() {

        @Override
        public int compare(Entry<String, Path> e1, Entry<String, Path> e2) {
            Path n1 = e1.getValue().getFileName();
            Path n2 = e2.getValue().getFileName();
            return ComparisonChain.start().compareTrueFirst(jarMatcher.matches(n1), jarMatcher.matches(n2)).compare(n1, n2).result();
        }
    });
    addAllEntries(activePlugins, sortedPlugins);
    return sortedPlugins;
}
#method_after
private TreeSet<Entry<String, Path>> jarsFirstSortedPluginsSet(Map<String, Path> activePlugins) {
    TreeSet<Entry<String, Path>> sortedPlugins = Sets.newTreeSet(new Comparator<Entry<String, Path>>() {

        @Override
        public int compare(Entry<String, Path> e1, Entry<String, Path> e2) {
            Path n1 = e1.getValue().getFileName();
            Path n2 = e2.getValue().getFileName();
            return ComparisonChain.start().compareTrueFirst(isJar(n1), isJar(n2)).compare(n1, n2).result();
        }

        private boolean isJar(Path n1) {
            return n1.toString().endsWith(".jar");
        }
    });
    addAllEntries(activePlugins, sortedPlugins);
    return sortedPlugins;
}
#end_block

#method_before
private void load(List<String> pluginUrls) {
    for (String url : pluginUrls) {
        Plugin plugin = Plugin.create(url);
        plugins().put(url, plugin);
        ScriptInjector.fromUrl(url).setWindow(ScriptInjector.TOP_WINDOW).setCallback(new LoadCallback(plugin)).inject();
    }
}
#method_after
public static void load(List<String> plugins, int loadTimeout, AsyncCallback<VoidResult> callback) {
    if (plugins == null || plugins.isEmpty()) {
        callback.onSuccess(VoidResult.create());
    } else {
        self = new PluginLoader(loadTimeout, callback);
        self.load(plugins);
        self.startTimers();
        self.center();
    }
}
#end_block

#method_before
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    topMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    bottomMenu = RootPanel.get("gerrit_btmmenu");
    topMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    topMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            String token = view.getToken();
            History.newItem(token, false);
            dispatchHistoryHooks(token);
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
            lastViewToken = token;
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus();
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    ApiGlue.init();
    applyUserPreferences();
    populateBottomMenu(bottomMenu, hpd);
    refreshMenuBar(false);
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    saveDefaultTheme();
    if (hpd.messages != null) {
        new MessageOfTheDayBar(hpd.messages).show();
    }
    CallbackGroup cbg = new CallbackGroup();
    if (isSignedIn()) {
        AccountApi.self().view("preferences").get(cbg.add(createMyMenuBarCallback()));
    }
    PluginLoader.load(hpd.plugins, cbg.addFinal(new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            String token = History.getToken();
            if (token.isEmpty()) {
                token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
            }
            display(token);
        }
    }), hpd.pluginsLoadTimeout);
}
#method_after
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    topMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    bottomMenu = RootPanel.get("gerrit_btmmenu");
    topMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    topMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            String token = view.getToken();
            History.newItem(token, false);
            dispatchHistoryHooks(token);
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
            lastViewToken = token;
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus();
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    ApiGlue.init();
    applyUserPreferences();
    populateBottomMenu(bottomMenu, hpd);
    refreshMenuBar(false);
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    saveDefaultTheme();
    if (hpd.messages != null) {
        new MessageOfTheDayBar(hpd.messages).show();
    }
    CallbackGroup cbg = new CallbackGroup();
    if (isSignedIn()) {
        AccountApi.self().view("preferences").get(cbg.add(createMyMenuBarCallback()));
    }
    PluginLoader.load(hpd.plugins, hpd.pluginsLoadTimeout, cbg.addFinal(new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            String token = History.getToken();
            if (token.isEmpty()) {
                token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
            }
            display(token);
        }
    }));
}
#end_block

#method_before
private int getPluginsLoadTimeout(final Config cfg) {
    long cfgValue = ConfigUtil.getTimeUnit(cfg, "plugins", null, "jsLoadTimeout", 5000, TimeUnit.MILLISECONDS);
    if (cfgValue < 0) {
        return 0;
    }
    return (int) cfgValue;
}
#method_after
private static int getPluginsLoadTimeout(final Config cfg) {
    long cfgValue = ConfigUtil.getTimeUnit(cfg, "plugins", null, "jsLoadTimeout", DEFAULT_JS_LOAD_TIMEOUT, TimeUnit.MILLISECONDS);
    if (cfgValue < 0) {
        return 0;
    }
    return (int) cfgValue;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EventQueue.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(EventQueue.class);
    bind(EventStore.class).to(SQLStore.class);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(SQLStore.class);
    bind(QueryMaker.class).to(SQLQueryMaker.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventHandler.class);
}
#method_after
@Override
protected void configure() {
    bind(EventQueue.class).in(Scopes.SINGLETON);
    bind(EventHandler.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(EventQueue.class);
    bind(EventStore.class).to(SQLStore.class);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(SQLStore.class);
    bind(QueryMaker.class).to(SQLQueryMaker.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventHandler.class);
}
#end_block

#method_before
@Before
public void setUp() {
    easyMock = new EasyMockSupport();
    storeMock = easyMock.createMock(EventStore.class);
    queueMock = easyMock.createMock(EventQueue.class);
    listener = new EventHandler(storeMock, queueMock);
}
#method_after
@Before
public void setUp() {
    easyMock = new EasyMockSupport();
    storeMock = easyMock.createMock(EventStore.class);
    poolMock = new PoolMock(1);
    listener = new EventHandler(storeMock, poolMock);
}
#end_block

#method_before
@Override
public void onEvent(Event event) {
    if (event instanceof ProjectEvent) {
        if (pool != null) {
            pool.execute(new StoreEventTask((ProjectEvent) event));
        } else {
            (new StoreEventTask((ProjectEvent) event)).run();
        }
    }
}
#method_after
@Override
public void onEvent(Event event) {
    pool.execute(new StoreEventTask((ProjectEvent) event));
}
#end_block

#method_before
public WorkQueue.Executor getPool() {
    return this.pool;
}
#method_after
public ScheduledThreadPoolExecutor getPool() {
    return this.pool;
}
#end_block

#method_before
public void apply(ProjectResource rsrc) throws ResourceNotFoundException, ResourceConflictException, IOException {
    try {
        MetaDataUpdate md = metaDataUpdateFactory.create(rsrc.getNameKey());
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setState(ProjectState.HIDDEN);
        for (AccessSection as : projectConfig.getAccessSections()) {
            projectConfig.remove(as);
        }
        String parentForDeletedProjects = cfgFactory.getFromGerritConfig(pluginName).getString("parentForDeletedProjects", DEFAULT_PARENT_FOR_DELETED_PROJECTS);
        createParentForDeletedProjectsIfMissing(parentForDeletedProjects);
        p.setParentName(parentForDeletedProjects);
        md.setMessage("Hide project\n");
        projectConfig.commit(md);
        projectCache.evict(projectConfig.getProject());
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException();
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
public void apply(ProjectResource rsrc) throws ResourceNotFoundException, ResourceConflictException, IOException {
    try {
        MetaDataUpdate md = metaDataUpdateFactory.create(rsrc.getNameKey());
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setState(ProjectState.HIDDEN);
        for (AccessSection as : projectConfig.getAccessSections()) {
            projectConfig.remove(as);
        }
        String parentForDeletedProjects = cfgFactory.getFromGerritConfig(pluginName).getString("parentForDeletedProjects", DEFAULT_PARENT_FOR_DELETED_PROJECTS);
        createProjectIfMissing(parentForDeletedProjects);
        p.setParentName(parentForDeletedProjects);
        md.setMessage("Hide project\n");
        projectConfig.commit(md);
        projectCache.evict(projectConfig.getProject());
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException();
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
public void onDelete(IdentifiedUser user, Project.NameKey project, DeleteProject.Input options, Exception ex) {
    long ts = TimeUtil.nowMs();
    LoggingEvent event = new // 
    LoggingEvent(// fqnOfCategoryClass
    Logger.class.getName(), // logger
    log, // when
    ts, // level
    ex == null ? Level.INFO : Level.ERROR, ex == null ? "ProjectDeletion" : // message text
    "ProjectDeletionFailure", // thread name
    Thread.currentThread().getName(), // exception information
    null, // current NDC string
    null, // caller location
    null, // MDC properties
    null);
    event.setProperty(ACCOUNT_ID, user.getAccountId().toString());
    event.setProperty(USER_NAME, user.getUserName());
    event.setProperty(PROJECT_NAME, project.get());
    if (options != null) {
        event.setProperty(OPTIONS, OutputFormat.JSON_COMPACT.newGson().toJson(options));
    }
    if (ex != null) {
        event.setProperty(ERROR, ex.toString());
    }
    log.callAppenders(event);
    audit(user, ts, project, options, ex);
}
#method_after
public void onDelete(IdentifiedUser user, Project.NameKey project, DeleteProject.Input options, Exception ex) {
    long ts = TimeUtil.nowMs();
    LoggingEvent event = new // 
    LoggingEvent(// fqnOfCategoryClass
    Logger.class.getName(), // logger
    log, // when
    ts, // level
    ex == null ? Level.INFO : Level.ERROR, // message text
    ex == null ? "OK" : "FAIL", // thread name
    Thread.currentThread().getName(), // exception information
    null, // current NDC string
    null, // caller location
    null, // MDC properties
    null);
    event.setProperty(ACCOUNT_ID, user.getAccountId().toString());
    event.setProperty(USER_NAME, user.getUserName());
    event.setProperty(PROJECT_NAME, project.get());
    if (options != null) {
        event.setProperty(OPTIONS, OutputFormat.JSON_COMPACT.newGson().toJson(options));
    }
    if (ex != null) {
        event.setProperty(ERROR, ex.toString());
    }
    log.callAppenders(event);
    audit(user, ts, project, options, ex);
}
#end_block

#method_before
private void audit(IdentifiedUser user, long ts, Project.NameKey project, DeleteProject.Input options, Exception ex) {
    StringBuilder msg = new StringBuilder();
    msg.append("ProjectDeletion");
    if (ex != null) {
        msg.append("Failure");
    }
    msg.append(": ");
    msg.append(project.get());
    Multimap<String, String> params = HashMultimap.create();
    params.put("force", Boolean.valueOf(options.force).toString());
    params.put("preserve", Boolean.valueOf(options.preserve).toString());
    auditService.dispatch(new AuditEvent(null, user, msg.toString(), ts, params, ex != null ? ex.toString() : "OK"));
}
#method_after
private void audit(IdentifiedUser user, long ts, Project.NameKey project, DeleteProject.Input options, Exception ex) {
    Multimap<String, Object> params = HashMultimap.create();
    params.put("class", DeleteLog.class);
    params.put("project", project.get());
    params.put("force", String.valueOf(options.force));
    params.put("preserve", String.valueOf(options.preserve));
    auditService.dispatch(new AuditEvent(// sessionId
    null, // who
    user, // what
    ex == null ? "ProjectDeletion" : "ProjectDeletionFailure", // when
    ts, // params
    params, // result
    ex != null ? ex.toString() : "OK"));
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    if (problemsForSubmittingChanges(Arrays.asList(cd), resource.getUser()) != null) {
        visible = false;
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic)) {
        List<ChangeData> changesByTopic = null;
        try {
            changesByTopic = queryProvider.get().byTopicOpen(topic);
        } catch (OrmException e) {
            throw new OrmRuntimeException(e);
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        String topicProblems = problemsForSubmittingChanges(changesByTopic, resource.getUser());
        if (topicProblems != null) {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(topicProblems).setVisible(true).setEnabled(false);
        } else {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(true);
        }
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true);
    }
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    if (problemsForSubmittingChanges(Arrays.asList(cd), resource.getUser()) != null) {
        visible = false;
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    List<ChangeData> changesByTopic = null;
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic)) {
        changesByTopic = getChangesByTopic(topic);
    }
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic) && changesByTopic.size() > 1) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        String topicProblems = problemsForSubmittingChanges(changesByTopic, resource.getUser());
        if (topicProblems != null) {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(topicProblems).setVisible(true).setEnabled(false);
        } else {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(true);
        }
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true);
    }
}
#end_block

#method_before
private Change submitThisChange(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = submitToDatabase(db, change.getId(), timestamp);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#method_after
private Change submitThisChange(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(change.currentPatchSetId(), cd.changeControl(), update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = submitToDatabase(db, change.getId(), timestamp);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#end_block

#method_before
private List<Change> submitWholeTopic(RevisionResource rsrc, IdentifiedUser caller, boolean force, String topic) throws ResourceConflictException, OrmException, IOException {
    Preconditions.checkNotNull(topic);
    final Timestamp timestamp = TimeUtil.nowTs();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<ChangeData> changesByTopic = queryProvider.get().byTopicOpen(topic);
    String problems = problemsForSubmittingChanges(changesByTopic, caller);
    if (problems != null) {
        throw new ResourceConflictException(problems);
    }
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        for (ChangeData c : changesByTopic) {
            RevisionResource resource = new RevisionResource(new ChangeResource(c.changeControl()), c.currentPatchSet());
            BatchMetaDataUpdate batch = approve(resource, update, caller, timestamp);
            // Write update commit after all normalized label commits.
            batch.write(update, new CommitBuilder());
            submitToDatabase(db, c.getId(), timestamp);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    List<Change.Id> ids = new ArrayList<>(changesByTopic.size());
    List<Change> ret = new ArrayList<>(changesByTopic.size());
    for (ChangeData c : changesByTopic) {
        ids.add(c.getId());
        ret.add(c.change());
    }
    indexer.indexAsync(ids).checkedGet();
    return ret;
}
#method_after
private List<Change> submitWholeTopic(RevisionResource rsrc, IdentifiedUser caller, boolean force, String topic) throws ResourceConflictException, OrmException, IOException {
    Preconditions.checkNotNull(topic);
    final Timestamp timestamp = TimeUtil.nowTs();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<ChangeData> changesByTopic = queryProvider.get().byTopicOpen(topic);
    String problems = problemsForSubmittingChanges(changesByTopic, caller);
    if (problems != null) {
        throw new ResourceConflictException(problems);
    }
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        for (ChangeData c : changesByTopic) {
            BatchMetaDataUpdate batch = approve(c.currentPatchSet().getId(), c.changeControl(), update, caller, timestamp);
            // Write update commit after all normalized label commits.
            batch.write(update, new CommitBuilder());
            submitToDatabase(db, c.getId(), timestamp);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    List<Change.Id> ids = new ArrayList<>(changesByTopic.size());
    List<Change> ret = new ArrayList<>(changesByTopic.size());
    for (ChangeData c : changesByTopic) {
        ids.add(c.getId());
        ret.add(c.change());
    }
    indexer.indexAsync(ids).checkedGet();
    return ret;
}
#end_block

#method_before
private BatchMetaDataUpdate approve(RevisionResource rsrc, ChangeUpdate update, IdentifiedUser caller, Timestamp timestamp) throws OrmException {
    PatchSet.Id psId = rsrc.getPatchSet().getId();
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = Maps.newHashMap();
    for (PatchSetApproval psa : approvalsUtil.byPatchSet(dbProvider.get(), rsrc.getControl(), psId)) {
        if (!byKey.containsKey(psa.getKey())) {
            byKey.put(psa.getKey(), psa);
        }
    }
    PatchSetApproval submit = ApprovalsUtil.getSubmitter(psId, byKey.values());
    if (submit == null || !submit.getAccountId().equals(caller.getAccountId())) {
        submit = new PatchSetApproval(new PatchSetApproval.Key(rsrc.getPatchSet().getId(), caller.getAccountId(), LabelId.SUBMIT), (short) 1, TimeUtil.nowTs());
        byKey.put(submit.getKey(), submit);
    }
    submit.setValue((short) 1);
    submit.setGranted(timestamp);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = labelNormalizer.normalize(rsrc.getControl(), byKey.values());
    // TODO(dborowitz): Don't use a label in notedb; just check when status
    // change happened.
    update.putApproval(submit.getLabel(), submit.getValue());
    dbProvider.get().patchSetApprovals().upsert(normalized.getNormalized());
    dbProvider.get().patchSetApprovals().delete(normalized.deleted());
    try {
        return saveToBatch(rsrc, update, normalized, timestamp);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
private BatchMetaDataUpdate approve(PatchSet.Id psId, ChangeControl control, ChangeUpdate update, IdentifiedUser caller, Timestamp timestamp) throws OrmException {
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = Maps.newHashMap();
    for (PatchSetApproval psa : approvalsUtil.byPatchSet(dbProvider.get(), control, psId)) {
        if (!byKey.containsKey(psa.getKey())) {
            byKey.put(psa.getKey(), psa);
        }
    }
    PatchSetApproval submit = ApprovalsUtil.getSubmitter(psId, byKey.values());
    if (submit == null || !submit.getAccountId().equals(caller.getAccountId())) {
        submit = new PatchSetApproval(new PatchSetApproval.Key(psId, caller.getAccountId(), LabelId.SUBMIT), (short) 1, TimeUtil.nowTs());
        byKey.put(submit.getKey(), submit);
    }
    submit.setValue((short) 1);
    submit.setGranted(timestamp);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = labelNormalizer.normalize(control, byKey.values());
    // TODO(dborowitz): Don't use a label in notedb; just check when status
    // change happened.
    update.putApproval(submit.getLabel(), submit.getValue());
    dbProvider.get().patchSetApprovals().upsert(normalized.getNormalized());
    dbProvider.get().patchSetApprovals().delete(normalized.deleted());
    try {
        return saveToBatch(control, update, normalized, timestamp);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
private BatchMetaDataUpdate saveToBatch(RevisionResource rsrc, ChangeUpdate callerUpdate, LabelNormalizer.Result normalized, Timestamp timestamp) throws IOException {
    Table<Account.Id, String, Optional<Short>> byUser = HashBasedTable.create();
    for (PatchSetApproval psa : normalized.updated()) {
        byUser.put(psa.getAccountId(), psa.getLabel(), Optional.of(psa.getValue()));
    }
    for (PatchSetApproval psa : normalized.deleted()) {
        byUser.put(psa.getAccountId(), psa.getLabel(), Optional.<Short>absent());
    }
    ChangeControl ctl = rsrc.getControl();
    BatchMetaDataUpdate batch = callerUpdate.openUpdate();
    for (Account.Id accountId : byUser.rowKeySet()) {
        if (!accountId.equals(callerUpdate.getUser().getAccountId())) {
            ChangeUpdate update = updateFactory.create(ctl.forUser(userFactory.create(dbProvider, accountId)), timestamp);
            update.setSubject("Finalize approvals at submit");
            putApprovals(update, byUser.row(accountId));
            CommitBuilder commit = new CommitBuilder();
            commit.setCommitter(new PersonIdent(serverIdent, timestamp));
            batch.write(update, commit);
        }
    }
    putApprovals(callerUpdate, byUser.row(callerUpdate.getUser().getAccountId()));
    return batch;
}
#method_after
private BatchMetaDataUpdate saveToBatch(ChangeControl ctl, ChangeUpdate callerUpdate, LabelNormalizer.Result normalized, Timestamp timestamp) throws IOException {
    Table<Account.Id, String, Optional<Short>> byUser = HashBasedTable.create();
    for (PatchSetApproval psa : normalized.updated()) {
        byUser.put(psa.getAccountId(), psa.getLabel(), Optional.of(psa.getValue()));
    }
    for (PatchSetApproval psa : normalized.deleted()) {
        byUser.put(psa.getAccountId(), psa.getLabel(), Optional.<Short>absent());
    }
    BatchMetaDataUpdate batch = callerUpdate.openUpdate();
    for (Account.Id accountId : byUser.rowKeySet()) {
        if (!accountId.equals(callerUpdate.getUser().getAccountId())) {
            ChangeUpdate update = updateFactory.create(ctl.forUser(userFactory.create(dbProvider, accountId)), timestamp);
            update.setSubject("Finalize approvals at submit");
            putApprovals(update, byUser.row(accountId));
            CommitBuilder commit = new CommitBuilder();
            commit.setCommitter(new PersonIdent(serverIdent, timestamp));
            batch.write(update, commit);
        }
    }
    putApprovals(callerUpdate, byUser.row(callerUpdate.getUser().getAccountId()));
    return batch;
}
#end_block

#method_before
public void assertStatus(Status expectedStatus, String expectedMessage) {
    RemoteRefUpdate refUpdate = result.getRemoteUpdate(ref);
    assertThat(expectedStatus).named(message(refUpdate)).isEqualTo(refUpdate.getStatus());
    assertThat(expectedMessage).isEqualTo(refUpdate.getMessage());
}
#method_after
private void assertStatus(Status expectedStatus, String expectedMessage) {
    RemoteRefUpdate refUpdate = result.getRemoteUpdate(ref);
    assertThat(expectedStatus).named(message(refUpdate)).isEqualTo(refUpdate.getStatus());
    assertThat(expectedMessage).isEqualTo(refUpdate.getMessage());
}
#end_block

#method_before
@Test
public void forcePushNotAllowed() throws GitAPIException, IOException {
    ObjectId initial = git.getRepository().getRef(HEAD).getLeaf().getObjectId();
    PushOneCommit push1 = pushFactory.create(db, admin.getIdent(), "change1", "a.txt", "content");
    PushOneCommit.Result r1 = push1.to(git, "refs/heads/master");
    r1.assertOkStatus();
    // Reset HEAD to initial so the new change is a non-fast forward
    RefUpdate ru = git.getRepository().updateRef(HEAD);
    ru.setNewObjectId(initial);
    assertThat(ru.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED);
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), "change2", "b.txt", "content");
    push2.setForce(true);
    PushOneCommit.Result r2 = push2.to(git, "refs/heads/master");
    r2.assertStatus(Status.REJECTED_OTHER_REASON, "non-fast forward");
}
#method_after
@Test
public void forcePushNotAllowed() throws Exception {
    ObjectId initial = git.getRepository().getRef(HEAD).getLeaf().getObjectId();
    PushOneCommit push1 = pushFactory.create(db, admin.getIdent(), "change1", "a.txt", "content");
    PushOneCommit.Result r1 = push1.to(git, "refs/heads/master");
    r1.assertOkStatus();
    // Reset HEAD to initial so the new change is a non-fast forward
    RefUpdate ru = git.getRepository().updateRef(HEAD);
    ru.setNewObjectId(initial);
    assertThat(ru.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED);
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), "change2", "b.txt", "content");
    push2.setForce(true);
    PushOneCommit.Result r2 = push2.to(git, "refs/heads/master");
    r2.assertErrorStatus("non-fast forward");
}
#end_block

#method_before
@Test
public void forcePushAllowed() throws GitAPIException, IOException, ConfigInvalidException {
    ObjectId initial = git.getRepository().getRef(HEAD).getLeaf().getObjectId();
    grant(Permission.PUSH, project, "refs/*", true);
    PushOneCommit push1 = pushFactory.create(db, admin.getIdent(), "change1", "a.txt", "content");
    PushOneCommit.Result r1 = push1.to(git, "refs/heads/master");
    r1.assertOkStatus();
    // Reset HEAD to initial so the new change is a non-fast forward
    RefUpdate ru = git.getRepository().updateRef(HEAD);
    ru.setNewObjectId(initial);
    assertThat(ru.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED);
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), "change2", "b.txt", "content");
    push2.setForce(true);
    PushOneCommit.Result r2 = push2.to(git, "refs/heads/master");
    r2.assertOkStatus();
}
#method_after
@Test
public void forcePushAllowed() throws Exception {
    ObjectId initial = git.getRepository().getRef(HEAD).getLeaf().getObjectId();
    grant(Permission.PUSH, project, "refs/*", true);
    PushOneCommit push1 = pushFactory.create(db, admin.getIdent(), "change1", "a.txt", "content");
    PushOneCommit.Result r1 = push1.to(git, "refs/heads/master");
    r1.assertOkStatus();
    // Reset HEAD to initial so the new change is a non-fast forward
    RefUpdate ru = git.getRepository().updateRef(HEAD);
    ru.setNewObjectId(initial);
    assertThat(ru.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED);
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), "change2", "b.txt", "content");
    push2.setForce(true);
    PushOneCommit.Result r2 = push2.to(git, "refs/heads/master");
    r2.assertOkStatus();
}
#end_block

#method_before
private int adjustCommitMessageLine(int line) {
    int offset = 6;
    if (diff.text_b().startsWith("Merge")) {
        offset += 1;
    }
    if (line <= offset) {
        return 1;
    } else {
        return line - offset;
    }
}
#method_after
private int adjustCommitMessageLine(int line) {
    /* When commit messages are shown in the side-by-side screen they include
      a header block that looks like this:

      1 Parent:     deadbeef (Parent commit title)
      2 Author:     A. U. Thor <author@example.com>
      3 AuthorDate: 2015-02-27 19:20:52 +0900
      4 Commit:     A. U. Thor <author@example.com>
      5 CommitDate: 2015-02-27 19:20:52 +0900
      6 [blank line]
      7 Commit message title
      8
      9 Commit message body
     10 ...
     11 ...

    If the commit is a merge commit, both parent commits are listed in the
    first two lines instead of a 'Parent' line:

      1 Merge Of:   deadbeef (Parent 1 commit title)
      2             beefdead (Parent 2 commit title)

    */
    // Offset to compensate for header lines until the blank line
    // after 'CommitDate'
    int offset = 6;
    // Adjust for merge commits, which have two parent lines
    if (diff.text_b().startsWith("Merge")) {
        offset += 1;
    }
    // focus is on the correct line.
    if (line <= offset) {
        return 1;
    } else {
        return line - offset;
    }
}
#end_block

#method_before
@Test
public void suggestAccounts() throws Exception {
    List<AccountInfo> result = gApi.accounts().suggestAccounts("admin").get();
    assertThat(result.size()).is(1);
    assertThat(result.get(0).username.equals("admin"));
    List<AccountInfo> emptyResult = gApi.accounts().suggestAccounts("unknown").get();
    assertThat(emptyResult.isEmpty()).isTrue();
}
#method_after
@Test
public void suggestAccounts() throws Exception {
    String adminUsername = "admin";
    List<AccountInfo> result = gApi.accounts().suggestAccounts().withQuery(adminUsername).get();
    assertThat(result.size()).is(1);
    assertThat(result.get(0).username.equals(adminUsername));
    List<AccountInfo> resultShortcutApi = gApi.accounts().suggestAccounts(adminUsername).get();
    assertThat(resultShortcutApi.size()).is(result.size());
    List<AccountInfo> emptyResult = gApi.accounts().suggestAccounts("unknown").get();
    assertThat(emptyResult).isEmpty();
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.setAllowNonFastForwards(magicBranch.edit);
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.setAllowNonFastForwards(magicBranch != null && magicBranch.edit);
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = false;
        if (magicBranch != null && magicBranch.edit) {
            edit = true;
        }
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(final String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.getLabel());
        ApprovalsUtil.checkLabel(labelTypes, v.getLabel(), v.getValue());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.getLabel(), v.getValue());
}
#method_after
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(final String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(destBranch).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(destBranch).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c;
    try {
        // Force submit even if submit rule evaluation fails.
        c = submit.submit(rsrc, currentUser, true);
    } catch (ResourceConflictException e) {
        throw new IOException(e);
    }
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c;
    try {
        // Force submit even if submit rule evaluation fails.
        c = submit.submit(rsrc, currentUser, true);
    } catch (ResourceConflictException e) {
        throw new IOException(e);
    }
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            // $FALL-THROUGH$
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#end_block

#method_before
private boolean newEdit() {
    newPatchSet = new PatchSet(change.currentPatchSetId());
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(change);
    } catch (AuthException | IOException e) {
        log.error("Cannt retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(newPatchSet.getId())) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommit, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#method_after
private boolean newEdit() {
    newPatchSet = new PatchSet(change.currentPatchSetId());
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(change, currentUser);
    } catch (IOException e) {
        log.error("Cannt retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(newPatchSet.getId())) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommit, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#end_block

#method_before
CheckedFuture<PatchSet.Id, InsertException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException, NoSuchChangeException {
            try {
                if (caller == Thread.currentThread() || magicBranch.edit) {
                    return magicBranch.edit ? upsertEdit() : insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#method_after
CheckedFuture<PatchSet.Id, InsertException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException, NoSuchChangeException {
            try {
                if (magicBranch.edit) {
                    return upsertEdit();
                } else if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
private ChangeMessage newChangeMessage(ReviewDb db) throws OrmException {
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), newPatchSet.getCreatedOn(), newPatchSet.getId());
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    ChangeKind changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
    String message = "Uploaded patch set " + newPatchSet.getPatchSetId();
    switch(changeKind) {
        case TRIVIAL_REBASE:
            message += ": Patch Set " + priorPatchSet.get() + " was rebased";
            break;
        case NO_CODE_CHANGE:
            message += ": Commit message was updated";
            break;
        case REWORK:
        default:
            break;
    }
    msg.setMessage(message + ".");
    return msg;
}
#method_after
private ChangeMessage newChangeMessage(ReviewDb db, ChangeKind changeKind) throws OrmException {
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), newPatchSet.getCreatedOn(), newPatchSet.getId());
    String message = "Uploaded patch set " + newPatchSet.getPatchSetId();
    switch(changeKind) {
        case TRIVIAL_REBASE:
            message += ": Patch Set " + priorPatchSet.get() + " was rebased";
            break;
        case NO_CODE_CHANGE:
            message += ": Commit message was updated";
            break;
        case REWORK:
        default:
            break;
    }
    msg.setMessage(message + ".");
    return msg;
}
#end_block

#method_before
PatchSet.Id upsertEdit() {
    // TODO(davido): remove old edit ref when exists
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id upsertEdit() {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, changeCtl, approvals);
        recipients.add(oldRecipients);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(ReplaceRequest.this);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    f.checkedGet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db, commit.getName());
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
public Optional<ChangeEdit> byChange(Change change) throws AuthException, IOException {
    if (!user.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        IdentifiedUser me = (IdentifiedUser) user.get();
        String editRefPrefix = editRefPrefix(me.getAccountId(), change.getId());
        Map<String, Ref> refs = repo.getRefDatabase().getRefs(editRefPrefix);
        if (refs.isEmpty()) {
            return Optional.absent();
        }
        // TODO(davido): Rather than failing when we encounter the corrupt state
        // where there is more than one ref, we could silently delete all but the
        // current one.
        Ref ref = Iterables.getOnlyElement(refs.values());
        RevWalk rw = new RevWalk(repo);
        try {
            RevCommit commit = rw.parseCommit(ref.getObjectId());
            PatchSet basePs = getBasePatchSet(change, ref);
            return Optional.of(new ChangeEdit(me, change, ref, commit, basePs));
        } finally {
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
public Optional<ChangeEdit> byChange(Change change) throws AuthException, IOException {
    CurrentUser currentUser = user.get();
    if (!currentUser.isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    return byChange(change, (IdentifiedUser) currentUser);
}
#end_block

#method_before
public Optional<ChangeEdit> byChange(Change change) throws AuthException, IOException {
    if (!user.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        IdentifiedUser me = (IdentifiedUser) user.get();
        String editRefPrefix = editRefPrefix(me.getAccountId(), change.getId());
        Map<String, Ref> refs = repo.getRefDatabase().getRefs(editRefPrefix);
        if (refs.isEmpty()) {
            return Optional.absent();
        }
        // TODO(davido): Rather than failing when we encounter the corrupt state
        // where there is more than one ref, we could silently delete all but the
        // current one.
        Ref ref = Iterables.getOnlyElement(refs.values());
        RevWalk rw = new RevWalk(repo);
        try {
            RevCommit commit = rw.parseCommit(ref.getObjectId());
            PatchSet basePs = getBasePatchSet(change, ref);
            return Optional.of(new ChangeEdit(me, change, ref, commit, basePs));
        } finally {
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
public Optional<ChangeEdit> byChange(Change change, IdentifiedUser me) throws IOException {
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        String editRefPrefix = editRefPrefix(me.getAccountId(), change.getId());
        Map<String, Ref> refs = repo.getRefDatabase().getRefs(editRefPrefix);
        if (refs.isEmpty()) {
            return Optional.absent();
        }
        // TODO(davido): Rather than failing when we encounter the corrupt state
        // where there is more than one ref, we could silently delete all but the
        // current one.
        Ref ref = Iterables.getOnlyElement(refs.values());
        RevWalk rw = new RevWalk(repo);
        try {
            RevCommit commit = rw.parseCommit(ref.getObjectId());
            PatchSet basePs = getBasePatchSet(change, ref);
            return Optional.of(new ChangeEdit(me, change, ref, commit, basePs));
        } finally {
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setUseAutoBase(getEnum(rc, RECEIVE, null, KEY_USE_AUTO_BASE, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadBranchOrderSection(rc);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setCreateNewChangeForAllNotInTarget(getEnum(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadBranchOrderSection(rc);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_USE_AUTO_BASE, p.getUseAutoBase(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), defaultStateValue);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveLabelSections(rc);
    savePluginSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, p.getCreateNewChangeForAllNotInTarget(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), defaultStateValue);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveLabelSections(rc);
    savePluginSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
    return true;
}
#end_block

#method_before
@Override
public ConfigInfo apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = rsrc.getNameKey();
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(projectName.get());
    }
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.useAutoBase != null) {
            p.setUseAutoBase(input.useAutoBase);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        if (input.pluginConfigValues != null) {
            setPluginConfigValues(rsrc.getControl().getProjectState(), projectConfig, input.pluginConfigValues);
        }
        md.setMessage("Modified project settings\n");
        try {
            ObjectId baseRev = projectConfig.getRevision();
            ObjectId commitRev = projectConfig.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equal(baseRev, commitRev)) {
                IdentifiedUser user = (IdentifiedUser) currentUser.get();
                hooks.doRefUpdatedHook(new Branch.NameKey(projectName, RefNames.REFS_CONFIG), baseRev, commitRev, user.getAccount());
            }
            ;
            projectCache.evict(projectConfig.getProject());
            gitMgr.setProjectDescription(projectName, p.getDescription());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfo(state.controlFor(currentUser.get()), config, pluginConfigEntries, cfgFactory, allProjects, views);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#method_after
@Override
public ConfigInfo apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = rsrc.getNameKey();
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(projectName.get());
    }
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.createNewChangeForAllNotInTarget != null) {
            p.setCreateNewChangeForAllNotInTarget(input.createNewChangeForAllNotInTarget);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        if (input.pluginConfigValues != null) {
            setPluginConfigValues(rsrc.getControl().getProjectState(), projectConfig, input.pluginConfigValues);
        }
        md.setMessage("Modified project settings\n");
        try {
            ObjectId baseRev = projectConfig.getRevision();
            ObjectId commitRev = projectConfig.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equal(baseRev, commitRev)) {
                IdentifiedUser user = (IdentifiedUser) currentUser.get();
                hooks.doRefUpdatedHook(new Branch.NameKey(projectName, RefNames.REFS_CONFIG), baseRev, commitRev, user.getAccount());
            }
            ;
            projectCache.evict(projectConfig.getProject());
            gitMgr.setProjectDescription(projectName, p.getDescription());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfo(state.controlFor(currentUser.get()), config, pluginConfigEntries, cfgFactory, allProjects, views);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.setCmdLineParser(clp);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (useAutoBase) {
        String magicBranchRef = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(magicBranchRef).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), magicBranchRef), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.setCmdLineParser(clp);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(destBranch).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.maxBatchChanges;
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (useAutoBase && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "You can't push merges with auto base on");
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.maxBatchChanges;
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
public static void setConfig(Project.NameKey name, String description, InheritableBoolean useContributorAgreements, InheritableBoolean useContentMerge, InheritableBoolean useSignedOffBy, InheritableBoolean useAutoBase, InheritableBoolean requireChangeId, String maxObjectSizeLimit, SubmitType submitType, ProjectState state, Map<String, Map<String, ConfigParameterValue>> pluginConfigValues, AsyncCallback<ConfigInfo> cb) {
    ConfigInput in = ConfigInput.create();
    in.setDescription(description);
    in.setUseContributorAgreements(useContributorAgreements);
    in.setUseContentMerge(useContentMerge);
    in.setUseSignedOffBy(useSignedOffBy);
    in.setRequireChangeId(requireChangeId);
    in.setUseAutoBase(useAutoBase);
    in.setMaxObjectSizeLimit(maxObjectSizeLimit);
    in.setSubmitType(submitType);
    in.setState(state);
    in.setPluginConfigValues(pluginConfigValues);
    project(name).view("config").put(in, cb);
}
#method_after
public static void setConfig(Project.NameKey name, String description, InheritableBoolean useContributorAgreements, InheritableBoolean useContentMerge, InheritableBoolean useSignedOffBy, InheritableBoolean createNewChangeForAllNotInTarget, InheritableBoolean requireChangeId, String maxObjectSizeLimit, SubmitType submitType, ProjectState state, Map<String, Map<String, ConfigParameterValue>> pluginConfigValues, AsyncCallback<ConfigInfo> cb) {
    ConfigInput in = ConfigInput.create();
    in.setDescription(description);
    in.setUseContributorAgreements(useContributorAgreements);
    in.setUseContentMerge(useContentMerge);
    in.setUseSignedOffBy(useSignedOffBy);
    in.setRequireChangeId(requireChangeId);
    in.setCreateNewChangeForAllNotInTarget(createNewChangeForAllNotInTarget);
    in.setMaxObjectSizeLimit(maxObjectSizeLimit);
    in.setSubmitType(submitType);
    in.setState(state);
    in.setPluginConfigValues(pluginConfigValues);
    project(name).view("config").put(in, cb);
}
#end_block

#method_before
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ProjectCreationFailedException, ResourceNotFoundException, IOException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = MoreObjects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = MoreObjects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : MoreObjects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.autoBase = MoreObjects.firstNonNull(input.useAutoBase, InheritableBoolean.INHERIT);
    args.changeIdRequired = MoreObjects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProjectFactory.create(args).createProject();
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), currentUser.get());
            PutConfig.Input in = new PutConfig.Input();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(new ProjectResource(projectControl), in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#method_after
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ProjectCreationFailedException, ResourceNotFoundException, IOException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = MoreObjects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = MoreObjects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : MoreObjects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.newChangeForAllNotInTarget = MoreObjects.firstNonNull(input.createNewChangeForAllNotInTarget, InheritableBoolean.INHERIT);
    args.changeIdRequired = MoreObjects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProjectFactory.create(args).createProject();
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), currentUser.get());
            PutConfig.Input in = new PutConfig.Input();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(new ProjectResource(projectControl), in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#end_block

#method_before
public void copySettingsFrom(final Project update) {
    description = update.description;
    useContributorAgreements = update.useContributorAgreements;
    useSignedOffBy = update.useSignedOffBy;
    useContentMerge = update.useContentMerge;
    requireChangeID = update.requireChangeID;
    submitType = update.submitType;
    state = update.state;
    maxObjectSizeLimit = update.maxObjectSizeLimit;
    useAutoBase = update.useAutoBase;
}
#method_after
public void copySettingsFrom(final Project update) {
    description = update.description;
    useContributorAgreements = update.useContributorAgreements;
    useSignedOffBy = update.useSignedOffBy;
    useContentMerge = update.useContentMerge;
    requireChangeID = update.requireChangeID;
    submitType = update.submitType;
    state = update.state;
    maxObjectSizeLimit = update.maxObjectSizeLimit;
    createNewChangeForAllNotInTarget = update.createNewChangeForAllNotInTarget;
}
#end_block

#method_before
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(MoreObjects.firstNonNull(createProjectArgs.submitType, cfg.getEnum("repository", "*", "defaultSubmitType", SubmitType.MERGE_IF_NECESSARY)));
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setUseAutoBase(createProjectArgs.autoBase);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        newProject.setMaxObjectSizeLimit(createProjectArgs.maxObjectSizeLimit);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
}
#method_after
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(MoreObjects.firstNonNull(createProjectArgs.submitType, cfg.getEnum("repository", "*", "defaultSubmitType", SubmitType.MERGE_IF_NECESSARY)));
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setCreateNewChangeForAllNotInTarget(createProjectArgs.newChangeForAllNotInTarget);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        newProject.setMaxObjectSizeLimit(createProjectArgs.maxObjectSizeLimit);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
}
#end_block

#method_before
private void enableForm(boolean isOwner) {
    state.setEnabled(isOwner);
    submitType.setEnabled(isOwner);
    setEnabledForUseContentMerge();
    autoBase.setEnabled(isOwner);
    descTxt.setEnabled(isOwner);
    contributorAgreements.setEnabled(isOwner);
    signedOffBy.setEnabled(isOwner);
    requireChangeID.setEnabled(isOwner);
    maxObjectSizeLimit.setEnabled(isOwner);
    if (pluginConfigWidgets != null) {
        for (Map<String, HasEnabled> widgetMap : pluginConfigWidgets.values()) {
            for (HasEnabled widget : widgetMap.values()) {
                widget.setEnabled(isOwner);
            }
        }
    }
}
#method_after
private void enableForm(boolean isOwner) {
    state.setEnabled(isOwner);
    submitType.setEnabled(isOwner);
    setEnabledForUseContentMerge();
    newChangeForAllNotInTarget.setEnabled(isOwner);
    descTxt.setEnabled(isOwner);
    contributorAgreements.setEnabled(isOwner);
    signedOffBy.setEnabled(isOwner);
    requireChangeID.setEnabled(isOwner);
    maxObjectSizeLimit.setEnabled(isOwner);
    if (pluginConfigWidgets != null) {
        for (Map<String, HasEnabled> widgetMap : pluginConfigWidgets.values()) {
            for (HasEnabled widget : widgetMap.values()) {
                widget.setEnabled(isOwner);
            }
        }
    }
}
#end_block

#method_before
private void initProjectOptions() {
    grid.addHeader(new SmallHeading(Util.C.headingProjectOptions()));
    state = new ListBox();
    for (ProjectState stateValue : ProjectState.values()) {
        state.addItem(Util.toLongString(stateValue), stateValue.name());
    }
    saveEnabler.listenTo(state);
    grid.add(Util.C.headingProjectState(), state);
    submitType = new ListBox();
    for (final SubmitType type : SubmitType.values()) {
        submitType.addItem(Util.toLongString(type), type.name());
    }
    submitType.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            setEnabledForUseContentMerge();
        }
    });
    saveEnabler.listenTo(submitType);
    grid.add(Util.C.headingProjectSubmitType(), submitType);
    contentMerge = newInheritedBooleanBox();
    saveEnabler.listenTo(contentMerge);
    grid.add(Util.C.useContentMerge(), contentMerge);
    autoBase = newInheritedBooleanBox();
    saveEnabler.listenTo(autoBase);
    grid.add(Util.C.useAutoBase(), autoBase);
    requireChangeID = newInheritedBooleanBox();
    saveEnabler.listenTo(requireChangeID);
    grid.addHtml(Util.C.requireChangeID(), requireChangeID);
    maxObjectSizeLimit = new NpTextBox();
    saveEnabler.listenTo(maxObjectSizeLimit);
    effectiveMaxObjectSizeLimit = new Label();
    effectiveMaxObjectSizeLimit.setStyleName(Gerrit.RESOURCES.css().maxObjectSizeLimitEffectiveLabel());
    HorizontalPanel p = new HorizontalPanel();
    p.add(maxObjectSizeLimit);
    p.add(effectiveMaxObjectSizeLimit);
    grid.addHtml(Util.C.headingMaxObjectSizeLimit(), p);
}
#method_after
private void initProjectOptions() {
    grid.addHeader(new SmallHeading(Util.C.headingProjectOptions()));
    state = new ListBox();
    for (ProjectState stateValue : ProjectState.values()) {
        state.addItem(Util.toLongString(stateValue), stateValue.name());
    }
    saveEnabler.listenTo(state);
    grid.add(Util.C.headingProjectState(), state);
    submitType = new ListBox();
    for (final SubmitType type : SubmitType.values()) {
        submitType.addItem(Util.toLongString(type), type.name());
    }
    submitType.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            setEnabledForUseContentMerge();
        }
    });
    saveEnabler.listenTo(submitType);
    grid.add(Util.C.headingProjectSubmitType(), submitType);
    contentMerge = newInheritedBooleanBox();
    saveEnabler.listenTo(contentMerge);
    grid.add(Util.C.useContentMerge(), contentMerge);
    newChangeForAllNotInTarget = newInheritedBooleanBox();
    saveEnabler.listenTo(newChangeForAllNotInTarget);
    grid.add(Util.C.createNewChangeForAllNotInTarget(), newChangeForAllNotInTarget);
    requireChangeID = newInheritedBooleanBox();
    saveEnabler.listenTo(requireChangeID);
    grid.addHtml(Util.C.requireChangeID(), requireChangeID);
    maxObjectSizeLimit = new NpTextBox();
    saveEnabler.listenTo(maxObjectSizeLimit);
    effectiveMaxObjectSizeLimit = new Label();
    effectiveMaxObjectSizeLimit.setStyleName(Gerrit.RESOURCES.css().maxObjectSizeLimitEffectiveLabel());
    HorizontalPanel p = new HorizontalPanel();
    p.add(maxObjectSizeLimit);
    p.add(effectiveMaxObjectSizeLimit);
    grid.addHtml(Util.C.headingMaxObjectSizeLimit(), p);
}
#end_block

#method_before
void display(ConfigInfo result) {
    descTxt.setText(result.description());
    setBool(contributorAgreements, result.use_contributor_agreements());
    setBool(signedOffBy, result.use_signed_off_by());
    setBool(contentMerge, result.use_content_merge());
    setBool(autoBase, result.use_auto_base());
    setBool(requireChangeID, result.require_change_id());
    setSubmitType(result.submit_type());
    setState(result.state());
    maxObjectSizeLimit.setText(result.max_object_size_limit().configured_value());
    if (result.max_object_size_limit().inherited_value() != null) {
        effectiveMaxObjectSizeLimit.setVisible(true);
        effectiveMaxObjectSizeLimit.setText(Util.M.effectiveMaxObjectSizeLimit(result.max_object_size_limit().value()));
        effectiveMaxObjectSizeLimit.setTitle(Util.M.globalMaxObjectSizeLimit(result.max_object_size_limit().inherited_value()));
    } else {
        effectiveMaxObjectSizeLimit.setVisible(false);
    }
    saveProject.setEnabled(false);
    initPluginOptions(result);
    initProjectActions(result);
}
#method_after
void display(ConfigInfo result) {
    descTxt.setText(result.description());
    setBool(contributorAgreements, result.use_contributor_agreements());
    setBool(signedOffBy, result.use_signed_off_by());
    setBool(contentMerge, result.use_content_merge());
    setBool(newChangeForAllNotInTarget, result.create_new_change_for_all_not_in_target());
    setBool(requireChangeID, result.require_change_id());
    setSubmitType(result.submit_type());
    setState(result.state());
    maxObjectSizeLimit.setText(result.max_object_size_limit().configured_value());
    if (result.max_object_size_limit().inherited_value() != null) {
        effectiveMaxObjectSizeLimit.setVisible(true);
        effectiveMaxObjectSizeLimit.setText(Util.M.effectiveMaxObjectSizeLimit(result.max_object_size_limit().value()));
        effectiveMaxObjectSizeLimit.setTitle(Util.M.globalMaxObjectSizeLimit(result.max_object_size_limit().inherited_value()));
    } else {
        effectiveMaxObjectSizeLimit.setVisible(false);
    }
    saveProject.setEnabled(false);
    initPluginOptions(result);
    initProjectActions(result);
}
#end_block

#method_before
private void doSave() {
    enableForm(false);
    saveProject.setEnabled(false);
    ProjectApi.setConfig(getProjectKey(), descTxt.getText().trim(), getBool(contributorAgreements), getBool(contentMerge), getBool(signedOffBy), getBool(autoBase), getBool(requireChangeID), maxObjectSizeLimit.getText().trim(), SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())), ProjectState.valueOf(state.getValue(state.getSelectedIndex())), getPluginConfigValues(), new GerritCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo result) {
            enableForm();
            display(result);
        }

        @Override
        public void onFailure(Throwable caught) {
            enableForm();
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    enableForm(false);
    saveProject.setEnabled(false);
    ProjectApi.setConfig(getProjectKey(), descTxt.getText().trim(), getBool(contributorAgreements), getBool(contentMerge), getBool(signedOffBy), getBool(newChangeForAllNotInTarget), getBool(requireChangeID), maxObjectSizeLimit.getText().trim(), SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())), ProjectState.valueOf(state.getValue(state.getSelectedIndex())), getPluginConfigValues(), new GerritCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo result) {
            enableForm();
            display(result);
        }

        @Override
        public void onFailure(Throwable caught) {
            enableForm();
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
public String getSchemeRest() {
    String id = getExternalId();
    int c = id.indexOf(':');
    return 0 < c ? id.substring(c + 1) : null;
}
#method_after
public String getSchemeRest() {
    String scheme = key.getScheme();
    return null != scheme ? getExternalId().substring(scheme.length() + 1) : null;
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws ServletException, IOException {
    final String token = LoginUrlToken.getToken(req);
    if ("/logout".equals(token) || "/signout".equals(token)) {
        req.getRequestDispatcher("/logout").forward(req, rsp);
        return;
    }
    CacheHeaders.setNotCacheable(rsp);
    final String user = authFilter.getRemoteUser(req);
    if (user == null || "".equals(user)) {
        log.error("Unable to authenticate user by " + authFilter.getLoginHeader() + " request header.  Check container or server configuration.");
        final Document doc = // 
        HtmlDomUtil.parseFile(HttpLoginServlet.class, "ConfigurationError.html");
        replace(doc, "loginHeader", authFilter.getLoginHeader());
        replace(doc, "ServerName", req.getServerName());
        replace(doc, "ServerPort", ":" + req.getServerPort());
        replace(doc, "ContextPath", req.getContextPath());
        final byte[] bin = HtmlDomUtil.toUTF8(doc);
        rsp.setStatus(HttpServletResponse.SC_FORBIDDEN);
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding("UTF-8");
        rsp.setContentLength(bin.length);
        final ServletOutputStream out = rsp.getOutputStream();
        try {
            out.write(bin);
        } finally {
            out.flush();
            out.close();
        }
        return;
    }
    final AuthRequest areq = AuthRequest.forUser(user);
    areq.setDisplayName(authFilter.getRemoteDisplayname(req));
    areq.setEmailAddress(authFilter.getRemoteEmail(req));
    final AuthResult arsp;
    try {
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    String remoteExternalId = authFilter.getRemoteExternalIdToken(req);
    if (remoteExternalId != null) {
        try {
            linkRemoteExternalId(arsp, remoteExternalId);
        } catch (AccountException | OrmException e) {
            log.error("Unable to associated external identity \"" + remoteExternalId + "\" to user \"" + user + "\"", e);
            rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
            return;
        }
    }
    final StringBuilder rdr = new StringBuilder();
    if (arsp.isNew() && authConfig.getRegisterPageUrl() != null) {
        rdr.append(authConfig.getRegisterPageUrl());
    } else {
        rdr.append(urlProvider.get(req));
        rdr.append('#');
        if (arsp.isNew() && !token.startsWith(PageLinks.REGISTER + "/")) {
            rdr.append(PageLinks.REGISTER);
        }
        rdr.append(token);
    }
    webSession.get().login(arsp, true);
    rsp.sendRedirect(rdr.toString());
}
#method_after
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws ServletException, IOException {
    final String token = LoginUrlToken.getToken(req);
    CacheHeaders.setNotCacheable(rsp);
    final String user = authFilter.getRemoteUser(req);
    if (user == null || "".equals(user)) {
        log.error("Unable to authenticate user by " + authFilter.getLoginHeader() + " request header.  Check container or server configuration.");
        final Document doc = // 
        HtmlDomUtil.parseFile(HttpLoginServlet.class, "ConfigurationError.html");
        replace(doc, "loginHeader", authFilter.getLoginHeader());
        replace(doc, "ServerName", req.getServerName());
        replace(doc, "ServerPort", ":" + req.getServerPort());
        replace(doc, "ContextPath", req.getContextPath());
        final byte[] bin = HtmlDomUtil.toUTF8(doc);
        rsp.setStatus(HttpServletResponse.SC_FORBIDDEN);
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding("UTF-8");
        rsp.setContentLength(bin.length);
        final ServletOutputStream out = rsp.getOutputStream();
        try {
            out.write(bin);
        } finally {
            out.flush();
            out.close();
        }
        return;
    }
    final AuthRequest areq = AuthRequest.forUser(user);
    areq.setDisplayName(authFilter.getRemoteDisplayname(req));
    areq.setEmailAddress(authFilter.getRemoteEmail(req));
    final AuthResult arsp;
    try {
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    String remoteExternalId = authFilter.getRemoteExternalIdToken(req);
    if (remoteExternalId != null) {
        try {
            log.debug("Associating external identity \"{}\" to user \"{}\"", remoteExternalId, user);
            updateRemoteExternalId(arsp, remoteExternalId);
        } catch (AccountException | OrmException e) {
            log.error("Unable to associate external identity \"" + remoteExternalId + "\" to user \"" + user + "\"", e);
            rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
            return;
        }
    }
    final StringBuilder rdr = new StringBuilder();
    if (arsp.isNew() && authConfig.getRegisterPageUrl() != null) {
        rdr.append(authConfig.getRegisterPageUrl());
    } else {
        rdr.append(urlProvider.get(req));
        if (arsp.isNew() && !token.startsWith(PageLinks.REGISTER + "/")) {
            rdr.append('#' + PageLinks.REGISTER);
        }
        rdr.append(token);
    }
    webSession.get().login(arsp, true);
    rsp.sendRedirect(rdr.toString());
}
#end_block

#method_before
private static AuthType toType(final Config cfg) {
    return ConfigUtil.getEnum(cfg, "auth", null, "type", AuthType.OPENID);
}
#method_after
private static AuthType toType(final Config cfg) {
    return cfg.getEnum("auth", null, "type", AuthType.OPENID);
}
#end_block

#method_before
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            deleteFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile);
            deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.is_edit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#method_after
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            deleteFile.setVisible(!editMode.isVisible());
            renameFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile);
            deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
            renameFileAction = new RenameFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.is_edit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#end_block

#method_before
@UiHandler("editMode")
void onEditMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.EDIT;
    refreshFileTable();
    editMode.setVisible(false);
    addFile.setVisible(true);
    deleteFile.setVisible(true);
    reviewMode.setVisible(true);
}
#method_after
@UiHandler("editMode")
void onEditMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.EDIT;
    refreshFileTable();
    editMode.setVisible(false);
    addFile.setVisible(true);
    deleteFile.setVisible(true);
    renameFile.setVisible(true);
    reviewMode.setVisible(true);
}
#end_block

#method_before
@UiHandler("reviewMode")
void onReviewMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.REVIEW;
    refreshFileTable();
    editMode.setVisible(true);
    addFile.setVisible(false);
    deleteFile.setVisible(false);
    reviewMode.setVisible(false);
}
#method_after
@UiHandler("reviewMode")
void onReviewMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.REVIEW;
    refreshFileTable();
    editMode.setVisible(true);
    addFile.setVisible(false);
    deleteFile.setVisible(false);
    renameFile.setVisible(false);
    reviewMode.setVisible(false);
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.set(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.is_edit()) {
        loadFileList(b, rev, lastReply, group, null, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    DiffApi.list(changeId.get(), base != null ? base.name() : null, rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
            files.setValue(m, myLastReply, comments.get(0), drafts.get(0));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#method_after
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    loadFileList(base, rev, myLastReply, group, comments, drafts);
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    List<Change> submittedChanges = submit(rsrc, caller, false);
    if (input.waitForMerge) {
        for (Change c : submittedChanges) {
            mergeQueue.merge(c.getDest());
        }
        change = dbProvider.get().changes().get(change.getId());
    } else {
        for (Change c : submittedChanges) {
            mergeQueue.schedule(c.getDest());
        }
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    List<Change> submittedChanges = submit(rsrc, caller, false);
    if (input.waitForMerge) {
        for (Change c : submittedChanges) {
            // TODO(sbeller): We should make schedule return a Future, then we
            // could do these all in parallel and still block until they're done.
            mergeQueue.merge(c.getDest());
        }
        change = dbProvider.get().changes().get(change.getId());
    } else {
        for (Change c : submittedChanges) {
            mergeQueue.schedule(c.getDest());
        }
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#end_block

#method_before
private Change submitThisChange(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = submitToDatabase(db, change.getId(), timestamp);
        db.commit();
    } catch (ResourceConflictException e) {
        throw e;
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#method_after
private Change submitThisChange(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = submitToDatabase(db, change.getId(), timestamp);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#end_block

#method_before
private List<Change> submitWholeTopic(RevisionResource rsrc, IdentifiedUser caller, boolean force, String topic) throws ResourceConflictException, OrmException, IOException {
    Preconditions.checkNotNull(topic);
    final Timestamp timestamp = TimeUtil.nowTs();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<ChangeData> changesByTopic = queryProvider.get().byTopicOpen(topic);
    String problems = problemsForSubmittingChanges(changesByTopic, caller);
    if (problems != null) {
        throw new ResourceConflictException(problems);
    }
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        for (ChangeData c : changesByTopic) {
            submitToDatabase(db, c.getId(), timestamp);
        }
        db.commit();
    } catch (ResourceConflictException e) {
        throw e;
    } finally {
        db.rollback();
    }
    List<Change.Id> ids = new ArrayList<>(changesByTopic.size());
    List<Change> ret = new ArrayList<>(changesByTopic.size());
    for (ChangeData c : changesByTopic) {
        ids.add(c.getId());
        ret.add(c.change());
    }
    indexer.indexAsync(ids).checkedGet();
    return ret;
}
#method_after
private List<Change> submitWholeTopic(RevisionResource rsrc, IdentifiedUser caller, boolean force, String topic) throws ResourceConflictException, OrmException, IOException {
    Preconditions.checkNotNull(topic);
    final Timestamp timestamp = TimeUtil.nowTs();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<ChangeData> changesByTopic = queryProvider.get().byTopicOpen(topic);
    String problems = problemsForSubmittingChanges(changesByTopic, caller);
    if (problems != null) {
        throw new ResourceConflictException(problems);
    }
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        for (ChangeData c : changesByTopic) {
            submitToDatabase(db, c.getId(), timestamp);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    List<Change.Id> ids = new ArrayList<>(changesByTopic.size());
    List<Change> ret = new ArrayList<>(changesByTopic.size());
    for (ChangeData c : changesByTopic) {
        ids.add(c.getId());
        ret.add(c.change());
    }
    indexer.indexAsync(ids).checkedGet();
    return ret;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, base);
            loadRevisionInfo();
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            // Revision loading may be slower than the rest, so do it
            // asynchronous to have the rest fast.
            loadConfigInfo(info, base);
            loadRevisionInfo();
        }
    }));
}
#end_block

#method_before
void loadRevisionInfo() {
    RestApi call = ChangeApi.actions(changeId.get(), revision);
    call.background();
    call.get(new AsyncCallback<NativeMap<ActionInfo>>() {

        @Override
        public void onFailure(Throwable caught) {
        }

        @Override
        public void onSuccess(NativeMap<ActionInfo> result) {
            renderRevisionInfo(changeInfo, result);
        }
    });
}
#method_after
void loadRevisionInfo() {
    RestApi call = ChangeApi.actions(changeId.get(), revision);
    call.background();
    call.get(new GerritCallback<NativeMap<ActionInfo>>() {

        @Override
        public void onSuccess(NativeMap<ActionInfo> actionMap) {
            actionMap.copyKeysIntoChildren("id");
            renderRevisionInfo(changeInfo, actionMap);
        }
    });
}
#end_block

#method_before
private void initChangeAction(ChangeInfo info, NativeMap<ActionInfo> actions) {
    if (info.status() == Status.DRAFT) {
        actions.copyKeysIntoChildren("id");
        if (actions.containsKey("/")) {
            deleteChange.setVisible(true);
            deleteChange.setTitle(actions.get("/").title());
        }
    }
}
#method_after
private void initChangeAction(ChangeInfo info) {
    if (info.status() == Status.DRAFT) {
        NativeMap<ActionInfo> actions = info.has_actions() ? info.actions() : NativeMap.<ActionInfo>create();
        actions.copyKeysIntoChildren("id");
        if (actions.containsKey("/")) {
            deleteChange.setVisible(true);
            deleteChange.setTitle(actions.get("/").title());
        }
    }
}
#end_block

#method_before
private void initRevisionsAction(ChangeInfo info, String revision, NativeMap<ActionInfo> actions) {
    int currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    String currentlyViewedPatchSet;
    if (info.revision(revision).id().equals("edit")) {
        currentlyViewedPatchSet = Resources.M.editPatchSet(RevisionInfo.findEditParent(info.revisions().values()));
        currentPatchSet = info.revisions().values().length() - 1;
    } else {
        currentlyViewedPatchSet = info.revision(revision).id();
    }
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
    RevisionInfo revInfo = info.revision(revision);
    if (revInfo.draft()) {
        actions.copyKeysIntoChildren("id");
        if (actions.containsKey("publish")) {
            publish.setVisible(true);
            publish.setTitle(actions.get("publish").title());
        }
        if (actions.containsKey("/")) {
            deleteRevision.setVisible(true);
            deleteRevision.setTitle(actions.get("/").title());
        }
    }
}
#method_after
private void initRevisionsAction(ChangeInfo info, String revision, NativeMap<ActionInfo> actions) {
    int currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    String currentlyViewedPatchSet;
    if (info.revision(revision).id().equals("edit")) {
        currentlyViewedPatchSet = Resources.M.editPatchSet(RevisionInfo.findEditParent(info.revisions().values()));
        currentPatchSet = info.revisions().values().length() - 1;
    } else {
        currentlyViewedPatchSet = info.revision(revision).id();
    }
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
    RevisionInfo revInfo = info.revision(revision);
    if (revInfo.draft()) {
        if (actions.containsKey("publish")) {
            publish.setVisible(true);
            publish.setTitle(actions.get("publish").title());
        }
        if (actions.containsKey("/")) {
            deleteRevision.setVisible(true);
            deleteRevision.setTitle(actions.get("/").title());
        }
    }
}
#end_block

#method_before
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            deleteFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile);
            deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.is_edit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#method_after
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            deleteFile.setVisible(!editMode.isVisible());
            renameFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile);
            deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
            renameFileAction = new RenameFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.is_edit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#end_block

#method_before
@UiHandler("editMode")
void onEditMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.EDIT;
    refreshFileTable();
    editMode.setVisible(false);
    addFile.setVisible(true);
    deleteFile.setVisible(true);
    reviewMode.setVisible(true);
}
#method_after
@UiHandler("editMode")
void onEditMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.EDIT;
    refreshFileTable();
    editMode.setVisible(false);
    addFile.setVisible(true);
    deleteFile.setVisible(true);
    renameFile.setVisible(true);
    reviewMode.setVisible(true);
}
#end_block

#method_before
@UiHandler("reviewMode")
void onReviewMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.REVIEW;
    refreshFileTable();
    editMode.setVisible(true);
    addFile.setVisible(false);
    deleteFile.setVisible(false);
    reviewMode.setVisible(false);
}
#method_after
@UiHandler("reviewMode")
void onReviewMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.REVIEW;
    refreshFileTable();
    editMode.setVisible(true);
    addFile.setVisible(false);
    deleteFile.setVisible(false);
    renameFile.setVisible(false);
    reviewMode.setVisible(false);
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.set(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.is_edit()) {
        loadFileList(b, rev, lastReply, group, null, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    DiffApi.list(changeId.get(), base != null ? base.name() : null, rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
            files.setValue(m, myLastReply, comments.get(0), drafts.get(0));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#method_after
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    loadFileList(base, rev, myLastReply, group, comments, drafts);
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled();
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            if (canSubmit) {
                if (status == Change.Status.NEW) {
                    statusText.setInnerText(changeInfo.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                }
            }
            setVisible(notMergeable, !changeInfo.mergeable());
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#method_after
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            if (canSubmit) {
                if (status == Change.Status.NEW) {
                    statusText.setInnerText(changeInfo.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                }
            }
            setVisible(notMergeable, !changeInfo.mergeable());
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    renderRevisionInfo(info, NativeMap.<ActionInfo>create());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initChangeAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    // Properly render revision actions initially while waiting for
    // the callback to populate them correctly.
    renderRevisionInfo(changeInfo, NativeMap.<ActionInfo>create());
}
#end_block

#method_before
void renderRevisionInfo(ChangeInfo info, NativeMap<ActionInfo> actionMap) {
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    initChangeAction(info, actionMap);
    initRevisionsAction(info, revision, actionMap);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
}
#method_after
private void renderRevisionInfo(ChangeInfo info, NativeMap<ActionInfo> actionMap) {
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    initRevisionsAction(info, revision, actionMap);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    actions.reloadRevisionActions(actionMap);
}
#end_block

#method_before
private void initChangeAction(ChangeInfo info, NativeMap<ActionInfo> actions) {
    if (info.status() == Status.DRAFT) {
        actions.copyKeysIntoChildren("id");
        if (actions.containsKey("/")) {
            deleteChange.setVisible(true);
            deleteChange.setTitle(actions.get("/").title());
        }
    }
}
#method_after
private void initChangeAction(ChangeInfo info) {
    if (info.status() == Status.DRAFT) {
        NativeMap<ActionInfo> actions = info.has_actions() ? info.actions() : NativeMap.<ActionInfo>create();
        actions.copyKeysIntoChildren("id");
        if (actions.containsKey("/")) {
            deleteChange.setVisible(true);
            deleteChange.setTitle(actions.get("/").title());
        }
    }
}
#end_block

#method_before
private void initRevisionsAction(ChangeInfo info, String revision, NativeMap<ActionInfo> actions) {
    int currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    String currentlyViewedPatchSet;
    if (info.revision(revision).id().equals("edit")) {
        currentlyViewedPatchSet = Resources.M.editPatchSet(RevisionInfo.findEditParent(info.revisions().values()));
        currentPatchSet = info.revisions().values().length() - 1;
    } else {
        currentlyViewedPatchSet = info.revision(revision).id();
    }
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
    RevisionInfo revInfo = info.revision(revision);
    if (revInfo.draft()) {
        actions.copyKeysIntoChildren("id");
        if (actions.containsKey("publish")) {
            publish.setVisible(true);
            publish.setTitle(actions.get("publish").title());
        }
        if (actions.containsKey("/")) {
            deleteRevision.setVisible(true);
            deleteRevision.setTitle(actions.get("/").title());
        }
    }
}
#method_after
private void initRevisionsAction(ChangeInfo info, String revision, NativeMap<ActionInfo> actions) {
    int currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    String currentlyViewedPatchSet;
    if (info.revision(revision).id().equals("edit")) {
        currentlyViewedPatchSet = Resources.M.editPatchSet(RevisionInfo.findEditParent(info.revisions().values()));
        currentPatchSet = info.revisions().values().length() - 1;
    } else {
        currentlyViewedPatchSet = info.revision(revision).id();
    }
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
    RevisionInfo revInfo = info.revision(revision);
    if (revInfo.draft()) {
        if (actions.containsKey("publish")) {
            publish.setVisible(true);
            publish.setTitle(actions.get("publish").title());
        }
        if (actions.containsKey("/")) {
            deleteRevision.setVisible(true);
            deleteRevision.setTitle(actions.get("/").title());
        }
    }
}
#end_block

#method_before
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            deleteFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile);
            deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.is_edit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#method_after
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            deleteFile.setVisible(!editMode.isVisible());
            renameFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile);
            deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
            renameFileAction = new RenameFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.is_edit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#end_block

#method_before
@UiHandler("editMode")
void onEditMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.EDIT;
    refreshFileTable();
    editMode.setVisible(false);
    addFile.setVisible(true);
    deleteFile.setVisible(true);
    reviewMode.setVisible(true);
}
#method_after
@UiHandler("editMode")
void onEditMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.EDIT;
    refreshFileTable();
    editMode.setVisible(false);
    addFile.setVisible(true);
    deleteFile.setVisible(true);
    renameFile.setVisible(true);
    reviewMode.setVisible(true);
}
#end_block

#method_before
@UiHandler("reviewMode")
void onReviewMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.REVIEW;
    refreshFileTable();
    editMode.setVisible(true);
    addFile.setVisible(false);
    deleteFile.setVisible(false);
    reviewMode.setVisible(false);
}
#method_after
@UiHandler("reviewMode")
void onReviewMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.REVIEW;
    refreshFileTable();
    editMode.setVisible(true);
    addFile.setVisible(false);
    deleteFile.setVisible(false);
    renameFile.setVisible(false);
    reviewMode.setVisible(false);
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.set(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.is_edit()) {
        loadFileList(b, rev, lastReply, group, null, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    DiffApi.list(changeId.get(), base != null ? base.name() : null, rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
            files.setValue(m, myLastReply, comments.get(0), drafts.get(0));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#method_after
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    loadFileList(base, rev, myLastReply, group, comments, drafts);
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    renderRevisionInfo(info, NativeMap.<ActionInfo>create());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initChangeAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    RevisionInfo revInfo = info.revision(revision);
    NativeMap<ActionInfo> actionMap = revInfo.has_actions() ? info.actions() : NativeMap.<ActionInfo>create();
    actionMap.copyKeysIntoChildren("id");
    renderRevisionInfo(info, actionMap);
}
#end_block

#method_before
void renderRevisionInfo(ChangeInfo info, NativeMap<ActionInfo> actionMap) {
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    initChangeAction(info, actionMap);
    initRevisionsAction(info, revision, actionMap);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
}
#method_after
private void renderRevisionInfo(ChangeInfo info, NativeMap<ActionInfo> actionMap) {
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    initRevisionsAction(info, revision, actionMap);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    change = submit(rsrc, caller, false);
    if (change == null) {
        throw new ResourceConflictException("change is " + status(dbProvider.get().changes().get(rsrc.getChange().getId())));
    }
    if (input.waitForMerge) {
        mergeQueue.merge(change.getDest());
        change = dbProvider.get().changes().get(change.getId());
    } else {
        mergeQueue.schedule(change.getDest());
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    change = submit(rsrc, caller, false);
    if (change == null) {
        throw new ResourceConflictException("change is " + status(dbProvider.get().changes().get(rsrc.getChange().getId())));
    }
    if (input.waitForMerge) {
        mergeQueue.merge(change.getDest());
        change = dbProvider.get().changes().get(change.getId());
    } else {
        mergeQueue.schedule(change.getDest());
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic)) {
        List<ChangeData> changesByTopic = null;
        try {
            changesByTopic = queryProvider.get().byTopicOpen(topic);
        } catch (OrmException e) {
            throw new OrmRuntimeException(e);
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        String topicProblems = areChangesSubmittable(changesByTopic, resource.getUser());
        if (!Strings.isNullOrEmpty(topicProblems)) {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(topicProblems).setVisible(true).setEnabled(false);
        } else {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(true);
        }
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true);
    }
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    if (problemsForSubmittingChanges(Arrays.asList(cd), resource.getUser()) != null) {
        visible = false;
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic)) {
        List<ChangeData> changesByTopic = null;
        try {
            changesByTopic = queryProvider.get().byTopicOpen(topic);
        } catch (OrmException e) {
            throw new OrmRuntimeException(e);
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        String topicProblems = problemsForSubmittingChanges(changesByTopic, resource.getUser());
        if (topicProblems != null) {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(topicProblems).setVisible(true).setEnabled(false);
        } else {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(true);
        }
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true);
    }
}
#end_block

#method_before
private Change submitWholeTopic(RevisionResource rsrc, IdentifiedUser caller, boolean force, String topic) throws ResourceConflictException, OrmException, IOException {
    Preconditions.checkNotNull(topic);
    final Timestamp timestamp = TimeUtil.nowTs();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    List<ChangeData> changesByTopic = queryProvider.get().byTopicOpen(topic);
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        for (ChangeData c : changesByTopic) {
            if (submitToDatabase(db, c.getId(), timestamp) == null) {
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    List<Change.Id> ids = new ArrayList<>(changesByTopic.size());
    for (ChangeData c : changesByTopic) {
        ids.add(c.getId());
    }
    indexer.indexAsync(ids).checkedGet();
    return change;
}
#method_after
private Change submitWholeTopic(RevisionResource rsrc, IdentifiedUser caller, boolean force, String topic) throws ResourceConflictException, OrmException, IOException {
    Preconditions.checkNotNull(topic);
    final Timestamp timestamp = TimeUtil.nowTs();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<ChangeData> changesByTopic = queryProvider.get().byTopicOpen(topic);
    String problems = problemsForSubmittingChanges(changesByTopic, caller);
    if (problems != null) {
        throw new ResourceConflictException(problems);
    }
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        for (ChangeData c : changesByTopic) {
            if (submitToDatabase(db, c.getId(), timestamp) == null) {
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    List<Change.Id> ids = new ArrayList<>(changesByTopic.size());
    for (ChangeData c : changesByTopic) {
        ids.add(c.getId());
    }
    indexer.indexAsync(ids).checkedGet();
    return change;
}
#end_block

#method_before
private List<SubmitRecord> checkSubmitRule(ChangeData cd, PatchSet patchSet, boolean force) throws ResourceConflictException, OrmException {
    List<SubmitRecord> results = new SubmitRuleEvaluator(cd).setPatchSet(patchSet).canSubmit();
    Optional<SubmitRecord> ok = findOkRecord(results);
    if (ok.isPresent()) {
        // Rules supplied a valid solution.
        return ImmutableList.of(ok.get());
    } else if (force) {
        return results;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("ChangeControl.canSubmit returned empty list for %s in %s", patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException(String.format("rule error: %s", record.errorMessage));
            case NOT_READY:
                StringBuilder msg = new StringBuilder();
                for (SubmitRecord.Label lbl : record.labels) {
                    switch(lbl.status) {
                        case OK:
                        case MAY:
                            continue;
                        case REJECT:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("blocked by ").append(lbl.label);
                            continue;
                        case NEED:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("needs ").append(lbl.label);
                            continue;
                        case IMPOSSIBLE:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("needs ").append(lbl.label).append(" (check project access)");
                            continue;
                        default:
                            throw new IllegalStateException(String.format("Unsupported SubmitRecord.Label %s for %s in %s", lbl.toString(), patchSet.getId(), cd.change().getProject().get()));
                    }
                }
                throw new ResourceConflictException(msg.toString());
            default:
                throw new IllegalStateException(String.format("Unsupported SubmitRecord %s for %s in %s", record, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#method_after
private List<SubmitRecord> checkSubmitRule(ChangeData cd, PatchSet patchSet, boolean force) throws ResourceConflictException, OrmException {
    List<SubmitRecord> results = new SubmitRuleEvaluator(cd).setPatchSet(patchSet).canSubmit();
    Optional<SubmitRecord> ok = findOkRecord(results);
    if (ok.isPresent()) {
        // Rules supplied a valid solution.
        return ImmutableList.of(ok.get());
    } else if (force) {
        return results;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("ChangeControl.canSubmit returned empty list for %s in %s", patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException(String.format("rule error: %s", record.errorMessage));
            case NOT_READY:
                StringBuilder msg = new StringBuilder();
                for (SubmitRecord.Label lbl : record.labels) {
                    switch(lbl.status) {
                        case OK:
                        case MAY:
                            continue;
                        case REJECT:
                            if (msg.length() > 0) {
                                msg.append("; ");
                            }
                            msg.append("blocked by ").append(lbl.label);
                            continue;
                        case NEED:
                            if (msg.length() > 0) {
                                msg.append("; ");
                            }
                            msg.append("needs ").append(lbl.label);
                            continue;
                        case IMPOSSIBLE:
                            if (msg.length() > 0) {
                                msg.append("; ");
                            }
                            msg.append("needs ").append(lbl.label).append(" (check project access)");
                            continue;
                        default:
                            throw new IllegalStateException(String.format("Unsupported SubmitRecord.Label %s for %s in %s", lbl.toString(), patchSet.getId(), cd.change().getProject().get()));
                    }
                }
                throw new ResourceConflictException(msg.toString());
            default:
                throw new IllegalStateException(String.format("Unsupported SubmitRecord %s for %s in %s", record, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#end_block

#method_before
private static boolean notModified(HttpServletRequest req, RestResource rsrc, RestView<RestResource> view) {
    if (!isGetOrHead(req)) {
        return false;
    }
    if (view instanceof ETagView) {
        String have = req.getHeader(HttpHeaders.IF_NONE_MATCH);
        if (have != null) {
            return have.equals(((ETagView) view).getETag(rsrc));
        }
    }
    if (rsrc instanceof RestResource.HasETag) {
        String have = req.getHeader(HttpHeaders.IF_NONE_MATCH);
        if (have != null) {
            return have.equals(((RestResource.HasETag) rsrc).getETag());
        }
    }
    if (rsrc instanceof RestResource.HasLastModified) {
        Timestamp m = ((RestResource.HasLastModified) rsrc).getLastModified();
        long d = req.getDateHeader(HttpHeaders.IF_MODIFIED_SINCE);
        // HTTP times are in seconds, database may have millisecond precision.
        return d / 1000L == m.getTime() / 1000L;
    }
    return false;
}
#method_after
@SuppressWarnings({ "unchecked", "rawtypes" })
private static boolean notModified(HttpServletRequest req, RestResource rsrc, RestView<RestResource> view) {
    if (!isGetOrHead(req)) {
        return false;
    }
    if (view instanceof ETagView) {
        String have = req.getHeader(HttpHeaders.IF_NONE_MATCH);
        if (have != null) {
            return have.equals(((ETagView) view).getETag(rsrc));
        }
    }
    if (rsrc instanceof RestResource.HasETag) {
        String have = req.getHeader(HttpHeaders.IF_NONE_MATCH);
        if (have != null) {
            return have.equals(((RestResource.HasETag) rsrc).getETag());
        }
    }
    if (rsrc instanceof RestResource.HasLastModified) {
        Timestamp m = ((RestResource.HasLastModified) rsrc).getLastModified();
        long d = req.getDateHeader(HttpHeaders.IF_MODIFIED_SINCE);
        // HTTP times are in seconds, database may have millisecond precision.
        return d / 1000L == m.getTime() / 1000L;
    }
    return false;
}
#end_block

#method_before
static void replyBinaryResult(@Nullable HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    final BinaryResult appResult = bin;
    try {
        if (bin.getAttachmentName() != null) {
            res.setHeader("Content-Disposition", "attachment; filename=\"" + bin.getAttachmentName() + "\"");
        }
        if (bin.isBase64()) {
            bin = stackBase64(res, bin);
        }
        if (bin.canGzip() && acceptsGzip(req)) {
            bin = stackGzip(res, bin);
        }
        res.setContentType(bin.getContentType());
        long len = bin.getContentLength();
        if (0 <= len && len < Integer.MAX_VALUE) {
            res.setContentLength((int) len);
        } else if (0 <= len) {
            res.setHeader("Content-Length", Long.toString(len));
        }
        if (req == null || !"HEAD".equals(req.getMethod())) {
            OutputStream dst = res.getOutputStream();
            try {
                bin.writeTo(dst);
            } finally {
                dst.close();
            }
        }
    } finally {
        appResult.close();
    }
}
#method_after
@SuppressWarnings("resource")
static void replyBinaryResult(@Nullable HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    final BinaryResult appResult = bin;
    try {
        if (bin.getAttachmentName() != null) {
            res.setHeader("Content-Disposition", "attachment; filename=\"" + bin.getAttachmentName() + "\"");
        }
        if (bin.isBase64()) {
            if (req != null && JSON_TYPE.equals(req.getHeader(HttpHeaders.ACCEPT))) {
                bin = stackJsonString(res, bin);
            } else {
                bin = stackBase64(res, bin);
            }
        }
        if (bin.canGzip() && acceptsGzip(req)) {
            bin = stackGzip(res, bin);
        }
        res.setContentType(bin.getContentType());
        long len = bin.getContentLength();
        if (0 <= len && len < Integer.MAX_VALUE) {
            res.setContentLength((int) len);
        } else if (0 <= len) {
            res.setHeader("Content-Length", Long.toString(len));
        }
        if (req == null || !"HEAD".equals(req.getMethod())) {
            OutputStream dst = res.getOutputStream();
            try {
                bin.writeTo(dst);
            } finally {
                dst.close();
            }
        }
    } finally {
        appResult.close();
    }
}
#end_block

#method_before
@Test
public void multipleUpdatesIncludingComments() throws Exception {
    Change c = newChange();
    ChangeUpdate update1 = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String message1 = "comment 1";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    BatchRefUpdate bru = repo.getRefDatabase().newBatchUpdate();
    BatchMetaDataUpdate batch = update1.openUpdateInBatch(bru);
    PatchLineComment comment1 = newPublishedPatchLineComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update1.setPatchSetId(psId);
    update1.upsertComment(comment1);
    update1.writeCommit(batch);
    ChangeUpdate update2 = newUpdate(c, otherUser);
    update2.putApproval("Code-Review", (short) 2);
    batch.write(update2, new CommitBuilder());
    try {
        batch.commit();
    } finally {
        batch.close();
    }
    RevWalk rw = new RevWalk(repo);
    try {
        bru.execute(rw, NullProgressMonitor.INSTANCE);
    } finally {
        rw.release();
    }
    ChangeNotes notes = newNotes(c);
    List<PatchSetApproval> psas = notes.getApprovals().get(c.currentPatchSetId());
    assertEquals(1, psas.size());
    assertTrue(notes.getBaseComments().size() == 0);
}
#method_after
@Test
public void multipleUpdatesIncludingComments() throws Exception {
    Change c = newChange();
    ChangeUpdate update1 = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String message1 = "comment 1";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    BatchRefUpdate bru = repo.getRefDatabase().newBatchUpdate();
    BatchMetaDataUpdate batch = update1.openUpdateInBatch(bru);
    PatchLineComment comment1 = newPublishedPatchLineComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update1.setPatchSetId(psId);
    update1.upsertComment(comment1);
    update1.writeCommit(batch);
    ChangeUpdate update2 = newUpdate(c, otherUser);
    update2.putApproval("Code-Review", (short) 2);
    update2.writeCommit(batch);
    RevWalk rw = new RevWalk(repo);
    try {
        batch.commit();
        bru.execute(rw, NullProgressMonitor.INSTANCE);
        ChangeNotes notes = newNotes(c);
        ObjectId tip = notes.getRevision();
        RevCommit commitWithApprovals = rw.parseCommit(tip);
        assertNotNull(commitWithApprovals);
        RevCommit commitWithComments = commitWithApprovals.getParent(0);
        assertNotNull(commitWithComments);
        ChangeNotesParser notesWithComments = new ChangeNotesParser(c, commitWithComments.copy(), rw, repoManager);
        notesWithComments.parseAll();
        ImmutableListMultimap<PatchSet.Id, PatchSetApproval> approvals1 = notesWithComments.buildApprovals();
        assertEquals(0, approvals1.size());
        assertEquals(1, notesWithComments.commentsForBase.size());
        notesWithComments.close();
        ChangeNotesParser notesWithApprovals = new ChangeNotesParser(c, commitWithApprovals.copy(), rw, repoManager);
        notesWithApprovals.parseAll();
        ImmutableListMultimap<PatchSet.Id, PatchSetApproval> approvals2 = notesWithApprovals.buildApprovals();
        assertEquals(1, approvals2.size());
        assertEquals(1, notesWithApprovals.commentsForBase.size());
        notesWithApprovals.close();
    } finally {
        batch.close();
        rw.release();
    }
}
#end_block

#method_before
public GroupControl controlFor(final CurrentUser who, final AccountGroup.UUID groupId) throws NoSuchGroupException {
    final GroupDescription.Basic group = groupBackend.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(who, group);
}
#method_after
public GroupControl controlFor(final CurrentUser who, final AccountGroup.UUID groupId) throws NoSuchGroupException {
    final GroupDescription.Basic group = groupBackend.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(who, group, groupBackend);
}
#end_block

#method_before
public GroupControl controlFor(GroupDescription.Basic group) {
    return new GroupControl(user.get(), group);
}
#method_after
public GroupControl controlFor(GroupDescription.Basic group) {
    return new GroupControl(user.get(), group, groupBackend);
}
#end_block

#method_before
public boolean isVisible() {
    AccountGroup accountGroup = GroupDescriptions.toAccountGroup(group);
    /* Check for canAdministrateServer may seem redundant, but allows
     * for visibility of all groups that are not an internal group to
     * server administrators.
     */
    return (accountGroup != null && accountGroup.isVisibleToAll()) || user instanceof InternalUser || user.getEffectiveGroups().contains(group.getGroupUUID()) || isOwner() || group.getName().startsWith("ldap/") ? true : user.getCapabilities().canAdministrateServer();
}
#method_after
public boolean isVisible() {
    /* Check for canAdministrateServer may seem redundant, but allows
     * for visibility of all groups that are not an internal group to
     * server administrators.
     */
    return user instanceof InternalUser || user.memberOf(group.getGroupUUID()) || isOwner() || user.getCapabilities().canAdministrateServer() || groupBackend.isVisibleToAll(group.getGroupUUID());
}
#end_block

#method_before
public boolean isOwner() {
    AccountGroup accountGroup = GroupDescriptions.toAccountGroup(group);
    if (accountGroup == null) {
        isOwner = false;
    } else if (isOwner == null) {
        AccountGroup.UUID ownerUUID = accountGroup.getOwnerGroupUUID();
        isOwner = getCurrentUser().getEffectiveGroups().contains(ownerUUID) || getCurrentUser().getCapabilities().canAdministrateServer();
    }
    return isOwner;
}
#method_after
public boolean isOwner() {
    AccountGroup accountGroup = GroupDescriptions.toAccountGroup(group);
    if (accountGroup == null) {
        isOwner = false;
    } else if (isOwner == null) {
        AccountGroup.UUID ownerUUID = accountGroup.getOwnerGroupUUID();
        isOwner = getCurrentUser().memberOf(ownerUUID) || getCurrentUser().getCapabilities().canAdministrateServer();
    }
    return isOwner;
}
#end_block

#method_before
public PatchSet rebase(final Repository git, final RevWalk revWalk, final ObjectInserter inserter, final PatchSet.Id patchSetId, final Change change, final IdentifiedUser uploader, final RevCommit baseCommit, final MergeUtil mergeUtil, PersonIdent committerIdent, boolean sendMail, boolean runHooks, ValidatePolicy validate) throws NoSuchChangeException, OrmException, IOException, InvalidChangeOperationException, PathConflictException {
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new InvalidChangeOperationException("patch set is not current");
    }
    final PatchSet originalPatchSet = db.patchSets().get(patchSetId);
    final RevCommit rebasedCommit;
    ObjectId oldId = ObjectId.fromString(originalPatchSet.getRevision().get());
    ObjectId newId = rebaseCommit(git, inserter, revWalk.parseCommit(oldId), baseCommit, mergeUtil, committerIdent);
    rebasedCommit = revWalk.parseCommit(newId);
    final ChangeControl changeControl = changeControlFactory.validateFor(change.getId(), uploader);
    PatchSetInserter patchSetInserter = patchSetInserterFactory.create(git, revWalk, changeControl, rebasedCommit).setCopyLabels(true).setValidatePolicy(validate).setDraft(originalPatchSet.isDraft()).setSendMail(sendMail).setRunHooks(runHooks);
    final PatchSet.Id newPatchSetId = patchSetInserter.getPatchSetId();
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), uploader.getAccountId(), TimeUtil.nowTs(), patchSetId);
    cmsg.setMessage("Patch Set " + newPatchSetId.get() + ": Patch Set " + patchSetId.get() + " was rebased");
    Change newChange = patchSetInserter.setMessage(cmsg).insert();
    return db.patchSets().get(newChange.currentPatchSetId());
}
#method_after
public void rebase(Change change, PatchSet.Id patchSetId, final IdentifiedUser uploader) throws NoSuchChangeException, EmailException, OrmException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(change, uploader);
    if (!changeControl.canRebase()) {
        throw new InvalidChangeOperationException("Cannot rebase: New patch sets are not allowed to be added to change: " + changeId.toString());
    }
    Repository git = null;
    RevWalk rw = null;
    ObjectInserter inserter = null;
    try {
        git = gitManager.openRepository(change.getProject());
        rw = new RevWalk(git);
        inserter = git.newObjectInserter();
        final String baseRev = findBaseRevision(patchSetId, db.get(), change.getDest(), git, null, null, null);
        final RevCommit baseCommit = rw.parseCommit(ObjectId.fromString(baseRev));
        PersonIdent committerIdent = uploader.newCommitterIdent(TimeUtil.nowTs(), serverTimeZone);
        rebase(git, rw, inserter, patchSetId, change, uploader, baseCommit, mergeUtilFactory.create(changeControl.getProjectControl().getProjectState(), true), committerIdent, true, ValidatePolicy.GERRIT);
    } catch (MergeConflictException e) {
        throw new IOException(e.getMessage());
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (git != null) {
            git.close();
        }
    }
}
#end_block

#method_before
private static String findBaseRevision(final PatchSet.Id patchSetId, final ReviewDb db, final Branch.NameKey destBranch, final Repository git, List<PatchSetAncestor> patchSetAncestors, List<PatchSet> depPatchSetList, List<Change> depChangeList) throws IOException, OrmException {
    String baseRev = null;
    if (patchSetAncestors == null) {
        patchSetAncestors = db.patchSetAncestors().ancestorsOf(patchSetId).toList();
    }
    if (patchSetAncestors.size() > 1) {
        throw new IOException("Cannot rebase a change with multiple parents. Parents commits: " + patchSetAncestors.toString());
    }
    if (patchSetAncestors.size() == 0) {
        throw new IOException("Cannot rebase a change without any parents (is this the initial commit?).");
    }
    RevId ancestorRev = patchSetAncestors.get(0).getAncestorRevision();
    if (depPatchSetList == null || depPatchSetList.size() != 1 || !depPatchSetList.get(0).getRevision().equals(ancestorRev)) {
        depPatchSetList = db.patchSets().byRevision(ancestorRev).toList();
    }
    for (PatchSet depPatchSet : depPatchSetList) {
        Change.Id depChangeId = depPatchSet.getId().getParentKey();
        Change depChange;
        if (depChangeList == null || depChangeList.size() != 1 || !depChangeList.get(0).getId().equals(depChangeId)) {
            depChange = db.changes().get(depChangeId);
        } else {
            depChange = depChangeList.get(0);
        }
        if (!depChange.getDest().equals(destBranch)) {
            continue;
        }
        if (depChange.getStatus() == Status.ABANDONED) {
            throw new IOException("Cannot rebase a change with an abandoned parent: " + depChange.getKey().toString());
        }
        if (depChange.getStatus().isOpen()) {
            if (depPatchSet.getId().equals(depChange.currentPatchSetId())) {
                throw new IOException("Change is already based on the latest patch set of the dependent change.");
            }
            PatchSet latestDepPatchSet = db.patchSets().get(depChange.currentPatchSetId());
            baseRev = latestDepPatchSet.getRevision().get();
        }
        break;
    }
    if (baseRev == null) {
        // We are dependent on a merged PatchSet or have no PatchSet
        // dependencies at all.
        Ref destRef = git.getRef(destBranch.get());
        if (destRef == null) {
            throw new IOException("The destination branch does not exist: " + destBranch.get());
        }
        baseRev = destRef.getObjectId().getName();
        if (baseRev.equals(ancestorRev.get())) {
            throw new IOException("Change is already up to date.");
        }
    }
    return baseRev;
}
#method_after
private static String findBaseRevision(final PatchSet.Id patchSetId, final ReviewDb db, final Branch.NameKey destBranch, final Repository git, List<PatchSetAncestor> patchSetAncestors, List<PatchSet> depPatchSetList, List<Change> depChangeList) throws IOException, OrmException {
    String baseRev = null;
    if (patchSetAncestors == null) {
        patchSetAncestors = db.patchSetAncestors().ancestorsOf(patchSetId).toList();
    }
    if (patchSetAncestors.size() > 1) {
        throw new IOException("Cannot rebase a change with multiple parents. Parent commits: " + patchSetAncestors.toString());
    }
    if (patchSetAncestors.size() == 0) {
        throw new IOException("Cannot rebase a change without any parents (is this the initial commit?).");
    }
    RevId ancestorRev = patchSetAncestors.get(0).getAncestorRevision();
    if (depPatchSetList == null || depPatchSetList.size() != 1 || !depPatchSetList.get(0).getRevision().equals(ancestorRev)) {
        depPatchSetList = db.patchSets().byRevision(ancestorRev).toList();
    }
    for (PatchSet depPatchSet : depPatchSetList) {
        Change.Id depChangeId = depPatchSet.getId().getParentKey();
        Change depChange;
        if (depChangeList == null || depChangeList.size() != 1 || !depChangeList.get(0).getId().equals(depChangeId)) {
            depChange = db.changes().get(depChangeId);
        } else {
            depChange = depChangeList.get(0);
        }
        if (!depChange.getDest().equals(destBranch)) {
            continue;
        }
        if (depChange.getStatus() == Status.ABANDONED) {
            throw new IOException("Cannot rebase a change with an abandoned parent: " + depChange.getKey().toString());
        }
        if (depChange.getStatus().isOpen()) {
            if (depPatchSet.getId().equals(depChange.currentPatchSetId())) {
                throw new IOException("Change is already based on the latest patch set of the dependent change.");
            }
            PatchSet latestDepPatchSet = db.patchSets().get(depChange.currentPatchSetId());
            baseRev = latestDepPatchSet.getRevision().get();
        }
        break;
    }
    if (baseRev == null) {
        // We are dependent on a merged PatchSet or have no PatchSet
        // dependencies at all.
        Ref destRef = git.getRef(destBranch.get());
        if (destRef == null) {
            throw new IOException("The destination branch does not exist: " + destBranch.get());
        }
        baseRev = destRef.getObjectId().getName();
        if (baseRev.equals(ancestorRev.get())) {
            throw new IOException("Change is already up to date.");
        }
    }
    return baseRev;
}
#end_block

#method_before
private ObjectId rebaseCommit(final Repository git, final ObjectInserter inserter, final RevCommit original, final RevCommit base, final MergeUtil mergeUtil, final PersonIdent committerIdent) throws IOException, PathConflictException {
    final RevCommit parentCommit = original.getParent(0);
    if (base.equals(parentCommit)) {
        throw new IOException("Change is already up to date.");
    }
    final ThreeWayMerger merger = mergeUtil.newThreeWayMerger(git, inserter);
    merger.setBase(parentCommit);
    merger.merge(original, base);
    if (merger.getResultTreeId() == null) {
        throw new PathConflictException("The change could not be rebased due to a path conflict during merge.");
    }
    final CommitBuilder cb = new CommitBuilder();
    cb.setTreeId(merger.getResultTreeId());
    cb.setParentId(base);
    cb.setAuthor(original.getAuthorIdent());
    cb.setMessage(original.getFullMessage());
    cb.setCommitter(committerIdent);
    final ObjectId objectId = inserter.insert(cb);
    inserter.flush();
    return objectId;
}
#method_after
private ObjectId rebaseCommit(Repository git, ObjectInserter inserter, RevCommit original, RevCommit base, MergeUtil mergeUtil, PersonIdent committerIdent) throws MergeConflictException, IOException {
    RevCommit parentCommit = original.getParent(0);
    if (base.equals(parentCommit)) {
        throw new IOException("Change is already up to date.");
    }
    ThreeWayMerger merger = mergeUtil.newThreeWayMerger(git, inserter);
    merger.setBase(parentCommit);
    merger.merge(original, base);
    if (merger.getResultTreeId() == null) {
        throw new MergeConflictException("The change could not be rebased due to a conflict during merge.");
    }
    CommitBuilder cb = new CommitBuilder();
    cb.setTreeId(merger.getResultTreeId());
    cb.setParentId(base);
    cb.setAuthor(original.getAuthorIdent());
    cb.setMessage(original.getFullMessage());
    cb.setCommitter(committerIdent);
    ObjectId objectId = inserter.insert(cb);
    inserter.flush();
    return objectId;
}
#end_block

#method_before
public boolean canRebase(RevisionResource r) {
    Repository git;
    try {
        git = gitManager.openRepository(r.getChange().getProject());
    } catch (RepositoryNotFoundException err) {
        return false;
    } catch (IOException err) {
        return false;
    }
    try {
        findBaseRevision(r.getPatchSet().getId(), db, r.getChange().getDest(), git, null, null, null);
        return true;
    } catch (IOException e) {
        return false;
    } catch (OrmException e) {
        return false;
    } finally {
        git.close();
    }
}
#method_after
public boolean canRebase(RevisionResource r) {
    Repository git;
    try {
        git = gitManager.openRepository(r.getChange().getProject());
    } catch (RepositoryNotFoundException err) {
        return false;
    } catch (IOException err) {
        return false;
    }
    try {
        findBaseRevision(r.getPatchSet().getId(), db.get(), r.getChange().getDest(), git, null, null, null);
        return true;
    } catch (IOException e) {
        return false;
    } catch (OrmException e) {
        return false;
    } finally {
        git.close();
    }
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case DELETE:
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change));
        }
        addMessage("");
    }
    Iterable<ReplaceRequest> updated = Iterables.filter(replaceByChange.values(), new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    });
    if (!Iterables.isEmpty(updated)) {
        addMessage("");
        addMessage("Updated Changes:");
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change));
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private static String formatChangeUrl(String url, Change change) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId());
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    return m.toString();
}
#method_after
private static String formatChangeUrl(String url, Change change) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(change.getSubject()));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    return m.toString();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            } catch (OrmException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "internal server error");
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, OrmException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (CheckedFuture<?, OrmException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (OrmException err) {
        log.error("Can't insert changes for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            } catch (InsertException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, InsertException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (CheckedFuture<?, InsertException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (InsertException err) {
        log.error("Can't insert change/patchset for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
@Option(name = "-r", metaVar = "EMAIL", usage = "add reviewer to changes")
void reviewer(Account.Id id) {
    reviewer.add(id);
}
#method_after
@Option(name = "--reviewer", aliases = { "-r" }, metaVar = "EMAIL", usage = "add reviewer to changes")
void reviewer(Account.Id id) {
    reviewer.add(id);
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    }
    // 
    try {
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(destBranch).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#method_after
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void markHeadsAsUninteresting(final RevWalk walk, Set<ObjectId> existing, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith(REFS_CHANGES)) {
            existing.add(ref.getObjectId());
        } else if (ref.getName().startsWith(R_HEADS) || (forRef != null && forRef.equals(ref.getName()))) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
}
#end_block

#method_before
CheckedFuture<Void, OrmException> insertChange() throws IOException {
    rp.getRevWalk().parseBody(commit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, IOException {
            if (caller == Thread.currentThread()) {
                insertChange(db);
            } else {
                ReviewDb db = schemaFactory.open();
                try {
                    insertChange(db);
                } finally {
                    db.close();
                }
            }
            synchronized (newProgress) {
                newProgress.update(1);
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, ORM_EXCEPTION);
}
#method_after
CheckedFuture<Void, InsertException> insertChange() throws IOException {
    rp.getRevWalk().parseBody(commit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, IOException {
            if (caller == Thread.currentThread()) {
                insertChange(db);
            } else {
                ReviewDb db = schemaFactory.open();
                try {
                    insertChange(db);
                } finally {
                    db.close();
                }
            }
            synchronized (newProgress) {
                newProgress.update(1);
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setMessage(msg).setSendMail(false).insert();
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, ins.getPatchSetInfo());
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        ins.setHashtags(magicBranch.hashtags);
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).insert();
    created = true;
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ps);
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c = submit.submit(rsrc, currentUser);
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c;
    try {
        // Force submit even if submit rule evaluation fails.
        c = submit.submit(rsrc, currentUser, true);
    } catch (ResourceConflictException e) {
        throw new IOException(e);
    }
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            // $FALL-THROUGH$
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#end_block

#method_before
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                    replaceByCommit.remove(req.newCommit);
                }
            }
        }
    } catch (OrmException err) {
        log.error("Cannot read database before replacement", err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        log.error("Cannot read repository before replacement", err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#method_after
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        log.error(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        log.error(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists");
        return false;
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.isDraft()) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.draft) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#end_block

#method_before
CheckedFuture<PatchSet.Id, OrmException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException {
            try {
                if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, ORM_EXCEPTION);
}
#method_after
CheckedFuture<PatchSet.Id, InsertException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException, NoSuchChangeException {
            try {
                if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(change, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.updateAndIndexAsync(change);
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    if (changeKind == ChangeKind.REWORK) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(ReplaceRequest.this);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(ReplaceRequest.this);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    f.checkedGet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private List<Ref> refs(Change.Id changeId) {
    if (refsByChange == null) {
        int estRefsPerChange = 4;
        refsByChange = ArrayListMultimap.create(allRefs.size() / estRefsPerChange, estRefsPerChange);
        for (Ref ref : allRefs.values()) {
            if (ref.getObjectId() != null && PatchSet.isRef(ref.getName())) {
                refsByChange.put(Change.Id.fromRef(ref.getName()), ref);
            }
        }
    }
    return refsByChange.get(changeId);
}
#method_after
private List<Ref> refs(Change.Id changeId) {
    return refsByChange().get(changeId);
}
#end_block

#method_before
private SetMultimap<ObjectId, Ref> changeRefsById() throws IOException {
    if (refsById == null) {
        refsById = HashMultimap.create();
        for (Ref r : repo.getRefDatabase().getRefs(REFS_CHANGES).values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#method_after
private SetMultimap<ObjectId, Ref> changeRefsById() {
    initChangeRefMaps();
    return refsById;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.getEmailAddresses().contains(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    if (validCommits.contains(c)) {
        return true;
    }
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c);
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) {
    if (validCommits.contains(c)) {
        return true;
    }
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c);
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Set<Ref> refs = byCommit.get(c.copy());
            for (Ref ref : refs) {
                if (ref != null) {
                    rw.parseBody(c);
                    Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                    closeProgress.update(1);
                    if (closedChange != null) {
                        byKey.remove(closedChange);
                    }
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // Update superproject gitlinks if required.
        subOpFactory.create(branch, newTip, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>(), currentUser.getAccount()).update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db, commit.getName());
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceRequest result) throws OrmException, IOException {
    Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), TimeUtil.nowTs(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
    indexer.index(db, change);
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result, ChangeControl control) throws OrmException, IOException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    if (areChangesSubmittable(Arrays.asList(cd), resource.getUser(), false) != null) {
        visible = false;
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic)) {
        List<ChangeData> changesByTopic = null;
        try {
            changesByTopic = queryProvider.get().byTopicOpen(topic);
        } catch (OrmException e) {
            throw new OrmRuntimeException(e);
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        String topicProblems = areChangesSubmittable(changesByTopic, resource.getUser(), false);
        if (!Strings.isNullOrEmpty(topicProblems)) {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(topicProblems).setVisible(true).setEnabled(false);
        } else {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(true);
        }
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true);
    }
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic)) {
        List<ChangeData> changesByTopic = null;
        try {
            changesByTopic = queryProvider.get().byTopicOpen(topic);
        } catch (OrmException e) {
            throw new OrmRuntimeException(e);
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        String topicProblems = problemsForSubmittingChanges(changesByTopic, resource.getUser());
        if (topicProblems != null) {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(topicProblems).setVisible(true).setEnabled(false);
        } else {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(true);
        }
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true);
    }
}
#end_block

#method_before
private Change submitThisChange(RevisionResource rsrc, IdentifiedUser caller, boolean force, ReviewDb db, ChangeData cd, Timestamp timestamp) throws ResourceConflictException, OrmException, IOException {
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = submitToDatabase(db, change.getId(), timestamp);
        if (change == null) {
            return null;
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#method_after
private Change submitThisChange(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = submitToDatabase(db, change.getId(), timestamp);
        if (change == null) {
            return null;
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#end_block

#method_before
private Change submitWholeTopic(RevisionResource rsrc, IdentifiedUser caller, boolean force, ReviewDb db, ChangeData cd, Timestamp timestamp, String topic) throws ResourceConflictException, OrmException, IOException {
    Preconditions.checkNotNull(topic);
    List<ChangeData> changesByTopic = queryProvider.get().byTopicOpen(topic);
    String problems = areChangesSubmittable(changesByTopic, caller, force);
    if (problems != null) {
        throw new OrmRuntimeException(problems);
    }
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        for (ChangeData c : changesByTopic) {
            if (submitToDatabase(db, c.getId(), timestamp) == null) {
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    List<Change.Id> ids = new ArrayList<>(changesByTopic.size());
    for (ChangeData c : changesByTopic) {
        ids.add(c.getId());
    }
    indexer.indexAsync(ids).checkedGet();
    return change;
}
#method_after
private Change submitWholeTopic(RevisionResource rsrc, IdentifiedUser caller, boolean force, String topic) throws ResourceConflictException, OrmException, IOException {
    Preconditions.checkNotNull(topic);
    final Timestamp timestamp = TimeUtil.nowTs();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<ChangeData> changesByTopic = queryProvider.get().byTopicOpen(topic);
    String problems = problemsForSubmittingChanges(changesByTopic, caller);
    if (problems != null) {
        throw new ResourceConflictException(problems);
    }
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        for (ChangeData c : changesByTopic) {
            if (submitToDatabase(db, c.getId(), timestamp) == null) {
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    List<Change.Id> ids = new ArrayList<>(changesByTopic.size());
    for (ChangeData c : changesByTopic) {
        ids.add(c.getId());
    }
    indexer.indexAsync(ids).checkedGet();
    return change;
}
#end_block

#method_before
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    String topic = rsrc.getChange().getTopic();
    Timestamp timestamp = TimeUtil.nowTs();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic)) {
        return submitWholeTopic(rsrc, caller, force, db, cd, timestamp, topic);
    } else {
        return submitThisChange(rsrc, caller, force, db, cd, timestamp);
    }
}
#method_after
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    String topic = rsrc.getChange().getTopic();
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic)) {
        return submitWholeTopic(rsrc, caller, force, topic);
    } else {
        return submitThisChange(rsrc, caller, force);
    }
}
#end_block

#method_before
private List<SubmitRecord> checkSubmitRule(ChangeData cd, PatchSet patchSet, boolean force) throws ResourceConflictException, OrmException {
    List<SubmitRecord> results = new SubmitRuleEvaluator(cd).setPatchSet(patchSet).canSubmit();
    Optional<SubmitRecord> ok = findOkRecord(results);
    if (ok.isPresent()) {
        // Rules supplied a valid solution.
        return ImmutableList.of(ok.get());
    } else if (force) {
        return results;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("ChangeControl.canSubmit returned empty list for %s in %s", patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException(String.format("rule error: %s", record.errorMessage));
            case NOT_READY:
                StringBuilder msg = new StringBuilder();
                for (SubmitRecord.Label lbl : record.labels) {
                    switch(lbl.status) {
                        case OK:
                        case MAY:
                            continue;
                        case REJECT:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("blocked by ").append(lbl.label);
                            continue;
                        case NEED:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("needs ").append(lbl.label);
                            continue;
                        case IMPOSSIBLE:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("needs ").append(lbl.label).append(" (check project access)");
                            continue;
                        default:
                            throw new IllegalStateException(String.format("Unsupported SubmitRecord.Label %s for %s in %s", lbl.toString(), patchSet.getId(), cd.change().getProject().get()));
                    }
                }
                throw new ResourceConflictException(msg.toString());
            default:
                throw new IllegalStateException(String.format("Unsupported SubmitRecord %s for %s in %s", record, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#method_after
private List<SubmitRecord> checkSubmitRule(ChangeData cd, PatchSet patchSet, boolean force) throws ResourceConflictException, OrmException {
    List<SubmitRecord> results = new SubmitRuleEvaluator(cd).setPatchSet(patchSet).canSubmit();
    Optional<SubmitRecord> ok = findOkRecord(results);
    if (ok.isPresent()) {
        // Rules supplied a valid solution.
        return ImmutableList.of(ok.get());
    } else if (force) {
        return results;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("ChangeControl.canSubmit returned empty list for %s in %s", patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException(String.format("rule error: %s", record.errorMessage));
            case NOT_READY:
                StringBuilder msg = new StringBuilder();
                for (SubmitRecord.Label lbl : record.labels) {
                    switch(lbl.status) {
                        case OK:
                        case MAY:
                            continue;
                        case REJECT:
                            if (msg.length() > 0) {
                                msg.append("; ");
                            }
                            msg.append("blocked by ").append(lbl.label);
                            continue;
                        case NEED:
                            if (msg.length() > 0) {
                                msg.append("; ");
                            }
                            msg.append("needs ").append(lbl.label);
                            continue;
                        case IMPOSSIBLE:
                            if (msg.length() > 0) {
                                msg.append("; ");
                            }
                            msg.append("needs ").append(lbl.label).append(" (check project access)");
                            continue;
                        default:
                            throw new IllegalStateException(String.format("Unsupported SubmitRecord.Label %s for %s in %s", lbl.toString(), patchSet.getId(), cd.change().getProject().get()));
                    }
                }
                throw new ResourceConflictException(msg.toString());
            default:
                throw new IllegalStateException(String.format("Unsupported SubmitRecord %s for %s in %s", record, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountLoader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteFile.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountLoader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteFile.Factory.class);
        }
    });
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    change = submit(rsrc, caller, false);
    if (change == null) {
        throw new ResourceConflictException("change is " + status(dbProvider.get().changes().get(rsrc.getChange().getId())));
    }
    if (input.waitForMerge) {
        mergeQueue.merge(change.getDest());
        change = dbProvider.get().changes().get(change.getId());
    } else {
        mergeQueue.schedule(change.getDest());
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    change = submit(rsrc, caller, false);
    if (change == null) {
        throw new ResourceConflictException("change is " + status(dbProvider.get().changes().get(rsrc.getChange().getId())));
    }
    if (input.waitForMerge) {
        mergeQueue.merge(change.getDest());
        change = dbProvider.get().changes().get(change.getId());
    } else {
        mergeQueue.schedule(change.getDest());
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic)) {
        List<ChangeData> changesByTopic = null;
        try {
            changesByTopic = queryProvider.get().byTopicOpen(topic);
        } catch (OrmException e) {
            throw new OrmRuntimeException(e);
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        // tooltip. Caution: Check access control for those changes.
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(areChangesSubmittable(changesByTopic, resource.getUser()));
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true);
    }
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic)) {
        List<ChangeData> changesByTopic = null;
        try {
            changesByTopic = queryProvider.get().byTopicOpen(topic);
        } catch (OrmException e) {
            throw new OrmRuntimeException(e);
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        String topicProblems = problemsForSubmittingChanges(changesByTopic, resource.getUser());
        if (topicProblems != null) {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(topicProblems).setVisible(true).setEnabled(false);
        } else {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(true);
        }
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true);
    }
}
#end_block

#method_before
private BatchMetaDataUpdate approve(RevisionResource rsrc, ChangeUpdate update, IdentifiedUser caller, Timestamp timestamp) throws OrmException {
    PatchSet.Id psId = rsrc.getPatchSet().getId();
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = Maps.newHashMap();
    for (PatchSetApproval psa : approvalsUtil.byPatchSet(dbProvider.get(), rsrc.getControl(), psId)) {
        if (!byKey.containsKey(psa.getKey())) {
            byKey.put(psa.getKey(), psa);
        }
    }
    PatchSetApproval submit = ApprovalsUtil.getSubmitter(psId, byKey.values());
    if (submit == null || submit.getAccountId() != caller.getAccountId()) {
        submit = new PatchSetApproval(new PatchSetApproval.Key(rsrc.getPatchSet().getId(), caller.getAccountId(), LabelId.SUBMIT), (short) 1, TimeUtil.nowTs());
        byKey.put(submit.getKey(), submit);
    }
    submit.setValue((short) 1);
    submit.setGranted(timestamp);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = labelNormalizer.normalize(rsrc.getControl(), byKey.values());
    // TODO(dborowitz): Don't use a label in notedb; just check when status
    // change happened.
    update.putApproval(submit.getLabel(), submit.getValue());
    dbProvider.get().patchSetApprovals().upsert(normalized.getNormalized());
    dbProvider.get().patchSetApprovals().delete(normalized.deleted());
    try {
        return saveToBatch(rsrc, update, normalized, timestamp);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
private BatchMetaDataUpdate approve(RevisionResource rsrc, ChangeUpdate update, IdentifiedUser caller, Timestamp timestamp) throws OrmException {
    PatchSet.Id psId = rsrc.getPatchSet().getId();
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = Maps.newHashMap();
    for (PatchSetApproval psa : approvalsUtil.byPatchSet(dbProvider.get(), rsrc.getControl(), psId)) {
        if (!byKey.containsKey(psa.getKey())) {
            byKey.put(psa.getKey(), psa);
        }
    }
    PatchSetApproval submit = ApprovalsUtil.getSubmitter(psId, byKey.values());
    if (submit == null || !submit.getAccountId().equals(caller.getAccountId())) {
        submit = new PatchSetApproval(new PatchSetApproval.Key(rsrc.getPatchSet().getId(), caller.getAccountId(), LabelId.SUBMIT), (short) 1, TimeUtil.nowTs());
        byKey.put(submit.getKey(), submit);
    }
    submit.setValue((short) 1);
    submit.setGranted(timestamp);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = labelNormalizer.normalize(rsrc.getControl(), byKey.values());
    // TODO(dborowitz): Don't use a label in notedb; just check when status
    // change happened.
    update.putApproval(submit.getLabel(), submit.getValue());
    dbProvider.get().patchSetApprovals().upsert(normalized.getNormalized());
    dbProvider.get().patchSetApprovals().delete(normalized.deleted());
    try {
        return saveToBatch(rsrc, update, normalized, timestamp);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
private List<SubmitRecord> checkSubmitRule(ChangeData cd, PatchSet patchSet, boolean force) throws ResourceConflictException, OrmException {
    List<SubmitRecord> results = new SubmitRuleEvaluator(cd).setPatchSet(patchSet).canSubmit();
    Optional<SubmitRecord> ok = findOkRecord(results);
    if (ok.isPresent()) {
        // Rules supplied a valid solution.
        return ImmutableList.of(ok.get());
    } else if (force) {
        return results;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("ChangeControl.canSubmit returned empty list for %s in %s", patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException(String.format("rule error: %s", record.errorMessage));
            case NOT_READY:
                StringBuilder msg = new StringBuilder();
                for (SubmitRecord.Label lbl : record.labels) {
                    switch(lbl.status) {
                        case OK:
                        case MAY:
                            continue;
                        case REJECT:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("blocked by ").append(lbl.label);
                            continue;
                        case NEED:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("needs ").append(lbl.label);
                            continue;
                        case IMPOSSIBLE:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("needs ").append(lbl.label).append(" (check project access)");
                            continue;
                        default:
                            throw new IllegalStateException(String.format("Unsupported SubmitRecord.Label %s for %s in %s", lbl.toString(), patchSet.getId(), cd.change().getProject().get()));
                    }
                }
                throw new ResourceConflictException(msg.toString());
            default:
                throw new IllegalStateException(String.format("Unsupported SubmitRecord %s for %s in %s", record, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#method_after
private List<SubmitRecord> checkSubmitRule(ChangeData cd, PatchSet patchSet, boolean force) throws ResourceConflictException, OrmException {
    List<SubmitRecord> results = new SubmitRuleEvaluator(cd).setPatchSet(patchSet).canSubmit();
    Optional<SubmitRecord> ok = findOkRecord(results);
    if (ok.isPresent()) {
        // Rules supplied a valid solution.
        return ImmutableList.of(ok.get());
    } else if (force) {
        return results;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("ChangeControl.canSubmit returned empty list for %s in %s", patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException(String.format("rule error: %s", record.errorMessage));
            case NOT_READY:
                StringBuilder msg = new StringBuilder();
                for (SubmitRecord.Label lbl : record.labels) {
                    switch(lbl.status) {
                        case OK:
                        case MAY:
                            continue;
                        case REJECT:
                            if (msg.length() > 0) {
                                msg.append("; ");
                            }
                            msg.append("blocked by ").append(lbl.label);
                            continue;
                        case NEED:
                            if (msg.length() > 0) {
                                msg.append("; ");
                            }
                            msg.append("needs ").append(lbl.label);
                            continue;
                        case IMPOSSIBLE:
                            if (msg.length() > 0) {
                                msg.append("; ");
                            }
                            msg.append("needs ").append(lbl.label).append(" (check project access)");
                            continue;
                        default:
                            throw new IllegalStateException(String.format("Unsupported SubmitRecord.Label %s for %s in %s", lbl.toString(), patchSet.getId(), cd.change().getProject().get()));
                    }
                }
                throw new ResourceConflictException(msg.toString());
            default:
                throw new IllegalStateException(String.format("Unsupported SubmitRecord %s for %s in %s", record, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    initPageHeader();
    prev = new Hyperlink(Util.C.pagedListPrev(), true, "");
    prev.setVisible(false);
    next = new Hyperlink(Util.C.pagedListNext(), true, "");
    next.setVisible(false);
    addPanel = new FlowPanel();
    final Grid addGrid = new Grid(2, 2);
    addGrid.setStyleName(Gerrit.RESOURCES.css().addBranch());
    final int texBoxLength = 50;
    nameTxtBox = new HintTextBox();
    nameTxtBox.setVisibleLength(texBoxLength);
    nameTxtBox.setHintText(Util.C.defaultBranchName());
    nameTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(0, 0, Util.C.columnBranchName() + ":");
    addGrid.setWidget(0, 1, nameTxtBox);
    irevTxtBox = new HintTextBox();
    irevTxtBox.setVisibleLength(texBoxLength);
    irevTxtBox.setHintText(Util.C.defaultRevisionSpec());
    irevTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(1, 0, Util.C.initialRevision() + ":");
    addGrid.setWidget(1, 1, irevTxtBox);
    addBranch = new Button(Util.C.buttonAddBranch());
    addBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewBranch();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addBranch);
    branchTable = new BranchesTable();
    delBranch = new Button(Util.C.buttonDeleteBranch());
    delBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            branchTable.deleteChecked();
        }
    });
    HorizontalPanel buttons = new HorizontalPanel();
    buttons.setSpacing(10);
    buttons.add(delBranch);
    buttons.add(prev);
    buttons.add(next);
    add(branchTable);
    add(buttons);
    add(addPanel);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    initPageHeader();
    prev = new Hyperlink(Util.C.pagedListPrev(), true, "");
    prev.setVisible(false);
    next = new Hyperlink(Util.C.pagedListNext(), true, "");
    next.setVisible(false);
    addPanel = new FlowPanel();
    final Grid addGrid = new Grid(2, 2);
    addGrid.setStyleName(Gerrit.RESOURCES.css().addBranch());
    final int texBoxLength = 50;
    nameTxtBox = new HintTextBox();
    nameTxtBox.setVisibleLength(texBoxLength);
    nameTxtBox.setHintText(Util.C.defaultBranchName());
    nameTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(0, 0, Util.C.columnBranchName() + ":");
    addGrid.setWidget(0, 1, nameTxtBox);
    irevTxtBox = new HintTextBox();
    irevTxtBox.setVisibleLength(texBoxLength);
    irevTxtBox.setHintText(Util.C.defaultRevisionSpec());
    irevTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(1, 0, Util.C.initialRevision() + ":");
    addGrid.setWidget(1, 1, irevTxtBox);
    addBranch = new Button(Util.C.buttonAddBranch());
    addBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewBranch();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addBranch);
    branchTable = new BranchesTable();
    delBranch = new Button(Util.C.buttonDeleteBranch());
    delBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            branchTable.deleteChecked();
        }
    });
    HorizontalPanel buttons = new HorizontalPanel();
    buttons.setStyleName(Gerrit.RESOURCES.css().branchTablePrevNextLinks());
    buttons.add(delBranch);
    buttons.add(prev);
    buttons.add(next);
    add(branchTable);
    add(buttons);
    add(addPanel);
}
#end_block

#method_before
private void initPageHeader() {
    parseToken();
    HorizontalPanel hp = new HorizontalPanel();
    hp.setStyleName(Gerrit.RESOURCES.css().projectFilterPanel());
    Label filterLabel = new Label(Util.C.projectFilter());
    filterLabel.setStyleName(Gerrit.RESOURCES.css().projectFilterLabel());
    hp.add(filterLabel);
    filterTxt = new NpTextBox();
    filterTxt.setValue(match);
    filterTxt.addKeyUpHandler(new KeyUpHandler() {

        @Override
        public void onKeyUp(KeyUpEvent event) {
            Query q = new Query(filterTxt.getValue()).open(event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER);
            if (match.equals(q.qMatch)) {
                q.start(start);
            }
            if (q.open || !match.equals(q.qMatch)) {
                if (query == null) {
                    q.run();
                }
                query = q;
            }
        }
    });
    hp.add(filterTxt);
    add(hp);
}
#method_after
private void initPageHeader() {
    parseToken();
    HorizontalPanel hp = new HorizontalPanel();
    hp.setStyleName(Gerrit.RESOURCES.css().projectFilterPanel());
    Label filterLabel = new Label(Util.C.projectFilter());
    filterLabel.setStyleName(Gerrit.RESOURCES.css().projectFilterLabel());
    hp.add(filterLabel);
    filterTxt = new NpTextBox();
    filterTxt.setValue(match);
    filterTxt.addKeyUpHandler(new KeyUpHandler() {

        @Override
        public void onKeyUp(KeyUpEvent event) {
            Query q = new Query(filterTxt.getValue());
            if (match.equals(q.qMatch)) {
                q.start(start);
            } else if (query == null) {
                q.run();
                query = q;
            }
        }
    });
    hp.add(filterTxt);
    add(hp);
}
#end_block

#method_before
private void doAddNewBranch() {
    final String branchName = nameTxtBox.getText().trim();
    if ("".equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    final String rev = irevTxtBox.getText().trim();
    if ("".equals(rev)) {
        irevTxtBox.setText("HEAD");
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    addBranch.setEnabled(false);
    ProjectApi.createBranch(getProjectKey(), branchName, rev, new GerritCallback<BranchInfo>() {

        @Override
        public void onSuccess(BranchInfo branch) {
            showAddedBranch(branch);
            addBranch.setEnabled(true);
            nameTxtBox.setText("");
            irevTxtBox.setText("");
            delBranch.setVisible(branchTable.hasBranchCanDelete());
            if (match == null || match.equals("")) {
                branchTable.insert(branch);
            } else {
                query = new Query(null).open(true).run();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            addBranch.setEnabled(true);
            selectAllAndFocus(nameTxtBox);
            new ErrorDialog(caught.getMessage()).center();
        }
    });
}
#method_after
private void doAddNewBranch() {
    final String branchName = nameTxtBox.getText().trim();
    if ("".equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    final String rev = irevTxtBox.getText().trim();
    if ("".equals(rev)) {
        irevTxtBox.setText("HEAD");
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    addBranch.setEnabled(false);
    ProjectApi.createBranch(getProjectKey(), branchName, rev, new GerritCallback<BranchInfo>() {

        @Override
        public void onSuccess(BranchInfo branch) {
            showAddedBranch(branch);
            nameTxtBox.setText("");
            irevTxtBox.setText("");
            query = new Query(match).start(start).run();
        }

        @Override
        public void onFailure(Throwable caught) {
            addBranch.setEnabled(true);
            selectAllAndFocus(nameTxtBox);
            new ErrorDialog(caught.getMessage()).center();
        }
    });
}
#end_block

#method_before
void showAddedBranch(BranchInfo branch) {
    SafeHtmlBuilder b = new SafeHtmlBuilder();
    b.openElement("b");
    b.append(Gerrit.C.branchCreationConfirmationMessage());
    b.closeElement("b");
    b.openElement("p");
    b.append(branch.ref());
    b.closeElement("p");
    ConfirmationDialog confirmationDialog = new ConfirmationDialog(Gerrit.C.branchCreationDialogTitle(), b.toSafeHtml(), new ConfirmationCallback() {

        @Override
        public void onOk() {
        // do nothing
        }
    });
    confirmationDialog.setCancelVisible(false);
    confirmationDialog.center();
}
#method_after
void showAddedBranch(BranchInfo branch) {
    SafeHtmlBuilder b = new SafeHtmlBuilder();
    b.openElement("b");
    b.append(Gerrit.C.branchCreationConfirmationMessage());
    b.closeElement("b");
    b.openElement("p");
    b.append(branch.ref());
    b.closeElement("p");
    ConfirmationDialog confirmationDialog = new ConfirmationDialog(Gerrit.C.branchCreationDialogTitle(), b.toSafeHtml(), new ConfirmationCallback() {

        @Override
        public void onOk() {
        // do nothing
        }
    });
    confirmationDialog.center();
    confirmationDialog.setCancelVisible(false);
}
#end_block

#method_before
private void deleteBranches(final Set<String> branches) {
    ProjectApi.deleteBranches(getProjectKey(), branches, new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            for (int row = 1; row < table.getRowCount(); ) {
                BranchInfo k = getRowItem(row);
                if (k != null && branches.contains(k.ref())) {
                    table.removeRow(row);
                } else {
                    row++;
                }
            }
            updateDeleteButton();
            delBranch.setVisible(branchTable.hasBranchCanDelete());
        }

        @Override
        public void onFailure(Throwable caught) {
            query = new Query(match).start(start).run();
            super.onFailure(caught);
        }
    });
}
#method_after
private void deleteBranches(final Set<String> branches) {
    ProjectApi.deleteBranches(getProjectKey(), branches, new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            query = new Query(match).start(start).run();
        }

        @Override
        public void onFailure(Throwable caught) {
            query = new Query(match).start(start).run();
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
void populate(int row, BranchInfo k) {
    final GitwebLink c = Gerrit.getGitwebLink();
    if (k.canDelete()) {
        CheckBox sel = new CheckBox();
        sel.addValueChangeHandler(updateDeleteHandler);
        table.setWidget(row, 1, sel);
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setWidget(row, 2, new InlineHTML(com.google.gerrit.client.ui.Util.highlight(k.getShortName(), match)));
    if (k.revision() != null) {
        if ("HEAD".equals(k.getShortName())) {
            setHeadRevision(row, 3, k.revision());
        } else {
            table.setText(row, 3, k.revision());
        }
    } else {
        table.setText(row, 3, "");
    }
    FlowPanel actionsPanel = new FlowPanel();
    if (c != null) {
        actionsPanel.add(new Anchor(c.getLinkName(), false, c.toBranch(new Branch.NameKey(getProjectKey(), k.ref()))));
    }
    if (k.web_links() != null) {
        for (WebLinkInfo webLink : Natives.asList(k.web_links())) {
            actionsPanel.add(webLink.toAnchor());
        }
    }
    if (k.actions() != null) {
        k.actions().copyKeysIntoChildren("id");
        for (ActionInfo a : Natives.asList(k.actions().values())) {
            actionsPanel.add(new ActionButton(getProjectKey(), k, a));
        }
    }
    table.setWidget(row, 4, actionsPanel);
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    String iconCellStyle = Gerrit.RESOURCES.css().iconCell();
    String dataCellStyle = Gerrit.RESOURCES.css().dataCell();
    if (RefNames.REFS_CONFIG.equals(k.getShortName()) || "HEAD".equals(k.getShortName())) {
        iconCellStyle = Gerrit.RESOURCES.css().specialBranchIconCell();
        dataCellStyle = Gerrit.RESOURCES.css().specialBranchDataCell();
        fmt.setStyleName(row, 0, iconCellStyle);
    }
    fmt.addStyleName(row, 1, iconCellStyle);
    fmt.addStyleName(row, 2, dataCellStyle);
    fmt.addStyleName(row, 3, dataCellStyle);
    fmt.addStyleName(row, 4, dataCellStyle);
    setRowItem(row, k);
}
#method_after
void populate(int row, BranchInfo k) {
    final GitwebLink c = Gerrit.getGitwebLink();
    if (k.canDelete()) {
        CheckBox sel = new CheckBox();
        sel.addValueChangeHandler(updateDeleteHandler);
        table.setWidget(row, 1, sel);
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setWidget(row, 2, new InlineHTML(highlight(k.getShortName(), match)));
    if (k.revision() != null) {
        if ("HEAD".equals(k.getShortName())) {
            setHeadRevision(row, 3, k.revision());
        } else {
            table.setText(row, 3, k.revision());
        }
    } else {
        table.setText(row, 3, "");
    }
    FlowPanel actionsPanel = new FlowPanel();
    if (c != null) {
        actionsPanel.add(new Anchor(c.getLinkName(), false, c.toBranch(new Branch.NameKey(getProjectKey(), k.ref()))));
    }
    if (k.web_links() != null) {
        for (WebLinkInfo webLink : Natives.asList(k.web_links())) {
            actionsPanel.add(webLink.toAnchor());
        }
    }
    if (k.actions() != null) {
        k.actions().copyKeysIntoChildren("id");
        for (ActionInfo a : Natives.asList(k.actions().values())) {
            actionsPanel.add(new ActionButton(getProjectKey(), k, a));
        }
    }
    table.setWidget(row, 4, actionsPanel);
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    String iconCellStyle = Gerrit.RESOURCES.css().iconCell();
    String dataCellStyle = Gerrit.RESOURCES.css().dataCell();
    if (RefNames.REFS_CONFIG.equals(k.getShortName()) || "HEAD".equals(k.getShortName())) {
        iconCellStyle = Gerrit.RESOURCES.css().specialBranchIconCell();
        dataCellStyle = Gerrit.RESOURCES.css().specialBranchDataCell();
        fmt.setStyleName(row, 0, iconCellStyle);
    }
    fmt.addStyleName(row, 1, iconCellStyle);
    fmt.addStyleName(row, 2, dataCellStyle);
    fmt.addStyleName(row, 3, dataCellStyle);
    fmt.addStyleName(row, 4, dataCellStyle);
    setRowItem(row, k);
}
#end_block

#method_before
void showList(JsArray<BranchInfo> result) {
    if (open && (result.length() != 0)) {
        Gerrit.display(PageLinks.toProjectBranches(getProjectKey()));
        return;
    }
    setToken(getTokenForScreen(qMatch, qStart));
    ProjectBranchesScreen.this.match = qMatch;
    ProjectBranchesScreen.this.start = qStart;
    if (result.length() <= pageSize) {
        branchTable.display(Natives.asList(result));
        next.setVisible(false);
    } else {
        branchTable.displaySubset(Natives.asList(result), 0, result.length() - 1);
        setupNavigationLink(next, qMatch, qStart + pageSize);
    }
    if (qStart > 0) {
        setupNavigationLink(prev, qMatch, qStart - pageSize);
    } else {
        prev.setVisible(false);
    }
    delBranch.setVisible(branchTable.hasBranchCanDelete());
    Set<String> checkedRefs = branchTable.getCheckedRefs();
    branchTable.setChecked(checkedRefs);
    updateForm();
    if (!isCurrentView()) {
        display();
    }
}
#method_after
void showList(JsArray<BranchInfo> result) {
    setToken(getTokenForScreen(qMatch, qStart));
    ProjectBranchesScreen.this.match = qMatch;
    ProjectBranchesScreen.this.start = qStart;
    if (result.length() <= pageSize) {
        branchTable.display(Natives.asList(result));
        next.setVisible(false);
    } else {
        branchTable.displaySubset(Natives.asList(result), 0, result.length() - 1);
        setupNavigationLink(next, qMatch, qStart + pageSize);
    }
    if (qStart > 0) {
        setupNavigationLink(prev, qMatch, qStart - pageSize);
    } else {
        prev.setVisible(false);
    }
    delBranch.setVisible(branchTable.hasBranchCanDelete());
    Set<String> checkedRefs = branchTable.getCheckedRefs();
    branchTable.setChecked(checkedRefs);
    updateForm();
    if (!isCurrentView()) {
        display();
    }
}
#end_block

#method_before
public static void deleteBranches(Project.NameKey name, Set<String> refs, AsyncCallback<VoidResult> cb) {
    CallbackGroup group = new CallbackGroup();
    for (String ref : refs) {
        project(name).view("branches").id(ref).delete(group.add(cb));
        cb = CallbackGroup.emptyCallback();
    }
    group.done();
}
#method_after
public static void deleteBranches(Project.NameKey name, Set<String> refs, AsyncCallback<VoidResult> cb) {
    if (refs.size() == 1) {
        project(name).view("branches").id(refs.iterator().next()).delete(cb);
    } else {
        DeleteBranchesInput d = DeleteBranchesInput.create();
        for (String ref : refs) {
            d.add_branch(ref);
        }
        project(name).view("branches:delete").post(d, cb);
    }
}
#end_block

#method_before
private List<BranchInfo> filterBranches(List<BranchInfo> branches) throws BadRequestException {
    if (matchSubstring != null) {
        return Lists.newArrayList(Iterables.filter(branches, new Predicate<BranchInfo>() {

            @Override
            public boolean apply(BranchInfo in) {
                return in.sName.toLowerCase(Locale.US).contains(matchSubstring.toLowerCase(Locale.US));
            }
        }));
    } else if (matchRegex != null) {
        if (matchRegex.startsWith("^")) {
            matchRegex = matchRegex.substring(1);
            if (matchRegex.endsWith("$") && !matchRegex.endsWith("\\$")) {
                matchRegex = matchRegex.substring(0, matchRegex.length() - 1);
            }
        }
        if (matchRegex.equals(".*")) {
            return branches;
        }
        try {
            final RunAutomaton a = new RunAutomaton(new RegExp(matchRegex).toAutomaton());
            return Lists.newArrayList(Iterables.filter(branches, new Predicate<BranchInfo>() {

                @Override
                public boolean apply(BranchInfo in) {
                    return a.run(in.sName);
                }
            }));
        } catch (IllegalArgumentException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    return branches;
}
#method_after
private List<BranchInfo> filterBranches(List<BranchInfo> branches) throws BadRequestException {
    if (matchSubstring != null) {
        return Lists.newArrayList(Iterables.filter(branches, new Predicate<BranchInfo>() {

            @Override
            public boolean apply(BranchInfo in) {
                if (!in.ref.startsWith(Constants.R_HEADS)) {
                    return in.ref.toLowerCase(Locale.US).contains(matchSubstring.toLowerCase(Locale.US));
                } else {
                    return in.ref.substring(Constants.R_HEADS.length()).toLowerCase(Locale.US).contains(matchSubstring.toLowerCase(Locale.US));
                }
            }
        }));
    } else if (matchRegex != null) {
        if (matchRegex.startsWith("^")) {
            matchRegex = matchRegex.substring(1);
            if (matchRegex.endsWith("$") && !matchRegex.endsWith("\\$")) {
                matchRegex = matchRegex.substring(0, matchRegex.length() - 1);
            }
        }
        if (matchRegex.equals(".*")) {
            return branches;
        }
        try {
            final RunAutomaton a = new RunAutomaton(new RegExp(matchRegex).toAutomaton());
            return Lists.newArrayList(Iterables.filter(branches, new Predicate<BranchInfo>() {

                @Override
                public boolean apply(BranchInfo in) {
                    if (!in.ref.startsWith(Constants.R_HEADS)) {
                        return a.run(in.ref);
                    } else {
                        return a.run(in.ref.substring(Constants.R_HEADS.length()));
                    }
                }
            }));
        } catch (IllegalArgumentException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    return branches;
}
#end_block

#method_before
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) {
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) {
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes("UTF-8"));
        err.flush();
        onExit(1);
        return;
    }
    stdout = toPrintWriter(out);
    source.addChangeListener(listener, currentUser);
}
#method_after
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes("UTF-8"));
        err.flush();
        onExit(1);
        return;
    }
    stdout = toPrintWriter(out);
    source.addEventListener(listener, currentUser);
}
#end_block

#method_before
@Override
protected void onExit(final int rc) {
    source.removeChangeListener(listener);
    synchronized (taskLock) {
        done = true;
    }
    super.onExit(rc);
}
#method_after
@Override
protected void onExit(final int rc) {
    source.removeEventListener(listener);
    synchronized (taskLock) {
        done = true;
    }
    super.onExit(rc);
}
#end_block

#method_before
@Override
public void destroy() {
    source.removeChangeListener(listener);
    final boolean exit;
    synchronized (taskLock) {
        if (task != null) {
            task.cancel(true);
            // onExit will be invoked by the task cancellation.
            exit = false;
        } else {
            exit = !done;
        }
        done = true;
    }
    if (exit) {
        onExit(0);
    }
}
#method_after
@Override
public void destroy() {
    source.removeEventListener(listener);
    final boolean exit;
    synchronized (taskLock) {
        if (task != null) {
            task.cancel(true);
            // onExit will be invoked by the task cancellation.
            exit = false;
        } else {
            exit = !done;
        }
        done = true;
    }
    if (exit) {
        onExit(0);
    }
}
#end_block

#method_before
private void writeEvents() {
    int processed = 0;
    while (processed < BATCH_SIZE) {
        if (Thread.interrupted() || stdout.checkError()) {
            // The other side either requested a shutdown by calling our
            // destroy() above, or it closed the stream and is no longer
            // accepting output. Either way terminate this instance.
            // 
            source.removeChangeListener(listener);
            flush();
            onExit(0);
            return;
        }
        if (dropped) {
            write(droppedOutputEvent);
            dropped = false;
        }
        final Event event = poll();
        if (event == null) {
            break;
        }
        write(event);
        processed++;
    }
    flush();
    if (BATCH_SIZE <= processed) {
        // 
        synchronized (taskLock) {
            task = pool.submit(writer);
        }
    }
}
#method_after
private void writeEvents() {
    int processed = 0;
    while (processed < BATCH_SIZE) {
        if (Thread.interrupted() || stdout.checkError()) {
            // The other side either requested a shutdown by calling our
            // destroy() above, or it closed the stream and is no longer
            // accepting output. Either way terminate this instance.
            // 
            source.removeEventListener(listener);
            flush();
            onExit(0);
            return;
        }
        if (dropped) {
            write(droppedOutputEvent);
            dropped = false;
        }
        final Event event = poll();
        if (event == null) {
            break;
        }
        write(event);
        processed++;
    }
    flush();
    if (BATCH_SIZE <= processed) {
        // 
        synchronized (taskLock) {
            task = pool.submit(writer);
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    bind(EventSource.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
@Override
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db, String mergeResultRev) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
private void fireEventForUnrestrictedListeners(final Event event) {
    for (ChangeListener listener : unrestrictedListeners) {
        listener.onEvent(event);
    }
}
#method_after
private void fireEventForUnrestrictedListeners(final Event event) {
    for (EventListener listener : unrestrictedListeners) {
        listener.onEvent(event);
    }
}
#end_block

#method_before
private void fireEvent(final Change change, final Event event, final ReviewDb db) throws OrmException {
    for (ChangeListenerHolder holder : listeners.values()) {
        if (isVisibleTo(change, holder.user, db)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#method_after
private void fireEvent(final Change change, final Event event, final ReviewDb db) throws OrmException {
    for (EventListenerHolder holder : listeners.values()) {
        if (isVisibleTo(change, holder.user, db)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#end_block

#method_before
private void fireEvent(Branch.NameKey branchName, final Event event) {
    for (ChangeListenerHolder holder : listeners.values()) {
        if (isVisibleTo(branchName, holder.user)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#method_after
private void fireEvent(Branch.NameKey branchName, final Event event) {
    for (EventListenerHolder holder : listeners.values()) {
        if (isVisibleTo(branchName, holder.user)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#end_block

#method_before
private void columnPath(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().pathColumn()).openAnchor();
    String path = info.path();
    if (mode == Mode.EDIT && !isEditable(info)) {
        sb.setAttribute("onclick", RESTORE + "(event," + info._row() + ")");
    } else {
        sb.setAttribute("href", "#" + url(info)).setAttribute("onclick", OPEN + "(event," + info._row() + ")");
    }
    if (Patch.COMMIT_MSG.equals(path)) {
        sb.append(Util.C.commitMessage());
    } else {
        int commonPrefixLen = commonPrefix(path);
        if (commonPrefixLen > 0) {
            sb.openSpan().setStyleName(R.css().commonPrefix()).append(path.substring(0, commonPrefixLen)).closeSpan();
        }
        sb.append(path.substring(commonPrefixLen));
        lastPath = path;
    }
    sb.closeAnchor();
    if (info.old_path() != null) {
        sb.br();
        sb.openSpan().setStyleName(R.css().renameCopySource()).append(info.old_path()).closeSpan();
    }
    sb.closeTd();
}
#method_after
private void columnPath(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().pathColumn()).openAnchor();
    String path = info.path();
    if (mode == Mode.EDIT && !isEditable(info)) {
        sb.setAttribute("onclick", RESTORE + "(event," + info._row() + ")");
    } else {
        sb.setAttribute("href", "#" + url(info)).setAttribute("onclick", OPEN + "(event," + info._row() + ")");
    }
    if (Patch.COMMIT_MSG.equals(path)) {
        sb.append(Util.C.commitMessage());
    } else if (!hasUser || Gerrit.getUserAccount().getGeneralPreferences().isMuteCommonPathPrefixes()) {
        int commonPrefixLen = commonPrefix(path);
        if (commonPrefixLen > 0) {
            sb.openSpan().setStyleName(R.css().commonPrefix()).append(path.substring(0, commonPrefixLen)).closeSpan();
        }
        sb.append(path.substring(commonPrefixLen));
        lastPath = path;
    } else {
        sb.append(path);
    }
    sb.closeAnchor();
    if (info.old_path() != null) {
        sb.br();
        sb.openSpan().setStyleName(R.css().renameCopySource()).append(info.old_path()).closeSpan();
    }
    sb.closeTd();
}
#end_block

#method_before
private void columnDelta1(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn1());
    if (!Patch.COMMIT_MSG.equals(info.path()) && !info.binary() && !ChangeType.DELETED.matches(info.status())) {
        if (ChangeType.ADDED.matches(info.status())) {
            sb.append(info.lines_inserted()).append(" lines");
        } else {
            sb.append("+").append(info.lines_inserted()).append(", -").append(info.lines_deleted());
        }
    }
    sb.closeTd();
}
#method_after
private void columnDelta1(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn1());
    if (!Patch.COMMIT_MSG.equals(info.path()) && !info.binary()) {
        if (showChangeSizeBars) {
            sb.append(info.lines_inserted() + info.lines_deleted());
        } else if (!ChangeType.DELETED.matches(info.status())) {
            if (ChangeType.ADDED.matches(info.status())) {
                sb.append(info.lines_inserted()).append(" lines");
            } else {
                sb.append("+").append(info.lines_inserted()).append(", -").append(info.lines_deleted());
            }
        }
    }
    sb.closeTd();
}
#end_block

#method_before
private void columnDelta2(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn2());
    if (!Patch.COMMIT_MSG.equals(info.path()) && !info.binary() && (info.lines_inserted() != 0 || info.lines_deleted() != 0)) {
        int w = 80;
        int t = inserted + deleted;
        int i = Math.max(5, (int) (((double) w) * info.lines_inserted() / t));
        int d = Math.max(5, (int) (((double) w) * info.lines_deleted() / t));
        sb.setAttribute("title", Util.M.patchTableSize_LongModify(info.lines_inserted(), info.lines_deleted()));
        if (0 < info.lines_inserted()) {
            sb.openDiv().setStyleName(R.css().inserted()).setAttribute("style", "width:" + i + "px").closeDiv();
        }
        if (0 < info.lines_deleted()) {
            sb.openDiv().setStyleName(R.css().deleted()).setAttribute("style", "width:" + d + "px").closeDiv();
        }
    }
    sb.closeTd();
}
#method_after
private void columnDelta2(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn2());
    if (showChangeSizeBars && !Patch.COMMIT_MSG.equals(info.path()) && !info.binary() && (info.lines_inserted() != 0 || info.lines_deleted() != 0)) {
        int w = 80;
        int t = inserted + deleted;
        int i = Math.max(5, (int) (((double) w) * info.lines_inserted() / t));
        int d = Math.max(5, (int) (((double) w) * info.lines_deleted() / t));
        sb.setAttribute("title", Util.M.patchTableSize_LongModify(info.lines_inserted(), info.lines_deleted()));
        if (0 < info.lines_inserted()) {
            sb.openDiv().setStyleName(R.css().inserted()).setAttribute("style", "width:" + i + "px").closeDiv();
        }
        if (0 < info.lines_deleted()) {
            sb.openDiv().setStyleName(R.css().deleted()).setAttribute("style", "width:" + d + "px").closeDiv();
        }
    }
    sb.closeTd();
}
#end_block

#method_before
private void footer(SafeHtmlBuilder sb) {
    sb.openTr().setStyleName(R.css().nohover());
    sb.openTh().setStyleName(R.css().pointer()).closeTh();
    if (mode == Mode.REVIEW) {
        sb.openTh().setStyleName(R.css().reviewed()).closeTh();
    } else {
        sb.openTh().setStyleName(R.css().removeButton()).closeTh();
    }
    sb.openTh().setStyleName(R.css().status()).closeTh();
    // path
    sb.openTd().closeTd();
    // comments
    sb.openTd().setAttribute("colspan", 3).closeTd();
    // delta1
    sb.openTh().setStyleName(R.css().deltaColumn1()).append(Util.M.patchTableSize_Modify(inserted, deleted)).closeTh();
    // delta2
    sb.openTh().setStyleName(R.css().deltaColumn2());
    int w = 80;
    int t = inserted + deleted;
    int i = Math.max(1, (int) (((double) w) * inserted / t));
    int d = Math.max(1, (int) (((double) w) * deleted / t));
    if (i + d > w && i > d) {
        i = w - d;
    } else if (i + d > w && d > i) {
        d = w - i;
    }
    if (0 < inserted) {
        sb.openDiv().setStyleName(R.css().inserted()).setAttribute("style", "width:" + i + "px").closeDiv();
    }
    if (0 < deleted) {
        sb.openDiv().setStyleName(R.css().deleted()).setAttribute("style", "width:" + d + "px").closeDiv();
    }
    sb.closeTh();
    sb.closeTr();
}
#method_after
private void footer(SafeHtmlBuilder sb) {
    sb.openTr().setStyleName(R.css().nohover());
    sb.openTh().setStyleName(R.css().pointer()).closeTh();
    if (mode == Mode.REVIEW) {
        sb.openTh().setStyleName(R.css().reviewed()).closeTh();
    } else {
        sb.openTh().setStyleName(R.css().removeButton()).closeTh();
    }
    sb.openTh().setStyleName(R.css().status()).closeTh();
    // path
    sb.openTd().closeTd();
    // comments
    sb.openTd().setAttribute("colspan", 3).closeTd();
    // delta1
    sb.openTh().setStyleName(R.css().deltaColumn1()).append(Util.M.patchTableSize_Modify(inserted, deleted)).closeTh();
    // delta2
    sb.openTh().setStyleName(R.css().deltaColumn2());
    if (showChangeSizeBars) {
        int w = 80;
        int t = inserted + deleted;
        int i = Math.max(1, (int) (((double) w) * inserted / t));
        int d = Math.max(1, (int) (((double) w) * deleted / t));
        if (i + d > w && i > d) {
            i = w - d;
        } else if (i + d > w && d > i) {
            d = w - i;
        }
        if (0 < inserted) {
            sb.openDiv().setStyleName(R.css().inserted()).setAttribute("style", "width:" + i + "px").closeDiv();
        }
        if (0 < deleted) {
            sb.openDiv().setStyleName(R.css().deleted()).setAttribute("style", "width:" + d + "px").closeDiv();
        }
    }
    sb.closeTh();
    sb.closeTr();
}
#end_block

#method_before
static void call(final Button b, final String project) {
    b.setEnabled(false);
    ChangeApi.createDraftChange(project, "refs/meta/config", Util.C.editConfigMessage(), null, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            Gerrit.display(Dispatcher.toEditScreen(new PatchSet.Id(result.legacy_id(), 1), "project.config"));
        }

        @Override
        public void onFailure(Throwable caught) {
            b.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
static void call(final Button b, final String project) {
    b.setEnabled(false);
    ChangeApi.createChange(project, RefNames.REFS_CONFIG, Util.C.editConfigMessage(), null, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            Gerrit.display(Dispatcher.toEditScreen(new PatchSet.Id(result.legacy_id(), 1), "project.config"));
        }

        @Override
        public void onFailure(Throwable caught) {
            b.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Test
public void rebaseEdit() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId() - 1);
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    modifier.rebaseEdit(edit, current);
    edit = editUtil.byChange(change).get();
    assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), ObjectId.fromString(edit.getRevision().get()), FILE_NAME), CONTENT_NEW);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), ObjectId.fromString(edit.getRevision().get()), FILE_NAME2), CONTENT_NEW2.getBytes("UTF-8"));
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertThat(beforeRebase.equals(afterRebase)).isFalse();
}
#method_after
@Test
public void rebaseEdit() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId() - 1);
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    modifier.rebaseEdit(edit, current);
    edit = editUtil.byChange(change).get();
    assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), ObjectId.fromString(edit.getRevision().get()), FILE_NAME), CONTENT_NEW);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), ObjectId.fromString(edit.getRevision().get()), FILE_NAME2), CONTENT_NEW2);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertThat(beforeRebase.equals(afterRebase)).isFalse();
}
#end_block

#method_before
@Test
public void rebaseEditRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId() - 1);
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    RestResponse r = adminSession.post(urlRebase());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change).get();
    assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), ObjectId.fromString(edit.getRevision().get()), FILE_NAME), CONTENT_NEW);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), ObjectId.fromString(edit.getRevision().get()), FILE_NAME2), CONTENT_NEW2.getBytes("UTF-8"));
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertThat(afterRebase).isNotEqualTo(beforeRebase);
}
#method_after
@Test
public void rebaseEditRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId() - 1);
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    RestResponse r = adminSession.post(urlRebase());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change).get();
    assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), ObjectId.fromString(edit.getRevision().get()), FILE_NAME), CONTENT_NEW);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), ObjectId.fromString(edit.getRevision().get()), FILE_NAME2), CONTENT_NEW2);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertThat(afterRebase).isNotEqualTo(beforeRebase);
}
#end_block

#method_before
@Test
public void updateMessageRest() throws Exception {
    assertThat(adminSession.get(urlEditMessage()).getStatusCode()).isEqualTo(SC_NOT_FOUND);
    EditMessage.Input in = new EditMessage.Input();
    in.message = String.format("New commit message\n\n" + CONTENT_NEW2 + "\n\nChange-Id: %s", change.getKey());
    assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    RestResponse r = adminSession.getJsonAccept(urlEditMessage());
    assertThat(r.getStatusCode()).isEqualTo(SC_OK);
    assertThat(readContentFromJson(r)).isEqualTo(in.message);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    in.message = String.format("New commit message2\n\nChange-Id: %s", change.getKey());
    assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
}
#method_after
@Test
public void updateMessageRest() throws Exception {
    assertThat(adminSession.get(urlEditMessage()).getStatusCode()).isEqualTo(SC_NOT_FOUND);
    EditMessage.Input in = new EditMessage.Input();
    in.message = String.format("New commit message\n\n" + CONTENT_NEW2_STR + "\n\nChange-Id: %s", change.getKey());
    assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    RestResponse r = adminSession.getJsonAccept(urlEditMessage());
    assertThat(r.getStatusCode()).isEqualTo(SC_OK);
    assertThat(readContentFromJson(r)).isEqualTo(in.message);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    in.message = String.format("New commit message2\n\nChange-Id: %s", change.getKey());
    assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
}
#end_block

#method_before
@Test
public void amendExistingFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW2.getBytes("UTF-8"));
}
#method_after
@Test
public void amendExistingFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW2);
}
#end_block

#method_before
@Test
public void createAndChangeEditInOneRequestRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW);
    in.content = RestSession.newRawInput(CONTENT_NEW2);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW2.getBytes("UTF-8"));
}
#method_after
@Test
public void createAndChangeEditInOneRequestRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW);
    in.content = RestSession.newRawInput(CONTENT_NEW2);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW2);
}
#end_block

#method_before
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    RestResponse r = adminSession.getJsonAccept(urlEditFile());
    assertThat(r.getStatusCode()).isEqualTo(SC_OK);
    assertThat(readContentFromJson(r)).isEqualTo(StringUtils.newStringUtf8(CONTENT_NEW2.getBytes("UTF-8")));
}
#method_after
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    RestResponse r = adminSession.getJsonAccept(urlEditFile());
    assertThat(r.getStatusCode()).isEqualTo(SC_OK);
    assertThat(readContentFromJson(r)).isEqualTo(StringUtils.newStringUtf8(CONTENT_NEW2));
}
#end_block

#method_before
@Test
public void addNewFileAndAmend() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME2), CONTENT_NEW);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME2), CONTENT_NEW2.getBytes("UTF-8"));
}
#method_after
@Test
public void addNewFileAndAmend() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME2), CONTENT_NEW);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME2), CONTENT_NEW2);
}
#end_block

#method_before
@Override
public Rule[] blockPluginRules() {
    return new Rule[] { toc(), note() };
}
#method_after
@Override
public Rule[] blockPluginRules() {
    return new Rule[] { note(), toc() };
}
#end_block

#method_before
public Rule note() {
    StringBuilderVar body = new StringBuilderVar();
    return NodeSequence(string("***"), whitespace(), typeOfNote(), Newline(), oneOrMore(testNot(string("***"), Newline()), Line(body)), string("***"), Newline(), push(new DivNode((DivNode.Style) pop(), parse(body).getChildren())));
}
#method_after
public Rule note() {
    StringBuilderVar body = new StringBuilderVar();
    return NodeSequence(string("***"), Sp(), typeOfNote(), Newline(), oneOrMore(testNot(string("***"), Newline()), Line(body)), string("***"), Newline(), push(new DivNode(popAsString(), parse(body))));
}
#end_block

#method_before
public Rule typeOfNote() {
    return firstOf(sequence(string("note"), push(DivNode.Style.NOTE)), sequence(string("promo"), push(DivNode.Style.PROMO)), sequence(string("aside"), push(DivNode.Style.ASIDE)));
}
#method_after
public Rule typeOfNote() {
    return firstOf(sequence(string("note"), push(match())), sequence(string("promo"), push(match())), sequence(string("aside"), push(match())));
}
#end_block

#method_before
public RootNode parse(StringBuilderVar body) {
    // parsing within a block.
    return parser.parseMarkdown(body.getChars());
}
#method_after
public List<Node> parse(StringBuilderVar body) {
    // parsing within a block.
    if (parser == null) {
        parser = newParser();
    }
    return parser.parseMarkdown(body.getChars()).getChildren();
}
#end_block

#method_before
String getStyleName() {
    return style.name().toLowerCase(Locale.US);
}
#method_after
public String getStyleName() {
    return style;
}
#end_block

#method_before
@Override
public void accept(Visitor visitor) {
    visitor.visit(this);
}
#method_after
@Override
public void accept(org.pegdown.ast.Visitor visitor) {
    ((Visitor) visitor).visit(this);
}
#end_block

#method_before
String getTitle(Node root) {
    if (root instanceof HeaderNode) {
        HeaderNode h = (HeaderNode) root;
        if (h.getLevel() == 1) {
            return TocSerializer.getText(h);
        }
    }
    List<Node> ch = root.getChildren();
    if (ch != null) {
        for (Node n : ch) {
            String title = getTitle(n);
            if (title != null) {
                return title;
            }
        }
    }
    return null;
}
#method_after
static String getTitle(Node node) {
    if (node instanceof HeaderNode) {
        if (((HeaderNode) node).getLevel() == 1) {
            return getInnerText(node);
        }
        return null;
    }
    for (Node child : node.getChildren()) {
        String title = getTitle(child);
        if (title != null) {
            return title;
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    RevWalk rw = new RevWalk(repo);
    try {
        String path = view.getPathPart();
        if (Strings.isNullOrEmpty(path)) {
            path = INDEX_MD;
        } else if (path.endsWith("/")) {
            path += INDEX_MD;
        }
        if (!path.endsWith(".md")) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        RevTree root = getRoot(view, rw);
        if (root == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        String srcmd = readFile(rw, root, path);
        if (srcmd == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        MarkdownHelper fmt = new MarkdownHelper(view);
        RootNode doc = parseFile(view, path, fmt, srcmd);
        if (doc == null) {
            res.setStatus(SC_INTERNAL_SERVER_ERROR);
            return;
        }
        String navmd = readFile(rw, root, "navbar.md");
        RootNode nav = navmd != null ? parseFile(view, "navbar.md", fmt, navmd) : null;
        showDoc(req, res, fmt, nav, doc);
    } finally {
        rw.release();
    }
}
#method_after
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Config cfg = getAccess(req).getConfig();
    if (!cfg.getBoolean("markdown", "render", true)) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    RevWalk rw = new RevWalk(repo);
    try {
        String path = view.getPathPart();
        RevTree root;
        try {
            root = rw.parseTree(view.getRevision().getId());
        } catch (IncorrectObjectTypeException e) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        SourceFile srcmd = findFile(rw, root, path);
        if (srcmd == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        SourceFile navmd = findFile(rw, root, NAVBAR_MD);
        String reqEtag = req.getHeader(HttpHeaders.IF_NONE_MATCH);
        String curEtag = etag(srcmd, navmd);
        if (reqEtag != null && reqEtag.equals(curEtag)) {
            res.setStatus(SC_NOT_MODIFIED);
            return;
        }
        view = view.toBuilder().setPathPart(srcmd.path).build();
        int inputLimit = cfg.getInt("markdown", "inputLimit", 5 << 20);
        RootNode doc = GitilesMarkdown.parseFile(view, srcmd.path, srcmd.read(rw.getObjectReader(), inputLimit));
        if (doc == null) {
            res.setStatus(SC_INTERNAL_SERVER_ERROR);
            return;
        }
        RootNode nav = null;
        if (navmd != null) {
            nav = GitilesMarkdown.parseFile(view, navmd.path, navmd.read(rw.getObjectReader(), inputLimit));
            if (nav == null) {
                res.setStatus(SC_INTERNAL_SERVER_ERROR);
                return;
            }
        }
        res.setHeader(HttpHeaders.ETAG, curEtag);
        showDoc(req, res, view, nav, doc);
    } finally {
        rw.release();
    }
}
#end_block

#method_before
private void showDoc(HttpServletRequest req, HttpServletResponse res, MarkdownHelper fmt, RootNode nav, RootNode doc) throws IOException {
    String title = MoreObjects.firstNonNull(Strings.emptyToNull(fmt.getTitle(doc)), ViewFilter.getView(req).getPathPart());
    Map<String, Object> data = new HashMap<>();
    data.put("breadcrumbs", null);
    data.put("repositoryName", null);
    data.put("title", title);
    data.put("navbarHtml", fmt.renderHTML(nav));
    data.put("bodyHtml", fmt.renderHTML(doc));
    renderHtml(req, res, "gitiles.markdownDoc", data);
}
#method_after
private void showDoc(HttpServletRequest req, HttpServletResponse res, GitilesView view, RootNode nav, RootNode doc) throws IOException {
    Map<String, Object> data = new HashMap<>();
    data.put("pageTitle", MoreObjects.firstNonNull(MarkdownHelper.getTitle(doc), view.getPathPart()));
    data.put("sourceUrl", GitilesView.path().copyFrom(view).toUrl());
    data.put("logUrl", GitilesView.log().copyFrom(view).toUrl());
    data.put("blameUrl", GitilesView.blame().copyFrom(view).toUrl());
    data.put("navbarHtml", new MarkdownToHtml(view).toSoyHtml(nav));
    data.put("bodyHtml", new MarkdownToHtml(view).toSoyHtml(doc));
    String page = renderer.render(SOY_TEMPLATE, data);
    byte[] raw = page.getBytes(UTF_8);
    res.setContentType(FormatType.HTML.getMimeType());
    res.setCharacterEncoding(UTF_8.name());
    setCacheHeaders(res);
    if (acceptsGzipEncoding(req)) {
        res.setHeader(HttpHeaders.CONTENT_ENCODING, "gzip");
        raw = gzip(raw);
    }
    res.setContentLength(raw.length);
    res.setStatus(HttpServletResponse.SC_OK);
    res.getOutputStream().write(raw);
}
#end_block

#method_before
void render(HttpServletResponse res, String templateName, Map<String, ?> soyData) throws IOException {
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    byte[] data = newRenderer(templateName).setData(soyData).render().getBytes(UTF_8);
    res.setContentLength(data.length);
    res.getOutputStream().write(data);
}
#method_after
public String render(String templateName, Map<String, ?> soyData) {
    return newRenderer(templateName).setData(soyData).render();
}
#end_block

#method_before
@Override
public void accept(Visitor visitor) {
    visitor.visit(this);
}
#method_after
@Override
public void accept(org.pegdown.ast.Visitor visitor) {
    ((Visitor) visitor).visit(this);
}
#end_block

#method_before
@Override
public Rule[] blockPluginRules() {
    return new Rule[] { toc(), note(), cols() };
}
#method_after
@Override
public Rule[] blockPluginRules() {
    return new Rule[] { cols(), note(), toc() };
}
#end_block

#method_before
public Rule note() {
    StringBuilderVar body = new StringBuilderVar();
    return NodeSequence(string("***"), whitespace(), typeOfNote(), Newline(), oneOrMore(testNot(string("***"), Newline()), Line(body)), string("***"), Newline(), push(new DivNode((DivNode.Style) pop(), parse(body).getChildren())));
}
#method_after
public Rule note() {
    StringBuilderVar body = new StringBuilderVar();
    return NodeSequence(string("***"), Sp(), typeOfNote(), Newline(), oneOrMore(testNot(string("***"), Newline()), Line(body)), string("***"), Newline(), push(new DivNode(popAsString(), parse(body))));
}
#end_block

#method_before
public Rule typeOfNote() {
    return firstOf(sequence(string("note"), push(DivNode.Style.NOTE)), sequence(string("promo"), push(DivNode.Style.PROMO)), sequence(string("aside"), push(DivNode.Style.ASIDE)));
}
#method_after
public Rule typeOfNote() {
    return firstOf(sequence(string("note"), push(match())), sequence(string("promo"), push(match())), sequence(string("aside"), push(match())));
}
#end_block

#method_before
public Rule cols() {
    StringBuilderVar body = new StringBuilderVar();
    return NodeSequence(colsTag(), Newline(), oneOrMore(testNot(colsTag(), Newline()), Line(body)), colsTag(), Newline(), push(new ColsNode(parse(body).getChildren())));
}
#method_after
public Rule cols() {
    StringBuilderVar body = new StringBuilderVar();
    return NodeSequence(colsTag(), Newline(), oneOrMore(testNot(colsTag(), Newline()), Line(body)), colsTag(), Newline(), push(new ColsNode(parse(body))));
}
#end_block

#method_before
public RootNode parse(StringBuilderVar body) {
    // parsing within a block.
    return parser.parseMarkdown(body.getChars());
}
#method_after
public List<Node> parse(StringBuilderVar body) {
    // parsing within a block.
    if (parser == null) {
        parser = newParser();
    }
    return parser.parseMarkdown(body.getChars()).getChildren();
}
#end_block

#method_before
public static String getInnerText(Node h) {
    List<Node> ch = h.getChildren();
    if (ch == null || ch.isEmpty()) {
        return null;
    }
    StringBuilder b = new StringBuilder();
    for (Node n : ch) {
        if (n instanceof TextNode) {
            b.append(((TextNode) n).getText());
        }
    }
    return Strings.emptyToNull(b.toString().trim());
}
#method_after
public static String getInnerText(Node node) {
    if (node == null || node.getChildren().isEmpty()) {
        return null;
    }
    StringBuilder b = new StringBuilder();
    appendTextFromChildren(b, node);
    return Strings.emptyToNull(b.toString().trim());
}
#end_block

#method_before
@Override
public void accept(Visitor visitor) {
    visitor.visit(this);
}
#method_after
@Override
public void accept(org.pegdown.ast.Visitor visitor) {
    ((Visitor) visitor).visit(this);
}
#end_block

#method_before
@Override
public List<Node> getChildren() {
    return null;
}
#method_after
@Override
public List<Node> getChildren() {
    return Collections.emptyList();
}
#end_block

#method_before
@UiHandler("diffBase")
void onChangeRevision(@SuppressWarnings("unused") ChangeEvent e) {
    int idx = diffBase.getSelectedIndex();
    if (0 <= idx && fileTableMode == FileTable.Mode.REVIEW) {
        String n = diffBase.getValue(idx);
        loadConfigInfo(changeInfo, !n.isEmpty() ? n : null);
    }
}
#method_after
@UiHandler("diffBase")
void onChangeRevision(@SuppressWarnings("unused") ChangeEvent e) {
    int idx = diffBase.getSelectedIndex();
    if (0 <= idx) {
        String n = diffBase.getValue(idx);
        loadConfigInfo(changeInfo, !n.isEmpty() ? n : null);
    }
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> empty = NativeMap.create();
        loadFileList(b, rev, lastReply, group, null, null, empty);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.is_edit()) {
        loadFileList(b, rev, lastReply, group, null, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    loadFileList(base, rev, myLastReply, group, comments, drafts, null);
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#method_after
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    loadFileList(base, rev, myLastReply, group, comments, drafts);
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private void loadFileList(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group, final List<NativeMap<JsArray<CommentInfo>>> comments, final List<NativeMap<JsArray<CommentInfo>>> drafts, final NativeMap<JsArray<CommentInfo>> empty) {
    DiffApi.list(changeId.get(), base != null ? base.name() : null, rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
            files.setValue(m, myLastReply, comments == null ? empty : comments.get(0), drafts == null ? empty : drafts.get(0));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#method_after
private void loadFileList(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group, final List<NativeMap<JsArray<CommentInfo>>> comments, final List<NativeMap<JsArray<CommentInfo>>> drafts) {
    DiffApi.list(changeId.get(), base != null ? base.name() : null, rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
            files.setValue(m, myLastReply, comments != null ? comments.get(0) : null, drafts != null ? drafts.get(0) : null);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#end_block

#method_before
@Test
public void cherryPick() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master%topic=someTopic");
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = "it goes to stable branch";
    gApi.projects().name(project.get()).branch(in.destination).create(new BranchInput());
    ChangeApi orig = gApi.changes().id("p~master~" + r.getChangeId());
    assertThat((Iterable<?>) orig.get().messages).hasSize(1);
    ChangeApi cherry = orig.revision(r.getCommit().name()).cherryPick(in);
    assertThat((Iterable<?>) orig.get().messages).hasSize(2);
    ChangeInfo cherryInfo = cherry.get();
    assertThat((Iterable<?>) cherryInfo.messages).hasSize(1);
    Iterator<ChangeMessageInfo> it = cherryInfo.messages.iterator();
    assertThat(it.next().message).isEqualTo("Cherry picked as patch set 1.");
    assertThat(cherryInfo.subject).contains(in.message);
    assertThat(cherryInfo.topic).isEqualTo("someTopic");
    cherry.current().review(ReviewInput.approve());
    cherry.current().submit();
}
#method_after
@Test
public void cherryPick() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master%topic=someTopic");
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = "it goes to stable branch";
    gApi.projects().name(project.get()).branch(in.destination).create(new BranchInput());
    ChangeApi orig = gApi.changes().id("p~master~" + r.getChangeId());
    assertThat((Iterable<?>) orig.get().messages).hasSize(1);
    ChangeApi cherry = orig.revision(r.getCommit().name()).cherryPick(in);
    assertThat((Iterable<?>) orig.get().messages).hasSize(2);
    String cherryPickedRevision = cherry.get().currentRevision;
    String expectedMessage = String.format("Patch Set 1: Cherry Picked\n\n" + "This patchset was cherry picked to branch %s as commit %s", in.destination, cherryPickedRevision);
    Iterator<ChangeMessageInfo> origIt = orig.get().messages.iterator();
    origIt.next();
    assertThat(origIt.next().message).isEqualTo(expectedMessage);
    assertThat((Iterable<?>) cherry.get().messages).hasSize(1);
    Iterator<ChangeMessageInfo> cherryIt = cherry.get().messages.iterator();
    expectedMessage = "Patch Set 1: Cherry Picked from branch master.";
    assertThat(cherryIt.next().message).isEqualTo(expectedMessage);
    assertThat(cherry.get().subject).contains(in.message);
    assertThat(cherry.get().topic).isEqualTo("someTopic");
    cherry.current().review(ReviewInput.approve());
    cherry.current().submit();
}
#end_block

#method_before
public static void registerClass(Event event) {
    typesByString.put(event.getType(), event.getClass());
}
#method_after
public static void registerClass(Event event) {
    String type = event.getType();
    if (typesByString.containsKey(type)) {
        throw new IllegalArgumentException("Event type already registered: " + type);
    }
    typesByString.put(type, event.getClass());
}
#end_block

#method_before
public static Class getClass(String type) {
    return typesByString.get(type);
}
#method_after
public static Class<?> getClass(String type) {
    return typesByString.get(type);
}
#end_block

#method_before
private List<InlineHyperlink> getLinks() {
    // skip change edits
    if (revision.get() > 0) {
        InlineHyperlink toUnifiedDiffLink = new InlineHyperlink();
        toUnifiedDiffLink.setHTML(new ImageResourceRenderer().render(Gerrit.RESOURCES.unifiedDiff()));
        toUnifiedDiffLink.setTargetHistoryToken(getUnifiedDiffUrl());
        toUnifiedDiffLink.setTitle(PatchUtil.C.unifiedDiff());
        return Collections.singletonList(toUnifiedDiffLink);
    } else {
        return Collections.emptyList();
    }
}
#method_after
private List<InlineHyperlink> getLinks() {
    InlineHyperlink toUnifiedDiffLink = new InlineHyperlink();
    toUnifiedDiffLink.setHTML(new ImageResourceRenderer().render(Gerrit.RESOURCES.unifiedDiff()));
    toUnifiedDiffLink.setTargetHistoryToken(getUnifiedDiffUrl());
    toUnifiedDiffLink.setTitle(PatchUtil.C.unifiedDiff());
    return Collections.singletonList(toUnifiedDiffLink);
}
#end_block

#method_before
@Override
public Map<Class<? extends Annotation>, Iterable<ExtensionMetaData>> scan(final String pluginName, Iterable<Class<? extends Annotation>> annotations) throws InvalidPluginException {
    Set<String> descriptors = Sets.newHashSet();
    final Multimap<String, JarScanner.ClassData> rawMap = ArrayListMultimap.create();
    Map<Class<? extends Annotation>, String> classObjToClassDescr = Maps.newHashMap();
    for (Class<? extends Annotation> annotation : annotations) {
        String descriptor = Type.getType(annotation).getDescriptor();
        descriptors.add(descriptor);
        classObjToClassDescr.put(annotation, descriptor);
    }
    inspectJar(pluginName, descriptors, new JarInspector() {

        @Override
        public void inspect(ClassData def) {
            if (def.isConcrete()) {
                if (!Strings.isNullOrEmpty(def.annotationName)) {
                    rawMap.put(def.annotationName, def);
                }
            } else {
                PluginLoader.log.warn(String.format("Plugin %s tries to @%s(\"%s\") abstract class %s", pluginName, def.annotationName, def.annotationValue, def.className));
            }
        }
    });
    ImmutableMap.Builder<Class<? extends Annotation>, Iterable<ExtensionMetaData>> result = ImmutableMap.builder();
    for (Class<? extends Annotation> annotoation : annotations) {
        String descr = classObjToClassDescr.get(annotoation);
        Collection<ClassData> discoverdData = rawMap.get(descr);
        Collection<ClassData> values = firstNonNull(discoverdData, Collections.<ClassData>emptySet());
        result.put(annotoation, transform(values, CLASS_DATA_TO_EXTENSION_META_DATA));
    }
    return result.build();
}
#method_after
@Override
public Map<Class<? extends Annotation>, Iterable<ExtensionMetaData>> scan(String pluginName, Iterable<Class<? extends Annotation>> annotations) throws InvalidPluginException {
    Set<String> descriptors = Sets.newHashSet();
    Multimap<String, JarScanner.ClassData> rawMap = ArrayListMultimap.create();
    Map<Class<? extends Annotation>, String> classObjToClassDescr = Maps.newHashMap();
    for (Class<? extends Annotation> annotation : annotations) {
        String descriptor = Type.getType(annotation).getDescriptor();
        descriptors.add(descriptor);
        classObjToClassDescr.put(annotation, descriptor);
    }
    Enumeration<JarEntry> e = jarFile.entries();
    while (e.hasMoreElements()) {
        JarEntry entry = e.nextElement();
        if (skip(entry)) {
            continue;
        }
        ClassData def = new ClassData(descriptors);
        try {
            new ClassReader(read(jarFile, entry)).accept(def, SKIP_ALL);
        } catch (IOException err) {
            throw new InvalidPluginException("Cannot auto-register", err);
        } catch (RuntimeException err) {
            PluginLoader.log.warn(String.format("Plugin %s has invaild class file %s inside of %s", pluginName, entry.getName(), jarFile.getName()), err);
            continue;
        }
        if (def.isConcrete()) {
            if (!Strings.isNullOrEmpty(def.annotationName)) {
                rawMap.put(def.annotationName, def);
            }
        } else {
            PluginLoader.log.warn(String.format("Plugin %s tries to @%s(\"%s\") abstract class %s", pluginName, def.annotationName, def.annotationValue, def.className));
        }
    }
    ImmutableMap.Builder<Class<? extends Annotation>, Iterable<ExtensionMetaData>> result = ImmutableMap.builder();
    for (Class<? extends Annotation> annotoation : annotations) {
        String descr = classObjToClassDescr.get(annotoation);
        Collection<ClassData> discoverdData = rawMap.get(descr);
        Collection<ClassData> values = firstNonNull(discoverdData, Collections.<ClassData>emptySet());
        result.put(annotoation, transform(values, CLASS_DATA_TO_EXTENSION_META_DATA));
    }
    return result.build();
}
#end_block

#method_before
public List<String> findImplementationsOf(String pluginName, final Class<?> requestedInterface) throws InvalidPluginException {
    Set<String> descriptors = Collections.emptySet();
    final ImmutableList.Builder<String> result = ImmutableList.builder();
    final String name = requestedInterface.getName().replace('.', '/');
    inspectJar(pluginName, descriptors, new JarInspector() {

        @Override
        public void inspect(ClassData data) {
            if (data.interfaces != null && Iterables.contains(Arrays.asList(data.interfaces), name)) {
                result.add(data.className);
            }
        }
    });
    return result.build();
}
#method_after
public List<String> findImplementationsOf(Class<?> requestedInterface) throws IOException {
    List<String> result = Lists.newArrayList();
    String name = requestedInterface.getName().replace('.', '/');
    Enumeration<JarEntry> e = jarFile.entries();
    while (e.hasMoreElements()) {
        JarEntry entry = e.nextElement();
        if (skip(entry)) {
            continue;
        }
        ClassData def = new ClassData(Collections.<String>emptySet());
        try {
            new ClassReader(read(jarFile, entry)).accept(def, SKIP_ALL);
        } catch (RuntimeException err) {
            PluginLoader.log.warn(String.format("Jar %s has invalid class file %s", jarFile.getName(), entry.getName()), err);
            continue;
        }
        if (def.isConcrete() && def.interfaces != null && Iterables.contains(Arrays.asList(def.interfaces), name)) {
            result.add(def.className);
        }
    }
    return result;
}
#end_block

#method_before
@Override
public Enumeration<PluginEntry> entries() {
    return Collections.enumeration(Lists.transform(Collections.list(jarFile.entries()), new Function<JarEntry, PluginEntry>() {

        public PluginEntry apply(JarEntry jarEntry) {
            try {
                return resourceOf(jarEntry);
            } catch (IOException e) {
                throw new IllegalArgumentException("Cannot convert jar entry " + jarEntry + " to a resource", e);
            }
        }
    }));
}
#method_after
@Override
public Enumeration<PluginEntry> entries() {
    return Collections.enumeration(Lists.transform(Collections.list(jarFile.entries()), new Function<JarEntry, PluginEntry>() {

        @Override
        public PluginEntry apply(JarEntry jarEntry) {
            try {
                return resourceOf(jarEntry);
            } catch (IOException e) {
                throw new IllegalArgumentException("Cannot convert jar entry " + jarEntry + " to a resource", e);
            }
        }
    }));
}
#end_block

#method_before
@Override
public void onResponseReceived(Request req, final Response res) {
    int status = res.getStatusCode();
    if (status == Response.SC_NO_CONTENT) {
        cb.onSuccess(new HttpResponse<T>(res, null, null));
        if (!background) {
            RpcStatus.INSTANCE.onRpcComplete();
        }
    } else if (200 <= status && status < 300) {
        long start = System.currentTimeMillis();
        final T data;
        final String type;
        if (isJsonBody(res)) {
            try {
                // javac generics bug
                data = RestApi.<T>cast(parseJson(res));
                type = JSON_TYPE;
            } catch (JSONException e) {
                if (!background) {
                    RpcStatus.INSTANCE.onRpcComplete();
                }
                cb.onFailure(new StatusCodeException(SC_BAD_RESPONSE, "Invalid JSON: " + e.getMessage()));
                return;
            }
        } else if (isEncodedBase64(res)) {
            data = NativeString.wrap(decodeBase64(res.getText())).cast();
            type = simpleType(res.getHeader("X-FYI-Content-Type"));
        } else if (isTextBody(res)) {
            data = NativeString.wrap(res.getText()).cast();
            type = TEXT_TYPE;
        } else {
            if (!background) {
                RpcStatus.INSTANCE.onRpcComplete();
            }
            cb.onFailure(new StatusCodeException(SC_BAD_RESPONSE, "Expected " + JSON_TYPE + " or " + TEXT_TYPE + "; received Content-Type: " + res.getHeader("Content-Type")));
            return;
        }
        Scheduler.ScheduledCommand cmd = new Scheduler.ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    cb.onSuccess(new HttpResponse<>(res, type, data));
                } finally {
                    if (!background) {
                        RpcStatus.INSTANCE.onRpcComplete();
                    }
                }
            }
        };
        // Defer handling the response if the parse took a while.
        if ((System.currentTimeMillis() - start) > 75) {
            Scheduler.get().scheduleDeferred(cmd);
        } else {
            cmd.execute();
        }
    } else {
        String msg;
        if (isTextBody(res)) {
            msg = res.getText().trim();
        } else if (isJsonBody(res)) {
            JSONValue v;
            try {
                v = parseJson(res);
            } catch (JSONException e) {
                v = null;
            }
            if (v != null && v.isString() != null) {
                msg = v.isString().stringValue();
            } else {
                msg = trimJsonMagic(res.getText()).trim();
            }
        } else {
            msg = res.getStatusText();
        }
        if (!background) {
            RpcStatus.INSTANCE.onRpcComplete();
        }
        cb.onFailure(new StatusCodeException(status, msg));
    }
}
#method_after
@Override
public void onResponseReceived(Request req, final Response res) {
    int status = res.getStatusCode();
    if (status == Response.SC_NO_CONTENT) {
        cb.onSuccess(new HttpResponse<T>(res, null, null));
        if (!background) {
            RpcStatus.INSTANCE.onRpcComplete();
        }
    } else if (200 <= status && status < 300) {
        long start = System.currentTimeMillis();
        final T data;
        final String type;
        if (isJsonBody(res)) {
            try {
                JSONValue val = parseJson(res);
                if (isJsonEncoded(res) && val.isString() != null) {
                    data = NativeString.wrap(val.isString().stringValue()).cast();
                    type = simpleType(res.getHeader("X-FYI-Content-Type"));
                } else {
                    data = RestApi.<T>cast(val);
                    type = JSON_TYPE;
                }
            } catch (JSONException e) {
                if (!background) {
                    RpcStatus.INSTANCE.onRpcComplete();
                }
                cb.onFailure(new StatusCodeException(SC_BAD_RESPONSE, "Invalid JSON: " + e.getMessage()));
                return;
            }
        } else if (isTextBody(res)) {
            data = NativeString.wrap(res.getText()).cast();
            type = TEXT_TYPE;
        } else {
            if (!background) {
                RpcStatus.INSTANCE.onRpcComplete();
            }
            cb.onFailure(new StatusCodeException(SC_BAD_RESPONSE, "Expected " + JSON_TYPE + " or " + TEXT_TYPE + "; received Content-Type: " + res.getHeader("Content-Type")));
            return;
        }
        Scheduler.ScheduledCommand cmd = new Scheduler.ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    cb.onSuccess(new HttpResponse<>(res, type, data));
                } finally {
                    if (!background) {
                        RpcStatus.INSTANCE.onRpcComplete();
                    }
                }
            }
        };
        // Defer handling the response if the parse took a while.
        if ((System.currentTimeMillis() - start) > 75) {
            Scheduler.get().scheduleDeferred(cmd);
        } else {
            cmd.execute();
        }
    } else {
        String msg;
        if (isTextBody(res)) {
            msg = res.getText().trim();
        } else if (isJsonBody(res)) {
            JSONValue v;
            try {
                v = parseJson(res);
            } catch (JSONException e) {
                v = null;
            }
            if (v != null && v.isString() != null) {
                msg = v.isString().stringValue();
            } else {
                msg = trimJsonMagic(res.getText()).trim();
            }
        } else {
            msg = res.getStatusText();
        }
        if (!background) {
            RpcStatus.INSTANCE.onRpcComplete();
        }
        cb.onFailure(new StatusCodeException(status, msg));
    }
}
#end_block

#method_before
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#method_after
public RestApi addParameter(String name, String value) {
    return addParameterRaw(name, URL.encodeQueryString(value));
}
#end_block

#method_before
public RestApi addParameter(String name, Enum<?> value) {
    return addParameterRaw(name, value.name());
}
#method_after
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#end_block

#method_before
public <T extends JavaScriptObject> void post(String content, HttpCallback<T> cb) {
    sendRaw(POST, content, cb);
}
#method_after
public <T extends JavaScriptObject> void post(String content, HttpCallback<T> cb) {
    sendText(POST, content, cb);
}
#end_block

#method_before
public <T extends JavaScriptObject> void put(String content, HttpCallback<T> cb) {
    sendRaw(PUT, content, cb);
}
#method_after
public <T extends JavaScriptObject> void put(String content, HttpCallback<T> cb) {
    sendText(PUT, content, cb);
}
#end_block

#method_before
private static BinaryResult stackBase64(HttpServletResponse res, final BinaryResult src) throws IOException {
    BinaryResult b64;
    long len = src.getContentLength();
    if (0 <= len && len <= (7 << 20)) {
        b64 = base64(src);
    } else {
        b64 = new BinaryResult() {

            @Override
            public void writeTo(final OutputStream out) throws IOException {
                try (OutputStreamWriter w = new OutputStreamWriter(new OutputStream() {

                    @Override
                    public void write(int b) throws IOException {
                        out.write(b);
                    }

                    @Override
                    public void close() {
                    // do not close `out`, but only `w` and `e`
                    }
                }, ISO_8859_1);
                    OutputStream e = BaseEncoding.base64().encodingStream(w)) {
                    src.writeTo(e);
                    e.flush();
                }
            }
        };
    }
    res.setHeader("X-FYI-Content-Encoding", "base64");
    res.setHeader("X-FYI-Content-Type", src.getContentType());
    return b64.setContentType("text/plain").setCharacterEncoding("ISO-8859-1");
}
#method_after
private static BinaryResult stackBase64(HttpServletResponse res, final BinaryResult src) throws IOException {
    BinaryResult b64;
    long len = src.getContentLength();
    if (0 <= len && len <= (7 << 20)) {
        b64 = base64(src);
    } else {
        b64 = new BinaryResult() {

            @Override
            public void writeTo(OutputStream out) throws IOException {
                try (OutputStreamWriter w = new OutputStreamWriter(new FilterOutputStream(out) {

                    @Override
                    public void close() {
                    // Do not close out, but only w and e.
                    }
                }, ISO_8859_1);
                    OutputStream e = BaseEncoding.base64().encodingStream(w)) {
                    src.writeTo(e);
                }
            }
        };
    }
    res.setHeader("X-FYI-Content-Encoding", "base64");
    res.setHeader("X-FYI-Content-Type", src.getContentType());
    return b64.setContentType("text/plain").setCharacterEncoding("ISO-8859-1");
}
#end_block

#method_before
private void columnPath(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().pathColumn()).openAnchor();
    String path = info.path();
    if (mode == Mode.EDIT && !isEditable(info)) {
        sb.setAttribute("onclick", RESTORE + "(event," + info._row() + ")");
    } else {
        sb.setAttribute("href", "#" + url(info)).setAttribute("onclick", OPEN + "(event," + info._row() + ")");
    }
    if (Patch.COMMIT_MSG.equals(path)) {
        sb.append(Util.C.commitMessage());
    } else if (Gerrit.getConfig().getMuteCommonPathsInFileTable()) {
        int commonPrefixLen = commonPrefix(path);
        if (commonPrefixLen > 0) {
            sb.openSpan().setStyleName(R.css().commonPrefix()).append(path.substring(0, commonPrefixLen)).closeSpan();
        }
        sb.append(path.substring(commonPrefixLen));
        lastPath = path;
    } else {
        sb.append(path);
    }
    sb.closeAnchor();
    if (info.old_path() != null) {
        sb.br();
        sb.openSpan().setStyleName(R.css().renameCopySource()).append(info.old_path()).closeSpan();
    }
    sb.closeTd();
}
#method_after
private void columnPath(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().pathColumn()).openAnchor();
    String path = info.path();
    if (mode == Mode.EDIT && !isEditable(info)) {
        sb.setAttribute("onclick", RESTORE + "(event," + info._row() + ")");
    } else {
        sb.setAttribute("href", "#" + url(info)).setAttribute("onclick", OPEN + "(event," + info._row() + ")");
    }
    if (Patch.COMMIT_MSG.equals(path)) {
        sb.append(Util.C.commitMessage());
    } else if (!hasUser || Gerrit.getUserAccount().getGeneralPreferences().isMuteCommonPathPrefixes()) {
        int commonPrefixLen = commonPrefix(path);
        if (commonPrefixLen > 0) {
            sb.openSpan().setStyleName(R.css().commonPrefix()).append(path.substring(0, commonPrefixLen)).closeSpan();
        }
        sb.append(path.substring(commonPrefixLen));
        lastPath = path;
    } else {
        sb.append(path);
    }
    sb.closeAnchor();
    if (info.old_path() != null) {
        sb.br();
        sb.openSpan().setStyleName(R.css().renameCopySource()).append(info.old_path()).closeSpan();
    }
    sb.closeTd();
}
#end_block

#method_before
private void columnDelta1(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn1());
    if (!Patch.COMMIT_MSG.equals(info.path()) && !info.binary() && !ChangeType.DELETED.matches(info.status())) {
        if (ChangeType.ADDED.matches(info.status())) {
            sb.append(info.lines_inserted()).append(" lines");
        } else {
            sb.append("+").append(info.lines_inserted()).append(", -").append(info.lines_deleted());
        }
    }
    sb.closeTd();
}
#method_after
private void columnDelta1(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn1());
    if (!Patch.COMMIT_MSG.equals(info.path()) && !info.binary()) {
        sb.append(info.lines_inserted() + info.lines_deleted());
    }
    sb.closeTd();
}
#end_block

#method_before
private Injector newRootInjector(final PluginGuiceEnvironment env) {
    List<Module> modules = Lists.newArrayListWithCapacity(4);
    if (getApiType() == ApiType.PLUGIN) {
        modules.add(env.getSysModule());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(PluginUser.class).toInstance(getPluginUser());
            bind(String.class).annotatedWith(PluginName.class).toInstance(getName());
            bind(String.class).annotatedWith(PluginCanonicalWebUrl.class).toInstance(pluginCanonicalWebUrl);
            bind(File.class).annotatedWith(PluginData.class).toProvider(new Provider<File>() {

                private volatile boolean ready;

                @Override
                public File get() {
                    synchronized (dataDir) {
                        if (!ready) {
                            if (!dataDir.exists() && !dataDir.mkdirs()) {
                                throw new ProvisionException(String.format("Cannot create %s for plugin %s", dataDir.getAbsolutePath(), getName()));
                            }
                            ready = true;
                        }
                    }
                    return dataDir;
                }
            });
        }
    });
    return Guice.createInjector(modules);
}
#method_after
private Injector newRootInjector(final PluginGuiceEnvironment env) {
    List<Module> modules = Lists.newArrayListWithCapacity(4);
    if (getApiType() == ApiType.PLUGIN) {
        modules.add(env.getSysModule());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(PluginUser.class).toInstance(getPluginUser());
            bind(String.class).annotatedWith(PluginName.class).toInstance(getName());
            bind(String.class).annotatedWith(PluginCanonicalWebUrl.class).toInstance(pluginCanonicalWebUrl);
            bind(File.class).annotatedWith(PluginData.class).toProvider(new Provider<File>() {

                private volatile boolean ready;

                @Override
                public File get() {
                    if (!ready) {
                        synchronized (dataDir) {
                            if (!ready) {
                                if (!dataDir.exists() && !dataDir.mkdirs()) {
                                    throw new ProvisionException(String.format("Cannot create %s for plugin %s", dataDir.getAbsolutePath(), getName()));
                                }
                                ready = true;
                            }
                        }
                    }
                    return dataDir;
                }
            });
        }
    });
    return Guice.createInjector(modules);
}
#end_block

#method_before
@Override
public void foreach(Processor processor) throws FileNotFoundException, IOException {
    File myWar = GerritLauncher.getDistributionArchive();
    if (myWar.isFile()) {
        try (ZipFile zf = new ZipFile(myWar)) {
            Enumeration<? extends ZipEntry> e = zf.entries();
            while (e.hasMoreElements()) {
                ZipEntry ze = e.nextElement();
                if (ze.isDirectory()) {
                    continue;
                }
                if (ze.getName().startsWith(PLUGIN_DIR) && ze.getName().endsWith(JAR)) {
                    String pluginJarName = new File(ze.getName()).getName();
                    String pluginName = pluginJarName.substring(0, pluginJarName.length() - JAR.length());
                    final InputStream in = zf.getInputStream(ze);
                    processor.process(pluginName, in);
                    in.close();
                }
            }
        }
    }
}
#method_after
@Override
public void foreach(Processor processor) throws FileNotFoundException, IOException {
    File myWar = GerritLauncher.getDistributionArchive();
    if (myWar.isFile()) {
        try (ZipFile zf = new ZipFile(myWar)) {
            Enumeration<? extends ZipEntry> e = zf.entries();
            while (e.hasMoreElements()) {
                ZipEntry ze = e.nextElement();
                if (ze.isDirectory()) {
                    continue;
                }
                if (ze.getName().startsWith(PLUGIN_DIR) && ze.getName().endsWith(JAR)) {
                    String pluginJarName = new File(ze.getName()).getName();
                    String pluginName = pluginJarName.substring(0, pluginJarName.length() - JAR.length());
                    try (InputStream in = zf.getInputStream(ze)) {
                        processor.process(pluginName, in);
                    }
                }
            }
        }
    }
}
#end_block

#method_before
@Test
public void createDraft() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput.CommentInput comment = newCommentInfo("file1", Side.REVISION, "comment 1");
    addDraft(changeId, revId, comment);
    Map<String, List<CommentInfo>> result = getDraftComments(changeId, revId);
    assertThat(result).hasSize(1);
    CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
    assertCommentInfo(comment, actual);
}
#method_after
@Test
public void createDraft() throws Exception {
    for (Integer line : lines) {
        PushOneCommit.Result r = createChange();
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput.CommentInput comment = newCommentInfo("file1", Side.REVISION, line, "comment 1");
        addDraft(changeId, revId, comment);
        Map<String, List<CommentInfo>> result = getDraftComments(changeId, revId);
        assertThat(result).hasSize(1);
        CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
        assertCommentInfo(comment, actual);
    }
}
#end_block

#method_before
@Test
public void postComment() throws Exception {
    String file = "file";
    String contents = "contents";
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), "first subject", file, contents);
    PushOneCommit.Result r = push.to(git, "refs/for/master");
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput input = new ReviewInput();
    ReviewInput.CommentInput comment = newCommentInfo(file, Side.REVISION, "comment 1");
    input.comments = new HashMap<>();
    input.comments.put(comment.path, Lists.newArrayList(comment));
    revision(r).review(input);
    Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
    assertThat(result).isNotEmpty();
    CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
    assertCommentInfo(comment, actual);
}
#method_after
@Test
public void postComment() throws Exception {
    for (Integer line : lines) {
        String file = "file";
        String contents = "contents " + line;
        PushOneCommit push = pushFactory.create(db, admin.getIdent(), "first subject", file, contents);
        PushOneCommit.Result r = push.to(git, "refs/for/master");
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput input = new ReviewInput();
        ReviewInput.CommentInput comment = newCommentInfo(file, Side.REVISION, line, "comment 1");
        input.comments = new HashMap<>();
        input.comments.put(comment.path, Lists.newArrayList(comment));
        revision(r).review(input);
        Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
        assertThat(result).isNotEmpty();
        CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
        assertCommentInfo(comment, actual);
    }
}
#end_block

#method_before
@Test
public void putDraft() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput.CommentInput comment = newCommentInfo("file1", Side.REVISION, "comment 1");
    addDraft(changeId, revId, comment);
    Map<String, List<CommentInfo>> result = getDraftComments(changeId, revId);
    CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
    assertCommentInfo(comment, actual);
    String uuid = actual.id;
    comment.message = "updated comment 1";
    updateDraft(changeId, revId, comment, uuid);
    result = getDraftComments(changeId, revId);
    actual = Iterables.getOnlyElement(result.get(comment.path));
    assertCommentInfo(comment, actual);
}
#method_after
@Test
public void putDraft() throws Exception {
    for (Integer line : lines) {
        PushOneCommit.Result r = createChange();
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput.CommentInput comment = newCommentInfo("file1", Side.REVISION, line, "comment 1");
        addDraft(changeId, revId, comment);
        Map<String, List<CommentInfo>> result = getDraftComments(changeId, revId);
        CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
        assertCommentInfo(comment, actual);
        String uuid = actual.id;
        comment.message = "updated comment 1";
        updateDraft(changeId, revId, comment, uuid);
        result = getDraftComments(changeId, revId);
        actual = Iterables.getOnlyElement(result.get(comment.path));
        assertCommentInfo(comment, actual);
    }
}
#end_block

#method_before
@Test
public void getDraft() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput.CommentInput comment = newCommentInfo("file1", Side.REVISION, "comment 1");
    CommentInfo returned = addDraft(changeId, revId, comment);
    CommentInfo actual = getDraftComment(changeId, revId, returned.id);
    assertCommentInfo(comment, actual);
}
#method_after
@Test
public void getDraft() throws Exception {
    for (Integer line : lines) {
        PushOneCommit.Result r = createChange();
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput.CommentInput comment = newCommentInfo("file1", Side.REVISION, line, "comment 1");
        CommentInfo returned = addDraft(changeId, revId, comment);
        CommentInfo actual = getDraftComment(changeId, revId, returned.id);
        assertCommentInfo(comment, actual);
    }
}
#end_block

#method_before
@Test
public void deleteDraft() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput.CommentInput comment = newCommentInfo("file1", Side.REVISION, "comment 1");
    CommentInfo returned = addDraft(changeId, revId, comment);
    deleteDraft(changeId, revId, returned.id);
    Map<String, List<CommentInfo>> drafts = getDraftComments(changeId, revId);
    assertThat(drafts).isEmpty();
}
#method_after
@Test
public void deleteDraft() throws Exception {
    for (Integer line : lines) {
        PushOneCommit.Result r = createChange();
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput.CommentInput comment = newCommentInfo("file1", Side.REVISION, line, "comment 1");
        CommentInfo returned = addDraft(changeId, revId, comment);
        deleteDraft(changeId, revId, returned.id);
        Map<String, List<CommentInfo>> drafts = getDraftComments(changeId, revId);
        assertThat(drafts).isEmpty();
    }
}
#end_block

#method_before
private ReviewInput.CommentInput newCommentInfo(String path, Side side, String message) {
    ReviewInput.CommentInput input = new ReviewInput.CommentInput();
    input.path = path;
    input.side = side;
    input.line = 1;
    input.message = message;
    Comment.Range range = new Comment.Range();
    range.startLine = 1;
    range.startCharacter = 1;
    range.endLine = 1;
    range.endCharacter = 5;
    input.range = range;
    return input;
}
#method_after
private ReviewInput.CommentInput newCommentInfo(String path, Side side, int line, String message) {
    ReviewInput.CommentInput input = new ReviewInput.CommentInput();
    input.path = path;
    input.side = side;
    input.line = line != 0 ? line : null;
    input.message = message;
    if (line != 0) {
        Comment.Range range = new Comment.Range();
        range.startLine = 1;
        range.startCharacter = 1;
        range.endLine = 1;
        range.endCharacter = 5;
        input.range = range;
    }
    return input;
}
#end_block

#method_before
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws AuthException, OrmException, BadRequestException, UnprocessableEntityException, IOException, InvalidChangeOperationException, ResourceNotFoundException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new BadRequestException("cannot upload drafts");
        }
    }
    String refName = input.branch;
    if (!refName.startsWith(Constants.R_REFS)) {
        refName = Constants.R_HEADS + input.branch;
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    Repository git = gitManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(git);
        try {
            ObjectId parentCommit;
            if (input.baseChange != null) {
                List<Change> changes = changeUtil.findChanges(input.baseChange);
                if (changes.size() != 1) {
                    throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
                }
                Change change = Iterables.getOnlyElement(changes);
                if (!rsrc.getControl().controlFor(change).isVisible(db.get())) {
                    throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
                }
                PatchSet ps = db.get().patchSets().get(new PatchSet.Id(change.getId(), change.currentPatchSetId().get()));
                parentCommit = ObjectId.fromString(ps.getRevision().get());
            } else {
                Ref destRef = git.getRef(refName);
                if (destRef == null) {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
                parentCommit = destRef.getObjectId();
            }
            RevCommit mergeTip = rw.parseCommit(parentCommit);
            Timestamp now = TimeUtil.nowTs();
            IdentifiedUser me = (IdentifiedUser) userProvider.get();
            PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
            ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(git, rw, author, mergeTip, commitMessage);
            Change change = new Change(getChangeId(id, c), new Change.Id(db.get().nextChangeId()), me.getAccountId(), new Branch.NameKey(project, refName), now);
            ChangeInserter ins = changeInserterFactory.create(refControl, change, c);
            validateCommit(git, refControl, c, me, ins);
            updateRef(git, rw, c, change, ins.getPatchSet());
            change.setTopic(input.topic);
            ins.setDraft(input.status != null && input.status == ChangeStatus.DRAFT);
            ins.insert();
            return Response.created(json.format(change.getId()));
        } finally {
            rw.release();
        }
    } finally {
        git.close();
    }
}
#method_after
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws AuthException, OrmException, BadRequestException, UnprocessableEntityException, IOException, InvalidChangeOperationException, ResourceNotFoundException, MethodNotAllowedException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("cannot upload drafts");
        }
    }
    String refName = input.branch;
    if (!refName.startsWith(Constants.R_REFS)) {
        refName = Constants.R_HEADS + input.branch;
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    Repository git = gitManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(git);
        try {
            ObjectId parentCommit;
            if (input.baseChange != null) {
                List<Change> changes = changeUtil.findChanges(input.baseChange);
                if (changes.size() != 1) {
                    throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
                }
                Change change = Iterables.getOnlyElement(changes);
                if (!rsrc.getControl().controlFor(change).isVisible(db.get())) {
                    throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
                }
                PatchSet ps = db.get().patchSets().get(new PatchSet.Id(change.getId(), change.currentPatchSetId().get()));
                parentCommit = ObjectId.fromString(ps.getRevision().get());
            } else {
                Ref destRef = git.getRef(refName);
                if (destRef == null) {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
                parentCommit = destRef.getObjectId();
            }
            RevCommit mergeTip = rw.parseCommit(parentCommit);
            Timestamp now = TimeUtil.nowTs();
            IdentifiedUser me = (IdentifiedUser) userProvider.get();
            PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
            ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(git, rw, author, mergeTip, commitMessage);
            Change change = new Change(getChangeId(id, c), new Change.Id(db.get().nextChangeId()), me.getAccountId(), new Branch.NameKey(project, refName), now);
            ChangeInserter ins = changeInserterFactory.create(refControl, change, c);
            validateCommit(git, refControl, c, me, ins);
            updateRef(git, rw, c, change, ins.getPatchSet());
            change.setTopic(input.topic);
            ins.setDraft(input.status != null && input.status == ChangeStatus.DRAFT);
            ins.insert();
            return Response.created(json.format(change.getId()));
        } finally {
            rw.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
@Test
public void createDraftChangeNotAllowed() throws Exception {
    assume().that(isAllowDrafts()).isFalse();
    ChangeInfo ci = newChangeInfo(ChangeStatus.DRAFT);
    RestResponse r = adminSession.post("/changes/", ci);
    assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_BAD_REQUEST);
    assertThat(r.getEntityContent()).contains("cannot upload drafts");
}
#method_after
@Test
public void createDraftChangeNotAllowed() throws Exception {
    assume().that(isAllowDrafts()).isFalse();
    ChangeInfo ci = newChangeInfo(ChangeStatus.DRAFT);
    RestResponse r = adminSession.post("/changes/", ci);
    assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_METHOD_NOT_ALLOWED);
    assertThat(r.getEntityContent()).contains("cannot upload drafts");
}
#end_block

#method_before
@Override
public void addProjectWatch(final String projectName, final String filter, final AsyncCallback<AccountProjectWatchInfo> callback) {
    run(callback, new Action<AccountProjectWatchInfo>() {

        @Override
        public AccountProjectWatchInfo run(ReviewDb db) throws OrmException, NoSuchProjectException, InvalidQueryException {
            final Project.NameKey nameKey = new Project.NameKey(projectName);
            final ProjectControl ctl = projectControlFactory.validateFor(nameKey);
            if (filter != null) {
                try {
                    queryBuilder.create(currentUser).parse(filter);
                } catch (QueryParseException badFilter) {
                    throw new InvalidQueryException(badFilter.getMessage(), filter);
                }
            }
            AccountProjectWatch watch = new AccountProjectWatch(new AccountProjectWatch.Key(((IdentifiedUser) ctl.getCurrentUser()).getAccountId(), nameKey, filter));
            try {
                db.accountProjectWatches().insert(Collections.singleton(watch));
            } catch (OrmDuplicateKeyException alreadyHave) {
                watch = db.accountProjectWatches().get(watch.getKey());
            }
            return new AccountProjectWatchInfo(watch, ctl.getProject());
        }
    });
}
#method_after
@Override
public void addProjectWatch(final String projectName, final String filter, final AsyncCallback<AccountProjectWatchInfo> callback) {
    run(callback, new Action<AccountProjectWatchInfo>() {

        @Override
        public AccountProjectWatchInfo run(ReviewDb db) throws OrmException, NoSuchProjectException, InvalidQueryException {
            final Project.NameKey nameKey = new Project.NameKey(projectName);
            final ProjectControl ctl = projectControlFactory.validateFor(nameKey);
            if (filter != null) {
                try {
                    queryBuilder.parse(filter);
                } catch (QueryParseException badFilter) {
                    throw new InvalidQueryException(badFilter.getMessage(), filter);
                }
            }
            AccountProjectWatch watch = new AccountProjectWatch(new AccountProjectWatch.Key(((IdentifiedUser) ctl.getCurrentUser()).getAccountId(), nameKey, filter));
            try {
                db.accountProjectWatches().insert(Collections.singleton(watch));
            } catch (OrmDuplicateKeyException alreadyHave) {
                watch = db.accountProjectWatches().get(watch.getKey());
            }
            return new AccountProjectWatchInfo(watch, ctl.getProject());
        }
    });
}
#end_block

#method_before
private boolean filterMatch(CurrentUser user, String filter) throws OrmException, QueryParseException {
    ChangeQueryBuilder qb;
    Predicate<ChangeData> p = null;
    if (user == null) {
        qb = args.queryBuilder.create(Providers.of(args.anonymousUser));
    } else {
        qb = args.queryBuilder.create(Providers.of(user));
        p = qb.is_visible();
    }
    if (filter != null) {
        Predicate<ChangeData> filterPredicate = qb.parse(filter);
        if (p == null) {
            p = filterPredicate;
        } else {
            p = Predicate.and(filterPredicate, p);
        }
    }
    return p == null || p.match(changeData);
}
#method_after
private boolean filterMatch(CurrentUser user, String filter) throws OrmException, QueryParseException {
    ChangeQueryBuilder qb;
    Predicate<ChangeData> p = null;
    if (user == null) {
        qb = args.queryBuilder.asUser(args.anonymousUser);
    } else {
        qb = args.queryBuilder.asUser(user);
        p = qb.is_visible();
    }
    if (filter != null) {
        Predicate<ChangeData> filterPredicate = qb.parse(filter);
        if (p == null) {
            p = filterPredicate;
        } else {
            p = Predicate.and(filterPredicate, p);
        }
    }
    return p == null || p.match(changeData);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> has(String value) {
    if ("star".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args, userProvider.get());
    }
    if ("draft".equalsIgnoreCase(value)) {
        return new HasDraftByPredicate(args, self());
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> has(String value) throws QueryParseException {
    if ("star".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args);
    }
    if ("draft".equalsIgnoreCase(value)) {
        return new HasDraftByPredicate(args, self());
    }
    throw new IllegalArgumentException();
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args, userProvider.get());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, userProvider.get(), false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return new IsReviewedPredicate();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(self(), args.allowsDrafts);
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(schema(args.indexes), args.fillArgs);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args);
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return new IsReviewedPredicate();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(self(), args.allowsDrafts);
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(schema(args.indexes), args.fillArgs);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> parentproject(String name) {
    return new ParentProjectPredicate(args.projectCache, args.listChildProjects, userProvider, name);
}
#method_after
@Operator
public Predicate<ChangeData> parentproject(String name) {
    return new ParentProjectPredicate(args.projectCache, args.listChildProjects, args.self, name);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> starredby(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return new IsStarredByPredicate(args, userProvider.get());
    }
    Set<Account.Id> m = parseAccount(who);
    List<IsStarredByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(new IsStarredByPredicate(args, args.userFactory.create(args.db, id)));
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> starredby(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return new IsStarredByPredicate(args);
    }
    Set<Account.Id> m = parseAccount(who);
    List<IsStarredByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(new IsStarredByPredicate(args.asUser(id)));
    }
    return Predicate.or(p);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        CurrentUser user = userProvider.get();
        if (user.isIdentifiedUser() && id.equals(((IdentifiedUser) user).getAccountId())) {
            p.add(new IsWatchedByPredicate(args, user, false));
        } else {
            p.add(new IsWatchedByPredicate(args, args.userFactory.create(args.db, id), true));
        }
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    Account.Id callerId;
    try {
        CurrentUser caller = args.self.get();
        if (caller.isIdentifiedUser()) {
            callerId = ((IdentifiedUser) caller).getAccountId();
        } else {
            callerId = null;
        }
    } catch (ProvisionException e) {
        callerId = null;
    }
    for (Account.Id id : m) {
        // Each child IsWatchedByPredicate includes a visibility filter for the
        // corresponding user, to ensure that predicate subtree only returns
        // changes visible to that user. The exception is if one of the users is
        // the caller of this method, in which case visibility is already being
        // checked at the top level.
        p.add(new IsWatchedByPredicate(args.asUser(id), !id.equals(callerId)));
    }
    return Predicate.or(p);
}
#end_block

#method_before
public Predicate<ChangeData> is_visible() {
    return visibleto(userProvider.get());
}
#method_after
public Predicate<ChangeData> is_visible() throws QueryParseException {
    return visibleto(args.getCurrentUser());
}
#end_block

#method_before
private Account.Id self() {
    CurrentUser user = userProvider.get();
    if (user.isIdentifiedUser()) {
        return ((IdentifiedUser) user).getAccountId();
    }
    throw new IllegalArgumentException();
}
#method_after
private Account.Id self() throws QueryParseException {
    return args.getIdentifiedUser().getAccountId();
}
#end_block

#method_before
boolean isDisabled() {
    return getPermittedLimit() <= 0;
}
#method_after
boolean isDisabled() {
    return permittedLimit <= 0;
}
#end_block

#method_before
private int getEffectiveLimit(Predicate<ChangeData> p) {
    List<Integer> possibleLimits = new ArrayList<>(3);
    possibleLimits.add(getPermittedLimit());
    if (limitFromCaller > 0) {
        possibleLimits.add(limitFromCaller);
    }
    Integer limitFromPredicate = LimitPredicate.getLimit(p);
    if (limitFromPredicate != null) {
        possibleLimits.add(limitFromPredicate);
    }
    return Ordering.natural().min(possibleLimits);
}
#method_after
private int getEffectiveLimit(Predicate<ChangeData> p) {
    List<Integer> possibleLimits = new ArrayList<>(3);
    possibleLimits.add(permittedLimit);
    if (limitFromCaller > 0) {
        possibleLimits.add(limitFromCaller);
    }
    Integer limitFromPredicate = LimitPredicate.getLimit(p);
    if (limitFromPredicate != null) {
        possibleLimits.add(limitFromPredicate);
    }
    return Ordering.natural().min(possibleLimits);
}
#end_block

#method_before
private void registerCmEvents(final CodeMirror cm) {
    cm.on("beforeSelectionChange", onSelectionChange(cm));
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("gutterClick", onGutterClick(cm));
    cm.on("focus", updateActiveLine(cm));
    cm.addKeyMap(KeyMap.create().on("A", upToChange(true)).on("U", upToChange(false)).on("[", header.navigate(Direction.PREV)).on("]", header.navigate(Direction.NEXT)).on("R", header.toggleReviewed()).on("O", commentManager.toggleOpenBox(cm)).on("Enter", commentManager.toggleOpenBox(cm)).on("C", commentManager.insertNewDraft(cm)).on("N", maybeNextVimSearch(cm)).on("M", modifyInEditScreen(cm)).on("P", chunkManager.diffChunkNav(cm, Direction.PREV)).on("Shift-A", diffTable.toggleA()).on("Shift-M", header.reviewedAndNext()).on("Shift-N", maybePrevVimSearch(cm)).on("Shift-P", commentManager.commentNav(cm, Direction.PREV)).on("Shift-O", commentManager.openCloseAll(cm)).on("Shift-Left", moveCursorToSide(cm, DisplaySide.A)).on("Shift-Right", moveCursorToSide(cm, DisplaySide.B)).on("I", new Runnable() {

        @Override
        public void run() {
            switch(getIntraLineStatus()) {
                case OFF:
                case OK:
                    toggleShowIntraline();
                    break;
                default:
                    break;
            }
        }
    }).on("','", new Runnable() {

        @Override
        public void run() {
            prefsAction.show();
        }
    }).on("Shift-/", new Runnable() {

        @Override
        public void run() {
            new ShowHelpCommand().onKeyPress(null);
        }
    }).on("Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-d>");
        }
    }).on("Shift-Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-u>");
        }
    }).on("Ctrl-F", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("/");
        }
    }).on("Ctrl-A", new Runnable() {

        @Override
        public void run() {
            cm.execCommand("selectAll");
        }
    }));
    if (prefs.renderEntireFile()) {
        cm.addKeyMap(RENDER_ENTIRE_FILE_KEYMAP);
    }
}
#method_after
private void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("focus", updateActiveLine(cm));
    KeyMap keyMap = KeyMap.create().on("A", upToChange(true)).on("U", upToChange(false)).on("[", header.navigate(Direction.PREV)).on("]", header.navigate(Direction.NEXT)).on("R", header.toggleReviewed()).on("O", commentManager.toggleOpenBox(cm)).on("Enter", commentManager.toggleOpenBox(cm)).on("N", maybeNextVimSearch(cm)).on("M", modifyInEditScreen(cm)).on("P", chunkManager.diffChunkNav(cm, Direction.PREV)).on("Shift-A", diffTable.toggleA()).on("Shift-M", header.reviewedAndNext()).on("Shift-N", maybePrevVimSearch(cm)).on("Shift-P", commentManager.commentNav(cm, Direction.PREV)).on("Shift-O", commentManager.openCloseAll(cm)).on("Shift-Left", moveCursorToSide(cm, DisplaySide.A)).on("Shift-Right", moveCursorToSide(cm, DisplaySide.B)).on("I", new Runnable() {

        @Override
        public void run() {
            switch(getIntraLineStatus()) {
                case OFF:
                case OK:
                    toggleShowIntraline();
                    break;
                default:
                    break;
            }
        }
    }).on("','", new Runnable() {

        @Override
        public void run() {
            prefsAction.show();
        }
    }).on("Shift-/", new Runnable() {

        @Override
        public void run() {
            new ShowHelpCommand().onKeyPress(null);
        }
    }).on("Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-d>");
        }
    }).on("Shift-Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-u>");
        }
    }).on("Ctrl-F", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("/");
        }
    }).on("Ctrl-A", new Runnable() {

        @Override
        public void run() {
            cm.execCommand("selectAll");
        }
    });
    if (revision.get() != 0) {
        cm.on("beforeSelectionChange", onSelectionChange(cm));
        cm.on("gutterClick", onGutterClick(cm));
        keyMap.on("C", commentManager.insertNewDraft(cm));
    }
    cm.addKeyMap(keyMap);
    if (prefs.renderEntireFile()) {
        cm.addKeyMap(RENDER_ENTIRE_FILE_KEYMAP);
    }
}
#end_block

#method_before
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    List<SubmitRecord> submitRecords = checkSubmitRule(rsrc, force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.SUBMITTED);
                    change.setLastUpdatedOn(timestamp);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            return null;
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#method_after
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    List<SubmitRecord> submitRecords = checkSubmitRule(rsrc, force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = submitToDatabase(db, change, timestamp);
        if (change == null) {
            return null;
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#end_block

#method_before
protected void submitStatusOnly(String changeId) throws IOException, OrmException {
    approve(changeId);
    Change c = db.changes().byKey(new Change.Key(changeId)).toList().get(0);
    c.setStatus(Change.Status.SUBMITTED);
    db.changes().update(Collections.singleton(c));
    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(new PatchSetApproval.Key(c.currentPatchSetId(), admin.id, LabelId.SUBMIT), (short) 1, new Timestamp(System.currentTimeMillis()))));
}
#method_after
protected void submitStatusOnly(String changeId) throws IOException, OrmException {
    approve(changeId);
    Change c = queryProvider.get().byKeyPrefix(changeId).get(0).change();
    c.setStatus(Change.Status.SUBMITTED);
    db.changes().update(Collections.singleton(c));
    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(new PatchSetApproval.Key(c.currentPatchSetId(), admin.id, LabelId.SUBMIT), (short) 1, new Timestamp(System.currentTimeMillis()))));
    indexer.index(db, c);
}
#end_block

#method_before
protected void assertSubmitter(String changeId, int psId) throws OrmException {
    ChangeNotes cn = notesFactory.create(Iterables.getOnlyElement(db.changes().byKey(new Change.Key(changeId))));
    PatchSetApproval submitter = approvalsUtil.getSubmitter(db, cn, new PatchSet.Id(cn.getChangeId(), psId));
    assertThat(submitter.isSubmit()).isTrue();
    assertThat(submitter.getAccountId()).isEqualTo(admin.getId());
}
#method_after
protected void assertSubmitter(String changeId, int psId) throws OrmException {
    ChangeNotes cn = notesFactory.create(getOnlyElement(queryProvider.get().byKeyPrefix(changeId)).change());
    PatchSetApproval submitter = approvalsUtil.getSubmitter(db, cn, new PatchSet.Id(cn.getChangeId(), psId));
    assertThat(submitter.isSubmit()).isTrue();
    assertThat(submitter.getAccountId()).isEqualTo(admin.getId());
}
#end_block

#method_before
public void reduceToMinimalMerge(final MergeSorter mergeSorter, final List<CodeReviewCommit> toSort) throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = mergeSorter.sort(toSort);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toSort.clear();
    toSort.addAll(heads);
    Collections.sort(toSort, new Comparator<CodeReviewCommit>() {

        @Override
        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#method_after
public List<CodeReviewCommit> reduceToMinimalMerge(MergeSorter mergeSorter, Collection<CodeReviewCommit> toSort) throws MergeException {
    List<CodeReviewCommit> result = new ArrayList<>();
    try {
        result.addAll(mergeSorter.sort(toSort));
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    Collections.sort(result, CodeReviewCommit.ORDER);
    return result;
}
#end_block

#method_before
private void deleteActionCategories(ReviewDb db) throws OrmException {
    try {
        Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
        try {
            stmt.executeUpdate("DELETE FROM approval_categories WHERE position < 0");
        } finally {
            stmt.close();
        }
    } catch (SQLException e) {
        throw new OrmException(e);
    }
}
#method_after
private void deleteActionCategories(ReviewDb db) throws SQLException {
    try (Statement stmt = newStatement(db)) {
        stmt.executeUpdate("DELETE FROM approval_categories WHERE position < 0");
    }
}
#end_block

#method_before
private void exportProjectConfig(ReviewDb db) throws OrmException, SQLException {
    Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
    ResultSet rs = stmt.executeQuery("SELECT * FROM projects ORDER BY name");
    while (rs.next()) {
        final String name = rs.getString("name");
        final Project.NameKey nameKey = new Project.NameKey(name);
        Repository git;
        try {
            git = mgr.openRepository(nameKey);
        } catch (RepositoryNotFoundException notFound) {
            // inheritable permissions. For example 'All-Projects'.
            try {
                git = mgr.createRepository(nameKey);
            } catch (IOException err) {
                throw new OrmException("Cannot create repository " + name, err);
            }
        } catch (IOException e) {
            throw new OrmException(e);
        }
        try {
            MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, nameKey, git);
            md.getCommitBuilder().setAuthor(serverUser);
            md.getCommitBuilder().setCommitter(serverUser);
            ProjectConfig config = ProjectConfig.read(md);
            loadProject(rs, config.getProject());
            config.getAccessSections().clear();
            convertRights(config);
            // 
            if (config.getProject().getNameKey().equals(systemConfig.wildProjectName)) {
                AccessSection meta = config.getAccessSection(RefNames.REFS_CONFIG, true);
                Permission read = meta.getPermission(READ, true);
                read.getRule(config.resolve(projectOwners), true);
            }
            md.setMessage("Import project configuration from SQL\n");
            config.commit(md);
        } catch (ConfigInvalidException err) {
            throw new OrmException("Cannot read project " + name, err);
        } catch (IOException err) {
            throw new OrmException("Cannot export project " + name, err);
        } finally {
            git.close();
        }
    }
    rs.close();
    stmt.close();
}
#method_after
private void exportProjectConfig(ReviewDb db) throws OrmException, SQLException {
    try (Statement s = newStatement(db);
        ResultSet rs = s.executeQuery("SELECT * FROM projects ORDER BY name")) {
        while (rs.next()) {
            final String name = rs.getString("name");
            final Project.NameKey nameKey = new Project.NameKey(name);
            Repository git;
            try {
                git = mgr.openRepository(nameKey);
            } catch (RepositoryNotFoundException notFound) {
                // inheritable permissions. For example 'All-Projects'.
                try {
                    git = mgr.createRepository(nameKey);
                } catch (IOException err) {
                    throw new OrmException("Cannot create repository " + name, err);
                }
            } catch (IOException e) {
                throw new OrmException(e);
            }
            try {
                MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, nameKey, git);
                md.getCommitBuilder().setAuthor(serverUser);
                md.getCommitBuilder().setCommitter(serverUser);
                ProjectConfig config = ProjectConfig.read(md);
                loadProject(rs, config.getProject());
                config.getAccessSections().clear();
                convertRights(config);
                // 
                if (config.getProject().getNameKey().equals(systemConfig.wildProjectName)) {
                    AccessSection meta = config.getAccessSection(RefNames.REFS_CONFIG, true);
                    Permission read = meta.getPermission(READ, true);
                    read.getRule(config.resolve(projectOwners), true);
                }
                md.setMessage("Import project configuration from SQL\n");
                config.commit(md);
            } catch (ConfigInvalidException err) {
                throw new OrmException("Cannot read project " + name, err);
            } catch (IOException err) {
                throw new OrmException("Cannot export project " + name, err);
            } finally {
                git.close();
            }
        }
    }
}
#end_block

#method_before
private void readOldRefRights(ReviewDb db) throws SQLException {
    rightsByProject = new HashMap<>();
    Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
    ResultSet rs = stmt.executeQuery("SELECT * FROM ref_rights");
    while (rs.next()) {
        OldRefRight right = new OldRefRight(rs);
        if (right.group == null || right.category == null) {
            continue;
        }
        List<OldRefRight> list;
        list = rightsByProject.get(right.project);
        if (list == null) {
            list = new ArrayList<>();
            rightsByProject.put(right.project, list);
        }
        list.add(right);
    }
    rs.close();
    stmt.close();
}
#method_after
private void readOldRefRights(ReviewDb db) throws SQLException {
    rightsByProject = new HashMap<>();
    try (Statement s = newStatement(db);
        ResultSet rs = s.executeQuery("SELECT * FROM ref_rights")) {
        while (rs.next()) {
            OldRefRight right = new OldRefRight(rs);
            if (right.group == null || right.category == null) {
                continue;
            }
            List<OldRefRight> list;
            list = rightsByProject.get(right.project);
            if (list == null) {
                list = new ArrayList<>();
                rightsByProject.put(right.project, list);
            }
            list.add(right);
        }
    }
}
#end_block

#method_before
private void readProjectParents(ReviewDb db) throws SQLException {
    parentsByProject = new HashMap<>();
    Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
    ResultSet rs = stmt.executeQuery("SELECT * FROM projects");
    while (rs.next()) {
        String name = rs.getString("name");
        String parent_name = rs.getString("parent_name");
        if (parent_name == null) {
            parent_name = systemConfig.wildProjectName.get();
        }
        // 
        parentsByProject.put(// 
        new Project.NameKey(name), new Project.NameKey(parent_name));
    }
    rs.close();
    stmt.close();
}
#method_after
private void readProjectParents(ReviewDb db) throws SQLException {
    parentsByProject = new HashMap<>();
    try (Statement s = newStatement(db);
        ResultSet rs = s.executeQuery("SELECT * FROM projects")) {
        while (rs.next()) {
            String name = rs.getString("name");
            String parent_name = rs.getString("parent_name");
            if (parent_name == null) {
                parent_name = systemConfig.wildProjectName.get();
            }
            // 
            parentsByProject.put(// 
            new Project.NameKey(name), new Project.NameKey(parent_name));
        }
    }
}
#end_block

#method_before
private void alterTable(ReviewDb db, String sqlFormat) throws SQLException {
    Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
    try {
        stmt.executeUpdate(String.format(sqlFormat, "patch_set_approvals", "category_id"));
    } finally {
        stmt.close();
    }
}
#method_after
private void alterTable(ReviewDb db, String sqlFormat) throws SQLException {
    try (Statement stmt = newStatement(db)) {
        stmt.executeUpdate(String.format(sqlFormat, "patch_set_approvals", "category_id"));
    }
}
#end_block

#method_before
private void migratePatchSetApprovals(ReviewDb db, LegacyLabelTypes labelTypes) throws SQLException {
    PreparedStatement stmt = ((JdbcSchema) db).getConnection().prepareStatement("UPDATE patch_set_approvals SET category_id = ?, granted=granted" + " WHERE category_id = ?");
    try {
        for (LegacyLabelType type : labelTypes.getLegacyLabelTypes()) {
            stmt.setString(1, type.getName());
            stmt.setString(2, type.getId());
            stmt.addBatch();
        }
        stmt.executeBatch();
    } finally {
        stmt.close();
    }
}
#method_after
private void migratePatchSetApprovals(ReviewDb db, LegacyLabelTypes labelTypes) throws SQLException {
    try (PreparedStatement stmt = prepareStatement(db, "UPDATE patch_set_approvals SET category_id = ?, granted=granted" + " WHERE category_id = ?")) {
        for (LegacyLabelType type : labelTypes.getLegacyLabelTypes()) {
            stmt.setString(1, type.getName());
            stmt.setString(2, type.getId());
            stmt.addBatch();
        }
        stmt.executeBatch();
    }
}
#end_block

#method_before
static LegacyLabelTypes getLegacyTypes(ReviewDb db) throws SQLException {
    List<LegacyLabelType> types = Lists.newArrayListWithCapacity(2);
    Statement catStmt = ((JdbcSchema) db).getConnection().createStatement();
    try {
        ResultSet catRs = catStmt.executeQuery("SELECT category_id, name, function_name, copy_min_score" + " FROM approval_categories" + " ORDER BY position, name");
        PreparedStatement valStmt = ((JdbcSchema) db).getConnection().prepareStatement("SELECT value, name" + " FROM approval_category_values" + " WHERE category_id = ?");
        try {
            while (catRs.next()) {
                String id = catRs.getString("category_id");
                valStmt.setString(1, id);
                List<LabelValue> values = Lists.newArrayListWithCapacity(5);
                ResultSet valRs = valStmt.executeQuery();
                while (valRs.next()) {
                    values.add(new LabelValue(valRs.getShort("value"), valRs.getString("name")));
                }
                LegacyLabelType type = new LegacyLabelType(getLabelName(catRs.getString("name")), values);
                type.setId(id);
                type.setFunctionName(catRs.getString("function_name"));
                type.setCopyMinScore("Y".equals(catRs.getString("copy_min_score")));
                types.add(type);
            }
        } finally {
            valStmt.close();
        }
    } finally {
        catStmt.close();
    }
    return new LegacyLabelTypes(types);
}
#method_after
static LegacyLabelTypes getLegacyTypes(ReviewDb db) throws SQLException {
    List<LegacyLabelType> types = Lists.newArrayListWithCapacity(2);
    try (Statement catStmt = newStatement(db);
        ResultSet catRs = catStmt.executeQuery("SELECT category_id, name, function_name, copy_min_score" + " FROM approval_categories" + " ORDER BY position, name");
        PreparedStatement valStmt = prepareStatement(db, "SELECT value, name" + " FROM approval_category_values" + " WHERE category_id = ?")) {
        while (catRs.next()) {
            String id = catRs.getString("category_id");
            valStmt.setString(1, id);
            List<LabelValue> values = Lists.newArrayListWithCapacity(5);
            try (ResultSet valRs = valStmt.executeQuery()) {
                while (valRs.next()) {
                    values.add(new LabelValue(valRs.getShort("value"), valRs.getString("name")));
                }
            }
            LegacyLabelType type = new LegacyLabelType(getLabelName(catRs.getString("name")), values);
            type.setId(id);
            type.setFunctionName(catRs.getString("function_name"));
            type.setCopyMinScore("Y".equals(catRs.getString("copy_min_score")));
            types.add(type);
        }
    }
    return new LegacyLabelTypes(types);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
@Override
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db, String mergeResultRev) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
private void fireEventForUnrestrictedListeners(final Event event) {
    for (ChangeListener listener : unrestrictedListeners) {
        listener.onEvent(event);
    }
}
#method_after
private void fireEventForUnrestrictedListeners(final Event event) {
    for (EventListener listener : unrestrictedListeners) {
        listener.onEvent(event);
    }
}
#end_block

#method_before
private void fireEvent(final Change change, final Event event, final ReviewDb db) throws OrmException {
    for (ChangeListenerHolder holder : listeners.values()) {
        if (isVisibleTo(change, holder.user, db)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#method_after
private void fireEvent(final Change change, final Event event, final ReviewDb db) throws OrmException {
    for (EventListenerHolder holder : listeners.values()) {
        if (isVisibleTo(change, holder.user, db)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#end_block

#method_before
private void fireEvent(Branch.NameKey branchName, final Event event) {
    for (ChangeListenerHolder holder : listeners.values()) {
        if (isVisibleTo(branchName, holder.user)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#method_after
private void fireEvent(Branch.NameKey branchName, final Event event) {
    for (EventListenerHolder holder : listeners.values()) {
        if (isVisibleTo(branchName, holder.user)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) {
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) {
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes("UTF-8"));
        err.flush();
        onExit(1);
        return;
    }
    stdout = toPrintWriter(out);
    hooks.addChangeListener(listener, currentUser);
}
#method_after
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes("UTF-8"));
        err.flush();
        onExit(1);
        return;
    }
    stdout = toPrintWriter(out);
    hooks.addEventListener(listener, currentUser);
}
#end_block

#method_before
@Override
protected void onExit(final int rc) {
    hooks.removeChangeListener(listener);
    synchronized (taskLock) {
        done = true;
    }
    super.onExit(rc);
}
#method_after
@Override
protected void onExit(final int rc) {
    hooks.removeEventListener(listener);
    synchronized (taskLock) {
        done = true;
    }
    super.onExit(rc);
}
#end_block

#method_before
@Override
public void destroy() {
    hooks.removeChangeListener(listener);
    final boolean exit;
    synchronized (taskLock) {
        if (task != null) {
            task.cancel(true);
            // onExit will be invoked by the task cancellation.
            exit = false;
        } else {
            exit = !done;
        }
        done = true;
    }
    if (exit) {
        onExit(0);
    }
}
#method_after
@Override
public void destroy() {
    hooks.removeEventListener(listener);
    final boolean exit;
    synchronized (taskLock) {
        if (task != null) {
            task.cancel(true);
            // onExit will be invoked by the task cancellation.
            exit = false;
        } else {
            exit = !done;
        }
        done = true;
    }
    if (exit) {
        onExit(0);
    }
}
#end_block

#method_before
private void writeEvents() {
    int processed = 0;
    while (processed < BATCH_SIZE) {
        if (Thread.interrupted() || stdout.checkError()) {
            // The other side either requested a shutdown by calling our
            // destroy() above, or it closed the stream and is no longer
            // accepting output. Either way terminate this instance.
            // 
            hooks.removeChangeListener(listener);
            flush();
            onExit(0);
            return;
        }
        if (dropped) {
            write(droppedOutputEvent);
            dropped = false;
        }
        final Event event = poll();
        if (event == null) {
            break;
        }
        write(event);
        processed++;
    }
    flush();
    if (BATCH_SIZE <= processed) {
        // 
        synchronized (taskLock) {
            task = pool.submit(writer);
        }
    }
}
#method_after
private void writeEvents() {
    int processed = 0;
    while (processed < BATCH_SIZE) {
        if (Thread.interrupted() || stdout.checkError()) {
            // The other side either requested a shutdown by calling our
            // destroy() above, or it closed the stream and is no longer
            // accepting output. Either way terminate this instance.
            // 
            hooks.removeEventListener(listener);
            flush();
            onExit(0);
            return;
        }
        if (dropped) {
            write(droppedOutputEvent);
            dropped = false;
        }
        final Event event = poll();
        if (event == null) {
            break;
        }
        write(event);
        processed++;
    }
    flush();
    if (BATCH_SIZE <= processed) {
        // 
        synchronized (taskLock) {
            task = pool.submit(writer);
        }
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group1 = new CallbackGroup();
    CallbackGroup group2 = new CallbackGroup();
    final CallbackGroup group3 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group3.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.detail(revision.getParentKey().get(), group1.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo c) {
            project.setInnerText(c.project());
            SafeHtml.setInnerHTML(filePath, Header.formatPath(path, null, null));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (revision.get() == 0) {
        ChangeEditApi.getMeta(revision, path, group1.add(new AsyncCallback<EditFileInfo>() {

            @Override
            public void onSuccess(EditFileInfo editInfo) {
                editFileinfo = editInfo;
            }

            @Override
            public void onFailure(Throwable e) {
            }
        }));
    } else {
        // TODO(davido): We probably want to create dedicated GET EditScreenMeta
        // REST endpoint. Abuse GET diff for now, as it retrieves links we need.
        DiffApi.diff(revision, path).base(base).webLinksOnly().get(new GerritCallback<DiffInfo>() {

            @Override
            public void onSuccess(DiffInfo diffInfo) {
                patchSetDiffInfo = diffInfo;
            }
        });
    }
    ChangeEditApi.get(revision, path, group2.add(new HttpCallback<NativeString>() {

        final AsyncCallback<Void> modeCallback = group3.addEmpty();

        @Override
        public void onSuccess(HttpResponse<NativeString> fc) {
            content = fc;
            if (prefs.syntaxHighlighting()) {
                injectMode(fc.getContentType(), modeCallback);
            } else {
                modeCallback.onSuccess(null);
            }
        }

        @Override
        public void onFailure(Throwable e) {
            // "Not Found" means it's a new file.
            if (RestApi.isNotFound(e)) {
                content = null;
                modeCallback.onSuccess(null);
            } else {
                GerritCallback.showFailure(e);
            }
        }
    }));
    group3.addListener(new ScreenLoadCallback<Void>(this) {

        @Override
        protected void preDisplay(Void result) {
            initEditor(content, editFileinfo, patchSetDiffInfo);
            content = null;
            editFileinfo = null;
            patchSetDiffInfo = null;
        }
    });
    group1.done();
    group2.done();
    group3.done();
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group1 = new CallbackGroup();
    CallbackGroup group2 = new CallbackGroup();
    final CallbackGroup group3 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group3.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.detail(revision.getParentKey().get(), group1.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo c) {
            project.setInnerText(c.project());
            SafeHtml.setInnerHTML(filePath, Header.formatPath(path, null, null));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (revision.get() == 0) {
        ChangeEditApi.getMeta(revision, path, group1.add(new AsyncCallback<EditFileInfo>() {

            @Override
            public void onSuccess(EditFileInfo editInfo) {
                editFileInfo = editInfo;
            }

            @Override
            public void onFailure(Throwable e) {
            }
        }));
    } else {
        // TODO(davido): We probably want to create dedicated GET EditScreenMeta
        // REST endpoint. Abuse GET diff for now, as it retrieves links we need.
        DiffApi.diff(revision, path).base(base).webLinksOnly().get(new GerritCallback<DiffInfo>() {

            @Override
            public void onSuccess(DiffInfo diffInfo) {
                patchSetDiffInfo = diffInfo;
            }
        });
    }
    ChangeEditApi.get(revision, path, group2.add(new HttpCallback<NativeString>() {

        final AsyncCallback<Void> modeCallback = group3.addEmpty();

        @Override
        public void onSuccess(HttpResponse<NativeString> fc) {
            content = fc;
            if (prefs.syntaxHighlighting()) {
                injectMode(fc.getContentType(), modeCallback);
            } else {
                modeCallback.onSuccess(null);
            }
        }

        @Override
        public void onFailure(Throwable e) {
            // "Not Found" means it's a new file.
            if (RestApi.isNotFound(e)) {
                content = null;
                modeCallback.onSuccess(null);
            } else {
                GerritCallback.showFailure(e);
            }
        }
    }));
    group3.addListener(new ScreenLoadCallback<Void>(this) {

        @Override
        protected void preDisplay(Void result) {
            initEditor(content, editFileInfo, patchSetDiffInfo);
            content = null;
            editFileInfo = null;
            patchSetDiffInfo = null;
        }
    });
    group1.done();
    group2.done();
    group3.done();
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
    boolean useTopicSubmit = submitWholeTopic && !resource.getChange().getTopic().isEmpty();
    return new UiAction.Description().setLabel(useTopicSubmit ? labelSubmitTopic : label).setTitle(useTopicSubmit ? titlePatternSubmitTopic : Strings.emptyToNull(titlePattern.replace(params))).setVisible(!resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit());
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    if (submitWholeTopic && !topic.isEmpty()) {
        List<ChangeData> changesByTopic = null;
        try {
            changesByTopic = queryProvider.get().byTopic(topic);
        } catch (OrmException e) {
            throw new OrmRuntimeException(e);
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        // tooltip. Caution: Check access control for those changes.
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(areChangesSubmittable(changesByTopic, resource.getUser()));
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true);
    }
}
#end_block

#method_before
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    List<SubmitRecord> submitRecords = checkSubmitRule(rsrc, force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.SUBMITTED);
                    change.setLastUpdatedOn(timestamp);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            return null;
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#method_after
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    List<SubmitRecord> submitRecords = checkSubmitRule(rsrc, force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = submitToDatabase(db, change, timestamp);
        if (change == null) {
            return null;
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#end_block

#method_before
@Override
public int hashCode() {
    return computedHashCode();
}
#method_after
@Override
public int hashCode() {
    return cachedHashCode();
}
#end_block

#method_before
private void setUpChange() throws Exception {
    change = new Change(new Change.Key("Iabcd1234abcd1234abcd1234abcd1234abcd1234"), new Change.Id(1), userId, new Branch.NameKey(allProjects, "refs/heads/master"), TimeUtil.nowTs());
    ChangeUtil.computeSortKey(change);
    PatchSetInfo ps = new PatchSetInfo(new PatchSet.Id(change.getId(), 1));
    ps.setSubject("Test change");
    change.setCurrentPatchSet(ps);
    db.changes().insert(ImmutableList.of(change));
}
#method_after
private void setUpChange() throws Exception {
    change = new Change(new Change.Key("Iabcd1234abcd1234abcd1234abcd1234abcd1234"), new Change.Id(1), userId, new Branch.NameKey(allProjects, "refs/heads/master"), TimeUtil.nowTs());
    PatchSetInfo ps = new PatchSetInfo(new PatchSet.Id(change.getId(), 1));
    ps.setSubject("Test change");
    change.setCurrentPatchSet(ps);
    db.changes().insert(ImmutableList.of(change));
}
#end_block

#method_before
@Argument(index = 0, required = true, multiValued = true, metaVar = "{COMMIT | CHANGE,PATCHSET}", usage = "list of commits or patch sets to review")
void addPatchSetId(final String token) {
    try {
        patchSets.add(parsePatchSet(token));
    } catch (UnloggedFailure e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    } catch (OrmException e) {
        throw new IllegalArgumentException("database error", e);
    }
}
#method_after
@Argument(index = 0, required = true, multiValued = true, metaVar = "{COMMIT | CHANGE,PATCHSET}", usage = "list of commits or patch sets to review")
void addPatchSetId(final String token) {
    try {
        PatchSet ps = CommandUtils.parsePatchSet(token, db, projectControl, branch);
        patchSets.add(ps);
    } catch (UnloggedFailure e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    } catch (OrmException e) {
        throw new IllegalArgumentException("database error", e);
    }
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.setCmdLineParser(clp);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(destBranch).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(destBranch).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#method_after
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void markHeadsAsUninteresting(final RevWalk walk, Set<ObjectId> existing, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith(REFS_CHANGES)) {
            existing.add(ref.getObjectId());
        } else if (ref.getName().startsWith(R_HEADS) || (forRef != null && forRef.equals(ref.getName()))) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
        ins.setHashtags(magicBranch.getHashtags());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setApprovals(approvals).setMessage(msg).setSendMail(false).insert();
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, ins.getPatchSetInfo());
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        ins.setHashtags(magicBranch.hashtags);
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).insert();
    created = true;
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ps);
    }
}
#end_block

#method_before
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                    replaceByCommit.remove(req.newCommit);
                }
            }
        }
    } catch (OrmException err) {
        log.error(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        log.error(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#method_after
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        log.error(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        log.error(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.isDraft()) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.draft) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
        Set<String> hashtags = magicBranch.getHashtags();
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, changeCtl, approvals);
        recipients.add(oldRecipients);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, changeCtl, approvals);
        recipients.add(oldRecipients);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private ListMultimap<Change.Id, Ref> refsByChange() {
    if (refsByChange == null) {
        int estRefsPerChange = 4;
        refsByChange = ArrayListMultimap.create(allRefs.size() / estRefsPerChange, estRefsPerChange);
        for (Ref ref : allRefs.values()) {
            if (ref.getObjectId() != null) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                if (psId != null) {
                    refsByChange.put(psId.getParentKey(), ref);
                }
            }
        }
    }
    return refsByChange;
}
#method_after
private ListMultimap<Change.Id, Ref> refsByChange() {
    initChangeRefMaps();
    return refsByChange;
}
#end_block

#method_before
private SetMultimap<ObjectId, Ref> changeRefsById() {
    if (refsById == null) {
        refsById = HashMultimap.create();
        for (Ref r : refsByChange().values()) {
            refsById.put(r.getObjectId(), r);
        }
    }
    return refsById;
}
#method_after
private SetMultimap<ObjectId, Ref> changeRefsById() {
    initChangeRefMaps();
    return refsById;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.getEmailAddresses().contains(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByKey(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByKey(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // Update superproject gitlinks if required.
        subOpFactory.create(branch, newTip, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>(), currentUser.getAccount()).update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // Update superproject gitlinks if required.
        subOpFactory.create(branch, newTip, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>(), currentUser.getAccount()).update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db, commit.getName());
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws AuthException, BadRequestException, UnprocessableEntityException, OrmException, IOException {
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.get().changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.get().changes().get(revision.getChange().getId());
        ChangeUtil.updated(change);
        timestamp = change.getLastUpdatedOn();
        ChangeUpdate update = updateFactory.create(revision.getControl(), timestamp);
        update.setPatchSetId(revision.getPatchSet().getId());
        dirty |= insertComments(revision, update, input.comments, input.drafts);
        dirty |= updateLabels(revision, update, input.labels);
        dirty |= insertMessage(revision, input.message, update);
        if (dirty) {
            db.get().changes().update(Collections.singleton(change));
            db.get().commit();
        }
        update.commit();
    } finally {
        db.get().rollback();
    }
    CheckedFuture<?, IOException> indexWrite;
    if (dirty) {
        indexWrite = indexer.indexAsync(change.getId());
    } else {
        indexWrite = Futures.<Void, IOException>immediateCheckedFuture(null);
    }
    if (message != null && input.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
    }
    Output output = new Output();
    output.labels = input.labels;
    indexWrite.checkedGet();
    if (message != null) {
        fireCommentAddedHook(revision);
    }
    return output;
}
#method_after
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws AuthException, BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException {
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.get().changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.get().changes().get(revision.getChange().getId());
        ChangeUtil.updated(change);
        timestamp = change.getLastUpdatedOn();
        ChangeUpdate update = updateFactory.create(revision.getControl(), timestamp);
        update.setPatchSetId(revision.getPatchSet().getId());
        dirty |= insertComments(revision, update, input.comments, input.drafts);
        dirty |= updateLabels(revision, update, input.labels);
        dirty |= insertMessage(revision, input.message, update);
        if (dirty) {
            db.get().changes().update(Collections.singleton(change));
            db.get().commit();
        }
        update.commit();
    } finally {
        db.get().rollback();
    }
    CheckedFuture<?, IOException> indexWrite;
    if (dirty) {
        indexWrite = indexer.indexAsync(change.getId());
    } else {
        indexWrite = Futures.<Void, IOException>immediateCheckedFuture(null);
    }
    if (message != null && input.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
    }
    Output output = new Output();
    output.labels = input.labels;
    indexWrite.checkedGet();
    if (message != null) {
        fireCommentAddedHook(revision);
    }
    return output;
}
#end_block

#method_before
private void checkComments(RevisionResource revision, Map<String, List<CommentInput>> in) throws BadRequestException, OrmException {
    Iterator<Map.Entry<String, List<CommentInput>>> mapItr = in.entrySet().iterator();
    Set<String> filePaths = Sets.newHashSet(changeDataFactory.create(db.get(), revision.getControl()).filePaths(revision.getPatchSet()));
    while (mapItr.hasNext()) {
        Map.Entry<String, List<CommentInput>> ent = mapItr.next();
        String path = ent.getKey();
        if (!filePaths.contains(path) && !Patch.COMMIT_MSG.equals(path)) {
            throw new BadRequestException(String.format("file %s not found in revision %s", path, revision.getChange().currentPatchSetId()));
        }
        List<CommentInput> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        Iterator<CommentInput> listItr = list.iterator();
        while (listItr.hasNext()) {
            CommentInput c = listItr.next();
            if (c == null) {
                listItr.remove();
                continue;
            }
            if (c.line < 0) {
                throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
            }
            c.message = Strings.nullToEmpty(c.message).trim();
            if (c.message.isEmpty()) {
                listItr.remove();
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#method_after
private void checkComments(RevisionResource revision, Map<String, List<CommentInput>> in) throws BadRequestException, OrmException {
    Iterator<Map.Entry<String, List<CommentInput>>> mapItr = in.entrySet().iterator();
    Set<String> filePaths = Sets.newHashSet(changeDataFactory.create(db.get(), revision.getControl()).filePaths(revision.getPatchSet()));
    while (mapItr.hasNext()) {
        Map.Entry<String, List<CommentInput>> ent = mapItr.next();
        String path = ent.getKey();
        if (!filePaths.contains(path) && !Patch.COMMIT_MSG.equals(path)) {
            throw new BadRequestException(String.format("file %s not found in revision %s", path, revision.getChange().currentPatchSetId()));
        }
        List<CommentInput> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        Iterator<CommentInput> listItr = list.iterator();
        while (listItr.hasNext()) {
            CommentInput c = listItr.next();
            if (c == null) {
                listItr.remove();
                continue;
            }
            if (c.line != null && c.line < 0) {
                throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
            }
            c.message = Strings.nullToEmpty(c.message).trim();
            if (c.message.isEmpty()) {
                listItr.remove();
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
    return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(!resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit());
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    if (submitWholeTopic && !topic.isEmpty()) {
        List<ChangeData> changesByTopic = null;
        try {
            changesByTopic = queryProvider.get().byTopic(topic);
        } catch (OrmException e) {
            throw new OrmRuntimeException(e);
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        // tooltip. Caution: Check access control for those changes.
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(areChangesSubmittable(changesByTopic, resource.getUser()));
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true);
    }
}
#end_block

#method_before
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    List<SubmitRecord> submitRecords = checkSubmitRule(rsrc, force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.SUBMITTED);
                    change.setLastUpdatedOn(timestamp);
                    ChangeUtil.computeSortKey(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            return null;
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#method_after
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    if (submitWholeTopic) {
        return submitWholeTopic(rsrc, caller, force);
    } else {
        return submitThisChange(rsrc, caller, force);
    }
}
#end_block

#method_before
PermissionCollection filter(Iterable<SectionMatcher> matcherList, String ref, Collection<String> usernames) {
    if (isRE(ref)) {
        ref = RefControl.shortestExample(ref);
    } else if (ref.endsWith("/*")) {
        ref = ref.substring(0, ref.length() - 1);
    }
    boolean hasUsernames = usernames != null && !usernames.isEmpty();
    boolean perUser = false;
    Map<AccessSection, Project.NameKey> sectionToProject = Maps.newLinkedHashMap();
    for (SectionMatcher sm : matcherList) {
        // 
        if (hasUsernames) {
            if (!perUser && sm.matcher instanceof RefPatternMatcher.ExpandParameters) {
                perUser = ((RefPatternMatcher.ExpandParameters) sm.matcher).matchPrefix(ref);
            }
            for (String username : usernames) {
                if (sm.match(ref, username)) {
                    sectionToProject.put(sm.section, sm.project);
                    break;
                }
            }
        } else if (sm.match(ref, null)) {
            sectionToProject.put(sm.section, sm.project);
        }
    }
    List<AccessSection> sections = Lists.newArrayList(sectionToProject.keySet());
    sorter.sort(ref, sections);
    Set<SeenRule> seen = new HashSet<>();
    Set<String> exclusiveGroupPermissions = new HashSet<>();
    HashMap<String, List<PermissionRule>> permissions = new HashMap<>();
    Map<PermissionRule, ProjectRef> ruleProps = Maps.newIdentityHashMap();
    for (AccessSection section : sections) {
        Project.NameKey project = sectionToProject.get(section);
        for (Permission permission : section.getPermissions()) {
            boolean exclusivePermissionExists = exclusiveGroupPermissions.contains(permission.getName());
            for (PermissionRule rule : permission.getRules()) {
                SeenRule s = SeenRule.create(section, permission, rule);
                boolean addRule;
                if (rule.isBlock()) {
                    addRule = true;
                } else {
                    addRule = seen.add(s) && !rule.isDeny() && !exclusivePermissionExists;
                }
                if (addRule) {
                    List<PermissionRule> r = permissions.get(permission.getName());
                    if (r == null) {
                        r = new ArrayList<>(2);
                        permissions.put(permission.getName(), r);
                    }
                    r.add(rule);
                    ruleProps.put(rule, ProjectRef.create(project, section.getName()));
                }
            }
            if (permission.getExclusiveGroup()) {
                exclusiveGroupPermissions.add(permission.getName());
            }
        }
    }
    return new PermissionCollection(permissions, ruleProps, perUser);
}
#method_after
PermissionCollection filter(Iterable<SectionMatcher> matcherList, String ref, Provider<? extends Collection<String>> usernameProvider) {
    if (isRE(ref)) {
        ref = RefControl.shortestExample(ref);
    } else if (ref.endsWith("/*")) {
        ref = ref.substring(0, ref.length() - 1);
    }
    Collection<String> usernames = null;
    boolean perUser = false;
    Map<AccessSection, Project.NameKey> sectionToProject = Maps.newLinkedHashMap();
    for (SectionMatcher sm : matcherList) {
        // 
        if (sm.matcher instanceof RefPatternMatcher.ExpandParameters) {
            if (!((RefPatternMatcher.ExpandParameters) sm.matcher).matchPrefix(ref)) {
                continue;
            }
            perUser = true;
            if (usernames == null) {
                usernames = usernameProvider.get();
            }
            for (String username : usernames) {
                if (sm.match(ref, username)) {
                    sectionToProject.put(sm.section, sm.project);
                    break;
                }
            }
        } else if (sm.match(ref, null)) {
            sectionToProject.put(sm.section, sm.project);
        }
    }
    List<AccessSection> sections = Lists.newArrayList(sectionToProject.keySet());
    sorter.sort(ref, sections);
    Set<SeenRule> seen = new HashSet<>();
    Set<String> exclusiveGroupPermissions = new HashSet<>();
    HashMap<String, List<PermissionRule>> permissions = new HashMap<>();
    HashMap<String, List<PermissionRule>> overridden = new HashMap<>();
    Map<PermissionRule, ProjectRef> ruleProps = Maps.newIdentityHashMap();
    for (AccessSection section : sections) {
        Project.NameKey project = sectionToProject.get(section);
        for (Permission permission : section.getPermissions()) {
            boolean exclusivePermissionExists = exclusiveGroupPermissions.contains(permission.getName());
            for (PermissionRule rule : permission.getRules()) {
                SeenRule s = SeenRule.create(section, permission, rule);
                boolean addRule;
                if (rule.isBlock()) {
                    addRule = true;
                } else {
                    addRule = seen.add(s) && !rule.isDeny() && !exclusivePermissionExists;
                }
                HashMap<String, List<PermissionRule>> p = null;
                if (addRule) {
                    p = permissions;
                } else if (!rule.isDeny() && !exclusivePermissionExists) {
                    p = overridden;
                }
                if (p != null) {
                    List<PermissionRule> r = p.get(permission.getName());
                    if (r == null) {
                        r = new ArrayList<>(2);
                        p.put(permission.getName(), r);
                    }
                    r.add(rule);
                    ruleProps.put(rule, ProjectRef.create(project, section.getName()));
                }
            }
            if (permission.getExclusiveGroup()) {
                exclusiveGroupPermissions.add(permission.getName());
            }
        }
    }
    return new PermissionCollection(permissions, overridden, ruleProps, perUser);
}
#end_block

#method_before
static SeenRule create(AccessSection section, Permission permission, PermissionRule rule) {
    return new AutoValue_PermissionCollection_SeenRule(section.getName(), permission.getName(), rule.getGroup().getUUID());
}
#method_after
static SeenRule create(AccessSection section, Permission permission, @Nullable PermissionRule rule) {
    AccountGroup.UUID group = rule != null && rule.getGroup() != null ? rule.getGroup().getUUID() : null;
    return new AutoValue_PermissionCollection_SeenRule(section.getName(), permission.getName(), group);
}
#end_block

#method_before
@Override
public AuthUser authenticate(AuthRequest req) throws MissingCredentialsException, InvalidCredentialsException, UnknownUserException, UserNotAllowedException, AuthException {
    if (req.getUsername() == null) {
        throw new MissingCredentialsException();
    }
    final String username = lowerCaseUsername ? req.getUsername().toLowerCase(Locale.US) : req.getUsername();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, req.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), req.getPassword());
            }
            return new AuthUser(AuthUser.UUID.create(username), username);
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (AccountException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new InvalidCredentialsException("Cannot query LDAP for account", e);
    } catch (NamingException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new AuthException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthException("Cannot query LDAP for account", e);
    }
}
#method_after
@Override
public AuthUser authenticate(AuthRequest req) throws MissingCredentialsException, InvalidCredentialsException, UnknownUserException, UserNotAllowedException, AuthException {
    if (req.getUsername() == null) {
        throw new MissingCredentialsException();
    }
    final String username = lowerCaseUsername ? req.getUsername().toLowerCase(Locale.US) : req.getUsername();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, req.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), req.getPassword()).close();
            }
            return new AuthUser(AuthUser.UUID.create(username), username);
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (AccountException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new InvalidCredentialsException("Cannot query LDAP for account", e);
    } catch (NamingException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new AuthException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
public BatchMetaDataUpdate openUpdate(final MetaDataUpdate update) throws IOException {
    final Repository db = update.getRepository();
    reader = db.newObjectReader();
    inserter = db.newObjectInserter();
    final RevWalk rw = new RevWalk(reader);
    final RevTree tree = revision != null ? rw.parseTree(revision) : null;
    newTree = readTree(tree);
    return new BatchMetaDataUpdate() {

        AnyObjectId src = revision;

        AnyObjectId srcTree = tree;

        @Override
        public void write(CommitBuilder commit) throws IOException {
            write(VersionedMetaData.this, commit);
        }

        private boolean doSave(VersionedMetaData config, CommitBuilder commit) throws IOException {
            DirCache nt = config.newTree;
            ObjectReader r = config.reader;
            ObjectInserter i = config.inserter;
            try {
                config.newTree = newTree;
                config.reader = reader;
                config.inserter = inserter;
                return config.onSave(commit);
            } catch (ConfigInvalidException e) {
                throw new IOException("Cannot update " + getRefName() + " in " + db.getDirectory() + ": " + e.getMessage(), e);
            } finally {
                config.newTree = nt;
                config.reader = r;
                config.inserter = i;
            }
        }

        @Override
        public void write(VersionedMetaData config, CommitBuilder commit) throws IOException {
            if (!doSave(config, commit)) {
                return;
            }
            // Reuse tree from parent commit unless there are contents in newTree or
            // there is no tree for a parent commit.
            ObjectId res = newTree.getEntryCount() != 0 || srcTree == null ? newTree.writeTree(inserter) : srcTree.copy();
            if (res.equals(srcTree) && !update.allowEmpty() && (commit.getTreeId() == null)) {
                // If there are no changes to the content, don't create the commit.
                return;
            }
            // the tree for the updated DirCache.
            if (commit.getTreeId() == null) {
                commit.setTreeId(res);
            } else {
                // In this case, the caller populated the tree without using DirCache.
                res = commit.getTreeId();
            }
            if (src != null) {
                commit.addParentId(src);
            }
            src = inserter.insert(commit);
            srcTree = res;
        }

        @Override
        public RevCommit createRef(String refName) throws IOException {
            if (Objects.equals(src, revision)) {
                return revision;
            }
            return updateRef(ObjectId.zeroId(), src, refName);
        }

        @Override
        public void removeRef(String refName) throws IOException {
            RefUpdate ru = db.updateRef(refName);
            ru.setForceUpdate(true);
            if (revision != null) {
                ru.setExpectedOldObjectId(revision);
            }
            RefUpdate.Result result = ru.delete();
            switch(result) {
                case FORCED:
                    update.fireGitRefUpdatedEvent(ru);
                    return;
                default:
                    throw new IOException("Cannot delete " + ru.getName() + " in " + db.getDirectory() + ": " + ru.getResult());
            }
        }

        @Override
        public RevCommit commit() throws IOException {
            return commitAt(revision);
        }

        @Override
        public RevCommit commitAt(ObjectId expected) throws IOException {
            if (Objects.equals(src, expected)) {
                return revision;
            }
            return updateRef(MoreObjects.firstNonNull(expected, ObjectId.zeroId()), src, getRefName());
        }

        @Override
        public void close() {
            newTree = null;
            if (inserter != null) {
                inserter.release();
                inserter = null;
            }
            if (reader != null) {
                reader.release();
                reader = null;
            }
        }

        private RevCommit updateRef(AnyObjectId oldId, AnyObjectId newId, String refName) throws IOException {
            BatchRefUpdate bru = update.getBatch();
            if (bru != null) {
                bru.addCommand(new ReceiveCommand(oldId.toObjectId(), newId.toObjectId(), refName));
                inserter.flush();
                revision = rw.parseCommit(newId);
                return revision;
            }
            RefUpdate ru = db.updateRef(refName);
            ru.setExpectedOldObjectId(oldId);
            ru.setNewObjectId(src);
            ru.setRefLogIdent(update.getCommitBuilder().getAuthor());
            ru.setRefLogMessage("meta data update", true);
            inserter.flush();
            RefUpdate.Result result = ru.update();
            switch(result) {
                case NEW:
                case FAST_FORWARD:
                    revision = rw.parseCommit(ru.getNewObjectId());
                    update.fireGitRefUpdatedEvent(ru);
                    return revision;
                default:
                    throw new IOException("Cannot update " + ru.getName() + " in " + db.getDirectory() + ": " + ru.getResult());
            }
        }
    };
}
#method_after
public BatchMetaDataUpdate openUpdate(final MetaDataUpdate update) throws IOException {
    final Repository db = update.getRepository();
    reader = db.newObjectReader();
    inserter = db.newObjectInserter();
    final RevWalk rw = new RevWalk(reader);
    final RevTree tree = revision != null ? rw.parseTree(revision) : null;
    newTree = readTree(tree);
    return new BatchMetaDataUpdate() {

        AnyObjectId src = revision;

        AnyObjectId srcTree = tree;

        @Override
        public void write(CommitBuilder commit) throws IOException {
            write(VersionedMetaData.this, commit);
        }

        private boolean doSave(VersionedMetaData config, CommitBuilder commit) throws IOException {
            DirCache nt = config.newTree;
            ObjectReader r = config.reader;
            ObjectInserter i = config.inserter;
            try {
                config.newTree = newTree;
                config.reader = reader;
                config.inserter = inserter;
                return config.onSave(commit);
            } catch (ConfigInvalidException e) {
                throw new IOException("Cannot update " + getRefName() + " in " + db.getDirectory() + ": " + e.getMessage(), e);
            } finally {
                config.newTree = nt;
                config.reader = r;
                config.inserter = i;
            }
        }

        @Override
        public void write(VersionedMetaData config, CommitBuilder commit) throws IOException {
            if (!doSave(config, commit)) {
                return;
            }
            // Reuse tree from parent commit unless there are contents in newTree or
            // there is no tree for a parent commit.
            ObjectId res = newTree.getEntryCount() != 0 || srcTree == null ? newTree.writeTree(inserter) : srcTree.copy();
            if (res.equals(srcTree) && !update.allowEmpty() && (commit.getTreeId() == null)) {
                // If there are no changes to the content, don't create the commit.
                return;
            }
            // the tree for the updated DirCache.
            if (commit.getTreeId() == null) {
                commit.setTreeId(res);
            } else {
                // In this case, the caller populated the tree without using DirCache.
                res = commit.getTreeId();
            }
            if (src != null) {
                commit.addParentId(src);
            }
            src = inserter.insert(commit);
            srcTree = res;
        }

        @Override
        public RevCommit createRef(String refName) throws IOException {
            if (Objects.equals(src, revision)) {
                return revision;
            }
            return updateRef(ObjectId.zeroId(), src, refName);
        }

        @Override
        public void removeRef(String refName) throws IOException {
            RefUpdate ru = db.updateRef(refName);
            ru.setForceUpdate(true);
            if (revision != null) {
                ru.setExpectedOldObjectId(revision);
            }
            RefUpdate.Result result = ru.delete();
            switch(result) {
                case FORCED:
                    update.fireGitRefUpdatedEvent(ru);
                    return;
                default:
                    throw new IOException("Cannot delete " + ru.getName() + " in " + db.getDirectory() + ": " + ru.getResult());
            }
        }

        @Override
        public RevCommit commit() throws IOException {
            return commitAt(revision);
        }

        @Override
        public RevCommit commitAt(ObjectId expected) throws IOException {
            if (Objects.equals(src, expected)) {
                return revision;
            }
            return updateRef(MoreObjects.firstNonNull(expected, ObjectId.zeroId()), src, getRefName());
        }

        @Override
        public void close() {
            newTree = null;
            if (inserter != null) {
                inserter.release();
                inserter = null;
            }
            if (reader != null) {
                reader.release();
                reader = null;
            }
        }

        private RevCommit updateRef(AnyObjectId oldId, AnyObjectId newId, String refName) throws IOException {
            BatchRefUpdate bru = update.getBatch();
            if (bru != null) {
                bru.addCommand(new ReceiveCommand(oldId.toObjectId(), newId.toObjectId(), refName));
                inserter.flush();
                revision = rw.parseCommit(newId);
                return revision;
            }
            RefUpdate ru = db.updateRef(refName);
            ru.setExpectedOldObjectId(oldId);
            ru.setNewObjectId(src);
            ru.setRefLogIdent(update.getCommitBuilder().getAuthor());
            try (BufferedReader reader = new BufferedReader(new StringReader(update.getCommitBuilder().getMessage()))) {
                // read the subject line and use it as reflog message
                ru.setRefLogMessage("commit: " + reader.readLine(), true);
            }
            inserter.flush();
            RefUpdate.Result result = ru.update();
            switch(result) {
                case NEW:
                case FAST_FORWARD:
                    revision = rw.parseCommit(ru.getNewObjectId());
                    update.fireGitRefUpdatedEvent(ru);
                    return revision;
                default:
                    throw new IOException("Cannot update " + ru.getName() + " in " + db.getDirectory() + ": " + ru.getResult());
            }
        }
    };
}
#end_block

#method_before
private Repository createRepository(File path, Project.NameKey name) throws RepositoryNotFoundException, RepositoryCaseMismatchException {
    if (isUnreasonableName(name)) {
        throw new RepositoryNotFoundException("Invalid name: " + name);
    }
    File dir = FileKey.resolve(new File(path, name.get()), FS.DETECTED);
    FileKey loc;
    if (dir != null) {
        // Already exists on disk, use the repository we found.
        // 
        loc = FileKey.exact(dir, FS.DETECTED);
        if (!names.contains(name)) {
            throw new RepositoryCaseMismatchException(name);
        }
    } else {
        // It doesn't exist under any of the standard permutations
        // of the repository name, so prefer the standard bare name.
        // 
        String n = name.get() + Constants.DOT_GIT_EXT;
        loc = FileKey.exact(new File(path, n), FS.DETECTED);
    }
    try {
        Repository db = RepositoryCache.open(loc, false);
        db.create(true);
        StoredConfig config = db.getConfig();
        config.setBoolean(ConfigConstants.CONFIG_CORE_SECTION, null, ConfigConstants.CONFIG_KEY_LOGALLREFUPDATES, true);
        config.save();
        // JGit only creates a ref log for refs/meta/config if the log file
        // already exists.
        // 
        File metaConfigLog = new File(db.getDirectory(), "logs/" + RefNames.REFS_CONFIG);
        if (!metaConfigLog.getParentFile().mkdirs() || !metaConfigLog.createNewFile()) {
            log.error(String.format("Failed to create ref log for %s in repository %s", RefNames.REFS_CONFIG, name));
        }
        onCreateProject(name);
        return db;
    } catch (IOException e1) {
        final RepositoryNotFoundException e2;
        e2 = new RepositoryNotFoundException("Cannot create repository " + name);
        e2.initCause(e1);
        throw e2;
    }
}
#method_after
private Repository createRepository(File path, Project.NameKey name) throws RepositoryNotFoundException, RepositoryCaseMismatchException {
    if (isUnreasonableName(name)) {
        throw new RepositoryNotFoundException("Invalid name: " + name);
    }
    File dir = FileKey.resolve(new File(path, name.get()), FS.DETECTED);
    FileKey loc;
    if (dir != null) {
        // Already exists on disk, use the repository we found.
        // 
        loc = FileKey.exact(dir, FS.DETECTED);
        if (!names.contains(name)) {
            throw new RepositoryCaseMismatchException(name);
        }
    } else {
        // It doesn't exist under any of the standard permutations
        // of the repository name, so prefer the standard bare name.
        // 
        String n = name.get() + Constants.DOT_GIT_EXT;
        loc = FileKey.exact(new File(path, n), FS.DETECTED);
    }
    try {
        Repository db = RepositoryCache.open(loc, false);
        db.create(true);
        StoredConfig config = db.getConfig();
        config.setBoolean(ConfigConstants.CONFIG_CORE_SECTION, null, ConfigConstants.CONFIG_KEY_LOGALLREFUPDATES, true);
        config.save();
        // JGit only writes to the reflog for refs/meta/config if the log file
        // already exists.
        // 
        File metaConfigLog = new File(db.getDirectory(), "logs/" + RefNames.REFS_CONFIG);
        if (!metaConfigLog.getParentFile().mkdirs() || !metaConfigLog.createNewFile()) {
            log.error(String.format("Failed to create ref log for %s in repository %s", RefNames.REFS_CONFIG, name));
        }
        onCreateProject(name);
        return db;
    } catch (IOException e1) {
        final RepositoryNotFoundException e2;
        e2 = new RepositoryNotFoundException("Cannot create repository " + name);
        e2.initCause(e1);
        throw e2;
    }
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    if (!(repoManager instanceof LocalDiskRepositoryManager)) {
        return;
    }
    for (Project.NameKey project : repoManager.list()) {
        try {
            Repository repo = repoManager.openRepository(project);
            try {
                File metaConfigLog = new File(repo.getDirectory(), "logs/" + RefNames.REFS_CONFIG);
                if (metaConfigLog.exists()) {
                    continue;
                }
                if (!metaConfigLog.getParentFile().mkdirs() || !metaConfigLog.createNewFile()) {
                    throw new IOException(String.format("Failed to create ref log for %s in repository %s", RefNames.REFS_CONFIG, project));
                }
                ObjectId metaConfigId = repo.resolve(RefNames.REFS_CONFIG);
                if (metaConfigId != null) {
                    try (PrintWriter writer = new PrintWriter(metaConfigLog, UTF_8.name())) {
                        writer.print(ObjectId.zeroId().name());
                        writer.print(" ");
                        writer.print(metaConfigId.name());
                        writer.print(" ");
                        writer.print(serverUser.toExternalString());
                        writer.print("\t");
                        writer.print("create ref log");
                        writer.println();
                    }
                }
            } finally {
                repo.close();
            }
        } catch (IOException e) {
            throw new OrmException(e);
        }
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    if (!(repoManager instanceof LocalDiskRepositoryManager)) {
        return;
    }
    ui.message("listing all repositories ...");
    SortedSet<Project.NameKey> repoList = repoManager.list();
    ui.message("done");
    ui.message(String.format("creating reflog files for %s branches ...", RefNames.REFS_CONFIG));
    for (Project.NameKey project : repoList) {
        try {
            Repository repo = repoManager.openRepository(project);
            try {
                File metaConfigLog = new File(repo.getDirectory(), "logs/" + RefNames.REFS_CONFIG);
                if (metaConfigLog.exists()) {
                    continue;
                }
                if (!metaConfigLog.getParentFile().mkdirs() || !metaConfigLog.createNewFile()) {
                    throw new IOException(String.format("Failed to create reflog for %s in repository %s", RefNames.REFS_CONFIG, project));
                }
                ObjectId metaConfigId = repo.resolve(RefNames.REFS_CONFIG);
                if (metaConfigId != null) {
                    try (PrintWriter writer = new PrintWriter(metaConfigLog, UTF_8.name())) {
                        writer.print(ObjectId.zeroId().name());
                        writer.print(" ");
                        writer.print(metaConfigId.name());
                        writer.print(" ");
                        writer.print(serverUser.toExternalString());
                        writer.print("\t");
                        writer.print("create reflog");
                        writer.println();
                    }
                }
            } finally {
                repo.close();
            }
        } catch (IOException e) {
            ui.message(String.format("ERROR: Failed to create reflog file for the" + " %s branch in repository %s", RefNames.REFS_CONFIG, project.get()));
        }
    }
    ui.message("done");
}
#end_block

#method_before
static void call(Button b, final String project) {
    // TODO Replace CreateChangeDialog with a nicer looking display.
    b.setEnabled(false);
    new CreateChangeDialog(new Project.NameKey(project)) {

        {
            sendButton.setText(Util.C.buttonCreate());
            message.setText(Util.C.buttonCreateDescription());
        }

        @Override
        public void onSend() {
            ChangeApi.createChange(project, getDestinationBranch(), message.getText(), null, true, new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#method_after
static void call(Button b, final String project) {
    // TODO Replace CreateChangeDialog with a nicer looking display.
    b.setEnabled(false);
    new CreateChangeDialog(new Project.NameKey(project)) {

        {
            sendButton.setText(Util.C.buttonCreate());
            message.setText(Util.C.buttonCreateDescription());
        }

        @Override
        public void onSend() {
            ChangeApi.createDraftChange(project, getDestinationBranch(), message.getText(), null, new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#end_block

#method_before
@Override
protected void run() throws Failure {
    IoAcceptor acceptor = sshDaemon.getIoAcceptor();
    if (acceptor == null) {
        throw new Failure(1, "fatal: sshd no longer running");
    }
    for (String sessionId : sessionIds) {
        boolean connectionFound = false;
        int id = (int) Long.parseLong(sessionId, 16);
        for (final IoSession io : acceptor.getManagedSessions().values()) {
            ServerSession serverSession = (ServerSession) ServerSession.getSession(io, true);
            SshSession sshSession = serverSession != null ? serverSession.getAttribute(SshSession.KEY) : null;
            if (sshSession.getSessionId() == id) {
                connectionFound = true;
                stdout.println("closing connection " + sessionId + "...");
                io.close(true);
                break;
            }
        }
        if (!connectionFound) {
            stderr.print("close connection " + id + ": no such connection\n");
        }
    }
}
#method_after
@Override
protected void run() throws Failure {
    IoAcceptor acceptor = sshDaemon.getIoAcceptor();
    if (acceptor == null) {
        throw new Failure(1, "fatal: sshd no longer running");
    }
    for (String sessionId : sessionIds) {
        boolean connectionFound = false;
        int id = (int) Long.parseLong(sessionId, 16);
        for (IoSession io : acceptor.getManagedSessions().values()) {
            ServerSession serverSession = (ServerSession) ServerSession.getSession(io, true);
            SshSession sshSession = serverSession != null ? serverSession.getAttribute(SshSession.KEY) : null;
            if (sshSession != null && sshSession.getSessionId() == id) {
                connectionFound = true;
                stdout.println("closing connection " + sessionId + "...");
                IoCloseFuture future = io.close(true);
                if (wait) {
                    try {
                        future.await();
                        stdout.println("closed connection " + sessionId);
                    } catch (InterruptedException e) {
                        log.warn("Wait for connection to close interrupted: " + e.getMessage());
                    }
                }
                break;
            }
        }
        if (!connectionFound) {
            stderr.print("close connection " + sessionId + ": no such connection\n");
        }
    }
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    if (submitWholeTopic && !topic.isEmpty()) {
        ReviewDb db = dbProvider.get();
        ResultSet<Change> changesByTopic = null;
        try {
            changesByTopic = db.changes().byTopic(topic);
        } catch (OrmException e1) {
            // TODO(sbeller): Auto-generated catch block,
            e1.printStackTrace();
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.toList().size()));
        boolean visibility = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
        Project.NameKey previousProject = resource.getChange().getProject();
        for (Change c : changesByTopic) {
            ChangeControl changeControl = null;
            if (c.getProject().equals(previousProject)) {
                // Avoid calling changeControlFactory all the time as it is quite costly.
                changeControl = resource.getControl().getProjectControl().controlFor(c);
            } else {
                try {
                    changeControl = changeControlFactory.controlFor(c, resource.getUser());
                } catch (NoSuchChangeException e) {
                    visibility = false;
                // todo also log/tell the user
                }
                previousProject = changeControl.getChange().getProject();
            }
            if (changeControl != null) {
                visibility &= changeControl.canSubmit();
            }
        }
        return new UiAction.Description().setLabel(labelSubmitTopic).setTitle(Strings.emptyToNull(titlePatternSubmitTopic.replace(params))).setVisible(visibility);
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(!resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit());
    }
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    if (submitWholeTopic && !topic.isEmpty()) {
        List<ChangeData> changesByTopic = null;
        try {
            changesByTopic = queryProvider.get().byTopic(topic);
        } catch (OrmException e) {
            throw new OrmRuntimeException(e);
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        // tooltip. Caution: Check access control for those changes.
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(areChangesSubmittable(changesByTopic, resource.getUser()));
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true);
    }
}
#end_block

#method_before
private Change submitToDatabase(ReviewDb db, Change change, final Timestamp timestamp) throws OrmException {
    return db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setStatus(Change.Status.SUBMITTED);
                change.setLastUpdatedOn(timestamp);
                return change;
            }
            return null;
        }
    });
}
#method_after
private Change submitToDatabase(ReviewDb db, Change.Id changeId, final Timestamp timestamp) throws OrmException {
    return db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setStatus(Change.Status.SUBMITTED);
                change.setLastUpdatedOn(timestamp);
                return change;
            }
            return null;
        }
    });
}
#end_block

#method_before
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    List<SubmitRecord> submitRecords = checkSubmitRule(rsrc, force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        if (submitWholeTopic) {
            String topic = change.getTopic();
            ResultSet<Change> changes = db.changes().byTopic(topic);
            for (Change c : changes) {
                c = submitToDatabase(db, c, timestamp);
                if (c == null) {
                    return null;
                }
            }
        } else {
            change = submitToDatabase(db, change, timestamp);
            if (change == null) {
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (submitWholeTopic) {
        for (Change c : db.changes().byTopic(change.getTopic())) {
            indexer.index(db, c);
        }
    } else {
        indexer.index(db, change);
    }
    return change;
}
#method_after
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    if (submitWholeTopic) {
        return submitWholeTopic(rsrc, caller, force);
    } else {
        return submitThisChange(rsrc, caller, force);
    }
}
#end_block

#method_before
private void initEditMode(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.is_edit()) {
            NativeMap<ActionInfo> actions = info.edit().has_actions() ? info.edit().actions() : NativeMap.<ActionInfo>create();
            actions.copyKeysIntoChildren("id");
            if (actions.containsKey("publish")) {
                publishEdit.setVisible(true);
                publishEdit.setTitle(actions.get("publish").title());
            }
            if (actions.containsKey("rebase")) {
                rebaseEdit.setVisible(true);
                rebaseEdit.setTitle(actions.get("rebase").title());
            }
            if (actions.containsKey("/")) {
                deleteEdit.setVisible(true);
                deleteEdit.setTitle(actions.get("/").title());
            }
        }
    }
}
#method_after
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.is_edit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    commit.onShowView();
    related.setMaxHeight(commit.getElement().getParentElement().getOffsetHeight());
    if (openReplyBox) {
        onReply();
    } else {
        String prior = Gerrit.getPriorView();
        if (prior != null && prior.startsWith("/c/")) {
            scrollToPath(prior.substring(3));
        }
    }
    ChangeGlue.fireShowChange(changeInfo, changeInfo.revision(revision));
    CodeMirror.preload();
    startPoller();
    if (NewChangeScreenBar.show()) {
        add(new NewChangeScreenBar(changeId));
    }
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    commit.onShowView();
    related.setMaxHeight(commit.getElement().getParentElement().getOffsetHeight());
    if (openReplyBox) {
        onReply();
    } else {
        String prior = Gerrit.getPriorView();
        if (prior != null && prior.startsWith("/c/")) {
            scrollToPath(prior.substring(3));
        }
    }
    ChangeGlue.fireShowChange(changeInfo, changeInfo.revision(revision));
    CodeMirror.preload();
    startPoller();
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.set(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()), style, editMessage, reply, fileTableMode, edit != null);
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.set(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    DiffApi.list(changeId.get(), base != null ? base.name() : null, rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()), style, editMessage, reply, fileTableMode, edit != null);
            files.setValue(m, myLastReply, comments.get(0), drafts.get(0));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#method_after
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    DiffApi.list(changeId.get(), base != null ? base.name() : null, rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
            files.setValue(m, myLastReply, comments.get(0), drafts.get(0));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initChangeAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initChangeAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        postReviewers.get().apply(change, in);
    } catch (OrmException | EmailException | IOException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#method_after
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        postReviewers.apply(change, in);
    } catch (OrmException | EmailException | IOException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> suggestReviewers(String query, int limit) throws RestApiException {
    try {
        SuggestReviewers mySuggestReviewers = suggestReviewers.get();
        mySuggestReviewers.setQuery(query);
        mySuggestReviewers.setLimit(limit);
        return mySuggestReviewers.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#method_after
@Override
public SuggestedReviewersRequest suggestReviewers() throws RestApiException {
    return new SuggestedReviewersRequest() {

        @Override
        public List<SuggestedReviewerInfo> get() throws RestApiException {
            return ChangeApiImpl.this.suggestReviewers(this);
        }
    };
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> suggestReviewers(String query) throws RestApiException {
    try {
        SuggestReviewers mySuggestReviewers = suggestReviewers.get();
        mySuggestReviewers.setQuery(query);
        return mySuggestReviewers.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#method_after
@Override
public SuggestedReviewersRequest suggestReviewers(String query) throws RestApiException {
    return suggestReviewers().withQuery(query);
}
#end_block

#method_before
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return ChangeInfoMapper.INSTANCE.apply(changeJson.get().addOptions(s).format(change));
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#method_after
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return changeJson.get().addOptions(s).format(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo get() throws RestApiException {
    return get(EnumSet.allOf(ListChangesOption.class));
}
#method_after
@Override
public ChangeInfo get() throws RestApiException {
    return get(EnumSet.complementOf(EnumSet.of(ListChangesOption.CHECK)));
}
#end_block

#method_before
@Test
@GerritConfig(name = "suggest.accounts", value = "false")
public void suggestReviewersNoResult1() throws GitAPIException, IOException, Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertEquals(reviewers.size(), 0);
}
#method_after
@Test
@GerritConfig(name = "suggest.accounts", value = "false")
public void suggestReviewersNoResult1() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertThat(reviewers).isEmpty();
}
#end_block

#method_before
@Test
@GerritConfigs({ @GerritConfig(name = "suggest.accounts", value = "true"), @GerritConfig(name = "suggest.from", value = "1"), @GerritConfig(name = "accounts.visibility", value = "NONE") })
public void suggestReviewersNoResult2() throws GitAPIException, IOException, Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertEquals(reviewers.size(), 0);
}
#method_after
@Test
@GerritConfigs({ @GerritConfig(name = "suggest.accounts", value = "true"), @GerritConfig(name = "suggest.from", value = "1"), @GerritConfig(name = "accounts.visibility", value = "NONE") })
public void suggestReviewersNoResult2() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertThat(reviewers).isEmpty();
}
#end_block

#method_before
@Test
@GerritConfig(name = "suggest.from", value = "2")
public void suggestReviewersNoResult3() throws GitAPIException, IOException, Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertEquals(reviewers.size(), 0);
}
#method_after
@Test
@GerritConfig(name = "suggest.from", value = "2")
public void suggestReviewersNoResult3() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertThat(reviewers).isEmpty();
}
#end_block

#method_before
@Test
public void suggestReviewersChange() throws GitAPIException, IOException, Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertEquals(reviewers.size(), 6);
    reviewers = suggestReviewers(changeId, "u", 5);
    assertEquals(reviewers.size(), 5);
    reviewers = suggestReviewers(changeId, "users3", 10);
    assertEquals(reviewers.size(), 1);
}
#method_after
@Test
public void suggestReviewersChange() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertThat(reviewers).hasSize(6);
    reviewers = suggestReviewers(changeId, "u", 5);
    assertThat(reviewers).hasSize(5);
    reviewers = suggestReviewers(changeId, "users3", 10);
    assertThat(reviewers).hasSize(1);
}
#end_block

#method_before
@Test
@GerritConfig(name = "accounts.visibility", value = "SAME_GROUP")
public void suggestReviewersSameGroupVisibility() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers;
    reviewers = suggestReviewers(changeId, "user2", 2);
    assertEquals(1, reviewers.size());
    assertEquals("User2", Iterables.getOnlyElement(reviewers).account.name);
    reviewers = suggestReviewers(new RestSession(server, user1), changeId, "user2", 2);
    assertTrue(reviewers.isEmpty());
    reviewers = suggestReviewers(new RestSession(server, user2), changeId, "user2", 2);
    assertEquals(1, reviewers.size());
    assertEquals("User2", Iterables.getOnlyElement(reviewers).account.name);
    reviewers = suggestReviewers(new RestSession(server, user3), changeId, "user2", 2);
    assertEquals(1, reviewers.size());
    assertEquals("User2", Iterables.getOnlyElement(reviewers).account.name);
}
#method_after
@Test
@GerritConfig(name = "accounts.visibility", value = "SAME_GROUP")
public void suggestReviewersSameGroupVisibility() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers;
    reviewers = suggestReviewers(changeId, "user2", 2);
    assertThat(reviewers).hasSize(1);
    assertThat(Iterables.getOnlyElement(reviewers).account.name).isEqualTo("User2");
    reviewers = suggestReviewers(new RestSession(server, user1), changeId, "user2", 2);
    assertThat(reviewers).isEmpty();
    reviewers = suggestReviewers(new RestSession(server, user2), changeId, "user2", 2);
    assertThat(reviewers).hasSize(1);
    assertThat(Iterables.getOnlyElement(reviewers).account.name).isEqualTo("User2");
    reviewers = suggestReviewers(new RestSession(server, user3), changeId, "user2", 2);
    assertThat(reviewers).hasSize(1);
    assertThat(Iterables.getOnlyElement(reviewers).account.name).isEqualTo("User2");
}
#end_block

#method_before
@Test
@GerritConfig(name = "accounts.visibility", value = "SAME_GROUP")
public void suggestReviewersViewAllAccounts() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers;
    reviewers = suggestReviewers(new RestSession(server, user1), changeId, "user2", 2);
    assertTrue(reviewers.isEmpty());
    grantCapability(GlobalCapability.VIEW_ALL_ACCOUNTS, group1);
    reviewers = suggestReviewers(new RestSession(server, user1), changeId, "user2", 2);
    assertEquals(1, reviewers.size());
    assertEquals("User2", Iterables.getOnlyElement(reviewers).account.name);
}
#method_after
@Test
@GerritConfig(name = "accounts.visibility", value = "SAME_GROUP")
public void suggestReviewersViewAllAccounts() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers;
    reviewers = suggestReviewers(new RestSession(server, user1), changeId, "user2", 2);
    assertThat(reviewers).isEmpty();
    grantCapability(GlobalCapability.VIEW_ALL_ACCOUNTS, group1);
    reviewers = suggestReviewers(new RestSession(server, user1), changeId, "user2", 2);
    assertThat(reviewers).hasSize(1);
    assertThat(Iterables.getOnlyElement(reviewers).account.name).isEqualTo("User2");
}
#end_block

#method_before
@Test
@GerritConfig(name = "suggest.maxSuggestedReviewers", value = "2")
public void suggestReviewersMaxNbrSuggestions() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "user", 5);
    assertEquals(2, reviewers.size());
}
#method_after
@Test
@GerritConfig(name = "suggest.maxSuggestedReviewers", value = "2")
public void suggestReviewersMaxNbrSuggestions() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "user", 5);
    assertThat(reviewers).hasSize(2);
}
#end_block

#method_before
@Test
@GerritConfig(name = "suggest.fullTextSearch", value = "true")
public void suggestReviewersFullTextSearch() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "ser", 5);
    assertEquals(4, reviewers.size());
}
#method_after
@Test
@GerritConfig(name = "suggest.fullTextSearch", value = "true")
public void suggestReviewersFullTextSearch() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "ser", 5);
    assertThat(reviewers).hasSize(4);
}
#end_block

#method_before
@Test
@GerritConfigs({ @GerritConfig(name = "suggest.fulltextsearch", value = "true"), @GerritConfig(name = "suggest.fullTextSearchMaxMatches", value = "2") })
public void suggestReviewersFullTextSearchLimitMaxMatches() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "ser", 3);
    assertEquals(2, reviewers.size());
}
#method_after
@Test
@GerritConfigs({ @GerritConfig(name = "suggest.fulltextsearch", value = "true"), @GerritConfig(name = "suggest.fullTextSearchMaxMatches", value = "2") })
public void suggestReviewersFullTextSearchLimitMaxMatches() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "ser", 3);
    assertThat(reviewers).hasSize(2);
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> suggestReviewers(String query, int limit) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public SuggestedReviewersRequest suggestReviewers() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> suggestReviewers(String query) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public SuggestedReviewersRequest suggestReviewers(String query) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws BadRequestException, OrmException, IOException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (!suggestAccounts || query.length() < suggestFrom) {
        return Collections.emptyList();
    }
    VisibilityControl visibilityControl = getVisibility(rsrc);
    List<AccountInfo> suggestedAccounts;
    if (useFullTextSearch) {
        suggestedAccounts = suggestAccountFullTextSearch(visibilityControl);
    } else {
        suggestedAccounts = suggestAccount(visibilityControl);
    }
    accountLoaderFactory.create(true).fill(suggestedAccounts);
    List<SuggestedReviewerInfo> reviewer = Lists.newArrayList();
    for (AccountInfo a : suggestedAccounts) {
        SuggestedReviewerInfo info = new SuggestedReviewerInfo();
        info.account = a;
        reviewer.add(info);
    }
    Project p = rsrc.getControl().getProject();
    for (GroupReference g : suggestAccountGroup(rsrc.getControl().getProjectControl())) {
        if (suggestGroupAsReviewer(p, g, visibilityControl)) {
            GroupBaseInfo info = new GroupBaseInfo();
            info.id = Url.encode(g.getUUID().get());
            info.name = g.getName();
            SuggestedReviewerInfo suggestedReviewerInfo = new SuggestedReviewerInfo();
            suggestedReviewerInfo.group = info;
            reviewer.add(suggestedReviewerInfo);
        }
    }
    reviewer = SUGGESTED_REVIEWER_INFO_ORDERING.sortedCopy(reviewer);
    if (reviewer.size() <= limit) {
        return reviewer;
    } else {
        return reviewer.subList(0, limit);
    }
}
#method_after
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws BadRequestException, OrmException, IOException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (!suggestAccounts || query.length() < suggestFrom) {
        return Collections.emptyList();
    }
    VisibilityControl visibilityControl = getVisibility(rsrc);
    List<AccountInfo> suggestedAccounts;
    if (useFullTextSearch) {
        suggestedAccounts = suggestAccountFullTextSearch(visibilityControl);
    } else {
        suggestedAccounts = suggestAccount(visibilityControl);
    }
    List<SuggestedReviewerInfo> reviewer = Lists.newArrayList();
    for (AccountInfo a : suggestedAccounts) {
        SuggestedReviewerInfo info = new SuggestedReviewerInfo();
        info.account = a;
        reviewer.add(info);
    }
    Project p = rsrc.getControl().getProject();
    for (GroupReference g : suggestAccountGroup(rsrc.getControl().getProjectControl())) {
        if (suggestGroupAsReviewer(p, g, visibilityControl)) {
            GroupBaseInfo info = new GroupBaseInfo();
            info.id = Url.encode(g.getUUID().get());
            info.name = g.getName();
            SuggestedReviewerInfo suggestedReviewerInfo = new SuggestedReviewerInfo();
            suggestedReviewerInfo.group = info;
            reviewer.add(suggestedReviewerInfo);
        }
    }
    reviewer = ORDERING.immutableSortedCopy(reviewer);
    if (reviewer.size() <= limit) {
        return reviewer;
    } else {
        return reviewer.subList(0, limit);
    }
}
#end_block

#method_before
private VisibilityControl getVisibility(final ChangeResource rsrc) {
    if (rsrc.getControl().getRefControl().isVisibleByRegisteredUsers()) {
        return new VisibilityControl() {

            @Override
            public boolean isVisibleTo(Account account) throws OrmException {
                return true;
            }
        };
    } else {
        return new VisibilityControl() {

            @Override
            public boolean isVisibleTo(Account account) throws OrmException {
                IdentifiedUser who = identifiedUserFactory.create(dbProvider, account.getId());
                // to drafts
                return rsrc.getControl().forUser(who).isRefVisible();
            }
        };
    }
}
#method_after
private VisibilityControl getVisibility(final ChangeResource rsrc) {
    if (rsrc.getControl().getRefControl().isVisibleByRegisteredUsers()) {
        return new VisibilityControl() {

            @Override
            public boolean isVisibleTo(Account.Id account) throws OrmException {
                return true;
            }
        };
    } else {
        return new VisibilityControl() {

            @Override
            public boolean isVisibleTo(Account.Id account) throws OrmException {
                IdentifiedUser who = identifiedUserFactory.create(dbProvider, account);
                // to drafts
                return rsrc.getControl().forUser(who).isRefVisible();
            }
        };
    }
}
#end_block

#method_before
private List<AccountInfo> suggestAccount(VisibilityControl visibilityControl) throws OrmException {
    String a = query;
    String b = a + MAX_SUFFIX;
    LinkedHashMap<Account.Id, AccountInfo> r = Maps.newLinkedHashMap();
    for (Account p : dbProvider.get().accounts().suggestByFullName(a, b, limit)) {
        addSuggestion(r, p, new AccountInfo(p.getId()), visibilityControl);
    }
    if (r.size() < limit) {
        for (Account p : dbProvider.get().accounts().suggestByPreferredEmail(a, b, limit - r.size())) {
            addSuggestion(r, p, new AccountInfo(p.getId()), visibilityControl);
        }
    }
    if (r.size() < limit) {
        for (AccountExternalId e : dbProvider.get().accountExternalIds().suggestByEmailAddress(a, b, limit - r.size())) {
            if (!r.containsKey(e.getAccountId())) {
                Account p = accountCache.get(e.getAccountId()).getAccount();
                AccountInfo info = new AccountInfo(p.getId());
                addSuggestion(r, p, info, visibilityControl);
            }
        }
    }
    return Lists.newArrayList(r.values());
}
#method_after
private List<AccountInfo> suggestAccount(VisibilityControl visibilityControl) throws OrmException {
    String a = query;
    String b = a + MAX_SUFFIX;
    Map<Account.Id, AccountInfo> r = new LinkedHashMap<>();
    Map<Account.Id, String> queryEmail = new HashMap<>();
    for (Account p : dbProvider.get().accounts().suggestByFullName(a, b, limit)) {
        if (p.isActive()) {
            addSuggestion(r, p.getId(), visibilityControl);
        }
    }
    if (r.size() < limit) {
        for (Account p : dbProvider.get().accounts().suggestByPreferredEmail(a, b, limit - r.size())) {
            if (p.isActive()) {
                addSuggestion(r, p.getId(), visibilityControl);
            }
        }
    }
    if (r.size() < limit) {
        for (AccountExternalId e : dbProvider.get().accountExternalIds().suggestByEmailAddress(a, b, limit - r.size())) {
            if (!r.containsKey(e.getAccountId())) {
                Account p = accountCache.get(e.getAccountId()).getAccount();
                if (p.isActive()) {
                    if (addSuggestion(r, p.getId(), visibilityControl)) {
                        queryEmail.put(e.getAccountId(), e.getEmailAddress());
                    }
                }
            }
        }
    }
    accountLoader.fill();
    for (Map.Entry<Account.Id, String> p : queryEmail.entrySet()) {
        AccountInfo info = r.get(p.getKey());
        if (info != null) {
            info.email = p.getValue();
        }
    }
    return new ArrayList<>(r.values());
}
#end_block

#method_before
private List<AccountInfo> suggestAccountFullTextSearch(VisibilityControl visibilityControl) throws OrmException {
    String str = query.toLowerCase();
    LinkedHashMap<Account.Id, AccountInfo> accountMap = Maps.newLinkedHashMap();
    List<Account> fullNameMatches = Lists.newArrayListWithCapacity(fullTextMaxMatches);
    List<Account> emailMatches = Lists.newArrayListWithCapacity(fullTextMaxMatches);
    for (Account a : reviewerSuggestionCache.get()) {
        if (a.getFullName() != null && a.getFullName().toLowerCase().contains(str)) {
            fullNameMatches.add(a);
        } else if (a.getPreferredEmail() != null && emailMatches.size() < fullTextMaxMatches && a.getPreferredEmail().toLowerCase().contains(str)) {
            emailMatches.add(a);
        }
        if (fullNameMatches.size() >= fullTextMaxMatches) {
            break;
        }
    }
    for (Account a : fullNameMatches) {
        addSuggestion(accountMap, a, new AccountInfo(a.getId()), visibilityControl);
        if (accountMap.size() >= limit) {
            break;
        }
    }
    if (accountMap.size() < limit) {
        for (Account a : emailMatches) {
            addSuggestion(accountMap, a, new AccountInfo(a.getId()), visibilityControl);
            if (accountMap.size() >= limit) {
                break;
            }
        }
    }
    return Lists.newArrayList(accountMap.values());
}
#method_after
private List<AccountInfo> suggestAccountFullTextSearch(VisibilityControl visibilityControl) throws OrmException {
    String str = query.toLowerCase();
    Map<Account.Id, AccountInfo> accountMap = new LinkedHashMap<>();
    List<Account> fullNameMatches = new ArrayList<>(fullTextMaxMatches);
    List<Account> emailMatches = new ArrayList<>(fullTextMaxMatches);
    for (Account a : reviewerSuggestionCache.get()) {
        if (a.getFullName() != null && a.getFullName().toLowerCase().contains(str)) {
            fullNameMatches.add(a);
        } else if (a.getPreferredEmail() != null && emailMatches.size() < fullTextMaxMatches && a.getPreferredEmail().toLowerCase().contains(str)) {
            emailMatches.add(a);
        }
        if (fullNameMatches.size() >= fullTextMaxMatches) {
            break;
        }
    }
    for (Account a : fullNameMatches) {
        addSuggestion(accountMap, a.getId(), visibilityControl);
        if (accountMap.size() >= limit) {
            break;
        }
    }
    if (accountMap.size() < limit) {
        for (Account a : emailMatches) {
            addSuggestion(accountMap, a.getId(), visibilityControl);
            if (accountMap.size() >= limit) {
                break;
            }
        }
    }
    accountLoader.fill();
    return Lists.newArrayList(accountMap.values());
}
#end_block

#method_before
private void addSuggestion(Map<Account.Id, AccountInfo> map, Account account, AccountInfo info, VisibilityControl visibilityControl) throws OrmException {
    if (!map.containsKey(account.getId()) && account.isActive() && // Can the suggestion see the change?
    visibilityControl.isVisibleTo(account) && // Can the account see the current user?
    accountControlFactory.get().canSee(account)) {
        map.put(account.getId(), info);
    }
}
#method_after
private boolean addSuggestion(Map<Account.Id, AccountInfo> map, Account.Id account, VisibilityControl visibilityControl) throws OrmException {
    if (!map.containsKey(account) && // Can the suggestion see the change?
    visibilityControl.isVisibleTo(account) && // Can the account see the current user?
    accountControl.canSee(account)) {
        map.put(account, accountLoader.get(account));
        return true;
    }
    return false;
}
#end_block

#method_before
private boolean suggestGroupAsReviewer(Project project, GroupReference group, VisibilityControl visibilityControl) throws OrmException, IOException {
    if (!PostReviewers.isLegalReviewerGroup(group.getUUID())) {
        return false;
    }
    try {
        Set<Account> members = groupMembersFactory.create(currentUser.get()).listAccounts(group.getUUID(), project.getNameKey());
        if (members.isEmpty()) {
            return false;
        }
        if (maxAllowed > 0 && members.size() > maxAllowed) {
            return false;
        }
        // require that at least one member in the group can see the change
        for (Account account : members) {
            if (visibilityControl.isVisibleTo(account)) {
                return true;
            }
        }
    } catch (NoSuchGroupException e) {
        return false;
    } catch (NoSuchProjectException e) {
        return false;
    }
    return false;
}
#method_after
private boolean suggestGroupAsReviewer(Project project, GroupReference group, VisibilityControl visibilityControl) throws OrmException, IOException {
    if (!PostReviewers.isLegalReviewerGroup(group.getUUID())) {
        return false;
    }
    try {
        Set<Account> members = groupMembersFactory.create(currentUser.get()).listAccounts(group.getUUID(), project.getNameKey());
        if (members.isEmpty()) {
            return false;
        }
        if (maxAllowed > 0 && members.size() > maxAllowed) {
            return false;
        }
        // require that at least one member in the group can see the change
        for (Account account : members) {
            if (visibilityControl.isVisibleTo(account.getId())) {
                return true;
            }
        }
    } catch (NoSuchGroupException e) {
        return false;
    } catch (NoSuchProjectException e) {
        return false;
    }
    return false;
}
#end_block

#method_before
static int optional(final Config config, final String name, int defaultValue) {
    return config.getInt("ldap", name, defaultValue);
}
#method_after
static int optional(Config config, String name, int defaultValue) {
    return config.getInt("ldap", name, defaultValue);
}
#end_block

#method_before
static String optional(final Config config, final String name, final String defaultValue) {
    final String v = optional(config, name);
    if (v == null || "".equals(v)) {
        return defaultValue;
    }
    return v;
}
#method_after
static String optional(Config config, String name, String defaultValue) {
    final String v = optional(config, name);
    if (Strings.isNullOrEmpty(v)) {
        return defaultValue;
    }
    return v;
}
#end_block

#method_before
static boolean optional(final Config config, final String name, final boolean defaultValue) {
    return config.getBoolean("ldap", name, defaultValue);
}
#method_after
static boolean optional(Config config, String name, boolean defaultValue) {
    return config.getBoolean("ldap", name, defaultValue);
}
#end_block

#method_before
DirContext open() throws NamingException, LoginException {
    final Properties env = createContextProperties();
    if (useConnectionPooling) {
        env.put("com.sun.jndi.ldap.connect.pool", String.valueOf(useConnectionPooling));
        if (connectTimeOutMillis != null) {
            env.put("com.sun.jndi.ldap.connect.timeout", connectTimeOutMillis);
        }
        env.put("com.sun.jndi.ldap.connect.pool.authentication", poolAuthentication);
        if (poolDebug != null) {
            env.put("com.sun.jndi.ldap.connect.pool.debug", poolDebug);
        }
        env.put("com.sun.jndi.ldap.connect.pool.initsize", poolInitsize);
        env.put("com.sun.jndi.ldap.connect.pool.maxsize", poolMaxsize);
        env.put("com.sun.jndi.ldap.connect.pool.prefsize", poolPrefsize);
        env.put("com.sun.jndi.ldap.connect.pool.protocol", poolProtocol);
        if (poolTimeoutMillis != null) {
            env.put("com.sun.jndi.ldap.connect.pool.timeout", poolTimeoutMillis);
        }
    }
    env.put(Context.SECURITY_AUTHENTICATION, authentication);
    env.put(Context.REFERRAL, referral);
    if ("GSSAPI".equals(authentication)) {
        return kerberosOpen(env);
    } else {
        if (username != null) {
            env.put(Context.SECURITY_PRINCIPAL, username);
            env.put(Context.SECURITY_CREDENTIALS, password);
        }
        return new InitialDirContext(env);
    }
}
#method_after
DirContext open() throws NamingException, LoginException {
    final Properties env = createContextProperties();
    if (connectionPoolConfig != null) {
        env.putAll(connectionPoolConfig);
    }
    env.put(Context.SECURITY_AUTHENTICATION, authentication);
    env.put(Context.REFERRAL, referral);
    if ("GSSAPI".equals(authentication)) {
        return kerberosOpen(env);
    } else {
        if (username != null) {
            env.put(Context.SECURITY_PRINCIPAL, username);
            env.put(Context.SECURITY_CREDENTIALS, password);
        }
        return new InitialDirContext(env);
    }
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws SQLException, OrmException {
    JdbcSchema schema = (JdbcSchema) db;
    SqlDialect dialect = schema.getDialect();
    String table = "changes";
    try (StatementExecutor e = newExecutor(db)) {
        for (String index : dialect.listIndexes(schema.getConnection(), table)) {
            if (index.startsWith("changes_")) {
                dialect.dropIndex(e, table, index);
            }
        }
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws SQLException, OrmException {
    JdbcSchema schema = (JdbcSchema) db;
    SqlDialect dialect = schema.getDialect();
    Map<String, OrmException> errors = new HashMap<>();
    try (StatementExecutor e = newExecutor(db)) {
        for (String index : listChangesIndexes(schema)) {
            ui.message("Dropping index " + index + " on table " + TABLE);
            try {
                dialect.dropIndex(e, TABLE, index);
            } catch (OrmException err) {
                errors.put(index, err);
            }
        }
    }
    for (String index : listChangesIndexes(schema)) {
        String msg = "Failed to drop index " + index;
        OrmException err = errors.get(index);
        if (err != null) {
            msg += ": " + err.getMessage();
        }
        ui.message(msg);
    }
}
#end_block

#method_before
public Result rm(Git git, String ref) throws GitAPIException, IOException {
    GitUtil.rm(git, fileName);
    return execute(git, ref);
}
#method_after
public Result rm(Git git, String ref) throws GitAPIException {
    GitUtil.rm(git, fileName);
    return execute(git, ref);
}
#end_block

#method_before
private Result execute(Git git, String ref) throws GitAPIException, IOException, ConcurrentRefUpdateException, InvalidTagNameException, NoHeadException {
    Commit c;
    if (changeId != null) {
        c = amendCommit(git, i, subject, changeId);
    } else {
        c = createCommit(git, i, subject);
        changeId = c.getChangeId();
    }
    if (tagName != null) {
        git.tag().setName(tagName).setAnnotated(false).call();
    }
    return new Result(ref, pushHead(git, ref, tagName != null), c, subject);
}
#method_after
private Result execute(Git git, String ref) throws GitAPIException, ConcurrentRefUpdateException, InvalidTagNameException, NoHeadException {
    Commit c;
    if (changeId != null) {
        c = amendCommit(git, i, subject, changeId);
    } else {
        c = createCommit(git, i, subject);
        changeId = c.getChangeId();
    }
    if (tag != null) {
        TagCommand tagCommand = git.tag().setName(tag.name);
        if (tag instanceof AnnotatedTag) {
            AnnotatedTag annotatedTag = (AnnotatedTag) tag;
            tagCommand.setAnnotated(true).setMessage(annotatedTag.message).setTagger(annotatedTag.tagger);
        } else {
            tagCommand.setAnnotated(false);
        }
        tagCommand.call();
    }
    return new Result(ref, pushHead(git, ref, tag != null), c, subject);
}
#end_block

#method_before
public void setTag(final String tagName) {
    this.tagName = tagName;
}
#method_after
public void setTag(final Tag tag) {
    this.tag = tag;
}
#end_block

#method_before
public void assertChange(Change.Status expectedStatus, String expectedTopic, TestAccount... expectedReviewers) throws OrmException {
    Change c = Iterables.getOnlyElement(db.changes().byKey(new Change.Key(commit.getChangeId())).toList());
    assertEquals(subject, c.getSubject());
    assertEquals(expectedStatus, c.getStatus());
    assertEquals(expectedTopic, Strings.emptyToNull(c.getTopic()));
    assertReviewers(c, expectedReviewers);
}
#method_after
public void assertChange(Change.Status expectedStatus, String expectedTopic, TestAccount... expectedReviewers) throws OrmException {
    Change c = Iterables.getOnlyElement(db.changes().byKey(new Change.Key(commit.getChangeId())).toList());
    assertThat(resSubj).isEqualTo(c.getSubject());
    assertThat(expectedStatus).isEqualTo(c.getStatus());
    assertThat(expectedTopic).isEqualTo(Strings.emptyToNull(c.getTopic()));
    assertReviewers(c, expectedReviewers);
}
#end_block

#method_before
private void assertReviewers(Change c, TestAccount... expectedReviewers) throws OrmException {
    Set<Account.Id> expectedReviewerIds = Sets.newHashSet(Lists.transform(Arrays.asList(expectedReviewers), new Function<TestAccount, Account.Id>() {

        @Override
        public Account.Id apply(TestAccount a) {
            return a.id;
        }
    }));
    for (Account.Id accountId : approvalsUtil.getReviewers(db, notesFactory.create(c)).values()) {
        assertTrue("unexpected reviewer " + accountId, expectedReviewerIds.remove(accountId));
    }
    assertTrue("missing reviewers: " + expectedReviewerIds, expectedReviewerIds.isEmpty());
}
#method_after
private void assertReviewers(Change c, TestAccount... expectedReviewers) throws OrmException {
    Set<Account.Id> expectedReviewerIds = Sets.newHashSet(Lists.transform(Arrays.asList(expectedReviewers), new Function<TestAccount, Account.Id>() {

        @Override
        public Account.Id apply(TestAccount a) {
            return a.id;
        }
    }));
    for (Account.Id accountId : approvalsUtil.getReviewers(db, notesFactory.create(c)).values()) {
        assertThat(expectedReviewerIds.remove(accountId)).named("unexpected reviewer " + accountId).isTrue();
    }
    assertThat(expectedReviewerIds.isEmpty()).named("missing reviewers: " + expectedReviewerIds).isTrue();
}
#end_block

#method_before
private void assertStatus(Status expectedStatus, String expectedMessage) {
    RemoteRefUpdate refUpdate = result.getRemoteUpdate(ref);
    assertEquals(message(refUpdate), expectedStatus, refUpdate.getStatus());
    assertEquals(expectedMessage, refUpdate.getMessage());
}
#method_after
private void assertStatus(Status expectedStatus, String expectedMessage) {
    RemoteRefUpdate refUpdate = result.getRemoteUpdate(ref);
    assertThat(expectedStatus).named(message(refUpdate)).isEqualTo(refUpdate.getStatus());
    assertThat(expectedMessage).isEqualTo(refUpdate.getMessage());
}
#end_block

#method_before
public void assertMessage(String expectedMessage) {
    RemoteRefUpdate refUpdate = result.getRemoteUpdate(ref);
    assertTrue(message(refUpdate), message(refUpdate).toLowerCase().contains(expectedMessage.toLowerCase()));
}
#method_after
public void assertMessage(String expectedMessage) {
    RemoteRefUpdate refUpdate = result.getRemoteUpdate(ref);
    assertThat(message(refUpdate).toLowerCase()).named(message(refUpdate)).contains(expectedMessage.toLowerCase());
}
#end_block

#method_before
@Override
public String content() throws RestApiException {
    try {
        BinaryResult bin = getContent.apply(file);
        ByteArrayOutputStream os = new ByteArrayOutputStream();
        bin.writeTo(os);
        return new String(os.toByteArray(), Charsets.UTF_8);
    } catch (IOException e) {
        throw new RestApiException("Cannot retrieve file content", e);
    }
}
#method_after
@Override
public BinaryResult content() throws RestApiException {
    try {
        return getContent.apply(file);
    } catch (NoSuchChangeException | IOException | OrmException e) {
        throw new RestApiException("Cannot retrieve file content", e);
    }
}
#end_block

#method_before
@Override
public DiffInfo diff() throws RestApiException {
    try {
        return gtDiff.get().apply(file).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve diff", e);
    }
}
#method_after
@Override
public DiffInfo diff() throws RestApiException {
    try {
        return getDiff.get().apply(file).value();
    } catch (IOException | InvalidChangeOperationException | OrmException e) {
        throw new RestApiException("Cannot retrieve diff", e);
    }
}
#end_block

#method_before
@Override
public DiffInfo diff(String base) throws RestApiException {
    try {
        return gtDiff.get().setBase(base).apply(file).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve diff", e);
    }
}
#method_after
@Override
public DiffInfo diff(String base) throws RestApiException {
    try {
        return getDiff.get().setBase(base).apply(file).value();
    } catch (IOException | InvalidChangeOperationException | OrmException e) {
        throw new RestApiException("Cannot retrieve diff", e);
    }
}
#end_block

#method_before
@Override
public Response<DiffInfo> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException {
    PatchSet.Id basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet().getId();
    }
    AccountDiffPreference prefs = new AccountDiffPreference(new Account.Id(0));
    prefs.setIgnoreWhitespace(ignoreWhitespace.whitespace);
    prefs.setContext(context);
    prefs.setIntralineDifference(intraline);
    try {
        PatchScriptFactory psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet, resource.getPatchKey().getParentKey(), prefs);
        psf.setLoadHistory(false);
        psf.setLoadComments(context != AccountDiffPreference.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %d; want %d", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %d; want %d", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        DiffInfo result = new DiffInfo();
        if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
            result.metaA = new FileMeta();
            result.metaA.name = Objects.firstNonNull(ps.getOldName(), ps.getNewName());
            setContentType(result.metaA, state, ps.getFileModeA(), ps.getMimeTypeA());
            result.metaA.lines = ps.getA().size();
        }
        if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
            result.metaB = new FileMeta();
            result.metaB.name = ps.getNewName();
            setContentType(result.metaB, state, ps.getFileModeB(), ps.getMimeTypeB());
            result.metaB.lines = ps.getB().size();
        }
        if (intraline) {
            if (ps.hasIntralineTimeout()) {
                result.intralineStatus = IntraLineStatus.TIMEOUT;
            } else if (ps.hasIntralineFailure()) {
                result.intralineStatus = IntraLineStatus.FAILURE;
            } else {
                result.intralineStatus = IntraLineStatus.OK;
            }
        }
        result.changeType = ps.getChangeType();
        if (ps.getPatchHeader().size() > 0) {
            result.diffHeader = ps.getPatchHeader();
        }
        result.content = content.lines;
        Response<DiffInfo> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
@Override
public Response<DiffInfo> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException, AuthException, InvalidChangeOperationException, IOException {
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
    }
    AccountDiffPreference prefs = new AccountDiffPreference(new Account.Id(0));
    prefs.setIgnoreWhitespace(ignoreWhitespace.whitespace);
    prefs.setContext(context);
    prefs.setIntralineDifference(intraline);
    try {
        PatchScriptFactory psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet != null ? basePatchSet.getId() : null, resource.getPatchKey().getParentKey(), prefs);
        psf.setLoadHistory(false);
        psf.setLoadComments(context != AccountDiffPreference.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %s; want %s", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %s; want %s", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        DiffInfo result = new DiffInfo();
        // TODO referring to the parent commit by refs/changes/12/60012/1^1
        // will likely not work for inline edits
        String revA = basePatchSet != null ? basePatchSet.getRefName() : resource.getRevision().getPatchSet().getRefName() + "^1";
        String revB = resource.getRevision().getEdit().isPresent() ? resource.getRevision().getEdit().get().getRefName() : resource.getRevision().getPatchSet().getRefName();
        FluentIterable<DiffWebLinkInfo> links = webLinks.getDiffLinks(state.getProject().getName(), resource.getPatchKey().getParentKey().getParentKey().get(), basePatchSet != null ? basePatchSet.getId().get() : null, revA, MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName()), resource.getPatchKey().getParentKey().get(), revB, ps.getNewName());
        result.webLinks = links.isEmpty() ? null : links.toList();
        if (!webLinksOnly) {
            if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
                result.metaA = new FileMeta();
                result.metaA.name = MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName());
                result.metaA.contentType = FileContentUtil.resolveContentType(state, result.metaA.name, ps.getFileModeA(), ps.getMimeTypeA());
                result.metaA.lines = ps.getA().size();
                result.metaA.webLinks = getFileWebLinks(state.getProject(), revA, result.metaA.name);
            }
            if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
                result.metaB = new FileMeta();
                result.metaB.name = ps.getNewName();
                result.metaB.contentType = FileContentUtil.resolveContentType(state, result.metaB.name, ps.getFileModeB(), ps.getMimeTypeB());
                result.metaB.lines = ps.getB().size();
                result.metaB.webLinks = getFileWebLinks(state.getProject(), revB, result.metaB.name);
            }
            if (intraline) {
                if (ps.hasIntralineTimeout()) {
                    result.intralineStatus = IntraLineStatus.TIMEOUT;
                } else if (ps.hasIntralineFailure()) {
                    result.intralineStatus = IntraLineStatus.FAILURE;
                } else {
                    result.intralineStatus = IntraLineStatus.OK;
                }
            }
            result.changeType = CHANGE_TYPE.get(ps.getChangeType());
            if (result.changeType == null) {
                throw new IllegalStateException("unknown change type: " + ps.getChangeType());
            }
            if (ps.getPatchHeader().size() > 0) {
                result.diffHeader = ps.getPatchHeader();
            }
            result.content = content.lines;
        }
        Response<DiffInfo> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
@Test
public void reviewTriplet() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
}
#method_after
@Test
public void reviewTriplet() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
}
#end_block

#method_before
@Test
public void reviewCurrent() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).current().review(ReviewInput.approve());
}
#method_after
@Test
public void reviewCurrent() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).current().review(ReviewInput.approve());
}
#end_block

#method_before
@Test
public void reviewNumber() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(1).review(ReviewInput.approve());
    r = updateChange(r, "new content");
    gApi.changes().id(r.getChangeId()).revision(2).review(ReviewInput.approve());
}
#method_after
@Test
public void reviewNumber() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(1).review(ReviewInput.approve());
    r = updateChange(r, "new content");
    gApi.changes().id(r.getChangeId()).revision(2).review(ReviewInput.approve());
}
#end_block

#method_before
@Test
public void submit() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(ReviewInput.approve());
    gApi.changes().id("p~master~" + r.getChangeId()).current().submit();
}
#method_after
@Test
public void submit() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(ReviewInput.approve());
    gApi.changes().id("p~master~" + r.getChangeId()).current().submit();
}
#end_block

#method_before
@Test(expected = AuthException.class)
public void submitOnBehalfOf() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(ReviewInput.approve());
    SubmitInput in = new SubmitInput();
    in.onBehalfOf = admin2.email;
    in.waitForMerge = true;
    gApi.changes().id("p~master~" + r.getChangeId()).current().submit(in);
}
#method_after
@Test(expected = AuthException.class)
public void submitOnBehalfOf() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(ReviewInput.approve());
    SubmitInput in = new SubmitInput();
    in.onBehalfOf = admin2.email;
    in.waitForMerge = true;
    gApi.changes().id("p~master~" + r.getChangeId()).current().submit(in);
}
#end_block

#method_before
@Test
public void deleteDraft() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createDraft();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).delete();
}
#method_after
@Test
public void deleteDraft() throws Exception {
    PushOneCommit.Result r = createDraft();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).delete();
}
#end_block

#method_before
@Test
public void cherryPick() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = "it goes to stable branch";
    gApi.projects().name(project.get()).branch(in.destination).create(new BranchInput());
    ChangeApi cApi = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).cherryPick(in);
    cApi.current().review(ReviewInput.approve());
    cApi.current().submit();
}
#method_after
@Test
public void cherryPick() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master%topic=someTopic");
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = "it goes to stable branch";
    gApi.projects().name(project.get()).branch(in.destination).create(new BranchInput());
    ChangeApi orig = gApi.changes().id("p~master~" + r.getChangeId());
    assertThat((Iterable<?>) orig.get().messages).hasSize(1);
    ChangeApi cherry = orig.revision(r.getCommit().name()).cherryPick(in);
    assertThat((Iterable<?>) orig.get().messages).hasSize(2);
    assertThat(cherry.get().subject).contains(in.message);
    assertThat(cherry.get().topic).isEqualTo("someTopic");
    cherry.current().review(ReviewInput.approve());
    cherry.current().submit();
}
#end_block

#method_before
@Test
public void canRebase() throws GitAPIException, IOException, RestApiException, Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent());
    PushOneCommit.Result r1 = push.to(git, "refs/for/master");
    merge(r1);
    push = pushFactory.create(db, admin.getIdent());
    PushOneCommit.Result r2 = push.to(git, "refs/for/master");
    assertFalse(gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).canRebase());
    merge(r2);
    git.checkout().setName(r1.getCommit().name()).call();
    push = pushFactory.create(db, admin.getIdent());
    PushOneCommit.Result r3 = push.to(git, "refs/for/master");
    assertTrue(gApi.changes().id(r3.getChangeId()).revision(r3.getCommit().name()).canRebase());
}
#method_after
@Test
public void canRebase() throws Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent());
    PushOneCommit.Result r1 = push.to(git, "refs/for/master");
    merge(r1);
    push = pushFactory.create(db, admin.getIdent());
    PushOneCommit.Result r2 = push.to(git, "refs/for/master");
    boolean canRebase = gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).canRebase();
    assertThat(canRebase).isFalse();
    merge(r2);
    git.checkout().setName(r1.getCommit().name()).call();
    push = pushFactory.create(db, admin.getIdent());
    PushOneCommit.Result r3 = push.to(git, "refs/for/master");
    canRebase = gApi.changes().id(r3.getChangeId()).revision(r3.getCommit().name()).canRebase();
    assertThat(canRebase).isTrue();
}
#end_block

#method_before
@Test
public void files() throws Exception {
    PushOneCommit.Result r = createChange();
    assertTrue(Iterables.all(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).files().keySet(), new Predicate<String>() {

        @Override
        public boolean apply(String file) {
            return file.matches(FILE_NAME + '|' + Patch.COMMIT_MSG);
        }
    }));
}
#method_after
@Test
public void files() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(Iterables.all(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).files().keySet(), new Predicate<String>() {

        @Override
        public boolean apply(String file) {
            return file.matches(FILE_NAME + '|' + Patch.COMMIT_MSG);
        }
    })).isTrue();
}
#end_block

#method_before
@Test
public void diff() throws Exception {
    PushOneCommit.Result r = createChange();
    DiffInfo diff = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).file(FILE_NAME).diff();
    assertNull(diff.metaA);
    assertTrue(diff.metaB.lines == 1);
}
#method_after
@Test
public void diff() throws Exception {
    PushOneCommit.Result r = createChange();
    DiffInfo diff = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).file(FILE_NAME).diff();
    assertThat(diff.metaA).isNull();
    assertThat(diff.metaB.lines).isEqualTo(1);
}
#end_block

#method_before
@Test
public void content() throws Exception {
    PushOneCommit.Result r = createChange();
    assertEquals(FILE_CONTENT, gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).file(FILE_NAME).content());
}
#method_after
@Test
public void content() throws Exception {
    PushOneCommit.Result r = createChange();
    BinaryResult bin = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).file(FILE_NAME).content();
    ByteArrayOutputStream os = new ByteArrayOutputStream();
    bin.writeTo(os);
    String res = new String(os.toByteArray(), StandardCharsets.UTF_8);
    assertThat(res).isEqualTo(FILE_CONTENT);
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public Map<String, FileInfo> files() throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.get().apply(revision).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve files", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files() throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.get().apply(revision).value();
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve files", e);
    }
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public Map<String, FileInfo> files(String base) throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.get().setBase(base).apply(revision).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve files", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files(String base) throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.get().setBase(base).apply(revision).value();
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve files", e);
    }
}
#end_block

#method_before
@Override
public FileApi file(String path) throws RestApiException {
    try {
        return fileApi.create(files.get().parse(revision, IdString.fromDecoded(path)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot cherry pick", e);
    }
}
#method_after
@Override
public FileApi file(String path) {
    return fileApi.create(files.get().parse(revision, IdString.fromDecoded(path)));
}
#end_block

#method_before
@Override
public FileResource parse(RevisionResource rev, IdString id) throws ResourceNotFoundException, OrmException, AuthException {
    return new FileResource(rev, id.get());
}
#method_after
@Override
public FileResource parse(RevisionResource rev, IdString id) {
    return new FileResource(rev, id.get());
}
#end_block

#method_before
@Override
public Response<?> apply(RevisionResource resource) throws AuthException, BadRequestException, ResourceNotFoundException, OrmException {
    if (base != null && reviewed) {
        throw new BadRequestException("cannot combine base and reviewed");
    } else if (reviewed) {
        return Response.ok(reviewed(resource));
    }
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
    }
    try {
        Response<Map<String, FileInfo>> r = Response.ok(fileInfoJson.toFileInfoMap(resource.getChange(), resource.getPatchSet(), basePatchSet));
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (PatchListNotAvailableException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
}
#method_after
@Override
public Response<?> apply(RevisionResource resource) throws AuthException, BadRequestException, ResourceNotFoundException, OrmException, RepositoryNotFoundException, IOException {
    checkOptions();
    if (reviewed) {
        return Response.ok(reviewed(resource));
    } else if (query != null) {
        return Response.ok(query(resource));
    }
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
    }
    try {
        Response<Map<String, FileInfo>> r = Response.ok(fileInfoJson.toFileInfoMap(resource.getChange(), resource.getPatchSet().getRevision(), basePatchSet));
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (PatchListNotAvailableException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public String content() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public BinaryResult content() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public DiffInfo diff(String diffBaseRevisionId) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public DiffInfo diff(String base) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, FileInfo> files() {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, FileInfo> files(String base) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, FileInfo> files() {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, FileInfo> files() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public FileApi file(String filePath) {
    throw new NotImplementedException();
}
#method_after
@Override
public FileApi file(String path) {
    throw new NotImplementedException();
}
#end_block

#method_before
List<PermissionRule> getOverridden(String permissionName) {
    List<PermissionRule> r = overridden.get(permissionName);
    return r != null ? r : Collections.<PermissionRule>emptyList();
}
#method_after
List<PermissionRule> getOverridden(String permissionName) {
    return firstNonNull(overridden.get(permissionName), Collections.<PermissionRule>emptyList());
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group1 = new CallbackGroup();
    final CallbackGroup group2 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group2.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.detail(revision.getParentKey().get(), group1.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo c) {
            project.setInnerText(c.project());
            SafeHtml.setInnerHTML(filePath, Header.formatPath(path, null, null));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ChangeEditApi.get(revision, path, new HttpCallback<NativeString>() {

        final AsyncCallback<Void> modeCallback = group2.addEmpty();

        @Override
        public void onSuccess(HttpResponse<NativeString> fc) {
            content = fc;
            if (prefs.syntaxHighlighting()) {
                injectMode(fc.getContentType(), modeCallback);
            } else {
                modeCallback.onSuccess(null);
            }
        }

        @Override
        public void onFailure(Throwable e) {
            // "Not Found" means it's a new file.
            if (RestApi.isNotFound(e)) {
                content = null;
                modeCallback.onSuccess(null);
            } else {
                GerritCallback.showFailure(e);
            }
        }
    });
    group2.addListener(new ScreenLoadCallback<Void>(this) {

        @Override
        protected void preDisplay(Void result) {
            initEditor(content);
            content = null;
        }
    });
    group1.done();
    group2.done();
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group1 = new CallbackGroup();
    CallbackGroup group2 = new CallbackGroup();
    final CallbackGroup group3 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group3.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.detail(revision.getParentKey().get(), group1.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo c) {
            project.setInnerText(c.project());
            SafeHtml.setInnerHTML(filePath, Header.formatPath(path, null, null));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ChangeEditApi.get(revision, path, group2.add(new HttpCallback<NativeString>() {

        final AsyncCallback<Void> modeCallback = group3.addEmpty();

        @Override
        public void onSuccess(HttpResponse<NativeString> fc) {
            content = fc;
            if (prefs.syntaxHighlighting()) {
                injectMode(fc.getContentType(), modeCallback);
            } else {
                modeCallback.onSuccess(null);
            }
        }

        @Override
        public void onFailure(Throwable e) {
            // "Not Found" means it's a new file.
            if (RestApi.isNotFound(e)) {
                content = null;
                modeCallback.onSuccess(null);
            } else {
                GerritCallback.showFailure(e);
            }
        }
    }));
    group3.addListener(new ScreenLoadCallback<Void>(this) {

        @Override
        protected void preDisplay(Void result) {
            initEditor(content);
            content = null;
        }
    });
    group1.done();
    group2.done();
    group3.done();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setHeaderVisible(false);
    Resources.I.style().ensureInjected();
    star.setVisible(Gerrit.isSignedIn());
    labels.init(style);
    reviewers.init(style, ccText);
    hashtags.init(style);
    initReplyButton();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                star.setValue(!star.getValue(), true);
            }
        });
        keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                reviewers.onOpenForm();
            }
        });
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setHeaderVisible(false);
    Resources.I.style().ensureInjected();
    star.setVisible(Gerrit.isSignedIn());
    labels.init(style);
    reviewers.init(style, ccText);
    hashtags.init(style);
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                star.setValue(!star.getValue(), true);
            }
        });
        keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                reviewers.onOpenForm();
            }
        });
    }
}
#end_block

#method_before
private void initReplyButton() {
    reply.setTitle(Gerrit.getConfig().getReplyTitle());
    reply.setHTML(new SafeHtmlBuilder().openDiv().append(Gerrit.getConfig().getReplyLabel()).closeDiv());
}
#method_after
private void initReplyButton(ChangeInfo info, String revision) {
    if (!info.revision(revision).is_edit()) {
        reply.setTitle(Gerrit.getConfig().getReplyTitle());
        reply.setHTML(new SafeHtmlBuilder().openDiv().append(Gerrit.getConfig().getReplyLabel()).closeDiv());
        reply.setVisible(true);
    }
}
#end_block

#method_before
private void initEditMode(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            reply.setVisible(editMode.isVisible());
            addFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            reply.setVisible(true);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
    }
}
#method_after
private void initEditMode(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
    }
}
#end_block

#method_before
@UiHandler("editMode")
void onEditMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.EDIT;
    refreshFileTable();
    editMode.setVisible(false);
    reply.setVisible(false);
    addFile.setVisible(true);
    reviewMode.setVisible(true);
}
#method_after
@UiHandler("editMode")
void onEditMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.EDIT;
    refreshFileTable();
    editMode.setVisible(false);
    addFile.setVisible(true);
    reviewMode.setVisible(true);
}
#end_block

#method_before
@UiHandler("reviewMode")
void onReviewMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.REVIEW;
    refreshFileTable();
    editMode.setVisible(true);
    reply.setVisible(true);
    addFile.setVisible(false);
    reviewMode.setVisible(false);
}
#method_after
@UiHandler("reviewMode")
void onReviewMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.REVIEW;
    refreshFileTable();
    editMode.setVisible(true);
    addFile.setVisible(false);
    reviewMode.setVisible(false);
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
public void onEdit() {
    if (popup != null) {
        popup.hide();
        return;
    }
    if (addBox == null) {
        addBox = new AddFileBox(changeId, revision);
    }
    final PluginSafePopupPanel p = new PluginSafePopupPanel(true);
    p.setStyleName(style.replyBox());
    p.addAutoHidePartner(addButton.getElement());
    p.addCloseHandler(new CloseHandler<PopupPanel>() {

        @Override
        public void onClose(CloseEvent<PopupPanel> event) {
            if (popup == p) {
                popup = null;
            }
        }
    });
    p.add(addBox);
    p.showRelativeTo(addButton);
    GlobalKey.dialog(p);
    addBox.setFocus(true);
    popup = p;
}
#method_after
public void onEdit() {
    if (popup != null) {
        popup.hide();
        return;
    }
    if (addBox == null) {
        addBox = new AddFileBox(changeId, revision);
    }
    addBox.clearPath();
    final PluginSafePopupPanel p = new PluginSafePopupPanel(true);
    p.setStyleName(style.replyBox());
    p.addAutoHidePartner(addButton.getElement());
    p.addCloseHandler(new CloseHandler<PopupPanel>() {

        @Override
        public void onClose(CloseEvent<PopupPanel> event) {
            if (popup == p) {
                popup = null;
            }
        }
    });
    p.add(addBox);
    p.showRelativeTo(addButton);
    GlobalKey.dialog(p);
    addBox.setFocus(true);
    popup = p;
}
#end_block

#method_before
@UiHandler("open")
void onOpen(@SuppressWarnings("unused") ClickEvent e) {
    hide();
    Gerrit.display(Dispatcher.toEditScreen(new PatchSet.Id(changeId, revision._number()), path.getText()));
}
#method_after
@UiHandler("open")
void onOpen(@SuppressWarnings("unused") ClickEvent e) {
    open(path.getText());
}
#end_block

#method_before
@UiHandler("cancel")
void onCancel(@SuppressWarnings("unused") ClickEvent e) {
    path.setText("");
    hide();
}
#method_after
@UiHandler("cancel")
void onCancel(@SuppressWarnings("unused") ClickEvent e) {
    hide();
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    JdbcSchema schema = (JdbcSchema) db;
    SqlDialect dialect = schema.getDialect();
    try (Statement stmt = schema.getConnection().createStatement()) {
        // Drop left over indexes that were missed to be removed in schema 84.
        // See "Delete SQL index support" commit for more details:
        // d4ae3a16d5e1464574bd04f429a63eb9c02b3b43
        Set<String> listIndexes = dialect.listIndexes(schema.getConnection(), "changes");
        for (String index : listIndexes) {
            if (index.equalsIgnoreCase("changes_allOpen")) {
                stmt.executeUpdate("DROP INDEX " + index);
            }
            if (index.equalsIgnoreCase("changes_allClosed")) {
                stmt.executeUpdate("DROP INDEX " + index);
            }
            if (index.equalsIgnoreCase("changes_byBranchClosed")) {
                stmt.executeUpdate("DROP INDEX " + index);
            }
        }
        stmt.executeUpdate("DROP INDEX changes_byProjectOpen");
        if (dialect instanceof DialectPostgreSQL) {
            stmt.executeUpdate("CREATE INDEX changes_byProjectOpen" + " ON changes (dest_project_name, last_updated_on)" + " WHERE open = 'Y'");
        } else {
            stmt.executeUpdate("CREATE INDEX changes_byProjectOpen" + " ON changes (open, dest_project_name, last_updated_on)");
        }
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    JdbcSchema schema = (JdbcSchema) db;
    SqlDialect dialect = schema.getDialect();
    try (Statement stmt = schema.getConnection().createStatement()) {
        // Drop left over indexes that were missed to be removed in schema 84.
        // See "Delete SQL index support" commit for more details:
        // d4ae3a16d5e1464574bd04f429a63eb9c02b3b43
        Pattern pattern = Pattern.compile("^changes_(allOpen|allClosed|byBranchClosed)$", Pattern.CASE_INSENSITIVE);
        Set<String> listIndexes = dialect.listIndexes(schema.getConnection(), "changes");
        for (String index : listIndexes) {
            if (pattern.matcher(index).matches()) {
                stmt.executeUpdate("DROP INDEX " + index);
            }
        }
        stmt.executeUpdate("DROP INDEX changes_byProjectOpen");
        if (dialect instanceof DialectPostgreSQL) {
            stmt.executeUpdate("CREATE INDEX changes_byProjectOpen" + " ON changes (dest_project_name, last_updated_on)" + " WHERE open = 'Y'");
        } else {
            stmt.executeUpdate("CREATE INDEX changes_byProjectOpen" + " ON changes (open, dest_project_name, last_updated_on)");
        }
    }
}
#end_block

#method_before
void save(CallbackGroup group) {
    if (pendingGroup != null) {
        pendingGroup.addListener(group);
        return;
    }
    String message = editArea.getValue().trim();
    if (message.length() == 0) {
        return;
    }
    CommentInfo input = CommentInfo.copy(comment);
    input.message(message);
    enableEdit(false);
    pendingGroup = group;
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            enableEdit(true);
            pendingGroup = null;
            set(result);
            setEdit(false);
            if (autoClosed) {
                setOpen(false);
            }
            getCommentManager().setUnsaved(DraftBox.this, false);
        }

        @Override
        public void onFailure(Throwable e) {
            enableEdit(true);
            pendingGroup = null;
            super.onFailure(e);
        }
    };
    if (input.id() == null) {
        CommentApi.createDraft(psId, input, group.add(cb));
    } else {
        CommentApi.updateDraft(psId, input.id(), input, group.add(cb));
    }
    CodeMirror cm = getCm();
    cm.setOption("keyMap", "vim_ro");
    cm.focus();
}
#method_after
void save(CallbackGroup group) {
    if (pendingGroup != null) {
        pendingGroup.addListener(group);
        return;
    }
    String message = editArea.getValue().trim();
    if (message.length() == 0) {
        return;
    }
    CommentInfo input = CommentInfo.copy(comment);
    input.message(message);
    enableEdit(false);
    pendingGroup = group;
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            enableEdit(true);
            pendingGroup = null;
            set(result);
            setEdit(false);
            if (autoClosed) {
                setOpen(false);
            }
            getCommentManager().setUnsaved(DraftBox.this, false);
        }

        @Override
        public void onFailure(Throwable e) {
            enableEdit(true);
            pendingGroup = null;
            super.onFailure(e);
        }
    };
    if (input.id() == null) {
        CommentApi.createDraft(psId, input, group.add(cb));
    } else {
        CommentApi.updateDraft(psId, input.id(), input, group.add(cb));
    }
    CodeMirror cm = getCm();
    cm.vim().handleKey("<Esc>");
    cm.focus();
}
#end_block

#method_before
private List<AccountInfo> suggestAccount(VisibilityControl visibilityControl) throws OrmException {
    String a = query;
    String b = a + MAX_SUFFIX;
    Map<Account.Id, AccountInfo> r = new LinkedHashMap<>();
    Map<Account.Id, String> queryEmail = new HashMap<>();
    for (Account p : dbProvider.get().accounts().suggestByFullName(a, b, limit)) {
        if (p.isActive()) {
            addSuggestion(r, p.getId(), visibilityControl);
        }
    }
    if (r.size() < limit) {
        for (Account p : dbProvider.get().accounts().suggestByPreferredEmail(a, b, limit - r.size())) {
            if (p.isActive()) {
                addSuggestion(r, p.getId(), visibilityControl);
            }
        }
    }
    if (r.size() < limit) {
        for (AccountExternalId e : dbProvider.get().accountExternalIds().suggestByEmailAddress(a, b, limit - r.size())) {
            if (!r.containsKey(e.getAccountId())) {
                Account p = accountCache.get(e.getAccountId()).getAccount();
                if (p.isActive()) {
                    queryEmail.put(e.getAccountId(), e.getEmailAddress());
                    addSuggestion(r, p.getId(), visibilityControl);
                }
            }
        }
    }
    accountLoader.fill();
    for (Map.Entry<Account.Id, String> p : queryEmail.entrySet()) {
        r.get(p.getKey()).email = p.getValue();
    }
    return Lists.newArrayList(r.values());
}
#method_after
private List<AccountInfo> suggestAccount(VisibilityControl visibilityControl) throws OrmException {
    String a = query;
    String b = a + MAX_SUFFIX;
    Map<Account.Id, AccountInfo> r = new LinkedHashMap<>();
    Map<Account.Id, String> queryEmail = new HashMap<>();
    for (Account p : dbProvider.get().accounts().suggestByFullName(a, b, limit)) {
        if (p.isActive()) {
            addSuggestion(r, p.getId(), visibilityControl);
        }
    }
    if (r.size() < limit) {
        for (Account p : dbProvider.get().accounts().suggestByPreferredEmail(a, b, limit - r.size())) {
            if (p.isActive()) {
                addSuggestion(r, p.getId(), visibilityControl);
            }
        }
    }
    if (r.size() < limit) {
        for (AccountExternalId e : dbProvider.get().accountExternalIds().suggestByEmailAddress(a, b, limit - r.size())) {
            if (!r.containsKey(e.getAccountId())) {
                Account p = accountCache.get(e.getAccountId()).getAccount();
                if (p.isActive()) {
                    if (addSuggestion(r, p.getId(), visibilityControl)) {
                        queryEmail.put(e.getAccountId(), e.getEmailAddress());
                    }
                }
            }
        }
    }
    accountLoader.fill();
    for (Map.Entry<Account.Id, String> p : queryEmail.entrySet()) {
        AccountInfo info = r.get(p.getKey());
        if (info != null) {
            info.email = p.getValue();
        }
    }
    return new ArrayList<>(r.values());
}
#end_block

#method_before
private void addSuggestion(Map<Account.Id, AccountInfo> map, Account.Id account, VisibilityControl visibilityControl) throws OrmException {
    if (!map.containsKey(account) && // Can the suggestion see the change?
    visibilityControl.isVisibleTo(account) && // Can the account see the current user?
    accountControl.canSee(account)) {
        map.put(account, accountLoader.get(account));
    }
}
#method_after
private boolean addSuggestion(Map<Account.Id, AccountInfo> map, Account.Id account, VisibilityControl visibilityControl) throws OrmException {
    if (!map.containsKey(account) && // Can the suggestion see the change?
    visibilityControl.isVisibleTo(account) && // Can the account see the current user?
    accountControl.canSee(account)) {
        map.put(account, accountLoader.get(account));
        return true;
    }
    return false;
}
#end_block

#method_before
public final Change.Status status() {
    return Change.Status.valueOf(statusRaw());
}
#method_after
public final Change.Status status() {
    String s = statusRaw();
    return s != null ? Change.Status.valueOf(s) : null;
}
#end_block

#method_before
public static Config newDefaultConfig() {
    Config cfg = new Config();
    cfg.setEnum("auth", null, "type", AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT);
    cfg.setString("gerrit", null, "basePath", "git");
    cfg.setString("gerrit", null, "allProjects", "Test-Projects");
    cfg.setString("user", null, "name", "Gerrit Code Review");
    cfg.setString("user", null, "email", "gerrit@localhost");
    cfg.setBoolean("sendemail", null, "enable", false);
    cfg.setString("cache", null, "directory", null);
    return cfg;
}
#method_after
public static Config newDefaultConfig() {
    Config cfg = new Config();
    cfg.setEnum("auth", null, "type", AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT);
    cfg.setString("gerrit", null, "basePath", "git");
    cfg.setString("gerrit", null, "allProjects", "Test-Projects");
    cfg.setString("user", null, "name", "Gerrit Code Review");
    cfg.setString("user", null, "email", "gerrit@localhost");
    cfg.setBoolean("sendemail", null, "enable", false);
    cfg.setString("cache", null, "directory", null);
    cfg.setString("index", null, "type", "lucene");
    cfg.setBoolean("index", "lucene", "testInmemory", true);
    cfg.setInt("index", "lucene", "testVersion", 4);
    return cfg;
}
#end_block

#method_before
@Override
protected void configure() {
    // For simplicity, don't create child injectors, just use this one to get a
    // few required modules.
    Injector cfgInjector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
        }
    });
    install(cfgInjector.getInstance(GerritGlobalModule.class));
    bindScope(RequestScoped.class, PerThreadRequestScope.REQUEST);
    install(new SchemaVersion.Module());
    bind(File.class).annotatedWith(SitePath.class).toInstance(new File("."));
    bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
    try {
        bind(SocketAddress.class).annotatedWith(RemotePeer.class).toInstance(new InetSocketAddress(InetAddress.getLocalHost(), 1234));
    } catch (UnknownHostException e) {
        throw newProvisionException(e);
    }
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
    bind(AllProjectsName.class).toProvider(AllProjectsNameProvider.class);
    bind(GitRepositoryManager.class).to(InMemoryRepositoryManager.class);
    bind(InMemoryRepositoryManager.class).in(SINGLETON);
    bind(TrackingFooters.class).toProvider(TrackingFootersProvider.class).in(SINGLETON);
    bind(DataSourceType.class).to(InMemoryH2Type.class);
    bind(new TypeLiteral<SchemaFactory<ReviewDb>>() {
    }).to(InMemoryDatabase.class);
    bind(ChangeHooks.class).to(DisabledChangeHooks.class);
    install(NoSshKeyCache.module());
    install(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    install(new DefaultCacheFactory.Module());
    install(new SmtpEmailSender.Module());
    install(new SignedTokenEmailTokenVerifier.Module());
    install(new MergeabilityChecksExecutorModule());
    IndexType indexType = null;
    try {
        indexType = cfg.getEnum("index", null, "type", IndexType.LUCENE);
    } catch (IllegalArgumentException e) {
    // Custom index type, caller must provide their own module.
    }
    if (indexType != null) {
        switch(indexType) {
            case LUCENE:
                install(luceneIndexModule());
                break;
            default:
                throw new ProvisionException("index type unsupported in tests: " + indexType);
        }
    }
}
#method_after
@Override
protected void configure() {
    // For simplicity, don't create child injectors, just use this one to get a
    // few required modules.
    Injector cfgInjector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
        }
    });
    install(cfgInjector.getInstance(GerritGlobalModule.class));
    bindScope(RequestScoped.class, PerThreadRequestScope.REQUEST);
    install(new SchemaVersion.Module());
    bind(File.class).annotatedWith(SitePath.class).toInstance(new File("."));
    bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
    bind(SocketAddress.class).annotatedWith(RemotePeer.class).toInstance(new InetSocketAddress(InetAddresses.forString("127.0.0.1"), 1234));
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
    bind(AllProjectsName.class).toProvider(AllProjectsNameProvider.class);
    bind(GitRepositoryManager.class).to(InMemoryRepositoryManager.class);
    bind(InMemoryRepositoryManager.class).in(SINGLETON);
    bind(TrackingFooters.class).toProvider(TrackingFootersProvider.class).in(SINGLETON);
    bind(DataSourceType.class).to(InMemoryH2Type.class);
    bind(new TypeLiteral<SchemaFactory<ReviewDb>>() {
    }).to(InMemoryDatabase.class);
    bind(ChangeHooks.class).to(DisabledChangeHooks.class);
    install(NoSshKeyCache.module());
    install(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    install(new DefaultCacheFactory.Module());
    install(new SmtpEmailSender.Module());
    install(new SignedTokenEmailTokenVerifier.Module());
    install(new MergeabilityChecksExecutorModule());
    IndexType indexType = null;
    try {
        indexType = cfg.getEnum("index", null, "type", IndexType.LUCENE);
    } catch (IllegalArgumentException e) {
    // Custom index type, caller must provide their own module.
    }
    if (indexType != null) {
        switch(indexType) {
            case LUCENE:
                install(luceneIndexModule());
                break;
            default:
                throw new ProvisionException("index type unsupported in tests: " + indexType);
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeQueryRewriter.class).to(IndexRewriteImpl.class);
    bind(IndexRewriteImpl.BasicRewritesImpl.class);
    bind(IndexCollection.class);
    listener().to(IndexCollection.class);
    install(new FactoryModuleBuilder().implement(ChangeIndexer.class, ChangeIndexerImpl.class).build(ChangeIndexer.Factory.class));
    if (indexExecutor != null) {
        bind(ListeningExecutorService.class).annotatedWith(IndexExecutor.class).toInstance(indexExecutor);
    } else {
        install(new IndexExecutorModule(threads));
    }
}
#method_after
@Override
protected void configure() {
    bind(ChangeQueryRewriter.class).to(IndexRewriteImpl.class);
    bind(BasicChangeRewrites.class);
    bind(IndexCollection.class);
    listener().to(IndexCollection.class);
    install(new FactoryModuleBuilder().implement(ChangeIndexer.class, ChangeIndexerImpl.class).build(ChangeIndexer.Factory.class));
    if (indexExecutor != null) {
        bind(ListeningExecutorService.class).annotatedWith(IndexExecutor.class).toInstance(indexExecutor);
    } else {
        install(new IndexExecutorModule(threads));
    }
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = luceneModule != null ? luceneModule : new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    if (Objects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(createIndexModule());
    if (Objects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setTestChangeMerge(cfg.getBoolean("changeMerge", "test", false));
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setReportBugUrl(cfg.getString("gerrit", null, "reportBugUrl"));
    if (config.getReportBugUrl() == null) {
        config.setReportBugUrl("http://code.google.com/p/gerrit/issues/list");
    } else if (config.getReportBugUrl().isEmpty()) {
        config.setReportBugUrl(null);
    }
    config.setGitBasicAuth(authConfig.isGitBasicAuth());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#method_after
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setReportBugUrl(cfg.getString("gerrit", null, "reportBugUrl"));
    if (config.getReportBugUrl() == null) {
        config.setReportBugUrl("http://code.google.com/p/gerrit/issues/list");
    } else if (config.getReportBugUrl().isEmpty()) {
        config.setReportBugUrl(null);
    }
    config.setGitBasicAuth(authConfig.isGitBasicAuth());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#end_block

#method_before
private void setForOpenChange(final ChangeInfo info, final String revision) {
    relatedChangesTab = createTab(Resources.C.relatedChanges(), Resources.C.relatedChangesTooltip());
    ChangeApi.revision(info.legacy_id().get(), revision).view("related").get(new AsyncCallback<RelatedInfo>() {

        @Override
        public void onSuccess(RelatedInfo result) {
            relatedChangesTab.setTitle(Resources.M.relatedChanges(result.changes().length()));
            relatedChangesTab.setChanges(info.project(), revision, result.changes());
        }

        @Override
        public void onFailure(Throwable err) {
            relatedChangesTab.setTitle(Resources.M.relatedChanges(Resources.C.notAvailable()));
            relatedChangesTab.setError(err.getMessage());
        }
    });
    if (info.mergeable()) {
        StringBuilder conflictsQuery = new StringBuilder();
        conflictsQuery.append("status:open");
        conflictsQuery.append(" is:mergeable");
        conflictsQuery.append(" ").append(op("conflicts", info.legacy_id().get()));
        ChangeList.query(conflictsQuery.toString(), EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT), new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                JsArray<ChangeAndCommit> changes = convertChangeList(result);
                if (changes.length() > 0) {
                    getTab().setTitle(Resources.M.conflictingChanges(changes.length()));
                    getTab().setChanges(info.project(), revision, changes);
                }
            }

            @Override
            public void onFailure(Throwable err) {
                getTab().setTitle(Resources.M.conflictingChanges(Resources.C.notAvailable()));
                getTab().setError(err.getMessage());
            }

            private RelatedChangesTab getTab() {
                if (conflictingChangesTab == null) {
                    conflictingChangesTab = createTab(Resources.C.conflictingChanges(), Resources.C.conflictingChangesTooltip());
                }
                return conflictingChangesTab;
            }
        });
    }
}
#method_after
private void setForOpenChange(final ChangeInfo info, final String revision) {
    ChangeApi.revision(info.legacy_id().get(), revision).view("related").get(new AsyncCallback<RelatedInfo>() {

        @Override
        public void onSuccess(RelatedInfo result) {
            if (result.changes().length() > 0) {
                getTab().setTitle(Resources.M.relatedChanges(result.changes().length()));
                getTab().setChanges(info.project(), revision, result.changes());
            }
        }

        @Override
        public void onFailure(Throwable err) {
            getTab().setTitle(Resources.M.relatedChanges(Resources.C.notAvailable()));
            getTab().setError(err.getMessage());
        }

        private RelatedChangesTab getTab() {
            if (relatedChangesTab == null) {
                relatedChangesTab = createTab(Resources.C.relatedChanges(), Resources.C.relatedChangesTooltip());
            }
            return relatedChangesTab;
        }
    });
    if (info.mergeable()) {
        StringBuilder conflictsQuery = new StringBuilder();
        conflictsQuery.append("status:open");
        conflictsQuery.append(" is:mergeable");
        conflictsQuery.append(" ").append(op("conflicts", info.legacy_id().get()));
        ChangeList.query(conflictsQuery.toString(), EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT), new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                JsArray<ChangeAndCommit> changes = convertChangeList(result);
                if (changes.length() > 0) {
                    getTab().setTitle(Resources.M.conflictingChanges(changes.length()));
                    getTab().setChanges(info.project(), revision, changes);
                }
            }

            @Override
            public void onFailure(Throwable err) {
                getTab().setTitle(Resources.M.conflictingChanges(Resources.C.notAvailable()));
                getTab().setError(err.getMessage());
            }

            private RelatedChangesTab getTab() {
                if (conflictingChangesTab == null) {
                    conflictingChangesTab = createTab(Resources.C.conflictingChanges(), Resources.C.conflictingChangesTooltip());
                }
                return conflictingChangesTab;
            }
        });
    }
}
#end_block

#method_before
public void run() {
    ui.header("Index");
    boolean upgrading = !site.isNew && index.get("type") == null;
    index.select("Type", "type", IndexType.LUCENE);
    if (upgrading) {
        ui.message("The index must be rebuilt before starting Gerrit:\n" + "  java -jar gerrit.war reindex -d site_path");
    }
}
#method_after
public void run() throws IOException {
    ui.header("Index");
    IndexType type = index.select("Type", "type", IndexType.LUCENE);
    if (site.isNew && type == IndexType.LUCENE) {
        createLuceneIndex();
    } else {
        ui.message("The index must be built before starting Gerrit:\n" + "  java -jar gerrit.war reindex -d site_path\n");
        initFlags.autoStart = false;
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (file.startsWith("^")) {
        if (!allowFileRegex) {
            args.indexes.getSearchIndex();
        }
        return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
    } else {
        return new EqualsFilePredicate(args.dbProvider, args.patchListCache, file);
    }
}
#method_after
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (file.startsWith("^")) {
        return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
    } else {
        return new EqualsFilePredicate(args.dbProvider, args.patchListCache, file);
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    index = new FakeIndex(FakeIndex.V2);
    indexes = new IndexCollection();
    indexes.setSearchIndex(index);
    queryBuilder = new FakeQueryBuilder(indexes);
    rewrite = new IndexRewriteImpl(indexes, null, new IndexRewriteImpl.BasicRewritesImpl(null, indexes));
}
#method_after
@Before
public void setUp() throws Exception {
    index = new FakeIndex(FakeIndex.V2);
    indexes = new IndexCollection();
    indexes.setSearchIndex(index);
    queryBuilder = new FakeQueryBuilder(indexes);
    rewrite = new IndexRewriteImpl(indexes, null, new BasicChangeRewrites(null, indexes));
}
#end_block

#method_before
private Predicate<ChangeData> rewriteImpl(Predicate<ChangeData> in, ChangeIndex index, int limit) throws QueryParseException {
    if (isIndexPredicate(in, index)) {
        return in;
    } else if (in instanceof LimitPredicate) {
        // Replace any limits with the limit provided by the caller.
        return new LimitPredicate(limit);
    } else if (!isRewritePossible(in)) {
        // magic to indicate "in" cannot be rewritten
        return null;
    }
    int n = in.getChildCount();
    BitSet isIndexed = new BitSet(n);
    BitSet notIndexed = new BitSet(n);
    BitSet rewritten = new BitSet(n);
    List<Predicate<ChangeData>> newChildren = Lists.newArrayListWithCapacity(n);
    boolean hasLimit = false;
    for (int i = 0; i < n; i++) {
        Predicate<ChangeData> c = in.getChild(i);
        Predicate<ChangeData> nc = rewriteImpl(c, index, limit);
        if (nc == c) {
            isIndexed.set(i);
            newChildren.add(c);
            continue;
        } else if (nc == null) /* cannot rewrite c */
        {
            notIndexed.set(i);
            newChildren.add(c);
            continue;
        } else if (nc instanceof LimitPredicate) {
            if (hasLimit) {
                // Omit subsequent LimitPredicates regardless of value.
                n--;
                continue;
            } else {
                hasLimit = true;
            }
        }
        rewritten.set(i);
        newChildren.add(nc);
    }
    if (isIndexed.cardinality() == n) {
        // All children are indexed, leave as-is for parent.
        return in;
    } else if (notIndexed.cardinality() == n) {
        // Can't rewrite any children, so cannot rewrite in.
        return null;
    } else if (rewritten.cardinality() == n) {
        // All children were rewritten.
        return in.copy(newChildren);
    }
    return partitionChildren(in, newChildren, isIndexed, index, limit);
}
#method_after
private Predicate<ChangeData> rewriteImpl(Predicate<ChangeData> in, ChangeIndex index, int limit) throws QueryParseException {
    if (isIndexPredicate(in, index)) {
        return in;
    } else if (in instanceof LimitPredicate) {
        // Replace any limits with the limit provided by the caller.
        return new LimitPredicate(limit);
    } else if (!isRewritePossible(in)) {
        // magic to indicate "in" cannot be rewritten
        return null;
    }
    int n = in.getChildCount();
    BitSet isIndexed = new BitSet(n);
    BitSet notIndexed = new BitSet(n);
    BitSet rewritten = new BitSet(n);
    List<Predicate<ChangeData>> newChildren = Lists.newArrayListWithCapacity(n);
    for (int i = 0; i < n; i++) {
        Predicate<ChangeData> c = in.getChild(i);
        Predicate<ChangeData> nc = rewriteImpl(c, index, limit);
        if (nc == c) {
            isIndexed.set(i);
            newChildren.add(c);
        } else if (nc == null) /* cannot rewrite c */
        {
            notIndexed.set(i);
            newChildren.add(c);
        } else {
            rewritten.set(i);
            newChildren.add(nc);
        }
    }
    if (isIndexed.cardinality() == n) {
        // All children are indexed, leave as-is for parent.
        return in;
    } else if (notIndexed.cardinality() == n) {
        // Can't rewrite any children, so cannot rewrite in.
        return null;
    } else if (rewritten.cardinality() == n) {
        // All children were rewritten.
        return in.copy(newChildren);
    }
    return partitionChildren(in, newChildren, isIndexed, index, limit);
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.getEmailAddresses().contains(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
public void setLimit(int n) {
    limit = n;
}
#method_after
public void setLimit(int n) {
    limitFromCaller = n;
}
#end_block

#method_before
public List<List<ChangeData>> queryChanges(List<String> queries) throws OrmException, QueryParseException {
    final Predicate<ChangeData> visibleToMe = queryBuilder.is_visible();
    int cnt = queries.size();
    // Parse and rewrite all queries.
    List<Integer> limits = Lists.newArrayListWithCapacity(cnt);
    List<ChangeDataSource> sources = Lists.newArrayListWithCapacity(cnt);
    for (String query : queries) {
        Predicate<ChangeData> q = parseQuery(query, visibleToMe);
        Predicate<ChangeData> s = queryRewriter.rewrite(q, start);
        if (!(s instanceof ChangeDataSource)) {
            q = Predicate.and(queryBuilder.status_open(), q);
            s = queryRewriter.rewrite(q, start);
        }
        if (!(s instanceof ChangeDataSource)) {
            throw new QueryParseException("invalid query: " + s);
        }
        // Don't trust QueryRewriter to have left the visible predicate.
        AndSource a = new AndSource(ImmutableList.of(s, visibleToMe), start);
        limits.add(limit(q));
        sources.add(a);
    }
    // Run each query asynchronously, if supported.
    List<ResultSet<ChangeData>> matches = Lists.newArrayListWithCapacity(cnt);
    for (ChangeDataSource s : sources) {
        matches.add(s.read());
    }
    List<List<ChangeData>> out = Lists.newArrayListWithCapacity(cnt);
    for (int i = 0; i < cnt; i++) {
        List<ChangeData> results = matches.get(i).toList();
        if (results.size() > maxLimit) {
            moreResults = true;
        }
        int limit = limits.get(i);
        if (limit < results.size()) {
            results = results.subList(0, limit);
        }
        out.add(results);
    }
    return out;
}
#method_after
public QueryResult queryChanges(Predicate<ChangeData> query) throws OrmException, QueryParseException {
    return queryChanges(ImmutableList.of(query)).get(0);
}
#end_block

#method_before
boolean isDisabled() {
    return maxLimit <= 0;
}
#method_after
boolean isDisabled() {
    return permittedLimit <= 0;
}
#end_block

#method_before
private Iterable<ChangeData> queryRecentChanges(int limit) throws OrmException {
    QueryProcessor qp = queryProcessor.get();
    qp.setLimit(limit);
    String query = "project:{" + projectName + "} is:open";
    try {
        return Iterables.limit(queryProcessor.get().queryChanges(query), limit);
    } catch (QueryParseException e) {
        throw new IllegalStateException(e);
    }
}
#method_after
private Iterable<ChangeData> queryRecentChanges(int limit) throws OrmException {
    QueryProcessor qp = queryProcessor.get();
    qp.setLimit(limit);
    ChangeQueryBuilder qb = qp.getQueryBuilder();
    Predicate<ChangeData> p = Predicate.and(qb.project(projectName.get()), qb.status_open());
    try {
        return qp.queryChanges(p).changes();
    } catch (QueryParseException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    try {
        boolean visible = threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
        if (!visible) {
            return;
        }
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, state);
        return;
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
    }
}
#method_after
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    if (!isVisible(project, state)) {
        return;
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
    }
}
#end_block

#method_before
boolean wouldPushProject(final Project.NameKey project) {
    try {
        boolean visible = threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
        if (!visible) {
            return false;
        }
    } catch (Exception e) {
        log.warn(String.format("Could not determine visibility for project '%s'!", project));
    }
    // by default push all projects
    if (projects.length < 1) {
        return true;
    }
    String projectName = project.get();
    for (final String projectMatch : projects) {
        if (isRE(projectMatch)) {
            // projectMatch is a regular expression
            if (projectName.matches(projectMatch)) {
                return true;
            }
        } else if (isWildcard(projectMatch)) {
            // projectMatch is a wildcard
            if (projectName.startsWith(projectMatch.substring(0, projectMatch.length() - 1))) {
                return true;
            }
        } else {
            // No special case, so we try to match directly
            if (projectName.equals(projectMatch)) {
                return true;
            }
        }
    }
    // Nothing matched, so don't push the project
    return false;
}
#method_after
boolean wouldPushProject(final Project.NameKey project) {
    if (!isVisible(project)) {
        return false;
    }
    // by default push all projects
    if (projects.length < 1) {
        return true;
    }
    String projectName = project.get();
    for (final String projectMatch : projects) {
        if (isRE(projectMatch)) {
            // projectMatch is a regular expression
            if (projectName.matches(projectMatch)) {
                return true;
            }
        } else if (isWildcard(projectMatch)) {
            // projectMatch is a wildcard
            if (projectName.startsWith(projectMatch.substring(0, projectMatch.length() - 1))) {
                return true;
            }
        } else {
            // No special case, so we try to match directly
            if (projectName.equals(projectMatch)) {
                return true;
            }
        }
    }
    // Nothing matched, so don't push the project
    return false;
}
#end_block

#method_before
public PatchSet rebase(final Repository git, final RevWalk revWalk, final ObjectInserter inserter, final PatchSet.Id patchSetId, final Change change, final IdentifiedUser uploader, final RevCommit baseCommit, final MergeUtil mergeUtil, PersonIdent committerIdent, boolean sendMail, boolean runHooks, ValidatePolicy validate) throws NoSuchChangeException, OrmException, IOException, InvalidChangeOperationException, MergeConflictException {
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new InvalidChangeOperationException("patch set is not current");
    }
    final PatchSet originalPatchSet = db.get().patchSets().get(patchSetId);
    final RevCommit rebasedCommit;
    ObjectId oldId = ObjectId.fromString(originalPatchSet.getRevision().get());
    ObjectId newId = rebaseCommit(git, inserter, revWalk.parseCommit(oldId), baseCommit, mergeUtil, committerIdent);
    rebasedCommit = revWalk.parseCommit(newId);
    final ChangeControl changeControl = changeControlFactory.validateFor(change, uploader);
    PatchSetInserter patchSetInserter = patchSetInserterFactory.create(git, revWalk, changeControl, rebasedCommit).setCopyLabels(true).setValidatePolicy(validate).setDraft(originalPatchSet.isDraft()).setUploader(uploader.getAccountId()).setSendMail(sendMail).setRunHooks(runHooks);
    final PatchSet.Id newPatchSetId = patchSetInserter.getPatchSetId();
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db.get())), uploader.getAccountId(), TimeUtil.nowTs(), patchSetId);
    cmsg.setMessage("Patch Set " + newPatchSetId.get() + ": Patch Set " + patchSetId.get() + " was rebased");
    Change newChange = patchSetInserter.setMessage(cmsg).insert();
    return db.get().patchSets().get(newChange.currentPatchSetId());
}
#method_after
public PatchSet rebase(final Repository git, final RevWalk revWalk, final ObjectInserter inserter, final PatchSet.Id patchSetId, final Change change, final IdentifiedUser uploader, final RevCommit baseCommit, final MergeUtil mergeUtil, PersonIdent committerIdent, boolean sendMail, boolean runHooks, ValidatePolicy validate) throws NoSuchChangeException, OrmException, IOException, InvalidChangeOperationException, MergeConflictException {
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new InvalidChangeOperationException("patch set is not current");
    }
    final PatchSet originalPatchSet = db.get().patchSets().get(patchSetId);
    final RevCommit rebasedCommit;
    ObjectId oldId = ObjectId.fromString(originalPatchSet.getRevision().get());
    ObjectId newId = rebaseCommit(git, inserter, revWalk.parseCommit(oldId), baseCommit, mergeUtil, committerIdent);
    rebasedCommit = revWalk.parseCommit(newId);
    final ChangeControl changeControl = changeControlFactory.validateFor(change, uploader);
    PatchSetInserter patchSetInserter = patchSetInserterFactory.create(git, revWalk, changeControl, rebasedCommit).setValidatePolicy(validate).setDraft(originalPatchSet.isDraft()).setUploader(uploader.getAccountId()).setSendMail(sendMail).setRunHooks(runHooks);
    final PatchSet.Id newPatchSetId = patchSetInserter.getPatchSetId();
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db.get())), uploader.getAccountId(), TimeUtil.nowTs(), patchSetId);
    cmsg.setMessage("Patch Set " + newPatchSetId.get() + ": Patch Set " + patchSetId.get() + " was rebased");
    Change newChange = patchSetInserter.setMessage(cmsg).insert();
    return db.get().patchSets().get(newChange.currentPatchSetId());
}
#end_block

#method_before
public static String cleanupHashtag(String hashtag) {
    hashtag = LEADER.trimLeadingFrom(hashtag);
    hashtag = WHITESPACE.trimTrailingFrom(hashtag);
    return hashtag.toLowerCase();
}
#method_after
public static String cleanupHashtag(String hashtag) {
    hashtag = LEADER.trimLeadingFrom(hashtag);
    hashtag = WHITESPACE.trimTrailingFrom(hashtag);
    return hashtag;
}
#end_block

#method_before
public static Set<String> extractTags(String input) {
    if (Strings.isNullOrEmpty(input)) {
        return Collections.emptySet();
    } else {
        HashSet<String> result = new HashSet<>();
        Pattern pattern = Pattern.compile("#[A-Za-z0-9]+");
        Matcher matcher = pattern.matcher(input);
        while (matcher.find()) {
            result.add(matcher.group());
        }
        return result;
    }
}
#method_after
public static Set<String> extractTags(String input) {
    Set<String> result = new HashSet<>();
    if (!Strings.isNullOrEmpty(input)) {
        Matcher matcher = Pattern.compile(PATTERN).matcher(input);
        while (matcher.find()) {
            result.add(cleanupHashtag(matcher.group()));
        }
    }
    return result;
}
#end_block

#method_before
@Test
public void emptyCommitMessage() {
    assertThat(HashtagsUtil.extractTags("")).isEmpty();
}
#method_after
@Test
public void emptyCommitMessage() throws Exception {
    assertThat(HashtagsUtil.extractTags("")).isEmpty();
}
#end_block

#method_before
@Test
public void nullCommitMessage() {
    assertThat(HashtagsUtil.extractTags(null)).isEmpty();
}
#method_after
@Test
public void nullCommitMessage() throws Exception {
    assertThat(HashtagsUtil.extractTags(null)).isEmpty();
}
#end_block

#method_before
@Test
public void noHashtags() {
    String commitMessage = "Subject\n\nLine 1\n\nLine 2";
    assertThat(HashtagsUtil.extractTags(commitMessage)).isEmpty();
}
#method_after
@Test
public void noHashtags() throws Exception {
    String commitMessage = "Subject\n\nLine 1\n\nLine 2";
    assertThat(HashtagsUtil.extractTags(commitMessage)).isEmpty();
}
#end_block

#method_before
@Test
public void singleHashtag() {
    String commitMessage = "#Subject\n\nLine 1\n\nLine 2";
    assertThat(HashtagsUtil.extractTags(commitMessage)).containsExactlyElementsIn(Sets.newHashSet("#Subject"));
}
#method_after
@Test
public void singleHashtag() throws Exception {
    String commitMessage = "#Subject\n\nLine 1\n\nLine 2";
    assertThat(HashtagsUtil.extractTags(commitMessage)).containsExactlyElementsIn(Sets.newHashSet("Subject"));
}
#end_block

#method_before
@Test
public void multipleHashtags() {
    String commitMessage = "#Subject\n\n#Hashtag\n\nLine 2";
    assertThat(HashtagsUtil.extractTags(commitMessage)).containsExactlyElementsIn(Sets.newHashSet("#Subject", "#Hashtag"));
}
#method_after
@Test
public void multipleHashtags() throws Exception {
    String commitMessage = "#Subject\n\n#Hashtag\n\nLine 2";
    assertThat(HashtagsUtil.extractTags(commitMessage)).containsExactlyElementsIn(Sets.newHashSet("Subject", "Hashtag"));
}
#end_block

#method_before
@Test
public void multipleHashtagsNoSpaces() {
    String commitMessage = "Subject\n\n#Hashtag1#Hashtag2";
    assertThat(HashtagsUtil.extractTags(commitMessage)).containsExactlyElementsIn(Sets.newHashSet("#Hashtag1", "#Hashtag2"));
}
#method_after
@Test
public void multipleHashtagsNoSpaces() throws Exception {
    String commitMessage = "Subject\n\n#Hashtag1#Hashtag2";
    assertThat(HashtagsUtil.extractTags(commitMessage)).containsExactlyElementsIn(Sets.newHashSet("Hashtag1"));
}
#end_block

#method_before
@Override
public List<Record> apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = Objects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(db.get(), gerritServerConfig, rsrc.getPatchSet(), rsrc.getControl().getProjectControl(), rsrc.getControl(), rsrc.getChange(), changeDataFactory.create(db.get(), rsrc.getChange()), false, "locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results", input.filters == Filters.SKIP, input.rule != null ? new ByteArrayInputStream(input.rule.getBytes(UTF_8)) : null);
    List<Term> results;
    try {
        results = eval(evaluator);
    } catch (RuleEvalException | RuleEvalTimeoutException e) {
        String msg = Joiner.on(": ").skipNulls().join(Iterables.transform(Throwables.getCausalChain(e), new Function<Throwable, String>() {

            @Override
            public String apply(Throwable in) {
                return in.getMessage();
            }
        }));
        throw new BadRequestException("rule failed: " + msg);
    }
    if (results.isEmpty()) {
        throw new BadRequestException(String.format("rule %s has no solutions", evaluator.getSubmitRule().toString()));
    }
    List<SubmitRecord> records = rsrc.getControl().resultsToSubmitRecord(evaluator.getSubmitRule(), results);
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountInfo.Loader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    accounts.fill();
    return out;
}
#method_after
@Override
public List<Record> apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(changeDataFactory.create(db.get(), rsrc.getControl()));
    List<SubmitRecord> records = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).canSubmit();
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountLoader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    if (!out.isEmpty()) {
        out.get(0).prologReductionCount = evaluator.getReductionsConsumed();
    }
    accounts.fill();
    return out;
}
#end_block

#method_before
private List<Term> evaluateImpl() throws RuleEvalException {
    PrologEnvironment env = getPrologEnvironment();
    try {
        submitRule = env.once("gerrit", userRuleLocatorName, new VariableTerm());
        if (fastEvalLabels) {
            env.once("gerrit", "assume_range_from_label");
        }
        List<Term> results = new ArrayList<>();
        try {
            for (Term[] template : env.all("gerrit", userRuleWrapperName, submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            throw new RuleEvalException("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProjectName(), err);
        } catch (RuntimeException err) {
            throw new RuleEvalException("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProjectName(), err);
        }
        Term resultsTerm = toListTerm(results);
        if (!skipFilters) {
            resultsTerm = runSubmitFilters(resultsTerm, env);
        }
        if (resultsTerm.isList()) {
            List<Term> r = Lists.newArrayList();
            for (Term t = resultsTerm; t.isList(); ) {
                ListTerm l = (ListTerm) t;
                r.add(l.car().dereference());
                t = l.cdr().dereference();
            }
            return r;
        }
        return Collections.emptyList();
    } finally {
        env.close();
    }
}
#method_after
private List<Term> evaluateImpl(String userRuleLocatorName, String userRuleWrapperName, String filterRuleLocatorName, String filterRuleWrapperName, CurrentUser user) throws RuleEvalException {
    PrologEnvironment env = getPrologEnvironment(user);
    try {
        Term sr = env.once("gerrit", userRuleLocatorName, new VariableTerm());
        if (fastEvalLabels) {
            env.once("gerrit", "assume_range_from_label");
        }
        List<Term> results = new ArrayList<>();
        try {
            for (Term[] template : env.all("gerrit", userRuleWrapperName, sr, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), getProjectName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", sr, cd.getId().get(), getProjectName()), err);
        } finally {
            reductionsConsumed = env.getReductions();
        }
        Term resultsTerm = toListTerm(results);
        if (!skipFilters) {
            resultsTerm = runSubmitFilters(resultsTerm, env, filterRuleLocatorName, filterRuleWrapperName);
        }
        List<Term> r;
        if (resultsTerm.isList()) {
            r = Lists.newArrayList();
            for (Term t = resultsTerm; t.isList(); ) {
                ListTerm l = (ListTerm) t;
                r.add(l.car().dereference());
                t = l.cdr().dereference();
            }
        } else {
            r = Collections.emptyList();
        }
        submitRule = sr;
        return r;
    } finally {
        env.close();
    }
}
#end_block

#method_before
private PrologEnvironment getPrologEnvironment() throws RuleEvalException {
    ProjectState projectState = projectControl.getProjectState();
    PrologEnvironment env;
    try {
        if (rulesInputStream == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", rulesInputStream);
        }
    } catch (CompileException err) {
        throw new RuleEvalException("Cannot consult rules.pl for " + getProjectName(), err);
    }
    env.set(StoredValues.REVIEW_DB, db);
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.PATCH_SET, patchSet);
    env.set(StoredValues.CHANGE_CONTROL, changeControl);
    return env;
}
#method_after
private PrologEnvironment getPrologEnvironment(CurrentUser user) throws RuleEvalException {
    checkState(patchSet != null, "getPrologEnvironment() called before initPatchSet()");
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (rule == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new ByteArrayInputStream(rule.getBytes(UTF_8)));
        }
    } catch (CompileException err) {
        throw new RuleEvalException("Cannot consult rules.pl for " + getProjectName(), err);
    }
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.PATCH_SET, patchSet);
    env.set(StoredValues.CHANGE_CONTROL, control);
    if (user != null) {
        env.set(StoredValues.CURRENT_USER, user);
    }
    return env;
}
#end_block

#method_before
private Term runSubmitFilters(Term results, PrologEnvironment env) throws RuleEvalException {
    ProjectState projectState = projectControl.getProjectState();
    PrologEnvironment childEnv = env;
    for (ProjectState parentState : projectState.parents()) {
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            throw new RuleEvalException("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", filterRuleLocatorName, new VariableTerm());
        try {
            if (fastEvalLabels) {
                env.once("gerrit", "assume_range_from_label");
            }
            Term[] template = parentEnv.once("gerrit", filterRuleWrapperName, filterRule, results, new VariableTerm());
            results = template[2];
        } catch (PrologException err) {
            throw new RuleEvalException("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
        } catch (RuntimeException err) {
            throw new RuleEvalException("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
        }
        childEnv = parentEnv;
    }
    return results;
}
#method_after
private Term runSubmitFilters(Term results, PrologEnvironment env, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment childEnv = env;
    for (ProjectState parentState : projectState.parents()) {
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            throw new RuleEvalException("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", filterRuleLocatorName, new VariableTerm());
        try {
            if (fastEvalLabels) {
                env.once("gerrit", "assume_range_from_label");
            }
            Term[] template = parentEnv.once("gerrit", filterRuleWrapperName, filterRule, results, new VariableTerm());
            results = template[2];
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), parentState.getProject().getName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", filterRule, cd.getId().get(), parentState.getProject().getName()), err);
        } finally {
            reductionsConsumed += env.getReductions();
        }
        childEnv = parentEnv;
    }
    return results;
}
#end_block

#method_before
public Term getSubmitRule() {
    return submitRule;
}
#method_after
public Term getSubmitRule() {
    checkState(submitRule != null, "getSubmitRule() invalid before evaluation");
    return submitRule;
}
#end_block

#method_before
private String getProjectName() {
    if (projectName == null) {
        projectName = projectControl.getProjectState().getProject().getName();
    }
    return projectName;
}
#method_after
private String getProjectName() {
    return control.getProjectControl().getProjectState().getProject().getName();
}
#end_block

#method_before
@Override
public Response<DiffInfo> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException {
    PatchSet.Id basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet().getId();
    }
    AccountDiffPreference prefs = new AccountDiffPreference(new Account.Id(0));
    prefs.setIgnoreWhitespace(ignoreWhitespace.whitespace);
    prefs.setContext(context);
    prefs.setIntralineDifference(intraline);
    try {
        PatchScriptFactory psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet, resource.getPatchKey().getParentKey(), prefs);
        psf.setLoadHistory(false);
        psf.setLoadComments(context != AccountDiffPreference.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %d; want %d", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %d; want %d", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        DiffInfo result = new DiffInfo();
        if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
            result.metaA = new FileMeta();
            result.metaA.name = Objects.firstNonNull(ps.getOldName(), ps.getNewName());
            setContentType(result.metaA, state, ps.getFileModeA(), ps.getMimeTypeA());
            result.metaA.lines = ps.getA().size();
        }
        if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
            result.metaB = new FileMeta();
            result.metaB.name = ps.getNewName();
            setContentType(result.metaB, state, ps.getFileModeB(), ps.getMimeTypeB());
            result.metaB.lines = ps.getB().size();
        }
        if (intraline) {
            if (ps.hasIntralineTimeout()) {
                result.intralineStatus = IntraLineStatus.TIMEOUT;
            } else if (ps.hasIntralineFailure()) {
                result.intralineStatus = IntraLineStatus.FAILURE;
            } else {
                result.intralineStatus = IntraLineStatus.OK;
            }
        }
        result.changeType = ps.getChangeType();
        if (ps.getPatchHeader().size() > 0) {
            result.diffHeader = ps.getPatchHeader();
        }
        result.content = content.lines;
        Response<DiffInfo> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
@Override
public Response<DiffInfo> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException, AuthException, InvalidChangeOperationException, IOException {
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
    }
    AccountDiffPreference prefs = new AccountDiffPreference(new Account.Id(0));
    prefs.setIgnoreWhitespace(ignoreWhitespace.whitespace);
    prefs.setContext(context);
    prefs.setIntralineDifference(intraline);
    try {
        PatchScriptFactory psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet != null ? basePatchSet.getId() : null, resource.getPatchKey().getParentKey(), prefs);
        psf.setLoadHistory(false);
        psf.setLoadComments(context != AccountDiffPreference.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %d; want %d", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %d; want %d", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        DiffInfo result = new DiffInfo();
        // TODO referring to the parent commit by refs/changes/12/60012/1^1
        // will likely not work for inline edits
        String revA = basePatchSet != null ? basePatchSet.getRefName() : resource.getRevision().getPatchSet().getRefName() + "^1";
        String revB = resource.getRevision().getEdit().isPresent() ? resource.getRevision().getEdit().get().getRefName() : resource.getRevision().getPatchSet().getRefName();
        FluentIterable<DiffWebLinkInfo> links = webLinks.getDiffLinks(state.getProject().getName(), resource.getPatchKey().getParentKey().getParentKey().get(), basePatchSet != null ? basePatchSet.getId().get() : null, revA, MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName()), resource.getPatchKey().getParentKey().get(), revB, ps.getNewName());
        result.webLinks = links.isEmpty() ? null : links.toList();
        if (!webLinksOnly) {
            if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
                result.metaA = new FileMeta();
                result.metaA.name = MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName());
                setContentType(result.metaA, state, ps.getFileModeA(), ps.getMimeTypeA());
                result.metaA.lines = ps.getA().size();
                result.metaA.webLinks = getFileWebLinks(state.getProject(), revA, result.metaA.name);
            }
            if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
                result.metaB = new FileMeta();
                result.metaB.name = ps.getNewName();
                setContentType(result.metaB, state, ps.getFileModeB(), ps.getMimeTypeB());
                result.metaB.lines = ps.getB().size();
                result.metaB.webLinks = getFileWebLinks(state.getProject(), revB, result.metaB.name);
            }
            if (intraline) {
                if (ps.hasIntralineTimeout()) {
                    result.intralineStatus = IntraLineStatus.TIMEOUT;
                } else if (ps.hasIntralineFailure()) {
                    result.intralineStatus = IntraLineStatus.FAILURE;
                } else {
                    result.intralineStatus = IntraLineStatus.OK;
                }
            }
            result.changeType = CHANGE_TYPE.get(ps.getChangeType());
            if (result.changeType == null) {
                throw new IllegalStateException("unknown change type: " + ps.getChangeType());
            }
            if (ps.getPatchHeader().size() > 0) {
                result.diffHeader = ps.getPatchHeader();
            }
            result.content = content.lines;
        }
        Response<DiffInfo> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.setCmdLineParser(clp);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(destBranch).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(destBranch).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#method_after
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void markHeadsAsUninteresting(final RevWalk walk, Set<ObjectId> existing, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith(REFS_CHANGES)) {
            existing.add(ref.getObjectId());
        } else if (ref.getName().startsWith(R_HEADS) || (forRef != null && forRef.equals(ref.getName()))) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
        ins.setHashtags(magicBranch.getHashtags());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setApprovals(approvals).setMessage(msg).setSendMail(false).insert();
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, ins.getPatchSetInfo());
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        ins.setHashtags(magicBranch.hashtags);
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).insert();
    created = true;
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ps);
    }
}
#end_block

#method_before
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                    replaceByCommit.remove(req.newCommit);
                }
            }
        }
    } catch (OrmException err) {
        log.error(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        log.error(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#method_after
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        log.error(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        log.error(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.isDraft()) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.draft) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
        Set<String> hashtags = magicBranch.getHashtags();
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, changeCtl, approvals);
        recipients.add(oldRecipients);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(FooterConstants.CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, changeCtl, approvals);
        recipients.add(oldRecipients);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private ListMultimap<Change.Id, Ref> refsByChange() {
    if (refsByChange == null) {
        int estRefsPerChange = 4;
        refsByChange = ArrayListMultimap.create(allRefs.size() / estRefsPerChange, estRefsPerChange);
        for (Ref ref : allRefs.values()) {
            if (ref.getObjectId() != null) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                if (psId != null) {
                    refsByChange.put(psId.getParentKey(), ref);
                }
            }
        }
    }
    return refsByChange;
}
#method_after
private ListMultimap<Change.Id, Ref> refsByChange() {
    initChangeRefMaps();
    return refsByChange;
}
#end_block

#method_before
private SetMultimap<ObjectId, Ref> changeRefsById() {
    if (refsById == null) {
        refsById = HashMultimap.create();
        for (Ref r : refsByChange().values()) {
            refsById.put(r.getObjectId(), r);
        }
    }
    return refsById;
}
#method_after
private SetMultimap<ObjectId, Ref> changeRefsById() {
    initChangeRefMaps();
    return refsById;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.getEmailAddresses().contains(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.getEmailAddresses().contains(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByKey(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(FooterConstants.CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByKey(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // Update superproject gitlinks if required.
        subOpFactory.create(branch, newTip, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>(), currentUser.getAccount()).update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByKey(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByKey(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // Update superproject gitlinks if required.
        subOpFactory.create(branch, newTip, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>(), currentUser.getAccount()).update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private Change.Id insertPatchSet(Repository git, RevWalk revWalk, Change change, RevCommit cherryPickCommit, RefControl refControl, IdentifiedUser identifiedUser) throws InvalidChangeOperationException, IOException, OrmException, NoSuchChangeException {
    final ChangeControl changeControl = refControl.getProjectControl().controlFor(change);
    final PatchSetInserter inserter = patchSetInserterFactory.create(git, revWalk, changeControl, cherryPickCommit);
    final PatchSet.Id newPatchSetId = inserter.getPatchSetId();
    PatchSet current = db.get().patchSets().get(change.currentPatchSetId());
    inserter.setMessage("Uploaded patch set " + newPatchSetId.get() + ".").setDraft(current.isDraft()).setUploader(identifiedUser.getAccountId()).setCopyLabels(true).insert();
    return change.getId();
}
#method_after
private Change.Id insertPatchSet(Repository git, RevWalk revWalk, Change change, RevCommit cherryPickCommit, RefControl refControl, IdentifiedUser identifiedUser) throws InvalidChangeOperationException, IOException, OrmException, NoSuchChangeException {
    final ChangeControl changeControl = refControl.getProjectControl().controlFor(change);
    final PatchSetInserter inserter = patchSetInserterFactory.create(git, revWalk, changeControl, cherryPickCommit);
    final PatchSet.Id newPatchSetId = inserter.getPatchSetId();
    PatchSet current = db.get().patchSets().get(change.currentPatchSetId());
    inserter.setMessage("Uploaded patch set " + newPatchSetId.get() + ".").setDraft(current.isDraft()).setUploader(identifiedUser.getAccountId()).insert();
    return change.getId();
}
#end_block

#method_before
@Override
public ChangeInfo get() throws RestApiException {
    EnumSet<ListChangesOption> opts = EnumSet.allOf(ListChangesOption.class);
    opts.remove(ListChangesOption.CHECK);
    return get(opts);
}
#method_after
@Override
public ChangeInfo get() throws RestApiException {
    return get(EnumSet.complementOf(EnumSet.of(ListChangesOption.CHECK)));
}
#end_block

#method_before
public String getContentType(Project.NameKey project, String revstr, String path) throws ResourceNotFoundException, IOException {
    Repository repo = repoManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(repo);
        try {
            RevCommit commit = rw.parseCommit(repo.resolve(revstr));
            TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), path, commit.getTree().getId());
            if (tw == null) {
                throw new ResourceNotFoundException();
            }
            return registry.getMimeType(path, Text.asByteArray(repo.open(tw.getObjectId(0)))).toString();
        } finally {
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
public String getContentType(Project.NameKey project, String revstr, String path) throws ResourceNotFoundException, IOException {
    Repository repo = repoManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectReader reader = repo.newObjectReader();
        try {
            RevCommit commit = rw.parseCommit(repo.resolve(revstr));
            TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), path, commit.getTree().getId());
            if (tw == null) {
                throw new ResourceNotFoundException();
            }
            ObjectLoader blobLoader = reader.open(tw.getObjectId(0), OBJ_BLOB);
            byte[] raw = blobLoader.isLarge() ? null : blobLoader.getCachedBytes();
            return registry.getMimeType(path, raw).toString();
        } finally {
            reader.release();
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
@Test
public void updateMessage() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        modifier.modifyMessage(edit.get(), edit.get().getEditCommit().getFullMessage());
        fail("UnchangedCommitMessage expected");
    } catch (UnchangedCommitMessageException ex) {
        assertThat(ex.getMessage()).isEqualTo("New commit message cannot be same as existing commit message");
    }
    String msg = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
    editUtil.publish(edit.get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
}
#method_after
@Test
public void updateMessage() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        modifier.modifyMessage(edit.get(), edit.get().getEditCommit().getFullMessage());
        fail("UnchangedCommitMessageException expected");
    } catch (UnchangedCommitMessageException ex) {
        assertThat(ex.getMessage()).isEqualTo("New commit message cannot be same as existing commit message");
    }
    String msg = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
    editUtil.publish(edit.get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
}
#end_block

#method_before
private String extractWhat(DispatchCommand dcmd) {
    String commandName = dcmd.getCommandName();
    String[] args = dcmd.getArguments();
    for (int i = 1; i < args.length; i++) {
        commandName = commandName + "." + args[i];
    }
    return commandName;
}
#method_after
private String extractWhat(DispatchCommand dcmd) {
    String commandName = dcmd.getCommandName();
    for (String arg : dcmd.getArguments()) {
        commandName = commandName + "." + arg;
    }
    return commandName;
}
#end_block

#method_before
private Connector[] listen(Server server, Config cfg) {
    // OpenID and certain web-based single-sign-on products can cause
    // some very long headers, especially in the Referer header. We
    // need to use a larger default header size to ensure we have
    // the space required.
    // 
    final int requestHeaderSize = cfg.getInt("httpd", "requestheadersize", 16386);
    final URI[] listenUrls = listenURLs(cfg);
    final boolean reuseAddress = cfg.getBoolean("httpd", "reuseaddress", true);
    final int acceptors = cfg.getInt("httpd", "acceptorThreads", 2);
    final AuthType authType = ConfigUtil.getEnum(cfg, "auth", null, "type", AuthType.OPENID);
    reverseProxy = isReverseProxied(listenUrls);
    final Connector[] connectors = new Connector[listenUrls.length];
    for (int idx = 0; idx < listenUrls.length; idx++) {
        final URI u = listenUrls[idx];
        final int defaultPort;
        final ServerConnector c;
        HttpConfiguration config = defaultConfig(requestHeaderSize);
        if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType) && !"https".equals(u.getScheme())) {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "' when auth.type = '" + AuthType.CLIENT_SSL_CERT_LDAP.name() + "'; only 'https' is supported");
        }
        if ("http".equals(u.getScheme())) {
            defaultPort = 80;
            c = newServerConnector(server, acceptors, config);
        } else if ("https".equals(u.getScheme())) {
            SslContextFactory ssl = new SslContextFactory();
            final File keystore = getFile(cfg, "sslkeystore", "etc/keystore");
            String password = cfg.getString("httpd", null, "sslkeypassword");
            if (password == null) {
                password = "gerrit";
            }
            ssl.setKeyStorePath(keystore.getAbsolutePath());
            ssl.setTrustStorePath(keystore.getAbsolutePath());
            ssl.setKeyStorePassword(password);
            ssl.setTrustStorePassword(password);
            if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType)) {
                ssl.setNeedClientAuth(true);
                File crl = getFile(cfg, "sslcrl", "etc/crl.pem");
                if (crl.exists()) {
                    ssl.setCrlPath(crl.getAbsolutePath());
                    ssl.setValidatePeerCerts(true);
                }
            }
            defaultPort = 443;
            config.addCustomizer(new SecureRequestCustomizer());
            c = new ServerConnector(server, null, null, null, 0, acceptors, new SslConnectionFactory(ssl, "http/1.1"), new HttpConnectionFactory(config));
        } else if ("proxy-http".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            c = newServerConnector(server, acceptors, config);
        } else if ("proxy-https".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            config.addCustomizer(new HttpConfiguration.Customizer() {

                @Override
                public void customize(Connector connector, HttpConfiguration channelConfig, Request request) {
                    request.setScheme(HttpScheme.HTTPS.asString());
                    request.setSecure(true);
                }
            });
            c = newServerConnector(server, acceptors, config);
        } else {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "';" + " only 'http', 'https', 'proxy-http, 'proxy-https'" + " are supported");
        }
        try {
            if (u.getHost() == null && (// 
            u.getAuthority().equals("*") || u.getAuthority().startsWith("*:"))) {
                // Bind to all local addresses. Port wasn't parsed right by URI
                // due to the illegal host of "*" so replace with a legal name
                // and parse the URI.
                // 
                final URI r = new URI(u.toString().replace('*', 'A')).parseServerAuthority();
                c.setHost(null);
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            } else {
                final URI r = u.parseServerAuthority();
                c.setHost(r.getHost());
                c.setPort(0 <= r.getPort() ? r.getPort() : defaultPort);
            }
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException("Invalid httpd.listenurl " + u, e);
        }
        c.setReuseAddress(reuseAddress);
        connectors[idx] = c;
    }
    return connectors;
}
#method_after
private Connector[] listen(Server server, Config cfg) {
    // OpenID and certain web-based single-sign-on products can cause
    // some very long headers, especially in the Referer header. We
    // need to use a larger default header size to ensure we have
    // the space required.
    // 
    final int requestHeaderSize = cfg.getInt("httpd", "requestheadersize", 16386);
    final URI[] listenUrls = listenURLs(cfg);
    final boolean reuseAddress = cfg.getBoolean("httpd", "reuseaddress", true);
    final int acceptors = cfg.getInt("httpd", "acceptorThreads", 2);
    final AuthType authType = cfg.getEnum("auth", null, "type", AuthType.OPENID);
    reverseProxy = isReverseProxied(listenUrls);
    final Connector[] connectors = new Connector[listenUrls.length];
    for (int idx = 0; idx < listenUrls.length; idx++) {
        final URI u = listenUrls[idx];
        final int defaultPort;
        final ServerConnector c;
        HttpConfiguration config = defaultConfig(requestHeaderSize);
        if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType) && !"https".equals(u.getScheme())) {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "' when auth.type = '" + AuthType.CLIENT_SSL_CERT_LDAP.name() + "'; only 'https' is supported");
        }
        if ("http".equals(u.getScheme())) {
            defaultPort = 80;
            c = newServerConnector(server, acceptors, config);
        } else if ("https".equals(u.getScheme())) {
            SslContextFactory ssl = new SslContextFactory();
            final File keystore = getFile(cfg, "sslkeystore", "etc/keystore");
            String password = cfg.getString("httpd", null, "sslkeypassword");
            if (password == null) {
                password = "gerrit";
            }
            ssl.setKeyStorePath(keystore.getAbsolutePath());
            ssl.setTrustStorePath(keystore.getAbsolutePath());
            ssl.setKeyStorePassword(password);
            ssl.setTrustStorePassword(password);
            if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType)) {
                ssl.setNeedClientAuth(true);
                File crl = getFile(cfg, "sslcrl", "etc/crl.pem");
                if (crl.exists()) {
                    ssl.setCrlPath(crl.getAbsolutePath());
                    ssl.setValidatePeerCerts(true);
                }
            }
            defaultPort = 443;
            config.addCustomizer(new SecureRequestCustomizer());
            c = new ServerConnector(server, null, null, null, 0, acceptors, new SslConnectionFactory(ssl, "http/1.1"), new HttpConnectionFactory(config));
        } else if ("proxy-http".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            c = newServerConnector(server, acceptors, config);
        } else if ("proxy-https".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            config.addCustomizer(new HttpConfiguration.Customizer() {

                @Override
                public void customize(Connector connector, HttpConfiguration channelConfig, Request request) {
                    request.setScheme(HttpScheme.HTTPS.asString());
                    request.setSecure(true);
                }
            });
            c = newServerConnector(server, acceptors, config);
        } else {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "';" + " only 'http', 'https', 'proxy-http, 'proxy-https'" + " are supported");
        }
        try {
            if (u.getHost() == null && (// 
            u.getAuthority().equals("*") || u.getAuthority().startsWith("*:"))) {
                // Bind to all local addresses. Port wasn't parsed right by URI
                // due to the illegal host of "*" so replace with a legal name
                // and parse the URI.
                // 
                final URI r = new URI(u.toString().replace('*', 'A')).parseServerAuthority();
                c.setHost(null);
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            } else {
                final URI r = u.parseServerAuthority();
                c.setHost(r.getHost());
                c.setPort(0 <= r.getPort() ? r.getPort() : defaultPort);
            }
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException("Invalid httpd.listenurl " + u, e);
        }
        c.setReuseAddress(reuseAddress);
        connectors[idx] = c;
    }
    return connectors;
}
#end_block

#method_before
private Resource useDeveloperBuild(ServletContextHandler app) throws IOException {
    final File dir = GerritLauncher.getDeveloperBuckOut();
    final File gen = new File(dir, "gen");
    final File root = dir.getParentFile();
    final File dstwar = makeWarTempDir();
    File ui = new File(dstwar, "gerrit_ui");
    File p = new File(ui, "permutations");
    mkdir(ui);
    p.createNewFile();
    p.deleteOnExit();
    app.addFilter(new FilterHolder(new Filter() {

        private final boolean gwtuiRecompile = System.getProperty("gerrit.disable-gwtui-recompile") == null;

        private final UserAgentRule rule = new UserAgentRule();

        private final Map<String, Boolean> uaInitialized = new HashMap<>();

        private String lastTarget;

        private long lastTime;

        @Override
        public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
            String pkg = "gerrit-gwtui";
            String target = "ui_" + rule.select((HttpServletRequest) request);
            if (gwtuiRecompile || uaInitialized.get(target) == null) {
                String rule = "//" + pkg + ":" + target;
                // TODO(davido): instead of assuming specific Buck's internal
                // target directory for gwt_binary() artifacts, ask Buck for
                // the location of user agent permutation GWT zip, e. g.:
                // $ buck targets --show_output //gerrit-gwtui:ui_safari \
                // | awk '{print $2}'
                String child = String.format("%s/__gwt_binary_%s__", pkg, target);
                File zip = new File(new File(gen, child), target + ".zip");
                synchronized (this) {
                    try {
                        build(root, gen, rule);
                    } catch (BuildFailureException e) {
                        displayFailure(rule, e.why, (HttpServletResponse) res);
                        return;
                    }
                    if (!target.equals(lastTarget) || lastTime != zip.lastModified()) {
                        lastTarget = target;
                        lastTime = zip.lastModified();
                        unpack(zip, dstwar);
                    }
                }
                if (uaInitialized.get(target) == null) {
                    uaInitialized.put(target, Boolean.TRUE);
                }
            }
            chain.doFilter(request, res);
        }

        private void displayFailure(String rule, byte[] why, HttpServletResponse res) throws IOException {
            res.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            res.setContentType("text/html");
            res.setCharacterEncoding(Charsets.UTF_8.name());
            CacheHeaders.setNotCacheable(res);
            Escaper html = HtmlEscapers.htmlEscaper();
            PrintWriter w = res.getWriter();
            w.write("<html><title>BUILD FAILED</title><body>");
            w.format("<h1>%s FAILED</h1>", html.escape(rule));
            w.write("<pre>");
            w.write(html.escape(RawParseUtils.decode(why)));
            w.write("</pre>");
            w.write("</body></html>");
            w.close();
        }

        @Override
        public void init(FilterConfig config) {
        }

        @Override
        public void destroy() {
        }
    }), "/", EnumSet.of(DispatcherType.REQUEST));
    return Resource.newResource(dstwar.toURI());
}
#method_after
private Resource useDeveloperBuild(ServletContextHandler app) throws IOException {
    final File dir = GerritLauncher.getDeveloperBuckOut();
    final File gen = new File(dir, "gen");
    final File root = dir.getParentFile();
    final File dstwar = makeWarTempDir();
    File ui = new File(dstwar, "gerrit_ui");
    File p = new File(ui, "permutations");
    mkdir(ui);
    p.createNewFile();
    p.deleteOnExit();
    app.addFilter(new FilterHolder(new Filter() {

        private final boolean gwtuiRecompile = System.getProperty("gerrit.disable-gwtui-recompile") == null;

        private final UserAgentRule rule = new UserAgentRule();

        private final Set<String> uaInitialized = new HashSet<>();

        private String lastTarget;

        private long lastTime;

        @Override
        public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
            String pkg = "gerrit-gwtui";
            String target = "ui_" + rule.select((HttpServletRequest) request);
            if (gwtuiRecompile || !uaInitialized.contains(target)) {
                String rule = "//" + pkg + ":" + target;
                // TODO(davido): instead of assuming specific Buck's internal
                // target directory for gwt_binary() artifacts, ask Buck for
                // the location of user agent permutation GWT zip, e. g.:
                // $ buck targets --show_output //gerrit-gwtui:ui_safari \
                // | awk '{print $2}'
                String child = String.format("%s/__gwt_binary_%s__", pkg, target);
                File zip = new File(new File(gen, child), target + ".zip");
                synchronized (this) {
                    try {
                        build(root, gen, rule);
                    } catch (BuildFailureException e) {
                        displayFailure(rule, e.why, (HttpServletResponse) res);
                        return;
                    }
                    if (!target.equals(lastTarget) || lastTime != zip.lastModified()) {
                        lastTarget = target;
                        lastTime = zip.lastModified();
                        unpack(zip, dstwar);
                    }
                }
                uaInitialized.add(target);
            }
            chain.doFilter(request, res);
        }

        private void displayFailure(String rule, byte[] why, HttpServletResponse res) throws IOException {
            res.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            res.setContentType("text/html");
            res.setCharacterEncoding(Charsets.UTF_8.name());
            CacheHeaders.setNotCacheable(res);
            Escaper html = HtmlEscapers.htmlEscaper();
            PrintWriter w = res.getWriter();
            w.write("<html><title>BUILD FAILED</title><body>");
            w.format("<h1>%s FAILED</h1>", html.escape(rule));
            w.write("<pre>");
            w.write(html.escape(RawParseUtils.decode(why)));
            w.write("</pre>");
            w.write("</body></html>");
            w.close();
        }

        @Override
        public void init(FilterConfig config) {
        }

        @Override
        public void destroy() {
        }
    }), "/", EnumSet.of(DispatcherType.REQUEST));
    return Resource.newResource(dstwar.toURI());
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    db = reviewDbProvider.open();
    changeId = newChange(git, admin.getIdent());
    ps = getCurrentPatchSet(changeId);
    amendChange(git, admin.getIdent(), changeId);
    change = getChange(changeId);
    assertNotNull(ps);
    String changeId2 = newChange2(git, admin.getIdent());
    change2 = getChange(changeId2);
    assertNotNull(change2);
    ps2 = getCurrentPatchSet(changeId2);
    assertNotNull(ps2);
    final long clockStepMs = MILLISECONDS.convert(1, SECONDS);
    final AtomicLong clockMs = new AtomicLong(new DateTime(2009, 9, 30, 17, 0, 0).getMillis());
    DateTimeUtils.setCurrentMillisProvider(new MillisProvider() {

        @Override
        public long getMillis() {
            return clockMs.getAndAdd(clockStepMs);
        }
    });
}
#method_after
@Before
public void setUp() throws Exception {
    db = reviewDbProvider.open();
    changeId = newChange(git, admin.getIdent());
    ps = getCurrentPatchSet(changeId);
    amendChange(git, admin.getIdent(), changeId);
    change = getChange(changeId);
    assertThat(ps).isNotNull();
    String changeId2 = newChange2(git, admin.getIdent());
    change2 = getChange(changeId2);
    assertThat(change2).isNotNull();
    ps2 = getCurrentPatchSet(changeId2);
    assertThat(ps2).isNotNull();
    final long clockStepMs = MILLISECONDS.convert(1, SECONDS);
    final AtomicLong clockMs = new AtomicLong(new DateTime(2009, 9, 30, 17, 0, 0).getMillis());
    DateTimeUtils.setCurrentMillisProvider(new MillisProvider() {

        @Override
        public long getMillis() {
            return clockMs.getAndAdd(clockStepMs);
        }
    });
}
#end_block

#method_before
@Test
public void deleteEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    editUtil.delete(editUtil.byChange(change).get());
    assertFalse(editUtil.byChange(change).isPresent());
}
#method_after
@Test
public void deleteEdit() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.delete(editUtil.byChange(change).get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
}
#end_block

#method_before
@Test
public void publishEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, getCurrentPatchSet(changeId)));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW2));
    editUtil.publish(editUtil.byChange(change).get());
    assertFalse(editUtil.byChange(change).isPresent());
}
#method_after
@Test
public void publishEdit() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.publish(editUtil.byChange(change).get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
}
#end_block

#method_before
@Test
public void publishEditRest() throws Exception {
    PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId);
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, oldCurrentPatchSet));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = adminSession.post(urlPublish());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
    PatchSet newCurrentPatchSet = getCurrentPatchSet(changeId);
    assertFalse(oldCurrentPatchSet.getId().equals(newCurrentPatchSet.getId()));
}
#method_after
@Test
public void publishEditRest() throws Exception {
    PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId);
    assertThat(modifier.createEdit(change, oldCurrentPatchSet)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = adminSession.post(urlPublish());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
    PatchSet newCurrentPatchSet = getCurrentPatchSet(changeId);
    assertThat(oldCurrentPatchSet.getId().equals(newCurrentPatchSet.getId())).isFalse();
}
#end_block

#method_before
@Test
public void deleteEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = adminSession.delete(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void deleteEditRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = adminSession.delete(urlEdit());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
}
#end_block

#method_before
@Test
public void rebaseEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertEquals(current.getPatchSetId() - 1, edit.getBasePatchSet().getPatchSetId());
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    modifier.rebaseEdit(edit, current);
    edit = editUtil.byChange(change).get();
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME)));
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME2)));
    assertEquals(current.getPatchSetId(), edit.getBasePatchSet().getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertFalse(beforeRebase.equals(afterRebase));
}
#method_after
@Test
public void rebaseEdit() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId() - 1);
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    modifier.rebaseEdit(edit, current);
    edit = editUtil.byChange(change).get();
    assertByteArray(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME), CONTENT_NEW);
    assertByteArray(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME2), CONTENT_NEW2);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertThat(beforeRebase.equals(afterRebase)).isFalse();
}
#end_block

#method_before
@Test
public void rebaseEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertEquals(current.getPatchSetId() - 1, edit.getBasePatchSet().getPatchSetId());
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    RestResponse r = adminSession.post(urlRebase());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change).get();
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME)));
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME2)));
    assertEquals(current.getPatchSetId(), edit.getBasePatchSet().getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertFalse(beforeRebase.equals(afterRebase));
}
#method_after
@Test
public void rebaseEditRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId() - 1);
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    RestResponse r = adminSession.post(urlRebase());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change).get();
    assertByteArray(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME), CONTENT_NEW);
    assertByteArray(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME2), CONTENT_NEW2);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertThat(beforeRebase.equals(afterRebase)).isFalse();
}
#end_block

#method_before
@Test
public void updateExistingFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
    editUtil.delete(edit.get());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void updateExistingFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW);
    editUtil.delete(edit.get());
    edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
}
#end_block

#method_before
@Test
public void updateMessage() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, getCurrentPatchSet(changeId)));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        modifier.modifyMessage(edit.get(), edit.get().getEditCommit().getFullMessage());
        fail("InvalidChangeOperationException expected");
    } catch (UnchangedCommitMessage ex) {
        assertEquals(ex.getMessage(), "New commit message cannot be same as existing commit message");
    }
    String msg = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyMessage(edit.get(), msg));
    edit = editUtil.byChange(change);
    assertEquals(msg, edit.get().getEditCommit().getFullMessage());
    editUtil.publish(edit.get());
    assertFalse(editUtil.byChange(change).isPresent());
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertEquals(msg, info.revisions.get(info.currentRevision).commit.message);
}
#method_after
@Test
public void updateMessage() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        modifier.modifyMessage(edit.get(), edit.get().getEditCommit().getFullMessage());
        fail("UnchangedCommitMessageException expected");
    } catch (UnchangedCommitMessageException ex) {
        assertThat(ex.getMessage()).isEqualTo("New commit message cannot be same as existing commit message");
    }
    String msg = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
    editUtil.publish(edit.get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
}
#end_block

#method_before
@Test
public void updateMessageRest() throws Exception {
    EditMessage.Input in = new EditMessage.Input();
    in.message = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertEquals(SC_NO_CONTENT, adminSession.put(urlEditMessage(), in).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(in.message, edit.get().getEditCommit().getFullMessage());
    in.message = String.format("New commit message2\n\nChange-Id: %s", change.getKey());
    assertEquals(SC_NO_CONTENT, adminSession.put(urlEditMessage(), in).getStatusCode());
    edit = editUtil.byChange(change);
    assertEquals(in.message, edit.get().getEditCommit().getFullMessage());
    editUtil.delete(edit.get());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void updateMessageRest() throws Exception {
    EditMessage.Input in = new EditMessage.Input();
    in.message = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    in.message = String.format("New commit message2\n\nChange-Id: %s", change.getKey());
    assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
}
#end_block

#method_before
@Test
public void retrieveEdit() throws Exception {
    RestResponse r = adminSession.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    EditInfo info = toEditInfo(false);
    assertEquals(edit.get().getRevision().get(), info.commit.commit);
    assertEquals(1, info.commit.parents.size());
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = adminSession.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
}
#method_after
@Test
public void retrieveEdit() throws Exception {
    RestResponse r = adminSession.get(urlEdit());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    EditInfo info = toEditInfo(false);
    assertThat(info.commit.commit).isEqualTo(edit.get().getRevision().get());
    assertThat(info.commit.parents).hasSize(1);
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = adminSession.get(urlEdit());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
}
#end_block

#method_before
@Test
public void retrieveFilesInEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    EditInfo info = toEditInfo(true);
    assertEquals(2, info.files.size());
    List<String> l = Lists.newArrayList(info.files.keySet());
    assertEquals("/COMMIT_MSG", l.get(0));
    assertEquals("foo", l.get(1));
}
#method_after
@Test
public void retrieveFilesInEdit() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    EditInfo info = toEditInfo(true);
    assertThat(info.files).hasSize(2);
    List<String> l = Lists.newArrayList(info.files.keySet());
    assertThat(l.get(0)).isEqualTo("/COMMIT_MSG");
    assertThat(l.get(1)).isEqualTo("foo");
}
#end_block

#method_before
@Test
public void deleteExistingFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.deleteFile(edit.get(), FILE_NAME));
    edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#method_after
@Test
public void deleteExistingFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.deleteFile(edit.get(), FILE_NAME)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#end_block

#method_before
@Test
public void createEditByDeletingExistingFileRest() throws Exception {
    RestResponse r = adminSession.delete(urlEditFile());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#method_after
@Test
public void createEditByDeletingExistingFileRest() throws Exception {
    RestResponse r = adminSession.delete(urlEditFile());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#end_block

#method_before
@Test
public void deletingNonExistingEditRest() throws Exception {
    RestResponse r = adminSession.delete(urlEdit());
    assertEquals(SC_NOT_FOUND, r.getStatusCode());
}
#method_after
@Test
public void deletingNonExistingEditRest() throws Exception {
    RestResponse r = adminSession.delete(urlEdit());
    assertThat(r.getStatusCode()).isEqualTo(SC_NOT_FOUND);
}
#end_block

#method_before
@Test
public void deleteExistingFileRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(SC_NO_CONTENT, adminSession.delete(urlEditFile()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#method_after
@Test
public void deleteExistingFileRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(adminSession.delete(urlEditFile()).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#end_block

#method_before
@Test
public void restoreDeletedFileInPatchSet() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change2, ps2));
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertEquals(RefUpdate.Result.FORCED, modifier.restoreFile(edit.get(), FILE_NAME));
    edit = editUtil.byChange(change2);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void restoreDeletedFileInPatchSet() throws Exception {
    assertThat(modifier.createEdit(change2, ps2)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertThat(modifier.restoreFile(edit.get(), FILE_NAME)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change2);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_OLD);
}
#end_block

#method_before
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Post.Input in = new Post.Input();
    in.restorePath = FILE_NAME;
    assertEquals(SC_NO_CONTENT, adminSession.post(urlEdit2(), in).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Post.Input in = new Post.Input();
    in.restorePath = FILE_NAME;
    assertThat(adminSession.post(urlEdit2(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_OLD);
}
#end_block

#method_before
@Test
public void amendExistingFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void amendExistingFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW2);
}
#end_block

#method_before
@Test
public void createAndChangeEditInOneRequestRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, adminSession.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
    in.content = RestSession.newRawInput(CONTENT_NEW2);
    assertEquals(SC_NO_CONTENT, adminSession.putRaw(urlEditFile(), in.content).getStatusCode());
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void createAndChangeEditInOneRequestRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW);
    in.content = RestSession.newRawInput(CONTENT_NEW2);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW2);
}
#end_block

#method_before
@Test
public void changeEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, adminSession.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void changeEditRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW);
}
#end_block

#method_before
@Test
public void emptyPutRequest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(SC_NO_CONTENT, adminSession.put(urlEditFile()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals("".getBytes(), toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void emptyPutRequest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(adminSession.put(urlEditFile()).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), "".getBytes());
}
#end_block

#method_before
@Test
public void createEmptyEditRest() throws Exception {
    assertEquals(SC_NO_CONTENT, adminSession.post(urlEdit()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void createEmptyEditRest() throws Exception {
    assertThat(adminSession.post(urlEdit()).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_OLD);
}
#end_block

#method_before
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, adminSession.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = adminSession.get(urlEditFile());
    assertEquals(SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(StringUtils.newStringUtf8(CONTENT_NEW2), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#method_after
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    RestResponse r = adminSession.get(urlEditFile());
    assertThat(r.getStatusCode()).isEqualTo(SC_OK);
    String content = r.getEntityContent();
    assertThat(StringUtils.newStringUtf8(Base64.decodeBase64(content))).isEqualTo(StringUtils.newStringUtf8(CONTENT_NEW2));
}
#end_block

#method_before
@Test
public void getFileNotFoundRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(SC_NO_CONTENT, adminSession.delete(urlEditFile()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
    RestResponse r = adminSession.get(urlEditFile());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
}
#method_after
@Test
public void getFileNotFoundRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(adminSession.delete(urlEditFile()).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
    RestResponse r = adminSession.get(urlEditFile());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
}
#end_block

#method_before
@Test
public void addNewFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
}
#method_after
@Test
public void addNewFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2), CONTENT_NEW);
}
#end_block

#method_before
@Test
public void addNewFileAndAmend() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
}
#method_after
@Test
public void addNewFileAndAmend() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2), CONTENT_NEW);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2), CONTENT_NEW2);
}
#end_block

#method_before
@Test
public void writeNoChanges() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    try {
        modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_OLD);
        fail();
    } catch (InvalidChangeOperationException e) {
        assertEquals("no changes were made", e.getMessage());
    }
}
#method_after
@Test
public void writeNoChanges() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    try {
        modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_OLD));
        fail();
    } catch (InvalidChangeOperationException e) {
        assertThat(e.getMessage()).isEqualTo("no changes were made");
    }
}
#end_block

#method_before
private String urlEditMessage() {
    return "/changes/" + change.getChangeId() + "/edit_message";
}
#method_after
private String urlEditMessage() {
    return "/changes/" + change.getChangeId() + "/edit:message";
}
#end_block

#method_before
private String urlPublish() {
    return "/changes/" + change.getChangeId() + "/publish_edit";
}
#method_after
private String urlPublish() {
    return "/changes/" + change.getChangeId() + "/edit:publish";
}
#end_block

#method_before
private String urlRebase() {
    return "/changes/" + change.getChangeId() + "/rebase_edit";
}
#method_after
private String urlRebase() {
    return "/changes/" + change.getChangeId() + "/edit:rebase";
}
#end_block

#method_before
private EditInfo toEditInfo(boolean files) throws IOException {
    RestResponse r = adminSession.get(files ? urlGetFiles() : urlEdit());
    assertEquals(SC_OK, r.getStatusCode());
    return newGson().fromJson(r.getReader(), EditInfo.class);
}
#method_after
private EditInfo toEditInfo(boolean files) throws IOException {
    RestResponse r = adminSession.get(files ? urlGetFiles() : urlEdit());
    assertThat(r.getStatusCode()).isEqualTo(SC_OK);
    return newGson().fromJson(r.getReader(), EditInfo.class);
}
#end_block

#method_before
public void rebaseEdit(ChangeEdit edit, PatchSet current) throws AuthException, InvalidChangeOperationException, IOException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    Change change = edit.getChange();
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    String refName = editRefName(me.getAccountId(), change.getId(), current.getId());
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        BatchRefUpdate ru = repo.getRefDatabase().newBatchUpdate();
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            RevCommit editCommit = edit.getEditCommit();
            if (editCommit.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Rebase edit against root commit not implemented");
            }
            RevCommit tip = rw.parseCommit(ObjectId.fromString(current.getRevision().get()));
            ThreeWayMerger m = MergeStrategy.RESOLVE.newMerger(repo, true);
            m.setObjectInserter(inserter);
            m.setBase(ObjectId.fromString(edit.getBasePatchSet().getRevision().get()));
            if (m.merge(tip, editCommit)) {
                ObjectId tree = m.getResultTreeId();
                CommitBuilder commit = new CommitBuilder();
                commit.setTreeId(tree);
                for (int i = 0; i < tip.getParentCount(); i++) {
                    commit.addParentId(tip.getParent(i));
                }
                commit.setAuthor(editCommit.getAuthorIdent());
                commit.setCommitter(new PersonIdent(editCommit.getCommitterIdent(), TimeUtil.nowTs()));
                commit.setMessage(editCommit.getFullMessage());
                ObjectId newEdit = inserter.insert(commit);
                inserter.flush();
                ru.addCommand(new ReceiveCommand(ObjectId.zeroId(), newEdit, refName));
                ru.addCommand(new ReceiveCommand(edit.getRef().getObjectId(), ObjectId.zeroId(), edit.getRefName()));
                ru.execute(rw, NullProgressMonitor.INSTANCE);
                for (ReceiveCommand cmd : ru.getCommands()) {
                    if (cmd.getResult() != ReceiveCommand.Result.OK) {
                        throw new IOException("failed: " + cmd);
                    }
                }
            } else {
                // TODO(davido): Allow to resolve conflicts inline
                throw new InvalidChangeOperationException("merge conflict");
            }
        } finally {
            rw.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
public void rebaseEdit(ChangeEdit edit, PatchSet current) throws AuthException, InvalidChangeOperationException, IOException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    Change change = edit.getChange();
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    String refName = editRefName(me.getAccountId(), change.getId(), current.getId());
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        BatchRefUpdate ru = repo.getRefDatabase().newBatchUpdate();
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            RevCommit editCommit = edit.getEditCommit();
            if (editCommit.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Rebase edit against root commit not supported");
            }
            RevCommit tip = rw.parseCommit(ObjectId.fromString(current.getRevision().get()));
            ThreeWayMerger m = MergeStrategy.RESOLVE.newMerger(repo, true);
            m.setObjectInserter(inserter);
            m.setBase(ObjectId.fromString(edit.getBasePatchSet().getRevision().get()));
            if (m.merge(tip, editCommit)) {
                ObjectId tree = m.getResultTreeId();
                CommitBuilder commit = new CommitBuilder();
                commit.setTreeId(tree);
                for (int i = 0; i < tip.getParentCount(); i++) {
                    commit.addParentId(tip.getParent(i));
                }
                commit.setAuthor(editCommit.getAuthorIdent());
                commit.setCommitter(new PersonIdent(editCommit.getCommitterIdent(), TimeUtil.nowTs()));
                commit.setMessage(editCommit.getFullMessage());
                ObjectId newEdit = inserter.insert(commit);
                inserter.flush();
                ru.addCommand(new ReceiveCommand(ObjectId.zeroId(), newEdit, refName));
                ru.addCommand(new ReceiveCommand(edit.getRef().getObjectId(), ObjectId.zeroId(), edit.getRefName()));
                ru.execute(rw, NullProgressMonitor.INSTANCE);
                for (ReceiveCommand cmd : ru.getCommands()) {
                    if (cmd.getResult() != ReceiveCommand.Result.OK) {
                        throw new IOException("failed: " + cmd);
                    }
                }
            } else {
                // TODO(davido): Allow to resolve conflicts inline
                throw new InvalidChangeOperationException("merge conflict");
            }
        } finally {
            rw.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
public RefUpdate.Result modifyMessage(ChangeEdit edit, String msg) throws AuthException, InvalidChangeOperationException, IOException, UnchangedCommitMessage {
    checkState(!Strings.isNullOrEmpty(msg), "message cannot be null");
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    Repository repo = gitManager.openRepository(edit.getChange().getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            String refName = edit.getRefName();
            RevCommit prevEdit = edit.getEditCommit();
            if (prevEdit.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Modify edit against root commit not implemented");
            }
            if (prevEdit.getFullMessage().equals(msg)) {
                throw new UnchangedCommitMessage("New commit message cannot be same as existing commit message");
            }
            ObjectId commit = createCommit(me, inserter, prevEdit, rw.parseCommit(prevEdit.getParent(0)), prevEdit.getTree(), msg);
            inserter.flush();
            return update(repo, me, refName, rw, prevEdit, commit);
        } finally {
            rw.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
public RefUpdate.Result modifyMessage(ChangeEdit edit, String msg) throws AuthException, InvalidChangeOperationException, IOException, UnchangedCommitMessageException {
    checkState(!Strings.isNullOrEmpty(msg), "message cannot be null");
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    RevCommit prevEdit = edit.getEditCommit();
    if (prevEdit.getParentCount() == 0) {
        throw new InvalidChangeOperationException("Modify edit against root commit not supported");
    }
    if (prevEdit.getFullMessage().equals(msg)) {
        throw new UnchangedCommitMessageException();
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    Repository repo = gitManager.openRepository(edit.getChange().getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            String refName = edit.getRefName();
            ObjectId commit = createCommit(me, inserter, prevEdit, rw.parseCommit(prevEdit.getParent(0)), prevEdit.getTree(), msg);
            inserter.flush();
            return update(repo, me, refName, rw, prevEdit, commit);
        } finally {
            rw.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
public RefUpdate.Result modifyFile(ChangeEdit edit, String file, byte[] content) throws AuthException, InvalidChangeOperationException, IOException {
    return modify(TreeOperation.CHANGE_ENTRY, edit, file, content);
}
#method_after
public RefUpdate.Result modifyFile(ChangeEdit edit, String file, RawInput content) throws AuthException, InvalidChangeOperationException, IOException {
    return modify(TreeOperation.CHANGE_ENTRY, edit, file, content);
}
#end_block

#method_before
private RefUpdate.Result modify(TreeOperation op, ChangeEdit edit, String file, byte[] content) throws AuthException, IOException, InvalidChangeOperationException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    Repository repo = gitManager.openRepository(edit.getChange().getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        ObjectReader reader = repo.newObjectReader();
        try {
            String refName = edit.getRefName();
            RevCommit prevEdit = edit.getEditCommit();
            if (prevEdit.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Modify edit against root commit not implemented");
            }
            RevCommit base = prevEdit.getParent(0);
            base = rw.parseCommit(base);
            ObjectId newTree = writeNewTree(op, rw, inserter, prevEdit, reader, file, content, base);
            if (ObjectId.equals(newTree, prevEdit.getTree())) {
                throw new InvalidChangeOperationException("no changes were made");
            }
            ObjectId commit = createCommit(me, inserter, prevEdit, base, newTree);
            inserter.flush();
            return update(repo, me, refName, rw, prevEdit, commit);
        } finally {
            rw.release();
            inserter.release();
            reader.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
private RefUpdate.Result modify(TreeOperation op, ChangeEdit edit, String file, @Nullable RawInput content) throws AuthException, IOException, InvalidChangeOperationException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    Repository repo = gitManager.openRepository(edit.getChange().getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        ObjectReader reader = repo.newObjectReader();
        try {
            String refName = edit.getRefName();
            RevCommit prevEdit = edit.getEditCommit();
            if (prevEdit.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Modify edit against root commit not supported");
            }
            RevCommit base = prevEdit.getParent(0);
            base = rw.parseCommit(base);
            ObjectId newTree = writeNewTree(op, rw, inserter, prevEdit, reader, file, toBlob(inserter, content), base);
            if (ObjectId.equals(newTree, prevEdit.getTree())) {
                throw new InvalidChangeOperationException("no changes were made");
            }
            ObjectId commit = createCommit(me, inserter, prevEdit, base, newTree);
            inserter.flush();
            return update(repo, me, refName, rw, prevEdit, commit);
        } finally {
            rw.release();
            inserter.release();
            reader.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private static ObjectId writeNewTree(TreeOperation op, RevWalk rw, ObjectInserter ins, RevCommit prevEdit, ObjectReader reader, String fileName, byte[] content, RevCommit base) throws IOException, InvalidChangeOperationException {
    DirCache newTree = createTree(reader, prevEdit);
    editTree(op, rw, base, newTree.editor(), ins, fileName, content);
    return newTree.writeTree(ins);
}
#method_after
private static ObjectId writeNewTree(TreeOperation op, RevWalk rw, ObjectInserter ins, RevCommit prevEdit, ObjectReader reader, String fileName, @Nullable final ObjectId content, RevCommit base) throws IOException, InvalidChangeOperationException {
    DirCache newTree = readTree(reader, prevEdit);
    DirCacheEditor dce = newTree.editor();
    switch(op) {
        case DELETE_ENTRY:
            dce.add(new DeletePath(fileName));
            break;
        case CHANGE_ENTRY:
            checkNotNull(content, "new content required");
            dce.add(new PathEdit(fileName) {

                @Override
                public void apply(DirCacheEntry ent) {
                    if (ent.getRawMode() == 0) {
                        ent.setFileMode(FileMode.REGULAR_FILE);
                    }
                    ent.setObjectId(content);
                }
            });
            break;
        case RESTORE_ENTRY:
            TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), fileName, base.getTree().getId());
            // from the base's parent commit.
            if (tw == null && base.getParentCount() == 1) {
                tw = TreeWalk.forPath(rw.getObjectReader(), fileName, rw.parseCommit(base.getParent(0)).getTree());
            }
            if (tw == null) {
                throw new InvalidChangeOperationException(String.format("cannot restore path %s: missing in base revision %s", fileName, base.abbreviate(8).name()));
            }
            final FileMode mode = tw.getFileMode(0);
            final ObjectId oid = tw.getObjectId(0);
            dce.add(new PathEdit(fileName) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(mode);
                    ent.setObjectId(oid);
                }
            });
            break;
    }
    dce.finish();
    return newTree.writeTree(ins);
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, IOException {
    String path = rsrc.getPath();
    if (Strings.isNullOrEmpty(path) || path.charAt(0) == '/') {
        throw new ResourceConflictException("Invalid path: " + path);
    }
    try {
        editModifier.modifyFile(rsrc.getChangeEdit(), path, ByteStreams.toByteArray(input.content.getInputStream()));
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, IOException {
    String path = rsrc.getPath();
    if (Strings.isNullOrEmpty(path) || path.charAt(0) == '/') {
        throw new ResourceConflictException("Invalid path: " + path);
    }
    try {
        editModifier.modifyFile(rsrc.getChangeEdit(), rsrc.getPath(), input.content);
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Object apply(ChangeResource rsrc, Input input) throws AuthException, IOException, InvalidChangeOperationException, BadRequestException, ResourceConflictException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (!edit.isPresent()) {
        editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId()));
        edit = editUtil.byChange(rsrc.getChange());
    }
    if (input == null || Strings.isNullOrEmpty(input.message)) {
        throw new BadRequestException("commit message must be provided");
    }
    try {
        editModifier.modifyMessage(edit.get(), input.message);
    } catch (UnchangedCommitMessage ucm) {
        throw new ResourceConflictException(ucm.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Object apply(ChangeResource rsrc, Input input) throws AuthException, IOException, InvalidChangeOperationException, BadRequestException, ResourceConflictException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (!edit.isPresent()) {
        editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId()));
        edit = editUtil.byChange(rsrc.getChange());
    }
    if (input == null || Strings.isNullOrEmpty(input.message)) {
        throw new BadRequestException("commit message must be provided");
    }
    try {
        editModifier.modifyMessage(edit.get(), input.message);
    } catch (UnchangedCommitMessageException ucm) {
        throw new ResourceConflictException(ucm.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public String apply(ChangeResource rsrc) throws AuthException, IOException, InvalidChangeOperationException, OrmException, NoSuchChangeException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    String m = edit.isPresent() ? edit.get().getEditCommit().getFullMessage() : changeUtil.getMessage(rsrc.getChange());
    return Base64.encodeBytes(m.getBytes(UTF_8));
}
#method_after
@Override
public BinaryResult apply(ChangeResource rsrc) throws AuthException, IOException, OrmException, NoSuchChangeException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    // TODO(davido): Clean this up by returning 404 when edit doesn't exist.
    // Client should call GET /changes/{id}/revisions/current/commit in this
    // case; or, to be consistent with GET content logic, the client could
    // call directly the right endpoint.
    String m = edit.isPresent() ? edit.get().getEditCommit().getFullMessage() : changeUtil.getMessage(rsrc.getChange());
    return BinaryResult.create(m).base64();
}
#end_block

#method_before
public static void getMessage(PatchSet.Id id, AsyncCallback<String> cb) {
    ChangeApi.change(id.getParentKey().get()).view("edit_message").get(wrapper(cb));
}
#method_after
public static void getMessage(PatchSet.Id id, AsyncCallback<String> cb) {
    ChangeApi.change(id.getParentKey().get()).view("edit:message").get(wrapper(cb));
}
#end_block

#method_before
public static void putMessage(Change.Id id, String m, AsyncCallback<VoidResult> r) {
    ChangeApi.change(id.get()).view("edit_message").put(m, r);
}
#method_after
public static void putMessage(Change.Id id, String m, AsyncCallback<VoidResult> r) {
    ChangeApi.change(id.get()).view("edit:message").put(m, r);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setHeaderVisible(false);
    Resources.I.style().ensureInjected();
    star.setVisible(Gerrit.isSignedIn());
    labels.init(style, statusText);
    reviewers.init(style, ccText);
    hashtags.init(style);
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                star.setValue(!star.getValue(), true);
            }
        });
        keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                reviewers.onOpenForm();
            }
        });
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setHeaderVisible(false);
    Resources.I.style().ensureInjected();
    star.setVisible(Gerrit.isSignedIn());
    labels.init(style, statusText);
    reviewers.init(style, ccText);
    hashtags.init(style);
    initReplyButton();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                star.setValue(!star.getValue(), true);
            }
        });
        keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                reviewers.onOpenForm();
            }
        });
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    db = reviewDbProvider.open();
    changeId = newChange(git, admin.getIdent());
    ps = getCurrentPatchSet(changeId);
    amendChange(git, admin.getIdent(), changeId);
    change = getChange(changeId);
    assertNotNull(ps);
    String changeId2 = newChange2(git, admin.getIdent());
    change2 = getChange(changeId2);
    assertNotNull(change2);
    ps2 = getCurrentPatchSet(changeId2);
    assertNotNull(ps2);
    final long clockStepMs = MILLISECONDS.convert(1, SECONDS);
    final AtomicLong clockMs = new AtomicLong(new DateTime(2009, 9, 30, 17, 0, 0).getMillis());
    DateTimeUtils.setCurrentMillisProvider(new MillisProvider() {

        @Override
        public long getMillis() {
            return clockMs.getAndAdd(clockStepMs);
        }
    });
}
#method_after
@Before
public void setUp() throws Exception {
    db = reviewDbProvider.open();
    changeId = newChange(git, admin.getIdent());
    ps = getCurrentPatchSet(changeId);
    amendChange(git, admin.getIdent(), changeId);
    change = getChange(changeId);
    assertThat(ps).isNotNull();
    String changeId2 = newChange2(git, admin.getIdent());
    change2 = getChange(changeId2);
    assertThat(change2).isNotNull();
    ps2 = getCurrentPatchSet(changeId2);
    assertThat(ps2).isNotNull();
    final long clockStepMs = MILLISECONDS.convert(1, SECONDS);
    final AtomicLong clockMs = new AtomicLong(new DateTime(2009, 9, 30, 17, 0, 0).getMillis());
    DateTimeUtils.setCurrentMillisProvider(new MillisProvider() {

        @Override
        public long getMillis() {
            return clockMs.getAndAdd(clockStepMs);
        }
    });
}
#end_block

#method_before
@Test
public void deleteEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    editUtil.delete(editUtil.byChange(change).get());
    assertFalse(editUtil.byChange(change).isPresent());
}
#method_after
@Test
public void deleteEdit() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.delete(editUtil.byChange(change).get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
}
#end_block

#method_before
@Test
public void publishEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, getCurrentPatchSet(changeId)));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW2));
    editUtil.publish(editUtil.byChange(change).get());
    assertFalse(editUtil.byChange(change).isPresent());
}
#method_after
@Test
public void publishEdit() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.publish(editUtil.byChange(change).get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
}
#end_block

#method_before
@Test
public void publishEditRest() throws Exception {
    PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId);
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, oldCurrentPatchSet));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = adminSession.post(urlPublish());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
    PatchSet newCurrentPatchSet = getCurrentPatchSet(changeId);
    assertFalse(oldCurrentPatchSet.getId().equals(newCurrentPatchSet.getId()));
}
#method_after
@Test
public void publishEditRest() throws Exception {
    PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId);
    assertThat(modifier.createEdit(change, oldCurrentPatchSet)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = adminSession.post(urlPublish());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
    PatchSet newCurrentPatchSet = getCurrentPatchSet(changeId);
    assertThat(oldCurrentPatchSet.getId().equals(newCurrentPatchSet.getId())).isFalse();
}
#end_block

#method_before
@Test
public void deleteEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = adminSession.delete(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void deleteEditRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = adminSession.delete(urlEdit());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
}
#end_block

#method_before
@Test
public void rebaseEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertEquals(current.getPatchSetId() - 1, edit.getBasePatchSet().getPatchSetId());
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    modifier.rebaseEdit(edit, current);
    edit = editUtil.byChange(change).get();
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME)));
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME2)));
    assertEquals(current.getPatchSetId(), edit.getBasePatchSet().getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertFalse(beforeRebase.equals(afterRebase));
}
#method_after
@Test
public void rebaseEdit() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId() - 1);
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    modifier.rebaseEdit(edit, current);
    edit = editUtil.byChange(change).get();
    assertByteArray(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME), CONTENT_NEW);
    assertByteArray(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME2), CONTENT_NEW2);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertThat(beforeRebase.equals(afterRebase)).isFalse();
}
#end_block

#method_before
@Test
public void rebaseEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertEquals(current.getPatchSetId() - 1, edit.getBasePatchSet().getPatchSetId());
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    RestResponse r = adminSession.post(urlRebase());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change).get();
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME)));
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME2)));
    assertEquals(current.getPatchSetId(), edit.getBasePatchSet().getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertFalse(beforeRebase.equals(afterRebase));
}
#method_after
@Test
public void rebaseEditRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId() - 1);
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    RestResponse r = adminSession.post(urlRebase());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change).get();
    assertByteArray(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME), CONTENT_NEW);
    assertByteArray(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME2), CONTENT_NEW2);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertThat(beforeRebase.equals(afterRebase)).isFalse();
}
#end_block

#method_before
@Test
public void updateExistingFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
    editUtil.delete(edit.get());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void updateExistingFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW);
    editUtil.delete(edit.get());
    edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
}
#end_block

#method_before
@Test
public void updateMessage() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        modifier.modifyMessage(edit.get(), edit.get().getEditCommit().getFullMessage());
        fail("InvalidChangeOperationException expected");
    } catch (Exception e) {
        assertTrue(e instanceof InvalidChangeOperationException);
        assertEquals(e.getMessage(), "New commit message cannot be same as existing commit message");
    }
    String msg = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyMessage(edit.get(), msg));
    edit = editUtil.byChange(change);
    assertEquals(msg, edit.get().getEditCommit().getFullMessage());
    editUtil.delete(edit.get());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void updateMessage() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        modifier.modifyMessage(edit.get(), edit.get().getEditCommit().getFullMessage());
        fail("InvalidChangeOperationException expected");
    } catch (InvalidChangeOperationException ex) {
        assertThat(ex.getMessage()).isEqualTo("New commit message cannot be same as existing commit message");
    }
    String msg = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
    editUtil.publish(edit.get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
}
#end_block

#method_before
@Test
public void updateMessageRest() throws Exception {
    EditMessage.Input in = new EditMessage.Input();
    in.message = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertEquals(SC_NO_CONTENT, adminSession.post(urlEditMessage(), in).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(in.message, edit.get().getEditCommit().getFullMessage());
    in.message = String.format("New commit message2\n\nChange-Id: %s", change.getKey());
    assertEquals(SC_NO_CONTENT, adminSession.post(urlEditMessage(), in).getStatusCode());
    edit = editUtil.byChange(change);
    assertEquals(in.message, edit.get().getEditCommit().getFullMessage());
    editUtil.delete(edit.get());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void updateMessageRest() throws Exception {
    EditMessage.Input in = new EditMessage.Input();
    in.message = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    in.message = String.format("New commit message2\n\nChange-Id: %s", change.getKey());
    assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
}
#end_block

#method_before
@Test
public void retrieveEdit() throws Exception {
    RestResponse r = adminSession.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    EditInfo info = toEditInfo(false);
    assertEquals(edit.get().getRevision().get(), info.commit.commit);
    assertEquals(1, info.commit.parents.size());
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = adminSession.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
}
#method_after
@Test
public void retrieveEdit() throws Exception {
    RestResponse r = adminSession.get(urlEdit());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    EditInfo info = toEditInfo(false);
    assertThat(info.commit.commit).isEqualTo(edit.get().getRevision().get());
    assertThat(info.commit.parents).hasSize(1);
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = adminSession.get(urlEdit());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
}
#end_block

#method_before
@Test
public void retrieveFilesInEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    EditInfo info = toEditInfo(true);
    assertEquals(2, info.files.size());
    List<String> l = Lists.newArrayList(info.files.keySet());
    assertEquals("/COMMIT_MSG", l.get(0));
    assertEquals("foo", l.get(1));
}
#method_after
@Test
public void retrieveFilesInEdit() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    EditInfo info = toEditInfo(true);
    assertThat(info.files).hasSize(2);
    List<String> l = Lists.newArrayList(info.files.keySet());
    assertThat(l.get(0)).isEqualTo("/COMMIT_MSG");
    assertThat(l.get(1)).isEqualTo("foo");
}
#end_block

#method_before
@Test
public void deleteExistingFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.deleteFile(edit.get(), FILE_NAME));
    edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#method_after
@Test
public void deleteExistingFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.deleteFile(edit.get(), FILE_NAME)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#end_block

#method_before
@Test
public void createEditByDeletingExistingFileRest() throws Exception {
    RestResponse r = adminSession.delete(urlEditFile());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#method_after
@Test
public void createEditByDeletingExistingFileRest() throws Exception {
    RestResponse r = adminSession.delete(urlEditFile());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#end_block

#method_before
@Test
public void deletingNonExistingEditRest() throws Exception {
    RestResponse r = adminSession.delete(urlEdit());
    assertEquals(SC_NOT_FOUND, r.getStatusCode());
}
#method_after
@Test
public void deletingNonExistingEditRest() throws Exception {
    RestResponse r = adminSession.delete(urlEdit());
    assertThat(r.getStatusCode()).isEqualTo(SC_NOT_FOUND);
}
#end_block

#method_before
@Test
public void deleteExistingFileRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(SC_NO_CONTENT, adminSession.delete(urlEditFile()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#method_after
@Test
public void deleteExistingFileRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(adminSession.delete(urlEditFile()).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#end_block

#method_before
@Test
public void restoreDeletedFileInPatchSet() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change2, ps2));
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertEquals(RefUpdate.Result.FORCED, modifier.restoreFile(edit.get(), FILE_NAME));
    edit = editUtil.byChange(change2);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void restoreDeletedFileInPatchSet() throws Exception {
    assertThat(modifier.createEdit(change2, ps2)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertThat(modifier.restoreFile(edit.get(), FILE_NAME)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change2);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_OLD);
}
#end_block

#method_before
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Post.Input in = new Post.Input();
    in.restorePath = FILE_NAME;
    assertEquals(SC_NO_CONTENT, adminSession.post(urlEdit2(), in).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Post.Input in = new Post.Input();
    in.restorePath = FILE_NAME;
    assertThat(adminSession.post(urlEdit2(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_OLD);
}
#end_block

#method_before
@Test
public void amendExistingFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void amendExistingFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW2);
}
#end_block

#method_before
@Test
public void createAndChangeEditInOneRequestRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, adminSession.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
    in.content = RestSession.newRawInput(CONTENT_NEW2);
    assertEquals(SC_NO_CONTENT, adminSession.putRaw(urlEditFile(), in.content).getStatusCode());
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void createAndChangeEditInOneRequestRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW);
    in.content = RestSession.newRawInput(CONTENT_NEW2);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW2);
}
#end_block

#method_before
@Test
public void changeEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, adminSession.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void changeEditRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW);
}
#end_block

#method_before
@Test
public void emptyPutRequest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(SC_NO_CONTENT, adminSession.put(urlEditFile()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals("".getBytes(), toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void emptyPutRequest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(adminSession.put(urlEditFile()).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), "".getBytes());
}
#end_block

#method_before
@Test
public void createEmptyEditRest() throws Exception {
    assertEquals(SC_NO_CONTENT, adminSession.post(urlEdit()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void createEmptyEditRest() throws Exception {
    assertThat(adminSession.post(urlEdit()).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_OLD);
}
#end_block

#method_before
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, adminSession.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = adminSession.get(urlEditFile());
    assertEquals(SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(StringUtils.newStringUtf8(CONTENT_NEW2), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#method_after
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    RestResponse r = adminSession.get(urlEditFile());
    assertThat(r.getStatusCode()).isEqualTo(SC_OK);
    String content = r.getEntityContent();
    assertThat(StringUtils.newStringUtf8(Base64.decodeBase64(content))).isEqualTo(StringUtils.newStringUtf8(CONTENT_NEW2));
}
#end_block

#method_before
@Test
public void getFileNotFoundRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(SC_NO_CONTENT, adminSession.delete(urlEditFile()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
    RestResponse r = adminSession.get(urlEditFile());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
}
#method_after
@Test
public void getFileNotFoundRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(adminSession.delete(urlEditFile()).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
    RestResponse r = adminSession.get(urlEditFile());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
}
#end_block

#method_before
@Test
public void addNewFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
}
#method_after
@Test
public void addNewFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2), CONTENT_NEW);
}
#end_block

#method_before
@Test
public void addNewFileAndAmend() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
}
#method_after
@Test
public void addNewFileAndAmend() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2), CONTENT_NEW);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2), CONTENT_NEW2);
}
#end_block

#method_before
@Test
public void writeNoChanges() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    try {
        modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_OLD);
        fail();
    } catch (InvalidChangeOperationException e) {
        assertEquals("no changes were made", e.getMessage());
    }
}
#method_after
@Test
public void writeNoChanges() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    try {
        modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_OLD));
        fail();
    } catch (InvalidChangeOperationException e) {
        assertThat(e.getMessage()).isEqualTo("no changes were made");
    }
}
#end_block

#method_before
private String urlEditMessage() {
    return "/changes/" + change.getChangeId() + "/edit_message";
}
#method_after
private String urlEditMessage() {
    return "/changes/" + change.getChangeId() + "/edit:message";
}
#end_block

#method_before
private String urlPublish() {
    return "/changes/" + change.getChangeId() + "/publish_edit";
}
#method_after
private String urlPublish() {
    return "/changes/" + change.getChangeId() + "/edit:publish";
}
#end_block

#method_before
private String urlRebase() {
    return "/changes/" + change.getChangeId() + "/rebase_edit";
}
#method_after
private String urlRebase() {
    return "/changes/" + change.getChangeId() + "/edit:rebase";
}
#end_block

#method_before
private EditInfo toEditInfo(boolean files) throws IOException {
    RestResponse r = adminSession.get(files ? urlGetFiles() : urlEdit());
    assertEquals(SC_OK, r.getStatusCode());
    return newGson().fromJson(r.getReader(), EditInfo.class);
}
#method_after
private EditInfo toEditInfo(boolean files) throws IOException {
    RestResponse r = adminSession.get(files ? urlGetFiles() : urlEdit());
    assertThat(r.getStatusCode()).isEqualTo(SC_OK);
    return newGson().fromJson(r.getReader(), EditInfo.class);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "publish_edit").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "rebase_edit").to(RebaseChangeEdit.class);
    post(CHANGE_KIND, "edit_message").to(ChangeEdits.EditMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteFile.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteFile.Factory.class);
        }
    });
}
#end_block

#method_before
private Optional<ChangeEdit> createEdit() throws AuthException, IOException, ResourceConflictException, OrmException, InvalidChangeOperationException {
    editModifier.createEdit(change, db.get().patchSets().get(change.currentPatchSetId()));
    return editUtil.byChange(change);
}
#method_after
private Optional<ChangeEdit> createEdit() throws AuthException, IOException, ResourceConflictException, OrmException {
    editModifier.createEdit(change, db.get().patchSets().get(change.currentPatchSetId()));
    return editUtil.byChange(change);
}
#end_block

#method_before
private Optional<ChangeEdit> createEdit(Change change) throws AuthException, IOException, ResourceConflictException, OrmException, InvalidChangeOperationException {
    editModifier.createEdit(change, db.get().patchSets().get(change.currentPatchSetId()));
    return editUtil.byChange(change);
}
#method_after
private Optional<ChangeEdit> createEdit(Change change) throws AuthException, IOException, ResourceConflictException, OrmException {
    editModifier.createEdit(change, db.get().patchSets().get(change.currentPatchSetId()));
    return editUtil.byChange(change);
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, IOException {
    try {
        editModifier.modifyFile(rsrc.getChangeEdit(), rsrc.getPath(), ByteStreams.toByteArray(input.content.getInputStream()));
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, IOException {
    try {
        editModifier.modifyFile(rsrc.getChangeEdit(), rsrc.getPath(), input.content);
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Object apply(ChangeResource rsrc, Input input) throws AuthException, IOException, InvalidChangeOperationException, ResourceConflictException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (!edit.isPresent()) {
        editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId()));
        edit = editUtil.byChange(rsrc.getChange());
    }
    if (input != null && !Strings.isNullOrEmpty(input.message)) {
        editModifier.modifyMessage(edit.get(), input.message);
    }
    return Response.none();
}
#method_after
@Override
public Object apply(ChangeResource rsrc, Input input) throws AuthException, IOException, InvalidChangeOperationException, BadRequestException, ResourceConflictException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (!edit.isPresent()) {
        editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId()));
        edit = editUtil.byChange(rsrc.getChange());
    }
    if (input == null || Strings.isNullOrEmpty(input.message)) {
        throw new BadRequestException("commit message must be provided");
    }
    editModifier.modifyMessage(edit.get(), input.message);
    return Response.none();
}
#end_block

#method_before
public void rebaseEdit(ChangeEdit edit, PatchSet current) throws AuthException, InvalidChangeOperationException, IOException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    Change change = edit.getChange();
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    String refName = editRefName(me.getAccountId(), change.getId(), current.getId());
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        BatchRefUpdate ru = repo.getRefDatabase().newBatchUpdate();
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            RevCommit editCommit = edit.getEditCommit();
            if (editCommit.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Rebase edit against root commit not implemented");
            }
            RevCommit tip = rw.parseCommit(ObjectId.fromString(current.getRevision().get()));
            ThreeWayMerger m = MergeStrategy.RESOLVE.newMerger(repo, true);
            m.setObjectInserter(inserter);
            m.setBase(ObjectId.fromString(edit.getBasePatchSet().getRevision().get()));
            if (m.merge(tip, editCommit)) {
                ObjectId tree = m.getResultTreeId();
                CommitBuilder commit = new CommitBuilder();
                commit.setTreeId(tree);
                for (int i = 0; i < tip.getParentCount(); i++) {
                    commit.addParentId(tip.getParent(i));
                }
                commit.setAuthor(editCommit.getAuthorIdent());
                commit.setCommitter(new PersonIdent(editCommit.getCommitterIdent(), TimeUtil.nowTs()));
                commit.setMessage(editCommit.getFullMessage());
                ObjectId newEdit = inserter.insert(commit);
                inserter.flush();
                ru.addCommand(new ReceiveCommand(ObjectId.zeroId(), newEdit, refName));
                ru.addCommand(new ReceiveCommand(edit.getRef().getObjectId(), ObjectId.zeroId(), edit.getRefName()));
                ru.execute(rw, NullProgressMonitor.INSTANCE);
                for (ReceiveCommand cmd : ru.getCommands()) {
                    if (cmd.getResult() != ReceiveCommand.Result.OK) {
                        throw new IOException("failed: " + cmd);
                    }
                }
            } else {
                // TODO(davido): Allow to resolve conflicts inline
                throw new InvalidChangeOperationException("merge conflict");
            }
        } finally {
            rw.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
public void rebaseEdit(ChangeEdit edit, PatchSet current) throws AuthException, InvalidChangeOperationException, IOException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    Change change = edit.getChange();
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    String refName = editRefName(me.getAccountId(), change.getId(), current.getId());
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        BatchRefUpdate ru = repo.getRefDatabase().newBatchUpdate();
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            RevCommit editCommit = edit.getEditCommit();
            if (editCommit.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Rebase edit against root commit not supported");
            }
            RevCommit tip = rw.parseCommit(ObjectId.fromString(current.getRevision().get()));
            ThreeWayMerger m = MergeStrategy.RESOLVE.newMerger(repo, true);
            m.setObjectInserter(inserter);
            m.setBase(ObjectId.fromString(edit.getBasePatchSet().getRevision().get()));
            if (m.merge(tip, editCommit)) {
                ObjectId tree = m.getResultTreeId();
                CommitBuilder commit = new CommitBuilder();
                commit.setTreeId(tree);
                for (int i = 0; i < tip.getParentCount(); i++) {
                    commit.addParentId(tip.getParent(i));
                }
                commit.setAuthor(editCommit.getAuthorIdent());
                commit.setCommitter(new PersonIdent(editCommit.getCommitterIdent(), TimeUtil.nowTs()));
                commit.setMessage(editCommit.getFullMessage());
                ObjectId newEdit = inserter.insert(commit);
                inserter.flush();
                ru.addCommand(new ReceiveCommand(ObjectId.zeroId(), newEdit, refName));
                ru.addCommand(new ReceiveCommand(edit.getRef().getObjectId(), ObjectId.zeroId(), edit.getRefName()));
                ru.execute(rw, NullProgressMonitor.INSTANCE);
                for (ReceiveCommand cmd : ru.getCommands()) {
                    if (cmd.getResult() != ReceiveCommand.Result.OK) {
                        throw new IOException("failed: " + cmd);
                    }
                }
            } else {
                // TODO(davido): Allow to resolve conflicts inline
                throw new InvalidChangeOperationException("merge conflict");
            }
        } finally {
            rw.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
public RefUpdate.Result modifyMessage(ChangeEdit edit, String msg) throws AuthException, InvalidChangeOperationException, IOException {
    checkState(!Strings.isNullOrEmpty(msg), "message cannot be null");
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    Repository repo = gitManager.openRepository(edit.getChange().getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            String refName = edit.getRefName();
            RevCommit prevEdit = edit.getEditCommit();
            if (prevEdit.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Modify edit against root commit not implemented");
            }
            if (prevEdit.getFullMessage().equals(msg)) {
                throw new InvalidChangeOperationException("New commit message cannot be same as existing commit message");
            }
            ObjectId commit = createCommit(me, inserter, prevEdit, rw.parseCommit(prevEdit.getParent(0)), prevEdit.getTree(), msg);
            inserter.flush();
            return update(repo, me, refName, rw, prevEdit, commit);
        } finally {
            rw.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
public RefUpdate.Result modifyMessage(ChangeEdit edit, String msg) throws AuthException, InvalidChangeOperationException, IOException {
    checkState(!Strings.isNullOrEmpty(msg), "message cannot be null");
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    RevCommit prevEdit = edit.getEditCommit();
    if (prevEdit.getParentCount() == 0) {
        throw new InvalidChangeOperationException("Modify edit against root commit not supported");
    }
    if (prevEdit.getFullMessage().equals(msg)) {
        throw new InvalidChangeOperationException("New commit message cannot be same as existing commit message");
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    Repository repo = gitManager.openRepository(edit.getChange().getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            String refName = edit.getRefName();
            ObjectId commit = createCommit(me, inserter, prevEdit, rw.parseCommit(prevEdit.getParent(0)), prevEdit.getTree(), msg);
            inserter.flush();
            return update(repo, me, refName, rw, prevEdit, commit);
        } finally {
            rw.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
public RefUpdate.Result modifyFile(ChangeEdit edit, String file, byte[] content) throws AuthException, InvalidChangeOperationException, IOException {
    return modify(TreeOperation.CHANGE_ENTRY, edit, file, content);
}
#method_after
public RefUpdate.Result modifyFile(ChangeEdit edit, String file, RawInput content) throws AuthException, InvalidChangeOperationException, IOException {
    return modify(TreeOperation.CHANGE_ENTRY, edit, file, content);
}
#end_block

#method_before
private RefUpdate.Result modify(TreeOperation op, ChangeEdit edit, String file, byte[] content) throws AuthException, IOException, InvalidChangeOperationException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    Repository repo = gitManager.openRepository(edit.getChange().getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        ObjectReader reader = repo.newObjectReader();
        try {
            String refName = edit.getRefName();
            RevCommit prevEdit = edit.getEditCommit();
            if (prevEdit.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Modify edit against root commit not implemented");
            }
            RevCommit base = prevEdit.getParent(0);
            base = rw.parseCommit(base);
            ObjectId newTree = writeNewTree(op, repo, rw, inserter, prevEdit, reader, file, content, base);
            if (ObjectId.equals(newTree, prevEdit.getTree())) {
                throw new InvalidChangeOperationException("no changes were made");
            }
            ObjectId commit = createCommit(me, inserter, prevEdit, base, newTree);
            inserter.flush();
            return update(repo, me, refName, rw, prevEdit, commit);
        } finally {
            rw.release();
            inserter.release();
            reader.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
private RefUpdate.Result modify(TreeOperation op, ChangeEdit edit, String file, @Nullable RawInput content) throws AuthException, IOException, InvalidChangeOperationException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    Repository repo = gitManager.openRepository(edit.getChange().getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        ObjectReader reader = repo.newObjectReader();
        try {
            String refName = edit.getRefName();
            RevCommit prevEdit = edit.getEditCommit();
            if (prevEdit.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Modify edit against root commit not supported");
            }
            RevCommit base = prevEdit.getParent(0);
            base = rw.parseCommit(base);
            ObjectId newTree = writeNewTree(op, rw, inserter, prevEdit, reader, file, toBlob(inserter, content), base);
            if (ObjectId.equals(newTree, prevEdit.getTree())) {
                throw new InvalidChangeOperationException("no changes were made");
            }
            ObjectId commit = createCommit(me, inserter, prevEdit, base, newTree);
            inserter.flush();
            return update(repo, me, refName, rw, prevEdit, commit);
        } finally {
            rw.release();
            inserter.release();
            reader.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private static ObjectId writeNewTree(TreeOperation op, Repository repo, RevWalk rw, ObjectInserter ins, RevCommit prevEdit, ObjectReader reader, String fileName, byte[] content, RevCommit base) throws IOException, InvalidChangeOperationException {
    DirCache newTree = createTree(reader, prevEdit);
    editTree(op, repo, rw, base, newTree.editor(), ins, fileName, content);
    return newTree.writeTree(ins);
}
#method_after
private static ObjectId writeNewTree(TreeOperation op, RevWalk rw, ObjectInserter ins, RevCommit prevEdit, ObjectReader reader, String fileName, @Nullable final ObjectId content, RevCommit base) throws IOException, InvalidChangeOperationException {
    DirCache newTree = readTree(reader, prevEdit);
    DirCacheEditor dce = newTree.editor();
    switch(op) {
        case DELETE_ENTRY:
            dce.add(new DeletePath(fileName));
            break;
        case CHANGE_ENTRY:
            checkNotNull(content, "new content required");
            dce.add(new PathEdit(fileName) {

                @Override
                public void apply(DirCacheEntry ent) {
                    if (ent.getRawMode() == 0) {
                        ent.setFileMode(FileMode.REGULAR_FILE);
                    }
                    ent.setObjectId(content);
                }
            });
            break;
        case RESTORE_ENTRY:
            TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), fileName, base.getTree().getId());
            // from the base's parent commit.
            if (tw == null && base.getParentCount() == 1) {
                tw = TreeWalk.forPath(rw.getObjectReader(), fileName, rw.parseCommit(base.getParent(0)).getTree());
            }
            if (tw == null) {
                throw new InvalidChangeOperationException(String.format("cannot restore path %s: missing in base revision %s", fileName, base.abbreviate(8).name()));
            }
            final FileMode mode = tw.getFileMode(0);
            final ObjectId oid = tw.getObjectId(0);
            dce.add(new PathEdit(fileName) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(mode);
                    ent.setObjectId(oid);
                }
            });
            break;
    }
    dce.finish();
    return newTree.writeTree(ins);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    db = reviewDbProvider.open();
    changeId = newChange(git, admin.getIdent());
    ps = getCurrentPatchSet(changeId);
    amendChange(git, admin.getIdent(), changeId);
    change = getChange(changeId);
    assertNotNull(ps);
    String changeId2 = newChange2(git, admin.getIdent());
    change2 = getChange(changeId2);
    assertNotNull(change2);
    ps2 = getCurrentPatchSet(changeId2);
    assertNotNull(ps2);
    final long clockStepMs = MILLISECONDS.convert(1, SECONDS);
    final AtomicLong clockMs = new AtomicLong(new DateTime(2009, 9, 30, 17, 0, 0).getMillis());
    DateTimeUtils.setCurrentMillisProvider(new MillisProvider() {

        @Override
        public long getMillis() {
            return clockMs.getAndAdd(clockStepMs);
        }
    });
}
#method_after
@Before
public void setUp() throws Exception {
    db = reviewDbProvider.open();
    changeId = newChange(git, admin.getIdent());
    ps = getCurrentPatchSet(changeId);
    amendChange(git, admin.getIdent(), changeId);
    change = getChange(changeId);
    assertThat(ps).isNotNull();
    String changeId2 = newChange2(git, admin.getIdent());
    change2 = getChange(changeId2);
    assertThat(change2).isNotNull();
    ps2 = getCurrentPatchSet(changeId2);
    assertThat(ps2).isNotNull();
    final long clockStepMs = MILLISECONDS.convert(1, SECONDS);
    final AtomicLong clockMs = new AtomicLong(new DateTime(2009, 9, 30, 17, 0, 0).getMillis());
    DateTimeUtils.setCurrentMillisProvider(new MillisProvider() {

        @Override
        public long getMillis() {
            return clockMs.getAndAdd(clockStepMs);
        }
    });
}
#end_block

#method_before
@Test
public void deleteEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    editUtil.delete(editUtil.byChange(change).get());
    assertFalse(editUtil.byChange(change).isPresent());
}
#method_after
@Test
public void deleteEdit() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.delete(editUtil.byChange(change).get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
}
#end_block

#method_before
@Test
public void publishEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, getCurrentPatchSet(changeId)));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW2));
    editUtil.publish(editUtil.byChange(change).get());
    assertFalse(editUtil.byChange(change).isPresent());
}
#method_after
@Test
public void publishEdit() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.publish(editUtil.byChange(change).get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
}
#end_block

#method_before
@Test
public void publishEditRest() throws Exception {
    PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId);
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, oldCurrentPatchSet));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = adminSession.post(urlPublish());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
    PatchSet newCurrentPatchSet = getCurrentPatchSet(changeId);
    assertFalse(oldCurrentPatchSet.getId().equals(newCurrentPatchSet.getId()));
}
#method_after
@Test
public void publishEditRest() throws Exception {
    PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId);
    assertThat(modifier.createEdit(change, oldCurrentPatchSet)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = adminSession.post(urlPublish());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
    PatchSet newCurrentPatchSet = getCurrentPatchSet(changeId);
    assertThat(oldCurrentPatchSet.getId().equals(newCurrentPatchSet.getId())).isFalse();
}
#end_block

#method_before
@Test
public void deleteEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = adminSession.delete(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void deleteEditRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = adminSession.delete(urlEdit());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
}
#end_block

#method_before
@Test
public void rebaseEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertEquals(current.getPatchSetId() - 1, edit.getBasePatchSet().getPatchSetId());
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    modifier.rebaseEdit(edit, current);
    edit = editUtil.byChange(change).get();
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME)));
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME2)));
    assertEquals(current.getPatchSetId(), edit.getBasePatchSet().getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertFalse(beforeRebase.equals(afterRebase));
}
#method_after
@Test
public void rebaseEdit() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId() - 1);
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    modifier.rebaseEdit(edit, current);
    edit = editUtil.byChange(change).get();
    assertByteArray(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME), CONTENT_NEW);
    assertByteArray(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME2), CONTENT_NEW2);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertThat(beforeRebase.equals(afterRebase)).isFalse();
}
#end_block

#method_before
@Test
public void rebaseEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertEquals(current.getPatchSetId() - 1, edit.getBasePatchSet().getPatchSetId());
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    RestResponse r = adminSession.post(urlRebase());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change).get();
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME)));
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME2)));
    assertEquals(current.getPatchSetId(), edit.getBasePatchSet().getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertFalse(beforeRebase.equals(afterRebase));
}
#method_after
@Test
public void rebaseEditRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId() - 1);
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    RestResponse r = adminSession.post(urlRebase());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change).get();
    assertByteArray(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME), CONTENT_NEW);
    assertByteArray(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), FILE_NAME2), CONTENT_NEW2);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertThat(beforeRebase.equals(afterRebase)).isFalse();
}
#end_block

#method_before
@Test
public void updateExistingFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
    editUtil.delete(edit.get());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void updateExistingFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW);
    editUtil.delete(edit.get());
    edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
}
#end_block

#method_before
@Test
public void updateMessage() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        modifier.modifyMessage(edit.get(), edit.get().getEditCommit().getFullMessage());
        fail("Exception expected");
    } catch (InvalidChangeOperationException ex) {
        assertEquals(ex.getMessage(), "New commit message cannot be same as existing commit message");
    }
    String msg = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyMessage(edit.get(), msg));
    edit = editUtil.byChange(change);
    assertEquals(msg, edit.get().getEditCommit().getFullMessage());
    editUtil.delete(edit.get());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void updateMessage() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        modifier.modifyMessage(edit.get(), edit.get().getEditCommit().getFullMessage());
        fail("InvalidChangeOperationException expected");
    } catch (InvalidChangeOperationException ex) {
        assertThat(ex.getMessage()).isEqualTo("New commit message cannot be same as existing commit message");
    }
    String msg = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
    editUtil.publish(edit.get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
}
#end_block

#method_before
@Test
public void retrieveEdit() throws Exception {
    RestResponse r = adminSession.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    EditInfo info = toEditInfo(false);
    assertEquals(edit.get().getRevision().get(), info.commit.commit);
    assertEquals(1, info.commit.parents.size());
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = adminSession.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
}
#method_after
@Test
public void retrieveEdit() throws Exception {
    RestResponse r = adminSession.get(urlEdit());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    EditInfo info = toEditInfo(false);
    assertThat(info.commit.commit).isEqualTo(edit.get().getRevision().get());
    assertThat(info.commit.parents).hasSize(1);
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = adminSession.get(urlEdit());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
}
#end_block

#method_before
@Test
public void retrieveFilesInEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    EditInfo info = toEditInfo(true);
    assertEquals(2, info.files.size());
    List<String> l = Lists.newArrayList(info.files.keySet());
    assertEquals("/COMMIT_MSG", l.get(0));
    assertEquals("foo", l.get(1));
}
#method_after
@Test
public void retrieveFilesInEdit() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    EditInfo info = toEditInfo(true);
    assertThat(info.files).hasSize(2);
    List<String> l = Lists.newArrayList(info.files.keySet());
    assertThat(l.get(0)).isEqualTo("/COMMIT_MSG");
    assertThat(l.get(1)).isEqualTo("foo");
}
#end_block

#method_before
@Test
public void deleteExistingFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.deleteFile(edit.get(), FILE_NAME));
    edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#method_after
@Test
public void deleteExistingFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.deleteFile(edit.get(), FILE_NAME)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#end_block

#method_before
@Test
public void createEditByDeletingExistingFileRest() throws Exception {
    RestResponse r = adminSession.delete(urlEditFile());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#method_after
@Test
public void createEditByDeletingExistingFileRest() throws Exception {
    RestResponse r = adminSession.delete(urlEditFile());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#end_block

#method_before
@Test
public void deletingNonExistingEditRest() throws Exception {
    RestResponse r = adminSession.delete(urlEdit());
    assertEquals(SC_NOT_FOUND, r.getStatusCode());
}
#method_after
@Test
public void deletingNonExistingEditRest() throws Exception {
    RestResponse r = adminSession.delete(urlEdit());
    assertThat(r.getStatusCode()).isEqualTo(SC_NOT_FOUND);
}
#end_block

#method_before
@Test
public void deleteExistingFileRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(SC_NO_CONTENT, adminSession.delete(urlEditFile()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#method_after
@Test
public void deleteExistingFileRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(adminSession.delete(urlEditFile()).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
}
#end_block

#method_before
@Test
public void restoreDeletedFileInPatchSet() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change2, ps2));
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertEquals(RefUpdate.Result.FORCED, modifier.restoreFile(edit.get(), FILE_NAME));
    edit = editUtil.byChange(change2);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void restoreDeletedFileInPatchSet() throws Exception {
    assertThat(modifier.createEdit(change2, ps2)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertThat(modifier.restoreFile(edit.get(), FILE_NAME)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change2);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_OLD);
}
#end_block

#method_before
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Post.Input in = new Post.Input();
    in.restorePath = FILE_NAME;
    assertEquals(SC_NO_CONTENT, adminSession.post(urlEdit2(), in).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Post.Input in = new Post.Input();
    in.restorePath = FILE_NAME;
    assertThat(adminSession.post(urlEdit2(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_OLD);
}
#end_block

#method_before
@Test
public void amendExistingFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void amendExistingFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW2);
}
#end_block

#method_before
@Test
public void createAndChangeEditInOneRequestRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, adminSession.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
    in.content = RestSession.newRawInput(CONTENT_NEW2);
    assertEquals(SC_NO_CONTENT, adminSession.putRaw(urlEditFile(), in.content).getStatusCode());
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void createAndChangeEditInOneRequestRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW);
    in.content = RestSession.newRawInput(CONTENT_NEW2);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW2);
}
#end_block

#method_before
@Test
public void changeEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, adminSession.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void changeEditRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_NEW);
}
#end_block

#method_before
@Test
public void emptyPutRequest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(SC_NO_CONTENT, adminSession.put(urlEditFile()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals("".getBytes(), toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void emptyPutRequest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(adminSession.put(urlEditFile()).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), "".getBytes());
}
#end_block

#method_before
@Test
public void createEmptyEditRest() throws Exception {
    assertEquals(SC_NO_CONTENT, adminSession.post(urlEdit()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void createEmptyEditRest() throws Exception {
    assertThat(adminSession.post(urlEdit()).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME), CONTENT_OLD);
}
#end_block

#method_before
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, adminSession.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = adminSession.get(urlEditFile());
    assertEquals(SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(StringUtils.newStringUtf8(CONTENT_NEW2), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#method_after
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    RestResponse r = adminSession.get(urlEditFile());
    assertThat(r.getStatusCode()).isEqualTo(SC_OK);
    String content = r.getEntityContent();
    assertThat(StringUtils.newStringUtf8(Base64.decodeBase64(content))).isEqualTo(StringUtils.newStringUtf8(CONTENT_NEW2));
}
#end_block

#method_before
@Test
public void getFileNotFoundRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(SC_NO_CONTENT, adminSession.delete(urlEditFile()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
    RestResponse r = adminSession.get(urlEditFile());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
}
#method_after
@Test
public void getFileNotFoundRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(adminSession.delete(urlEditFile()).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME);
        fail("ResourceNotFoundException expected");
    } catch (ResourceNotFoundException rnfe) {
    }
    RestResponse r = adminSession.get(urlEditFile());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
}
#end_block

#method_before
@Test
public void addNewFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
}
#method_after
@Test
public void addNewFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2), CONTENT_NEW);
}
#end_block

#method_before
@Test
public void addNewFileAndAmend() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
}
#method_after
@Test
public void addNewFileAndAmend() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2), CONTENT_NEW);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2), CONTENT_NEW2);
}
#end_block

#method_before
@Test
public void writeNoChanges() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    try {
        modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_OLD);
        fail();
    } catch (InvalidChangeOperationException e) {
        assertEquals("no changes were made", e.getMessage());
    }
}
#method_after
@Test
public void writeNoChanges() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    try {
        modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_OLD));
        fail();
    } catch (InvalidChangeOperationException e) {
        assertThat(e.getMessage()).isEqualTo("no changes were made");
    }
}
#end_block

#method_before
private String urlPublish() {
    return "/changes/" + change.getChangeId() + "/publish_edit";
}
#method_after
private String urlPublish() {
    return "/changes/" + change.getChangeId() + "/edit:publish";
}
#end_block

#method_before
private String urlRebase() {
    return "/changes/" + change.getChangeId() + "/rebase_edit";
}
#method_after
private String urlRebase() {
    return "/changes/" + change.getChangeId() + "/edit:rebase";
}
#end_block

#method_before
private EditInfo toEditInfo(boolean files) throws IOException {
    RestResponse r = adminSession.get(files ? urlGetFiles() : urlEdit());
    assertEquals(SC_OK, r.getStatusCode());
    return newGson().fromJson(r.getReader(), EditInfo.class);
}
#method_after
private EditInfo toEditInfo(boolean files) throws IOException {
    RestResponse r = adminSession.get(files ? urlGetFiles() : urlEdit());
    assertThat(r.getStatusCode()).isEqualTo(SC_OK);
    return newGson().fromJson(r.getReader(), EditInfo.class);
}
#end_block

#method_before
@Override
public void start() {
    if (config.getBoolean("cache", "projects", "loadOnStartup", false)) {
        ScheduledThreadPoolExecutor pool = new ScheduledThreadPoolExecutor(config.getInt("cache", "projects", "ThreadPoolSize", Runtime.getRuntime().availableProcessors()), new ThreadFactoryBuilder().setNameFormat("ProjectCacheLoader-%d").build());
        log.info("Loading project cache");
        for (final Project.NameKey name : cache.all()) {
            pool.execute(new Runnable() {

                @Override
                public void run() {
                    cache.get(name);
                }
            });
        }
        pool.shutdown();
    }
}
#method_after
@Override
public void start() {
    int cpus = Runtime.getRuntime().availableProcessors();
    if (config.getBoolean("cache", "projects", "loadOnStartup", false)) {
        final ThreadPoolExecutor pool = new ScheduledThreadPoolExecutor(config.getInt("cache", "projects", "loadThreads", cpus), new ThreadFactoryBuilder().setNameFormat("ProjectCacheLoader-%d").build());
        log.info("Loading project cache");
        pool.execute(new Runnable() {

            @Override
            public void run() {
                for (final Project.NameKey name : cache.all()) {
                    pool.execute(new Runnable() {

                        @Override
                        public void run() {
                            cache.get(name);
                        }
                    });
                }
                pool.shutdown();
            }
        });
    }
}
#end_block

#method_before
public void evict(final Project.NameKey p) {
    if (p != null) {
        byName.invalidate(p.get());
    }
}
#method_after
@Override
public void evict(final Project.NameKey p) {
    if (p != null) {
        byName.invalidate(p.get());
    }
}
#end_block

#method_before
protected void assertApproved(String changeId) throws IOException {
    ChangeInfo c = getChange(changeId, DETAILED_LABELS);
    LabelInfo cr = c.labels.get("Code-Review");
    assertEquals(1, cr.all.size());
    assertEquals(2, cr.all.get(0).value.intValue());
    assertEquals("Administrator", cr.all.get(0).name);
}
#method_after
protected void assertApproved(String changeId) throws IOException {
    ChangeInfo c = getChange(changeId, DETAILED_LABELS);
    LabelInfo cr = c.labels.get("Code-Review");
    assertEquals(1, cr.all.size());
    assertEquals(2, cr.all.get(0).value.intValue());
    assertEquals(admin.getId(), new Account.Id(cr.all.get(0)._accountId));
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = statusToChangeStatus(in.getStatus());
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, cd, out.project, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(changeViews, new ChangeResource(ctl), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
        if (userProvider.get().isIdentifiedUser() && in.getStatus().isOpen()) {
            UiAction.Description descr = new UiAction.Description();
            PrivateInternals_UiActionDescription.setId(descr, "followup");
            PrivateInternals_UiActionDescription.setMethod(descr, "POST");
            descr.setTitle("Create follow-up change");
            out.actions.put(descr.getId(), new ActionInfo(descr));
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, cd, out.project, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(changeViews, new ChangeResource(ctl), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
        if (userProvider.get().isIdentifiedUser() && in.getStatus().isOpen()) {
            UiAction.Description descr = new UiAction.Description();
            PrivateInternals_UiActionDescription.setId(descr, "followup");
            PrivateInternals_UiActionDescription.setMethod(descr, "POST");
            descr.setTitle("Create follow-up change");
            out.actions.put(descr.getId(), new ActionInfo(descr));
        }
    }
    return out;
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, String project) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(new ChangeResource(ctl), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = plcUtil.draftByPatchSetAuthor(db.get(), in.getId(), user.getAccountId(), ctl.getNotes()).iterator().hasNext() ? true : null;
    }
    if (has(WEB_LINKS)) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, in.getRevision().get());
        out.webLinks = links.isEmpty() ? null : links.toList();
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, String project) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(new ChangeResource(ctl), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = plcUtil.draftByPatchSetAuthor(db.get(), in.getId(), user.getAccountId(), ctl.getNotes()).iterator().hasNext() ? true : null;
    }
    if (has(WEB_LINKS)) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, in.getRevision().get());
        out.webLinks = links.isEmpty() ? null : links.toList();
    }
    return out;
}
#end_block

#method_before
private static void finish(ChangeInfo info) {
    info.id = Joiner.on('~').join(Url.encode(info.project), Url.encode(info.branch), Url.encode(info.changeId));
}
#method_after
static void finish(ChangeInfo info) {
    info.id = Joiner.on('~').join(Url.encode(info.project), Url.encode(info.branch), Url.encode(info.changeId));
}
#end_block

#method_before
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws AuthException, OrmException, BadRequestException, UnprocessableEntityException, IOException, InvalidChangeOperationException, ResourceNotFoundException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
    }
    String refName = input.branch;
    if (!refName.startsWith(Constants.R_REFS)) {
        refName = Constants.R_HEADS + input.branch;
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    Repository git = gitManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(git);
        try {
            ObjectId parentCommit;
            if (input.baseChange != null) {
                List<Change> changes = changeUtil.findChanges(input.baseChange);
                if (changes.isEmpty()) {
                    throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
                }
                Change change = Iterables.getOnlyElement(changes);
                PatchSet ps = db.get().patchSets().get(new PatchSet.Id(change.getId(), change.currentPatchSetId().get()));
                parentCommit = ObjectId.fromString(ps.getRevision().get());
            } else {
                Ref destRef = git.getRef(refName);
                if (destRef == null) {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
                parentCommit = destRef.getObjectId();
            }
            RevCommit mergeTip = rw.parseCommit(parentCommit);
            Timestamp now = TimeUtil.nowTs();
            IdentifiedUser me = (IdentifiedUser) userProvider.get();
            PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
            ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(git, rw, author, mergeTip, commitMessage);
            Change change = new Change(getChangeId(id, c), new Change.Id(db.get().nextChangeId()), me.getAccountId(), new Branch.NameKey(project, refName), now);
            ChangeInserter ins = changeInserterFactory.create(refControl, change, c);
            validateCommit(git, refControl, c, me, ins);
            updateRef(git, rw, c, change, ins.getPatchSet());
            change.setTopic(input.topic);
            change.setStatus(ChangeJson.changeStatusToStatus(input.status));
            ins.insert();
            return Response.created(json.format(change.getId()));
        } finally {
            rw.release();
        }
    } finally {
        git.close();
    }
}
#method_after
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws AuthException, OrmException, BadRequestException, UnprocessableEntityException, IOException, InvalidChangeOperationException, ResourceNotFoundException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
    }
    String refName = input.branch;
    if (!refName.startsWith(Constants.R_REFS)) {
        refName = Constants.R_HEADS + input.branch;
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    Repository git = gitManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(git);
        try {
            ObjectId parentCommit;
            if (input.baseChange != null) {
                List<Change> changes = changeUtil.findChanges(input.baseChange);
                if (changes.isEmpty()) {
                    throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
                }
                Change change = Iterables.getOnlyElement(changes);
                PatchSet ps = db.get().patchSets().get(new PatchSet.Id(change.getId(), change.currentPatchSetId().get()));
                parentCommit = ObjectId.fromString(ps.getRevision().get());
            } else {
                Ref destRef = git.getRef(refName);
                if (destRef == null) {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
                parentCommit = destRef.getObjectId();
            }
            RevCommit mergeTip = rw.parseCommit(parentCommit);
            Timestamp now = TimeUtil.nowTs();
            IdentifiedUser me = (IdentifiedUser) userProvider.get();
            PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
            ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(git, rw, author, mergeTip, commitMessage);
            Change change = new Change(getChangeId(id, c), new Change.Id(db.get().nextChangeId()), me.getAccountId(), new Branch.NameKey(project, refName), now);
            ChangeInserter ins = changeInserterFactory.create(refControl, change, c);
            validateCommit(git, refControl, c, me, ins);
            updateRef(git, rw, c, change, ins.getPatchSet());
            change.setTopic(input.topic);
            change.setStatus(input.status != null ? Change.Status.forChangeStatus(input.status) : Change.Status.NEW);
            ins.insert();
            return Response.created(json.format(change.getId()));
        } finally {
            rw.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
@Test
public void queryChangesOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(EnumSet.allOf(ListChangesOption.class)).get());
    assertThat(Iterables.getOnlyElement(result.labels.keySet())).isEqualTo("Code-Review");
    assertThat(result.messages).hasSize(1);
    assertThat(result.actions).isNotEmpty();
    RevisionInfo rev = Iterables.getOnlyElement(result.revisions.values());
    assertThat(rev._number).isEqualTo(r.getPatchSetId().get());
    assertThat(rev.actions).isNotEmpty();
}
#method_after
@Test
public void queryChangesOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(EnumSet.allOf(ListChangesOption.class)).get());
    assertThat(Iterables.getOnlyElement(result.labels.keySet())).isEqualTo("Code-Review");
    assertThat(result.messages).hasSize(1);
    assertThat(result.actions).isNotEmpty();
    RevisionInfo rev = Iterables.getOnlyElement(result.revisions.values());
    assertThat(rev._number).isEqualTo(r.getPatchSetId().get());
    assertThat(rev.ref).isEqualTo(r.getPatchSetId().toRefName());
    assertThat(rev.actions).isNotEmpty();
}
#end_block

#method_before
private Change newChange() {
    return TestChanges.newChange(project, changeOwner);
}
#method_after
private Change newChange() {
    return TestChanges.newChange(project, changeOwner.getAccountId());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "publish_edit").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "rebase_edit").to(RebaseChangeEdit.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountLoader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteFile.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountLoader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteFile.Factory.class);
        }
    });
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, String project) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(new ChangeResource(ctl), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = plcUtil.draftByPatchSetAuthor(db.get(), in.getId(), user.getAccountId(), ctl.getNotes()).iterator().hasNext() ? true : null;
    }
    if (has(WEB_LINKS)) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, in.getRevision().get());
        out.webLinks = links.isEmpty() ? null : links.toList();
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, String project) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(new ChangeResource(ctl), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = plcUtil.draftByPatchSetAuthor(db.get(), in.getId(), user.getAccountId(), ctl.getNotes()).iterator().hasNext() ? true : null;
    }
    if (has(WEB_LINKS)) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, in.getRevision().get());
        out.webLinks = links.isEmpty() ? null : links.toList();
    }
    return out;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setHeaderVisible(false);
    Resources.I.style().ensureInjected();
    star.setVisible(Gerrit.isSignedIn());
    labels.init(style, statusText);
    reviewers.init(style, ccText);
    hashtags.init(style);
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReview(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                star.setValue(!star.getValue(), true);
            }
        });
        keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                reviewers.onOpenForm();
            }
        });
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setHeaderVisible(false);
    Resources.I.style().ensureInjected();
    star.setVisible(Gerrit.isSignedIn());
    labels.init(style, statusText);
    reviewers.init(style, ccText);
    hashtags.init(style);
    initReplyButton();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                star.setValue(!star.getValue(), true);
            }
        });
        keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                reviewers.onOpenForm();
            }
        });
    }
}
#end_block

#method_before
private void initEditMode(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.status() == Status.NEW) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            editFileAction = new EditFileAction(new PatchSet.Id(changeId, edit == null ? rev._number() : 0), "", "", style, editMessage, review);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
    }
}
#method_after
private void initEditMode(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.status() == Status.NEW) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            editFileAction = new EditFileAction(new PatchSet.Id(changeId, edit == null ? rev._number() : 0), "", "", style, editMessage, reply);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
    }
}
#end_block

#method_before
private void initEditMessageAction(ChangeInfo info, String revision) {
    NativeMap<ActionInfo> actions = info.revision(revision).actions();
    if (actions != null && actions.containsKey("message")) {
        editMessage.setVisible(true);
        editMessageAction = new EditMessageAction(info.legacy_id(), revision, info.revision(revision).commit().message(), style, editMessage, review);
        keysAction.add(new KeyCommand(0, 'e', Util.C.keyEditMessage()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                editMessageAction.onEdit();
            }
        });
    }
}
#method_after
private void initEditMessageAction(ChangeInfo info, String revision) {
    NativeMap<ActionInfo> actions = info.revision(revision).actions();
    if (actions != null && actions.containsKey("message")) {
        editMessage.setVisible(true);
        editMessageAction = new EditMessageAction(info.legacy_id(), revision, info.revision(revision).commit().message(), style, editMessage, reply);
        keysAction.add(new KeyCommand(0, 'e', Util.C.keyEditMessage()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                editMessageAction.onEdit();
            }
        });
    }
}
#end_block

#method_before
private void onReply() {
    if (Gerrit.isSignedIn()) {
        replyAction.onReply(null);
    } else {
        Gerrit.doSignIn(getToken());
    }
}
#method_after
@UiHandler("reply")
void onReply(@SuppressWarnings("unused") ClickEvent e) {
    onReply();
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.set(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()), style, editMessage, review, edit != null);
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment, fileTableMode);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.set(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()), style, editMessage, reply, edit != null);
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment, fileTableMode);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    DiffApi.list(changeId.get(), base != null ? base.name() : null, rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()), style, editMessage, review, edit != null);
            files.setValue(m, myLastReply, comments.get(0), drafts.get(0), fileTableMode);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#method_after
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    DiffApi.list(changeId.get(), base != null ? base.name() : null, rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()), style, editMessage, reply, edit != null);
            files.setValue(m, myLastReply, comments.get(0), drafts.get(0), fileTableMode);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, review, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), canSubmit);
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), canSubmit);
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
@Override
public List<GroupInfo> apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, UnprocessableEntityException, OrmException {
    AccountGroup group = resource.toAccountGroup();
    if (group == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    GroupControl control = resource.getControl();
    Map<AccountGroup.UUID, AccountGroupById> newIncludedGroups = Maps.newHashMap();
    List<GroupInfo> result = Lists.newLinkedList();
    Account.Id me = ((IdentifiedUser) control.getCurrentUser()).getAccountId();
    for (String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canAddGroup(d.getGroupUUID())) {
            throw new AuthException(String.format("Cannot add group: %s", d.getName()));
        }
        if (!newIncludedGroups.containsKey(d.getGroupUUID())) {
            AccountGroupById.Key agiKey = new AccountGroupById.Key(group.getId(), d.getGroupUUID());
            AccountGroupById agi = db.get().accountGroupById().get(agiKey);
            if (agi == null) {
                agi = new AccountGroupById(agiKey);
                newIncludedGroups.put(d.getGroupUUID(), agi);
            }
        }
        result.add(json.format(d));
    }
    if (!newIncludedGroups.isEmpty()) {
        auditService.dispatchAddGroupsToGroup(me, newIncludedGroups.values());
        db.get().accountGroupById().insert(newIncludedGroups.values());
        for (AccountGroupById agi : newIncludedGroups.values()) {
            groupIncludeCache.evictParentGroupsOf(agi.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(group.getGroupUUID());
    }
    return result;
}
#method_after
@Override
public List<GroupInfo> apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, UnprocessableEntityException, OrmException {
    AccountGroup group = resource.toAccountGroup();
    if (group == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    GroupControl control = resource.getControl();
    Map<AccountGroup.UUID, AccountGroupById> newIncludedGroups = Maps.newHashMap();
    List<GroupInfo> result = Lists.newLinkedList();
    Account.Id me = ((IdentifiedUser) control.getCurrentUser()).getAccountId();
    for (String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canAddGroup()) {
            throw new AuthException(String.format("Cannot add group: %s", d.getName()));
        }
        if (!newIncludedGroups.containsKey(d.getGroupUUID())) {
            AccountGroupById.Key agiKey = new AccountGroupById.Key(group.getId(), d.getGroupUUID());
            AccountGroupById agi = db.get().accountGroupById().get(agiKey);
            if (agi == null) {
                agi = new AccountGroupById(agiKey);
                newIncludedGroups.put(d.getGroupUUID(), agi);
            }
        }
        result.add(json.format(d));
    }
    if (!newIncludedGroups.isEmpty()) {
        auditService.dispatchAddGroupsToGroup(me, newIncludedGroups.values());
        db.get().accountGroupById().insert(newIncludedGroups.values());
        for (AccountGroupById agi : newIncludedGroups.values()) {
            groupIncludeCache.evictParentGroupsOf(agi.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(group.getGroupUUID());
    }
    return result;
}
#end_block

#method_before
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<AccountGroup.UUID, AccountGroupById> includedGroups = getIncludedGroups(internalGroup.getId());
    final List<AccountGroupById> toRemove = Lists.newLinkedList();
    for (final String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canRemoveGroup(d.getGroupUUID())) {
            throw new AuthException(String.format("Cannot delete group: %s", d.getName()));
        }
        AccountGroupById g = includedGroups.remove(d.getGroupUUID());
        if (g != null) {
            toRemove.add(g);
        }
    }
    if (!toRemove.isEmpty()) {
        writeAudits(toRemove);
        db.get().accountGroupById().delete(toRemove);
        for (final AccountGroupById g : toRemove) {
            groupIncludeCache.evictParentGroupsOf(g.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(internalGroup.getGroupUUID());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<AccountGroup.UUID, AccountGroupById> includedGroups = getIncludedGroups(internalGroup.getId());
    final List<AccountGroupById> toRemove = Lists.newLinkedList();
    for (final String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canRemoveGroup()) {
            throw new AuthException(String.format("Cannot delete group: %s", d.getName()));
        }
        AccountGroupById g = includedGroups.remove(d.getGroupUUID());
        if (g != null) {
            toRemove.add(g);
        }
    }
    if (!toRemove.isEmpty()) {
        writeAudits(toRemove);
        db.get().accountGroupById().delete(toRemove);
        for (final AccountGroupById g : toRemove) {
            groupIncludeCache.evictParentGroupsOf(g.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(internalGroup.getGroupUUID());
    }
    return Response.none();
}
#end_block

#method_before
private void writeAudits(final List<AccountGroupById> toRemoved) throws OrmException {
    final Account.Id me = ((IdentifiedUser) self.get()).getAccountId();
    auditService.dispatchDeleteGroupsFromGroup(me, toRemoved);
}
#method_after
private void writeAudits(final List<AccountGroupById> toRemoved) {
    final Account.Id me = ((IdentifiedUser) self.get()).getAccountId();
    auditService.dispatchDeleteGroupsFromGroup(me, toRemoved);
}
#end_block

#method_before
public final Watchers getWatchers(NotifyType type) throws OrmException {
    Watchers matching = new Watchers();
    Set<Account.Id> projectWatchers = new HashSet<>();
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(project)) {
        if (w.isNotify(type)) {
            projectWatchers.add(w.getAccountId());
            add(matching, w);
        }
    }
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(args.allProjectsName)) {
        if (!projectWatchers.contains(w.getAccountId()) && w.isNotify(type)) {
            add(matching, w);
        }
    }
    for (ProjectState state : projectState.tree()) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc, state.getProject().getNameKey());
                } catch (QueryParseException e) {
                    log.warn(String.format("Project %s has invalid notify %s filter \"%s\"", state.getProject().getName(), nc.getName(), nc.getFilter()), e);
                }
            }
        }
    }
    return matching;
}
#method_after
public final Watchers getWatchers(NotifyType type) throws OrmException {
    Watchers matching = new Watchers();
    Set<Account.Id> projectWatchers = new HashSet<>();
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(project)) {
        if (w.isNotify(type)) {
            projectWatchers.add(w.getAccountId());
            add(matching, w);
        }
    }
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(args.allProjectsName)) {
        if (!projectWatchers.contains(w.getAccountId()) && w.isNotify(type)) {
            add(matching, w);
        }
    }
    for (ProjectState state : projectState.tree()) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc);
                } catch (QueryParseException e) {
                    log.warn(String.format("Project %s has invalid notify %s filter \"%s\"", state.getProject().getName(), nc.getName(), nc.getFilter()), e);
                }
            }
        }
    }
    return matching;
}
#end_block

#method_before
private void add(Watchers matching, AccountProjectWatch w) throws OrmException {
    IdentifiedUser user = args.identifiedUserFactory.create(args.db, w.getAccountId());
    try {
        if (filterMatch(user, w.getFilter())) {
            matching.bcc.accounts.add(w.getAccountId());
        }
    } catch (QueryParseException e) {
    // Ignore broken filter expressions.
    }
}
#method_after
private void add(Watchers matching, NotifyConfig nc) throws OrmException, QueryParseException {
    for (GroupReference ref : nc.getGroups()) {
        CurrentUser user = new SingleGroupUser(args.capabilityControlFactory, ref.getUUID());
        if (filterMatch(user, nc.getFilter())) {
            deliverToMembers(matching.list(nc.getHeader()), ref.getUUID());
        }
    }
    if (!nc.getAddresses().isEmpty()) {
        if (filterMatch(null, nc.getFilter())) {
            matching.list(nc.getHeader()).emails.addAll(nc.getAddresses());
        }
    }
}
#end_block

#method_before
@Override
public CheckResult apply(ChangeResource rsrc) {
    CheckResult result = checkerProvider.get().check(rsrc.getChange());
    try {
        result.change = json.format(rsrc);
    } catch (OrmException e) {
        // Even with no options there are a surprising number of dependencies in
        // ChangeJson. Fall back to a very basic implementation with no
        // dependencies if this fails.
        String msg = "Error rendering final ChangeInfo";
        log.warn(msg, e);
        result.messages.add(msg);
        result.change = basicChangeInfo(rsrc.getChange());
    }
    return result;
}
#method_after
@Override
public CheckResult apply(ChangeResource rsrc) {
    CheckResult result = new CheckResult();
    result.messages = checkerProvider.get().check(rsrc.getChange());
    try {
        result.change = json.format(rsrc);
    } catch (OrmException e) {
        // Even with no options there are a surprising number of dependencies in
        // ChangeJson. Fall back to a very basic implementation with no
        // dependencies if this fails.
        String msg = "Error rendering final ChangeInfo";
        log.warn(msg, e);
        result.messages.add(msg);
        result.change = basicChangeInfo(rsrc.getChange());
    }
    return result;
}
#end_block

#method_before
private static ChangeInfo basicChangeInfo(Change c) {
    ChangeInfo info = new ChangeInfo();
    info.project = c.getProject().get();
    info.branch = c.getDest().getShortName();
    info.topic = c.getTopic();
    info.changeId = c.getKey().get();
    info.subject = c.getSubject();
    info.status = c.getStatus();
    info.owner = new AccountInfo(c.getOwner());
    info.created = c.getCreatedOn();
    info.updated = c.getLastUpdatedOn();
    info._number = c.getId().get();
    info._sortkey = c.getSortKey();
    info.finish();
    return info;
}
#method_after
private static ChangeInfo basicChangeInfo(Change c) {
    ChangeInfo info = new ChangeInfo();
    info.project = c.getProject().get();
    info.branch = c.getDest().getShortName();
    info.topic = c.getTopic();
    info.changeId = c.getKey().get();
    info.subject = c.getSubject();
    info.status = c.getStatus();
    info.owner = new AccountInfo(c.getOwner());
    info.created = c.getCreatedOn();
    info.updated = c.getLastUpdatedOn();
    info._number = c.getId().get();
    info.finish();
    return info;
}
#end_block

#method_before
public CheckResult check(Change c) {
    reset();
    change = c;
    try {
        checkImpl();
        CheckResult result = new CheckResult();
        result.messages = messages;
        return result;
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
    }
}
#method_after
public List<String> check(Change c) {
    reset();
    change = c;
    try {
        checkImpl();
        return messages;
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
    }
}
#end_block

#method_before
private void checkImpl() {
    // All checks that require the repo.
    if (!openRepo()) {
        return;
    }
    if (!checkPatchSets()) {
        return;
    }
    checkMerged();
}
#method_after
private void checkImpl() {
    checkOwner();
    checkCurrentPatchSetEntity();
    // All checks that require the repo.
    if (!openRepo()) {
        return;
    }
    if (!checkPatchSets()) {
        return;
    }
    checkMerged();
}
#end_block

#method_before
private boolean checkPatchSets() {
    List<PatchSet> all;
    try {
        all = db.get().patchSets().byChange(change.getId()).toList();
    } catch (OrmException e) {
        return error("Failed to look up patch sets", e);
    }
    Multimap<ObjectId, PatchSet> bySha = MultimapBuilder.hashKeys(all.size()).treeSetValues(Ordering.natural().onResultOf(new Function<PatchSet, Integer>() {

        @Override
        public Integer apply(PatchSet in) {
            return in.getId().get();
        }
    })).build();
    for (PatchSet ps : all) {
        ObjectId objId;
        String rev = ps.getRevision().get();
        int psNum = ps.getId().get();
        try {
            objId = ObjectId.fromString(rev);
        } catch (IllegalArgumentException e) {
            messages.add(String.format("Invalid revision on patch set %d: %s", psNum, rev));
            continue;
        }
        bySha.put(objId, ps);
        boolean isCurrent = ps.getId().equals(change.currentPatchSetId());
        if (isCurrent) {
            currPs = ps;
        }
        RevCommit psCommit = parseCommit(objId, String.format("patch set %d: %s", psNum, rev));
        if (psCommit == null) {
            continue;
        }
        if (isCurrent) {
            currPsCommit = psCommit;
        }
    }
    for (Map.Entry<ObjectId, Collection<PatchSet>> e : bySha.asMap().entrySet()) {
        if (e.getValue().size() > 1) {
            messages.add(String.format("Multiple patch sets pointing to %s: %s", e.getKey().name(), Joiner.on(", ").join(e.getValue())));
        }
    }
    if (currPs == null) {
        messages.add(String.format("Current patch set %d not found", change.currentPatchSetId().get()));
    }
    return currPs != null && currPsCommit != null;
}
#method_after
private boolean checkPatchSets() {
    List<PatchSet> all;
    try {
        all = db.get().patchSets().byChange(change.getId()).toList();
    } catch (OrmException e) {
        return error("Failed to look up patch sets", e);
    }
    Function<PatchSet, Integer> toPsId = new Function<PatchSet, Integer>() {

        @Override
        public Integer apply(PatchSet in) {
            return in.getId().get();
        }
    };
    Multimap<ObjectId, PatchSet> bySha = MultimapBuilder.hashKeys(all.size()).treeSetValues(Ordering.natural().onResultOf(toPsId)).build();
    for (PatchSet ps : all) {
        ObjectId objId;
        String rev = ps.getRevision().get();
        int psNum = ps.getId().get();
        try {
            objId = ObjectId.fromString(rev);
        } catch (IllegalArgumentException e) {
            error(String.format("Invalid revision on patch set %d: %s", psNum, rev), e);
            continue;
        }
        bySha.put(objId, ps);
        RevCommit psCommit = parseCommit(objId, String.format("patch set %d", psNum));
        if (psCommit == null) {
            continue;
        }
        if (ps.getId().equals(change.currentPatchSetId())) {
            currPsCommit = psCommit;
        }
    }
    for (Map.Entry<ObjectId, Collection<PatchSet>> e : bySha.asMap().entrySet()) {
        if (e.getValue().size() > 1) {
            messages.add(String.format("Multiple patch sets pointing to %s: %s", e.getKey().name(), Collections2.transform(e.getValue(), toPsId)));
        }
    }
    return currPs != null && currPsCommit != null;
}
#end_block

#method_before
private void checkMerged() {
    String refName = change.getDest().get();
    Ref dest;
    try {
        dest = repo.getRef(refName);
    } catch (IOException e) {
        messages.add("Failed to look up destination ref: " + refName);
        return;
    }
    if (dest == null) {
        messages.add("Destination ref not found (may be new branch): " + change.getDest());
    }
    RevCommit tip = parseCommit(dest.getObjectId(), "destination ref " + refName);
    if (tip == null) {
        return;
    }
    boolean merged;
    try {
        merged = rw.isMergedInto(currPsCommit, tip);
    } catch (IOException e) {
        messages.add("Error checking whether patch set " + currPs.getId().get() + " is merged");
        return;
    }
    if (merged && change.getStatus() != Change.Status.MERGED) {
        messages.add(String.format("Patch set %d (%s) is merged into destination" + " ref %s (%s), but change status is %s", currPs.getId().get(), currPsCommit.name(), refName, tip.name(), change.getStatus()));
    // TODO(dborowitz): Just fix it.
    } else if (!merged && change.getStatus() == Change.Status.MERGED) {
        messages.add(String.format("Patch set %d (%s) is not merged into" + " destination ref %s (%s), but change status is %s", currPs.getId().get(), currPsCommit.name(), refName, tip.name(), change.getStatus()));
    }
}
#method_after
private void checkMerged() {
    String refName = change.getDest().get();
    Ref dest;
    try {
        dest = repo.getRef(refName);
    } catch (IOException e) {
        messages.add("Failed to look up destination ref: " + refName);
        return;
    }
    if (dest == null) {
        messages.add("Destination ref not found (may be new branch): " + change.getDest().get());
        return;
    }
    RevCommit tip = parseCommit(dest.getObjectId(), "destination ref " + refName);
    if (tip == null) {
        return;
    }
    boolean merged;
    try {
        merged = rw.isMergedInto(currPsCommit, tip);
    } catch (IOException e) {
        messages.add("Error checking whether patch set " + currPs.getId().get() + " is merged");
        return;
    }
    if (merged && change.getStatus() != Change.Status.MERGED) {
        messages.add(String.format("Patch set %d (%s) is merged into destination" + " ref %s (%s), but change status is %s", currPs.getId().get(), currPsCommit.name(), refName, tip.name(), change.getStatus()));
    // TODO(dborowitz): Just fix it.
    } else if (!merged && change.getStatus() == Change.Status.MERGED) {
        messages.add(String.format("Patch set %d (%s) is not merged into" + " destination ref %s (%s), but change status is %s", currPs.getId().get(), currPsCommit.name(), refName, tip.name(), change.getStatus()));
    }
}
#end_block

#method_before
@Test
public void testCapabilitiesUser() throws Exception {
    grantAllCapabilitiesExceptAdministrateServerAndPriority();
    RestResponse r = userSession.get("/accounts/self/capabilities");
    int code = r.getStatusCode();
    assertEquals(code, 200);
    CapabilityInfo info = (new Gson()).fromJson(r.getReader(), new TypeToken<CapabilityInfo>() {
    }.getType());
    for (String c : GlobalCapability.getAllNames()) {
        if (ADMINISTRATE_SERVER.equals(c)) {
            assertFalse(info.administrateServer);
        } else if (BATCH_CHANGES_LIMIT.equals(c)) {
            assertEquals(0, info.batchChangesLimit.min);
            assertEquals(DEFAULT_MAX_BATCH_CHANGES, info.batchChangesLimit.max);
        } else if (PRIORITY.equals(c)) {
            assertFalse(info.priority);
        } else if (QUERY_LIMIT.equals(c)) {
            assertEquals(0, info.queryLimit.min);
            assertEquals(DEFAULT_MAX_QUERY_LIMIT, info.queryLimit.max);
        } else {
            assertTrue(String.format("capability %s was not granted", c), (Boolean) CapabilityInfo.class.getField(c).get(info));
        }
    }
}
#method_after
@Test
public void testCapabilitiesUser() throws Exception {
    grantAllCapabilities();
    RestResponse r = userSession.get("/accounts/self/capabilities");
    int code = r.getStatusCode();
    assertEquals(code, 200);
    CapabilityInfo info = (new Gson()).fromJson(r.getReader(), new TypeToken<CapabilityInfo>() {
    }.getType());
    for (String c : GlobalCapability.getAllNames()) {
        if (ADMINISTRATE_SERVER.equals(c)) {
            assertFalse(info.administrateServer);
        } else if (BATCH_CHANGES_LIMIT.equals(c)) {
            assertEquals(0, info.batchChangesLimit.min);
            assertEquals(DEFAULT_MAX_BATCH_CHANGES_LIMIT, info.batchChangesLimit.max);
        } else if (PRIORITY.equals(c)) {
            assertFalse(info.priority);
        } else if (QUERY_LIMIT.equals(c)) {
            assertEquals(0, info.queryLimit.min);
            assertEquals(DEFAULT_MAX_QUERY_LIMIT, info.queryLimit.max);
        } else {
            assertTrue(String.format("capability %s was not granted", c), (Boolean) CapabilityInfo.class.getField(c).get(info));
        }
    }
}
#end_block

#method_before
@Test
public void testCapabilitiesAdmin() throws Exception {
    RestResponse r = adminSession.get("/accounts/self/capabilities");
    int code = r.getStatusCode();
    assertEquals(code, 200);
    CapabilityInfo info = (new Gson()).fromJson(r.getReader(), new TypeToken<CapabilityInfo>() {
    }.getType());
    for (String c : GlobalCapability.getAllNames()) {
        if (BATCH_CHANGES_LIMIT.equals(c)) {
            // No default value for any user.
            assertNull(info.batchChangesLimit);
        } else if (PRIORITY.equals(c)) {
            assertFalse(info.priority);
        } else if (QUERY_LIMIT.equals(c)) {
            assertNotNull("missing queryLimit", info.queryLimit);
            assertEquals(0, info.queryLimit.min);
            assertEquals(DEFAULT_MAX_QUERY_LIMIT, info.queryLimit.max);
        } else if (ACCESS_DATABASE.equals(c)) {
            assertFalse(info.accessDatabase);
        } else if (RUN_AS.equals(c)) {
            assertFalse(info.runAs);
        } else {
            assertTrue(String.format("capability %s was not granted", c), (Boolean) CapabilityInfo.class.getField(c).get(info));
        }
    }
}
#method_after
@Test
public void testCapabilitiesAdmin() throws Exception {
    RestResponse r = adminSession.get("/accounts/self/capabilities");
    int code = r.getStatusCode();
    assertEquals(code, 200);
    CapabilityInfo info = (new Gson()).fromJson(r.getReader(), new TypeToken<CapabilityInfo>() {
    }.getType());
    for (String c : GlobalCapability.getAllNames()) {
        if (BATCH_CHANGES_LIMIT.equals(c)) {
            // It does not have default value for any user as it can override the
            // 'receive.batchChangesLimit'. It needs to be granted explicitly.
            assertNull(info.batchChangesLimit);
        } else if (PRIORITY.equals(c)) {
            assertFalse(info.priority);
        } else if (QUERY_LIMIT.equals(c)) {
            assertNotNull("missing queryLimit", info.queryLimit);
            assertEquals(0, info.queryLimit.min);
            assertEquals(DEFAULT_MAX_QUERY_LIMIT, info.queryLimit.max);
        } else if (ACCESS_DATABASE.equals(c)) {
            assertFalse(info.accessDatabase);
        } else if (RUN_AS.equals(c)) {
            assertFalse(info.runAs);
        } else {
            assertTrue(String.format("capability %s was not granted", c), (Boolean) CapabilityInfo.class.getField(c).get(info));
        }
    }
}
#end_block

#method_before
public static PermissionRange.WithDefaults getRange(String varName) {
    if (QUERY_LIMIT.equalsIgnoreCase(varName)) {
        return new PermissionRange.WithDefaults(varName, 0, Integer.MAX_VALUE, 0, DEFAULT_MAX_QUERY_LIMIT);
    }
    if (BATCH_CHANGES_LIMIT.equalsIgnoreCase(varName)) {
        return new PermissionRange.WithDefaults(varName, 0, Integer.MAX_VALUE, 0, DEFAULT_MAX_BATCH_CHANGES);
    }
    return null;
}
#method_after
public static PermissionRange.WithDefaults getRange(String varName) {
    if (QUERY_LIMIT.equalsIgnoreCase(varName)) {
        return new PermissionRange.WithDefaults(varName, 0, Integer.MAX_VALUE, 0, DEFAULT_MAX_QUERY_LIMIT);
    }
    if (BATCH_CHANGES_LIMIT.equalsIgnoreCase(varName)) {
        return new PermissionRange.WithDefaults(varName, 0, Integer.MAX_VALUE, 0, DEFAULT_MAX_BATCH_CHANGES_LIMIT);
    }
    return null;
}
#end_block

#method_before
@Test
public void testCapabilitiesUser() throws Exception {
    grantAllCapabilitiesExceptAdministrateServerAndPriority();
    RestResponse r = userSession.get("/accounts/self/capabilities");
    int code = r.getStatusCode();
    assertEquals(code, 200);
    CapabilityInfo info = (new Gson()).fromJson(r.getReader(), new TypeToken<CapabilityInfo>() {
    }.getType());
    for (String c : GlobalCapability.getAllNames()) {
        if (ADMINISTRATE_SERVER.equals(c)) {
            assertFalse(info.administrateServer);
        } else if (PRIORITY.equals(c)) {
            assertFalse(info.priority);
        } else if (QUERY_LIMIT.equals(c)) {
            assertEquals(0, info.queryLimit.min);
            assertEquals(DEFAULT_MAX_QUERY_LIMIT, info.queryLimit.max);
        } else {
            assertTrue(String.format("capability %s was not granted", c), (Boolean) CapabilityInfo.class.getField(c).get(info));
        }
    }
}
#method_after
@Test
public void testCapabilitiesUser() throws Exception {
    grantAllCapabilities();
    RestResponse r = userSession.get("/accounts/self/capabilities");
    int code = r.getStatusCode();
    assertEquals(code, 200);
    CapabilityInfo info = (new Gson()).fromJson(r.getReader(), new TypeToken<CapabilityInfo>() {
    }.getType());
    for (String c : GlobalCapability.getAllNames()) {
        if (ADMINISTRATE_SERVER.equals(c)) {
            assertFalse(info.administrateServer);
        } else if (PRIORITY.equals(c)) {
            assertFalse(info.priority);
        } else if (QUERY_LIMIT.equals(c)) {
            assertEquals(0, info.queryLimit.min);
            assertEquals(DEFAULT_MAX_QUERY_LIMIT, info.queryLimit.max);
        } else {
            assertTrue(String.format("capability %s was not granted", c), (Boolean) CapabilityInfo.class.getField(c).get(info));
        }
    }
}
#end_block

#method_before
@Test
public void autoValue() {
    Auto a = Auto.create("foo");
    assertEquals("foo", a.val());
    assertEquals("Auto{val=foo}", a.toString());
}
#method_after
@Test
public void autoValue() {
    Auto a = Auto.create("foo");
    assertThat(a.val()).isEqualTo("foo");
    assertThat(a.toString()).isEqualTo("Auto{val=foo}");
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.maxBatchChanges;
        boolean isLimitedUser = !projectControl.canPushBatchChangesWithoutLimitation();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (isLimitedUser && maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.destChanges.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(currentUser);
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.destChanges.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
@Override
public void onPluginLoad() {
    Plugin.get().screenRegex(".*", new AddReviewersScreen.Factory());
}
#method_after
@Override
public void onPluginLoad() {
    Plugin.get().screenRegex(".*", new ReviewersScreen.Factory());
}
#end_block

#method_before
void removeReviewer(String filter, String reviewer) {
    if (newReviewerFilterSection(filter).getReviewers().contains(reviewer)) {
        List<String> values = new ArrayList<>(Arrays.asList(cfg.getStringList(FILTER, filter, REVIEWER)));
        values.remove(reviewer);
        cfg.unsetSection(FILTER, filter);
        if (!values.isEmpty()) {
            cfg.setStringList(FILTER, filter, REVIEWER, values);
        }
    }
}
#method_after
void removeReviewer(String filter, String reviewer) {
    if (newReviewerFilterSection(filter).getReviewers().contains(reviewer)) {
        List<String> values = new ArrayList<>(Arrays.asList(cfg.getStringList(FILTER, filter, REVIEWER)));
        values.remove(reviewer);
        if (values.isEmpty()) {
            cfg.unsetSection(FILTER, filter);
        } else {
            cfg.setStringList(FILTER, filter, REVIEWER, values);
        }
    }
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated reviewers configuration\n");
    }
    saveConfig(FILENAME, cfg);
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (Strings.isNullOrEmpty(commit.getMessage())) {
        commit.setMessage("Update reviewers configuration\n");
    }
    saveConfig(FILENAME, cfg);
    return true;
}
#end_block

#method_before
@Override
public List<ReviewerFilterSection> apply(ProjectResource rsrc, Input input) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    Project.NameKey projectName = rsrc.getNameKey();
    ReviewersConfig cfg = configFactory.create(projectName);
    if (!rsrc.getControl().isOwner() || cfg == null) {
        throw new ResourceNotFoundException(projectName.get());
    }
    MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        cfg.load(md);
        if (input.action == Action.ADD) {
            cfg.addReviewer(input.filter, input.reviewer);
        } else {
            cfg.removeReviewer(input.filter, input.reviewer);
        }
        md.setMessage("Modified reviewers.config\n");
        try {
            ObjectId baseRev = cfg.getRevision();
            ObjectId commitRev = cfg.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equal(baseRev, commitRev)) {
                IdentifiedUser user = (IdentifiedUser) currentUser.get();
                hooks.doRefUpdatedHook(new Branch.NameKey(projectName, RefNames.REFS_CONFIG), baseRev, commitRev, user.getAccount());
            }
            projectCache.evict(projectName);
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read " + pluginName + " configurations for project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update " + pluginName + " configurations for project " + projectName, err);
    } finally {
        md.close();
    }
    return cfg.getReviewerFilterSections();
}
#method_after
@Override
public List<ReviewerFilterSection> apply(ProjectResource rsrc, Input input) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    Project.NameKey projectName = rsrc.getNameKey();
    ReviewersConfig cfg = configFactory.create(projectName);
    if (!rsrc.getControl().isOwner() || cfg == null) {
        throw new ResourceNotFoundException(projectName.get());
    }
    MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        cfg.load(md);
        if (input.action == Action.ADD) {
            cfg.addReviewer(input.filter, input.reviewer);
        } else {
            cfg.removeReviewer(input.filter, input.reviewer);
        }
        md.setMessage("Modify reviewers.config\n");
        try {
            ObjectId baseRev = cfg.getRevision();
            ObjectId commitRev = cfg.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equal(baseRev, commitRev)) {
                IdentifiedUser user = (IdentifiedUser) currentUser.get();
                hooks.doRefUpdatedHook(new Branch.NameKey(projectName, RefNames.REFS_CONFIG), baseRev, commitRev, user.getAccount());
            }
            projectCache.evict(projectName);
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read " + pluginName + " configurations for project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update " + pluginName + " configurations for project " + projectName, err);
    } finally {
        md.close();
    }
    return cfg.getReviewerFilterSections();
}
#end_block

#method_before
@Override
public void onAddAccountsToGroup(Account.Id me, Collection<AccountGroupMember> added) {
    List<AccountGroupMemberAudit> auditInserts = Lists.newLinkedList();
    for (AccountGroupMember m : added) {
        AccountGroupMemberAudit audit = new AccountGroupMemberAudit(m, me, TimeUtil.nowTs());
        auditInserts.add(audit);
    }
    try {
        ReviewDb db = schema.open();
        db.accountGroupMembersAudit().insert(auditInserts);
    } catch (OrmException e) {
        logOrmExceptionForAccounts("Cannot log add accounts to group event performed by user", me, added, e);
    }
}
#method_after
@Override
public void onAddAccountsToGroup(Account.Id me, Collection<AccountGroupMember> added) {
    List<AccountGroupMemberAudit> auditInserts = Lists.newLinkedList();
    for (AccountGroupMember m : added) {
        AccountGroupMemberAudit audit = new AccountGroupMemberAudit(m, me, TimeUtil.nowTs());
        auditInserts.add(audit);
    }
    try {
        ReviewDb db = schema.open();
        try {
            db.accountGroupMembersAudit().insert(auditInserts);
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        logOrmExceptionForAccounts("Cannot log add accounts to group event performed by user", me, added, e);
    }
}
#end_block

#method_before
@Override
public void onDeleteAccountsFromGroup(Account.Id me, Collection<AccountGroupMember> removed) {
    List<AccountGroupMemberAudit> auditInserts = Lists.newLinkedList();
    List<AccountGroupMemberAudit> auditUpdates = Lists.newLinkedList();
    try {
        ReviewDb reviewDB = schema.open();
        for (AccountGroupMember m : removed) {
            AccountGroupMemberAudit audit = null;
            for (AccountGroupMemberAudit a : reviewDB.accountGroupMembersAudit().byGroupAccount(m.getAccountGroupId(), m.getAccountId())) {
                if (a.isActive()) {
                    audit = a;
                    break;
                }
            }
            if (audit != null) {
                audit.removed(me, TimeUtil.nowTs());
                auditUpdates.add(audit);
            } else {
                audit = new AccountGroupMemberAudit(m, me, TimeUtil.nowTs());
                audit.removedLegacy();
                auditInserts.add(audit);
            }
        }
        reviewDB.accountGroupMembersAudit().update(auditUpdates);
        reviewDB.accountGroupMembersAudit().insert(auditInserts);
    } catch (OrmException e) {
        logOrmExceptionForAccounts("Cannot log delete accounts from group event performed by user", me, removed, e);
    }
}
#method_after
@Override
public void onDeleteAccountsFromGroup(Account.Id me, Collection<AccountGroupMember> removed) {
    List<AccountGroupMemberAudit> auditInserts = Lists.newLinkedList();
    List<AccountGroupMemberAudit> auditUpdates = Lists.newLinkedList();
    try {
        ReviewDb db = schema.open();
        try {
            for (AccountGroupMember m : removed) {
                AccountGroupMemberAudit audit = null;
                for (AccountGroupMemberAudit a : db.accountGroupMembersAudit().byGroupAccount(m.getAccountGroupId(), m.getAccountId())) {
                    if (a.isActive()) {
                        audit = a;
                        break;
                    }
                }
                if (audit != null) {
                    audit.removed(me, TimeUtil.nowTs());
                    auditUpdates.add(audit);
                } else {
                    audit = new AccountGroupMemberAudit(m, me, TimeUtil.nowTs());
                    audit.removedLegacy();
                    auditInserts.add(audit);
                }
            }
            db.accountGroupMembersAudit().update(auditUpdates);
            db.accountGroupMembersAudit().insert(auditInserts);
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        logOrmExceptionForAccounts("Cannot log delete accounts from group event performed by user", me, removed, e);
    }
}
#end_block

#method_before
@Override
public void onAddGroupsToGroup(Account.Id me, Collection<AccountGroupById> added) {
    List<AccountGroupByIdAud> includesAudit = new ArrayList<>();
    for (AccountGroupById groupInclude : added) {
        AccountGroupByIdAud audit = new AccountGroupByIdAud(groupInclude, me, TimeUtil.nowTs());
        includesAudit.add(audit);
    }
    try {
        ReviewDb db = schema.open();
        db.accountGroupByIdAud().insert(includesAudit);
    } catch (OrmException e) {
        logOrmExceptionForGroups("Cannot log add groups to group event performed by user", me, added, e);
    }
}
#method_after
@Override
public void onAddGroupsToGroup(Account.Id me, Collection<AccountGroupById> added) {
    List<AccountGroupByIdAud> includesAudit = new ArrayList<>();
    for (AccountGroupById groupInclude : added) {
        AccountGroupByIdAud audit = new AccountGroupByIdAud(groupInclude, me, TimeUtil.nowTs());
        includesAudit.add(audit);
    }
    try {
        ReviewDb db = schema.open();
        try {
            db.accountGroupByIdAud().insert(includesAudit);
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        logOrmExceptionForGroups("Cannot log add groups to group event performed by user", me, added, e);
    }
}
#end_block

#method_before
@Override
public void onDeleteGroupsFromGroup(Account.Id me, Collection<AccountGroupById> removed) {
    final List<AccountGroupByIdAud> auditUpdates = Lists.newLinkedList();
    try {
        ReviewDb db = schema.open();
        for (final AccountGroupById g : removed) {
            AccountGroupByIdAud audit = null;
            for (AccountGroupByIdAud a : db.accountGroupByIdAud().byGroupInclude(g.getGroupId(), g.getIncludeUUID())) {
                if (a.isActive()) {
                    audit = a;
                    break;
                }
            }
            if (audit != null) {
                audit.removed(me, TimeUtil.nowTs());
                auditUpdates.add(audit);
            }
        }
        db.accountGroupByIdAud().update(auditUpdates);
    } catch (OrmException e) {
        logOrmExceptionForGroups("Cannot log delete groups from group event performed by user", me, removed, e);
    }
}
#method_after
@Override
public void onDeleteGroupsFromGroup(Account.Id me, Collection<AccountGroupById> removed) {
    final List<AccountGroupByIdAud> auditUpdates = Lists.newLinkedList();
    try {
        ReviewDb db = schema.open();
        try {
            for (final AccountGroupById g : removed) {
                AccountGroupByIdAud audit = null;
                for (AccountGroupByIdAud a : db.accountGroupByIdAud().byGroupInclude(g.getGroupId(), g.getIncludeUUID())) {
                    if (a.isActive()) {
                        audit = a;
                        break;
                    }
                }
                if (audit != null) {
                    audit.removed(me, TimeUtil.nowTs());
                    auditUpdates.add(audit);
                }
            }
            db.accountGroupByIdAud().update(auditUpdates);
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        logOrmExceptionForGroups("Cannot log delete groups from group event performed by user", me, removed, e);
    }
}
#end_block

#method_before
private void setDefaultRenderer(FilterConfig filterConfig) {
    if (renderer == null) {
        renderer = new DefaultRenderer(filterConfig.getServletContext().getContextPath() + STATIC_PREFIX, FluentIterable.from(Arrays.asList(config.getStringList("gitiles", null, "customTemplates"))).transform(new FileUrlMapper()), Objects.firstNonNull(config.getString("gitiles", null, "siteTitle"), "Gitiles"));
    }
}
#method_after
private void setDefaultRenderer(FilterConfig filterConfig) {
    if (renderer == null) {
        renderer = new DefaultRenderer(filterConfig.getServletContext().getContextPath() + STATIC_PREFIX, FluentIterable.from(Arrays.asList(config.getStringList("gitiles", null, "customTemplates"))).transform(new FileUrlMapper()), firstNonNull(config.getString("gitiles", null, "siteTitle"), "Gitiles"));
    }
}
#end_block

#method_before
private void setDefaultAccess() throws ServletException {
    if (accessFactory == null || resolver == null) {
        String basePath = config.getString("gitiles", null, "basePath");
        if (basePath == null) {
            throw new ServletException("gitiles.basePath not set");
        }
        boolean exportAll = config.getBoolean("gitiles", null, "exportAll", false);
        FileResolver<HttpServletRequest> fileResolver;
        if (resolver == null) {
            fileResolver = new FileResolver<HttpServletRequest>(new File(basePath), exportAll);
            resolver = wrapResolver(fileResolver);
        } else if (resolver instanceof FileResolver) {
            fileResolver = (FileResolver<HttpServletRequest>) resolver;
        } else {
            fileResolver = null;
        }
        if (accessFactory == null) {
            checkState(fileResolver != null, "need a FileResolver when GitilesAccess.Factory not set");
            try {
                accessFactory = new DefaultAccess.Factory(new File(basePath), getBaseGitUrl(config), config, fileResolver);
            } catch (IOException e) {
                throw new ServletException(e);
            }
        }
    }
}
#method_after
private void setDefaultAccess() throws ServletException {
    if (accessFactory == null || resolver == null) {
        String basePath = config.getString("gitiles", null, "basePath");
        if (basePath == null) {
            throw new ServletException("gitiles.basePath not set");
        }
        boolean exportAll = config.getBoolean("gitiles", null, "exportAll", false);
        FileResolver<HttpServletRequest> fileResolver;
        if (resolver == null) {
            fileResolver = new FileResolver<>(new File(basePath), exportAll);
            resolver = wrapResolver(fileResolver);
        } else if (resolver instanceof FileResolver) {
            fileResolver = (FileResolver<HttpServletRequest>) resolver;
        } else {
            fileResolver = null;
        }
        if (accessFactory == null) {
            checkState(fileResolver != null, "need a FileResolver when GitilesAccess.Factory not set");
            try {
                accessFactory = new DefaultAccess.Factory(new File(basePath), getBaseGitUrl(config), config, fileResolver);
            } catch (IOException e) {
                throw new ServletException(e);
            }
        }
    }
}
#end_block

#method_before
// We cannot have all user provided commentlinks in one regular expression
// because in these comment links we may have references to groups by number and name.
// To prevent any possible interference between the regular expressions, we use a matcher
public List<Map<String, String>> linkify(HttpServletRequest req, String message) {
    // Because we're relying on 'req' as a dynamic parameter, we need to construct
    // the CommentLinkInfo for ChangeIds on the fly
    String baseGerritUrl = urls.getBaseGerritUrl(req);
    CommentLinkInfo changeIds = new CommentLinkInfo("ChangeIdLinks", changeId, baseGerritUrl + "#/q/$2,n,z", "");
    mCommentLinks.add(changeIds);
    List<Map<String, String>> parsed = Lists.newArrayList();
    parsed.add(ImmutableMap.of("text", message));
    for (CommentLinkInfo clp : mCommentLinks) {
        for (int index = 0; index < parsed.size(); index++) {
            Map<String, String> piece = parsed.get(index);
            if (piece.get("url") == null) {
                List<Map<String, String>> resultingReplacement = clp.replace(piece.get("text"));
                if (resultingReplacement != null) {
                    parsed.remove(index);
                    for (Map<String, String> it : resultingReplacement) {
                        parsed.add(index, it);
                        index++;
                    }
                }
            }
        }
    }
    // remove the ChangeIds CommentLink
    mCommentLinks.remove(mCommentLinks.size() - 1);
    return parsed;
}
#method_after
public List<Map<String, String>> linkify(HttpServletRequest req, String message) {
    List<CommentLinkInfo> operationalCommentLinks = new ArrayList<>(commentLinks);
    // Because we're relying on 'req' as a dynamic parameter, we need to construct
    // the CommentLinkInfo for ChangeIds on the fly.
    String baseGerritUrl = urls.getBaseGerritUrl(req);
    if (baseGerritUrl != null) {
        CommentLinkInfo changeIds = new CommentLinkInfo(CHANGE_ID_PATTERN, baseGerritUrl + "#/q/$0,n,z");
        operationalCommentLinks.add(changeIds);
    }
    List<Map<String, String>> parsed = Lists.newArrayList();
    parsed.add(ImmutableMap.of("text", message));
    for (int index = 0; index < parsed.size(); index++) {
        if (parsed.get(index).get("url") != null) {
            continue;
        }
        Matcher m = allPattern.matcher(parsed.get(index).get("text"));
        if (!m.find()) {
            continue;
        }
        for (CommentLinkInfo cli : operationalCommentLinks) {
            // No need to apply more rules if this is already a link.
            if (parsed.get(index).get("url") != null) {
                break;
            }
            String text = parsed.get(index).get("text");
            parsed.remove(index);
            parsed.addAll(index, cli.linkify(text));
        }
    }
    return parsed;
}
#end_block

#method_before
@Test
public void linkifyMessageChangeId() throws Exception {
    Config config = new Config();
    config.setString("commentlink", "bugzilla", "match", "(bug\\s+#?)(\\d+)");
    config.setString("commentlink", "bugzilla", "link", "http://bugs.example.com/show_bug.cgi?id=$2");
    config.setString("commentlink", "tracker", "match", "([Bb]ug:\\s+)(\\d+)");
    config.setString("commentlink", "tracker", "html", "$1<a href=\"http://trak.example.com/$2\">$2</a>");
    Linkifier l = new Linkifier(TestGitilesUrls.URLS, config);
    assertEquals(ImmutableList.of(ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z")), l.linkify(REQ, "I0123456789"));
    assertEquals(ImmutableList.of(ImmutableMap.of("text", "Change-Id: "), ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z")), l.linkify(REQ, "Change-Id: I0123456789"));
    assertEquals(ImmutableList.of(ImmutableMap.of("text", "Change-Id: "), ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z"), ImmutableMap.of("text", " exists")), l.linkify(REQ, "Change-Id: I0123456789 exists"));
}
#method_after
@Test
public void linkifyMessageChangeId() throws Exception {
    Config config = new Config();
    Linkifier l = new Linkifier(TestGitilesUrls.URLS, config);
    assertEquals(ImmutableList.of(ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z")), l.linkify(REQ, "I0123456789"));
    assertEquals(ImmutableList.of(ImmutableMap.of("text", "Change-Id: "), ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z")), l.linkify(REQ, "Change-Id: I0123456789"));
    assertEquals(ImmutableList.of(ImmutableMap.of("text", "Change-Id: "), ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z"), ImmutableMap.of("text", " exists")), l.linkify(REQ, "Change-Id: I0123456789 exists"));
}
#end_block

#method_before
private ChangeData toChangeData(Document doc) {
    BytesRef cb = doc.getBinaryValue(CHANGE_FIELD);
    if (cb == null) {
        int id = doc.getField(ID_FIELD).numericValue().intValue();
        return changeDataFactory.create(db.get(), new Change.Id(id));
    }
    // Change proto.
    Change change = ChangeProtoField.CODEC.decode(cb.bytes, cb.offset, cb.length);
    ChangeData cd = changeDataFactory.create(db.get(), change);
    // Approvals.
    BytesRef[] approvalsBytes = doc.getBinaryValues(APPROVAL_FIELD);
    if (approvalsBytes != null) {
        List<PatchSetApproval> approvals = Lists.newArrayListWithCapacity(approvalsBytes.length);
        for (BytesRef ab : approvalsBytes) {
            approvals.add(PatchSetApprovalProtoField.CODEC.decode(ab.bytes, ab.offset, ab.length));
        }
        cd.setCurrentApprovals(approvals);
    }
    // Changed lines.
    IndexableField added = doc.getField(ADDED_FIELD);
    IndexableField deleted = doc.getField(DELETED_FIELD);
    if (added != null && deleted != null) {
        cd.setChangedLines(added.numericValue().intValue(), deleted.numericValue().intValue());
    }
    // Mergeable.
    cd.setMergeable("1".equals(doc.get(MERGEABLE_FIELD)));
    return cd;
}
#method_after
private ChangeData toChangeData(Document doc) {
    BytesRef cb = doc.getBinaryValue(CHANGE_FIELD);
    if (cb == null) {
        int id = doc.getField(ID_FIELD).numericValue().intValue();
        return changeDataFactory.create(db.get(), new Change.Id(id));
    }
    // Change proto.
    Change change = ChangeProtoField.CODEC.decode(cb.bytes, cb.offset, cb.length);
    ChangeData cd = changeDataFactory.create(db.get(), change);
    // Approvals.
    BytesRef[] approvalsBytes = doc.getBinaryValues(APPROVAL_FIELD);
    if (approvalsBytes != null) {
        List<PatchSetApproval> approvals = Lists.newArrayListWithCapacity(approvalsBytes.length);
        for (BytesRef ab : approvalsBytes) {
            approvals.add(PatchSetApprovalProtoField.CODEC.decode(ab.bytes, ab.offset, ab.length));
        }
        cd.setCurrentApprovals(approvals);
    }
    // Changed lines.
    IndexableField added = doc.getField(ADDED_FIELD);
    IndexableField deleted = doc.getField(DELETED_FIELD);
    if (added != null && deleted != null) {
        cd.setChangedLines(added.numericValue().intValue(), deleted.numericValue().intValue());
    }
    // Mergeable.
    String mergeable = doc.get(MERGEABLE_FIELD);
    if ("1".equals(mergeable)) {
        cd.setMergeable(true);
    } else if ("0".equals(mergeable)) {
        cd.setMergeable(false);
    }
    return cd;
}
#end_block

#method_before
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (Values<ChangeData> vs : schema.buildFields(cd, fillArgs)) {
            if (vs.getValues() != null) {
                add(result, vs);
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#method_after
private Document toDocument(ChangeData cd) {
    Document result = new Document();
    for (Values<ChangeData> vs : schema.buildFields(cd, fillArgs)) {
        if (vs.getValues() != null) {
            add(result, vs);
        }
    }
    return result;
}
#end_block

#method_before
private void add(Document doc, Values<ChangeData> values) throws OrmException {
    String name = values.getField().getName();
    FieldType<?> type = values.getField().getType();
    Store store = store(values.getField());
    if (type == FieldType.INTEGER || type == FieldType.INTEGER_RANGE) {
        for (Object value : values.getValues()) {
            doc.add(new IntField(name, (Integer) value, store));
        }
    } else if (type == FieldType.LONG) {
        for (Object value : values.getValues()) {
            doc.add(new LongField(name, (Long) value, store));
        }
    } else if (type == FieldType.TIMESTAMP) {
        @SuppressWarnings("deprecation")
        boolean legacy = values.getField() == ChangeField.LEGACY_UPDATED;
        if (legacy) {
            for (Object value : values.getValues()) {
                int t = queryBuilder.toIndexTimeInMinutes((Timestamp) value);
                doc.add(new IntField(name, (int) t, store));
            }
        } else {
            for (Object value : values.getValues()) {
                doc.add(new LongField(name, ((Timestamp) value).getTime(), store));
            }
        }
    } else if (type == FieldType.EXACT || type == FieldType.PREFIX) {
        for (Object value : values.getValues()) {
            doc.add(new StringField(name, (String) value, store));
        }
    } else if (type == FieldType.FULL_TEXT) {
        for (Object value : values.getValues()) {
            doc.add(new TextField(name, (String) value, store));
        }
    } else if (type == FieldType.STORED_ONLY) {
        for (Object value : values.getValues()) {
            doc.add(new StoredField(name, (byte[]) value));
        }
    } else {
        throw QueryBuilder.badFieldType(type);
    }
}
#method_after
private void add(Document doc, Values<ChangeData> values) {
    String name = values.getField().getName();
    FieldType<?> type = values.getField().getType();
    Store store = store(values.getField());
    if (type == FieldType.INTEGER || type == FieldType.INTEGER_RANGE) {
        for (Object value : values.getValues()) {
            doc.add(new IntField(name, (Integer) value, store));
        }
    } else if (type == FieldType.LONG) {
        for (Object value : values.getValues()) {
            doc.add(new LongField(name, (Long) value, store));
        }
    } else if (type == FieldType.TIMESTAMP) {
        @SuppressWarnings("deprecation")
        boolean legacy = values.getField() == ChangeField.LEGACY_UPDATED;
        if (legacy) {
            for (Object value : values.getValues()) {
                int t = queryBuilder.toIndexTimeInMinutes((Timestamp) value);
                doc.add(new IntField(name, t, store));
            }
        } else {
            for (Object value : values.getValues()) {
                doc.add(new LongField(name, ((Timestamp) value).getTime(), store));
            }
        }
    } else if (type == FieldType.EXACT || type == FieldType.PREFIX) {
        for (Object value : values.getValues()) {
            doc.add(new StringField(name, (String) value, store));
        }
    } else if (type == FieldType.FULL_TEXT) {
        for (Object value : values.getValues()) {
            doc.add(new TextField(name, (String) value, store));
        }
    } else if (type == FieldType.STORED_ONLY) {
        for (Object value : values.getValues()) {
            doc.add(new StoredField(name, (byte[]) value));
        }
    } else {
        throw QueryBuilder.badFieldType(type);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public static Integer getLimit(Predicate<ChangeData> p) {
    IntPredicate<?> ip = (IntPredicate<?>) find(p, IntPredicate.class, FIELD_LIMIT);
    return ip != null ? ip.intValue() : null;
}
#method_after
@SuppressWarnings("unchecked")
public static Integer getLimit(Predicate<ChangeData> p) {
    IntPredicate<?> ip = find(p, IntPredicate.class, FIELD_LIMIT);
    return ip != null ? ip.intValue() : null;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> comment(String value) throws QueryParseException {
    ChangeIndex index = args.indexes.getSearchIndex();
    return new CommentPredicate(args, index, value);
}
#method_after
@Operator
public Predicate<ChangeData> comment(String value) {
    ChangeIndex index = args.indexes.getSearchIndex();
    return new CommentPredicate(args, index, value);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args, currentUser);
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, currentUser, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return new IsReviewedPredicate();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(self(), args.allowsDrafts);
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(schema(args.indexes));
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args, currentUser);
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, currentUser, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return new IsReviewedPredicate();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(self(), args.allowsDrafts);
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(schema(args.indexes), args.fillArgs);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> parentproject(String name) {
    return new ParentProjectPredicate(args.db, args.projectCache, args.listChildProjects, args.self, name);
}
#method_after
@Operator
public Predicate<ChangeData> parentproject(String name) {
    return new ParentProjectPredicate(args.projectCache, args.listChildProjects, args.self, name);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> f(String file) throws QueryParseException {
    return file(file);
}
#method_after
@Operator
public Predicate<ChangeData> f(String file) {
    return file(file);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (file.startsWith("^")) {
        return new RegexPathPredicate(FIELD_FILE, file);
    } else {
        return EqualsFilePredicate.create(args, file);
    }
}
#method_after
@Operator
public Predicate<ChangeData> file(String file) {
    if (file.startsWith("^")) {
        return new RegexPathPredicate(file);
    } else {
        return EqualsFilePredicate.create(args, file);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> path(String path) throws QueryParseException {
    if (path.startsWith("^")) {
        return new RegexPathPredicate(FIELD_PATH, path);
    } else {
        return new EqualsPathPredicate(FIELD_PATH, path);
    }
}
#method_after
@Operator
public Predicate<ChangeData> path(String path) {
    if (path.startsWith("^")) {
        return new RegexPathPredicate(path);
    } else {
        return new EqualsPathPredicate(FIELD_PATH, path);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> message(String text) throws QueryParseException {
    ChangeIndex index = args.indexes.getSearchIndex();
    return new MessagePredicate(args, index, text);
}
#method_after
@Operator
public Predicate<ChangeData> message(String text) {
    ChangeIndex index = args.indexes.getSearchIndex();
    return new MessagePredicate(args, index, text);
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        return change(query);
    }
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(9);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(file(query));
    } catch (QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(message(query));
    } catch (QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(comment(query));
    } catch (QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(projects(query));
    } catch (QueryParseException e) {
    // Skip.
    }
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        return change(query);
    }
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(9);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    try {
        predicates.add(projects(query));
    } catch (QueryParseException e) {
    // Skip.
    }
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    return Predicate.or(predicates);
}
#end_block

#method_before
public static ChangeData createForTest(Change.Id id, int currentPatchSetId) {
    ChangeData cd = new ChangeData(null, null, null, null, null, null, null, null, null, null, null, null, null, id);
    cd.currentPatchSet = new PatchSet(new PatchSet.Id(id, currentPatchSetId));
    return cd;
}
#method_after
static ChangeData createForTest(Change.Id id, int currentPatchSetId) {
    ChangeData cd = new ChangeData(null, null, null, null, null, null, null, null, null, null, null, null, null, id);
    cd.currentPatchSet = new PatchSet(new PatchSet.Id(id, currentPatchSetId));
    return cd;
}
#end_block

#method_before
public boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else {
            PatchSet ps = currentPatchSet();
            Ref ref;
            Repository repo = null;
            try {
                repo = repoManager.openRepository(c.getProject());
                ref = repo.getRef(c.getDest().get());
            } catch (IOException e) {
                throw new OrmException(e);
            } finally {
                if (repo != null) {
                    repo.close();
                }
            }
            SubmitTypeRecord rec = new SubmitRuleEvaluator(this).setUser(userFactory.create(c.getOwner())).getSubmitType();
            if (rec.status != SubmitTypeRecord.Status.OK) {
                throw new OrmException("Error in mergeability check: " + rec.errorMessage);
            }
            String mergeStrategy = mergeUtilFactory.create(projectCache.get(c.getProject())).mergeStrategyName();
            mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref != null ? ref.getObjectId() : ObjectId.zeroId(), rec.type, mergeStrategy, c.getDest());
        }
    }
    return mergeable;
}
#method_after
public boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else {
            PatchSet ps = currentPatchSet();
            Repository repo = null;
            try {
                repo = repoManager.openRepository(c.getProject());
                Ref ref = repo.getRef(c.getDest().get());
                SubmitTypeRecord rec = new SubmitRuleEvaluator(this).getSubmitType();
                if (rec.status != SubmitTypeRecord.Status.OK) {
                    throw new OrmException("Error in mergeability check: " + rec.errorMessage);
                }
                String mergeStrategy = mergeUtilFactory.create(projectCache.get(c.getProject())).mergeStrategyName();
                mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref, rec.type, mergeStrategy, c.getDest(), repo, db);
            } catch (IOException e) {
                throw new OrmException(e);
            } finally {
                if (repo != null) {
                    repo.close();
                }
            }
        }
    }
    return mergeable;
}
#end_block

#method_before
@Override
public boolean match(ChangeData object) throws OrmException {
    return object.isMergeable();
}
#method_after
@Override
public boolean match(ChangeData object) throws OrmException {
    return getValue().equals(getField().get(object, args));
}
#end_block

#method_before
public void delete(int cdId) throws IOException {
    for (ChangeIndex i : getWriteIndexes()) {
        i.delete(cdId);
    }
}
#method_after
public void delete(int id) throws IOException {
    for (ChangeIndex i : getWriteIndexes()) {
        i.delete(id);
    }
}
#end_block

#method_before
@Override
public void delete(int cdId) throws IOException {
}
#method_after
@Override
public void delete(int id) throws IOException {
}
#end_block

#method_before
@Override
public ChangeResource parse(TopLevelResource root, IdString id) throws ResourceNotFoundException, OrmException {
    List<Change> changes = findChanges(id.encoded());
    if (changes.size() != 1) {
        try {
            changeUtil.deleteChange(Integer.parseInt(id.get()));
        } catch (NumberFormatException | IOException e) {
            throw new ResourceNotFoundException(id.get(), e);
        }
        throw new ResourceNotFoundException(id);
    }
    ChangeControl control;
    try {
        control = changeControlFactory.validateFor(changes.get(0), user.get());
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(id);
    }
    return new ChangeResource(control);
}
#method_after
@Override
public ChangeResource parse(TopLevelResource root, IdString id) throws ResourceNotFoundException, OrmException {
    List<Change> changes = findChanges(id.encoded());
    if (changes.isEmpty()) {
        Integer changeId = Ints.tryParse(id.get());
        if (changeId != null) {
            try {
                changeIndexer.delete(changeId);
            } catch (IOException e) {
                throw new ResourceNotFoundException(id.get(), e);
            }
        }
    }
    if (changes.size() != 1) {
        throw new ResourceNotFoundException(id);
    }
    ChangeControl control;
    try {
        control = changeControlFactory.validateFor(changes.get(0), user.get());
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(id);
    }
    return new ChangeResource(control);
}
#end_block

#method_before
@Override
public void delete(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    try {
        if (cd.change().getStatus().isOpen()) {
            openIndex.deleteById(id);
            commit(openIndex);
        } else {
            closedIndex.deleteById(id);
            commit(closedIndex);
        }
    } catch (OrmException | SolrServerException e) {
        throw new IOException(e);
    }
}
#method_after
@Override
public void delete(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    try {
        if (cd.change().getStatus().isOpen()) {
            delete(id, openIndex);
        } else {
            delete(id, closedIndex);
        }
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public void delete(int cdId) throws IOException {
}
#method_after
@Override
public void delete(int id) throws IOException {
    String idString = Integer.toString(id);
    delete(idString, openIndex);
    delete(idString, closedIndex);
}
#end_block

#method_before
@Override
public void delete(int cdId) throws IOException {
}
#method_after
private void delete(String id, CloudSolrServer index) throws IOException {
    try {
        index.deleteById(id);
        commit(index);
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public void delete(int cdId) throws IOException {
    Term id = QueryBuilder.idTerm(cdId);
    try {
        Futures.allAsList(openIndex.delete(id), closedIndex.delete(id)).get();
    } catch (ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public void delete(int id) throws IOException {
    Term idTerm = QueryBuilder.idTerm(id);
    try {
        Futures.allAsList(openIndex.delete(idTerm), closedIndex.delete(idTerm)).get();
    } catch (ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public void delete(int cdId) throws IOException {
}
#method_after
@Override
public void delete(int id) throws IOException {
}
#end_block

#method_before
private void doAssertApproval(int expected, ChangeInfo c) {
    LabelInfo cr = c.labels.get("Code-Review");
    assertThat((int) cr.defaultValue).isEqualTo(-1);
    assertThat(cr.all.size()).isEqualTo(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value.intValue()).isEqualTo(expected);
}
#method_after
private void doAssertApproval(int expected, ChangeInfo c) {
    LabelInfo cr = c.labels.get("Code-Review");
    assertThat((int) cr.defaultValue).isEqualTo(-1);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value.intValue()).isEqualTo(expected);
}
#end_block

#method_before
@Test
public void customLabelNoOp_NegativeVoteNotBlock() throws Exception {
    Q.setFunctionName("NoOp");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all.size()).isEqualTo(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#method_after
@Test
public void customLabelNoOp_NegativeVoteNotBlock() throws Exception {
    Q.setFunctionName("NoOp");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#end_block

#method_before
@Test
public void customLabelNoBlock_NegativeVoteNotBlock() throws Exception {
    Q.setFunctionName("NoBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all.size()).isEqualTo(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#method_after
@Test
public void customLabelNoBlock_NegativeVoteNotBlock() throws Exception {
    Q.setFunctionName("NoBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#end_block

#method_before
@Test
public void customLabelMaxNoBlock_NegativeVoteNotBlock() throws Exception {
    Q.setFunctionName("MaxNoBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all.size()).isEqualTo(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#method_after
@Test
public void customLabelMaxNoBlock_NegativeVoteNotBlock() throws Exception {
    Q.setFunctionName("MaxNoBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#end_block

#method_before
@Test
public void customLabelAnyWithBlock_NegativeVoteBlock() throws Exception {
    Q.setFunctionName("AnyWithBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all.size()).isEqualTo(1);
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isTrue();
}
#method_after
@Test
public void customLabelAnyWithBlock_NegativeVoteBlock() throws Exception {
    Q.setFunctionName("AnyWithBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isTrue();
}
#end_block

#method_before
@Test
public void customLabelMaxWithBlock_NegativeVoteBlock() throws Exception {
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all.size()).isEqualTo(1);
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isTrue();
}
#method_after
@Test
public void customLabelMaxWithBlock_NegativeVoteBlock() throws Exception {
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isTrue();
}
#end_block

#method_before
@Test
public void createDraft() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput.CommentInput comment = newCommentInfo("file1", Comment.Side.REVISION, 1, "comment 1");
    addDraft(changeId, revId, comment);
    Map<String, List<CommentInfo>> result = getDraftComments(changeId, revId);
    assertThat(result.size()).isEqualTo(1);
    CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
    assertCommentInfo(comment, actual);
}
#method_after
@Test
public void createDraft() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput.CommentInput comment = newCommentInfo("file1", Comment.Side.REVISION, 1, "comment 1");
    addDraft(changeId, revId, comment);
    Map<String, List<CommentInfo>> result = getDraftComments(changeId, revId);
    assertThat(result).hasSize(1);
    CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
    assertCommentInfo(comment, actual);
}
#end_block

#method_before
@Test
public void postComment() throws Exception {
    String file = "file";
    String contents = "contents";
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), "first subject", file, contents);
    PushOneCommit.Result r = push.to(git, "refs/for/master");
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput input = new ReviewInput();
    ReviewInput.CommentInput comment = newCommentInfo(file, Comment.Side.REVISION, 1, "comment 1");
    input.comments = new HashMap<>();
    input.comments.put(comment.path, Lists.newArrayList(comment));
    revision(r).review(input);
    Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
    assertThat(result.isEmpty()).isFalse();
    CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
    assertCommentInfo(comment, actual);
}
#method_after
@Test
public void postComment() throws Exception {
    String file = "file";
    String contents = "contents";
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), "first subject", file, contents);
    PushOneCommit.Result r = push.to(git, "refs/for/master");
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput input = new ReviewInput();
    ReviewInput.CommentInput comment = newCommentInfo(file, Comment.Side.REVISION, 1, "comment 1");
    input.comments = new HashMap<>();
    input.comments.put(comment.path, Lists.newArrayList(comment));
    revision(r).review(input);
    Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
    assertThat(result).isNotEmpty();
    CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
    assertCommentInfo(comment, actual);
}
#end_block

#method_before
@Test
public void deleteDraft() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput.CommentInput comment = newCommentInfo("file1", Comment.Side.REVISION, 1, "comment 1");
    CommentInfo returned = addDraft(changeId, revId, comment);
    deleteDraft(changeId, revId, returned.id);
    Map<String, List<CommentInfo>> drafts = getDraftComments(changeId, revId);
    assertThat(drafts.isEmpty()).isTrue();
}
#method_after
@Test
public void deleteDraft() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput.CommentInput comment = newCommentInfo("file1", Comment.Side.REVISION, 1, "comment 1");
    CommentInfo returned = addDraft(changeId, revId, comment);
    deleteDraft(changeId, revId, returned.id);
    Map<String, List<CommentInfo>> drafts = getDraftComments(changeId, revId);
    assertThat(drafts).isEmpty();
}
#end_block

#method_before
@Test
public void getRelatedNoResult() throws Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent());
    PatchSet.Id ps = push.to(git, "refs/for/master").getPatchSetId();
    List<ChangeAndCommit> related = getRelated(ps);
    assertThat(related.size()).isEqualTo(0);
}
#method_after
@Test
public void getRelatedNoResult() throws Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent());
    PatchSet.Id ps = push.to(git, "refs/for/master").getPatchSetId();
    List<ChangeAndCommit> related = getRelated(ps);
    assertThat(related).isEmpty();
}
#end_block

#method_before
@Test
public void getRelatedLinear() throws Exception {
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    pushHead(git, "refs/for/master", false);
    for (Commit c : ImmutableList.of(c2, c1)) {
        List<ChangeAndCommit> related = getRelated(getPatchSetId(c));
        assertThat(related.size()).isEqualTo(2);
        assertThat(related.get(0).changeId).named("related to " + c.getChangeId()).isEqualTo(c2.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + c.getChangeId()).isEqualTo(c1.getChangeId());
    }
}
#method_after
@Test
public void getRelatedLinear() throws Exception {
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    pushHead(git, "refs/for/master", false);
    for (Commit c : ImmutableList.of(c2, c1)) {
        List<ChangeAndCommit> related = getRelated(getPatchSetId(c));
        assertThat(related).hasSize(2);
        assertThat(related.get(0).changeId).named("related to " + c.getChangeId()).isEqualTo(c2.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + c.getChangeId()).isEqualTo(c1.getChangeId());
    }
}
#end_block

#method_before
@Test
public void getRelatedReorder() throws Exception {
    // Create two commits and push.
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps1 = getPatchSetId(c1);
    PatchSet.Id c2ps1 = getPatchSetId(c2);
    // Swap the order of commits and push again.
    git.reset().setMode(ResetType.HARD).setRef("HEAD^^").call();
    git.cherryPick().include(c2.getCommit()).include(c1.getCommit()).call();
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps2 = getPatchSetId(c1);
    PatchSet.Id c2ps2 = getPatchSetId(c2);
    for (PatchSet.Id ps : ImmutableList.of(c2ps2, c1ps2)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related.size()).isEqualTo(2);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
    }
    for (PatchSet.Id ps : ImmutableList.of(c2ps1, c1ps1)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related.size()).isEqualTo(2);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
    }
}
#method_after
@Test
public void getRelatedReorder() throws Exception {
    // Create two commits and push.
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps1 = getPatchSetId(c1);
    PatchSet.Id c2ps1 = getPatchSetId(c2);
    // Swap the order of commits and push again.
    git.reset().setMode(ResetType.HARD).setRef("HEAD^^").call();
    git.cherryPick().include(c2.getCommit()).include(c1.getCommit()).call();
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps2 = getPatchSetId(c1);
    PatchSet.Id c2ps2 = getPatchSetId(c2);
    for (PatchSet.Id ps : ImmutableList.of(c2ps2, c1ps2)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related).hasSize(2);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
    }
    for (PatchSet.Id ps : ImmutableList.of(c2ps1, c1ps1)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related).hasSize(2);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
    }
}
#end_block

#method_before
@Test
public void getRelatedReorderAndExtend() throws Exception {
    // Create two commits and push.
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps1 = getPatchSetId(c1);
    PatchSet.Id c2ps1 = getPatchSetId(c2);
    // Swap the order of commits, create a new commit on top, and push again.
    git.reset().setMode(ResetType.HARD).setRef("HEAD^^").call();
    git.cherryPick().include(c2.getCommit()).include(c1.getCommit()).call();
    add(git, "c.txt", "3");
    Commit c3 = createCommit(git, admin.getIdent(), "subject: 3");
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps2 = getPatchSetId(c1);
    PatchSet.Id c2ps2 = getPatchSetId(c2);
    PatchSet.Id c3ps1 = getPatchSetId(c3);
    for (PatchSet.Id ps : ImmutableList.of(c3ps1, c2ps2, c1ps2)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related.size()).isEqualTo(3);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c3.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
        assertThat(related.get(2).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
    }
    for (PatchSet.Id ps : ImmutableList.of(c2ps1, c1ps1)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related.size()).isEqualTo(3);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c3.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
        assertThat(related.get(2).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
    }
}
#method_after
@Test
public void getRelatedReorderAndExtend() throws Exception {
    // Create two commits and push.
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps1 = getPatchSetId(c1);
    PatchSet.Id c2ps1 = getPatchSetId(c2);
    // Swap the order of commits, create a new commit on top, and push again.
    git.reset().setMode(ResetType.HARD).setRef("HEAD^^").call();
    git.cherryPick().include(c2.getCommit()).include(c1.getCommit()).call();
    add(git, "c.txt", "3");
    Commit c3 = createCommit(git, admin.getIdent(), "subject: 3");
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps2 = getPatchSetId(c1);
    PatchSet.Id c2ps2 = getPatchSetId(c2);
    PatchSet.Id c3ps1 = getPatchSetId(c3);
    for (PatchSet.Id ps : ImmutableList.of(c3ps1, c2ps2, c1ps2)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related).hasSize(3);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c3.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
        assertThat(related.get(2).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
    }
    for (PatchSet.Id ps : ImmutableList.of(c2ps1, c1ps1)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related).hasSize(3);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c3.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
        assertThat(related.get(2).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
    }
}
#end_block

#method_before
@Test
public void getRelatedEdit() throws Exception {
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    add(git, "b.txt", "3");
    Commit c3 = createCommit(git, admin.getIdent(), "subject: 3");
    pushHead(git, "refs/for/master", false);
    Change ch2 = getChange(c2);
    editModifier.createEdit(ch2, getPatchSet(ch2));
    String editRev = editUtil.byChange(ch2).get().getRevision().get();
    List<ChangeAndCommit> related = getRelated(ch2.getId(), 0);
    assertThat(related.size()).isEqualTo(3);
    assertThat(related.get(0).changeId).named("related to " + c2.getChangeId()).isEqualTo(c3.getChangeId());
    assertThat(related.get(1).changeId).named("related to " + c2.getChangeId()).isEqualTo(c2.getChangeId());
    assertThat(related.get(1)._revisionNumber.intValue()).named("has edit revision number").isEqualTo(0);
    assertThat(related.get(1).commit.commit).named("has edit revision " + editRev).isEqualTo(editRev);
    assertThat(related.get(2).changeId).named("related to " + c2.getChangeId()).isEqualTo(c1.getChangeId());
}
#method_after
@Test
public void getRelatedEdit() throws Exception {
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    add(git, "b.txt", "3");
    Commit c3 = createCommit(git, admin.getIdent(), "subject: 3");
    pushHead(git, "refs/for/master", false);
    Change ch2 = getChange(c2);
    editModifier.createEdit(ch2, getPatchSet(ch2));
    String editRev = editUtil.byChange(ch2).get().getRevision().get();
    List<ChangeAndCommit> related = getRelated(ch2.getId(), 0);
    assertThat(related).hasSize(3);
    assertThat(related.get(0).changeId).named("related to " + c2.getChangeId()).isEqualTo(c3.getChangeId());
    assertThat(related.get(1).changeId).named("related to " + c2.getChangeId()).isEqualTo(c2.getChangeId());
    assertThat(related.get(1)._revisionNumber.intValue()).named("has edit revision number").isEqualTo(0);
    assertThat(related.get(1).commit.commit).named("has edit revision " + editRev).isEqualTo(editRev);
    assertThat(related.get(2).changeId).named("related to " + c2.getChangeId()).isEqualTo(c1.getChangeId());
}
#end_block

#method_before
private void assertResult(RestResponse r, List<String> expected) throws IOException {
    assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_OK);
    List<String> result = toHashtagList(r);
    assertThat(result).containsSequence(expected);
}
#method_after
private void assertResult(RestResponse r, List<String> expected) throws IOException {
    assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_OK);
    List<String> result = toHashtagList(r);
    assertThat(result).containsExactlyElementsIn(expected);
}
#end_block

#method_before
private RestResponse POST(String changeId, String toAdd, String toRemove) throws IOException {
    HashtagsInput input = new HashtagsInput();
    if (toAdd != null) {
        input.add = new HashSet<String>(Lists.newArrayList(Splitter.on(CharMatcher.anyOf(",")).split(toAdd)));
    }
    if (toRemove != null) {
        input.remove = new HashSet<String>(Lists.newArrayList(Splitter.on(CharMatcher.anyOf(",")).split(toRemove)));
    }
    return adminSession.post("/changes/" + changeId + "/hashtags/", input);
}
#method_after
private RestResponse POST(String changeId, String toAdd, String toRemove) throws IOException {
    HashtagsInput input = new HashtagsInput();
    if (toAdd != null) {
        input.add = new HashSet<>(Lists.newArrayList(Splitter.on(CharMatcher.anyOf(",")).split(toAdd)));
    }
    if (toRemove != null) {
        input.remove = new HashSet<>(Lists.newArrayList(Splitter.on(CharMatcher.anyOf(",")).split(toRemove)));
    }
    return adminSession.post("/changes/" + changeId + "/hashtags/", input);
}
#end_block

#method_before
public void assertChange(Change.Status expectedStatus, String expectedTopic, TestAccount... expectedReviewers) throws OrmException {
    Change c = Iterables.getOnlyElement(db.changes().byKey(new Change.Key(commit.getChangeId())).toList());
    assertThat(subject).isEqualTo(c.getSubject());
    assertThat(expectedStatus).isEqualTo(c.getStatus());
    assertThat(expectedTopic).isEqualTo(Strings.emptyToNull(c.getTopic()));
    assertReviewers(c, expectedReviewers);
}
#method_after
public void assertChange(Change.Status expectedStatus, String expectedTopic, TestAccount... expectedReviewers) throws OrmException {
    Change c = Iterables.getOnlyElement(db.changes().byKey(new Change.Key(commit.getChangeId())).toList());
    assertThat(resSubj).isEqualTo(c.getSubject());
    assertThat(expectedStatus).isEqualTo(c.getStatus());
    assertThat(expectedTopic).isEqualTo(Strings.emptyToNull(c.getTopic()));
    assertReviewers(c, expectedReviewers);
}
#end_block

#method_before
@Override
public MergeableInfo apply(RevisionResource resource) throws AuthException, ResourceConflictException, BadRequestException, OrmException, IOException {
    Change change = resource.getChange();
    PatchSet ps = resource.getPatchSet();
    MergeableInfo result = new MergeableInfo();
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + Submit.status(change));
    } else if (!ps.getId().equals(change.currentPatchSetId())) {
        // Only the current revision is mergeable. Others always fail.
        return result;
    }
    ChangeData cd = changeDataFactory.create(db.get(), resource.getControl());
    SubmitTypeRecord rec = new SubmitRuleEvaluator(cd).setPatchSet(ps).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new OrmException("Submit type rule failed: " + rec);
    }
    result.submitType = rec.type;
    result.mergeable = change.isMergeable();
    Repository git = gitManager.openRepository(change.getProject());
    try {
        Ref ref = git.getRef(change.getDest().get());
        if (force || isStale(change, ref)) {
            result.mergeable = refresh(change, ps, ref, result.submitType, git);
        }
        if (otherBranches) {
            result.mergeableInto = new ArrayList<>();
            BranchOrderSection branchOrder = projectCache.get(change.getProject()).getBranchOrderSection();
            if (branchOrder != null) {
                int prefixLen = Constants.R_HEADS.length();
                for (String n : branchOrder.getMoreStable(ref.getName())) {
                    Ref other = git.getRef(n);
                    if (other == null) {
                        continue;
                    }
                    if (isMergeable(change, ps, other, SubmitType.CHERRY_PICK, git)) {
                        result.mergeableInto.add(other.getName().substring(prefixLen));
                    }
                }
            }
        }
    } finally {
        git.close();
    }
    return result;
}
#method_after
@Override
public MergeableInfo apply(RevisionResource resource) throws AuthException, ResourceConflictException, BadRequestException, OrmException, IOException {
    Change change = resource.getChange();
    PatchSet ps = resource.getPatchSet();
    MergeableInfo result = new MergeableInfo();
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + Submit.status(change));
    } else if (!ps.getId().equals(change.currentPatchSetId())) {
        // Only the current revision is mergeable. Others always fail.
        return result;
    }
    ChangeData cd = changeDataFactory.create(db.get(), resource.getControl());
    SubmitTypeRecord rec = new SubmitRuleEvaluator(cd).setPatchSet(ps).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new OrmException("Submit type rule failed: " + rec);
    }
    result.submitType = rec.type;
    result.mergeable = change.isMergeable();
    Repository git = gitManager.openRepository(change.getProject());
    try {
        Ref ref = git.getRef(change.getDest().get());
        boolean refresh = force || isStale(change, ref);
        if (!refresh && !otherBranches) {
            return result;
        }
        ProjectState projectState = projectCache.get(change.getProject());
        String strategy = mergeUtilFactory.create(projectState).mergeStrategyName();
        if (refresh) {
            result.mergeable = refresh(change, ps, ref, result.submitType, strategy, git);
        }
        if (otherBranches) {
            result.mergeableInto = new ArrayList<>();
            BranchOrderSection branchOrder = projectState.getBranchOrderSection();
            if (branchOrder != null) {
                int prefixLen = Constants.R_HEADS.length();
                for (String n : branchOrder.getMoreStable(ref.getName())) {
                    Ref other = git.getRef(n);
                    if (other == null) {
                        continue;
                    }
                    if (isMergeable(change, ps, other, CHERRY_PICK, strategy, git)) {
                        result.mergeableInto.add(other.getName().substring(prefixLen));
                    }
                }
            }
        }
    } finally {
        git.close();
    }
    return result;
}
#end_block

#method_before
private boolean refresh(final Change change, final PatchSet ps, final Ref ref, SubmitType type, Repository git) throws OrmException, IOException {
    final boolean mergeable = isMergeable(change, ps, ref, type, git);
    Change c = db.get().changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change c) {
            if (c.getStatus().isOpen() && ps.getId().equals(c.currentPatchSetId())) {
                c.setMergeable(mergeable);
                c.setLastSha1MergeTested(toRevId(ref));
                return c;
            } else {
                return null;
            }
        }
    });
    if (c != null) {
        indexer.index(db.get(), c);
    }
    return mergeable;
}
#method_after
private boolean refresh(final Change change, final PatchSet ps, final Ref ref, SubmitType type, String strategy, Repository git) throws OrmException, IOException {
    final boolean mergeable = isMergeable(change, ps, ref, type, strategy, git);
    Change c = db.get().changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change c) {
            if (c.getStatus().isOpen() && ps.getId().equals(c.currentPatchSetId())) {
                c.setMergeable(mergeable);
                c.setLastSha1MergeTested(toRevId(ref));
                return c;
            } else {
                return null;
            }
        }
    });
    if (reindex && c != null) {
        indexer.index(db.get(), c);
    }
    return mergeable;
}
#end_block

#method_before
private boolean isMergeable(Change change, PatchSet ps, Ref ref, SubmitType type, Repository git) {
    ObjectId commit;
    try {
        commit = ObjectId.fromString(ps.getRevision().get());
    } catch (IllegalArgumentException e) {
        log.error("Invalid revision on patch set " + ps);
        return false;
    }
    ObjectId into = ref != null && ref.getObjectId() != null ? ref.getObjectId() : ObjectId.zeroId();
    return cache.load(commit, into, type, change.getDest(), git);
}
#method_after
private boolean isMergeable(Change change, PatchSet ps, Ref ref, SubmitType type, String strategy, Repository git) {
    ObjectId commit;
    try {
        commit = ObjectId.fromString(ps.getRevision().get());
    } catch (IllegalArgumentException e) {
        log.error("Invalid revision on patch set " + ps);
        return false;
    }
    return cache.get(commit, ref, type, strategy, change.getDest(), git, db.get());
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(CACHE_NAME, EntryKey.class, Boolean.class).maximumWeight(1 << 20).weigher(MergeabilityWeigher.class);
            bind(MergeabilityCache.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(CACHE_NAME, EntryKey.class, Boolean.class).maximumWeight(1 << 20).weigher(MergeabilityWeigher.class).loader(Loader.class);
            bind(MergeabilityCache.class);
        }
    };
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (o instanceof EntryKey) {
        EntryKey k = (EntryKey) o;
        return commit.equals(k.commit) && into.equals(k.into) && submitType == k.submitType;
    }
    return false;
}
#method_after
@Override
public boolean equals(Object o) {
    if (o instanceof EntryKey) {
        EntryKey k = (EntryKey) o;
        return commit.equals(k.commit) && into.equals(k.into) && submitType == k.submitType && mergeStrategy.equals(k.mergeStrategy);
    }
    return false;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(commit, into, submitType);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(commit, into, submitType, mergeStrategy);
}
#end_block

#method_before
private void writeObject(ObjectOutputStream out) throws IOException {
    writeNotNull(out, commit);
    writeNotNull(out, into);
    writeVarInt32(out, submitType.ordinal());
}
#method_after
private void writeObject(ObjectOutputStream out) throws IOException {
    writeNotNull(out, commit);
    writeNotNull(out, into);
    Character c = SUBMIT_TYPES.get(submitType);
    if (c == null) {
        throw new IOException("Invalid submit type: " + submitType);
    }
    out.writeChar(c);
    writeString(out, mergeStrategy);
}
#end_block

#method_before
private void readObject(ObjectInputStream in) throws IOException {
    commit = readNotNull(in);
    into = readNotNull(in);
    submitType = SubmitType.values()[readVarInt32(in)];
}
#method_after
private void readObject(ObjectInputStream in) throws IOException {
    commit = readNotNull(in);
    into = readNotNull(in);
    char t = in.readChar();
    submitType = SUBMIT_TYPES.inverse().get(t);
    if (submitType == null) {
        throw new IOException("Invalid submit type code: " + t);
    }
    mergeStrategy = readString(in);
}
#end_block

#method_before
@Override
public int weigh(EntryKey k, Boolean v) {
    return // Size of EntryKey, 64-bit JVM.
    16 + 2 * (16 + 20) + 1 + // Size of Boolean.
    1;
}
#method_after
@Override
public int weigh(EntryKey k, Boolean v) {
    return // Size of EntryKey, 64-bit JVM.
    16 + 2 * (16 + 20) + 3 * 8 + // Size of Boolean.
    8;
}
#end_block

#method_before
public boolean get(ObjectId commit, ObjectId into, SubmitType submitType, Branch.NameKey dest) {
    EntryKey key = new EntryKey(commit, into, submitType);
    Boolean result = cache.getIfPresent(key);
    if (result != null) {
        return result;
    }
    Project.NameKey p = dest.getParentKey();
    try {
        Repository repo = repoManager.openRepository(p);
        try {
            return load(key, dest, repo);
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        return failed(key, e);
    }
}
#method_after
public boolean get(ObjectId commit, Ref intoRef, SubmitType submitType, String mergeStrategy, Branch.NameKey dest, Repository repo, ReviewDb db) {
    ObjectId into = intoRef != null ? intoRef.getObjectId() : ObjectId.zeroId();
    EntryKey key = new EntryKey(commit, into, submitType, mergeStrategy, dest, repo, db);
    try {
        return cache.get(key);
    } catch (ExecutionException e) {
        log.error(String.format("Error checking mergeability of %s into %s (%s)", key.commit.name(), key.into.name(), key.submitType.name()), e.getCause());
        return false;
    }
}
#end_block

#method_before
@Test
public void cherryPick() throws Exception {
    PushOneCommit.Result r = createChange();
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = "it goes to stable branch";
    gApi.projects().name(project.get()).branch(in.destination).create(new BranchInput());
    ChangeApi orig = gApi.changes().id("p~master~" + r.getChangeId());
    assertEquals(1, orig.get().messages.size());
    ChangeApi cherry = orig.revision(r.getCommit().name()).cherryPick(in);
    assertEquals(2, orig.get().messages.size());
    assertTrue(cherry.get().subject.contains(in.message));
    cherry.current().review(ReviewInput.approve());
    cherry.current().submit();
}
#method_after
@Test
public void cherryPick() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master%topic=someTopic");
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = "it goes to stable branch";
    gApi.projects().name(project.get()).branch(in.destination).create(new BranchInput());
    ChangeApi orig = gApi.changes().id("p~master~" + r.getChangeId());
    assertEquals(1, orig.get().messages.size());
    ChangeApi cherry = orig.revision(r.getCommit().name()).cherryPick(in);
    assertEquals(2, orig.get().messages.size());
    assertTrue(cherry.get().subject.contains(in.message));
    assertEquals("someTopic", cherry.get().topic);
    cherry.current().review(ReviewInput.approve());
    cherry.current().submit();
}
#end_block

#method_before
public Change.Id editCommitMessage(ChangeControl ctl, PatchSet.Id patchSetId, String message, PersonIdent myIdent) throws NoSuchChangeException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException {
    Change.Id changeId = patchSetId.getParentKey();
    PatchSet originalPS = db.get().patchSets().get(patchSetId);
    if (originalPS == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (message == null || message.length() == 0) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    Repository git;
    try {
        git = gitManager.openRepository(ctl.getChange().getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        RevWalk revWalk = new RevWalk(git);
        try {
            RevCommit commit = revWalk.parseCommit(ObjectId.fromString(originalPS.getRevision().get()));
            if (commit.getFullMessage().equals(message)) {
                throw new InvalidChangeOperationException("New commit message cannot be same as existing commit message");
            }
            Date now = myIdent.getWhen();
            Change change = db.get().changes().get(changeId);
            PersonIdent authorIdent = user().newCommitterIdent(now, myIdent.getTimeZone());
            CommitBuilder commitBuilder = new CommitBuilder();
            commitBuilder.setTreeId(commit.getTree());
            commitBuilder.setParentIds(commit.getParents());
            commitBuilder.setAuthor(commit.getAuthorIdent());
            commitBuilder.setCommitter(authorIdent);
            commitBuilder.setMessage(message);
            RevCommit newCommit;
            ObjectInserter oi = git.newObjectInserter();
            try {
                ObjectId id = oi.insert(commitBuilder);
                oi.flush();
                newCommit = revWalk.parseCommit(id);
            } finally {
                oi.release();
            }
            PatchSet.Id id = nextPatchSetId(git, change.currentPatchSetId());
            PatchSet newPatchSet = new PatchSet(id);
            newPatchSet.setCreatedOn(new Timestamp(now.getTime()));
            newPatchSet.setUploader(user().getAccountId());
            newPatchSet.setRevision(new RevId(newCommit.name()));
            String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
            change = patchSetInserterFactory.create(git, revWalk, ctl, newCommit).setPatchSet(newPatchSet).setMessage(msg).setCopyLabels(true).setValidatePolicy(RECEIVE_COMMITS).setDraft(originalPS.isDraft()).insert();
            return change.getId();
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#method_after
public Change.Id editCommitMessage(ChangeControl ctl, PatchSet ps, String message, PersonIdent myIdent) throws NoSuchChangeException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException {
    Change change = ctl.getChange();
    Change.Id changeId = change.getId();
    if (Strings.isNullOrEmpty(message)) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    Repository git;
    try {
        git = gitManager.openRepository(ctl.getChange().getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        RevWalk revWalk = new RevWalk(git);
        try {
            RevCommit commit = revWalk.parseCommit(ObjectId.fromString(ps.getRevision().get()));
            if (commit.getFullMessage().equals(message)) {
                throw new InvalidChangeOperationException("New commit message cannot be same as existing commit message");
            }
            Date now = myIdent.getWhen();
            PersonIdent authorIdent = user().newCommitterIdent(now, myIdent.getTimeZone());
            CommitBuilder commitBuilder = new CommitBuilder();
            commitBuilder.setTreeId(commit.getTree());
            commitBuilder.setParentIds(commit.getParents());
            commitBuilder.setAuthor(commit.getAuthorIdent());
            commitBuilder.setCommitter(authorIdent);
            commitBuilder.setMessage(message);
            RevCommit newCommit;
            ObjectInserter oi = git.newObjectInserter();
            try {
                ObjectId id = oi.insert(commitBuilder);
                oi.flush();
                newCommit = revWalk.parseCommit(id);
            } finally {
                oi.release();
            }
            PatchSet.Id id = nextPatchSetId(git, change.currentPatchSetId());
            PatchSet newPatchSet = new PatchSet(id);
            newPatchSet.setCreatedOn(new Timestamp(now.getTime()));
            newPatchSet.setUploader(user().getAccountId());
            newPatchSet.setRevision(new RevId(newCommit.name()));
            String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
            change = patchSetInserterFactory.create(git, revWalk, ctl, newCommit).setPatchSet(newPatchSet).setMessage(msg).setCopyLabels(true).setValidatePolicy(RECEIVE_COMMITS).setDraft(ps.isDraft()).insert();
            return change.getId();
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
public void deleteDraftChange(Change.Id changeId) throws NoSuchChangeException, OrmException, IOException {
    ReviewDb db = this.db.get();
    Change change = db.changes().get(changeId);
    if (change == null || change.getStatus() != Change.Status.DRAFT) {
        throw new NoSuchChangeException(changeId);
    }
    for (PatchSet ps : db.patchSets().byChange(changeId)) {
        // These should all be draft patch sets.
        deleteOnlyDraftPatchSet(ps, change);
    }
    db.changeMessages().delete(db.changeMessages().byChange(changeId));
    db.starredChanges().delete(db.starredChanges().byChange(changeId));
    db.changes().delete(Collections.singleton(change));
    indexer.delete(db, change);
}
#method_after
public void deleteDraftChange(Change change) throws NoSuchChangeException, OrmException, IOException {
    Change.Id changeId = change.getId();
    if (change.getStatus() != Change.Status.DRAFT) {
        throw new NoSuchChangeException(changeId);
    }
    ReviewDb db = this.db.get();
    for (PatchSet ps : db.patchSets().byChange(changeId)) {
        // These should all be draft patch sets.
        deleteOnlyDraftPatchSet(ps, change);
    }
    db.changeMessages().delete(db.changeMessages().byChange(changeId));
    db.starredChanges().delete(db.starredChanges().byChange(changeId));
    db.changes().delete(Collections.singleton(change));
    indexer.delete(db, change);
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.maxBatchChanges;
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.destChanges.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.maxBatchChanges;
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.destChanges.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, Input input) throws ResourceConflictException, AuthException, ResourceNotFoundException, OrmException, IOException {
    if (rsrc.getChange().getStatus() != Status.DRAFT) {
        throw new ResourceConflictException("Change is not a draft");
    }
    if (!rsrc.getControl().canDeleteDraft(dbProvider.get())) {
        throw new AuthException("Not permitted to delete this draft change");
    }
    if (!allowDrafts) {
        throw new ResourceConflictException("Draft workflow is disabled.");
    }
    try {
        changeUtil.deleteDraftChange(rsrc.getChange().getId());
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, Input input) throws ResourceConflictException, AuthException, ResourceNotFoundException, OrmException, IOException {
    if (rsrc.getChange().getStatus() != Status.DRAFT) {
        throw new ResourceConflictException("Change is not a draft");
    }
    if (!rsrc.getControl().canDeleteDraft(dbProvider.get())) {
        throw new AuthException("Not permitted to delete this draft change");
    }
    if (!allowDrafts) {
        throw new ResourceConflictException("Draft workflow is disabled.");
    }
    try {
        changeUtil.deleteDraftChange(rsrc.getChange());
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
public static ReplicationFilter all() {
    return new ReplicationFilter();
}
#method_after
public static ReplicationFilter all() {
    return new ReplicationFilter(Collections.<String>emptyList());
}
#end_block

#method_before
public boolean matches(NameKey name) {
    if (matchAll) {
        return true;
    } else {
        String projectName = name.get();
        for (final String projectMatch : projectsToMatch) {
            if (isRE(projectMatch)) {
                // projectMatch is a regular expression
                if (projectName.matches(projectMatch)) {
                    return true;
                }
            } else if (isWildcard(projectMatch)) {
                // projectMatch is a wildcard
                if (projectName.startsWith(projectMatch.substring(0, projectMatch.length() - 1))) {
                    return true;
                }
            } else {
                // No special case, so we try to match directly
                if (projectName.equals(projectMatch)) {
                    return true;
                }
            }
        }
        // Nothing matched, so don't push the project
        return false;
    }
}
#method_after
public boolean matches(NameKey name) {
    if (projectPatterns.isEmpty()) {
        return true;
    } else {
        String projectName = name.get();
        for (String pattern : projectPatterns) {
            if (matchesPattern(projectName, pattern)) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
@Override
protected void run() throws Failure {
    if (all && projectNames.size() > 0) {
        throw new UnloggedFailure(1, "error: cannot combine --all and PROJECT");
    }
    ReplicationState state = new ReplicationState(new CommandProcessing(this));
    Future<?> future = null;
    ReplicationFilter projectFilter;
    if (all) {
        projectFilter = ReplicationFilter.all();
    } else {
        projectFilter = new ReplicationFilter(projectNames);
    }
    future = pushFactory.create(urlMatch, projectFilter, state).schedule(0, TimeUnit.SECONDS);
    if (wait) {
        if (future != null) {
            try {
                future.get();
            } catch (InterruptedException e) {
                stateLog.error("Thread was interrupted while waiting for PushAll operation to finish", e, state);
                return;
            } catch (ExecutionException e) {
                stateLog.error("An exception was thrown in PushAll operation", e, state);
                return;
            }
        }
        if (state.hasPushTask()) {
            try {
                state.waitForReplication();
            } catch (InterruptedException e) {
                writeStdErrSync("We are interrupted while waiting replication to complete");
            }
        } else {
            writeStdOutSync("Nothing to replicate");
        }
    }
}
#method_after
@Override
protected void run() throws Failure {
    if (all && projectPatterns.size() > 0) {
        throw new UnloggedFailure(1, "error: cannot combine --all and PROJECT");
    }
    ReplicationState state = new ReplicationState(new CommandProcessing(this));
    Future<?> future = null;
    ReplicationFilter projectFilter;
    if (all) {
        projectFilter = ReplicationFilter.all();
    } else {
        projectFilter = new ReplicationFilter(projectPatterns);
    }
    future = pushFactory.create(urlMatch, projectFilter, state).schedule(0, TimeUnit.SECONDS);
    if (wait) {
        if (future != null) {
            try {
                future.get();
            } catch (InterruptedException e) {
                stateLog.error("Thread was interrupted while waiting for PushAll operation to finish", e, state);
                return;
            } catch (ExecutionException e) {
                stateLog.error("An exception was thrown in PushAll operation", e, state);
                return;
            }
        }
        if (state.hasPushTask()) {
            try {
                state.waitForReplication();
            } catch (InterruptedException e) {
                writeStdErrSync("We are interrupted while waiting replication to complete");
            }
        } else {
            writeStdOutSync("Nothing to replicate");
        }
    }
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    try {
        repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
        boolean visible = threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
        if (!visible) {
            stateLog.warn(String.format("project %s is not visible", project), state);
            return;
        }
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, state);
        return;
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, delay);
    }
}
#method_after
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!isVisible(project, state)) {
        return;
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, delay);
    }
}
#end_block

#method_before
boolean wouldPushProject(Project.NameKey project) {
    // by default push all projects
    if (projects.length < 1) {
        return true;
    }
    return (new ReplicationFilter(Arrays.asList(projects))).matches(project);
}
#method_after
boolean wouldPushProject(final Project.NameKey project) {
    if (!isVisible(project)) {
        return false;
    }
    // by default push all projects
    if (projects.length < 1) {
        return true;
    }
    return (new ReplicationFilter(Arrays.asList(projects))).matches(project);
}
#end_block

#method_before
boolean isSingleProjectMatch() {
    boolean ret = (projects.length == 1);
    if (ret) {
        String projectMatch = projects[0];
        if (ReplicationFilter.isRE(projectMatch) || ReplicationFilter.isWildcard(projectMatch)) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#method_after
boolean isSingleProjectMatch() {
    boolean ret = (projects.length == 1);
    if (ret) {
        String projectMatch = projects[0];
        if (ReplicationFilter.getPatternType(projectMatch) != ReplicationFilter.PatternType.EXACT_MATCH) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#end_block

#method_before
@Override
public RestView<ProjectResource> list() throws ResourceNotFoundException, AuthException {
    return list;
}
#method_after
@Override
public RestView<ProjectResource> list() throws ResourceNotFoundException {
    return list;
}
#end_block

#method_before
@Override
public TagResource parse(ProjectResource parent, IdString id) throws ResourceNotFoundException, Exception {
    String tagName = id.get();
    if (!tagName.startsWith(Constants.R_TAGS)) {
        tagName = Constants.R_TAGS + tagName;
    }
    List<TagInfo> tags = list.apply(parent);
    for (TagInfo t : tags) {
        if (tagName.equals(t.getRef())) {
            return new TagResource(parent.getControl(), t);
        }
    }
    throw new ResourceNotFoundException();
}
#method_after
@Override
public TagResource parse(ProjectResource resource, IdString id) throws ResourceNotFoundException, IOException {
    return new TagResource(resource.getControl(), list.get(resource, id));
}
#end_block

#method_before
@Override
public List<TagInfo> apply(ProjectResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    List<TagInfo> tags = Lists.newArrayList();
    final Repository repo;
    try {
        repo = repoManager.openRepository(resource.getNameKey());
    } catch (RepositoryNotFoundException noGitRepository) {
        throw new ResourceNotFoundException();
    }
    try {
        RevWalk rw = new RevWalk(repo);
        try {
            final Map<String, Ref> all = repo.getRefDatabase().getRefs(Constants.R_TAGS);
            for (Ref ref : all.values()) {
                String name = ref.getName();
                RefControl refControl = resource.getControl().controlForRef(name);
                if (refControl.isVisible()) {
                    RevObject object = rw.parseAny(ref.getObjectId());
                    if (object instanceof RevTag) {
                        // Annotated/signed tag
                        tags.add(createTagInfo((RevTag) object, name));
                    } else if (object instanceof RevCommit) {
                        // Lightweight tag
                        tags.add(createTagInfo((RevCommit) object, name));
                    }
                }
            }
        } finally {
            rw.dispose();
        }
    } finally {
        repo.close();
    }
    Collections.sort(tags, new Comparator<TagInfo>() {

        @Override
        public int compare(TagInfo a, TagInfo b) {
            return a.getRef().compareTo(b.getRef());
        }
    });
    return tags;
}
#method_after
@Override
public List<TagInfo> apply(ProjectResource resource) throws IOException, ResourceNotFoundException {
    List<TagInfo> tags = Lists.newArrayList();
    Repository repo = getRepository(resource.getNameKey());
    try {
        RevWalk rw = new RevWalk(repo);
        try {
            Map<String, Ref> all = visibleTags(resource.getControl(), repo, repo.getRefDatabase().getRefs(Constants.R_TAGS));
            for (Ref ref : all.values()) {
                tags.add(createTagInfo(ref, rw));
            }
        } finally {
            rw.dispose();
        }
    } finally {
        repo.close();
    }
    Collections.sort(tags, new Comparator<TagInfo>() {

        @Override
        public int compare(TagInfo a, TagInfo b) {
            return a.ref.compareTo(b.ref);
        }
    });
    return tags;
}
#end_block

#method_before
private TagInfo createTagInfo(RevCommit commit, String name) {
    return new TagInfo(name, commit.getName());
}
#method_after
private static TagInfo createTagInfo(Ref ref, RevWalk rw) throws MissingObjectException, IOException {
    RevObject object = rw.parseAny(ref.getObjectId());
    if (object instanceof RevTag) {
        RevTag tag = (RevTag) object;
        // Annotated or signed tag
        return new TagInfo(Constants.R_TAGS + tag.getTagName(), tag.getName(), tag.getObject().getName(), tag.getFullMessage().trim(), CommonConverters.toGitPerson(tag.getTaggerIdent()));
    } else {
        // Lightweight tag
        return new TagInfo(ref.getName(), ref.getObjectId().getName());
    }
}
#end_block

#method_before
@Override
public Object apply(TagResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    return resource.getTagInfo();
}
#method_after
@Override
public TagInfo apply(TagResource resource) {
    return resource.getTagInfo();
}
#end_block

#method_before
@SuppressWarnings("resource")
private static PGPPublicKeyRingCollection readPubRing(final File pub) {
    try {
        InputStream in = new FileInputStream(pub);
        try {
            in = PGPUtil.getDecoderStream(in);
            return new PGPPublicKeyRingCollection(in);
        } finally {
            in.close();
        }
    } catch (IOException e) {
        throw new ProvisionException("Cannot read " + pub, e);
    } catch (PGPException e) {
        throw new ProvisionException("Cannot read " + pub, e);
    }
}
#method_after
private static PGPPublicKeyRingCollection readPubRing(final File pub) {
    try (InputStream fin = new FileInputStream(pub);
        InputStream in = PGPUtil.getDecoderStream(fin)) {
        return new PGPPublicKeyRingCollection(in);
    } catch (IOException e) {
        throw new ProvisionException("Cannot read " + pub, e);
    } catch (PGPException e) {
        throw new ProvisionException("Cannot read " + pub, e);
    }
}
#end_block

#method_before
private byte[] encrypt(final String name, final Date date, final byte[] rawText) throws NoSuchProviderException, PGPException, IOException {
    final byte[] zText = compress(name, date, rawText);
    final BcPGPDataEncryptorBuilder builder = new BcPGPDataEncryptorBuilder(PGPEncryptedData.CAST5).setSecureRandom(prng);
    final PGPEncryptedDataGenerator cpk = new PGPEncryptedDataGenerator(builder);
    final BcPublicKeyKeyEncryptionMethodGenerator methodGenerator = new BcPublicKeyKeyEncryptionMethodGenerator(dest);
    cpk.addMethod(methodGenerator);
    final ByteArrayOutputStream buf = new ByteArrayOutputStream();
    final ArmoredOutputStream aout = new ArmoredOutputStream(buf);
    final OutputStream cout = cpk.open(aout, zText.length);
    cout.write(zText);
    cout.close();
    aout.close();
    return buf.toByteArray();
}
#method_after
private byte[] encrypt(final String name, final Date date, final byte[] rawText) throws NoSuchProviderException, PGPException, IOException {
    final byte[] zText = compress(name, date, rawText);
    final ByteArrayOutputStream buf = new ByteArrayOutputStream();
    final ArmoredOutputStream aout = new ArmoredOutputStream(buf);
    final OutputStream cout = cpk().open(aout, zText.length);
    cout.write(zText);
    cout.close();
    aout.close();
    return buf.toByteArray();
}
#end_block

#method_before
public List<WebLinkInfo> getPatchSetLinks(String project, String commit) {
    List<WebLinkInfo> links = new ArrayList<>(4);
    for (PatchSetWebLink webLink : patchSetLinks) {
        String name = webLink.getLinkName();
        String url = webLink.getPatchSetUrl(project, commit);
        if (!Strings.isNullOrEmpty(name) && !Strings.isNullOrEmpty(url)) {
            links.add(new WebLinkInfo(name, webLink.getImageUrl(), url, webLink.getTarget()));
        }
    }
    return links;
}
#method_after
public FluentIterable<WebLinkInfo> getPatchSetLinks(final String project, final String commit) {
    return filterLinks(patchSetLinks, new Function<WebLink, WebLinkInfo>() {

        @Override
        public WebLinkInfo apply(WebLink webLink) {
            return ((PatchSetWebLink) webLink).getPathSetWebLink(project, commit);
        }
    });
}
#end_block

#method_before
public List<WebLinkInfo> getFileLinks(String project, String revision, String file) {
    List<WebLinkInfo> links = new ArrayList<>(4);
    for (FileWebLink webLink : fileLinks) {
        String name = webLink.getLinkName();
        String url = webLink.getFileUrl(project, revision, file);
        if (!Strings.isNullOrEmpty(name) && !Strings.isNullOrEmpty(url)) {
            links.add(new WebLinkInfo(name, webLink.getImageUrl(), url, webLink.getTarget()));
        }
    }
    return links;
}
#method_after
public FluentIterable<WebLinkInfo> getFileLinks(final String project, final String revision, final String file) {
    return filterLinks(fileLinks, new Function<WebLink, WebLinkInfo>() {

        @Override
        public WebLinkInfo apply(WebLink webLink) {
            return ((FileWebLink) webLink).getFileWebLink(project, revision, file);
        }
    });
}
#end_block

#method_before
public Iterable<WebLinkInfo> getProjectLinks(String project) {
    List<WebLinkInfo> links = Lists.newArrayList();
    for (ProjectWebLink webLink : projectLinks) {
        String name = webLink.getLinkName();
        String url = webLink.getProjectUrl(project);
        if (!Strings.isNullOrEmpty(name) && !Strings.isNullOrEmpty(url)) {
            links.add(new WebLinkInfo(name, webLink.getImageUrl(), url, webLink.getTarget()));
        }
    }
    return links;
}
#method_after
public FluentIterable<WebLinkInfo> getProjectLinks(final String project) {
    return filterLinks(projectLinks, new Function<WebLink, WebLinkInfo>() {

        @Override
        public WebLinkInfo apply(WebLink webLink) {
            return ((ProjectWebLink) webLink).getProjectWeblink(project);
        }
    });
}
#end_block

#method_before
public Iterable<WebLinkInfo> getBranchLinks(String project, String branch) {
    List<WebLinkInfo> links = Lists.newArrayList();
    for (BranchWebLink webLink : branchLinks) {
        String name = webLink.getLinkName();
        String url = webLink.getBranchUrl(project, branch);
        if (!Strings.isNullOrEmpty(name) && !Strings.isNullOrEmpty(url)) {
            links.add(new WebLinkInfo(name, webLink.getImageUrl(), url, webLink.getTarget()));
        }
    }
    return links;
}
#method_after
public FluentIterable<WebLinkInfo> getBranchLinks(final String project, final String branch) {
    return filterLinks(branchLinks, new Function<WebLink, WebLinkInfo>() {

        @Override
        public WebLinkInfo apply(WebLink webLink) {
            return ((BranchWebLink) webLink).getBranchWebLink(project, branch);
        }
    });
}
#end_block

#method_before
@Before
public void setup() {
    user = createNiceMock(IdentifiedUser.class);
    replay(user);
    backends = new DynamicSet<GroupBackend>();
    backends.add(new SystemGroupBackend());
    classUnderTest = new UniversalGroupBackend(backends);
}
#method_after
@Before
public void setup() {
    user = createNiceMock(IdentifiedUser.class);
    replay(user);
    backends = new DynamicSet<GroupBackend>();
    backends.add(new SystemGroupBackend());
    backend = new UniversalGroupBackend(backends);
}
#end_block

#method_before
@Test
public void testHandles() {
    assertTrue(classUnderTest.handles(ANONYMOUS_USERS));
    assertTrue(classUnderTest.handles(PROJECT_OWNERS));
    assertFalse(classUnderTest.handles(OTHER_UUID));
}
#method_after
@Test
public void testHandles() {
    assertTrue(backend.handles(ANONYMOUS_USERS));
    assertTrue(backend.handles(PROJECT_OWNERS));
    assertFalse(backend.handles(OTHER_UUID));
}
#end_block

#method_before
@Test
public void testGet() {
    assertEquals("Registered Users", classUnderTest.get(REGISTERED_USERS).getName());
    assertEquals("Project Owners", classUnderTest.get(PROJECT_OWNERS).getName());
    assertNull(classUnderTest.get(OTHER_UUID));
}
#method_after
@Test
public void testGet() {
    assertEquals("Registered Users", backend.get(REGISTERED_USERS).getName());
    assertEquals("Project Owners", backend.get(PROJECT_OWNERS).getName());
    assertNull(backend.get(OTHER_UUID));
}
#end_block

#method_before
@Test
public void testSuggest() {
    assertTrue(classUnderTest.suggest("X", null).isEmpty());
    assertEquals(1, classUnderTest.suggest("project", null).size());
    assertEquals(1, classUnderTest.suggest("reg", null).size());
}
#method_after
@Test
public void testSuggest() {
    assertTrue(backend.suggest("X", null).isEmpty());
    assertEquals(1, backend.suggest("project", null).size());
    assertEquals(1, backend.suggest("reg", null).size());
}
#end_block

#method_before
@Test
public void testSytemGroupMemberships() {
    GroupMembership checker = classUnderTest.membershipsOf(user);
    assertTrue(checker.contains(REGISTERED_USERS));
    assertFalse(checker.contains(OTHER_UUID));
    assertFalse(checker.contains(PROJECT_OWNERS));
}
#method_after
@Test
public void testSytemGroupMemberships() {
    GroupMembership checker = backend.membershipsOf(user);
    assertTrue(checker.contains(REGISTERED_USERS));
    assertFalse(checker.contains(OTHER_UUID));
    assertFalse(checker.contains(PROJECT_OWNERS));
}
#end_block

#method_before
@Test
public void testKnownGroups() {
    GroupMembership checker = classUnderTest.membershipsOf(user);
    Set<UUID> knownGroups = checker.getKnownGroups();
    assertEquals(2, knownGroups.size());
    assertTrue(knownGroups.contains(REGISTERED_USERS));
    assertTrue(knownGroups.contains(ANONYMOUS_USERS));
}
#method_after
@Test
public void testKnownGroups() {
    GroupMembership checker = backend.membershipsOf(user);
    Set<UUID> knownGroups = checker.getKnownGroups();
    assertEquals(2, knownGroups.size());
    assertTrue(knownGroups.contains(REGISTERED_USERS));
    assertTrue(knownGroups.contains(ANONYMOUS_USERS));
}
#end_block

#method_before
@Test
public void testOtherMemberships() {
    final AccountGroup.UUID handled = new AccountGroup.UUID("handled");
    final AccountGroup.UUID notHandled = new AccountGroup.UUID("not handled");
    final IdentifiedUser member = createNiceMock(IdentifiedUser.class);
    final IdentifiedUser notMember = createNiceMock(IdentifiedUser.class);
    GroupBackend backend = createMock(GroupBackend.class);
    expect(backend.handles(handled)).andStubReturn(true);
    expect(backend.handles(not(eq(handled)))).andStubReturn(false);
    expect(backend.membershipsOf(anyObject(IdentifiedUser.class))).andStubAnswer(new IAnswer<GroupMembership>() {

        @Override
        public GroupMembership answer() throws Throwable {
            Object[] args = getCurrentArguments();
            GroupMembership membership = createMock(GroupMembership.class);
            expect(membership.contains(eq(handled))).andStubReturn(args[0] == member);
            expect(membership.contains(not(eq(notHandled)))).andStubReturn(false);
            replay(membership);
            return membership;
        }
    });
    replay(member, notMember, backend);
    backends = new DynamicSet<GroupBackend>();
    backends.add(backend);
    classUnderTest = new UniversalGroupBackend(backends);
    GroupMembership checker = classUnderTest.membershipsOf(member);
    assertFalse(checker.contains(REGISTERED_USERS));
    assertFalse(checker.contains(OTHER_UUID));
    assertTrue(checker.contains(handled));
    assertFalse(checker.contains(notHandled));
    checker = classUnderTest.membershipsOf(notMember);
    assertFalse(checker.contains(handled));
    assertFalse(checker.contains(notHandled));
}
#method_after
@Test
public void testOtherMemberships() {
    final AccountGroup.UUID handled = new AccountGroup.UUID("handled");
    final AccountGroup.UUID notHandled = new AccountGroup.UUID("not handled");
    final IdentifiedUser member = createNiceMock(IdentifiedUser.class);
    final IdentifiedUser notMember = createNiceMock(IdentifiedUser.class);
    GroupBackend backend = createMock(GroupBackend.class);
    expect(backend.handles(handled)).andStubReturn(true);
    expect(backend.handles(not(eq(handled)))).andStubReturn(false);
    expect(backend.membershipsOf(anyObject(IdentifiedUser.class))).andStubAnswer(new IAnswer<GroupMembership>() {

        @Override
        public GroupMembership answer() throws Throwable {
            Object[] args = getCurrentArguments();
            GroupMembership membership = createMock(GroupMembership.class);
            expect(membership.contains(eq(handled))).andStubReturn(args[0] == member);
            expect(membership.contains(not(eq(notHandled)))).andStubReturn(false);
            replay(membership);
            return membership;
        }
    });
    replay(member, notMember, backend);
    backends = new DynamicSet<GroupBackend>();
    backends.add(backend);
    backend = new UniversalGroupBackend(backends);
    GroupMembership checker = backend.membershipsOf(member);
    assertFalse(checker.contains(REGISTERED_USERS));
    assertFalse(checker.contains(OTHER_UUID));
    assertTrue(checker.contains(handled));
    assertFalse(checker.contains(notHandled));
    checker = backend.membershipsOf(notMember);
    assertFalse(checker.contains(handled));
    assertFalse(checker.contains(notHandled));
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    HttpServletResponse res = (HttpServletResponse) response;
    String runas = req.getHeader(RUN_AS);
    if (runas != null) {
        if (!enabled) {
            RestApiServlet.replyError(req, res, SC_FORBIDDEN, RUN_AS + " disabled by auth.enableRunAs = false", null);
            return;
        }
        CurrentUser self = session.get().getCurrentUser();
        if (!self.getCapabilities().canRunAs()) {
            RestApiServlet.replyError(req, res, SC_FORBIDDEN, "not permitted to use " + RUN_AS, null);
            return;
        }
        Account target;
        try {
            target = accountResolver.find(runas);
        } catch (OrmException e) {
            log.warn("cannot resolve account for " + RUN_AS, e);
            RestApiServlet.replyError(req, res, SC_INTERNAL_SERVER_ERROR, "cannot resolve " + RUN_AS, e);
            return;
        }
        if (target == null) {
            RestApiServlet.replyError(req, res, SC_FORBIDDEN, "no account matches " + RUN_AS, null);
            return;
        }
        session.get().setUserAccountId(target.getId());
    }
    chain.doFilter(req, res);
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    HttpServletResponse res = (HttpServletResponse) response;
    String runas = req.getHeader(RUN_AS);
    if (runas != null) {
        if (!enabled) {
            replyError(req, res, SC_FORBIDDEN, RUN_AS + " disabled by auth.enableRunAs = false", null);
            return;
        }
        CurrentUser self = session.get().getCurrentUser();
        if (!self.getCapabilities().canRunAs()) {
            replyError(req, res, SC_FORBIDDEN, "not permitted to use " + RUN_AS, null);
            return;
        }
        Account target;
        try {
            target = accountResolver.find(runas);
        } catch (OrmException e) {
            log.warn("cannot resolve account for " + RUN_AS, e);
            replyError(req, res, SC_INTERNAL_SERVER_ERROR, "cannot resolve " + RUN_AS, e);
            return;
        }
        if (target == null) {
            replyError(req, res, SC_FORBIDDEN, "no account matches " + RUN_AS, null);
            return;
        }
        session.get().setUserAccountId(target.getId());
    }
    chain.doFilter(req, res);
}
#end_block

#method_before
public static void replyError(HttpServletRequest req, HttpServletResponse res, int statusCode, String msg, CacheControl c, @Nullable Throwable err) throws IOException {
    res.setStatus(statusCode);
    configureCaching(req, res, null, c);
    replyText(req, res, msg);
    if (err != null) {
        req.setAttribute(ATTRIBUTE_ERROR_TRACE, err);
    }
}
#method_after
public static void replyError(HttpServletRequest req, HttpServletResponse res, int statusCode, String msg, CacheControl c, @Nullable Throwable err) throws IOException {
    res.setStatus(statusCode);
    configureCaching(req, res, null, c);
    replyText(req, res, msg);
    if (err != null) {
        RequestUtil.setErrorTraceAttribute(req, err);
    }
}
#end_block

#method_before
protected String getBranchUrl(String projectName, String branchName) {
    ProjectState state = projectCache.get(new Project.NameKey(projectName));
    if (state == null) {
        // project not found -> no link
        return null;
    }
    return getPatchUrl(projectName, branchName, cfgFactory.create(state).getIndexFile());
}
#method_after
private String getBranchUrl(String projectName, String branchName) {
    ProjectState state = projectCache.get(new Project.NameKey(projectName));
    if (state == null) {
        // project not found -> no link
        return null;
    }
    return getFileUrl(projectName, branchName, cfgFactory.create(state).getIndexFile());
}
#end_block

#method_before
protected String getImageUrl() {
    return "plugins/" + pluginName + "/static/readme.png";
}
#method_after
private String getImageUrl() {
    return "plugins/" + pluginName + "/static/readme.png";
}
#end_block

#method_before
@Override
protected void configure() {
    install(new XDocLoader.Module());
    factory(XDocConfig.Factory.class);
    DynamicSet.bind(binder(), new TypeLiteral<WebLink<ProjectResource>>() {
    }).to(XDocProjectWebLink.class);
    DynamicSet.bind(binder(), new TypeLiteral<WebLink<BranchResource>>() {
    }).to(XDocBranchWebLink.class);
    DynamicSet.bind(binder(), new TypeLiteral<WebLink<FileResource>>() {
    }).to(XDocFileWebLink.class);
    DynamicSet.bind(binder(), TopMenu.class).toInstance(new TopMenu() {

        @Override
        public List<MenuEntry> getEntries() {
            StringBuilder url = new StringBuilder();
            url.append("/plugins/");
            url.append(pluginName);
            url.append(XDocServlet.PATH_PREFIX);
            url.append("${projectName}");
            return Lists.newArrayList(new MenuEntry(GerritTopMenu.PROJECTS, Lists.newArrayList(new MenuItem("Readme", url.toString()))));
        }
    });
}
#method_after
@Override
protected void configure() {
    install(new XDocLoader.Module());
    factory(XDocProjectConfig.Factory.class);
    DynamicMap.mapOf(binder(), Formatter.class);
    bind(Formatter.class).annotatedWith(Exports.named(AsciidoctorFormatter.NAME)).to(AsciidoctorFormatter.class);
    bind(Formatter.class).annotatedWith(Exports.named(MarkdownFormatter.NAME)).to(MarkdownFormatter.class);
    bind(Formatter.class).annotatedWith(Exports.named(PlainTextFormatter.NAME)).to(PlainTextFormatter.class);
    DynamicSet.bind(binder(), ProjectWebLink.class).to(XDocWebLink.class);
    DynamicSet.bind(binder(), BranchWebLink.class).to(XDocWebLink.class);
    DynamicSet.bind(binder(), FileWebLink.class).to(XDocWebLink.class);
    DynamicSet.bind(binder(), TopMenu.class).toInstance(new TopMenu() {

        @Override
        public List<MenuEntry> getEntries() {
            StringBuilder url = new StringBuilder();
            url.append("/plugins/");
            url.append(pluginName);
            url.append(XDocServlet.PATH_PREFIX);
            url.append("${projectName}");
            return Lists.newArrayList(new MenuEntry(GerritTopMenu.PROJECTS, Lists.newArrayList(new MenuItem("Readme", url.toString()))));
        }
    });
}
#end_block

#method_before
@Override
protected void configureServlets() {
    filter("/*").through(HideFromNonAdmins.class);
    serve("/etc/*").with(ServerConfigServlet.class);
    serve("/static/*").with(ServerConfigServlet.class);
}
#method_after
@Override
protected void configureServlets() {
    filter("/*").through(HideFromNonAdmins.class);
    serve("/etc/*", "/static/*").with(ServerConfigServlet.class);
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd, boolean fastEvalLabels, boolean allowClosed, boolean allowDraft) {
    if (!allowClosed && getChange().getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSet.getId().equals(getChange().currentPatchSetId())) {
        return ruleError("Patch set " + patchSet.getPatchSetId() + " is not current");
    }
    cd = changeData(db, cd);
    if ((getChange().getStatus() == Change.Status.DRAFT || patchSet.isDraft()) && !allowDraft) {
        return cannotSubmitDraft(db, patchSet, cd);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(cd, patchSet);
        results = evaluator.setFastEvalLabels(fastEvalLabels).evaluate();
    } catch (OrmException | RuleEvalException e) {
        return logRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    return resultsToSubmitRecord(evaluator.getSubmitRule(), results);
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd, boolean fastEvalLabels, boolean allowClosed, boolean allowDraft) {
    if (!allowClosed && getChange().getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSet.getId().equals(getChange().currentPatchSetId())) {
        return ruleError("Patch set " + patchSet.getPatchSetId() + " is not current");
    }
    cd = changeData(db, cd);
    if ((getChange().getStatus() == Change.Status.DRAFT || patchSet.isDraft()) && !allowDraft) {
        return cannotSubmitDraft(db, patchSet, cd);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(cd);
        results = evaluator.setPatchSet(patchSet).setFastEvalLabels(fastEvalLabels).evaluate();
    } catch (OrmException | RuleEvalException e) {
        return logRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    return resultsToSubmitRecord(evaluator.getSubmitRule(), results);
}
#end_block

#method_before
public SubmitTypeRecord getSubmitTypeRecord(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd) {
    cd = changeData(db, cd);
    try {
        if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
        if (patchSet.isDraft() && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
    } catch (OrmException err) {
        return logTypeRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(cd, patchSet);
        results = evaluator.evaluateSubmitType();
    } catch (OrmException | RuleEvalException e) {
        return logTypeRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " has no solution.");
        return typeRuleError("Project submit rule has no solution");
    }
    Term typeTerm = results.get(0);
    if (!typeTerm.isSymbol()) {
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " did not return a symbol.");
        return typeRuleError("Project submit rule has invalid solution");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return logInvalidType(evaluator.getSubmitRule(), typeName);
    }
}
#method_after
public SubmitTypeRecord getSubmitTypeRecord(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd) {
    cd = changeData(db, cd);
    try {
        if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
        if (patchSet.isDraft() && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
    } catch (OrmException err) {
        return logTypeRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(cd);
        results = evaluator.evaluateSubmitType();
    } catch (OrmException | RuleEvalException e) {
        return logTypeRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " has no solution.");
        return typeRuleError("Project submit rule has no solution");
    }
    Term typeTerm = results.get(0);
    if (!typeTerm.isSymbol()) {
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " did not return a symbol.");
        return typeRuleError("Project submit rule has invalid solution");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return logInvalidType(evaluator.getSubmitRule(), typeName);
    }
}
#end_block

#method_before
private List<Term> evaluateImpl(String userRuleLocatorName, String userRuleWrapperName, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    PrologEnvironment env = getPrologEnvironment();
    try {
        submitRule = env.once("gerrit", userRuleLocatorName, new VariableTerm());
        if (fastEvalLabels) {
            env.once("gerrit", "assume_range_from_label");
        }
        List<Term> results = new ArrayList<>();
        try {
            for (Term[] template : env.all("gerrit", userRuleWrapperName, submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            throw new RuleEvalException("Exception calling " + submitRule + " on change " + cd.getId() + " of " + getProjectName(), err);
        } catch (RuntimeException err) {
            throw new RuleEvalException("Exception calling " + submitRule + " on change " + cd.getId() + " of " + getProjectName(), err);
        }
        Term resultsTerm = toListTerm(results);
        if (!skipFilters) {
            resultsTerm = runSubmitFilters(resultsTerm, env, filterRuleLocatorName, filterRuleWrapperName);
        }
        if (resultsTerm.isList()) {
            List<Term> r = Lists.newArrayList();
            for (Term t = resultsTerm; t.isList(); ) {
                ListTerm l = (ListTerm) t;
                r.add(l.car().dereference());
                t = l.cdr().dereference();
            }
            return r;
        }
        return Collections.emptyList();
    } finally {
        env.close();
    }
}
#method_after
private List<Term> evaluateImpl(String userRuleLocatorName, String userRuleWrapperName, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    PrologEnvironment env = getPrologEnvironment();
    try {
        submitRule = env.once("gerrit", userRuleLocatorName, new VariableTerm());
        if (fastEvalLabels) {
            env.once("gerrit", "assume_range_from_label");
        }
        List<Term> results = new ArrayList<>();
        try {
            for (Term[] template : env.all("gerrit", userRuleWrapperName, submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (RuntimeException err) {
            throw new RuleEvalException("Exception calling " + submitRule + " on change " + cd.getId() + " of " + getProjectName(), err);
        }
        Term resultsTerm = toListTerm(results);
        if (!skipFilters) {
            resultsTerm = runSubmitFilters(resultsTerm, env, filterRuleLocatorName, filterRuleWrapperName);
        }
        if (resultsTerm.isList()) {
            List<Term> r = Lists.newArrayList();
            for (Term t = resultsTerm; t.isList(); ) {
                ListTerm l = (ListTerm) t;
                r.add(l.car().dereference());
                t = l.cdr().dereference();
            }
            return r;
        }
        return Collections.emptyList();
    } finally {
        env.close();
    }
}
#end_block

#method_before
private PrologEnvironment getPrologEnvironment() throws RuleEvalException {
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (rule == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new ByteArrayInputStream(rule.getBytes(UTF_8)));
        }
    } catch (CompileException err) {
        throw new RuleEvalException("Cannot consult rules.pl for " + getProjectName(), err);
    }
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.PATCH_SET, patchSet);
    env.set(StoredValues.CHANGE_CONTROL, control);
    return env;
}
#method_after
private PrologEnvironment getPrologEnvironment() throws RuleEvalException {
    if (patchSet == null) {
        try {
            patchSet = cd.currentPatchSet();
        } catch (OrmException err) {
            throw new RuleEvalException("Missing current patch set on change " + cd.getId() + " of " + getProjectName(), err);
        }
    }
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (rule == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new ByteArrayInputStream(rule.getBytes(UTF_8)));
        }
    } catch (CompileException err) {
        throw new RuleEvalException("Cannot consult rules.pl for " + getProjectName(), err);
    }
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.PATCH_SET, patchSet);
    env.set(StoredValues.CHANGE_CONTROL, control);
    return env;
}
#end_block

#method_before
@Override
public SubmitType apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(changeDataFactory.create(db.get(), rsrc.getChange()), rsrc.getPatchSet());
    List<Term> results;
    try {
        results = evaluator.setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluateSubmitType();
    } catch (RuleEvalException e) {
        throw new BadRequestException(String.format("rule failed with exception: %s", e.getMessage()));
    }
    if (results.isEmpty()) {
        throw new BadRequestException(String.format("rule %s has no solution", evaluator.getSubmitRule()));
    }
    Term type = results.get(0);
    if (!type.isSymbol()) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
    String typeName = ((SymbolTerm) type).name();
    try {
        return SubmitType.valueOf(typeName.toUpperCase());
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
}
#method_after
@Override
public SubmitType apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(changeDataFactory.create(db.get(), rsrc.getControl()));
    List<Term> results;
    try {
        results = evaluator.setPatchSet(rsrc.getPatchSet()).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluateSubmitType();
    } catch (RuleEvalException e) {
        throw new BadRequestException(String.format("rule failed with exception: %s", e.getMessage()));
    }
    if (results.isEmpty()) {
        throw new BadRequestException(String.format("rule %s has no solution", evaluator.getSubmitRule()));
    }
    Term type = results.get(0);
    if (!type.isSymbol()) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
    String typeName = ((SymbolTerm) type).name();
    try {
        return SubmitType.valueOf(typeName.toUpperCase());
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
}
#end_block

#method_before
@Override
public List<Record> apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(changeDataFactory.create(db.get(), rsrc.getChange()), rsrc.getPatchSet());
    List<Term> results;
    try {
        results = evaluator.setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluate();
    } catch (RuleEvalException e) {
        String msg = Joiner.on(": ").skipNulls().join(Iterables.transform(Throwables.getCausalChain(e), new Function<Throwable, String>() {

            @Override
            public String apply(Throwable in) {
                return in.getMessage();
            }
        }));
        throw new BadRequestException("rule failed: " + msg);
    }
    if (results.isEmpty()) {
        throw new BadRequestException(String.format("rule %s has no solutions", evaluator.getSubmitRule().toString()));
    }
    List<SubmitRecord> records = rsrc.getControl().resultsToSubmitRecord(evaluator.getSubmitRule(), results);
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountInfo.Loader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    accounts.fill();
    return out;
}
#method_after
@Override
public List<Record> apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(changeDataFactory.create(db.get(), rsrc.getControl()));
    List<Term> results;
    try {
        results = evaluator.setPatchSet(rsrc.getPatchSet()).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluate();
    } catch (RuleEvalException e) {
        String msg = Joiner.on(": ").skipNulls().join(Iterables.transform(Throwables.getCausalChain(e), new Function<Throwable, String>() {

            @Override
            public String apply(Throwable in) {
                return in.getMessage();
            }
        }));
        throw new BadRequestException("rule failed: " + msg);
    }
    if (results.isEmpty()) {
        throw new BadRequestException(String.format("rule %s has no solutions", evaluator.getSubmitRule().toString()));
    }
    List<SubmitRecord> records = rsrc.getControl().resultsToSubmitRecord(evaluator.getSubmitRule(), results);
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountInfo.Loader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    accounts.fill();
    return out;
}
#end_block

#method_before
@Override
public Response<Result> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException, AuthException, InvalidChangeOperationException, IOException {
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
    }
    AccountDiffPreference prefs = new AccountDiffPreference(new Account.Id(0));
    prefs.setIgnoreWhitespace(ignoreWhitespace.whitespace);
    prefs.setContext(context);
    prefs.setIntralineDifference(intraline);
    try {
        PatchScriptFactory psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet != null ? basePatchSet.getId() : null, resource.getPatchKey().getParentKey(), prefs);
        psf.setLoadHistory(false);
        psf.setLoadComments(context != AccountDiffPreference.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %d; want %d", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %d; want %d", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        Result result = new Result();
        if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
            result.metaA = new FileMeta();
            result.metaA.name = MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName());
            setContentType(result.metaA, state, ps.getFileModeA(), ps.getMimeTypeA());
            result.metaA.lines = ps.getA().size();
            result.webLinksA = Lists.newArrayList();
            String rev = basePatchSet != null ? basePatchSet.getRefName() : resource.getRevision().getPatchSet().getRefName() + "^1";
            for (WebLinkInfo link : webLinks.get().getPatchLinks(state.getProject().getName(), rev, result.metaA.name)) {
                if (!Strings.isNullOrEmpty(link.name) && !Strings.isNullOrEmpty(link.url)) {
                    result.webLinksA.add(link);
                }
            }
        }
        if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
            result.metaB = new FileMeta();
            result.metaB.name = ps.getNewName();
            setContentType(result.metaB, state, ps.getFileModeB(), ps.getMimeTypeB());
            result.metaB.lines = ps.getB().size();
            result.webLinksB = Lists.newArrayList();
            for (WebLinkInfo link : webLinks.get().getPatchLinks(state.getProject().getName(), resource.getRevision().getPatchSet().getRefName(), result.metaB.name)) {
                if (!Strings.isNullOrEmpty(link.name) && !Strings.isNullOrEmpty(link.url)) {
                    result.webLinksB.add(link);
                }
            }
        }
        if (intraline) {
            if (ps.hasIntralineTimeout()) {
                result.intralineStatus = IntraLineStatus.TIMEOUT;
            } else if (ps.hasIntralineFailure()) {
                result.intralineStatus = IntraLineStatus.FAILURE;
            } else {
                result.intralineStatus = IntraLineStatus.OK;
            }
        }
        result.changeType = ps.getChangeType();
        if (ps.getPatchHeader().size() > 0) {
            result.diffHeader = ps.getPatchHeader();
        }
        result.content = content.lines;
        Response<Result> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
@Override
public Response<Result> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException, AuthException, InvalidChangeOperationException, IOException {
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
    }
    AccountDiffPreference prefs = new AccountDiffPreference(new Account.Id(0));
    prefs.setIgnoreWhitespace(ignoreWhitespace.whitespace);
    prefs.setContext(context);
    prefs.setIntralineDifference(intraline);
    try {
        PatchScriptFactory psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet != null ? basePatchSet.getId() : null, resource.getPatchKey().getParentKey(), prefs);
        psf.setLoadHistory(false);
        psf.setLoadComments(context != AccountDiffPreference.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %d; want %d", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %d; want %d", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        Result result = new Result();
        if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
            result.metaA = new FileMeta();
            result.metaA.name = MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName());
            setContentType(result.metaA, state, ps.getFileModeA(), ps.getMimeTypeA());
            result.metaA.lines = ps.getA().size();
            // TODO referring to the parent commit by refs/changes/12/60012/1^1
            // will likely not work for inline edits
            String rev = basePatchSet != null ? basePatchSet.getRefName() : resource.getRevision().getPatchSet().getRefName() + "^1";
            result.webLinksA = getFileWebLinks(state.getProject(), rev, result.metaA.name);
        }
        if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
            result.metaB = new FileMeta();
            result.metaB.name = ps.getNewName();
            setContentType(result.metaB, state, ps.getFileModeB(), ps.getMimeTypeB());
            result.metaB.lines = ps.getB().size();
            result.webLinksB = getFileWebLinks(state.getProject(), resource.getRevision().getPatchSet().getRefName(), result.metaB.name);
        }
        if (intraline) {
            if (ps.hasIntralineTimeout()) {
                result.intralineStatus = IntraLineStatus.TIMEOUT;
            } else if (ps.hasIntralineFailure()) {
                result.intralineStatus = IntraLineStatus.FAILURE;
            } else {
                result.intralineStatus = IntraLineStatus.OK;
            }
        }
        result.changeType = ps.getChangeType();
        if (ps.getPatchHeader().size() > 0) {
            result.diffHeader = ps.getPatchHeader();
        }
        result.content = content.lines;
        Response<Result> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public WebLinks get() {
    return new WebLinks(patchSetLinks, patchLinks, projectLinks, branchLinks);
}
#method_after
@Override
public WebLinks get() {
    return new WebLinks(patchSetLinks, fileLinks, projectLinks, branchLinks);
}
#end_block

#method_before
public Iterable<WebLinkInfo> getPatchLinks(String project, String revision, String file) {
    List<WebLinkInfo> links = Lists.newArrayList();
    for (PatchWebLink webLink : patchLinks) {
        links.add(new WebLinkInfo(webLink.getLinkName(), webLink.getImageUrl(), webLink.getPatchUrl(project, revision, file)));
    }
    return links;
}
#method_after
public Iterable<WebLinkInfo> getPatchLinks(String project, String revision, String file) {
    List<WebLinkInfo> links = Lists.newArrayList();
    for (FileWebLink webLink : fileLinks) {
        links.add(new WebLinkInfo(webLink.getLinkName(), webLink.getImageUrl(), webLink.getFileUrl(project, revision, file)));
    }
    return links;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), PatchWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    ObjectReader reader = repo.newObjectReader();
    try {
        ObjectLoader loader = reader.open(view.getRevision().getId());
        if (loader.getType() != OBJ_COMMIT) {
            res.setStatus(SC_NOT_FOUND);
        } else {
            res.setHeader(PathServlet.MODE_HEADER, "160000");
            try (Writer writer = startRenderText(req, res);
                OutputStream out = BaseEncoding.base64().encodingStream(writer)) {
                loader.copyTo(out);
            }
        }
    } finally {
        reader.release();
    }
}
#method_after
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    ObjectReader reader = repo.newObjectReader();
    try {
        ObjectLoader loader = reader.open(view.getRevision().getId());
        if (loader.getType() != OBJ_COMMIT) {
            res.setStatus(SC_NOT_FOUND);
        } else {
            PathServlet.setTypeHeader(res, loader.getType());
            try (Writer writer = startRenderText(req, res);
                OutputStream out = BaseEncoding.base64().encodingStream(writer)) {
                loader.copyTo(out);
            }
        }
    } finally {
        reader.release();
    }
}
#end_block

#method_before
@Test
public void byHashtagWithNotedb() throws Exception {
    assumeTrue("notedb disabled", notesMigration.enabled());
    List<Change> changes = setUpHashtagChanges();
    List<ChangeInfo> results = query("hashtag:foo");
    assertEquals(2, results.size());
    assertResultEquals(changes.get(1), results.get(0));
    assertResultEquals(changes.get(0), results.get(1));
    assertResultEquals(changes.get(1), queryOne("hashtag:bar"));
    assertResultEquals(changes.get(1), queryOne("hashtag:\"a tag\""));
    assertResultEquals(changes.get(1), queryOne("hashtag:\"a tag \""));
    assertResultEquals(changes.get(1), queryOne("hashtag:\" a tag \""));
    assertResultEquals(changes.get(1), queryOne("hashtag:\"#a tag\""));
    assertResultEquals(changes.get(1), queryOne("hashtag:\"# #a tag\""));
}
#method_after
@Test
public void byHashtagWithNotedb() throws Exception {
    assumeTrue(notesMigration.enabled());
    List<Change> changes = setUpHashtagChanges();
    List<ChangeInfo> results = query("hashtag:foo");
    assertEquals(2, results.size());
    assertResultEquals(changes.get(1), results.get(0));
    assertResultEquals(changes.get(0), results.get(1));
    assertResultEquals(changes.get(1), queryOne("hashtag:bar"));
    assertResultEquals(changes.get(1), queryOne("hashtag:\"a tag\""));
    assertResultEquals(changes.get(1), queryOne("hashtag:\"a tag \""));
    assertResultEquals(changes.get(1), queryOne("hashtag:\" a tag \""));
    assertResultEquals(changes.get(1), queryOne("hashtag:\"#a tag\""));
    assertResultEquals(changes.get(1), queryOne("hashtag:\"# #a tag\""));
}
#end_block

#method_before
@Test
public void byHashtagWithoutNotedb() throws Exception {
    assumeFalse("notedb enabled", notesMigration.enabled());
    setUpHashtagChanges();
    assertTrue(query("hashtag:foo").isEmpty());
    assertTrue(query("hashtag:bar").isEmpty());
    assertTrue(query("hashtag:\" bar \"").isEmpty());
    assertTrue(query("hashtag:\"a tag\"").isEmpty());
    assertTrue(query("hashtag:\" a tag \"").isEmpty());
    assertTrue(query("hashtag:#foo").isEmpty());
    assertTrue(query("hashtag:\"# #foo\"").isEmpty());
}
#method_after
@Test
public void byHashtagWithoutNotedb() throws Exception {
    assumeTrue(!notesMigration.enabled());
    setUpHashtagChanges();
    assertTrue(query("hashtag:foo").isEmpty());
    assertTrue(query("hashtag:bar").isEmpty());
    assertTrue(query("hashtag:\" bar \"").isEmpty());
    assertTrue(query("hashtag:\"a tag\"").isEmpty());
    assertTrue(query("hashtag:\" a tag \"").isEmpty());
    assertTrue(query("hashtag:#foo").isEmpty());
    assertTrue(query("hashtag:\"# #foo\"").isEmpty());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
public List<ValidationMessage> validateForRefOperation() throws RefOperationValidationException {
    List<ValidationMessage> messages = Lists.newLinkedList();
    boolean withException = false;
    try {
        for (RefOperationValidationListener listener : refOperationValidationListeners) {
            messages.addAll(listener.onRefOperation(event));
        }
    } catch (ValidationException e) {
        messages.add(new ValidationMessage(e.getMessage(), true));
        withException = true;
    } finally {
        if (withException) {
            throwException(messages, event);
        }
    }
    return messages;
}
#method_after
public List<ValidationMessage> validateForRefOperation() throws RefOperationValidationException {
    List<ValidationMessage> messages = Lists.newArrayList();
    boolean withException = false;
    try {
        for (RefOperationValidationListener listener : refOperationValidationListeners) {
            messages.addAll(listener.onRefOperation(event));
        }
    } catch (ValidationException e) {
        messages.add(new ValidationMessage(e.getMessage(), true));
        withException = true;
    }
    if (withException) {
        throwException(messages, event);
    }
    return messages;
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.setCmdLineParser(clp);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(destBranch).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.setCmdLineParser(clp);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(destBranch).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setApprovals(approvals).setMessage(msg).setSendMail(false).setHashtags(magicBranch.getHashtags()).insert();
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, ins.getPatchSetInfo());
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
        ins.setHashtags(magicBranch.getHashtags());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setApprovals(approvals).setMessage(msg).setSendMail(false).insert();
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, ins.getPatchSetInfo());
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, change, changeCtl, approvals);
        recipients.add(oldRecipients);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
        Set<String> hashtags = magicBranch.getHashtags();
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, change, changeCtl, approvals);
        recipients.add(oldRecipients);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    RevWalk walk = new RevWalk(repo);
    try {
        RevObject obj = walk.parseAny(view.getRevision().getId());
        switch(obj.getType()) {
            case OBJ_COMMIT:
                try (Writer writer = startRenderText(req, res);
                    OutputStream out = BaseEncoding.base64().encodingStream(writer)) {
                    out.write(((RevCommit) obj).getRawBuffer());
                }
                break;
            default:
                // TODO(dborowitz): Support showing other types.
                res.setStatus(SC_NOT_FOUND);
                break;
        }
    } finally {
        walk.release();
    }
}
#method_after
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    ObjectReader reader = repo.newObjectReader();
    try {
        ObjectLoader loader = reader.open(view.getRevision().getId());
        if (loader.getType() != OBJ_COMMIT) {
            res.setStatus(SC_NOT_FOUND);
        } else {
            try (Writer writer = startRenderText(req, res);
                OutputStream out = BaseEncoding.base64().encodingStream(writer)) {
                loader.copyTo(out);
            }
        }
    } finally {
        reader.release();
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    if (regex == null) {
        regex = "^*.*$";
    }
    switch(level.toLowerCase()) {
        case RESET:
            reset();
            break;
        case LEVEL_ALL:
            setLoggingLevel(Level.ALL);
            break;
        case LEVEL_TRACE:
            setLoggingLevel(Level.TRACE);
            break;
        case LEVEL_DEBUG:
            setLoggingLevel(Level.DEBUG);
            break;
        case LEVEL_INFO:
            setLoggingLevel(Level.INFO);
            break;
        case LEVEL_WARN:
            setLoggingLevel(Level.WARN);
            break;
        case LEVEL_ERROR:
            setLoggingLevel(Level.ERROR);
            break;
        case LEVEL_FATAL:
            setLoggingLevel(Level.FATAL);
            break;
        case LEVEL_OFF:
            setLoggingLevel(Level.OFF);
            break;
        default:
            stdout.println("Invalid argument");
            stdout.flush();
            break;
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected void run() throws MalformedURLException {
    if (level == LevelOption.RESET) {
        reset();
    } else {
        for (Enumeration<Logger> logger = LogManager.getCurrentLoggers(); logger.hasMoreElements(); ) {
            Logger log = logger.nextElement();
            if (name == null || log.getName().contains(name)) {
                log.setLevel(Level.toLevel(level.name()));
            }
        }
    }
}
#end_block

#method_before
private void reset() {
    LogManager.resetConfiguration();
    PropertyConfigurator.configure(getClass().getClassLoader().getResource("log4j.properties"));
}
#method_after
@SuppressWarnings("unchecked")
private static void reset() throws MalformedURLException {
    for (Enumeration<Logger> logger = LogManager.getCurrentLoggers(); logger.hasMoreElements(); ) {
        logger.nextElement().setLevel(null);
    }
    String path = System.getProperty(JAVA_OPTIONS_LOG_CONFIG);
    if (Strings.isNullOrEmpty(path)) {
        PropertyConfigurator.configure(Loader.getResource(LOG_CONFIGURATION));
    } else {
        PropertyConfigurator.configure(new URL(path));
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    if (regex == null) {
        regex = "^*.*$";
    }
    printAll();
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected void run() {
    Map<String, String> logs = new TreeMap<>();
    for (Enumeration<Logger> logger = LogManager.getCurrentLoggers(); logger.hasMoreElements(); ) {
        Logger log = logger.nextElement();
        if (name == null || log.getName().contains(name)) {
            logs.put(log.getName(), log.getEffectiveLevel().toString());
        }
    }
    for (Map.Entry<String, String> e : logs.entrySet()) {
        stdout.println(e.getKey() + ": " + e.getValue());
    }
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, AproposCommand.class);
    command(gerrit, BanCommitCommand.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("suexec").to(SuExec.class);
    listener().to(ShowCaches.StartupListener.class);
    // The following commands can only be ran on a server in Master mode
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, AdminQueryShell.class);
    if (!slaveMode) {
        command("git-receive-pack").to(Commands.key(git, "receive-pack"));
        command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
        command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
        command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    }
    command(gerrit, Receive.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, ReviewCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, SetMembersCommand.class);
    command(gerrit, CreateBranchCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, CreateAccountCommand.class);
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
    command(gerrit, SetLoggingLevelCommand.class);
    command(gerrit, ListLoggingLevelCommand.class);
}
#method_after
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName logging = Commands.named(gerrit, "logging");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, AproposCommand.class);
    command(gerrit, BanCommitCommand.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("suexec").to(SuExec.class);
    listener().to(ShowCaches.StartupListener.class);
    // The following commands can only be ran on a server in Master mode
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, AdminQueryShell.class);
    if (!slaveMode) {
        command("git-receive-pack").to(Commands.key(git, "receive-pack"));
        command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
        command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
        command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    }
    command(gerrit, Receive.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, ReviewCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, SetMembersCommand.class);
    command(gerrit, CreateBranchCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, CreateAccountCommand.class);
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
    command(logging).toProvider(new DispatchCommandProvider(logging));
    command(logging, SetLoggingLevelCommand.class);
    command(logging, ListLoggingLevelCommand.class);
    alias(logging, "ls", ListLoggingLevelCommand.class);
    alias(logging, "set", SetLoggingLevelCommand.class);
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException {
    CurrentUser user = userProvider.get();
    if (user != null && user.isIdentifiedUser()) {
        IdentifiedUser who = (IdentifiedUser) user;
        if (who.getUserName() != null && !who.getUserName().isEmpty()) {
            req.setAttribute(REQ_ATTR_KEY, who.getUserName());
        } else {
            req.setAttribute(REQ_ATTR_KEY, who.getAccountId());
        }
    }
    chain.doFilter(req, resp);
}
#method_after
@Override
public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException {
    CurrentUser user = userProvider.get();
    if (user != null && user.isIdentifiedUser()) {
        IdentifiedUser who = (IdentifiedUser) user;
        if (who.getUserName() != null && !who.getUserName().isEmpty()) {
            req.setAttribute(REQ_ATTR_KEY, who.getUserName());
        } else {
            req.setAttribute(REQ_ATTR_KEY, "a/" + who.getAccountId());
        }
    }
    chain.doFilter(req, resp);
}
#end_block

#method_before
private Injector createDbInjector() {
    final List<Module> modules = new ArrayList<Module>();
    if (sitePath != null) {
        Module sitePathModule = new AbstractModule() {

            @Override
            protected void configure() {
                bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            }
        };
        modules.add(sitePathModule);
        Module configModule = new GerritServerConfigModule();
        modules.add(configModule);
        Injector cfgInjector = Guice.createInjector(sitePathModule, configModule);
        Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String dbType = cfg.getString("database", null, "type");
        final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(DataSourceType.class).toInstance(dst);
                bind(DataSourceProvider.Context.class).toInstance(DataSourceProvider.Context.MULTI_USER);
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(DataSourceProvider.class).in(SINGLETON);
                listener().to(DataSourceProvider.class);
            }
        });
    } else {
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
                listener().to(ReviewDbDataSourceProvider.class);
            }
        });
    }
    modules.add(new DatabaseModule());
    return Guice.createInjector(PRODUCTION, modules);
}
#method_after
private Injector createDbInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sitePath != null) {
        Module sitePathModule = new AbstractModule() {

            @Override
            protected void configure() {
                bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            }
        };
        modules.add(sitePathModule);
        Module configModule = new GerritServerConfigModule();
        modules.add(configModule);
        Injector cfgInjector = Guice.createInjector(sitePathModule, configModule);
        Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String dbType = cfg.getString("database", null, "type");
        final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(DataSourceType.class).toInstance(dst);
                bind(DataSourceProvider.Context.class).toInstance(DataSourceProvider.Context.MULTI_USER);
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(DataSourceProvider.class).in(SINGLETON);
                listener().to(DataSourceProvider.class);
            }
        });
    } else {
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
                listener().to(ReviewDbDataSourceProvider.class);
            }
        });
    }
    modules.add(new DatabaseModule());
    return Guice.createInjector(PRODUCTION, modules);
}
#end_block

#method_before
private Injector createCfgInjector() {
    final List<Module> modules = new ArrayList<Module>();
    if (sitePath == null) {
        // If we didn't get the site path from the system property
        // we need to get it from the database, as that's our old
        // method of locating the site path on disk.
        // 
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(File.class).annotatedWith(SitePath.class).toProvider(SitePathFromSystemConfigProvider.class).in(SINGLETON);
            }
        });
        modules.add(new GerritServerConfigModule());
    }
    modules.add(new SchemaModule());
    modules.add(new LocalDiskRepositoryManager.Module());
    modules.add(SchemaVersionCheck.module());
    modules.add(new AuthConfigModule());
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createCfgInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sitePath == null) {
        // If we didn't get the site path from the system property
        // we need to get it from the database, as that's our old
        // method of locating the site path on disk.
        // 
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(File.class).annotatedWith(SitePath.class).toProvider(SitePathFromSystemConfigProvider.class).in(SINGLETON);
            }
        });
        modules.add(new GerritServerConfigModule());
    }
    modules.add(new SchemaModule());
    modules.add(new LocalDiskRepositoryManager.Module());
    modules.add(SchemaVersionCheck.module());
    modules.add(new AuthConfigModule());
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(false));
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(sysInjector.getInstance(SshModule.class));
    modules.add(new SshHostKeyModule());
    modules.add(new DefaultCommandModule(false));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    modules.add(new SshHostKeyModule());
    modules.add(new DefaultCommandModule(false));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    if (sshInjector != null) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    if (sshInjector != null) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    modules.add(H2CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
@VisibleForTesting
public void start() {
    if (dbInjector == null) {
        dbInjector = createDbInjector(MULTI_USER);
    }
    cfgInjector = createCfgInjector();
    sysInjector = createSysInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setCfgInjector(cfgInjector);
    manager.add(dbInjector, cfgInjector, sysInjector);
    sshd &= !sshdOff();
    if (sshd) {
        initSshd();
    }
    if (Objects.firstNonNull(httpd, true)) {
        initHttpd();
    }
    manager.start();
}
#method_after
@VisibleForTesting
public void start() {
    if (dbInjector == null) {
        dbInjector = createDbInjector(MULTI_USER);
    }
    cfgInjector = createCfgInjector();
    sysInjector = createSysInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setCfgInjector(cfgInjector);
    manager.add(dbInjector, cfgInjector, sysInjector);
    sshd &= !sshdOff();
    if (sshd) {
        initSshd();
    }
    if (MoreObjects.firstNonNull(httpd, true)) {
        initHttpd();
    }
    manager.start();
}
#end_block

#method_before
private Injector createCfgInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new AuthConfigModule());
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createCfgInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new AuthConfigModule());
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(createIndexModule());
    if (Objects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(createIndexModule());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(headless));
            if (test) {
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private AbstractModule createIndexModule() {
    IndexType indexType = IndexModule.getIndexType(cfgInjector);
    switch(indexType) {
        case LUCENE:
            return luceneModule != null ? luceneModule : new LuceneIndexModule();
        case SOLR:
            return new SolrIndexModule();
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
}
#method_after
private AbstractModule createIndexModule() {
    if (slave) {
        return new DummyIndexModule();
    }
    IndexType indexType = IndexModule.getIndexType(cfgInjector);
    switch(indexType) {
        case LUCENE:
            return luceneModule != null ? luceneModule : new LuceneIndexModule();
        case SOLR:
            return new SolrIndexModule();
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
}
#end_block

#method_before
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(sysInjector.getInstance(SshModule.class));
    if (!test) {
        modules.add(new SshHostKeyModule());
    }
    modules.add(new DefaultCommandModule(slave));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    if (!test) {
        modules.add(new SshHostKeyModule());
    }
    modules.add(new DefaultCommandModule(slave));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(H2CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createHttpdInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new JettyModule(new JettyEnv(webInjector)));
    return webInjector.createChildInjector(modules);
}
#method_after
private Injector createHttpdInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new JettyModule(new JettyEnv(webInjector)));
    return webInjector.createChildInjector(modules);
}
#end_block

#method_before
void setUpPatchSetNav(JsArray<RevisionInfo> list, DiffInfo.FileMeta meta, List<WebLinkInfo> webLinks, boolean editExists, int currentPatchSet) {
    InlineHyperlink baseLink = null;
    InlineHyperlink selectedLink = null;
    if (sideA) {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
        linkPanel.add(baseLink);
    }
    for (int i = 0; i < list.length(); i++) {
        RevisionInfo r = list.get(i);
        InlineHyperlink link = createLink(r.id(), new PatchSet.Id(changeId, r._number()));
        linkPanel.add(link);
        if (revision != null && r.id().equals(revision.getId())) {
            selectedLink = link;
        }
    }
    if (selectedLink != null) {
        selectedLink.setStyleName(style.selected());
    } else if (sideA) {
        baseLink.setStyleName(style.selected());
    }
    if (meta != null && !Patch.COMMIT_MSG.equals(path)) {
        linkPanel.add(createDownloadLink());
    }
    if (!sideA && Gerrit.isSignedIn() && meta != null && !Patch.COMMIT_MSG.equals(path)) {
        PatchSet.Id id = (idActive == null) ? other.idActive : idActive;
        if ((editExists && id.get() == 0) || !editExists && id.get() == currentPatchSet) {
            linkPanel.add(createEditIcon());
        }
    }
    if (webLinks != null) {
        for (WebLinkInfo weblink : webLinks) {
            Anchor a = new Anchor();
            a.setHref(weblink.url());
            if (weblink.target() != null && !weblink.target().isEmpty()) {
                a.setTarget(weblink.target());
            }
            if (weblink.imageUrl() != null && !weblink.imageUrl().isEmpty()) {
                Image img = new Image();
                img.setAltText(weblink.name());
                img.setUrl(weblink.imageUrl());
                img.setTitle(weblink.name());
                a.getElement().appendChild(img.getElement());
            } else {
                a.setText("(" + weblink.name() + ")");
            }
            linkPanel.add(a);
        }
    }
}
#method_after
void setUpPatchSetNav(JsArray<RevisionInfo> list, DiffInfo.FileMeta meta, List<WebLinkInfo> webLinks, boolean editExists, int currentPatchSet) {
    InlineHyperlink baseLink = null;
    InlineHyperlink selectedLink = null;
    if (sideA) {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
        linkPanel.add(baseLink);
    }
    for (int i = 0; i < list.length(); i++) {
        RevisionInfo r = list.get(i);
        InlineHyperlink link = createLink(r.id(), new PatchSet.Id(changeId, r._number()));
        linkPanel.add(link);
        if (revision != null && r.id().equals(revision.getId())) {
            selectedLink = link;
        }
    }
    if (selectedLink != null) {
        selectedLink.setStyleName(style.selected());
    } else if (sideA) {
        baseLink.setStyleName(style.selected());
    }
    if (meta != null && !Patch.COMMIT_MSG.equals(path)) {
        linkPanel.add(createDownloadLink());
    }
    if (idActive != null && Gerrit.isSignedIn() && meta != null && !Patch.COMMIT_MSG.equals(path)) {
        if ((editExists && idActive.get() == 0) || (!editExists && idActive.get() == currentPatchSet)) {
            linkPanel.add(createEditIcon());
        }
    }
    if (webLinks != null) {
        for (WebLinkInfo weblink : webLinks) {
            Anchor a = new Anchor();
            a.setHref(weblink.url());
            if (weblink.target() != null && !weblink.target().isEmpty()) {
                a.setTarget(weblink.target());
            }
            if (weblink.imageUrl() != null && !weblink.imageUrl().isEmpty()) {
                Image img = new Image();
                img.setAltText(weblink.name());
                img.setUrl(weblink.imageUrl());
                img.setTitle(weblink.name());
                a.getElement().appendChild(img.getElement());
            } else {
                a.setText("(" + weblink.name() + ")");
            }
            linkPanel.add(a);
        }
    }
}
#end_block

#method_before
private Widget createEditIcon() {
    final Anchor anchor = new Anchor(new ImageResourceRenderer().render(Gerrit.RESOURCES.edit()));
    anchor.addClickHandler(new ClickHandler() {

        boolean editing = false;

        @Override
        public void onClick(ClickEvent event) {
            final PatchSet.Id id = (idActive == null) ? other.idActive : idActive;
            editing = !editing;
            parent.editSideB(editing);
            if (editing) {
                ChangeFileApi.getContent(id, path, new AsyncCallback<String>() {

                    @Override
                    public void onSuccess(String content) {
                        parent.setSiteBContent(content);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                    }
                });
                anchor.setHTML(new ImageResourceRenderer().render(Gerrit.RESOURCES.save()));
            } else {
                anchor.setHTML(new ImageResourceRenderer().render(Gerrit.RESOURCES.edit()));
                String siteBContent = parent.getSiteBContent();
                ChangeFileApi.putContent(id, path, siteBContent, new AsyncCallback<VoidResult>() {

                    @Override
                    public void onSuccess(VoidResult result) {
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                    }
                });
            }
        }
    });
    anchor.setTitle(PatchUtil.C.edit());
    return anchor;
}
#method_after
private Widget createEditIcon() {
    final Anchor anchor = new Anchor(new ImageResourceRenderer().render(Gerrit.RESOURCES.edit()));
    anchor.addClickHandler(new ClickHandler() {

        boolean editing = false;

        @Override
        public void onClick(ClickEvent event) {
            final PatchSet.Id id = (idActive == null) ? other.idActive : idActive;
            editing = !editing;
            parent.editSideB(editing);
            if (editing) {
                ChangeFileApi.getContent(id, path, new GerritCallback<String>() {

                    @Override
                    public void onSuccess(String content) {
                        parent.setSideBContent(content);
                    }
                });
                anchor.setHTML(new ImageResourceRenderer().render(Gerrit.RESOURCES.save()));
            } else {
                anchor.setHTML(new ImageResourceRenderer().render(Gerrit.RESOURCES.edit()));
                String siteBContent = parent.getSideBContent();
                ChangeFileApi.putContent(id, path, siteBContent, new GerritCallback<VoidResult>() {

                    @Override
                    public void onSuccess(VoidResult result) {
                    }
                });
            }
        }
    });
    anchor.setTitle(PatchUtil.C.edit());
    return anchor;
}
#end_block

#method_before
private BeforeSelectionChangeHandler onSelectionChange(final CodeMirror cm) {
    return new BeforeSelectionChangeHandler() {

        private InsertCommentBubble bubble;

        @Override
        public void handle(CodeMirror cm, LineCharacter anchor, LineCharacter head) {
            if (anchor == head || (anchor.getLine() == head.getLine() && anchor.getCh() == head.getCh())) {
                if (bubble != null) {
                    bubble.setVisible(false);
                }
                return;
            } else if (bubble == null) {
                init(anchor);
            } else {
                bubble.setVisible(true);
            }
            bubble.position(cm.charCoords(head, "local"));
        }

        private void init(LineCharacter anchor) {
            bubble = new InsertCommentBubble(commentManager, cm);
            add(bubble);
            cm.addWidget(anchor, bubble.getElement(), false);
        }
    };
}
#method_after
private BeforeSelectionChangeHandler onSelectionChange(final CodeMirror cm) {
    return new BeforeSelectionChangeHandler() {

        private InsertCommentBubble bubble;

        @Override
        public void handle(CodeMirror cm, LineCharacter anchor, LineCharacter head) {
            if (isEdited) {
                return;
            }
            if (anchor == head || (anchor.getLine() == head.getLine() && anchor.getCh() == head.getCh())) {
                if (bubble != null) {
                    bubble.setVisible(false);
                }
                return;
            } else if (bubble == null) {
                init(anchor);
            } else {
                bubble.setVisible(true);
            }
            bubble.position(cm.charCoords(head, "local"));
        }

        private void init(LineCharacter anchor) {
            bubble = new InsertCommentBubble(commentManager, cm);
            add(bubble);
            cm.addWidget(anchor, bubble.getElement(), false);
        }
    };
}
#end_block

#method_before
public void editSideB(boolean state) {
    cmB.setOption("readOnly", !state);
    JumpKeys.enable(!state);
    if (state) {
        removeKeyHandlerRegistrations();
        cmB.removeKeyMap(sbsKeyMap);
    } else {
        cmB.addKeyMap(sbsKeyMap);
        registerKeys();
    }
}
#method_after
public void editSideB(boolean state) {
    isEdited = state;
    cmB.setOption("readOnly", !state);
    JumpKeys.enable(!state);
    if (state) {
        removeKeyHandlerRegistrations();
        cmB.removeKeyMap(sbsKeyMap);
        cmB.setOption("keyMap", "default");
        cmB.focus();
    } else {
        cmB.setOption("keyMap", "vim_ro");
        cmB.addKeyMap(sbsKeyMap);
        registerKeys();
    }
}
#end_block

#method_before
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = refControl.getProjectControl().controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = refControl.getProjectControl().getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, change, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (hashtags != null && hashtags.size() > 0) {
        try {
            ChangeResource c = changes.get().parse(change.getId());
            HashtagsInput input = new HashtagsInput();
            input.add = hashtags;
            postHashtags.get().apply(c, input);
        } catch (RestApiException e) {
            log.error("Cannot add hashtags to change " + change.getId(), e);
        }
    }
    update.commit();
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    if (!messageIsForChange()) {
        commitMessageNotForChange();
    }
    if (sendMail) {
        try {
            CreateChangeSender cm = createChangeSenderFactory.create(change);
            cm.setFrom(change.getOwner());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.addReviewers(reviewers);
            cm.addExtraCC(extraCC);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new change " + change.getId(), err);
        }
    }
    f.checkedGet();
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    }
    return change;
}
#method_after
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = refControl.getProjectControl().controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = refControl.getProjectControl().getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, change, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (hashtags != null && hashtags.size() > 0) {
        try {
            HashtagsInput input = new HashtagsInput();
            input.add = hashtags;
            hashtagsUtil.setHashtags(ctl, input, false, false);
        } catch (ValidationException | AuthException e) {
            log.error("Cannot add hashtags to change " + change.getId(), e);
        }
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    if (!messageIsForChange()) {
        commitMessageNotForChange();
    }
    if (sendMail) {
        try {
            CreateChangeSender cm = createChangeSenderFactory.create(change);
            cm.setFrom(change.getOwner());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.addReviewers(reviewers);
            cm.addExtraCC(extraCC);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new change " + change.getId(), err);
        }
    }
    f.checkedGet();
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
        if (hashtags != null && hashtags.size() > 0) {
            hooks.doHashtagsChangedHook(change, accountCache.get(change.getOwner()).getAccount(), hashtags, null, hashtags, db);
        }
    }
    return change;
}
#end_block

#method_before
void setHeaderVisible(boolean show) {
    headerVisible = !autoHideHeader || show;
    UIObject.setVisible(patchSetNavRow, headerVisible);
    UIObject.setVisible(diffHeaderRow, headerVisible && header);
    if (headerVisible) {
        parent.header.removeStyleName(style.fullscreen());
    } else {
        parent.header.addStyleName(style.fullscreen());
    }
    parent.resizeCodeMirror();
}
#method_after
void setHeaderVisible(boolean show) {
    headerVisible = !autoHideHeader || show;
    showHeader(headerVisible);
}
#end_block

#method_before
void setAutoHideDiffHeader(boolean hide) {
    autoHideHeader = hide;
    if (!hide) {
        setHeaderVisible(true);
    }
}
#method_after
void setAutoHideDiffHeader(boolean hide) {
    autoHideHeader = hide;
    if (!hide) {
        showHeader(true);
    }
}
#end_block

#method_before
@UiHandler("autoHideDiffTableHeader")
void onAutoHideDiffTableHeader(ValueChangeEvent<Boolean> e) {
    prefs.autoHideDiffTableHeader(!e.getValue());
    view.setAutoHideDiffHeader(!e.getValue());
}
#method_after
@UiHandler("autoHideDiffTableHeader")
void onAutoHideDiffTableHeader(ValueChangeEvent<Boolean> e) {
    prefs.autoHideDiffTableHeader(!e.getValue());
    view.setAutoHideDiffHeader(!e.getValue());
    view.resizeCodeMirror();
}
#end_block

#method_before
public static AccountDiffPreference createDefault(Account.Id accountId) {
    AccountDiffPreference p = new AccountDiffPreference(accountId);
    p.setIgnoreWhitespace(Whitespace.IGNORE_NONE);
    p.setTheme(Theme.DEFAULT);
    p.setTabSize(8);
    p.setLineLength(100);
    p.setSyntaxHighlighting(true);
    p.setShowWhitespaceErrors(true);
    p.setShowLineEndings(true);
    p.setIntralineDifference(true);
    p.setShowTabs(true);
    p.setContext(DEFAULT_CONTEXT);
    p.setManualReview(false);
    p.setHideEmptyPane(false);
    return p;
}
#method_after
public static AccountDiffPreference createDefault(Account.Id accountId) {
    AccountDiffPreference p = new AccountDiffPreference(accountId);
    p.setIgnoreWhitespace(Whitespace.IGNORE_NONE);
    p.setTheme(Theme.DEFAULT);
    p.setTabSize(8);
    p.setLineLength(100);
    p.setSyntaxHighlighting(true);
    p.setShowWhitespaceErrors(true);
    p.setShowLineEndings(true);
    p.setIntralineDifference(true);
    p.setShowTabs(true);
    p.setContext(DEFAULT_CONTEXT);
    p.setManualReview(false);
    p.setHideEmptyPane(false);
    p.setAutoHideDiffTableHeader(true);
    return p;
}
#end_block

