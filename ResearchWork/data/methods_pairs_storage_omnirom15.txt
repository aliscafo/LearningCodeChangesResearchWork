86
#method_before
private boolean showDpadArrowKeys() {
    return Settings.System.getIntForUser(getContext().getContentResolver(), Settings.System.NAVIGATION_BAR_MENU_ARROW_KEYS, 0, UserHandle.USER_CURRENT) != 0;
}
#method_after
private boolean showDpadArrowKeys() {
    return Settings.System.getIntForUser(getContext().getContentResolver(), Settings.System.OMNI_NAVIGATION_BAR_ARROW_KEYS, 0, UserHandle.USER_CURRENT) != 0;
}
#end_block

#method_before
public void systemReady(IAppOpsService appOps) {
    synchronized (mLock) {
        mSystemReady = true;
        mAppOps = appOps;
        mDreamManager = getLocalService(DreamManagerInternal.class);
        mDisplayManagerInternal = getLocalService(DisplayManagerInternal.class);
        mPolicy = getLocalService(WindowManagerPolicy.class);
        mBatteryManagerInternal = getLocalService(BatteryManagerInternal.class);
        PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
        mScreenBrightnessSettingMinimum = pm.getMinimumScreenBrightnessSetting();
        mScreenBrightnessSettingMaximum = pm.getMaximumScreenBrightnessSetting();
        mScreenBrightnessSettingDefault = pm.getDefaultScreenBrightnessSetting();
        SensorManager sensorManager = new SystemSensorManager(mContext, mHandler.getLooper());
        // The notifier runs on the system server's main looper so as not to interfere
        // with the animations and other critical functions of the power manager.
        mBatteryStats = BatteryStatsService.getService();
        mNotifier = new Notifier(Looper.getMainLooper(), mContext, mBatteryStats, createSuspendBlockerLocked("PowerManagerService.Broadcasts"), mPolicy);
        mWirelessChargerDetector = new WirelessChargerDetector(sensorManager, createSuspendBlockerLocked("PowerManagerService.WirelessChargerDetector"), mHandler);
        mSettingsObserver = new SettingsObserver(mHandler);
        mLightsManager = getLocalService(LightsManager.class);
        mAttentionLight = mLightsManager.getLight(LightsManager.LIGHT_ID_ATTENTION);
        // Initialize display power management.
        mDisplayManagerInternal.initPowerManagement(mDisplayPowerCallbacks, mHandler, sensorManager);
        try {
            final ForegroundProfileObserver observer = new ForegroundProfileObserver();
            ActivityManager.getService().registerUserSwitchObserver(observer, TAG);
        } catch (RemoteException e) {
        // Shouldn't happen since in-process.
        }
        // Go.
        readConfigurationLocked();
        updateSettingsLocked();
        mDirty |= DIRTY_BATTERY_STATE;
        updatePowerStateLocked();
    }
    final ContentResolver resolver = mContext.getContentResolver();
    mConstants.start(resolver);
    mBatterySaverController.systemReady();
    mBatterySaverPolicy.systemReady();
    // Register for settings changes.
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ENABLED), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SLEEP_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.STAY_ON_WHILE_PLUGGED_IN), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.THEATER_MODE_ON), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DOZE_ALWAYS_ON), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DOUBLE_TAP_TO_WAKE), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.DEVICE_DEMO_MODE), false, mSettingsObserver, UserHandle.USER_SYSTEM);
    IVrManager vrManager = (IVrManager) getBinderService(Context.VR_SERVICE);
    if (vrManager != null) {
        try {
            vrManager.registerListener(mVrStateCallbacks);
        } catch (RemoteException e) {
            Slog.e(TAG, "Failed to register VR mode state listener: " + e);
        }
    }
    // Register for broadcasts from other components of the system.
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_BATTERY_CHANGED);
    filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
    mContext.registerReceiver(new BatteryReceiver(), filter, null, mHandler);
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    mContext.registerReceiver(new DreamReceiver(), filter, null, mHandler);
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    mContext.registerReceiver(new UserSwitchedReceiver(), filter, null, mHandler);
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    mContext.registerReceiver(new DockReceiver(), filter, null, mHandler);
    if (mButtonBrightnessSupport) {
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.OMNI_CUSTOM_BUTTON_BRIGHTNESS), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.OMNI_CUSTOM_BUTTON_USE_SCREEN_BRIGHTNESS), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.OMNI_BUTTON_BACKLIGHT_ENABLE), false, mSettingsObserver, UserHandle.USER_ALL);
        /*
            resolver.registerContentObserver(
                    Settings.Secure.getUriFor(Settings.Secure.HARDWARE_KEYS_DISABLE),
                    false, mSettingsObserver, UserHandle.USER_ALL);
            */
        // TODO enable once DUI is up
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.OMNI_BUTTON_BACKLIGHT_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.OMNI_BUTTON_BACKLIGHT_ON_TOUCH_ONLY), false, mSettingsObserver, UserHandle.USER_ALL);
    }
}
#method_after
public void systemReady(IAppOpsService appOps) {
    synchronized (mLock) {
        mSystemReady = true;
        mAppOps = appOps;
        mDreamManager = getLocalService(DreamManagerInternal.class);
        mDisplayManagerInternal = getLocalService(DisplayManagerInternal.class);
        mPolicy = getLocalService(WindowManagerPolicy.class);
        mBatteryManagerInternal = getLocalService(BatteryManagerInternal.class);
        PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
        mScreenBrightnessSettingMinimum = pm.getMinimumScreenBrightnessSetting();
        mScreenBrightnessSettingMaximum = pm.getMaximumScreenBrightnessSetting();
        mScreenBrightnessSettingDefault = pm.getDefaultScreenBrightnessSetting();
        SensorManager sensorManager = new SystemSensorManager(mContext, mHandler.getLooper());
        // The notifier runs on the system server's main looper so as not to interfere
        // with the animations and other critical functions of the power manager.
        mBatteryStats = BatteryStatsService.getService();
        mNotifier = new Notifier(Looper.getMainLooper(), mContext, mBatteryStats, createSuspendBlockerLocked("PowerManagerService.Broadcasts"), mPolicy);
        mWirelessChargerDetector = new WirelessChargerDetector(sensorManager, createSuspendBlockerLocked("PowerManagerService.WirelessChargerDetector"), mHandler);
        mSettingsObserver = new SettingsObserver(mHandler);
        mLightsManager = getLocalService(LightsManager.class);
        mAttentionLight = mLightsManager.getLight(LightsManager.LIGHT_ID_ATTENTION);
        // Initialize display power management.
        mDisplayManagerInternal.initPowerManagement(mDisplayPowerCallbacks, mHandler, sensorManager);
        try {
            final ForegroundProfileObserver observer = new ForegroundProfileObserver();
            ActivityManager.getService().registerUserSwitchObserver(observer, TAG);
        } catch (RemoteException e) {
        // Shouldn't happen since in-process.
        }
        // Go.
        readConfigurationLocked();
        updateSettingsLocked();
        mDirty |= DIRTY_BATTERY_STATE;
        updatePowerStateLocked();
    }
    final ContentResolver resolver = mContext.getContentResolver();
    mConstants.start(resolver);
    mBatterySaverController.systemReady();
    mBatterySaverPolicy.systemReady();
    // Register for settings changes.
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ENABLED), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SLEEP_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.STAY_ON_WHILE_PLUGGED_IN), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.THEATER_MODE_ON), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DOZE_ALWAYS_ON), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DOUBLE_TAP_TO_WAKE), false, mSettingsObserver, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.DEVICE_DEMO_MODE), false, mSettingsObserver, UserHandle.USER_SYSTEM);
    IVrManager vrManager = (IVrManager) getBinderService(Context.VR_SERVICE);
    if (vrManager != null) {
        try {
            vrManager.registerListener(mVrStateCallbacks);
        } catch (RemoteException e) {
            Slog.e(TAG, "Failed to register VR mode state listener: " + e);
        }
    }
    // Register for broadcasts from other components of the system.
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_BATTERY_CHANGED);
    filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
    mContext.registerReceiver(new BatteryReceiver(), filter, null, mHandler);
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    mContext.registerReceiver(new DreamReceiver(), filter, null, mHandler);
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    mContext.registerReceiver(new UserSwitchedReceiver(), filter, null, mHandler);
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    mContext.registerReceiver(new DockReceiver(), filter, null, mHandler);
    if (mButtonBrightnessSupport) {
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.OMNI_CUSTOM_BUTTON_BRIGHTNESS), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.OMNI_CUSTOM_BUTTON_USE_SCREEN_BRIGHTNESS), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.OMNI_BUTTON_BACKLIGHT_ENABLE), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.OMNI_HARDWARE_KEYS_DISABLE), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.OMNI_BUTTON_BACKLIGHT_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.OMNI_BUTTON_BACKLIGHT_ON_TOUCH_ONLY), false, mSettingsObserver, UserHandle.USER_ALL);
    }
}
#end_block

#method_before
private void updateButtonLightSettings() {
    final ContentResolver resolver = mContext.getContentResolver();
    if (mButtonBrightnessSupport) {
        mCustomButtonBrightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.OMNI_CUSTOM_BUTTON_BRIGHTNESS, mCustomButtonBrightness, UserHandle.USER_CURRENT);
        mButtonUseScreenBrightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.OMNI_CUSTOM_BUTTON_USE_SCREEN_BRIGHTNESS, 0, UserHandle.USER_CURRENT) != 0;
        mButtonBacklightEnable = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.OMNI_BUTTON_BACKLIGHT_ENABLE, 1, UserHandle.USER_CURRENT) != 0;
        /*boolean hardwareKeysDisable = Settings.Secure.getIntForUser(
                    mContext.getContentResolver(), Settings.Secure.OMNI_HARDWARE_KEYS_DISABLE,
                    0, UserHandle.USER_CURRENT) != 0;

            mButtonBacklightEnable = mButtonBacklightEnable && !hardwareKeysDisable;*/
        // TODO enable once DUI is up
        mButtonBacklightOnTouchOnly = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.OMNI_BUTTON_BACKLIGHT_ON_TOUCH_ONLY, 0, UserHandle.USER_CURRENT) != 0;
        mButtonTimeout = Settings.System.getIntForUser(resolver, Settings.System.OMNI_BUTTON_BACKLIGHT_TIMEOUT, 0, UserHandle.USER_CURRENT) * 1000;
        mButtonTimeoutEnabled = mButtonTimeout != 0 && mButtonBacklightEnable;
        // prevent remaining timout to be triggered
        mHandler.removeMessages(MSG_BUTTON_TIMEOUT);
        // force it off - it will come back if needed later
        updateButtonLight(true);
    }
}
#method_after
private void updateButtonLightSettings() {
    final ContentResolver resolver = mContext.getContentResolver();
    if (mButtonBrightnessSupport) {
        mCustomButtonBrightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.OMNI_CUSTOM_BUTTON_BRIGHTNESS, mCustomButtonBrightness, UserHandle.USER_CURRENT);
        mButtonUseScreenBrightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.OMNI_CUSTOM_BUTTON_USE_SCREEN_BRIGHTNESS, 0, UserHandle.USER_CURRENT) != 0;
        mButtonBacklightEnable = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.OMNI_BUTTON_BACKLIGHT_ENABLE, 1, UserHandle.USER_CURRENT) != 0;
        boolean hardwareKeysDisable = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.OMNI_HARDWARE_KEYS_DISABLE, 0, UserHandle.USER_CURRENT) != 0;
        mButtonBacklightEnable = mButtonBacklightEnable && !hardwareKeysDisable;
        mButtonBacklightOnTouchOnly = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.OMNI_BUTTON_BACKLIGHT_ON_TOUCH_ONLY, 0, UserHandle.USER_CURRENT) != 0;
        mButtonTimeout = Settings.System.getIntForUser(resolver, Settings.System.OMNI_BUTTON_BACKLIGHT_TIMEOUT, 0, UserHandle.USER_CURRENT) * 1000;
        mButtonTimeoutEnabled = mButtonTimeout != 0 && mButtonBacklightEnable;
        // prevent remaining timout to be triggered
        mHandler.removeMessages(MSG_BUTTON_TIMEOUT);
        // force it off - it will come back if needed later
        updateButtonLight(true);
    }
}
#end_block

#method_before
public void update() {
    ContentResolver resolver = mContext.getContentResolver();
    Resources res = mContext.getResources();
    // Battery light enabled
    mLightEnabled = Settings.System.getInt(resolver, Settings.System.OMNI_BATTERY_LIGHT_ENABLED, 1) != 0;
    mAllowBatteryLightOnDnd = Settings.System.getInt(resolver, Settings.System.OMNI_BATTERY_LIGHT_ALLOW_ON_DND, 0) == 1;
    mIsDndActive = Settings.Global.getInt(resolver, Settings.Global.ZEN_MODE, Settings.Global.ZEN_MODE_OFF) != Settings.Global.ZEN_MODE_OFF;
    mLowBatteryBlinking = Settings.System.getInt(resolver, Settings.System.OMNI_BATTERY_LIGHT_LOW_BLINKING, 0) == 1;
    mBatteryLowARGB = Settings.System.getInt(resolver, Settings.System.OMNI_BATTERY_LIGHT_LOW_COLOR, 0xFFFF0000);
    mBatteryMediumARGB = Settings.System.getInt(resolver, Settings.System.OMNI_BATTERY_LIGHT_MEDIUM_COLOR, 0xFFFFFF00);
    mBatteryFullARGB = Settings.System.getInt(resolver, Settings.System.OMNI_BATTERY_LIGHT_FULL_COLOR, 0xFFFFFF00);
    mBatteryReallyFullARGB = Settings.System.getInt(resolver, Settings.System.OMNI_BATTERY_LIGHT_REALLY_FULL_COLOR, 0xFF00FF00);
    mFastBatteryLightEnabled = Settings.System.getIntForUser(resolver, Settings.System.OMNI_FAST_CHARGING_LED_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
    mFastBatteryARGB = Settings.System.getIntForUser(resolver, Settings.System.OMNI_FAST_BATTERY_LIGHT_COLOR, res.getInteger(com.android.internal.R.integer.config_notificationsFastBatteryARGB), UserHandle.USER_CURRENT);
    mLightOnlyFullyCharged = Settings.System.getIntForUser(resolver, Settings.System.OMNI_BATTERY_LIGHT_ONLY_FULLY_CHARGED, 0, UserHandle.USER_CURRENT) != 0;
    updateLed();
}
#method_after
public void update() {
    ContentResolver resolver = mContext.getContentResolver();
    Resources res = mContext.getResources();
    // Battery light enabled
    mLightEnabled = Settings.System.getIntForUser(resolver, Settings.System.OMNI_BATTERY_LIGHT_ENABLED, 1, UserHandle.USER_CURRENT) != 0;
    mAllowBatteryLightOnDnd = Settings.System.getIntForUser(resolver, Settings.System.OMNI_BATTERY_LIGHT_ALLOW_ON_DND, 0, UserHandle.USER_CURRENT) == 1;
    mIsDndActive = Settings.Global.getInt(resolver, Settings.Global.ZEN_MODE, Settings.Global.ZEN_MODE_OFF) != Settings.Global.ZEN_MODE_OFF;
    mLowBatteryBlinking = Settings.System.getIntForUser(resolver, Settings.System.OMNI_BATTERY_LIGHT_LOW_BLINKING, 0, UserHandle.USER_CURRENT) == 1;
    mBatteryLowARGB = Settings.System.getIntForUser(resolver, Settings.System.OMNI_BATTERY_LIGHT_LOW_COLOR, 0xFFFF0000, UserHandle.USER_CURRENT);
    mBatteryMediumARGB = Settings.System.getIntForUser(resolver, Settings.System.OMNI_BATTERY_LIGHT_MEDIUM_COLOR, 0xFFFFFF00, UserHandle.USER_CURRENT);
    mBatteryFullARGB = Settings.System.getIntForUser(resolver, Settings.System.OMNI_BATTERY_LIGHT_FULL_COLOR, 0xFFFFFF00, UserHandle.USER_CURRENT);
    mBatteryReallyFullARGB = Settings.System.getIntForUser(resolver, Settings.System.OMNI_BATTERY_LIGHT_REALLY_FULL_COLOR, 0xFF00FF00, UserHandle.USER_CURRENT);
    mFastBatteryLightEnabled = Settings.System.getIntForUser(resolver, Settings.System.OMNI_FAST_CHARGING_LED_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
    mFastBatteryARGB = Settings.System.getIntForUser(resolver, Settings.System.OMNI_FAST_BATTERY_LIGHT_COLOR, res.getInteger(com.android.internal.R.integer.config_notificationsFastBatteryARGB), UserHandle.USER_CURRENT);
    mLightOnlyFullyCharged = Settings.System.getIntForUser(resolver, Settings.System.OMNI_BATTERY_LIGHT_ONLY_FULLY_CHARGED, 0, UserHandle.USER_CURRENT) != 0;
    updateLed();
}
#end_block

#method_before
private void processValuesLocked(boolean force) {
    boolean logOutlier = false;
    long dischargeDuration = 0;
    mBatteryLevelCritical = mHealthInfo.batteryStatus != BatteryManager.BATTERY_STATUS_UNKNOWN && mHealthInfo.batteryLevel <= mCriticalBatteryLevel;
    if (mHealthInfo.chargerAcOnline) {
        mPlugType = BatteryManager.BATTERY_PLUGGED_AC;
    } else if (mHealthInfo.chargerUsbOnline) {
        mPlugType = BatteryManager.BATTERY_PLUGGED_USB;
    } else if (mHealthInfo.chargerWirelessOnline) {
        mPlugType = BatteryManager.BATTERY_PLUGGED_WIRELESS;
    } else {
        mPlugType = BATTERY_PLUGGED_NONE;
    }
    if (DEBUG) {
        Slog.d(TAG, "Processing new values: " + "info=" + mHealthInfo + ", mBatteryLevelCritical=" + mBatteryLevelCritical + ", mPlugType=" + mPlugType);
    }
    // Let the battery stats keep track of the current level.
    try {
        mBatteryStats.setBatteryState(mHealthInfo.batteryStatus, mHealthInfo.batteryHealth, mPlugType, mHealthInfo.batteryLevel, mHealthInfo.batteryTemperature, mHealthInfo.batteryVoltage, mHealthInfo.batteryChargeCounter, mHealthInfo.batteryFullCharge);
    } catch (RemoteException e) {
    // Should never happen.
    }
    shutdownIfNoPowerLocked();
    shutdownIfOverTempLocked();
    if (force || (mHealthInfo.batteryStatus != mLastBatteryStatus || mHealthInfo.batteryHealth != mLastBatteryHealth || mHealthInfo.batteryPresent != mLastBatteryPresent || mHealthInfo.batteryLevel != mLastBatteryLevel || mPlugType != mLastPlugType || mHealthInfo.batteryVoltage != mLastBatteryVoltage || mHealthInfo.batteryTemperature != mLastBatteryTemperature || mHealthInfo.maxChargingCurrent != mLastMaxChargingCurrent || mHealthInfo.maxChargingVoltage != mLastMaxChargingVoltage || mHealthInfo.batteryChargeCounter != mLastChargeCounter || mInvalidCharger != mLastInvalidCharger)) {
        if (mPlugType != mLastPlugType) {
            if (mLastPlugType == BATTERY_PLUGGED_NONE) {
                // discharging -> charging
                mChargeStartLevel = mHealthInfo.batteryLevel;
                mChargeStartTime = SystemClock.elapsedRealtime();
                final LogMaker builder = new LogMaker(MetricsEvent.ACTION_CHARGE);
                builder.setType(MetricsEvent.TYPE_ACTION);
                builder.addTaggedData(MetricsEvent.FIELD_PLUG_TYPE, mPlugType);
                builder.addTaggedData(MetricsEvent.FIELD_BATTERY_LEVEL_START, mHealthInfo.batteryLevel);
                mMetricsLogger.write(builder);
                // battery level has changed; so don't log until it does.
                if (mDischargeStartTime != 0 && mDischargeStartLevel != mHealthInfo.batteryLevel) {
                    dischargeDuration = SystemClock.elapsedRealtime() - mDischargeStartTime;
                    logOutlier = true;
                    EventLog.writeEvent(EventLogTags.BATTERY_DISCHARGE, dischargeDuration, mDischargeStartLevel, mHealthInfo.batteryLevel);
                    // make sure we see a discharge event before logging again
                    mDischargeStartTime = 0;
                }
            } else if (mPlugType == BATTERY_PLUGGED_NONE) {
                // charging -> discharging or we just powered up
                mDischargeStartTime = SystemClock.elapsedRealtime();
                mDischargeStartLevel = mHealthInfo.batteryLevel;
                long chargeDuration = SystemClock.elapsedRealtime() - mChargeStartTime;
                if (mChargeStartTime != 0 && chargeDuration != 0) {
                    final LogMaker builder = new LogMaker(MetricsEvent.ACTION_CHARGE);
                    builder.setType(MetricsEvent.TYPE_DISMISS);
                    builder.addTaggedData(MetricsEvent.FIELD_PLUG_TYPE, mLastPlugType);
                    builder.addTaggedData(MetricsEvent.FIELD_CHARGING_DURATION_MILLIS, chargeDuration);
                    builder.addTaggedData(MetricsEvent.FIELD_BATTERY_LEVEL_START, mChargeStartLevel);
                    builder.addTaggedData(MetricsEvent.FIELD_BATTERY_LEVEL_END, mHealthInfo.batteryLevel);
                    mMetricsLogger.write(builder);
                }
                mChargeStartTime = 0;
            }
        }
        if (mHealthInfo.batteryStatus != mLastBatteryStatus || mHealthInfo.batteryHealth != mLastBatteryHealth || mHealthInfo.batteryPresent != mLastBatteryPresent || mPlugType != mLastPlugType) {
            EventLog.writeEvent(EventLogTags.BATTERY_STATUS, mHealthInfo.batteryStatus, mHealthInfo.batteryHealth, mHealthInfo.batteryPresent ? 1 : 0, mPlugType, mHealthInfo.batteryTechnology);
        }
        if (mHealthInfo.batteryLevel != mLastBatteryLevel) {
            // Don't do this just from voltage or temperature changes, that is
            // too noisy.
            EventLog.writeEvent(EventLogTags.BATTERY_LEVEL, mHealthInfo.batteryLevel, mHealthInfo.batteryVoltage, mHealthInfo.batteryTemperature);
        }
        if (mBatteryLevelCritical && !mLastBatteryLevelCritical && mPlugType == BATTERY_PLUGGED_NONE) {
            // We want to make sure we log discharge cycle outliers
            // if the battery is about to die.
            dischargeDuration = SystemClock.elapsedRealtime() - mDischargeStartTime;
            logOutlier = true;
        }
        if (!mBatteryLevelLow) {
            // Should we now switch in to low battery mode?
            if (mPlugType == BATTERY_PLUGGED_NONE && mHealthInfo.batteryStatus != BatteryManager.BATTERY_STATUS_UNKNOWN && mHealthInfo.batteryLevel <= mLowBatteryWarningLevel) {
                mBatteryLevelLow = true;
            }
        } else {
            // Should we now switch out of low battery mode?
            if (mPlugType != BATTERY_PLUGGED_NONE) {
                mBatteryLevelLow = false;
            } else if (mHealthInfo.batteryLevel >= mLowBatteryCloseWarningLevel) {
                mBatteryLevelLow = false;
            } else if (force && mHealthInfo.batteryLevel >= mLowBatteryWarningLevel) {
                // If being forced, the previous state doesn't matter, we will just
                // absolutely check to see if we are now above the warning level.
                mBatteryLevelLow = false;
            }
        }
        mSequence++;
        // applications may want to have smart behavior based on this.
        if (mPlugType != 0 && mLastPlugType == 0) {
            final Intent statusIntent = new Intent(Intent.ACTION_POWER_CONNECTED);
            statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            statusIntent.putExtra(BatteryManager.EXTRA_SEQUENCE, mSequence);
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        } else if (mPlugType == 0 && mLastPlugType != 0) {
            final Intent statusIntent = new Intent(Intent.ACTION_POWER_DISCONNECTED);
            statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            statusIntent.putExtra(BatteryManager.EXTRA_SEQUENCE, mSequence);
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        }
        if (shouldSendBatteryLowLocked()) {
            mSentLowBatteryBroadcast = true;
            final Intent statusIntent = new Intent(Intent.ACTION_BATTERY_LOW);
            statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            statusIntent.putExtra(BatteryManager.EXTRA_SEQUENCE, mSequence);
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        } else if (mSentLowBatteryBroadcast && mHealthInfo.batteryLevel >= mLowBatteryCloseWarningLevel) {
            mSentLowBatteryBroadcast = false;
            final Intent statusIntent = new Intent(Intent.ACTION_BATTERY_OKAY);
            statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            statusIntent.putExtra(BatteryManager.EXTRA_SEQUENCE, mSequence);
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        }
        // We are doing this after sending the above broadcasts, so anything processing
        // them will get the new sequence number at that point.  (See for example how testing
        // of JobScheduler's BatteryController works.)
        sendBatteryChangedIntentLocked();
        if (mLastBatteryLevel != mHealthInfo.batteryLevel) {
            sendBatteryLevelChangedIntentLocked();
        }
        // Update the battery LED
        mLed.updateLightsLocked();
        // This needs to be done after sendIntent() so that we get the lastest battery stats.
        if (logOutlier && dischargeDuration != 0) {
            logOutlierLocked(dischargeDuration);
        }
        mLastBatteryStatus = mHealthInfo.batteryStatus;
        mLastBatteryHealth = mHealthInfo.batteryHealth;
        mLastBatteryPresent = mHealthInfo.batteryPresent;
        mLastBatteryLevel = mHealthInfo.batteryLevel;
        mLastPlugType = mPlugType;
        mLastBatteryVoltage = mHealthInfo.batteryVoltage;
        mLastBatteryTemperature = mHealthInfo.batteryTemperature;
        mLastMaxChargingCurrent = mHealthInfo.maxChargingCurrent;
        mLastMaxChargingVoltage = mHealthInfo.maxChargingVoltage;
        mLastChargeCounter = mHealthInfo.batteryChargeCounter;
        mLastBatteryLevelCritical = mBatteryLevelCritical;
        mLastInvalidCharger = mInvalidCharger;
        mMaxChargingWattage = mLastMaxChargingCurrent * 5;
        if (mFastChargingLedSupported) {
            // Update the Fast battery LED
            mLed.fastCharge(mMaxChargingWattage);
        }
    }
}
#method_after
private void processValuesLocked(boolean force) {
    boolean logOutlier = false;
    long dischargeDuration = 0;
    mBatteryLevelCritical = mHealthInfo.batteryStatus != BatteryManager.BATTERY_STATUS_UNKNOWN && mHealthInfo.batteryLevel <= mCriticalBatteryLevel;
    if (mHealthInfo.chargerAcOnline) {
        mPlugType = BatteryManager.BATTERY_PLUGGED_AC;
    } else if (mHealthInfo.chargerUsbOnline) {
        mPlugType = BatteryManager.BATTERY_PLUGGED_USB;
    } else if (mHealthInfo.chargerWirelessOnline) {
        mPlugType = BatteryManager.BATTERY_PLUGGED_WIRELESS;
    } else {
        mPlugType = BATTERY_PLUGGED_NONE;
    }
    if (DEBUG) {
        Slog.d(TAG, "Processing new values: " + "info=" + mHealthInfo + ", mBatteryLevelCritical=" + mBatteryLevelCritical + ", mPlugType=" + mPlugType);
    }
    // Let the battery stats keep track of the current level.
    try {
        mBatteryStats.setBatteryState(mHealthInfo.batteryStatus, mHealthInfo.batteryHealth, mPlugType, mHealthInfo.batteryLevel, mHealthInfo.batteryTemperature, mHealthInfo.batteryVoltage, mHealthInfo.batteryChargeCounter, mHealthInfo.batteryFullCharge);
    } catch (RemoteException e) {
    // Should never happen.
    }
    shutdownIfNoPowerLocked();
    shutdownIfOverTempLocked();
    if (force || (mHealthInfo.batteryStatus != mLastBatteryStatus || mHealthInfo.batteryHealth != mLastBatteryHealth || mHealthInfo.batteryPresent != mLastBatteryPresent || mHealthInfo.batteryLevel != mLastBatteryLevel || mPlugType != mLastPlugType || mHealthInfo.batteryVoltage != mLastBatteryVoltage || mHealthInfo.batteryTemperature != mLastBatteryTemperature || mHealthInfo.maxChargingCurrent != mLastMaxChargingCurrent || mHealthInfo.maxChargingVoltage != mLastMaxChargingVoltage || mHealthInfo.batteryChargeCounter != mLastChargeCounter || mInvalidCharger != mLastInvalidCharger)) {
        if (mPlugType != mLastPlugType) {
            if (mLastPlugType == BATTERY_PLUGGED_NONE) {
                // discharging -> charging
                mChargeStartLevel = mHealthInfo.batteryLevel;
                mChargeStartTime = SystemClock.elapsedRealtime();
                final LogMaker builder = new LogMaker(MetricsEvent.ACTION_CHARGE);
                builder.setType(MetricsEvent.TYPE_ACTION);
                builder.addTaggedData(MetricsEvent.FIELD_PLUG_TYPE, mPlugType);
                builder.addTaggedData(MetricsEvent.FIELD_BATTERY_LEVEL_START, mHealthInfo.batteryLevel);
                mMetricsLogger.write(builder);
                // battery level has changed; so don't log until it does.
                if (mDischargeStartTime != 0 && mDischargeStartLevel != mHealthInfo.batteryLevel) {
                    dischargeDuration = SystemClock.elapsedRealtime() - mDischargeStartTime;
                    logOutlier = true;
                    EventLog.writeEvent(EventLogTags.BATTERY_DISCHARGE, dischargeDuration, mDischargeStartLevel, mHealthInfo.batteryLevel);
                    // make sure we see a discharge event before logging again
                    mDischargeStartTime = 0;
                }
            } else if (mPlugType == BATTERY_PLUGGED_NONE) {
                // charging -> discharging or we just powered up
                mDischargeStartTime = SystemClock.elapsedRealtime();
                mDischargeStartLevel = mHealthInfo.batteryLevel;
                long chargeDuration = SystemClock.elapsedRealtime() - mChargeStartTime;
                if (mChargeStartTime != 0 && chargeDuration != 0) {
                    final LogMaker builder = new LogMaker(MetricsEvent.ACTION_CHARGE);
                    builder.setType(MetricsEvent.TYPE_DISMISS);
                    builder.addTaggedData(MetricsEvent.FIELD_PLUG_TYPE, mLastPlugType);
                    builder.addTaggedData(MetricsEvent.FIELD_CHARGING_DURATION_MILLIS, chargeDuration);
                    builder.addTaggedData(MetricsEvent.FIELD_BATTERY_LEVEL_START, mChargeStartLevel);
                    builder.addTaggedData(MetricsEvent.FIELD_BATTERY_LEVEL_END, mHealthInfo.batteryLevel);
                    mMetricsLogger.write(builder);
                }
                mChargeStartTime = 0;
            }
        }
        if (mHealthInfo.batteryStatus != mLastBatteryStatus || mHealthInfo.batteryHealth != mLastBatteryHealth || mHealthInfo.batteryPresent != mLastBatteryPresent || mPlugType != mLastPlugType) {
            EventLog.writeEvent(EventLogTags.BATTERY_STATUS, mHealthInfo.batteryStatus, mHealthInfo.batteryHealth, mHealthInfo.batteryPresent ? 1 : 0, mPlugType, mHealthInfo.batteryTechnology);
        }
        if (mHealthInfo.batteryLevel != mLastBatteryLevel) {
            // Don't do this just from voltage or temperature changes, that is
            // too noisy.
            EventLog.writeEvent(EventLogTags.BATTERY_LEVEL, mHealthInfo.batteryLevel, mHealthInfo.batteryVoltage, mHealthInfo.batteryTemperature);
        }
        if (mBatteryLevelCritical && !mLastBatteryLevelCritical && mPlugType == BATTERY_PLUGGED_NONE) {
            // We want to make sure we log discharge cycle outliers
            // if the battery is about to die.
            dischargeDuration = SystemClock.elapsedRealtime() - mDischargeStartTime;
            logOutlier = true;
        }
        if (!mBatteryLevelLow) {
            // Should we now switch in to low battery mode?
            if (mPlugType == BATTERY_PLUGGED_NONE && mHealthInfo.batteryStatus != BatteryManager.BATTERY_STATUS_UNKNOWN && mHealthInfo.batteryLevel <= mLowBatteryWarningLevel) {
                mBatteryLevelLow = true;
            }
        } else {
            // Should we now switch out of low battery mode?
            if (mPlugType != BATTERY_PLUGGED_NONE) {
                mBatteryLevelLow = false;
            } else if (mHealthInfo.batteryLevel >= mLowBatteryCloseWarningLevel) {
                mBatteryLevelLow = false;
            } else if (force && mHealthInfo.batteryLevel >= mLowBatteryWarningLevel) {
                // If being forced, the previous state doesn't matter, we will just
                // absolutely check to see if we are now above the warning level.
                mBatteryLevelLow = false;
            }
        }
        mSequence++;
        // applications may want to have smart behavior based on this.
        if (mPlugType != 0 && mLastPlugType == 0) {
            final Intent statusIntent = new Intent(Intent.ACTION_POWER_CONNECTED);
            statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            statusIntent.putExtra(BatteryManager.EXTRA_SEQUENCE, mSequence);
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        } else if (mPlugType == 0 && mLastPlugType != 0) {
            final Intent statusIntent = new Intent(Intent.ACTION_POWER_DISCONNECTED);
            statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            statusIntent.putExtra(BatteryManager.EXTRA_SEQUENCE, mSequence);
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        }
        if (shouldSendBatteryLowLocked()) {
            mSentLowBatteryBroadcast = true;
            final Intent statusIntent = new Intent(Intent.ACTION_BATTERY_LOW);
            statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            statusIntent.putExtra(BatteryManager.EXTRA_SEQUENCE, mSequence);
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        } else if (mSentLowBatteryBroadcast && mHealthInfo.batteryLevel >= mLowBatteryCloseWarningLevel) {
            mSentLowBatteryBroadcast = false;
            final Intent statusIntent = new Intent(Intent.ACTION_BATTERY_OKAY);
            statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            statusIntent.putExtra(BatteryManager.EXTRA_SEQUENCE, mSequence);
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        }
        // We are doing this after sending the above broadcasts, so anything processing
        // them will get the new sequence number at that point.  (See for example how testing
        // of JobScheduler's BatteryController works.)
        sendBatteryChangedIntentLocked();
        if (mLastBatteryLevel != mHealthInfo.batteryLevel) {
            sendBatteryLevelChangedIntentLocked();
        }
        // Update the battery LED
        mLed.updateLightsLocked();
        // This needs to be done after sendIntent() so that we get the lastest battery stats.
        if (logOutlier && dischargeDuration != 0) {
            logOutlierLocked(dischargeDuration);
        }
        mLastBatteryStatus = mHealthInfo.batteryStatus;
        mLastBatteryHealth = mHealthInfo.batteryHealth;
        mLastBatteryPresent = mHealthInfo.batteryPresent;
        mLastBatteryLevel = mHealthInfo.batteryLevel;
        mLastPlugType = mPlugType;
        mLastBatteryVoltage = mHealthInfo.batteryVoltage;
        mLastBatteryTemperature = mHealthInfo.batteryTemperature;
        mLastMaxChargingCurrent = mHealthInfo.maxChargingCurrent;
        mLastMaxChargingVoltage = mHealthInfo.maxChargingVoltage;
        mLastChargeCounter = mHealthInfo.batteryChargeCounter;
        mLastBatteryLevelCritical = mBatteryLevelCritical;
        mLastInvalidCharger = mInvalidCharger;
        final int maxChargingMicroWatt;
        if (mLastMaxChargingVoltage <= 0) {
            mLastMaxChargingVoltage = DEFAULT_CHARGING_VOLTAGE_MICRO_VOLT;
        }
        if (mLastMaxChargingCurrent > 0) {
            // Calculating muW = muA * muV / (10^6 mu^2 / mu); splitting up the divisor
            // to maintain precision equally on both factors.
            maxChargingMicroWatt = (mLastMaxChargingCurrent / 1000) * (mLastMaxChargingVoltage / 1000);
        } else {
            maxChargingMicroWatt = -1;
        }
        if (DEBUG) {
            Slog.d(TAG, "mLastMaxChargingCurrent = " + mLastMaxChargingCurrent + " mLastMaxChargingVoltage = " + mLastMaxChargingVoltage + " maxChargingMicroWatt = " + maxChargingMicroWatt);
        }
        if (mFastChargingLedSupported) {
            // Update the Fast battery LED
            mLed.fastCharge(maxChargingMicroWatt);
        }
    }
}
#end_block

#method_before
protected void fastCharge(int mWatt) {
    mIsFastCharging = mWatt > mFastThreshold;
    updateLightsLocked();
}
#method_after
protected void fastCharge(int maxChargingMicroWatt) {
    mIsFastCharging = maxChargingMicroWatt > FAST_CHARGING_ENABLED_THRESHOLD;
    if (DEBUG) {
        Slog.d(TAG, "mIsFastCharging = " + mIsFastCharging);
    }
    updateLightsLocked();
}
#end_block

#method_before
@Override
public void onChange(boolean selfChange) {
    int adbPort = Settings.Secure.getInt(mContentResolver, Settings.Secure.OMNI_ADB_PORT, 0);
    // setting this will control whether ADB runs on TCP/IP or USB
    SystemProperties.set("service.adb.tcp.port", Integer.toString(adbPort));
}
#method_after
@Override
public void onChange(boolean selfChange) {
    try {
        int adbPort = Settings.Global.getInt(mContentResolver, Settings.Global.OMNI_ADB_PORT, 0);
        // setting this will control whether ADB runs on TCP/IP or USB
        SystemProperties.set("service.adb.tcp.port", Integer.toString(adbPort));
    } catch (Exception e) {
        Slog.e(TAG, "", e);
    }
}
#end_block

#method_before
private void run() {
    try {
        traceBeginAndSlog("InitBeforeStartServices");
        // hope that time from cell towers or NTP fixes it shortly.
        if (System.currentTimeMillis() < EARLIEST_SUPPORTED_TIME) {
            Slog.w(TAG, "System clock is before 1970; setting to 1970.");
            SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);
        }
        // 
        // Default the timezone property to GMT if not set.
        // 
        String timezoneProperty = SystemProperties.get("persist.sys.timezone");
        if (timezoneProperty == null || timezoneProperty.isEmpty()) {
            Slog.w(TAG, "Timezone not set; setting to GMT.");
            SystemProperties.set("persist.sys.timezone", "GMT");
        }
        // core/jni/AndroidRuntime.cpp
        if (!SystemProperties.get("persist.sys.language").isEmpty()) {
            final String languageTag = Locale.getDefault().toLanguageTag();
            SystemProperties.set("persist.sys.locale", languageTag);
            SystemProperties.set("persist.sys.language", "");
            SystemProperties.set("persist.sys.country", "");
            SystemProperties.set("persist.sys.localevar", "");
        }
        // The system server should never make non-oneway calls
        Binder.setWarnOnBlocking(true);
        // The system server should always load safe labels
        PackageItemInfo.setForceSafeLabels(true);
        // Deactivate SQLiteCompatibilityWalFlags until settings provider is initialized
        SQLiteCompatibilityWalFlags.init(null);
        // Here we go!
        Slog.i(TAG, "Entered the Android system server!");
        int uptimeMillis = (int) SystemClock.elapsedRealtime();
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, uptimeMillis);
        if (!mRuntimeRestart) {
            MetricsLogger.histogram(null, "boot_system_server_init", uptimeMillis);
        }
        // In case the runtime switched since last boot (such as when
        // the old runtime was removed in an OTA), set the system
        // property so that it is in sync. We can | xq oqi't do this in
        // libnativehelper's JniInvocation::Init code where we already
        // had to fallback to a different runtime because it is
        // running as root and we need to be the system user to set
        // the property. http://b/11463182
        SystemProperties.set("persist.sys.dalvik.vm.lib.2", VMRuntime.getRuntime().vmLibrary());
        // Mmmmmm... more memory!
        VMRuntime.getRuntime().clearGrowthLimit();
        // The system server has to run all of the time, so it needs to be
        // as efficient as possible with its memory usage.
        VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);
        // Some devices rely on runtime fingerprint generation, so make sure
        // we've defined it before booting further.
        Build.ensureFingerprintProperty();
        // Within the system server, it is an error to access Environment paths without
        // explicitly specifying a user.
        Environment.setUserRequired(true);
        // Within the system server, any incoming Bundles should be defused
        // to avoid throwing BadParcelableException.
        BaseBundle.setShouldDefuse(true);
        // Within the system server, when parceling exceptions, include the stack trace
        Parcel.setStackTraceParceling(true);
        // Ensure binder calls into the system always run at foreground priority.
        BinderInternal.disableBackgroundScheduling(true);
        // Increase the number of binder threads in system_server
        BinderInternal.setMaxThreads(sMaxBinderThreads);
        // Prepare the main looper thread (this thread).
        android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND);
        android.os.Process.setCanSelfBackground(false);
        Looper.prepareMainLooper();
        Looper.getMainLooper().setSlowLogThresholdMs(SLOW_DISPATCH_THRESHOLD_MS, SLOW_DELIVERY_THRESHOLD_MS);
        // Initialize native services.
        System.loadLibrary("android_servers");
        // Check whether we failed to shut down last time we tried.
        // This call may not return.
        performPendingShutdown();
        // Initialize the system context.
        createSystemContext();
        // Create the system service manager.
        mSystemServiceManager = new SystemServiceManager(mSystemContext);
        mSystemServiceManager.setStartInfo(mRuntimeRestart, mRuntimeStartElapsedTime, mRuntimeStartUptime);
        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);
        // Prepare the thread pool for init tasks that can be parallelized
        SystemServerInitThreadPool.get();
    } finally {
        // InitBeforeStartServices
        traceEnd();
    }
    // Start services.
    try {
        traceBeginAndSlog("StartServices");
        startBootstrapServices();
        startCoreServices();
        startOtherServices();
        SystemServerInitThreadPool.shutdown();
    } catch (Throwable ex) {
        Slog.e("System", "******************************************");
        Slog.e("System", "************ Failure starting system services", ex);
        throw ex;
    } finally {
        traceEnd();
    }
    StrictMode.initVmDefaults(null);
    if (!mRuntimeRestart && !isFirstBootOrUpgrade()) {
        int uptimeMillis = (int) SystemClock.elapsedRealtime();
        MetricsLogger.histogram(null, "boot_system_server_ready", uptimeMillis);
        final int MAX_UPTIME_MILLIS = 60 * 1000;
        if (uptimeMillis > MAX_UPTIME_MILLIS) {
            Slog.wtf(SYSTEM_SERVER_TIMING_TAG, "SystemServer init took too long. uptimeMillis=" + uptimeMillis);
        }
    }
    // Loop forever.
    Looper.loop();
    throw new RuntimeException("Main thread loop unexpectedly exited");
}
#method_after
private void run() {
    try {
        traceBeginAndSlog("InitBeforeStartServices");
        // hope that time from cell towers or NTP fixes it shortly.
        if (System.currentTimeMillis() < EARLIEST_SUPPORTED_TIME) {
            Slog.w(TAG, "System clock is before 1970; setting to 1970.");
            SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);
        }
        // 
        // Default the timezone property to GMT if not set.
        // 
        String timezoneProperty = SystemProperties.get("persist.sys.timezone");
        if (timezoneProperty == null || timezoneProperty.isEmpty()) {
            Slog.w(TAG, "Timezone not set; setting to GMT.");
            SystemProperties.set("persist.sys.timezone", "GMT");
        }
        // core/jni/AndroidRuntime.cpp
        if (!SystemProperties.get("persist.sys.language").isEmpty()) {
            final String languageTag = Locale.getDefault().toLanguageTag();
            SystemProperties.set("persist.sys.locale", languageTag);
            SystemProperties.set("persist.sys.language", "");
            SystemProperties.set("persist.sys.country", "");
            SystemProperties.set("persist.sys.localevar", "");
        }
        // The system server should never make non-oneway calls
        Binder.setWarnOnBlocking(true);
        // The system server should always load safe labels
        PackageItemInfo.setForceSafeLabels(true);
        // Deactivate SQLiteCompatibilityWalFlags until settings provider is initialized
        SQLiteCompatibilityWalFlags.init(null);
        // Here we go!
        Slog.i(TAG, "Entered the Android system server!");
        int uptimeMillis = (int) SystemClock.elapsedRealtime();
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, uptimeMillis);
        if (!mRuntimeRestart) {
            MetricsLogger.histogram(null, "boot_system_server_init", uptimeMillis);
        }
        // In case the runtime switched since last boot (such as when
        // the old runtime was removed in an OTA), set the system
        // property so that it is in sync. We can | xq oqi't do this in
        // libnativehelper's JniInvocation::Init code where we already
        // had to fallback to a different runtime because it is
        // running as root and we need to be the system user to set
        // the property. http://b/11463182
        SystemProperties.set("persist.sys.dalvik.vm.lib.2", VMRuntime.getRuntime().vmLibrary());
        // Mmmmmm... more memory!
        VMRuntime.getRuntime().clearGrowthLimit();
        // The system server has to run all of the time, so it needs to be
        // as efficient as possible with its memory usage.
        VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);
        // Some devices rely on runtime fingerprint generation, so make sure
        // we've defined it before booting further.
        Build.ensureFingerprintProperty();
        // Within the system server, it is an error to access Environment paths without
        // explicitly specifying a user.
        Environment.setUserRequired(true);
        // Within the system server, any incoming Bundles should be defused
        // to avoid throwing BadParcelableException.
        BaseBundle.setShouldDefuse(true);
        // Within the system server, when parceling exceptions, include the stack trace
        Parcel.setStackTraceParceling(true);
        // Ensure binder calls into the system always run at foreground priority.
        BinderInternal.disableBackgroundScheduling(true);
        // Increase the number of binder threads in system_server
        BinderInternal.setMaxThreads(sMaxBinderThreads);
        // Prepare the main looper thread (this thread).
        android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND);
        android.os.Process.setCanSelfBackground(false);
        Looper.prepareMainLooper();
        Looper.getMainLooper().setSlowLogThresholdMs(SLOW_DISPATCH_THRESHOLD_MS, SLOW_DELIVERY_THRESHOLD_MS);
        // Initialize native services.
        System.loadLibrary("android_servers");
        // Check whether we failed to shut down last time we tried.
        // This call may not return.
        performPendingShutdown();
        // Initialize the system context.
        createSystemContext();
        // Create the system service manager.
        mSystemServiceManager = new SystemServiceManager(mSystemContext);
        mSystemServiceManager.setStartInfo(mRuntimeRestart, mRuntimeStartElapsedTime, mRuntimeStartUptime);
        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);
        // Prepare the thread pool for init tasks that can be parallelized
        SystemServerInitThreadPool.get();
    } finally {
        // InitBeforeStartServices
        traceEnd();
    }
    // Start services.
    try {
        traceBeginAndSlog("StartServices");
        startBootstrapServices();
        startCoreServices();
        startOtherServices();
        startOmniAdditions();
        SystemServerInitThreadPool.shutdown();
    } catch (Throwable ex) {
        Slog.e("System", "******************************************");
        Slog.e("System", "************ Failure starting system services", ex);
        throw ex;
    } finally {
        traceEnd();
    }
    StrictMode.initVmDefaults(null);
    if (!mRuntimeRestart && !isFirstBootOrUpgrade()) {
        int uptimeMillis = (int) SystemClock.elapsedRealtime();
        MetricsLogger.histogram(null, "boot_system_server_ready", uptimeMillis);
        final int MAX_UPTIME_MILLIS = 60 * 1000;
        if (uptimeMillis > MAX_UPTIME_MILLIS) {
            Slog.wtf(SYSTEM_SERVER_TIMING_TAG, "SystemServer init took too long. uptimeMillis=" + uptimeMillis);
        }
    }
    // Loop forever.
    Looper.loop();
    throw new RuntimeException("Main thread loop unexpectedly exited");
}
#end_block

#method_before
private void startOtherServices() {
    final Context context = mSystemContext;
    VibratorService vibrator = null;
    IStorageManager storageManager = null;
    NetworkManagementService networkManagement = null;
    IpSecService ipSecService = null;
    NetworkStatsService networkStats = null;
    NetworkPolicyManagerService networkPolicy = null;
    ConnectivityService connectivity = null;
    NsdService serviceDiscovery = null;
    WindowManagerService wm = null;
    SerialService serial = null;
    NetworkTimeUpdateService networkTimeUpdater = null;
    CommonTimeManagementService commonTimeMgmtService = null;
    InputManagerService inputManager = null;
    TelephonyRegistry telephonyRegistry = null;
    ConsumerIrService consumerIr = null;
    MmsServiceBroker mmsService = null;
    HardwarePropertiesManagerService hardwarePropertiesService = null;
    boolean disableSystemTextClassifier = SystemProperties.getBoolean("config.disable_systemtextclassifier", false);
    boolean disableCameraService = SystemProperties.getBoolean("config.disable_cameraservice", false);
    boolean disableSlices = SystemProperties.getBoolean("config.disable_slices", false);
    boolean enableLeftyService = SystemProperties.getBoolean("config.enable_lefty", false);
    boolean isEmulator = SystemProperties.get("ro.kernel.qemu").equals("1");
    boolean isWatch = context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH);
    // For debugging RescueParty
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean("debug.crash_system", false)) {
        throw new RuntimeException();
    }
    try {
        final String SECONDARY_ZYGOTE_PRELOAD = "SecondaryZygotePreload";
        // We start the preload ~1s before the webview factory preparation, to
        // ensure that it completes before the 32 bit relro process is forked
        // from the zygote. In the event that it takes too long, the webview
        // RELRO process will block, but it will do so without holding any locks.
        mZygotePreload = SystemServerInitThreadPool.get().submit(() -> {
            try {
                Slog.i(TAG, SECONDARY_ZYGOTE_PRELOAD);
                TimingsTraceLog traceLog = new TimingsTraceLog(SYSTEM_SERVER_TIMING_ASYNC_TAG, Trace.TRACE_TAG_SYSTEM_SERVER);
                traceLog.traceBegin(SECONDARY_ZYGOTE_PRELOAD);
                if (!Process.zygoteProcess.preloadDefault(Build.SUPPORTED_32_BIT_ABIS[0])) {
                    Slog.e(TAG, "Unable to preload default resources");
                }
                traceLog.traceEnd();
            } catch (Exception ex) {
                Slog.e(TAG, "Exception preloading default resources", ex);
            }
        }, SECONDARY_ZYGOTE_PRELOAD);
        traceBeginAndSlog("StartKeyAttestationApplicationIdProviderService");
        ServiceManager.addService("sec_key_att_app_id_provider", new KeyAttestationApplicationIdProviderService(context));
        traceEnd();
        traceBeginAndSlog("StartKeyChainSystemService");
        mSystemServiceManager.startService(KeyChainSystemService.class);
        traceEnd();
        traceBeginAndSlog("StartSchedulingPolicyService");
        ServiceManager.addService("scheduling_policy", new SchedulingPolicyService());
        traceEnd();
        traceBeginAndSlog("StartTelecomLoaderService");
        mSystemServiceManager.startService(TelecomLoaderService.class);
        traceEnd();
        traceBeginAndSlog("StartTelephonyRegistry");
        telephonyRegistry = new TelephonyRegistry(context);
        ServiceManager.addService("telephony.registry", telephonyRegistry);
        traceEnd();
        traceBeginAndSlog("StartEntropyMixer");
        mEntropyMixer = new EntropyMixer(context);
        traceEnd();
        mContentResolver = context.getContentResolver();
        // The AccountManager must come before the ContentService
        traceBeginAndSlog("StartAccountManagerService");
        mSystemServiceManager.startService(ACCOUNT_SERVICE_CLASS);
        traceEnd();
        traceBeginAndSlog("StartContentService");
        mSystemServiceManager.startService(CONTENT_SERVICE_CLASS);
        traceEnd();
        traceBeginAndSlog("InstallSystemProviders");
        mActivityManagerService.installSystemProviders();
        // Now that SettingsProvider is ready, reactivate SQLiteCompatibilityWalFlags
        SQLiteCompatibilityWalFlags.reset();
        traceEnd();
        // Records errors and logs, for example wtf()
        // Currently this service indirectly depends on SettingsProvider so do this after
        // InstallSystemProviders.
        traceBeginAndSlog("StartDropBoxManager");
        mSystemServiceManager.startService(DropBoxManagerService.class);
        traceEnd();
        traceBeginAndSlog("StartVibratorService");
        vibrator = new VibratorService(context);
        ServiceManager.addService("vibrator", vibrator);
        traceEnd();
        if (!isWatch) {
            traceBeginAndSlog("StartConsumerIrService");
            consumerIr = new ConsumerIrService(context);
            ServiceManager.addService(Context.CONSUMER_IR_SERVICE, consumerIr);
            traceEnd();
        }
        traceBeginAndSlog("StartAlarmManagerService");
        mSystemServiceManager.startService(AlarmManagerService.class);
        traceEnd();
        traceBeginAndSlog("InitWatchdog");
        final Watchdog watchdog = Watchdog.getInstance();
        watchdog.init(context, mActivityManagerService);
        traceEnd();
        traceBeginAndSlog("StartInputManagerService");
        inputManager = new InputManagerService(context);
        traceEnd();
        traceBeginAndSlog("StartWindowManagerService");
        // WMS needs sensor service ready
        ConcurrentUtils.waitForFutureNoInterrupt(mSensorServiceStart, START_SENSOR_SERVICE);
        mSensorServiceStart = null;
        wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, !mFirstBoot, mOnlyCore, new PhoneWindowManager());
        ServiceManager.addService(Context.WINDOW_SERVICE, wm, /* allowIsolated= */
        false, DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PROTO);
        ServiceManager.addService(Context.INPUT_SERVICE, inputManager, /* allowIsolated= */
        false, DUMP_FLAG_PRIORITY_CRITICAL);
        traceEnd();
        traceBeginAndSlog("SetWindowManagerService");
        mActivityManagerService.setWindowManager(wm);
        traceEnd();
        traceBeginAndSlog("WindowManagerServiceOnInitReady");
        wm.onInitReady();
        traceEnd();
        // Start receiving calls from HIDL services. Start in in a separate thread
        // because it need to connect to SensorManager. This have to start
        // after START_SENSOR_SERVICE is done.
        SystemServerInitThreadPool.get().submit(() -> {
            TimingsTraceLog traceLog = new TimingsTraceLog(SYSTEM_SERVER_TIMING_ASYNC_TAG, Trace.TRACE_TAG_SYSTEM_SERVER);
            traceLog.traceBegin(START_HIDL_SERVICES);
            startHidlServices();
            traceLog.traceEnd();
        }, START_HIDL_SERVICES);
        if (!isWatch) {
            traceBeginAndSlog("StartVrManagerService");
            mSystemServiceManager.startService(VrManagerService.class);
            traceEnd();
        }
        traceBeginAndSlog("StartInputManager");
        inputManager.setWindowManagerCallbacks(wm.getInputMonitor());
        inputManager.start();
        traceEnd();
        // TODO: Use service dependencies instead.
        traceBeginAndSlog("DisplayManagerWindowManagerAndInputReady");
        mDisplayManagerService.windowManagerAndInputReady();
        traceEnd();
        // support Bluetooth - see bug 988521
        if (isEmulator) {
            Slog.i(TAG, "No Bluetooth Service (emulator)");
        } else if (mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            Slog.i(TAG, "No Bluetooth Service (factory test)");
        } else if (!context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)) {
            Slog.i(TAG, "No Bluetooth Service (Bluetooth Hardware Not Present)");
        } else {
            traceBeginAndSlog("StartBluetoothService");
            mSystemServiceManager.startService(BluetoothService.class);
            traceEnd();
        }
        traceBeginAndSlog("IpConnectivityMetrics");
        mSystemServiceManager.startService(IpConnectivityMetrics.class);
        traceEnd();
        traceBeginAndSlog("NetworkWatchlistService");
        mSystemServiceManager.startService(NetworkWatchlistService.Lifecycle.class);
        traceEnd();
        traceBeginAndSlog("PinnerService");
        mSystemServiceManager.startService(PinnerService.class);
        traceEnd();
    } catch (RuntimeException e) {
        Slog.e("System", "******************************************");
        Slog.e("System", "************ Failure starting core service", e);
    }
    StatusBarManagerService statusBar = null;
    INotificationManager notification = null;
    LocationManagerService location = null;
    CountryDetectorService countryDetector = null;
    ILockSettings lockSettings = null;
    MediaRouterService mediaRouter = null;
    // Bring up services needed for UI.
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        traceBeginAndSlog("StartInputMethodManagerLifecycle");
        mSystemServiceManager.startService(InputMethodManagerService.Lifecycle.class);
        traceEnd();
        traceBeginAndSlog("StartAccessibilityManagerService");
        try {
            ServiceManager.addService(Context.ACCESSIBILITY_SERVICE, new AccessibilityManagerService(context));
        } catch (Throwable e) {
            reportWtf("starting Accessibility Manager", e);
        }
        traceEnd();
    }
    traceBeginAndSlog("MakeDisplayReady");
    try {
        wm.displayReady();
    } catch (Throwable e) {
        reportWtf("making display ready", e);
    }
    traceEnd();
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        if (!"0".equals(SystemProperties.get("system_init.startmountservice"))) {
            traceBeginAndSlog("StartStorageManagerService");
            try {
                /*
                     * NotificationManagerService is dependant on StorageManagerService,
                     * (for media / usb notifications) so we must start StorageManagerService first.
                     */
                mSystemServiceManager.startService(STORAGE_MANAGER_SERVICE_CLASS);
                storageManager = IStorageManager.Stub.asInterface(ServiceManager.getService("mount"));
            } catch (Throwable e) {
                reportWtf("starting StorageManagerService", e);
            }
            traceEnd();
            traceBeginAndSlog("StartStorageStatsService");
            try {
                mSystemServiceManager.startService(STORAGE_STATS_SERVICE_CLASS);
            } catch (Throwable e) {
                reportWtf("starting StorageStatsService", e);
            }
            traceEnd();
        }
    }
    // We start this here so that we update our configuration to set watch or television
    // as appropriate.
    traceBeginAndSlog("StartUiModeManager");
    mSystemServiceManager.startService(UiModeManagerService.class);
    traceEnd();
    if (!mOnlyCore) {
        traceBeginAndSlog("UpdatePackagesIfNeeded");
        try {
            mPackageManagerService.updatePackagesIfNeeded();
        } catch (Throwable e) {
            reportWtf("update packages", e);
        }
        traceEnd();
    }
    traceBeginAndSlog("PerformFstrimIfNeeded");
    try {
        mPackageManagerService.performFstrimIfNeeded();
    } catch (Throwable e) {
        reportWtf("performing fstrim", e);
    }
    traceEnd();
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        traceBeginAndSlog("StartLockSettingsService");
        try {
            mSystemServiceManager.startService(LOCK_SETTINGS_SERVICE_CLASS);
            lockSettings = ILockSettings.Stub.asInterface(ServiceManager.getService("lock_settings"));
        } catch (Throwable e) {
            reportWtf("starting LockSettingsService service", e);
        }
        traceEnd();
        final boolean hasPdb = !SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP).equals("");
        if (hasPdb) {
            traceBeginAndSlog("StartPersistentDataBlock");
            mSystemServiceManager.startService(PersistentDataBlockService.class);
            traceEnd();
        }
        if (hasPdb || OemLockService.isHalPresent()) {
            // Implementation depends on pdb or the OemLock HAL
            traceBeginAndSlog("StartOemLockService");
            mSystemServiceManager.startService(OemLockService.class);
            traceEnd();
        }
        traceBeginAndSlog("StartDeviceIdleController");
        mSystemServiceManager.startService(DeviceIdleController.class);
        traceEnd();
        // Always start the Device Policy Manager, so that the API is compatible with
        // API8.
        traceBeginAndSlog("StartDevicePolicyManager");
        mSystemServiceManager.startService(DevicePolicyManagerService.Lifecycle.class);
        traceEnd();
        if (!isWatch) {
            traceBeginAndSlog("StartStatusBarManagerService");
            try {
                statusBar = new StatusBarManagerService(context, wm);
                ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);
            } catch (Throwable e) {
                reportWtf("starting StatusBarManagerService", e);
            }
            traceEnd();
        }
        traceBeginAndSlog("StartClipboardService");
        mSystemServiceManager.startService(ClipboardService.class);
        traceEnd();
        traceBeginAndSlog("StartNetworkManagementService");
        try {
            networkManagement = NetworkManagementService.create(context);
            ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);
        } catch (Throwable e) {
            reportWtf("starting NetworkManagement Service", e);
        }
        traceEnd();
        traceBeginAndSlog("StartIpSecService");
        try {
            ipSecService = IpSecService.create(context);
            ServiceManager.addService(Context.IPSEC_SERVICE, ipSecService);
        } catch (Throwable e) {
            reportWtf("starting IpSec Service", e);
        }
        traceEnd();
        traceBeginAndSlog("StartTextServicesManager");
        mSystemServiceManager.startService(TextServicesManagerService.Lifecycle.class);
        traceEnd();
        if (!disableSystemTextClassifier) {
            traceBeginAndSlog("StartTextClassificationManagerService");
            mSystemServiceManager.startService(TextClassificationManagerService.Lifecycle.class);
            traceEnd();
        }
        traceBeginAndSlog("StartNetworkScoreService");
        mSystemServiceManager.startService(NetworkScoreService.Lifecycle.class);
        traceEnd();
        traceBeginAndSlog("StartNetworkStatsService");
        try {
            networkStats = NetworkStatsService.create(context, networkManagement);
            ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats);
        } catch (Throwable e) {
            reportWtf("starting NetworkStats Service", e);
        }
        traceEnd();
        traceBeginAndSlog("StartNetworkPolicyManagerService");
        try {
            networkPolicy = new NetworkPolicyManagerService(context, mActivityManagerService, networkManagement);
            ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy);
        } catch (Throwable e) {
            reportWtf("starting NetworkPolicy Service", e);
        }
        traceEnd();
        if (!mOnlyCore) {
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI)) {
                // Wifi Service must be started first for wifi-related services.
                traceBeginAndSlog("StartWifi");
                mSystemServiceManager.startService(WIFI_SERVICE_CLASS);
                traceEnd();
                traceBeginAndSlog("StartWifiScanning");
                mSystemServiceManager.startService("com.android.server.wifi.scanner.WifiScanningService");
                traceEnd();
            }
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_RTT)) {
                traceBeginAndSlog("StartRttService");
                mSystemServiceManager.startService("com.android.server.wifi.rtt.RttService");
                traceEnd();
            }
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_AWARE)) {
                traceBeginAndSlog("StartWifiAware");
                mSystemServiceManager.startService(WIFI_AWARE_SERVICE_CLASS);
                traceEnd();
            }
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_DIRECT)) {
                traceBeginAndSlog("StartWifiP2P");
                mSystemServiceManager.startService(WIFI_P2P_SERVICE_CLASS);
                traceEnd();
            }
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOWPAN)) {
                traceBeginAndSlog("StartLowpan");
                mSystemServiceManager.startService(LOWPAN_SERVICE_CLASS);
                traceEnd();
            }
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_ETHERNET) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) {
            traceBeginAndSlog("StartEthernet");
            mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS);
            traceEnd();
        }
        traceBeginAndSlog("StartConnectivityService");
        try {
            connectivity = new ConnectivityService(context, networkManagement, networkStats, networkPolicy);
            ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity, /* allowIsolated= */
            false, DUMP_FLAG_PRIORITY_HIGH | DUMP_FLAG_PRIORITY_NORMAL);
            networkStats.bindConnectivityManager(connectivity);
            networkPolicy.bindConnectivityManager(connectivity);
        } catch (Throwable e) {
            reportWtf("starting Connectivity Service", e);
        }
        traceEnd();
        traceBeginAndSlog("StartNsdService");
        try {
            serviceDiscovery = NsdService.create(context);
            ServiceManager.addService(Context.NSD_SERVICE, serviceDiscovery);
        } catch (Throwable e) {
            reportWtf("starting Service Discovery Service", e);
        }
        traceEnd();
        traceBeginAndSlog("StartSystemUpdateManagerService");
        try {
            ServiceManager.addService(Context.SYSTEM_UPDATE_SERVICE, new SystemUpdateManagerService(context));
        } catch (Throwable e) {
            reportWtf("starting SystemUpdateManagerService", e);
        }
        traceEnd();
        traceBeginAndSlog("StartUpdateLockService");
        try {
            ServiceManager.addService(Context.UPDATE_LOCK_SERVICE, new UpdateLockService(context));
        } catch (Throwable e) {
            reportWtf("starting UpdateLockService", e);
        }
        traceEnd();
        traceBeginAndSlog("StartNotificationManager");
        mSystemServiceManager.startService(NotificationManagerService.class);
        SystemNotificationChannels.createAll(context);
        notification = INotificationManager.Stub.asInterface(ServiceManager.getService(Context.NOTIFICATION_SERVICE));
        traceEnd();
        traceBeginAndSlog("StartDeviceMonitor");
        mSystemServiceManager.startService(DeviceStorageMonitorService.class);
        traceEnd();
        traceBeginAndSlog("StartLocationManagerService");
        try {
            location = new LocationManagerService(context);
            ServiceManager.addService(Context.LOCATION_SERVICE, location);
        } catch (Throwable e) {
            reportWtf("starting Location Manager", e);
        }
        traceEnd();
        traceBeginAndSlog("StartCountryDetectorService");
        try {
            countryDetector = new CountryDetectorService(context);
            ServiceManager.addService(Context.COUNTRY_DETECTOR, countryDetector);
        } catch (Throwable e) {
            reportWtf("starting Country Detector", e);
        }
        traceEnd();
        if (!isWatch) {
            traceBeginAndSlog("StartSearchManagerService");
            try {
                mSystemServiceManager.startService(SEARCH_MANAGER_SERVICE_CLASS);
            } catch (Throwable e) {
                reportWtf("starting Search Service", e);
            }
            traceEnd();
        }
        if (context.getResources().getBoolean(R.bool.config_enableWallpaperService)) {
            traceBeginAndSlog("StartWallpaperManagerService");
            mSystemServiceManager.startService(WALLPAPER_SERVICE_CLASS);
            traceEnd();
        }
        traceBeginAndSlog("StartAudioService");
        mSystemServiceManager.startService(AudioService.Lifecycle.class);
        traceEnd();
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_BROADCAST_RADIO)) {
            traceBeginAndSlog("StartBroadcastRadioService");
            mSystemServiceManager.startService(BroadcastRadioService.class);
            traceEnd();
        }
        traceBeginAndSlog("StartDockObserver");
        mSystemServiceManager.startService(DockObserver.class);
        traceEnd();
        if (isWatch) {
            traceBeginAndSlog("StartThermalObserver");
            mSystemServiceManager.startService(THERMAL_OBSERVER_CLASS);
            traceEnd();
        }
        traceBeginAndSlog("StartWiredAccessoryManager");
        try {
            // Listen for wired headset changes
            inputManager.setWiredAccessoryCallbacks(new WiredAccessoryManager(context, inputManager));
        } catch (Throwable e) {
            reportWtf("starting WiredAccessoryManager", e);
        }
        traceEnd();
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_MIDI)) {
            // Start MIDI Manager service
            traceBeginAndSlog("StartMidiManager");
            mSystemServiceManager.startService(MIDI_SERVICE_CLASS);
            traceEnd();
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY) || isEmulator) {
            // Manage USB host and device support
            traceBeginAndSlog("StartUsbService");
            mSystemServiceManager.startService(USB_SERVICE_CLASS);
            traceEnd();
        }
        if (!isWatch) {
            traceBeginAndSlog("StartSerialService");
            try {
                // Serial port support
                serial = new SerialService(context);
                ServiceManager.addService(Context.SERIAL_SERVICE, serial);
            } catch (Throwable e) {
                Slog.e(TAG, "Failure starting SerialService", e);
            }
            traceEnd();
        }
        traceBeginAndSlog("StartHardwarePropertiesManagerService");
        try {
            hardwarePropertiesService = new HardwarePropertiesManagerService(context);
            ServiceManager.addService(Context.HARDWARE_PROPERTIES_SERVICE, hardwarePropertiesService);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting HardwarePropertiesManagerService", e);
        }
        traceEnd();
        traceBeginAndSlog("StartTwilightService");
        mSystemServiceManager.startService(TwilightService.class);
        traceEnd();
        if (ColorDisplayController.isAvailable(context)) {
            traceBeginAndSlog("StartNightDisplay");
            mSystemServiceManager.startService(ColorDisplayService.class);
            traceEnd();
        }
        traceBeginAndSlog("StartJobScheduler");
        mSystemServiceManager.startService(JobSchedulerService.class);
        traceEnd();
        traceBeginAndSlog("StartSoundTrigger");
        mSystemServiceManager.startService(SoundTriggerService.class);
        traceEnd();
        traceBeginAndSlog("StartTrustManager");
        mSystemServiceManager.startService(TrustManagerService.class);
        traceEnd();
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_BACKUP)) {
            traceBeginAndSlog("StartBackupManager");
            mSystemServiceManager.startService(BACKUP_MANAGER_SERVICE_CLASS);
            traceEnd();
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS) || context.getResources().getBoolean(R.bool.config_enableAppWidgetService)) {
            traceBeginAndSlog("StartAppWidgerService");
            mSystemServiceManager.startService(APPWIDGET_SERVICE_CLASS);
            traceEnd();
        }
        // We need to always start this service, regardless of whether the
        // FEATURE_VOICE_RECOGNIZERS feature is set, because it needs to take care
        // of initializing various settings.  It will internally modify its behavior
        // based on that feature.
        traceBeginAndSlog("StartVoiceRecognitionManager");
        mSystemServiceManager.startService(VOICE_RECOGNITION_MANAGER_SERVICE_CLASS);
        traceEnd();
        if (GestureLauncherService.isGestureLauncherEnabled(context.getResources())) {
            traceBeginAndSlog("StartGestureLauncher");
            mSystemServiceManager.startService(GestureLauncherService.class);
            traceEnd();
        }
        traceBeginAndSlog("StartSensorNotification");
        mSystemServiceManager.startService(SensorNotificationService.class);
        traceEnd();
        traceBeginAndSlog("StartContextHubSystemService");
        mSystemServiceManager.startService(ContextHubSystemService.class);
        traceEnd();
        traceBeginAndSlog("StartDiskStatsService");
        try {
            ServiceManager.addService("diskstats", new DiskStatsService(context));
        } catch (Throwable e) {
            reportWtf("starting DiskStats Service", e);
        }
        traceEnd();
        // timezone.RulesManagerService will prevent a device starting up if the chain of trust
        // required for safe time zone updates might be broken. RuleManagerService cannot do
        // this check when mOnlyCore == true, so we don't enable the service in this case.
        // This service requires that JobSchedulerService is already started when it starts.
        final boolean startRulesManagerService = !mOnlyCore && context.getResources().getBoolean(R.bool.config_enableUpdateableTimeZoneRules);
        if (startRulesManagerService) {
            traceBeginAndSlog("StartTimeZoneRulesManagerService");
            mSystemServiceManager.startService(TIME_ZONE_RULES_MANAGER_SERVICE_CLASS);
            traceEnd();
        }
        if (!isWatch) {
            traceBeginAndSlog("StartNetworkTimeUpdateService");
            try {
                networkTimeUpdater = new NetworkTimeUpdateService(context);
                ServiceManager.addService("network_time_update_service", networkTimeUpdater);
            } catch (Throwable e) {
                reportWtf("starting NetworkTimeUpdate service", e);
            }
            traceEnd();
        }
        traceBeginAndSlog("StartCommonTimeManagementService");
        try {
            commonTimeMgmtService = new CommonTimeManagementService(context);
            ServiceManager.addService("commontime_management", commonTimeMgmtService);
        } catch (Throwable e) {
            reportWtf("starting CommonTimeManagementService service", e);
        }
        traceEnd();
        traceBeginAndSlog("CertBlacklister");
        try {
            CertBlacklister blacklister = new CertBlacklister(context);
        } catch (Throwable e) {
            reportWtf("starting CertBlacklister", e);
        }
        traceEnd();
        if (EmergencyAffordanceManager.ENABLED) {
            // EmergencyMode service
            traceBeginAndSlog("StartEmergencyAffordanceService");
            mSystemServiceManager.startService(EmergencyAffordanceService.class);
            traceEnd();
        }
        // Dreams (interactive idle-time views, a/k/a screen savers, and doze mode)
        traceBeginAndSlog("StartDreamManager");
        mSystemServiceManager.startService(DreamManagerService.class);
        traceEnd();
        traceBeginAndSlog("AddGraphicsStatsService");
        ServiceManager.addService(GraphicsStatsService.GRAPHICS_STATS_SERVICE, new GraphicsStatsService(context));
        traceEnd();
        if (CoverageService.ENABLED) {
            traceBeginAndSlog("AddCoverageService");
            ServiceManager.addService(CoverageService.COVERAGE_SERVICE, new CoverageService());
            traceEnd();
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PRINTING)) {
            traceBeginAndSlog("StartPrintManager");
            mSystemServiceManager.startService(PRINT_MANAGER_SERVICE_CLASS);
            traceEnd();
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_COMPANION_DEVICE_SETUP)) {
            traceBeginAndSlog("StartCompanionDeviceManager");
            mSystemServiceManager.startService(COMPANION_DEVICE_MANAGER_SERVICE_CLASS);
            traceEnd();
        }
        traceBeginAndSlog("StartRestrictionManager");
        mSystemServiceManager.startService(RestrictionsManagerService.class);
        traceEnd();
        traceBeginAndSlog("StartMediaSessionService");
        mSystemServiceManager.startService(MediaSessionService.class);
        traceEnd();
        traceBeginAndSlog("StartMediaUpdateService");
        mSystemServiceManager.startService(MediaUpdateService.class);
        traceEnd();
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_HDMI_CEC)) {
            traceBeginAndSlog("StartHdmiControlService");
            mSystemServiceManager.startService(HdmiControlService.class);
            traceEnd();
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_LIVE_TV) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {
            traceBeginAndSlog("StartTvInputManager");
            mSystemServiceManager.startService(TvInputManagerService.class);
            traceEnd();
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PICTURE_IN_PICTURE)) {
            traceBeginAndSlog("StartMediaResourceMonitor");
            mSystemServiceManager.startService(MediaResourceMonitorService.class);
            traceEnd();
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {
            traceBeginAndSlog("StartTvRemoteService");
            mSystemServiceManager.startService(TvRemoteService.class);
            traceEnd();
        }
        traceBeginAndSlog("StartMediaRouterService");
        try {
            mediaRouter = new MediaRouterService(context);
            ServiceManager.addService(Context.MEDIA_ROUTER_SERVICE, mediaRouter);
        } catch (Throwable e) {
            reportWtf("starting MediaRouterService", e);
        }
        traceEnd();
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FINGERPRINT)) {
            traceBeginAndSlog("StartFingerprintSensor");
            mSystemServiceManager.startService(FingerprintService.class);
            traceEnd();
        }
        traceBeginAndSlog("StartBackgroundDexOptService");
        try {
            BackgroundDexOptService.schedule(context);
        } catch (Throwable e) {
            reportWtf("starting StartBackgroundDexOptService", e);
        }
        traceEnd();
        traceBeginAndSlog("StartPruneInstantAppsJobService");
        try {
            PruneInstantAppsJobService.schedule(context);
        } catch (Throwable e) {
            reportWtf("StartPruneInstantAppsJobService", e);
        }
        traceEnd();
        // LauncherAppsService uses ShortcutService.
        traceBeginAndSlog("StartShortcutServiceLifecycle");
        mSystemServiceManager.startService(ShortcutService.Lifecycle.class);
        traceEnd();
        traceBeginAndSlog("StartLauncherAppsService");
        mSystemServiceManager.startService(LauncherAppsService.class);
        traceEnd();
        traceBeginAndSlog("StartCrossProfileAppsService");
        mSystemServiceManager.startService(CrossProfileAppsService.class);
        traceEnd();
    }
    if (!isWatch) {
        traceBeginAndSlog("StartMediaProjectionManager");
        mSystemServiceManager.startService(MediaProjectionManagerService.class);
        traceEnd();
    }
    if (isWatch) {
        traceBeginAndSlog("StartWearConfigService");
        mSystemServiceManager.startService(WEAR_CONFIG_SERVICE_CLASS);
        traceEnd();
        traceBeginAndSlog("StartWearConnectivityService");
        mSystemServiceManager.startService(WEAR_CONNECTIVITY_SERVICE_CLASS);
        traceEnd();
        traceBeginAndSlog("StartWearTimeService");
        mSystemServiceManager.startService(WEAR_DISPLAY_SERVICE_CLASS);
        mSystemServiceManager.startService(WEAR_TIME_SERVICE_CLASS);
        traceEnd();
        if (enableLeftyService) {
            traceBeginAndSlog("StartWearLeftyService");
            mSystemServiceManager.startService(WEAR_LEFTY_SERVICE_CLASS);
            traceEnd();
        }
        traceBeginAndSlog("StartWearGlobalActionsService");
        mSystemServiceManager.startService(WEAR_GLOBAL_ACTIONS_SERVICE_CLASS);
        traceEnd();
    }
    if (!disableSlices) {
        traceBeginAndSlog("StartSliceManagerService");
        mSystemServiceManager.startService(SLICE_MANAGER_SERVICE_CLASS);
        traceEnd();
    }
    if (!disableCameraService) {
        traceBeginAndSlog("StartCameraServiceProxy");
        mSystemServiceManager.startService(CameraServiceProxy.class);
        traceEnd();
    }
    if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_EMBEDDED)) {
        traceBeginAndSlog("StartIoTSystemService");
        mSystemServiceManager.startService(IOT_SERVICE_CLASS);
        traceEnd();
    }
    Settings.Secure.putInt(mContentResolver, Settings.Secure.OMNI_ADB_PORT, Integer.parseInt(SystemProperties.get("service.adb.tcp.port", "-1")));
    // register observer to listen for settings changes
    mContentResolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.OMNI_ADB_PORT), false, new AdbPortObserver());
    // Statsd helper
    traceBeginAndSlog("StartStatsCompanionService");
    mSystemServiceManager.startService(StatsCompanionService.Lifecycle.class);
    traceEnd();
    // Before things start rolling, be sure we have decided whether
    // we are in safe mode.
    final boolean safeMode = wm.detectSafeMode();
    if (safeMode) {
        traceBeginAndSlog("EnterSafeModeAndDisableJitCompilation");
        mActivityManagerService.enterSafeMode();
        // Disable the JIT for the system_server process
        VMRuntime.getRuntime().disableJitCompilation();
        traceEnd();
    } else {
        // Enable the JIT for the system_server process
        traceBeginAndSlog("StartJitCompilation");
        VMRuntime.getRuntime().startJitCompilation();
        traceEnd();
    }
    // MMS service broker
    traceBeginAndSlog("StartMmsService");
    mmsService = mSystemServiceManager.startService(MmsServiceBroker.class);
    traceEnd();
    if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_AUTOFILL)) {
        traceBeginAndSlog("StartAutoFillService");
        mSystemServiceManager.startService(AUTO_FILL_MANAGER_SERVICE_CLASS);
        traceEnd();
    }
    // It is now time to start up the app processes...
    traceBeginAndSlog("MakeVibratorServiceReady");
    try {
        vibrator.systemReady();
    } catch (Throwable e) {
        reportWtf("making Vibrator Service ready", e);
    }
    traceEnd();
    traceBeginAndSlog("MakeLockSettingsServiceReady");
    if (lockSettings != null) {
        try {
            lockSettings.systemReady();
        } catch (Throwable e) {
            reportWtf("making Lock Settings Service ready", e);
        }
    }
    traceEnd();
    // Needed by DevicePolicyManager for initialization
    traceBeginAndSlog("StartBootPhaseLockSettingsReady");
    mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);
    traceEnd();
    traceBeginAndSlog("StartBootPhaseSystemServicesReady");
    mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);
    traceEnd();
    traceBeginAndSlog("MakeWindowManagerServiceReady");
    try {
        wm.systemReady();
    } catch (Throwable e) {
        reportWtf("making Window Manager Service ready", e);
    }
    traceEnd();
    if (safeMode) {
        mActivityManagerService.showSafeModeOverlay();
    }
    // Update the configuration for this context by hand, because we're going
    // to start using it before the config change done in wm.systemReady() will
    // propagate to it.
    final Configuration config = wm.computeNewConfiguration(DEFAULT_DISPLAY);
    DisplayMetrics metrics = new DisplayMetrics();
    WindowManager w = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    w.getDefaultDisplay().getMetrics(metrics);
    context.getResources().updateConfiguration(config, metrics);
    // The system context's theme may be configuration-dependent.
    final Theme systemTheme = context.getTheme();
    if (systemTheme.getChangingConfigurations() != 0) {
        systemTheme.rebase();
    }
    traceBeginAndSlog("MakePowerManagerServiceReady");
    try {
        // TODO: use boot phase
        mPowerManagerService.systemReady(mActivityManagerService.getAppOpsService());
    } catch (Throwable e) {
        reportWtf("making Power Manager Service ready", e);
    }
    traceEnd();
    traceBeginAndSlog("MakePackageManagerServiceReady");
    mPackageManagerService.systemReady();
    traceEnd();
    traceBeginAndSlog("MakeDisplayManagerServiceReady");
    try {
        // TODO: use boot phase and communicate these flags some other way
        mDisplayManagerService.systemReady(safeMode, mOnlyCore);
    } catch (Throwable e) {
        reportWtf("making Display Manager Service ready", e);
    }
    traceEnd();
    mSystemServiceManager.setSafeMode(safeMode);
    // Start device specific services
    traceBeginAndSlog("StartDeviceSpecificServices");
    final String[] classes = mSystemContext.getResources().getStringArray(R.array.config_deviceSpecificSystemServices);
    for (final String className : classes) {
        traceBeginAndSlog("StartDeviceSpecificServices " + className);
        try {
            mSystemServiceManager.startService(className);
        } catch (Throwable e) {
            reportWtf("starting " + className, e);
        }
        traceEnd();
    }
    traceEnd();
    traceBeginAndSlog("StartBootPhaseDeviceSpecificServicesReady");
    mSystemServiceManager.startBootPhase(SystemService.PHASE_DEVICE_SPECIFIC_SERVICES_READY);
    traceEnd();
    // These are needed to propagate to the runnable below.
    final NetworkManagementService networkManagementF = networkManagement;
    final NetworkStatsService networkStatsF = networkStats;
    final NetworkPolicyManagerService networkPolicyF = networkPolicy;
    final ConnectivityService connectivityF = connectivity;
    final LocationManagerService locationF = location;
    final CountryDetectorService countryDetectorF = countryDetector;
    final NetworkTimeUpdateService networkTimeUpdaterF = networkTimeUpdater;
    final CommonTimeManagementService commonTimeMgmtServiceF = commonTimeMgmtService;
    final InputManagerService inputManagerF = inputManager;
    final TelephonyRegistry telephonyRegistryF = telephonyRegistry;
    final MediaRouterService mediaRouterF = mediaRouter;
    final MmsServiceBroker mmsServiceF = mmsService;
    final IpSecService ipSecServiceF = ipSecService;
    final WindowManagerService windowManagerF = wm;
    // We now tell the activity manager it is okay to run third party
    // code.  It will call back into us once it has gotten to the state
    // where third party code can really run (but before it has actually
    // started launching the initial applications), for us to complete our
    // initialization.
    mActivityManagerService.systemReady(() -> {
        Slog.i(TAG, "Making services ready");
        traceBeginAndSlog("StartActivityManagerReadyPhase");
        mSystemServiceManager.startBootPhase(SystemService.PHASE_ACTIVITY_MANAGER_READY);
        traceEnd();
        traceBeginAndSlog("StartObservingNativeCrashes");
        try {
            mActivityManagerService.startObservingNativeCrashes();
        } catch (Throwable e) {
            reportWtf("observing native crashes", e);
        }
        traceEnd();
        // No dependency on Webview preparation in system server. But this should
        // be completed before allowing 3rd party
        final String WEBVIEW_PREPARATION = "WebViewFactoryPreparation";
        Future<?> webviewPrep = null;
        if (!mOnlyCore && mWebViewUpdateService != null) {
            webviewPrep = SystemServerInitThreadPool.get().submit(() -> {
                Slog.i(TAG, WEBVIEW_PREPARATION);
                TimingsTraceLog traceLog = new TimingsTraceLog(SYSTEM_SERVER_TIMING_ASYNC_TAG, Trace.TRACE_TAG_SYSTEM_SERVER);
                traceLog.traceBegin(WEBVIEW_PREPARATION);
                ConcurrentUtils.waitForFutureNoInterrupt(mZygotePreload, "Zygote preload");
                mZygotePreload = null;
                mWebViewUpdateService.prepareWebViewInSystemServer();
                traceLog.traceEnd();
            }, WEBVIEW_PREPARATION);
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            traceBeginAndSlog("StartCarServiceHelperService");
            mSystemServiceManager.startService(CAR_SERVICE_HELPER_SERVICE_CLASS);
            traceEnd();
        }
        traceBeginAndSlog("StartSystemUI");
        try {
            startSystemUi(context, windowManagerF);
        } catch (Throwable e) {
            reportWtf("starting System UI", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeNetworkManagementServiceReady");
        try {
            if (networkManagementF != null)
                networkManagementF.systemReady();
        } catch (Throwable e) {
            reportWtf("making Network Managment Service ready", e);
        }
        CountDownLatch networkPolicyInitReadySignal = null;
        if (networkPolicyF != null) {
            networkPolicyInitReadySignal = networkPolicyF.networkScoreAndNetworkManagementServiceReady();
        }
        traceEnd();
        traceBeginAndSlog("MakeIpSecServiceReady");
        try {
            if (ipSecServiceF != null)
                ipSecServiceF.systemReady();
        } catch (Throwable e) {
            reportWtf("making IpSec Service ready", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeNetworkStatsServiceReady");
        try {
            if (networkStatsF != null)
                networkStatsF.systemReady();
        } catch (Throwable e) {
            reportWtf("making Network Stats Service ready", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeConnectivityServiceReady");
        try {
            if (connectivityF != null)
                connectivityF.systemReady();
        } catch (Throwable e) {
            reportWtf("making Connectivity Service ready", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeNetworkPolicyServiceReady");
        try {
            if (networkPolicyF != null) {
                networkPolicyF.systemReady(networkPolicyInitReadySignal);
            }
        } catch (Throwable e) {
            reportWtf("making Network Policy Service ready", e);
        }
        traceEnd();
        traceBeginAndSlog("StartWatchdog");
        Watchdog.getInstance().start();
        traceEnd();
        // Wait for all packages to be prepared
        mPackageManagerService.waitForAppDataPrepared();
        // It is now okay to let the various system services start their
        // third party code...
        traceBeginAndSlog("PhaseThirdPartyAppsCanStart");
        // confirm webview completion before starting 3rd party
        if (webviewPrep != null) {
            ConcurrentUtils.waitForFutureNoInterrupt(webviewPrep, WEBVIEW_PREPARATION);
        }
        mSystemServiceManager.startBootPhase(SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);
        traceEnd();
        traceBeginAndSlog("MakeLocationServiceReady");
        try {
            if (locationF != null)
                locationF.systemRunning();
        } catch (Throwable e) {
            reportWtf("Notifying Location Service running", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeCountryDetectionServiceReady");
        try {
            if (countryDetectorF != null)
                countryDetectorF.systemRunning();
        } catch (Throwable e) {
            reportWtf("Notifying CountryDetectorService running", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeNetworkTimeUpdateReady");
        try {
            if (networkTimeUpdaterF != null)
                networkTimeUpdaterF.systemRunning();
        } catch (Throwable e) {
            reportWtf("Notifying NetworkTimeService running", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeCommonTimeManagementServiceReady");
        try {
            if (commonTimeMgmtServiceF != null) {
                commonTimeMgmtServiceF.systemRunning();
            }
        } catch (Throwable e) {
            reportWtf("Notifying CommonTimeManagementService running", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeInputManagerServiceReady");
        try {
            // TODO(BT) Pass parameter to input manager
            if (inputManagerF != null)
                inputManagerF.systemRunning();
        } catch (Throwable e) {
            reportWtf("Notifying InputManagerService running", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeTelephonyRegistryReady");
        try {
            if (telephonyRegistryF != null)
                telephonyRegistryF.systemRunning();
        } catch (Throwable e) {
            reportWtf("Notifying TelephonyRegistry running", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeMediaRouterServiceReady");
        try {
            if (mediaRouterF != null)
                mediaRouterF.systemRunning();
        } catch (Throwable e) {
            reportWtf("Notifying MediaRouterService running", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeMmsServiceReady");
        try {
            if (mmsServiceF != null)
                mmsServiceF.systemRunning();
        } catch (Throwable e) {
            reportWtf("Notifying MmsService running", e);
        }
        traceEnd();
        traceBeginAndSlog("IncidentDaemonReady");
        try {
            // TODO: Switch from checkService to getService once it's always
            // in the build and should reliably be there.
            final IIncidentManager incident = IIncidentManager.Stub.asInterface(ServiceManager.getService(Context.INCIDENT_SERVICE));
            if (incident != null)
                incident.systemRunning();
        } catch (Throwable e) {
            reportWtf("Notifying incident daemon running", e);
        }
        traceEnd();
    }, BOOT_TIMINGS_TRACE_LOG);
}
#method_after
private void startOtherServices() {
    final Context context = mSystemContext;
    VibratorService vibrator = null;
    IStorageManager storageManager = null;
    NetworkManagementService networkManagement = null;
    IpSecService ipSecService = null;
    NetworkStatsService networkStats = null;
    NetworkPolicyManagerService networkPolicy = null;
    ConnectivityService connectivity = null;
    NsdService serviceDiscovery = null;
    WindowManagerService wm = null;
    SerialService serial = null;
    NetworkTimeUpdateService networkTimeUpdater = null;
    CommonTimeManagementService commonTimeMgmtService = null;
    InputManagerService inputManager = null;
    TelephonyRegistry telephonyRegistry = null;
    ConsumerIrService consumerIr = null;
    MmsServiceBroker mmsService = null;
    HardwarePropertiesManagerService hardwarePropertiesService = null;
    boolean disableSystemTextClassifier = SystemProperties.getBoolean("config.disable_systemtextclassifier", false);
    boolean disableCameraService = SystemProperties.getBoolean("config.disable_cameraservice", false);
    boolean disableSlices = SystemProperties.getBoolean("config.disable_slices", false);
    boolean enableLeftyService = SystemProperties.getBoolean("config.enable_lefty", false);
    boolean isEmulator = SystemProperties.get("ro.kernel.qemu").equals("1");
    boolean isWatch = context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH);
    // For debugging RescueParty
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean("debug.crash_system", false)) {
        throw new RuntimeException();
    }
    try {
        final String SECONDARY_ZYGOTE_PRELOAD = "SecondaryZygotePreload";
        // We start the preload ~1s before the webview factory preparation, to
        // ensure that it completes before the 32 bit relro process is forked
        // from the zygote. In the event that it takes too long, the webview
        // RELRO process will block, but it will do so without holding any locks.
        mZygotePreload = SystemServerInitThreadPool.get().submit(() -> {
            try {
                Slog.i(TAG, SECONDARY_ZYGOTE_PRELOAD);
                TimingsTraceLog traceLog = new TimingsTraceLog(SYSTEM_SERVER_TIMING_ASYNC_TAG, Trace.TRACE_TAG_SYSTEM_SERVER);
                traceLog.traceBegin(SECONDARY_ZYGOTE_PRELOAD);
                if (!Process.zygoteProcess.preloadDefault(Build.SUPPORTED_32_BIT_ABIS[0])) {
                    Slog.e(TAG, "Unable to preload default resources");
                }
                traceLog.traceEnd();
            } catch (Exception ex) {
                Slog.e(TAG, "Exception preloading default resources", ex);
            }
        }, SECONDARY_ZYGOTE_PRELOAD);
        traceBeginAndSlog("StartKeyAttestationApplicationIdProviderService");
        ServiceManager.addService("sec_key_att_app_id_provider", new KeyAttestationApplicationIdProviderService(context));
        traceEnd();
        traceBeginAndSlog("StartKeyChainSystemService");
        mSystemServiceManager.startService(KeyChainSystemService.class);
        traceEnd();
        traceBeginAndSlog("StartSchedulingPolicyService");
        ServiceManager.addService("scheduling_policy", new SchedulingPolicyService());
        traceEnd();
        traceBeginAndSlog("StartTelecomLoaderService");
        mSystemServiceManager.startService(TelecomLoaderService.class);
        traceEnd();
        traceBeginAndSlog("StartTelephonyRegistry");
        telephonyRegistry = new TelephonyRegistry(context);
        ServiceManager.addService("telephony.registry", telephonyRegistry);
        traceEnd();
        traceBeginAndSlog("StartEntropyMixer");
        mEntropyMixer = new EntropyMixer(context);
        traceEnd();
        mContentResolver = context.getContentResolver();
        // The AccountManager must come before the ContentService
        traceBeginAndSlog("StartAccountManagerService");
        mSystemServiceManager.startService(ACCOUNT_SERVICE_CLASS);
        traceEnd();
        traceBeginAndSlog("StartContentService");
        mSystemServiceManager.startService(CONTENT_SERVICE_CLASS);
        traceEnd();
        traceBeginAndSlog("InstallSystemProviders");
        mActivityManagerService.installSystemProviders();
        // Now that SettingsProvider is ready, reactivate SQLiteCompatibilityWalFlags
        SQLiteCompatibilityWalFlags.reset();
        traceEnd();
        // Records errors and logs, for example wtf()
        // Currently this service indirectly depends on SettingsProvider so do this after
        // InstallSystemProviders.
        traceBeginAndSlog("StartDropBoxManager");
        mSystemServiceManager.startService(DropBoxManagerService.class);
        traceEnd();
        traceBeginAndSlog("StartVibratorService");
        vibrator = new VibratorService(context);
        ServiceManager.addService("vibrator", vibrator);
        traceEnd();
        if (!isWatch) {
            traceBeginAndSlog("StartConsumerIrService");
            consumerIr = new ConsumerIrService(context);
            ServiceManager.addService(Context.CONSUMER_IR_SERVICE, consumerIr);
            traceEnd();
        }
        traceBeginAndSlog("StartAlarmManagerService");
        mSystemServiceManager.startService(AlarmManagerService.class);
        traceEnd();
        traceBeginAndSlog("InitWatchdog");
        final Watchdog watchdog = Watchdog.getInstance();
        watchdog.init(context, mActivityManagerService);
        traceEnd();
        traceBeginAndSlog("StartInputManagerService");
        inputManager = new InputManagerService(context);
        traceEnd();
        traceBeginAndSlog("StartWindowManagerService");
        // WMS needs sensor service ready
        ConcurrentUtils.waitForFutureNoInterrupt(mSensorServiceStart, START_SENSOR_SERVICE);
        mSensorServiceStart = null;
        wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, !mFirstBoot, mOnlyCore, new PhoneWindowManager());
        ServiceManager.addService(Context.WINDOW_SERVICE, wm, /* allowIsolated= */
        false, DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PROTO);
        ServiceManager.addService(Context.INPUT_SERVICE, inputManager, /* allowIsolated= */
        false, DUMP_FLAG_PRIORITY_CRITICAL);
        traceEnd();
        traceBeginAndSlog("SetWindowManagerService");
        mActivityManagerService.setWindowManager(wm);
        traceEnd();
        traceBeginAndSlog("WindowManagerServiceOnInitReady");
        wm.onInitReady();
        traceEnd();
        // Start receiving calls from HIDL services. Start in in a separate thread
        // because it need to connect to SensorManager. This have to start
        // after START_SENSOR_SERVICE is done.
        SystemServerInitThreadPool.get().submit(() -> {
            TimingsTraceLog traceLog = new TimingsTraceLog(SYSTEM_SERVER_TIMING_ASYNC_TAG, Trace.TRACE_TAG_SYSTEM_SERVER);
            traceLog.traceBegin(START_HIDL_SERVICES);
            startHidlServices();
            traceLog.traceEnd();
        }, START_HIDL_SERVICES);
        if (!isWatch) {
            traceBeginAndSlog("StartVrManagerService");
            mSystemServiceManager.startService(VrManagerService.class);
            traceEnd();
        }
        traceBeginAndSlog("StartInputManager");
        inputManager.setWindowManagerCallbacks(wm.getInputMonitor());
        inputManager.start();
        traceEnd();
        // TODO: Use service dependencies instead.
        traceBeginAndSlog("DisplayManagerWindowManagerAndInputReady");
        mDisplayManagerService.windowManagerAndInputReady();
        traceEnd();
        // support Bluetooth - see bug 988521
        if (isEmulator) {
            Slog.i(TAG, "No Bluetooth Service (emulator)");
        } else if (mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            Slog.i(TAG, "No Bluetooth Service (factory test)");
        } else if (!context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)) {
            Slog.i(TAG, "No Bluetooth Service (Bluetooth Hardware Not Present)");
        } else {
            traceBeginAndSlog("StartBluetoothService");
            mSystemServiceManager.startService(BluetoothService.class);
            traceEnd();
        }
        traceBeginAndSlog("IpConnectivityMetrics");
        mSystemServiceManager.startService(IpConnectivityMetrics.class);
        traceEnd();
        traceBeginAndSlog("NetworkWatchlistService");
        mSystemServiceManager.startService(NetworkWatchlistService.Lifecycle.class);
        traceEnd();
        traceBeginAndSlog("PinnerService");
        mSystemServiceManager.startService(PinnerService.class);
        traceEnd();
    } catch (RuntimeException e) {
        Slog.e("System", "******************************************");
        Slog.e("System", "************ Failure starting core service", e);
    }
    StatusBarManagerService statusBar = null;
    INotificationManager notification = null;
    LocationManagerService location = null;
    CountryDetectorService countryDetector = null;
    ILockSettings lockSettings = null;
    MediaRouterService mediaRouter = null;
    // Bring up services needed for UI.
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        traceBeginAndSlog("StartInputMethodManagerLifecycle");
        mSystemServiceManager.startService(InputMethodManagerService.Lifecycle.class);
        traceEnd();
        traceBeginAndSlog("StartAccessibilityManagerService");
        try {
            ServiceManager.addService(Context.ACCESSIBILITY_SERVICE, new AccessibilityManagerService(context));
        } catch (Throwable e) {
            reportWtf("starting Accessibility Manager", e);
        }
        traceEnd();
    }
    traceBeginAndSlog("MakeDisplayReady");
    try {
        wm.displayReady();
    } catch (Throwable e) {
        reportWtf("making display ready", e);
    }
    traceEnd();
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        if (!"0".equals(SystemProperties.get("system_init.startmountservice"))) {
            traceBeginAndSlog("StartStorageManagerService");
            try {
                /*
                     * NotificationManagerService is dependant on StorageManagerService,
                     * (for media / usb notifications) so we must start StorageManagerService first.
                     */
                mSystemServiceManager.startService(STORAGE_MANAGER_SERVICE_CLASS);
                storageManager = IStorageManager.Stub.asInterface(ServiceManager.getService("mount"));
            } catch (Throwable e) {
                reportWtf("starting StorageManagerService", e);
            }
            traceEnd();
            traceBeginAndSlog("StartStorageStatsService");
            try {
                mSystemServiceManager.startService(STORAGE_STATS_SERVICE_CLASS);
            } catch (Throwable e) {
                reportWtf("starting StorageStatsService", e);
            }
            traceEnd();
        }
    }
    // We start this here so that we update our configuration to set watch or television
    // as appropriate.
    traceBeginAndSlog("StartUiModeManager");
    mSystemServiceManager.startService(UiModeManagerService.class);
    traceEnd();
    if (!mOnlyCore) {
        traceBeginAndSlog("UpdatePackagesIfNeeded");
        try {
            mPackageManagerService.updatePackagesIfNeeded();
        } catch (Throwable e) {
            reportWtf("update packages", e);
        }
        traceEnd();
    }
    traceBeginAndSlog("PerformFstrimIfNeeded");
    try {
        mPackageManagerService.performFstrimIfNeeded();
    } catch (Throwable e) {
        reportWtf("performing fstrim", e);
    }
    traceEnd();
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        traceBeginAndSlog("StartLockSettingsService");
        try {
            mSystemServiceManager.startService(LOCK_SETTINGS_SERVICE_CLASS);
            lockSettings = ILockSettings.Stub.asInterface(ServiceManager.getService("lock_settings"));
        } catch (Throwable e) {
            reportWtf("starting LockSettingsService service", e);
        }
        traceEnd();
        final boolean hasPdb = !SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP).equals("");
        if (hasPdb) {
            traceBeginAndSlog("StartPersistentDataBlock");
            mSystemServiceManager.startService(PersistentDataBlockService.class);
            traceEnd();
        }
        if (hasPdb || OemLockService.isHalPresent()) {
            // Implementation depends on pdb or the OemLock HAL
            traceBeginAndSlog("StartOemLockService");
            mSystemServiceManager.startService(OemLockService.class);
            traceEnd();
        }
        traceBeginAndSlog("StartDeviceIdleController");
        mSystemServiceManager.startService(DeviceIdleController.class);
        traceEnd();
        // Always start the Device Policy Manager, so that the API is compatible with
        // API8.
        traceBeginAndSlog("StartDevicePolicyManager");
        mSystemServiceManager.startService(DevicePolicyManagerService.Lifecycle.class);
        traceEnd();
        if (!isWatch) {
            traceBeginAndSlog("StartStatusBarManagerService");
            try {
                statusBar = new StatusBarManagerService(context, wm);
                ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);
            } catch (Throwable e) {
                reportWtf("starting StatusBarManagerService", e);
            }
            traceEnd();
        }
        traceBeginAndSlog("StartClipboardService");
        mSystemServiceManager.startService(ClipboardService.class);
        traceEnd();
        traceBeginAndSlog("StartNetworkManagementService");
        try {
            networkManagement = NetworkManagementService.create(context);
            ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);
        } catch (Throwable e) {
            reportWtf("starting NetworkManagement Service", e);
        }
        traceEnd();
        traceBeginAndSlog("StartIpSecService");
        try {
            ipSecService = IpSecService.create(context);
            ServiceManager.addService(Context.IPSEC_SERVICE, ipSecService);
        } catch (Throwable e) {
            reportWtf("starting IpSec Service", e);
        }
        traceEnd();
        traceBeginAndSlog("StartTextServicesManager");
        mSystemServiceManager.startService(TextServicesManagerService.Lifecycle.class);
        traceEnd();
        if (!disableSystemTextClassifier) {
            traceBeginAndSlog("StartTextClassificationManagerService");
            mSystemServiceManager.startService(TextClassificationManagerService.Lifecycle.class);
            traceEnd();
        }
        traceBeginAndSlog("StartNetworkScoreService");
        mSystemServiceManager.startService(NetworkScoreService.Lifecycle.class);
        traceEnd();
        traceBeginAndSlog("StartNetworkStatsService");
        try {
            networkStats = NetworkStatsService.create(context, networkManagement);
            ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats);
        } catch (Throwable e) {
            reportWtf("starting NetworkStats Service", e);
        }
        traceEnd();
        traceBeginAndSlog("StartNetworkPolicyManagerService");
        try {
            networkPolicy = new NetworkPolicyManagerService(context, mActivityManagerService, networkManagement);
            ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy);
        } catch (Throwable e) {
            reportWtf("starting NetworkPolicy Service", e);
        }
        traceEnd();
        if (!mOnlyCore) {
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI)) {
                // Wifi Service must be started first for wifi-related services.
                traceBeginAndSlog("StartWifi");
                mSystemServiceManager.startService(WIFI_SERVICE_CLASS);
                traceEnd();
                traceBeginAndSlog("StartWifiScanning");
                mSystemServiceManager.startService("com.android.server.wifi.scanner.WifiScanningService");
                traceEnd();
            }
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_RTT)) {
                traceBeginAndSlog("StartRttService");
                mSystemServiceManager.startService("com.android.server.wifi.rtt.RttService");
                traceEnd();
            }
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_AWARE)) {
                traceBeginAndSlog("StartWifiAware");
                mSystemServiceManager.startService(WIFI_AWARE_SERVICE_CLASS);
                traceEnd();
            }
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_DIRECT)) {
                traceBeginAndSlog("StartWifiP2P");
                mSystemServiceManager.startService(WIFI_P2P_SERVICE_CLASS);
                traceEnd();
            }
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOWPAN)) {
                traceBeginAndSlog("StartLowpan");
                mSystemServiceManager.startService(LOWPAN_SERVICE_CLASS);
                traceEnd();
            }
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_ETHERNET) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) {
            traceBeginAndSlog("StartEthernet");
            mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS);
            traceEnd();
        }
        traceBeginAndSlog("StartConnectivityService");
        try {
            connectivity = new ConnectivityService(context, networkManagement, networkStats, networkPolicy);
            ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity, /* allowIsolated= */
            false, DUMP_FLAG_PRIORITY_HIGH | DUMP_FLAG_PRIORITY_NORMAL);
            networkStats.bindConnectivityManager(connectivity);
            networkPolicy.bindConnectivityManager(connectivity);
        } catch (Throwable e) {
            reportWtf("starting Connectivity Service", e);
        }
        traceEnd();
        traceBeginAndSlog("StartNsdService");
        try {
            serviceDiscovery = NsdService.create(context);
            ServiceManager.addService(Context.NSD_SERVICE, serviceDiscovery);
        } catch (Throwable e) {
            reportWtf("starting Service Discovery Service", e);
        }
        traceEnd();
        traceBeginAndSlog("StartSystemUpdateManagerService");
        try {
            ServiceManager.addService(Context.SYSTEM_UPDATE_SERVICE, new SystemUpdateManagerService(context));
        } catch (Throwable e) {
            reportWtf("starting SystemUpdateManagerService", e);
        }
        traceEnd();
        traceBeginAndSlog("StartUpdateLockService");
        try {
            ServiceManager.addService(Context.UPDATE_LOCK_SERVICE, new UpdateLockService(context));
        } catch (Throwable e) {
            reportWtf("starting UpdateLockService", e);
        }
        traceEnd();
        traceBeginAndSlog("StartNotificationManager");
        mSystemServiceManager.startService(NotificationManagerService.class);
        SystemNotificationChannels.createAll(context);
        notification = INotificationManager.Stub.asInterface(ServiceManager.getService(Context.NOTIFICATION_SERVICE));
        traceEnd();
        traceBeginAndSlog("StartDeviceMonitor");
        mSystemServiceManager.startService(DeviceStorageMonitorService.class);
        traceEnd();
        traceBeginAndSlog("StartLocationManagerService");
        try {
            location = new LocationManagerService(context);
            ServiceManager.addService(Context.LOCATION_SERVICE, location);
        } catch (Throwable e) {
            reportWtf("starting Location Manager", e);
        }
        traceEnd();
        traceBeginAndSlog("StartCountryDetectorService");
        try {
            countryDetector = new CountryDetectorService(context);
            ServiceManager.addService(Context.COUNTRY_DETECTOR, countryDetector);
        } catch (Throwable e) {
            reportWtf("starting Country Detector", e);
        }
        traceEnd();
        if (!isWatch) {
            traceBeginAndSlog("StartSearchManagerService");
            try {
                mSystemServiceManager.startService(SEARCH_MANAGER_SERVICE_CLASS);
            } catch (Throwable e) {
                reportWtf("starting Search Service", e);
            }
            traceEnd();
        }
        if (context.getResources().getBoolean(R.bool.config_enableWallpaperService)) {
            traceBeginAndSlog("StartWallpaperManagerService");
            mSystemServiceManager.startService(WALLPAPER_SERVICE_CLASS);
            traceEnd();
        }
        traceBeginAndSlog("StartAudioService");
        mSystemServiceManager.startService(AudioService.Lifecycle.class);
        traceEnd();
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_BROADCAST_RADIO)) {
            traceBeginAndSlog("StartBroadcastRadioService");
            mSystemServiceManager.startService(BroadcastRadioService.class);
            traceEnd();
        }
        traceBeginAndSlog("StartDockObserver");
        mSystemServiceManager.startService(DockObserver.class);
        traceEnd();
        if (isWatch) {
            traceBeginAndSlog("StartThermalObserver");
            mSystemServiceManager.startService(THERMAL_OBSERVER_CLASS);
            traceEnd();
        }
        traceBeginAndSlog("StartWiredAccessoryManager");
        try {
            // Listen for wired headset changes
            inputManager.setWiredAccessoryCallbacks(new WiredAccessoryManager(context, inputManager));
        } catch (Throwable e) {
            reportWtf("starting WiredAccessoryManager", e);
        }
        traceEnd();
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_MIDI)) {
            // Start MIDI Manager service
            traceBeginAndSlog("StartMidiManager");
            mSystemServiceManager.startService(MIDI_SERVICE_CLASS);
            traceEnd();
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY) || isEmulator) {
            // Manage USB host and device support
            traceBeginAndSlog("StartUsbService");
            mSystemServiceManager.startService(USB_SERVICE_CLASS);
            traceEnd();
        }
        if (!isWatch) {
            traceBeginAndSlog("StartSerialService");
            try {
                // Serial port support
                serial = new SerialService(context);
                ServiceManager.addService(Context.SERIAL_SERVICE, serial);
            } catch (Throwable e) {
                Slog.e(TAG, "Failure starting SerialService", e);
            }
            traceEnd();
        }
        traceBeginAndSlog("StartHardwarePropertiesManagerService");
        try {
            hardwarePropertiesService = new HardwarePropertiesManagerService(context);
            ServiceManager.addService(Context.HARDWARE_PROPERTIES_SERVICE, hardwarePropertiesService);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting HardwarePropertiesManagerService", e);
        }
        traceEnd();
        traceBeginAndSlog("StartTwilightService");
        mSystemServiceManager.startService(TwilightService.class);
        traceEnd();
        if (ColorDisplayController.isAvailable(context)) {
            traceBeginAndSlog("StartNightDisplay");
            mSystemServiceManager.startService(ColorDisplayService.class);
            traceEnd();
        }
        traceBeginAndSlog("StartJobScheduler");
        mSystemServiceManager.startService(JobSchedulerService.class);
        traceEnd();
        traceBeginAndSlog("StartSoundTrigger");
        mSystemServiceManager.startService(SoundTriggerService.class);
        traceEnd();
        traceBeginAndSlog("StartTrustManager");
        mSystemServiceManager.startService(TrustManagerService.class);
        traceEnd();
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_BACKUP)) {
            traceBeginAndSlog("StartBackupManager");
            mSystemServiceManager.startService(BACKUP_MANAGER_SERVICE_CLASS);
            traceEnd();
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS) || context.getResources().getBoolean(R.bool.config_enableAppWidgetService)) {
            traceBeginAndSlog("StartAppWidgerService");
            mSystemServiceManager.startService(APPWIDGET_SERVICE_CLASS);
            traceEnd();
        }
        // We need to always start this service, regardless of whether the
        // FEATURE_VOICE_RECOGNIZERS feature is set, because it needs to take care
        // of initializing various settings.  It will internally modify its behavior
        // based on that feature.
        traceBeginAndSlog("StartVoiceRecognitionManager");
        mSystemServiceManager.startService(VOICE_RECOGNITION_MANAGER_SERVICE_CLASS);
        traceEnd();
        if (GestureLauncherService.isGestureLauncherEnabled(context.getResources())) {
            traceBeginAndSlog("StartGestureLauncher");
            mSystemServiceManager.startService(GestureLauncherService.class);
            traceEnd();
        }
        traceBeginAndSlog("StartSensorNotification");
        mSystemServiceManager.startService(SensorNotificationService.class);
        traceEnd();
        traceBeginAndSlog("StartContextHubSystemService");
        mSystemServiceManager.startService(ContextHubSystemService.class);
        traceEnd();
        traceBeginAndSlog("StartDiskStatsService");
        try {
            ServiceManager.addService("diskstats", new DiskStatsService(context));
        } catch (Throwable e) {
            reportWtf("starting DiskStats Service", e);
        }
        traceEnd();
        // timezone.RulesManagerService will prevent a device starting up if the chain of trust
        // required for safe time zone updates might be broken. RuleManagerService cannot do
        // this check when mOnlyCore == true, so we don't enable the service in this case.
        // This service requires that JobSchedulerService is already started when it starts.
        final boolean startRulesManagerService = !mOnlyCore && context.getResources().getBoolean(R.bool.config_enableUpdateableTimeZoneRules);
        if (startRulesManagerService) {
            traceBeginAndSlog("StartTimeZoneRulesManagerService");
            mSystemServiceManager.startService(TIME_ZONE_RULES_MANAGER_SERVICE_CLASS);
            traceEnd();
        }
        if (!isWatch) {
            traceBeginAndSlog("StartNetworkTimeUpdateService");
            try {
                networkTimeUpdater = new NetworkTimeUpdateService(context);
                ServiceManager.addService("network_time_update_service", networkTimeUpdater);
            } catch (Throwable e) {
                reportWtf("starting NetworkTimeUpdate service", e);
            }
            traceEnd();
        }
        traceBeginAndSlog("StartCommonTimeManagementService");
        try {
            commonTimeMgmtService = new CommonTimeManagementService(context);
            ServiceManager.addService("commontime_management", commonTimeMgmtService);
        } catch (Throwable e) {
            reportWtf("starting CommonTimeManagementService service", e);
        }
        traceEnd();
        traceBeginAndSlog("CertBlacklister");
        try {
            CertBlacklister blacklister = new CertBlacklister(context);
        } catch (Throwable e) {
            reportWtf("starting CertBlacklister", e);
        }
        traceEnd();
        if (EmergencyAffordanceManager.ENABLED) {
            // EmergencyMode service
            traceBeginAndSlog("StartEmergencyAffordanceService");
            mSystemServiceManager.startService(EmergencyAffordanceService.class);
            traceEnd();
        }
        // Dreams (interactive idle-time views, a/k/a screen savers, and doze mode)
        traceBeginAndSlog("StartDreamManager");
        mSystemServiceManager.startService(DreamManagerService.class);
        traceEnd();
        traceBeginAndSlog("AddGraphicsStatsService");
        ServiceManager.addService(GraphicsStatsService.GRAPHICS_STATS_SERVICE, new GraphicsStatsService(context));
        traceEnd();
        if (CoverageService.ENABLED) {
            traceBeginAndSlog("AddCoverageService");
            ServiceManager.addService(CoverageService.COVERAGE_SERVICE, new CoverageService());
            traceEnd();
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PRINTING)) {
            traceBeginAndSlog("StartPrintManager");
            mSystemServiceManager.startService(PRINT_MANAGER_SERVICE_CLASS);
            traceEnd();
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_COMPANION_DEVICE_SETUP)) {
            traceBeginAndSlog("StartCompanionDeviceManager");
            mSystemServiceManager.startService(COMPANION_DEVICE_MANAGER_SERVICE_CLASS);
            traceEnd();
        }
        traceBeginAndSlog("StartRestrictionManager");
        mSystemServiceManager.startService(RestrictionsManagerService.class);
        traceEnd();
        traceBeginAndSlog("StartMediaSessionService");
        mSystemServiceManager.startService(MediaSessionService.class);
        traceEnd();
        traceBeginAndSlog("StartMediaUpdateService");
        mSystemServiceManager.startService(MediaUpdateService.class);
        traceEnd();
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_HDMI_CEC)) {
            traceBeginAndSlog("StartHdmiControlService");
            mSystemServiceManager.startService(HdmiControlService.class);
            traceEnd();
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_LIVE_TV) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {
            traceBeginAndSlog("StartTvInputManager");
            mSystemServiceManager.startService(TvInputManagerService.class);
            traceEnd();
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PICTURE_IN_PICTURE)) {
            traceBeginAndSlog("StartMediaResourceMonitor");
            mSystemServiceManager.startService(MediaResourceMonitorService.class);
            traceEnd();
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {
            traceBeginAndSlog("StartTvRemoteService");
            mSystemServiceManager.startService(TvRemoteService.class);
            traceEnd();
        }
        traceBeginAndSlog("StartMediaRouterService");
        try {
            mediaRouter = new MediaRouterService(context);
            ServiceManager.addService(Context.MEDIA_ROUTER_SERVICE, mediaRouter);
        } catch (Throwable e) {
            reportWtf("starting MediaRouterService", e);
        }
        traceEnd();
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FINGERPRINT)) {
            traceBeginAndSlog("StartFingerprintSensor");
            mSystemServiceManager.startService(FingerprintService.class);
            traceEnd();
        }
        traceBeginAndSlog("StartBackgroundDexOptService");
        try {
            BackgroundDexOptService.schedule(context);
        } catch (Throwable e) {
            reportWtf("starting StartBackgroundDexOptService", e);
        }
        traceEnd();
        traceBeginAndSlog("StartPruneInstantAppsJobService");
        try {
            PruneInstantAppsJobService.schedule(context);
        } catch (Throwable e) {
            reportWtf("StartPruneInstantAppsJobService", e);
        }
        traceEnd();
        // LauncherAppsService uses ShortcutService.
        traceBeginAndSlog("StartShortcutServiceLifecycle");
        mSystemServiceManager.startService(ShortcutService.Lifecycle.class);
        traceEnd();
        traceBeginAndSlog("StartLauncherAppsService");
        mSystemServiceManager.startService(LauncherAppsService.class);
        traceEnd();
        traceBeginAndSlog("StartCrossProfileAppsService");
        mSystemServiceManager.startService(CrossProfileAppsService.class);
        traceEnd();
    }
    if (!isWatch) {
        traceBeginAndSlog("StartMediaProjectionManager");
        mSystemServiceManager.startService(MediaProjectionManagerService.class);
        traceEnd();
    }
    if (isWatch) {
        traceBeginAndSlog("StartWearConfigService");
        mSystemServiceManager.startService(WEAR_CONFIG_SERVICE_CLASS);
        traceEnd();
        traceBeginAndSlog("StartWearConnectivityService");
        mSystemServiceManager.startService(WEAR_CONNECTIVITY_SERVICE_CLASS);
        traceEnd();
        traceBeginAndSlog("StartWearTimeService");
        mSystemServiceManager.startService(WEAR_DISPLAY_SERVICE_CLASS);
        mSystemServiceManager.startService(WEAR_TIME_SERVICE_CLASS);
        traceEnd();
        if (enableLeftyService) {
            traceBeginAndSlog("StartWearLeftyService");
            mSystemServiceManager.startService(WEAR_LEFTY_SERVICE_CLASS);
            traceEnd();
        }
        traceBeginAndSlog("StartWearGlobalActionsService");
        mSystemServiceManager.startService(WEAR_GLOBAL_ACTIONS_SERVICE_CLASS);
        traceEnd();
    }
    if (!disableSlices) {
        traceBeginAndSlog("StartSliceManagerService");
        mSystemServiceManager.startService(SLICE_MANAGER_SERVICE_CLASS);
        traceEnd();
    }
    if (!disableCameraService) {
        traceBeginAndSlog("StartCameraServiceProxy");
        mSystemServiceManager.startService(CameraServiceProxy.class);
        traceEnd();
    }
    if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_EMBEDDED)) {
        traceBeginAndSlog("StartIoTSystemService");
        mSystemServiceManager.startService(IOT_SERVICE_CLASS);
        traceEnd();
    }
    // Statsd helper
    traceBeginAndSlog("StartStatsCompanionService");
    mSystemServiceManager.startService(StatsCompanionService.Lifecycle.class);
    traceEnd();
    // Before things start rolling, be sure we have decided whether
    // we are in safe mode.
    final boolean safeMode = wm.detectSafeMode();
    if (safeMode) {
        traceBeginAndSlog("EnterSafeModeAndDisableJitCompilation");
        mActivityManagerService.enterSafeMode();
        // Disable the JIT for the system_server process
        VMRuntime.getRuntime().disableJitCompilation();
        traceEnd();
    } else {
        // Enable the JIT for the system_server process
        traceBeginAndSlog("StartJitCompilation");
        VMRuntime.getRuntime().startJitCompilation();
        traceEnd();
    }
    // MMS service broker
    traceBeginAndSlog("StartMmsService");
    mmsService = mSystemServiceManager.startService(MmsServiceBroker.class);
    traceEnd();
    if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_AUTOFILL)) {
        traceBeginAndSlog("StartAutoFillService");
        mSystemServiceManager.startService(AUTO_FILL_MANAGER_SERVICE_CLASS);
        traceEnd();
    }
    // It is now time to start up the app processes...
    traceBeginAndSlog("MakeVibratorServiceReady");
    try {
        vibrator.systemReady();
    } catch (Throwable e) {
        reportWtf("making Vibrator Service ready", e);
    }
    traceEnd();
    traceBeginAndSlog("MakeLockSettingsServiceReady");
    if (lockSettings != null) {
        try {
            lockSettings.systemReady();
        } catch (Throwable e) {
            reportWtf("making Lock Settings Service ready", e);
        }
    }
    traceEnd();
    // Needed by DevicePolicyManager for initialization
    traceBeginAndSlog("StartBootPhaseLockSettingsReady");
    mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);
    traceEnd();
    traceBeginAndSlog("StartBootPhaseSystemServicesReady");
    mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);
    traceEnd();
    traceBeginAndSlog("MakeWindowManagerServiceReady");
    try {
        wm.systemReady();
    } catch (Throwable e) {
        reportWtf("making Window Manager Service ready", e);
    }
    traceEnd();
    if (safeMode) {
        mActivityManagerService.showSafeModeOverlay();
    }
    // Update the configuration for this context by hand, because we're going
    // to start using it before the config change done in wm.systemReady() will
    // propagate to it.
    final Configuration config = wm.computeNewConfiguration(DEFAULT_DISPLAY);
    DisplayMetrics metrics = new DisplayMetrics();
    WindowManager w = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    w.getDefaultDisplay().getMetrics(metrics);
    context.getResources().updateConfiguration(config, metrics);
    // The system context's theme may be configuration-dependent.
    final Theme systemTheme = context.getTheme();
    if (systemTheme.getChangingConfigurations() != 0) {
        systemTheme.rebase();
    }
    traceBeginAndSlog("MakePowerManagerServiceReady");
    try {
        // TODO: use boot phase
        mPowerManagerService.systemReady(mActivityManagerService.getAppOpsService());
    } catch (Throwable e) {
        reportWtf("making Power Manager Service ready", e);
    }
    traceEnd();
    traceBeginAndSlog("MakePackageManagerServiceReady");
    mPackageManagerService.systemReady();
    traceEnd();
    traceBeginAndSlog("MakeDisplayManagerServiceReady");
    try {
        // TODO: use boot phase and communicate these flags some other way
        mDisplayManagerService.systemReady(safeMode, mOnlyCore);
    } catch (Throwable e) {
        reportWtf("making Display Manager Service ready", e);
    }
    traceEnd();
    mSystemServiceManager.setSafeMode(safeMode);
    // Start device specific services
    traceBeginAndSlog("StartDeviceSpecificServices");
    final String[] classes = mSystemContext.getResources().getStringArray(R.array.config_deviceSpecificSystemServices);
    for (final String className : classes) {
        traceBeginAndSlog("StartDeviceSpecificServices " + className);
        try {
            mSystemServiceManager.startService(className);
        } catch (Throwable e) {
            reportWtf("starting " + className, e);
        }
        traceEnd();
    }
    traceEnd();
    traceBeginAndSlog("StartBootPhaseDeviceSpecificServicesReady");
    mSystemServiceManager.startBootPhase(SystemService.PHASE_DEVICE_SPECIFIC_SERVICES_READY);
    traceEnd();
    // These are needed to propagate to the runnable below.
    final NetworkManagementService networkManagementF = networkManagement;
    final NetworkStatsService networkStatsF = networkStats;
    final NetworkPolicyManagerService networkPolicyF = networkPolicy;
    final ConnectivityService connectivityF = connectivity;
    final LocationManagerService locationF = location;
    final CountryDetectorService countryDetectorF = countryDetector;
    final NetworkTimeUpdateService networkTimeUpdaterF = networkTimeUpdater;
    final CommonTimeManagementService commonTimeMgmtServiceF = commonTimeMgmtService;
    final InputManagerService inputManagerF = inputManager;
    final TelephonyRegistry telephonyRegistryF = telephonyRegistry;
    final MediaRouterService mediaRouterF = mediaRouter;
    final MmsServiceBroker mmsServiceF = mmsService;
    final IpSecService ipSecServiceF = ipSecService;
    final WindowManagerService windowManagerF = wm;
    // We now tell the activity manager it is okay to run third party
    // code.  It will call back into us once it has gotten to the state
    // where third party code can really run (but before it has actually
    // started launching the initial applications), for us to complete our
    // initialization.
    mActivityManagerService.systemReady(() -> {
        Slog.i(TAG, "Making services ready");
        traceBeginAndSlog("StartActivityManagerReadyPhase");
        mSystemServiceManager.startBootPhase(SystemService.PHASE_ACTIVITY_MANAGER_READY);
        traceEnd();
        traceBeginAndSlog("StartObservingNativeCrashes");
        try {
            mActivityManagerService.startObservingNativeCrashes();
        } catch (Throwable e) {
            reportWtf("observing native crashes", e);
        }
        traceEnd();
        // No dependency on Webview preparation in system server. But this should
        // be completed before allowing 3rd party
        final String WEBVIEW_PREPARATION = "WebViewFactoryPreparation";
        Future<?> webviewPrep = null;
        if (!mOnlyCore && mWebViewUpdateService != null) {
            webviewPrep = SystemServerInitThreadPool.get().submit(() -> {
                Slog.i(TAG, WEBVIEW_PREPARATION);
                TimingsTraceLog traceLog = new TimingsTraceLog(SYSTEM_SERVER_TIMING_ASYNC_TAG, Trace.TRACE_TAG_SYSTEM_SERVER);
                traceLog.traceBegin(WEBVIEW_PREPARATION);
                ConcurrentUtils.waitForFutureNoInterrupt(mZygotePreload, "Zygote preload");
                mZygotePreload = null;
                mWebViewUpdateService.prepareWebViewInSystemServer();
                traceLog.traceEnd();
            }, WEBVIEW_PREPARATION);
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            traceBeginAndSlog("StartCarServiceHelperService");
            mSystemServiceManager.startService(CAR_SERVICE_HELPER_SERVICE_CLASS);
            traceEnd();
        }
        traceBeginAndSlog("StartSystemUI");
        try {
            startSystemUi(context, windowManagerF);
        } catch (Throwable e) {
            reportWtf("starting System UI", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeNetworkManagementServiceReady");
        try {
            if (networkManagementF != null)
                networkManagementF.systemReady();
        } catch (Throwable e) {
            reportWtf("making Network Managment Service ready", e);
        }
        CountDownLatch networkPolicyInitReadySignal = null;
        if (networkPolicyF != null) {
            networkPolicyInitReadySignal = networkPolicyF.networkScoreAndNetworkManagementServiceReady();
        }
        traceEnd();
        traceBeginAndSlog("MakeIpSecServiceReady");
        try {
            if (ipSecServiceF != null)
                ipSecServiceF.systemReady();
        } catch (Throwable e) {
            reportWtf("making IpSec Service ready", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeNetworkStatsServiceReady");
        try {
            if (networkStatsF != null)
                networkStatsF.systemReady();
        } catch (Throwable e) {
            reportWtf("making Network Stats Service ready", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeConnectivityServiceReady");
        try {
            if (connectivityF != null)
                connectivityF.systemReady();
        } catch (Throwable e) {
            reportWtf("making Connectivity Service ready", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeNetworkPolicyServiceReady");
        try {
            if (networkPolicyF != null) {
                networkPolicyF.systemReady(networkPolicyInitReadySignal);
            }
        } catch (Throwable e) {
            reportWtf("making Network Policy Service ready", e);
        }
        traceEnd();
        traceBeginAndSlog("StartWatchdog");
        Watchdog.getInstance().start();
        traceEnd();
        // Wait for all packages to be prepared
        mPackageManagerService.waitForAppDataPrepared();
        // It is now okay to let the various system services start their
        // third party code...
        traceBeginAndSlog("PhaseThirdPartyAppsCanStart");
        // confirm webview completion before starting 3rd party
        if (webviewPrep != null) {
            ConcurrentUtils.waitForFutureNoInterrupt(webviewPrep, WEBVIEW_PREPARATION);
        }
        mSystemServiceManager.startBootPhase(SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);
        traceEnd();
        traceBeginAndSlog("MakeLocationServiceReady");
        try {
            if (locationF != null)
                locationF.systemRunning();
        } catch (Throwable e) {
            reportWtf("Notifying Location Service running", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeCountryDetectionServiceReady");
        try {
            if (countryDetectorF != null)
                countryDetectorF.systemRunning();
        } catch (Throwable e) {
            reportWtf("Notifying CountryDetectorService running", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeNetworkTimeUpdateReady");
        try {
            if (networkTimeUpdaterF != null)
                networkTimeUpdaterF.systemRunning();
        } catch (Throwable e) {
            reportWtf("Notifying NetworkTimeService running", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeCommonTimeManagementServiceReady");
        try {
            if (commonTimeMgmtServiceF != null) {
                commonTimeMgmtServiceF.systemRunning();
            }
        } catch (Throwable e) {
            reportWtf("Notifying CommonTimeManagementService running", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeInputManagerServiceReady");
        try {
            // TODO(BT) Pass parameter to input manager
            if (inputManagerF != null)
                inputManagerF.systemRunning();
        } catch (Throwable e) {
            reportWtf("Notifying InputManagerService running", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeTelephonyRegistryReady");
        try {
            if (telephonyRegistryF != null)
                telephonyRegistryF.systemRunning();
        } catch (Throwable e) {
            reportWtf("Notifying TelephonyRegistry running", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeMediaRouterServiceReady");
        try {
            if (mediaRouterF != null)
                mediaRouterF.systemRunning();
        } catch (Throwable e) {
            reportWtf("Notifying MediaRouterService running", e);
        }
        traceEnd();
        traceBeginAndSlog("MakeMmsServiceReady");
        try {
            if (mmsServiceF != null)
                mmsServiceF.systemRunning();
        } catch (Throwable e) {
            reportWtf("Notifying MmsService running", e);
        }
        traceEnd();
        traceBeginAndSlog("IncidentDaemonReady");
        try {
            // TODO: Switch from checkService to getService once it's always
            // in the build and should reliably be there.
            final IIncidentManager incident = IIncidentManager.Stub.asInterface(ServiceManager.getService(Context.INCIDENT_SERVICE));
            if (incident != null)
                incident.systemRunning();
        } catch (Throwable e) {
            reportWtf("Notifying incident daemon running", e);
        }
        traceEnd();
    }, BOOT_TIMINGS_TRACE_LOG);
}
#end_block

#method_before
private int processPointerEvent(QueuedInputEvent q) {
    final MotionEvent event = (MotionEvent) q.mEvent;
    int action;
    int i;
    int rotation;
    boolean isLandscape;
    float raw;
    boolean hit;
    if (mGestureButtonEnabled && !mIsKeyguard) {
        if (event.getPointerCount() == 1) {
            action = event.getActionMasked();
            rotation = 0;
            isLandscape = false;
            if (action == 0 || mCheckForGestureButton || mGestureButtonActive) {
                rotation = mAttachInfo.mDisplay.getRotation();
                isLandscape = rotation != 1 ? rotation == 3 : true;
            }
            Message msg;
            int i2;
            boolean ishandled;
            switch(action) {
                case 0:
                    mCheckForGestureButton = false;
                    mGestureButtonActive = false;
                    mQueueMotionConsumed = true;
                    mBackupEventList.clear();
                    if (isLandscape) {
                        raw = event.getRawX();
                    } else {
                        raw = event.getRawY();
                    }
                    if (rotation == 0 || rotation == 1) {
                        mGestureButtonZone = mScreenHeight - 20;
                        hit = raw > ((float) mGestureButtonZone);
                    } else {
                        mGestureButtonZone = 20;
                        hit = raw < ((float) mGestureButtonZone);
                    }
                    if (hit) {
                        mCheckForGestureButton = true;
                        mRawX = event.getRawX();
                        mRawY = event.getRawY();
                        mBackupEventList.add(MotionEvent.obtain(event));
                        msg = Message.obtain(mHandler, ViewRootImpl.MSG_GESTURE_MOTION_DOWN, mView);
                        mQueueMotionConsumed = false;
                        mHandler.sendMessageDelayed(msg, (long) ViewRootImpl.GESTURE_MOTION_QUEUE_DELAY);
                        return 1;
                    }
                    break;
                case 1:
                case 3:
                    if (!mGestureButtonActive) {
                        if (mCheckForGestureButton) {
                            if (mHandler.hasMessages(ViewRootImpl.MSG_GESTURE_MOTION_DOWN)) {
                                mHandler.removeMessages(ViewRootImpl.MSG_GESTURE_MOTION_DOWN);
                            }
                            if (!mQueueMotionConsumed) {
                                i2 = 0;
                                while (i2 < mBackupEventList.size()) {
                                    try {
                                        ishandled = mView.dispatchPointerEvent((MotionEvent) mBackupEventList.get(i2));
                                        i2++;
                                    } catch (NullPointerException e) {
                                        Log.e(ViewRootImpl.TAG, "mView does not exist, so discard the remaining points. " + e);
                                    }
                                }
                            }
                            mQueueMotionConsumed = true;
                            mCheckForGestureButton = false;
                            mGestureButtonActive = false;
                            break;
                        } else {
                            break;
                        }
                    }
                    mCheckForGestureButton = false;
                    mGestureButtonActive = false;
                    mQueueMotionConsumed = true;
                    return 1;
                case 2:
                    if (mCheckForGestureButton) {
                        mBackupEventList.add(MotionEvent.obtain(event));
                        boolean swipeTimeoSlow = false;
                        boolean reachDistance = false;
                        if (event.getEventTime() - event.getDownTime() > 400) {
                            swipeTimeoSlow = true;
                        }
                        int threshold = ViewRootImpl.GESTURE_KEY_DISTANCE_THRESHOLD;
                        if (rotation == 0 || rotation == 2) {
                            if (event.getRawX() > ((float) mOneThirdPart) && event.getRawX() < ((float) (mOneThirdPart * 2))) {
                                threshold = ViewRootImpl.GESTURE_KEY_LONG_CLICK_MOVE;
                            }
                            if (Math.abs(event.getRawY() - mRawY) > ((float) threshold)) {
                                reachDistance = true;
                            }
                        } else if (rotation == 1 || rotation == 3) {
                            if (event.getRawY() > ((float) mOneThirdPart) && event.getRawY() < ((float) (mOneThirdPart * 2))) {
                                threshold = ViewRootImpl.GESTURE_KEY_LONG_CLICK_MOVE;
                            }
                            if (Math.abs(event.getRawX() - mRawX) > ((float) threshold)) {
                                reachDistance = true;
                            }
                        }
                        if (reachDistance) {
                            mGestureButtonActive = true;
                            if (mHandler.hasMessages(ViewRootImpl.MSG_GESTURE_MOTION_DOWN)) {
                                mHandler.removeMessages(ViewRootImpl.MSG_GESTURE_MOTION_DOWN);
                            }
                            mCheckForGestureButton = false;
                            mQueueMotionConsumed = true;
                        } else if (reachDistance || swipeTimeoSlow) {
                            if (mHandler.hasMessages(ViewRootImpl.MSG_GESTURE_MOTION_DOWN)) {
                                mHandler.removeMessages(ViewRootImpl.MSG_GESTURE_MOTION_DOWN);
                            }
                            if (!mQueueMotionConsumed) {
                                i2 = 0;
                                while (i2 < mBackupEventList.size()) {
                                    try {
                                        ishandled = mView.dispatchPointerEvent((MotionEvent) mBackupEventList.get(i2));
                                        i2++;
                                    } catch (NullPointerException e2) {
                                        Log.e(ViewRootImpl.TAG, "mView does not exist, so discard the remaining points. " + e2);
                                    }
                                }
                            }
                            mCheckForGestureButton = false;
                            mGestureButtonActive = false;
                            mQueueMotionConsumed = true;
                        } else if (mHandler.hasMessages(ViewRootImpl.MSG_GESTURE_MOTION_DOWN)) {
                            mHandler.removeMessages(ViewRootImpl.MSG_GESTURE_MOTION_DOWN);
                            msg = Message.obtain(mHandler, ViewRootImpl.MSG_GESTURE_MOTION_DOWN, mView);
                            mQueueMotionConsumed = false;
                            mHandler.sendMessageDelayed(msg, (long) ViewRootImpl.GESTURE_MOTION_QUEUE_DELAY);
                        }
                        return 1;
                    } else if (mGestureButtonActive) {
                        return 1;
                    }
                    break;
            }
        }
    }
    mAttachInfo.mUnbufferedDispatchRequested = false;
    mAttachInfo.mHandlingPointerEvent = true;
    boolean handled = mView.dispatchPointerEvent(event);
    maybeUpdatePointerIcon(event);
    maybeUpdateTooltip(event);
    mAttachInfo.mHandlingPointerEvent = false;
    if (mAttachInfo.mUnbufferedDispatchRequested && !mUnbufferedInputDispatch) {
        mUnbufferedInputDispatch = true;
        if (mConsumeBatchedInputScheduled) {
            scheduleConsumeBatchedInputImmediately();
        }
    }
    return handled ? FINISH_HANDLED : FORWARD;
}
#method_after
private int processPointerEvent(QueuedInputEvent q) {
    final MotionEvent event = (MotionEvent) q.mEvent;
    int action;
    int i;
    int rotation;
    boolean isLandscape;
    float raw;
    boolean hit;
    if (mGestureButtonEnabled && !mIsKeyguard) {
        if (event.getPointerCount() == 1) {
            action = event.getActionMasked();
            rotation = 0;
            isLandscape = false;
            if (action == 0 || mCheckForGestureButton || mGestureButtonActive) {
                rotation = mAttachInfo.mDisplay.getRotation();
                isLandscape = rotation != 1 ? rotation == 3 : true;
            }
            Message msg;
            int i2;
            boolean ishandled;
            switch(action) {
                case MotionEvent.ACTION_DOWN:
                    mCheckForGestureButton = false;
                    mGestureButtonActive = false;
                    mQueueMotionConsumed = true;
                    mBackupEventList.clear();
                    if (isLandscape) {
                        raw = event.getRawX();
                    } else {
                        raw = event.getRawY();
                    }
                    if (rotation == 0 || rotation == 1) {
                        mGestureButtonZone = mScreenHeight - 20;
                        hit = raw > ((float) mGestureButtonZone);
                    } else {
                        mGestureButtonZone = 20;
                        hit = raw < ((float) mGestureButtonZone);
                    }
                    if (hit) {
                        mCheckForGestureButton = true;
                        mRawX = event.getRawX();
                        mRawY = event.getRawY();
                        mBackupEventList.add(MotionEvent.obtain(event));
                        msg = Message.obtain(mHandler, ViewRootImpl.MSG_GESTURE_MOTION_DOWN, mView);
                        mQueueMotionConsumed = false;
                        mHandler.sendMessageDelayed(msg, ViewRootImpl.GESTURE_MOTION_QUEUE_DELAY);
                        return 1;
                    }
                    break;
                case MotionEvent.ACTION_UP:
                case MotionEvent.ACTION_CANCEL:
                    if (!mGestureButtonActive) {
                        if (mCheckForGestureButton) {
                            if (mHandler.hasMessages(ViewRootImpl.MSG_GESTURE_MOTION_DOWN)) {
                                mHandler.removeMessages(ViewRootImpl.MSG_GESTURE_MOTION_DOWN);
                            }
                            if (!mQueueMotionConsumed) {
                                i2 = 0;
                                while (i2 < mBackupEventList.size()) {
                                    try {
                                        ishandled = mView.dispatchPointerEvent((MotionEvent) mBackupEventList.get(i2));
                                        i2++;
                                    } catch (NullPointerException e) {
                                        Log.e(ViewRootImpl.TAG, "mView does not exist, so discard the remaining points. " + e);
                                    }
                                }
                            }
                            mQueueMotionConsumed = true;
                            mCheckForGestureButton = false;
                            mGestureButtonActive = false;
                            break;
                        } else {
                            break;
                        }
                    }
                    mCheckForGestureButton = false;
                    mGestureButtonActive = false;
                    mQueueMotionConsumed = true;
                    return 1;
                case MotionEvent.ACTION_MOVE:
                    if (mCheckForGestureButton) {
                        mBackupEventList.add(MotionEvent.obtain(event));
                        boolean swipeTimeoSlow = false;
                        boolean reachDistance = false;
                        if (event.getEventTime() - event.getDownTime() > 400) {
                            swipeTimeoSlow = true;
                        }
                        float threshold = ViewRootImpl.GESTURE_KEY_DISTANCE_THRESHOLD;
                        if (rotation == 0 || rotation == 2) {
                            if (event.getRawX() > ((float) mOneThirdPart) && event.getRawX() < ((float) (mOneThirdPart * 2))) {
                                threshold = ViewRootImpl.GESTURE_KEY_LONG_CLICK_MOVE;
                            }
                            if (Math.abs(event.getRawY() - mRawY) > ((float) threshold)) {
                                reachDistance = true;
                            }
                        } else if (rotation == 1 || rotation == 3) {
                            if (event.getRawY() > ((float) mOneThirdPart) && event.getRawY() < ((float) (mOneThirdPart * 2))) {
                                threshold = ViewRootImpl.GESTURE_KEY_LONG_CLICK_MOVE;
                            }
                            if (Math.abs(event.getRawX() - mRawX) > ((float) threshold)) {
                                reachDistance = true;
                            }
                        }
                        if (reachDistance) {
                            mGestureButtonActive = true;
                            if (mHandler.hasMessages(ViewRootImpl.MSG_GESTURE_MOTION_DOWN)) {
                                mHandler.removeMessages(ViewRootImpl.MSG_GESTURE_MOTION_DOWN);
                            }
                            mCheckForGestureButton = false;
                            mQueueMotionConsumed = true;
                        } else if (reachDistance || swipeTimeoSlow) {
                            if (mHandler.hasMessages(ViewRootImpl.MSG_GESTURE_MOTION_DOWN)) {
                                mHandler.removeMessages(ViewRootImpl.MSG_GESTURE_MOTION_DOWN);
                            }
                            if (!mQueueMotionConsumed) {
                                i2 = 0;
                                while (i2 < mBackupEventList.size()) {
                                    try {
                                        ishandled = mView.dispatchPointerEvent((MotionEvent) mBackupEventList.get(i2));
                                        i2++;
                                    } catch (NullPointerException e2) {
                                        Log.e(ViewRootImpl.TAG, "mView does not exist, so discard the remaining points. " + e2);
                                    }
                                }
                            }
                            mCheckForGestureButton = false;
                            mGestureButtonActive = false;
                            mQueueMotionConsumed = true;
                        } else if (mHandler.hasMessages(ViewRootImpl.MSG_GESTURE_MOTION_DOWN)) {
                            mHandler.removeMessages(ViewRootImpl.MSG_GESTURE_MOTION_DOWN);
                            msg = Message.obtain(mHandler, ViewRootImpl.MSG_GESTURE_MOTION_DOWN, mView);
                            mQueueMotionConsumed = false;
                            mHandler.sendMessageDelayed(msg, (long) ViewRootImpl.GESTURE_MOTION_QUEUE_DELAY);
                        }
                        return 1;
                    } else if (mGestureButtonActive) {
                        return 1;
                    }
                    break;
            }
        }
    }
    mAttachInfo.mUnbufferedDispatchRequested = false;
    mAttachInfo.mHandlingPointerEvent = true;
    boolean handled = mView.dispatchPointerEvent(event);
    maybeUpdatePointerIcon(event);
    maybeUpdateTooltip(event);
    mAttachInfo.mHandlingPointerEvent = false;
    if (mAttachInfo.mUnbufferedDispatchRequested && !mUnbufferedInputDispatch) {
        mUnbufferedInputDispatch = true;
        if (mConsumeBatchedInputScheduled) {
            scheduleConsumeBatchedInputImmediately();
        }
    }
    return handled ? FINISH_HANDLED : FORWARD;
}
#end_block

#method_before
private void preloadRecentApps() {
    if (keyguardOn()) {
        return;
    }
    if (mOmniSwitchRecents) {
        OmniSwitchConstants.preloadOmniSwitchRecents(mContext, UserHandle.CURRENT);
        return;
    }
    mPreloadedRecentApps = true;
    StatusBarManagerInternal statusbar = getStatusBarManagerInternal();
    if (statusbar != null) {
        statusbar.preloadRecentApps();
    }
}
#method_after
protected void preloadRecentApps() {
    if (keyguardOn()) {
        return;
    }
    if (mOmniSwitchRecents) {
        OmniSwitchConstants.preloadOmniSwitchRecents(mContext, UserHandle.CURRENT);
        return;
    }
    mPreloadedRecentApps = true;
    StatusBarManagerInternal statusbar = getStatusBarManagerInternal();
    if (statusbar != null) {
        statusbar.preloadRecentApps();
    }
}
#end_block

#method_before
private void cancelPreloadRecentApps() {
    if (keyguardOn()) {
        return;
    }
    if (mOmniSwitchRecents) {
        return;
    }
    if (mPreloadedRecentApps) {
        mPreloadedRecentApps = false;
        StatusBarManagerInternal statusbar = getStatusBarManagerInternal();
        if (statusbar != null) {
            statusbar.cancelPreloadRecentApps();
        }
    }
}
#method_after
protected void cancelPreloadRecentApps() {
    if (keyguardOn()) {
        return;
    }
    if (mOmniSwitchRecents) {
        return;
    }
    if (mPreloadedRecentApps) {
        mPreloadedRecentApps = false;
        StatusBarManagerInternal statusbar = getStatusBarManagerInternal();
        if (statusbar != null) {
            statusbar.cancelPreloadRecentApps();
        }
    }
}
#end_block

#method_before
private void toggleRecentApps() {
    if (keyguardOn()) {
        return;
    }
    if (mOmniSwitchRecents) {
        OmniSwitchConstants.toggleOmniSwitchRecents(mContext, UserHandle.CURRENT);
    } else {
        // preloading no longer needs to be canceled
        mPreloadedRecentApps = false;
        StatusBarManagerInternal statusbar = getStatusBarManagerInternal();
        if (statusbar != null) {
            statusbar.toggleRecentApps();
        }
    }
}
#method_after
protected void toggleRecentApps() {
    if (keyguardOn()) {
        return;
    }
    if (mOmniSwitchRecents) {
        OmniSwitchConstants.toggleOmniSwitchRecents(mContext, UserHandle.CURRENT);
    } else {
        // preloading no longer needs to be canceled
        mPreloadedRecentApps = false;
        StatusBarManagerInternal statusbar = getStatusBarManagerInternal();
        if (statusbar != null) {
            statusbar.toggleRecentApps();
        }
    }
}
#end_block

#method_before
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_SEND_SWITCH_KEY:
            if (mSwipeStartFromEdge) {
                mLastKeyCode = 187;
                mSwipeStartFromEdge = false;
                mSwipeLongFireable = false;
                mPwm.performHapticFeedbackLw(null, 1, false);
                toggleRecentApps();
                break;
            }
        case MSG_SEND_KEY:
            mLastKeyCode = mPreparedKeycode;
            triggerGestureVirtualKeypress(mPreparedKeycode);
            mPwm.performHapticFeedbackLw(null, 1, false);
            break;
    }
}
#method_after
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_SEND_SWITCH_KEY:
            if (DEBUG)
                Slog.i(TAG, "MSG_SEND_SWITCH_KEY");
            mKeyEventHandled = true;
            mPwm.performHapticFeedbackLw(null, 1, false);
            toggleRecentApps();
            break;
        case MSG_SEND_KEY:
            if (DEBUG)
                Slog.i(TAG, "MSG_SEND_KEY " + mPreparedKeycode);
            mKeyEventHandled = true;
            triggerGestureVirtualKeypress(mPreparedKeycode);
            mPwm.performHapticFeedbackLw(null, 1, false);
            break;
    }
}
#end_block

#method_before
private void handleTouch(MotionEvent event) {
    if (isEnabled()) {
        int action = event.getActionMasked();
        if (action == 0 || mSwipeStartFromEdge) {
            float rawX = event.getRawX();
            float rawY = event.getRawY();
            switch(action) {
                case 0:
                    if (mNavigationBarPosition == 0) {
                        if (rawY >= ((float) (mScreenHeight - mSwipeStartThreshold))) {
                            mFromX = rawX;
                            mFromY = rawY;
                            if (mFromX < ((float) (mScreenWidth / 3)) || mFromX > ((float) ((mScreenWidth * 2) / 3))) {
                                mPreparedKeycode = 4;
                                if (!GESTURE_BUTTON_FOLLOW_FINGER && mFromX > ((float) ((mScreenWidth * 2) / 3))) {
                                    mPreparedKeycode = 187;
                                }
                            } else {
                                mPreparedKeycode = 3;
                            }
                        } else {
                            return;
                        }
                    } else if ((mNavigationBarPosition != 1 || rawX >= ((float) (mScreenHeight - mSwipeStartThreshold))) && (mNavigationBarPosition != 2 || rawX <= ((float) mSwipeStartThreshold))) {
                        mFromX = rawX;
                        mFromY = rawY;
                        if (mFromY < ((float) (mScreenWidth / 3)) || mFromY > ((float) ((mScreenWidth * 2) / 3))) {
                            mPreparedKeycode = 4;
                            if (!GESTURE_BUTTON_FOLLOW_FINGER && mFromX > ((float) ((mScreenWidth * 2) / 3))) {
                                mPreparedKeycode = 187;
                            }
                        } else {
                            mPreparedKeycode = 3;
                        }
                    } else {
                        return;
                    }
                    mSwipeStartFromEdge = true;
                    mIsKeyguardShowing = mPwm.mKeyguardDelegate != null ? mPwm.mKeyguardDelegate.isShowing() : false;
                    mLastY = mFromY;
                    mLastX = mFromX;
                    mDownTime = (float) event.getEventTime();
                    break;
                case 1:
                    mLongClick = false;
                    mGestureButtonMovingHome = false;
                    mGestureButtonHandler.removeMessages(MSG_SEND_SWITCH_KEY);
                    if (mSwipeLongFireable) {
                        mSwipeStartFromEdge = false;
                        if (mPreparedKeycode == 3) {
                            if (!mDismissInputMethod) {
                                dismissInputMethod();
                            }
                        }
                        mGestureButtonHandler.sendEmptyMessage(MSG_SEND_KEY);
                        break;
                    }
                    break;
                case 2:
                    if (!mLongClick) {
                        float moveDistance;
                        if (mNavigationBarPosition == 0) {
                            moveDistance = Math.abs(mFromY - rawY);
                        } else {
                            moveDistance = Math.abs(mFromX - rawX);
                        }
                        long delta = event.getEventTime() - event.getDownTime();
                        if (moveDistance < ((float) GESTURE_KEY_LONG_CLICK_MOVE)) {
                            if (delta > ((long) GESTURE_KEY_LONG_CLICK_TIMEOUT)) {
                                mLongClick = true;
                                break;
                            }
                        }
                        if (mNavigationBarPosition == 0) {
                            if (Math.abs(mFromY - rawY) <= ((float) GESTURE_KEY_DISTANCE_THRESHOLD)) {
                                mGestureButtonHandler.removeMessages(MSG_SEND_SWITCH_KEY);
                                mSwipeLongFireable = false;
                            } else if (mPreparedKeycode == 4) {
                                mSwipeStartFromEdge = false;
                                if (((float) event.getEventTime()) - mDownTime < 400.0f) {
                                    mGestureButtonHandler.sendEmptyMessage(MSG_SEND_KEY);
                                }
                                return;
                            } else {
                                mSwipeLongFireable = true;
                                if (Math.abs(mLastY - rawY) > mRecentMoveTolerance) {
                                    mGestureButtonHandler.removeMessages(MSG_SEND_SWITCH_KEY);
                                    mGestureButtonHandler.sendEmptyMessageDelayed(MSG_SEND_SWITCH_KEY, (long) GESTURE_KEY_DISTANCE_TIMEOUT);
                                }
                            }
                        } else if (Math.abs(mFromX - rawX) <= ((float) GESTURE_KEY_DISTANCE_THRESHOLD)) {
                            mGestureButtonHandler.removeMessages(MSG_SEND_SWITCH_KEY);
                            mSwipeLongFireable = false;
                        } else if (mPreparedKeycode == 4) {
                            mSwipeStartFromEdge = false;
                            if (((float) event.getEventTime()) - mDownTime < 400.0f) {
                                mGestureButtonHandler.sendEmptyMessage(MSG_SEND_KEY);
                            }
                            return;
                        } else {
                            mSwipeLongFireable = true;
                            if (Math.abs(mLastX - rawX) > mRecentMoveTolerance) {
                                mGestureButtonHandler.removeMessages(MSG_SEND_SWITCH_KEY);
                                mGestureButtonHandler.sendEmptyMessageDelayed(MSG_SEND_SWITCH_KEY, (long) GESTURE_KEY_DISTANCE_TIMEOUT);
                            }
                        }
                        mLastX = rawX;
                        mLastY = rawY;
                        break;
                    } else if (mLongClick && mPreparedKeycode == 3) {
                        mGestureButtonHandler.removeMessages(MSG_SEND_SWITCH_KEY);
                        mGestureButtonHandler.sendEmptyMessageDelayed(MSG_SEND_SWITCH_KEY, (long) GESTURE_KEY_DISTANCE_TIMEOUT);
                        mPreparedKeycode = 0;
                        mLongClick = false;
                    }
                    break;
                case 3:
                    break;
                default:
                    break;
            }
        // mSwipeStartFromEdge = false;
        // mSwipeLongFireable = false;
        }
    }
}
#method_after
private void handleTouch(MotionEvent event) {
    if (isEnabled()) {
        int action = event.getActionMasked();
        if (action == MotionEvent.ACTION_DOWN || mSwipeStartFromEdge) {
            float rawX = event.getRawX();
            float rawY = event.getRawY();
            switch(action) {
                case MotionEvent.ACTION_DOWN:
                    if (mNavigationBarPosition == 0) {
                        if (rawY >= ((float) (mScreenHeight - mSwipeStartThreshold))) {
                            mFromX = rawX;
                            mFromY = rawY;
                            if (mFromX < ((float) (mScreenWidth / 3)) || mFromX > ((float) ((mScreenWidth * 2) / 3))) {
                                mPreparedKeycode = KeyEvent.KEYCODE_BACK;
                            } else {
                                mPreparedKeycode = KeyEvent.KEYCODE_HOME;
                            }
                        } else {
                            return;
                        }
                    } else if ((mNavigationBarPosition != 1 || rawX >= ((float) (mScreenHeight - mSwipeStartThreshold))) && (mNavigationBarPosition != 2 || rawX <= ((float) mSwipeStartThreshold))) {
                        mFromX = rawX;
                        mFromY = rawY;
                        if (mFromY < ((float) (mScreenWidth / 3)) || mFromY > ((float) ((mScreenWidth * 2) / 3))) {
                            mPreparedKeycode = KeyEvent.KEYCODE_BACK;
                        } else {
                            mPreparedKeycode = KeyEvent.KEYCODE_HOME;
                        }
                    } else {
                        return;
                    }
                    mIsKeyguardShowing = mPwm.mKeyguardDelegate != null ? mPwm.mKeyguardDelegate.isShowing() : false;
                    mLastY = mFromY;
                    mLastX = mFromX;
                    mDownTime = event.getEventTime();
                    mSwipeStartFromEdge = true;
                    mKeyEventHandled = false;
                    mRecentsTriggered = false;
                    mLongSwipePossible = false;
                    if (DEBUG)
                        Slog.i(TAG, "ACTION_DOWN " + mPreparedKeycode);
                    break;
                case MotionEvent.ACTION_UP:
                    if (DEBUG)
                        Slog.i(TAG, "ACTION_UP " + mPreparedKeycode + " " + mRecentsTriggered + " " + mKeyEventHandled + " " + mLongSwipePossible);
                    mGestureButtonHandler.removeMessages(MSG_SEND_SWITCH_KEY);
                    cancelPreloadRecentApps();
                    if (!mKeyEventHandled && mLongSwipePossible) {
                        if (mPreparedKeycode == KeyEvent.KEYCODE_HOME) {
                            if (!mDismissInputMethod) {
                                dismissInputMethod();
                            }
                        }
                        mGestureButtonHandler.sendEmptyMessage(MSG_SEND_KEY);
                    }
                    mSwipeStartFromEdge = false;
                    mKeyEventHandled = false;
                    mRecentsTriggered = false;
                    mLongSwipePossible = false;
                    break;
                case MotionEvent.ACTION_MOVE:
                    if (!mKeyEventHandled && !mRecentsTriggered) {
                        float moveDistanceSinceDown;
                        if (mNavigationBarPosition == 0) {
                            moveDistanceSinceDown = Math.abs(mFromY - rawY);
                        } else {
                            moveDistanceSinceDown = Math.abs(mFromX - rawX);
                        }
                        float moveDistanceSinceLast;
                        if (mNavigationBarPosition == 0) {
                            moveDistanceSinceLast = Math.abs(mLastY - rawY);
                        } else {
                            moveDistanceSinceLast = Math.abs(mLastX - rawX);
                        }
                        long deltaSinceDown = event.getEventTime() - mDownTime;
                        if (moveDistanceSinceDown < GESTURE_KEY_LONG_CLICK_MOVE) {
                            if (deltaSinceDown > GESTURE_KEY_LONG_CLICK_TIMEOUT && !mRecentsTriggered) {
                                mRecentsTriggered = true;
                                preloadRecentApps();
                                mGestureButtonHandler.removeMessages(MSG_SEND_SWITCH_KEY);
                                mGestureButtonHandler.sendEmptyMessage(MSG_SEND_SWITCH_KEY);
                            }
                        }
                        if (moveDistanceSinceDown > GESTURE_KEY_DISTANCE_THRESHOLD) {
                            mLongSwipePossible = true;
                            if (mPreparedKeycode == KeyEvent.KEYCODE_BACK) {
                            // TODO should back be triggered already while move? so without up
                            // mGestureButtonHandler.sendEmptyMessage(MSG_SEND_KEY);
                            } else if (!mRecentsTriggered) {
                                // swipe comes to an stop
                                if (moveDistanceSinceLast < mRecentMoveTolerance) {
                                    mRecentsTriggered = true;
                                    preloadRecentApps();
                                    mGestureButtonHandler.removeMessages(MSG_SEND_SWITCH_KEY);
                                    mGestureButtonHandler.sendEmptyMessageDelayed(MSG_SEND_SWITCH_KEY, GESTURE_KEY_DISTANCE_TIMEOUT);
                                }
                            }
                        }
                        mLastX = rawX;
                        mLastY = rawY;
                    }
                    break;
                case MotionEvent.ACTION_CANCEL:
                    break;
                default:
                    break;
            }
        }
    }
}
#end_block

#method_before
private void toggleRecentApps() {
    StatusBarManagerInternal statusbar = mPwm.getStatusBarManagerInternal();
    if (statusbar != null && mPwm.isUserSetupComplete()) {
        statusbar.toggleRecentApps();
    }
}
#method_after
private void toggleRecentApps() {
    mPwm.toggleRecentApps();
}
#end_block

#method_before
private void triggerGestureVirtualKeypress(int keyCode) {
    InputManager im = InputManager.getInstance();
    long now = SystemClock.uptimeMillis();
    KeyEvent downEvent = new KeyEvent(now, now, KeyEvent.ACTION_DOWN, keyCode, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_FROM_SYSTEM, InputDevice.SOURCE_CLASS_BUTTON);
    KeyEvent upEvent = KeyEvent.changeAction(downEvent, KeyEvent.ACTION_UP);
    im.injectInputEvent(downEvent, 0);
    im.injectInputEvent(upEvent, 0);
}
#method_after
private void triggerGestureVirtualKeypress(int keyCode) {
    OmniUtils.sendKeycode(keyCode);
}
#end_block

#method_before
private void updateSettings() {
    int mQsBackGroundAlpha = Settings.System.getIntForUser(getContext().getContentResolver(), Settings.System.QS_PANEL_BG_ALPHA, 216, UserHandle.USER_CURRENT);
    mQsBackGround.setAlpha(mQsBackGroundAlpha);
    setBackground(mQsBackGround);
}
#method_after
private void updateSettings() {
    int mQsBackGroundAlpha = Settings.System.getIntForUser(getContext().getContentResolver(), Settings.System.QS_PANEL_BG_ALPHA, 221, UserHandle.USER_CURRENT);
    mQsBackGround.setAlpha(mQsBackGroundAlpha);
    setBackground(mQsBackGround);
}
#end_block

#method_before
public void onKeyguardShowingChanged() {
    mShowIndicator = Settings.Secure.getIntForUser(mContext.getContentResolver(), Settings.Secure.LOCK_HIDE_INDICATOR_DISPLAY, 0, UserHandle.USER_CURRENT) == 0;
    updateLeftAffordance();
    updateRightAffordance();
    inflateCameraPreview();
    mIndicationController.setVisibleOverwrite(mShowIndicator);
}
#method_after
public void onKeyguardShowingChanged() {
    mShowIndicator = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.HIDE_LOCKSCREEN_INDICATOR_DISPLAY, 0, UserHandle.USER_CURRENT) == 0;
    updateLeftAffordance();
    updateRightAffordance();
    inflateCameraPreview();
    mIndicationController.setVisibleOverwrite(mShowIndicator);
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    String packageName;
    switch(msg.what) {
        case MESSAGE_INITIALIZE_MAP:
            initializeFontMap();
            break;
        case MESSAGE_CHANGE_FONT:
            final FontInfo info = (FontInfo) msg.obj;
            applyFontsPriv(info);
            break;
        case MESSAGE_PACKAGE_ADDED_OR_UPDATED:
            packageName = (String) msg.obj;
            if (PackageUtils.isAvailableApp(packageName, mContext)) {
                // Only process the event if the package is an available app
                boolean isFontProvider = isPackageFontProvider(packageName);
                if (isFontProvider) {
                    Log.e(TAG, packageName + " was added or updated. Adding or updating fonts");
                    synchronized (mFontMap) {
                        processFontPackage(packageName);
                    }
                }
                break;
            }
        // is not an available app, i.e. disabled
        case MESSAGE_PACKAGE_REMOVED:
            packageName = (String) msg.obj;
            boolean hadFonts = mFontMap.containsKey(packageName);
            if (hadFonts) {
                synchronized (mFontMap) {
                    Log.e(TAG, packageName + " was removed. Clearing fonts from provider map");
                    removeFontPackage(packageName);
                }
                // if removed package provided current font, reset to system
                if (TextUtils.equals(packageName, mFontInfo.packageName)) {
                    Log.e(TAG, packageName + " provided the current font. Restoring to system font");
                    applyFontsPriv(FontInfo.getDefaultFontInfo());
                }
            }
            break;
        default:
            Log.w(TAG, "Unknown message " + msg.what);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    String packageName;
    switch(msg.what) {
        case MESSAGE_INITIALIZE_MAP:
            initializeFontMap();
            break;
        case MESSAGE_CHANGE_FONT:
            final FontInfo info = (FontInfo) msg.obj;
            applyFontsPriv(info);
            break;
        case MESSAGE_PACKAGE_ADDED_OR_UPDATED:
            packageName = (String) msg.obj;
            boolean isFontProvider = isPackageFontProvider(packageName);
            if (isFontProvider) {
                Log.e(TAG, packageName + " was added or updated. Adding or updating fonts");
                synchronized (mFontMap) {
                    processFontPackage(packageName);
                }
                break;
            }
        // is not a font provider, in case it needs cleanup
        case MESSAGE_PACKAGE_REMOVED:
            packageName = (String) msg.obj;
            boolean hadFonts = mFontMap.containsKey(packageName);
            if (hadFonts) {
                synchronized (mFontMap) {
                    Log.e(TAG, packageName + " was removed. Clearing fonts from provider map");
                    removeFontPackage(packageName);
                }
                // if removed package provided current font, reset to system
                if (TextUtils.equals(packageName, mFontInfo.packageName)) {
                    Log.e(TAG, packageName + " provided the current font. Restoring to system font");
                    applyFontsPriv(FontInfo.getDefaultFontInfo());
                }
            }
            break;
        default:
            Log.w(TAG, "Unknown message " + msg.what);
            break;
    }
}
#end_block

#method_before
@Override
public View getView(int position, View convertView, ViewGroup parent) {
    ViewHolder listViewHolder;
    if (convertView == null) {
        listViewHolder = new ViewHolder();
        convertView = layoutinflater.inflate(R.layout.app_grid_view_item, parent, false);
        listViewHolder.imageInListView = (ImageView) convertView.findViewById(R.id.appIcon);
        convertView.setTag(listViewHolder);
    } else {
        listViewHolder = (ViewHolder) convertView.getTag();
    }
    try {
        ComponentName componentName = ComponentName.unflattenFromString((String) appList[position]);
        Drawable icon = mPm.getActivityIcon(componentName);
        listViewHolder.imageInListView.setImageDrawable(icon);
    } catch (PackageManager.NameNotFoundException e) {
        Log.e(TAG, "Set app icon", e);
    }
    return convertView;
}
#method_after
@Override
public View getView(int position, View convertView, ViewGroup parent) {
    ViewHolder listViewHolder;
    if (convertView == null) {
        listViewHolder = new ViewHolder();
        convertView = layoutinflater.inflate(R.layout.app_grid_item, parent, false);
        listViewHolder.imageInListView = (ImageView) convertView.findViewById(R.id.appIcon);
        convertView.setTag(listViewHolder);
    } else {
        listViewHolder = (ViewHolder) convertView.getTag();
    }
    try {
        ComponentName componentName = ComponentName.unflattenFromString((String) appList[position]);
        Drawable icon = mPm.getActivityIcon(componentName);
        listViewHolder.imageInListView.setImageDrawable(icon);
    } catch (PackageManager.NameNotFoundException e) {
        Log.e(TAG, "Set app icon", e);
    }
    return convertView;
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.event_service_settings);
    mEnable = (SwitchPreference) findPreference(EVENT_SERVICE_ENABLED);
    mEnable.setChecked(getPrefs().getBoolean(EventServiceSettings.EVENT_SERVICE_ENABLED, false));
    mEnable.setOnPreferenceChangeListener(this);
    mServiceRunning = getResources().getString(R.string.event_service_running);
    mServiceStopped = getResources().getString(R.string.event_service_stopped);
    mEnable.setSummary(isServiceRunning() ? mServiceRunning : mServiceStopped);
    mAutoStart = (SwitchPreference) findPreference(EVENT_MEDIA_PLAYER_START);
    mAutoStart.setChecked(getPrefs().getBoolean(EventServiceSettings.EVENT_MEDIA_PLAYER_START, false));
    mAutoStart.setOnPreferenceChangeListener(this);
    mMusicActive = (SwitchPreference) findPreference(EVENT_MUSIC_ACTIVE);
    mMusicActive.setChecked(getPrefs().getBoolean(EventServiceSettings.EVENT_MUSIC_ACTIVE, false));
    mMusicActive.setOnPreferenceChangeListener(this);
    mAutorun = (SwitchPreference) findPreference(EVENT_AUTORUN_SINGLE);
    mAutorun.setChecked(getPrefs().getBoolean(EventServiceSettings.EVENT_AUTORUN_SINGLE, false));
    mAutorun.setOnPreferenceChangeListener(this);
    mA2DPappSelect = (AppMultiSelectListPreference) findPreference(EVENT_A2DP_CONNECT);
    mEnable.setChecked(getPrefs().getBoolean(EventServiceSettings.EVENT_SERVICE_ENABLED, false));
    String value = getPrefs().getString(EVENT_A2DP_CONNECT, null);
    if (value != null)
        mA2DPappSelect.setValues(SetStringPackUtils.unpackString(value));
    mA2DPappSelect.setOnPreferenceChangeListener(this);
    mWiredHeadsetAppSelect = (AppMultiSelectListPreference) findPreference(EVENT_WIRED_HEADSET_CONNECT);
    value = getPrefs().getString(EVENT_WIRED_HEADSET_CONNECT, null);
    if (value != null)
        mWiredHeadsetAppSelect.setValues(SetStringPackUtils.unpackString(value));
    mWiredHeadsetAppSelect.setOnPreferenceChangeListener(this);
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.event_service_settings);
    // -- For backward compatibility
    String old_value = getPrefs().getString(OLD_EVENT_A2DP_CONNECT, null);
    if (old_value != null) {
        fixOldPreference(OLD_EVENT_A2DP_CONNECT, EVENT_A2DP_CONNECT, old_value);
    }
    old_value = getPrefs().getString(OLD_EVENT_WIRED_HEADSET_CONNECT, null);
    if (old_value != null) {
        fixOldPreference(OLD_EVENT_WIRED_HEADSET_CONNECT, EVENT_WIRED_HEADSET_CONNECT, old_value);
    }
    // -- End backward compatibility
    mEnable = (SwitchPreference) findPreference(EVENT_SERVICE_ENABLED);
    mEnable.setChecked(getPrefs().getBoolean(EventServiceSettings.EVENT_SERVICE_ENABLED, false));
    mEnable.setOnPreferenceChangeListener(this);
    mServiceRunning = getResources().getString(R.string.event_service_running);
    mServiceStopped = getResources().getString(R.string.event_service_stopped);
    mEnable.setSummary(isServiceRunning() ? mServiceRunning : mServiceStopped);
    mAutoStart = (SwitchPreference) findPreference(EVENT_MEDIA_PLAYER_START);
    mAutoStart.setChecked(getPrefs().getBoolean(EventServiceSettings.EVENT_MEDIA_PLAYER_START, false));
    mAutoStart.setOnPreferenceChangeListener(this);
    mMusicActive = (SwitchPreference) findPreference(EVENT_MUSIC_ACTIVE);
    mMusicActive.setChecked(getPrefs().getBoolean(EventServiceSettings.EVENT_MUSIC_ACTIVE, false));
    mMusicActive.setOnPreferenceChangeListener(this);
    mAutorun = (SwitchPreference) findPreference(EVENT_AUTORUN_SINGLE);
    mAutorun.setChecked(getPrefs().getBoolean(EventServiceSettings.EVENT_AUTORUN_SINGLE, true));
    mAutorun.setOnPreferenceChangeListener(this);
    mA2DPappSelect = (AppMultiSelectListPreference) findPreference(EVENT_A2DP_CONNECT);
    Set<String> value = getPrefs().getStringSet(EVENT_A2DP_CONNECT, null);
    if (value != null)
        mA2DPappSelect.setValues(value);
    mA2DPappSelect.setOnPreferenceChangeListener(this);
    mA2DPApps = (ScrollAppsViewPreference) findPreference(A2DP_APP_LIST);
    if (value == null) {
        mA2DPApps.setVisible(false);
    } else {
        mA2DPApps.setVisible(true);
        mA2DPApps.setValues(value);
    }
    mWiredHeadsetAppSelect = (AppMultiSelectListPreference) findPreference(EVENT_WIRED_HEADSET_CONNECT);
    value = getPrefs().getStringSet(EVENT_WIRED_HEADSET_CONNECT, null);
    if (value != null)
        mWiredHeadsetAppSelect.setValues(value);
    mWiredHeadsetAppSelect.setOnPreferenceChangeListener(this);
    mHeadsetApps = (ScrollAppsViewPreference) findPreference(HEADSET_APP_LIST);
    if (value == null) {
        mHeadsetApps.setVisible(false);
    } else {
        mHeadsetApps.setValues(value);
        mHeadsetApps.setVisible(true);
    }
}
#end_block

#method_before
@Override
public boolean onPreferenceChange(Preference preference, Object newValue) {
    if (preference == mA2DPappSelect) {
        Set<String> value = (Set<String>) newValue;
        getPrefs().edit().putString(EVENT_A2DP_CONNECT, value != null ? SetStringPackUtils.packSet(value) : null).commit();
        return true;
    } else if (preference == mWiredHeadsetAppSelect) {
        Set<String> value = (Set<String>) newValue;
        getPrefs().edit().putString(EVENT_WIRED_HEADSET_CONNECT, value != null ? SetStringPackUtils.packSet(value) : null).commit();
        return true;
    } else if (preference == mEnable) {
        boolean value = ((Boolean) newValue).booleanValue();
        if (value) {
            getActivity().startService(new Intent(getActivity(), EventService.class));
        } else {
            getActivity().stopService(new Intent(getActivity(), EventService.class));
        }
        getPrefs().edit().putBoolean(EVENT_SERVICE_ENABLED, value).commit();
        mHandler.postDelayed(new Runnable() {

            @Override
            public void run() {
                try {
                    mEnable.setSummary(isServiceRunning() ? mServiceRunning : mServiceStopped);
                } catch (Exception e) {
                }
            }
        }, 1000);
        return true;
    } else if (preference == mAutoStart) {
        boolean value = ((Boolean) newValue).booleanValue();
        getPrefs().edit().putBoolean(EVENT_MEDIA_PLAYER_START, value).commit();
        return true;
    } else if (preference == mMusicActive) {
        boolean value = ((Boolean) newValue).booleanValue();
        getPrefs().edit().putBoolean(EVENT_MUSIC_ACTIVE, value).commit();
        return true;
    } else if (preference == mAutorun) {
        boolean value = ((Boolean) newValue).booleanValue();
        getPrefs().edit().putBoolean(EVENT_AUTORUN_SINGLE, value).commit();
        return true;
    }
    return false;
}
#method_after
@Override
public boolean onPreferenceChange(Preference preference, Object newValue) {
    if (preference == mA2DPappSelect) {
        Set<String> value = (Set<String>) newValue;
        getPrefs().edit().putStringSet(EVENT_A2DP_CONNECT, value).commit();
        mA2DPApps.setVisible(false);
        if (value != null) {
            mA2DPApps.setValues(value);
            mA2DPApps.setVisible(true);
        }
        return true;
    } else if (preference == mWiredHeadsetAppSelect) {
        Set<String> value = (Set<String>) newValue;
        getPrefs().edit().putStringSet(EVENT_WIRED_HEADSET_CONNECT, value).commit();
        mHeadsetApps.setVisible(false);
        if (value != null) {
            mHeadsetApps.setValues(value);
            mHeadsetApps.setVisible(true);
        }
        return true;
    } else if (preference == mEnable) {
        boolean value = ((Boolean) newValue).booleanValue();
        if (value) {
            getActivity().startService(new Intent(getActivity(), EventService.class));
        } else {
            getActivity().stopService(new Intent(getActivity(), EventService.class));
        }
        getPrefs().edit().putBoolean(EVENT_SERVICE_ENABLED, value).commit();
        mHandler.postDelayed(new Runnable() {

            @Override
            public void run() {
                try {
                    mEnable.setSummary(isServiceRunning() ? mServiceRunning : mServiceStopped);
                } catch (Exception e) {
                }
            }
        }, 1000);
        return true;
    } else if (preference == mAutoStart) {
        boolean value = ((Boolean) newValue).booleanValue();
        getPrefs().edit().putBoolean(EVENT_MEDIA_PLAYER_START, value).commit();
        return true;
    } else if (preference == mMusicActive) {
        boolean value = ((Boolean) newValue).booleanValue();
        getPrefs().edit().putBoolean(EVENT_MUSIC_ACTIVE, value).commit();
        return true;
    } else if (preference == mAutorun) {
        boolean value = ((Boolean) newValue).booleanValue();
        getPrefs().edit().putBoolean(EVENT_AUTORUN_SINGLE, value).commit();
        return true;
    }
    return false;
}
#end_block

#method_before
public void setValues(Collection<String> values) {
    mValues.clear();
    mValues.addAll(values);
}
#method_after
public void setValues(Set<String> values) {
    mValues.clear();
    mValues.addAll(values);
}
#end_block

#method_before
@Override
protected void onDialogClosed(boolean positiveResult) {
    super.onDialogClosed(positiveResult);
    callChangeListener(mValues.size() > 0 ? mValues : null);
}
#method_after
@Override
protected void onDialogClosed(boolean positiveResult) {
    super.onDialogClosed(positiveResult);
    if (positiveResult) {
        callChangeListener(mValues.size() > 0 ? mValues : null);
    }
}
#end_block

#method_before
public static String packSet(Set<String> values) {
    StringBuilder builder = new StringBuilder();
    String delimiter = "";
    for (String value : values) {
        builder.append(delimiter);
        builder.append(value);
        delimiter = "|";
    }
    return builder.toString();
}
#method_after
public static String packSet(Set<String> values) {
    return TextUtils.join("|", values);
}
#end_block

#method_before
private void openMultiAppSelector(String apps, Context context) {
    Intent intent = new Intent(context, MultiAppSelectorActivity.class);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    intent.putExtra(MultiAppSelectorActivity.APPS, apps);
    intent.putExtra(MultiAppSelectorActivity.AUTORUN_SINGLE, getPrefs(context).getBoolean(EventServiceSettings.EVENT_AUTORUN_SINGLE, true));
    intent.putExtra(MultiAppSelectorActivity.MEDIA_PLAYER_START, getPrefs(context).getBoolean(EventServiceSettings.EVENT_MEDIA_PLAYER_START, false));
    startActivityAsUser(intent, UserHandle.CURRENT);
}
#method_after
private void openMultiAppSelector(Set<String> apps, Context context) {
    Intent intent = new Intent(context, MultiAppSelectorActivity.class);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    intent.putExtra(MultiAppSelectorActivity.APPS, SetStringPackUtils.packSet(apps));
    intent.putExtra(MultiAppSelectorActivity.AUTORUN_SINGLE, getPrefs(context).getBoolean(EventServiceSettings.EVENT_AUTORUN_SINGLE, true));
    intent.putExtra(MultiAppSelectorActivity.MEDIA_PLAYER_START, getPrefs(context).getBoolean(EventServiceSettings.EVENT_MEDIA_PLAYER_START, false));
    startActivityAsUser(intent, UserHandle.CURRENT);
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    requestWindowFeature(Window.FEATURE_NO_TITLE);
    setContentView(R.layout.multi_app_selector);
    Intent intent = getIntent();
    mediaStart = intent.getBooleanExtra(MEDIA_PLAYER_START, false);
    autoRun = intent.getBooleanExtra(AUTORUN_SINGLE, false);
    appList = SetStringPackUtils.unpackString(intent.getStringExtra(APPS)).toArray();
    gridview = (GridView) findViewById(R.id.app_grid_view);
    gridview.setAdapter(new AppGridAdapter(MultiAppSelectorActivity.this, appList));
    gridview.setOnItemClickListener(new AdapterView.OnItemClickListener() {

        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            openApp((String) appList[position]);
        }
    });
    if (autoRun && appList.length == 1) {
        // If there is only one app open it
        openApp((String) appList[0]);
    }
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    requestWindowFeature(Window.FEATURE_NO_TITLE);
    setContentView(R.layout.app_grid_view);
    Intent intent = getIntent();
    mediaStart = intent.getBooleanExtra(MEDIA_PLAYER_START, false);
    autoRun = intent.getBooleanExtra(AUTORUN_SINGLE, false);
    appList = SetStringPackUtils.unpackString(intent.getStringExtra(APPS)).toArray();
    gridview = (GridView) findViewById(R.id.app_grid_view);
    gridview.setAdapter(new AppGridAdapter(MultiAppSelectorActivity.this, appList));
    gridview.setOnItemClickListener(new AdapterView.OnItemClickListener() {

        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            openApp((String) appList[position]);
        }
    });
    if (autoRun && appList.length == 1) {
        // If there is only one app open it
        openApp((String) appList[0]);
    }
}
#end_block

#method_before
private void mapIconSets() {
    mNetworkToIconLookup.clear();
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_0, TelephonyIcons.THREE_G);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_A, TelephonyIcons.THREE_G);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_B, TelephonyIcons.THREE_G);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EHRPD, TelephonyIcons.THREE_G);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UMTS, TelephonyIcons.THREE_G);
    if (!mConfig.showAtLeast3G) {
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UNKNOWN, TelephonyIcons.UNKNOWN);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EDGE, TelephonyIcons.E);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_CDMA, TelephonyIcons.ONE_X);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_1xRTT, TelephonyIcons.ONE_X);
        mDefaultIcons = TelephonyIcons.G;
    } else {
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UNKNOWN, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EDGE, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_CDMA, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_1xRTT, TelephonyIcons.THREE_G);
        mDefaultIcons = TelephonyIcons.THREE_G;
    }
    MobileIconGroup hGroup = TelephonyIcons.THREE_G;
    if (mConfig.hspaDataDistinguishable) {
        hGroup = TelephonyIcons.H;
    }
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSDPA, hGroup);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSUPA, hGroup);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSPA, hGroup);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSPAP, hGroup);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_DC_HSPAP, hGroup);
    if (mConfig.show4gForLte) {
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE, TelephonyIcons.FOUR_G);
        if (mConfig.hideLtePlus) {
            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE_CA, TelephonyIcons.FOUR_G);
        } else {
            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE_CA, TelephonyIcons.FOUR_G_PLUS);
        }
    } else {
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE, TelephonyIcons.LTE);
        if (mConfig.hideLtePlus) {
            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE_CA, TelephonyIcons.LTE);
        } else {
            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE_CA, TelephonyIcons.LTE_PLUS);
        }
    }
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_IWLAN, TelephonyIcons.WFC);
}
#method_after
private void mapIconSets() {
    mNetworkToIconLookup.clear();
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_0, TelephonyIcons.THREE_G);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_A, TelephonyIcons.THREE_G);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_B, TelephonyIcons.THREE_G);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EHRPD, TelephonyIcons.THREE_G);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UMTS, TelephonyIcons.THREE_G);
    if (!mConfig.showAtLeast3G) {
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UNKNOWN, TelephonyIcons.UNKNOWN);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EDGE, TelephonyIcons.E);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_CDMA, TelephonyIcons.ONE_X);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_1xRTT, TelephonyIcons.ONE_X);
        mDefaultIcons = TelephonyIcons.G;
    } else {
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UNKNOWN, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EDGE, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_CDMA, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_1xRTT, TelephonyIcons.THREE_G);
        mDefaultIcons = TelephonyIcons.THREE_G;
    }
    MobileIconGroup hGroup = TelephonyIcons.THREE_G;
    if (mConfig.hspaDataDistinguishable) {
        hGroup = TelephonyIcons.H;
    }
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSDPA, hGroup);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSUPA, hGroup);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSPA, hGroup);
    if (mConfig.hspaDataDistinguishable) {
        hGroup = TelephonyIcons.HP;
    }
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSPAP, hGroup);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_DC_HSPAP, hGroup);
    if (mConfig.show4gForLte) {
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE, TelephonyIcons.FOUR_G);
        if (mConfig.hideLtePlus) {
            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE_CA, TelephonyIcons.FOUR_G);
        } else {
            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE_CA, TelephonyIcons.FOUR_G_PLUS);
        }
    } else {
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE, TelephonyIcons.LTE);
        if (mConfig.hideLtePlus) {
            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE_CA, TelephonyIcons.LTE);
        } else {
            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE_CA, TelephonyIcons.LTE_PLUS);
        }
    }
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_IWLAN, TelephonyIcons.WFC);
}
#end_block

#method_before
public void updateSettings() {
    mQsSecureExpandDisabled = Settings.Secure.getIntForUser(mContext.getContentResolver(), Settings.Secure.LOCK_QS_DISABLED, 0, UserHandle.USER_CURRENT) != 0;
}
#method_after
public void updateSettings() {
    mQsSecureExpandDisabled = Settings.Secure.getIntForUser(mContext.getContentResolver(), Settings.Secure.LOCK_QS_DISABLED, 0, UserHandle.USER_CURRENT) != 0;
    mOneFingerQuickSettingsIntercept = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.STATUS_BAR_QUICK_QS_PULLDOWN, 0, UserHandle.USER_CURRENT);
}
#end_block

#method_before
void observe() {
    mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.DOUBLE_TAP_SLEEP_GESTURE), false, this, UserHandle.USER_ALL);
    mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_RECENTS), false, this, UserHandle.USER_ALL);
    mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.BUTTON_LONG_PRESS_RECENTS), false, this, UserHandle.USER_ALL);
    mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.LOCKSCREEN_ROTATION), false, this, UserHandle.USER_ALL);
    mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_SHOW), false, this, UserHandle.USER_ALL);
    mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.LOCKSCREEN_HIDE_MEDIA_METADATA), false, this, UserHandle.USER_ALL);
    mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.SYSTEM_UI_THEME), false, this, UserHandle.USER_ALL);
    mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.DOUBLE_TAP_SLEEP_LOCKSCREEN), false, this, UserHandle.USER_ALL);
    mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.FORCE_AMBIENT_FOR_MEDIA), false, this, UserHandle.USER_ALL);
    mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.LOCK_QS_DISABLED), false, this, UserHandle.USER_ALL);
}
#method_after
void observe() {
    mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.DOUBLE_TAP_SLEEP_GESTURE), false, this, UserHandle.USER_ALL);
    mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_RECENTS), false, this, UserHandle.USER_ALL);
    mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.BUTTON_LONG_PRESS_RECENTS), false, this, UserHandle.USER_ALL);
    mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.LOCKSCREEN_ROTATION), false, this, UserHandle.USER_ALL);
    mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_SHOW), false, this, UserHandle.USER_ALL);
    mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.LOCKSCREEN_HIDE_MEDIA_METADATA), false, this, UserHandle.USER_ALL);
    mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.SYSTEM_UI_THEME), false, this, UserHandle.USER_ALL);
    mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.DOUBLE_TAP_SLEEP_LOCKSCREEN), false, this, UserHandle.USER_ALL);
    mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.FORCE_AMBIENT_FOR_MEDIA), false, this, UserHandle.USER_ALL);
    mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.LOCK_QS_DISABLED), false, this, UserHandle.USER_ALL);
    mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_QUICK_QS_PULLDOWN), false, this, UserHandle.USER_ALL);
}
#end_block

#method_before
@Override
public void start() {
    mNetworkController = Dependency.get(NetworkController.class);
    mUserSwitcherController = Dependency.get(UserSwitcherController.class);
    mScreenLifecycle = Dependency.get(ScreenLifecycle.class);
    mScreenLifecycle.addObserver(mScreenObserver);
    mWakefulnessLifecycle = Dependency.get(WakefulnessLifecycle.class);
    mWakefulnessLifecycle.addObserver(mWakefulnessObserver);
    mBatteryController = Dependency.get(BatteryController.class);
    mAssistManager = Dependency.get(AssistManager.class);
    mSystemServicesProxy = SystemServicesProxy.getInstance(mContext);
    mOverlayManager = IOverlayManager.Stub.asInterface(ServiceManager.getService(Context.OVERLAY_SERVICE));
    mColorExtractor = Dependency.get(SysuiColorExtractor.class);
    mColorExtractor.addOnColorsChangedListener(this);
    mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
    mForegroundServiceController = Dependency.get(ForegroundServiceController.class);
    mDisplay = mWindowManager.getDefaultDisplay();
    updateDisplaySize();
    Resources res = mContext.getResources();
    mScrimSrcModeEnabled = res.getBoolean(R.bool.config_status_bar_scrim_behind_use_src);
    mClearAllEnabled = res.getBoolean(R.bool.config_enableNotificationsClearAll);
    mAlwaysExpandNonGroupedNotification = res.getBoolean(R.bool.config_alwaysExpandNonGroupedNotifications);
    DateTimeView.setReceiverHandler(Dependency.get(Dependency.TIME_TICK_HANDLER));
    putComponent(StatusBar.class, this);
    // start old BaseStatusBar.start().
    mWindowManagerService = WindowManagerGlobal.getWindowManagerService();
    mDevicePolicyManager = (DevicePolicyManager) mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
    mNotificationData = new NotificationData(this);
    mMessagingUtil = new NotificationMessagingUtil(mContext);
    mAccessibilityManager = (AccessibilityManager) mContext.getSystemService(Context.ACCESSIBILITY_SERVICE);
    mPowerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mDeviceProvisionedController = Dependency.get(DeviceProvisionedController.class);
    mDeviceProvisionedController.addCallback(mDeviceProvisionedListener);
    mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.ZEN_MODE), false, mSettingsObserver);
    mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.LOCK_SCREEN_SHOW_NOTIFICATIONS), false, mLockscreenSettingsObserver, UserHandle.USER_ALL);
    if (ENABLE_LOCK_SCREEN_ALLOW_REMOTE_INPUT) {
        mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.LOCK_SCREEN_ALLOW_REMOTE_INPUT), false, mSettingsObserver, UserHandle.USER_ALL);
    }
    mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.LOCK_SCREEN_ALLOW_PRIVATE_NOTIFICATIONS), true, mLockscreenSettingsObserver, UserHandle.USER_ALL);
    mBarService = IStatusBarService.Stub.asInterface(ServiceManager.getService(Context.STATUS_BAR_SERVICE));
    mRecents = getComponent(Recents.class);
    final Configuration currentConfig = res.getConfiguration();
    mLocale = currentConfig.locale;
    mLayoutDirection = TextUtils.getLayoutDirectionFromLocale(mLocale);
    mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
    mKeyguardManager = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
    mLockPatternUtils = new LockPatternUtils(mContext);
    // Connect in to the status bar manager service
    mCommandQueue = getComponent(CommandQueue.class);
    mCommandQueue.addCallbacks(this);
    int[] switches = new int[9];
    ArrayList<IBinder> binders = new ArrayList<>();
    ArrayList<String> iconSlots = new ArrayList<>();
    ArrayList<StatusBarIcon> icons = new ArrayList<>();
    Rect fullscreenStackBounds = new Rect();
    Rect dockedStackBounds = new Rect();
    try {
        mBarService.registerStatusBar(mCommandQueue, iconSlots, icons, switches, binders, fullscreenStackBounds, dockedStackBounds);
    } catch (RemoteException ex) {
    // If the system process isn't there we're doomed anyway.
    }
    createAndAddWindows();
    // set up
    mSettingsObserver.onChange(false);
    mCustomSettingsObserver.observe();
    mCustomSettingsObserver.update();
    mCommandQueue.disable(switches[0], switches[6], false);
    setSystemUiVisibility(switches[1], switches[7], switches[8], 0xffffffff, fullscreenStackBounds, dockedStackBounds);
    topAppWindowChanged(switches[2] != 0);
    // StatusBarManagerService has a back up of IME token and it's restored here.
    setImeWindowStatus(binders.get(0), switches[3], switches[4], switches[5] != 0);
    // Set up the initial icon state
    int N = iconSlots.size();
    for (int i = 0; i < N; i++) {
        mCommandQueue.setIcon(iconSlots.get(i), icons.get(i));
    }
    // Set up the initial notification state.
    try {
        mNotificationListener.registerAsSystemService(mContext, new ComponentName(mContext.getPackageName(), getClass().getCanonicalName()), UserHandle.USER_ALL);
    } catch (RemoteException e) {
        Log.e(TAG, "Unable to register notification listener", e);
    }
    if (DEBUG) {
        Log.d(TAG, String.format("init: icons=%d disabled=0x%08x lights=0x%08x menu=0x%08x imeButton=0x%08x", icons.size(), switches[0], switches[1], switches[2], switches[3]));
    }
    mCurrentUserId = ActivityManager.getCurrentUser();
    setHeadsUpUser(mCurrentUserId);
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    filter.addAction(Intent.ACTION_USER_ADDED);
    filter.addAction(Intent.ACTION_USER_PRESENT);
    mContext.registerReceiver(mBaseBroadcastReceiver, filter);
    IntentFilter internalFilter = new IntentFilter();
    internalFilter.addAction(NOTIFICATION_UNLOCKED_BY_WORK_CHALLENGE_ACTION);
    internalFilter.addAction(BANNER_ACTION_CANCEL);
    internalFilter.addAction(BANNER_ACTION_SETUP);
    mContext.registerReceiver(mBaseBroadcastReceiver, internalFilter, PERMISSION_SELF, null);
    IntentFilter allUsersFilter = new IntentFilter();
    allUsersFilter.addAction(DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED);
    allUsersFilter.addAction(Intent.ACTION_DEVICE_LOCKED_CHANGED);
    mContext.registerReceiverAsUser(mAllUsersReceiver, UserHandle.ALL, allUsersFilter, null, null);
    updateCurrentProfilesCache();
    IVrManager vrManager = IVrManager.Stub.asInterface(ServiceManager.getService(Context.VR_SERVICE));
    try {
        vrManager.registerListener(mVrStateCallbacks);
    } catch (RemoteException e) {
        Slog.e(TAG, "Failed to register VR mode state listener: " + e);
    }
    mNonBlockablePkgs = new HashSet<>();
    Collections.addAll(mNonBlockablePkgs, res.getStringArray(com.android.internal.R.array.config_nonBlockableNotificationPackages));
    // end old BaseStatusBar.start().
    mMediaSessionManager = (MediaSessionManager) mContext.getSystemService(Context.MEDIA_SESSION_SERVICE);
    // TODO: use MediaSessionManager.SessionListener to hook us up to future updates
    // in session state
    // Lastly, call to the icon policy to install/update all the icons.
    mIconPolicy = new PhoneStatusBarPolicy(mContext, mIconController);
    // set up
    mSettingsObserver.onChange(false);
    // set up
    mHeadsUpObserver.onChange(true);
    if (ENABLE_HEADS_UP) {
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.HEADS_UP_NOTIFICATIONS_ENABLED), true, mHeadsUpObserver);
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(SETTING_HEADS_UP_TICKER), true, mHeadsUpObserver);
    }
    mUnlockMethodCache = UnlockMethodCache.getInstance(mContext);
    mUnlockMethodCache.addListener(this);
    startKeyguard();
    KeyguardUpdateMonitor.getInstance(mContext).registerCallback(mUpdateCallback);
    putComponent(DozeHost.class, mDozeServiceHost);
    notifyUserAboutHiddenNotifications();
    mScreenPinningRequest = new ScreenPinningRequest(mContext);
    mFalsingManager = FalsingManager.getInstance(mContext);
    Dependency.get(ActivityStarterDelegate.class).setActivityStarterImpl(this);
    Dependency.get(ConfigurationController.class).addCallback(this);
    mOmniSettingsObserver = new OmniSettingsObserver(mHandler);
    mOmniSettingsObserver.observe();
    mOmniSettingsObserver.update();
    setForceAmbient();
}
#method_after
@Override
public void start() {
    mNetworkController = Dependency.get(NetworkController.class);
    mUserSwitcherController = Dependency.get(UserSwitcherController.class);
    mScreenLifecycle = Dependency.get(ScreenLifecycle.class);
    mScreenLifecycle.addObserver(mScreenObserver);
    mWakefulnessLifecycle = Dependency.get(WakefulnessLifecycle.class);
    mWakefulnessLifecycle.addObserver(mWakefulnessObserver);
    mBatteryController = Dependency.get(BatteryController.class);
    mAssistManager = Dependency.get(AssistManager.class);
    mSystemServicesProxy = SystemServicesProxy.getInstance(mContext);
    mOverlayManager = IOverlayManager.Stub.asInterface(ServiceManager.getService(Context.OVERLAY_SERVICE));
    mColorExtractor = Dependency.get(SysuiColorExtractor.class);
    mColorExtractor.addOnColorsChangedListener(this);
    mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
    mForegroundServiceController = Dependency.get(ForegroundServiceController.class);
    mDisplay = mWindowManager.getDefaultDisplay();
    updateDisplaySize();
    Resources res = mContext.getResources();
    mScrimSrcModeEnabled = res.getBoolean(R.bool.config_status_bar_scrim_behind_use_src);
    mClearAllEnabled = res.getBoolean(R.bool.config_enableNotificationsClearAll);
    mAlwaysExpandNonGroupedNotification = res.getBoolean(R.bool.config_alwaysExpandNonGroupedNotifications);
    DateTimeView.setReceiverHandler(Dependency.get(Dependency.TIME_TICK_HANDLER));
    putComponent(StatusBar.class, this);
    // start old BaseStatusBar.start().
    mWindowManagerService = WindowManagerGlobal.getWindowManagerService();
    mDevicePolicyManager = (DevicePolicyManager) mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
    mNotificationData = new NotificationData(this);
    mMessagingUtil = new NotificationMessagingUtil(mContext);
    mAccessibilityManager = (AccessibilityManager) mContext.getSystemService(Context.ACCESSIBILITY_SERVICE);
    mPowerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mDeviceProvisionedController = Dependency.get(DeviceProvisionedController.class);
    mDeviceProvisionedController.addCallback(mDeviceProvisionedListener);
    mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.ZEN_MODE), false, mSettingsObserver);
    mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.LOCK_SCREEN_SHOW_NOTIFICATIONS), false, mLockscreenSettingsObserver, UserHandle.USER_ALL);
    if (ENABLE_LOCK_SCREEN_ALLOW_REMOTE_INPUT) {
        mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.LOCK_SCREEN_ALLOW_REMOTE_INPUT), false, mSettingsObserver, UserHandle.USER_ALL);
    }
    mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.LOCK_SCREEN_ALLOW_PRIVATE_NOTIFICATIONS), true, mLockscreenSettingsObserver, UserHandle.USER_ALL);
    mBarService = IStatusBarService.Stub.asInterface(ServiceManager.getService(Context.STATUS_BAR_SERVICE));
    mRecents = getComponent(Recents.class);
    final Configuration currentConfig = res.getConfiguration();
    mLocale = currentConfig.locale;
    mLayoutDirection = TextUtils.getLayoutDirectionFromLocale(mLocale);
    mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
    mKeyguardManager = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
    mLockPatternUtils = new LockPatternUtils(mContext);
    // Connect in to the status bar manager service
    mCommandQueue = getComponent(CommandQueue.class);
    mCommandQueue.addCallbacks(this);
    int[] switches = new int[9];
    ArrayList<IBinder> binders = new ArrayList<>();
    ArrayList<String> iconSlots = new ArrayList<>();
    ArrayList<StatusBarIcon> icons = new ArrayList<>();
    Rect fullscreenStackBounds = new Rect();
    Rect dockedStackBounds = new Rect();
    try {
        mBarService.registerStatusBar(mCommandQueue, iconSlots, icons, switches, binders, fullscreenStackBounds, dockedStackBounds);
    } catch (RemoteException ex) {
    // If the system process isn't there we're doomed anyway.
    }
    createAndAddWindows();
    // set up
    mSettingsObserver.onChange(false);
    mCommandQueue.disable(switches[0], switches[6], false);
    setSystemUiVisibility(switches[1], switches[7], switches[8], 0xffffffff, fullscreenStackBounds, dockedStackBounds);
    topAppWindowChanged(switches[2] != 0);
    // StatusBarManagerService has a back up of IME token and it's restored here.
    setImeWindowStatus(binders.get(0), switches[3], switches[4], switches[5] != 0);
    // Set up the initial icon state
    int N = iconSlots.size();
    for (int i = 0; i < N; i++) {
        mCommandQueue.setIcon(iconSlots.get(i), icons.get(i));
    }
    // Set up the initial notification state.
    try {
        mNotificationListener.registerAsSystemService(mContext, new ComponentName(mContext.getPackageName(), getClass().getCanonicalName()), UserHandle.USER_ALL);
    } catch (RemoteException e) {
        Log.e(TAG, "Unable to register notification listener", e);
    }
    if (DEBUG) {
        Log.d(TAG, String.format("init: icons=%d disabled=0x%08x lights=0x%08x menu=0x%08x imeButton=0x%08x", icons.size(), switches[0], switches[1], switches[2], switches[3]));
    }
    mCurrentUserId = ActivityManager.getCurrentUser();
    setHeadsUpUser(mCurrentUserId);
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    filter.addAction(Intent.ACTION_USER_ADDED);
    filter.addAction(Intent.ACTION_USER_PRESENT);
    mContext.registerReceiver(mBaseBroadcastReceiver, filter);
    IntentFilter internalFilter = new IntentFilter();
    internalFilter.addAction(NOTIFICATION_UNLOCKED_BY_WORK_CHALLENGE_ACTION);
    internalFilter.addAction(BANNER_ACTION_CANCEL);
    internalFilter.addAction(BANNER_ACTION_SETUP);
    mContext.registerReceiver(mBaseBroadcastReceiver, internalFilter, PERMISSION_SELF, null);
    IntentFilter allUsersFilter = new IntentFilter();
    allUsersFilter.addAction(DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED);
    allUsersFilter.addAction(Intent.ACTION_DEVICE_LOCKED_CHANGED);
    mContext.registerReceiverAsUser(mAllUsersReceiver, UserHandle.ALL, allUsersFilter, null, null);
    updateCurrentProfilesCache();
    IVrManager vrManager = IVrManager.Stub.asInterface(ServiceManager.getService(Context.VR_SERVICE));
    try {
        vrManager.registerListener(mVrStateCallbacks);
    } catch (RemoteException e) {
        Slog.e(TAG, "Failed to register VR mode state listener: " + e);
    }
    mNonBlockablePkgs = new HashSet<>();
    Collections.addAll(mNonBlockablePkgs, res.getStringArray(com.android.internal.R.array.config_nonBlockableNotificationPackages));
    // end old BaseStatusBar.start().
    mMediaSessionManager = (MediaSessionManager) mContext.getSystemService(Context.MEDIA_SESSION_SERVICE);
    // TODO: use MediaSessionManager.SessionListener to hook us up to future updates
    // in session state
    // Lastly, call to the icon policy to install/update all the icons.
    mIconPolicy = new PhoneStatusBarPolicy(mContext, mIconController);
    // set up
    mSettingsObserver.onChange(false);
    // set up
    mHeadsUpObserver.onChange(true);
    if (ENABLE_HEADS_UP) {
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.HEADS_UP_NOTIFICATIONS_ENABLED), true, mHeadsUpObserver);
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(SETTING_HEADS_UP_TICKER), true, mHeadsUpObserver);
    }
    mUnlockMethodCache = UnlockMethodCache.getInstance(mContext);
    mUnlockMethodCache.addListener(this);
    startKeyguard();
    KeyguardUpdateMonitor.getInstance(mContext).registerCallback(mUpdateCallback);
    putComponent(DozeHost.class, mDozeServiceHost);
    notifyUserAboutHiddenNotifications();
    mScreenPinningRequest = new ScreenPinningRequest(mContext);
    mFalsingManager = FalsingManager.getInstance(mContext);
    Dependency.get(ActivityStarterDelegate.class).setActivityStarterImpl(this);
    Dependency.get(ConfigurationController.class).addCallback(this);
    mOmniSettingsObserver = new OmniSettingsObserver(mHandler);
    mOmniSettingsObserver.observe();
    mOmniSettingsObserver.update();
    setForceAmbient();
}
#end_block

#method_before
public Builder addExtras(Bundle extras) {
    if (extras != null) {
        mUserExtras.putAll(extras);
    }
    return this;
}
#method_after
public Builder addExtras(Bundle extras) {
    if (extras != null) {
        mExtras.putAll(extras);
    }
    return this;
}
#end_block

#method_before
public Bundle getExtras() {
    return mUserExtras;
}
#method_after
public Bundle getExtras() {
    return mExtras;
}
#end_block

#method_before
public UnreadConversation build() {
    String[] messages = mMessages.toArray(new String[mMessages.size()]);
    String[] participants = { mParticipant };
    return new UnreadConversation(messages, mRemoteInput, mReplyPendingIntent, mReadPendingIntent, participants, mLatestTimestamp);
}
#method_after
public Action build() {
    ArrayList<RemoteInput> dataOnlyInputs = new ArrayList<>();
    RemoteInput[] previousDataInputs = (RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS);
    if (previousDataInputs != null) {
        for (RemoteInput input : previousDataInputs) {
            dataOnlyInputs.add(input);
        }
    }
    List<RemoteInput> textInputs = new ArrayList<>();
    if (mRemoteInputs != null) {
        for (RemoteInput input : mRemoteInputs) {
            if (input.isDataOnly()) {
                dataOnlyInputs.add(input);
            } else {
                textInputs.add(input);
            }
        }
    }
    if (!dataOnlyInputs.isEmpty()) {
        RemoteInput[] dataInputsArr = dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]);
        mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr);
    }
    RemoteInput[] textInputsArr = textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]);
    return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies);
}
#end_block

#method_before
@Override
public WearableExtender clone() {
    WearableExtender that = new WearableExtender();
    that.mActions = new ArrayList<Action>(this.mActions);
    that.mFlags = this.mFlags;
    that.mDisplayIntent = this.mDisplayIntent;
    that.mPages = new ArrayList<Notification>(this.mPages);
    that.mBackground = this.mBackground;
    that.mContentIcon = this.mContentIcon;
    that.mContentIconGravity = this.mContentIconGravity;
    that.mContentActionIndex = this.mContentActionIndex;
    that.mCustomSizePreset = this.mCustomSizePreset;
    that.mCustomContentHeight = this.mCustomContentHeight;
    that.mGravity = this.mGravity;
    that.mHintScreenTimeout = this.mHintScreenTimeout;
    that.mDismissalId = this.mDismissalId;
    that.mBridgeTag = this.mBridgeTag;
    return that;
}
#method_after
@Override
public WearableExtender clone() {
    WearableExtender that = new WearableExtender();
    that.mFlags = this.mFlags;
    that.mInProgressLabel = this.mInProgressLabel;
    that.mConfirmLabel = this.mConfirmLabel;
    that.mCancelLabel = this.mCancelLabel;
    return that;
}
#end_block

#method_before
public UnreadConversation build() {
    String[] messages = mMessages.toArray(new String[mMessages.size()]);
    String[] participants = { mParticipant };
    return new UnreadConversation(messages, mRemoteInput, mReplyPendingIntent, mReadPendingIntent, participants, mLatestTimestamp);
}
#method_after
public Notification build() {
    // first, add any extras from the calling code
    if (mUserExtras != null) {
        mN.extras = getAllExtras();
    }
    mN.creationTime = System.currentTimeMillis();
    // lazy stuff from mContext; see comment in Builder(Context, Notification)
    Notification.addFieldsFromContext(mContext, mN);
    buildUnstyled();
    if (mStyle != null) {
        mStyle.reduceImageSizes(mContext);
        mStyle.purgeResources();
        mStyle.buildStyled(mN);
    }
    mN.reduceImageSizes(mContext);
    if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N && (useExistingRemoteView())) {
        if (mN.contentView == null) {
            mN.contentView = createContentView();
            mN.extras.putInt(EXTRA_REBUILD_CONTENT_VIEW_ACTION_COUNT, mN.contentView.getSequenceNumber());
        }
        if (mN.bigContentView == null) {
            mN.bigContentView = createBigContentView();
            if (mN.bigContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_BIG_CONTENT_VIEW_ACTION_COUNT, mN.bigContentView.getSequenceNumber());
            }
        }
        if (mN.headsUpContentView == null) {
            mN.headsUpContentView = createHeadsUpContentView();
            if (mN.headsUpContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_HEADS_UP_CONTENT_VIEW_ACTION_COUNT, mN.headsUpContentView.getSequenceNumber());
            }
        }
    }
    if ((mN.defaults & DEFAULT_LIGHTS) != 0) {
        mN.flags |= FLAG_SHOW_LIGHTS;
    }
    return mN;
}
#end_block

#method_before
public void deleteSyntheticPasswordState(int userId, long handle, String name) {
    String path = getSynthenticPasswordStateFilePathForUser(userId, handle, name);
    File file = new File(path);
    if (file.exists()) {
        try {
            if (mSkipSecDiscard) {
                mContext.getSystemService(StorageManager.class).secdiscard(file.getAbsolutePath());
            }
        } catch (Exception e) {
            Slog.w(TAG, "Failed to secdiscard " + path, e);
        } finally {
            file.delete();
        }
        mCache.putFile(path, null);
    }
}
#method_after
public void deleteSyntheticPasswordState(int userId, long handle, String name) {
    String path = getSynthenticPasswordStateFilePathForUser(userId, handle, name);
    File file = new File(path);
    if (file.exists()) {
        try {
            if (mSecDiscard) {
                mContext.getSystemService(StorageManager.class).secdiscard(file.getAbsolutePath());
            }
        } catch (Exception e) {
            Slog.w(TAG, "Failed to secdiscard " + path, e);
        } finally {
            file.delete();
        }
        mCache.putFile(path, null);
    }
}
#end_block

#method_before
private void backLongPress() {
    mBackKeyHandled = true;
    if (isStopLockTaskMode() == false) {
        // no longer possible
        mHandler.removeCallbacks(mBackLongPress);
        return;
    }
    switch(mLongPressOnBackBehavior) {
        case LONG_PRESS_BACK_NOTHING:
            break;
        case LONG_PRESS_BACK_GO_TO_VOICE_ASSIST:
            final boolean keyguardActive = mKeyguardDelegate == null ? false : mKeyguardDelegate.isShowing();
            if (!keyguardActive) {
                Intent intent = new Intent(Intent.ACTION_VOICE_ASSIST);
                startActivityAsUser(intent, UserHandle.CURRENT_OR_SELF);
            }
            break;
    }
}
#method_after
private void backLongPress() {
    mBackKeyHandled = true;
    if (isStopLockTaskMode(false)) {
        // no longer possible
        mHandler.removeCallbacks(mBackLongPress);
        return;
    }
    switch(mLongPressOnBackBehavior) {
        case LONG_PRESS_BACK_NOTHING:
            break;
        case LONG_PRESS_BACK_GO_TO_VOICE_ASSIST:
            final boolean keyguardActive = mKeyguardDelegate == null ? false : mKeyguardDelegate.isShowing();
            if (!keyguardActive) {
                Intent intent = new Intent(Intent.ACTION_VOICE_ASSIST);
                startActivityAsUser(intent, UserHandle.CURRENT_OR_SELF);
            }
            break;
    }
}
#end_block

#method_before
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    mHasFeatureLeanback = mContext.getPackageManager().hasSystemFeature(FEATURE_LEANBACK);
    mAccessibilityShortcutController = new AccessibilityShortcutController(mContext, new Handler(), mCurrentUserId);
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getDefaultDisplayRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mVrHeadsetHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mVrHeadsetHomeIntent.addCategory(Intent.CATEGORY_VR_HOME);
    mVrHeadsetHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mPanicPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_backPanicBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mHandleVolumeKeysInWM = mContext.getResources().getBoolean(com.android.internal.R.bool.config_handleVolumeKeysInWindowManager);
    boolean debugInputOverride = SystemProperties.getBoolean("debug.inputEvent", false);
    DEBUG_INPUT = DEBUG_INPUT || debugInputOverride;
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mBackKillTimeoutConfig = mContext.getResources().getInteger(com.android.internal.R.integer.config_backKillTimeout);
    readConfigurationDependentBehaviors();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromLeft() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerHint.INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mScreenrecordChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenrecordChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
    mWindowManagerInternal.registerAppTransitionListener(new AppTransitionListener() {

        @Override
        public int onAppTransitionStartingLocked(int transit, IBinder openToken, IBinder closeToken, Animation openAnimation, Animation closeAnimation) {
            return handleStartTransitionForKeyguardLw(transit, openAnimation);
        }

        @Override
        public void onAppTransitionCancelledLocked(int transit) {
            handleStartTransitionForKeyguardLw(transit, null);
        }
    });
    mKeyguardDelegate = new KeyguardServiceDelegate(mContext, new StateCallback() {

        @Override
        public void onTrustedChanged() {
            mWindowManagerFuncs.notifyKeyguardTrustedChanged();
        }
    });
    String deviceKeyHandlerLib = mContext.getResources().getString(com.android.internal.R.string.config_deviceKeyHandlerLib);
    String deviceKeyHandlerClass = mContext.getResources().getString(com.android.internal.R.string.config_deviceKeyHandlerClass);
    if (!deviceKeyHandlerLib.isEmpty() && !deviceKeyHandlerClass.isEmpty()) {
        try {
            PathClassLoader loader = new PathClassLoader(deviceKeyHandlerLib, getClass().getClassLoader());
            Class<?> klass = loader.loadClass(deviceKeyHandlerClass);
            Constructor<?> constructor = klass.getConstructor(Context.class);
            mDeviceKeyHandler = (DeviceKeyHandler) constructor.newInstance(mContext);
            mDeviceKeyHandler.setWindowManagerPolicy(this);
            if (DEBUG)
                Slog.d(TAG, "Device key handler loaded");
        } catch (Exception e) {
            Slog.w(TAG, "Could not instantiate device key handler " + deviceKeyHandlerClass + " from class " + deviceKeyHandlerLib, e);
        }
    }
}
#method_after
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    mHasFeatureLeanback = mContext.getPackageManager().hasSystemFeature(FEATURE_LEANBACK);
    mAccessibilityShortcutController = new AccessibilityShortcutController(mContext, new Handler(), mCurrentUserId);
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getDefaultDisplayRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mVrHeadsetHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mVrHeadsetHomeIntent.addCategory(Intent.CATEGORY_VR_HOME);
    mVrHeadsetHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mPanicPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_backPanicBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mHandleVolumeKeysInWM = mContext.getResources().getBoolean(com.android.internal.R.bool.config_handleVolumeKeysInWindowManager);
    boolean debugInputOverride = SystemProperties.getBoolean("debug.inputEvent", false);
    DEBUG_INPUT = DEBUG_INPUT || debugInputOverride;
    mBackKillTimeoutConfig = mContext.getResources().getInteger(com.android.internal.R.integer.config_backKillTimeout);
    readConfigurationDependentBehaviors();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromLeft() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerHint.INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mScreenrecordChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenrecordChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
    mWindowManagerInternal.registerAppTransitionListener(new AppTransitionListener() {

        @Override
        public int onAppTransitionStartingLocked(int transit, IBinder openToken, IBinder closeToken, Animation openAnimation, Animation closeAnimation) {
            return handleStartTransitionForKeyguardLw(transit, openAnimation);
        }

        @Override
        public void onAppTransitionCancelledLocked(int transit) {
            handleStartTransitionForKeyguardLw(transit, null);
        }
    });
    mKeyguardDelegate = new KeyguardServiceDelegate(mContext, new StateCallback() {

        @Override
        public void onTrustedChanged() {
            mWindowManagerFuncs.notifyKeyguardTrustedChanged();
        }
    });
    String deviceKeyHandlerLib = mContext.getResources().getString(com.android.internal.R.string.config_deviceKeyHandlerLib);
    String deviceKeyHandlerClass = mContext.getResources().getString(com.android.internal.R.string.config_deviceKeyHandlerClass);
    if (!deviceKeyHandlerLib.isEmpty() && !deviceKeyHandlerClass.isEmpty()) {
        try {
            PathClassLoader loader = new PathClassLoader(deviceKeyHandlerLib, getClass().getClassLoader());
            Class<?> klass = loader.loadClass(deviceKeyHandlerClass);
            Constructor<?> constructor = klass.getConstructor(Context.class);
            mDeviceKeyHandler = (DeviceKeyHandler) constructor.newInstance(mContext);
            mDeviceKeyHandler.setWindowManagerPolicy(this);
            if (DEBUG)
                Slog.d(TAG, "Device key handler loaded");
        } catch (Exception e) {
            Slog.w(TAG, "Could not instantiate device key handler " + deviceKeyHandlerClass + " from class " + deviceKeyHandlerLib, e);
        }
    }
}
#end_block

#method_before
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    final int scanCode = event.getScanCode();
    // if mHardwareKeysDisable is true we have disabled all button rebindings
    // so we can be sure that events that are !virtuaKey are only for real buttons
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean isVirtualHardKey = (flags & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0;
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled + " virtualKey=" + virtualKey + " scanCode=" + scanCode + " longPress=" + longPress + " isVirtualHardKey=" + isVirtualHardKey);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mScreenshotChordVolumeDownKeyTriggered && !mScreenshotChordPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
    }
    // try again later before dispatching.
    if (mScreenrecordChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mScreenrecordChordVolumeUpKeyTriggered && !mScreenshotChordPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mScreenrecordChordVolumeUpKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mScreenrecordChordVolumeUpKeyConsumed) {
            if (!down) {
                mScreenrecordChordVolumeUpKeyConsumed = false;
            }
            return -1;
        }
    }
    // know if it is complete or not
    if (mAccessibilityShortcutController.isAccessibilityShortcutAvailable(false) && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mScreenshotChordVolumeDownKeyTriggered ^ mA11yShortcutChordVolumeUpKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = (mScreenshotChordVolumeDownKeyTriggered ? mScreenshotChordVolumeDownKeyTime : mA11yShortcutChordVolumeUpKeyTime) + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mA11yShortcutChordVolumeUpKeyConsumed) {
            if (!down) {
                mA11yShortcutChordVolumeUpKeyConsumed = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // Any key that is not Alt or Meta cancels Caps Lock combo tracking.
    if (mPendingCapsLockToggle && !KeyEvent.isMetaKey(keyCode) && !KeyEvent.isAltKey(keyCode)) {
        mPendingCapsLockToggle = false;
    }
    if (keyCode == KeyEvent.KEYCODE_BACK && !down) {
        mHandler.removeCallbacks(mBackLongPress);
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down) {
            cancelPreloadRecentApps();
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehaviorCustom != DOUBLE_TAP_HOME_NOTHING) {
                mEventDeviceId = event.getDeviceId();
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            handleShortPressOnHome();
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            mHomePressed = true;
            if (mOmniSwitchRecents) {
                OmniSwitchConstants.hideOmniSwitchRecents(mContext, UserHandle.CURRENT);
            }
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                handleDoubleTapOnHome();
            } else if (mLongPressOnHomeBehaviorCustom == KEY_ACTION_APP_SWITCH || mDoubleTapOnHomeBehaviorCustom == KEY_ACTION_APP_SWITCH || mDoubleTapOnHomeBehaviorCustom == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
                preloadRecentApps();
            }
        } else if ((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
            if (!keyguardOn) {
                handleLongPressOnHome(event.getDeviceId());
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        if (!virtualKey) {
            if (down) {
                if (repeatCount == 0) {
                    if (isCustomKeyAction(keyCode)) {
                        doDownKeyAction(getCustomKeyAction(keyCode));
                        mDoCustomAction = true;
                        return -1;
                    }
                    doDownKeyAction(KEY_ACTION_MENU);
                }
            } else {
                if (doUpKeyAction(keyCode, canceled) == -1) {
                    return -1;
                }
            }
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (!keyguardOn) {
            if (down) {
                if (repeatCount == 0) {
                    if (isCustomKeyAction(keyCode)) {
                        doDownKeyAction(getCustomKeyAction(keyCode));
                        mDoCustomAction = true;
                        return -1;
                    }
                    doDownKeyAction(KEY_ACTION_APP_SWITCH);
                }
            } else {
                if (doUpKeyAction(keyCode, canceled) == -1) {
                    return -1;
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (!virtualKey) {
            if (down) {
                if (repeatCount == 0) {
                    if (isCustomKeyAction(keyCode)) {
                        doDownKeyAction(getCustomKeyAction(keyCode));
                        mDoCustomAction = true;
                        return -1;
                    }
                    doDownKeyAction(KEY_ACTION_BACK);
                }
            } else {
                if (doUpKeyAction(keyCode, canceled) == -1) {
                    return -1;
                }
            // back action is simple to continue and pass further
            }
        } else if (isVirtualHardKey && mBackKillEnabled && isStopLockTaskMode()) {
            // back kill called from navbar back button
            if (down) {
                if (repeatCount == 0) {
                    mHandler.postDelayed(mBackLongPress, mBackKillTimeout);
                }
            } else {
                mHandler.removeCallbacks(mBackLongPress);
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_N && event.isMetaPressed()) {
        if (down) {
            IStatusBarService service = getStatusBarService();
            if (service != null) {
                try {
                    service.expandNotificationsPanel();
                } catch (RemoteException e) {
                // do nothing.
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_S && event.isMetaPressed() && event.isCtrlPressed()) {
        if (down && repeatCount == 0) {
            int type = event.isShiftPressed() ? TAKE_SCREENSHOT_SELECTED_REGION : TAKE_SCREENSHOT_FULLSCREEN;
            mScreenshotRunnable.setScreenshotType(type);
            mHandler.post(mScreenshotRunnable);
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_SLASH && event.isMetaPressed()) {
        if (down && repeatCount == 0 && !isKeyguardLocked()) {
            toggleKeyboardShortcutsMenu(event.getDeviceId());
        }
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (repeatCount == 1) {
                mAssistKeyLongPressed = true;
                if (!keyguardOn) {
                    launchAssistLongPressAction();
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (!keyguardOn) {
                    launchAssistAction(null, event.getDeviceId());
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        if (!down) {
            Intent voiceIntent;
            if (!keyguardOn) {
                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
            } else {
                IDeviceIdleController dic = IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
                if (dic != null) {
                    try {
                        dic.exitIdle("voice-search");
                    } catch (RemoteException e) {
                    }
                }
                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
            }
            startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
        }
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_FULLSCREEN);
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
        if (mUseTvRouting || mHandleVolumeKeysInWM) {
            // On TVs or when the configuration is enabled, volume keys never
            // go to the foreground app.
            dispatchDirectAudioEvent(event);
            return -1;
        }
        // forward it to the application/dispatch the audio event.
        if (mPersistentVrModeEnabled) {
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_TAB && event.isMetaPressed()) {
        // Pass through keyboard navigation keys.
        return 0;
    } else if (mHasFeatureLeanback && interceptBugreportGestureTv(keyCode, down)) {
        return -1;
    } else if (mHasFeatureLeanback && interceptAccessibilityGestureTv(keyCode, down)) {
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_ALL_APPS) {
        if (!down) {
            mHandler.removeMessages(MSG_HANDLE_ALL_APPS);
            Message msg = mHandler.obtainMessage(MSG_HANDLE_ALL_APPS);
            msg.setAsynchronous(true);
            msg.sendToTarget();
        }
        return -1;
    }
    // Toggle Caps Lock on META-ALT.
    boolean actionTriggered = false;
    if (KeyEvent.isModifierKey(keyCode)) {
        if (!mPendingCapsLockToggle) {
            // Start tracking meta state for combo.
            mInitialMetaState = mMetaState;
            mPendingCapsLockToggle = true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            int altOnMask = mMetaState & KeyEvent.META_ALT_MASK;
            int metaOnMask = mMetaState & KeyEvent.META_META_MASK;
            // Check for Caps Lock toggle
            if ((metaOnMask != 0) && (altOnMask != 0)) {
                // Check if nothing else is pressed
                if (mInitialMetaState == (mMetaState ^ (altOnMask | metaOnMask))) {
                    // Handle Caps Lock Toggle
                    mInputManagerInternal.toggleCapsLock(event.getDeviceId());
                    actionTriggered = true;
                }
            }
            // Always stop tracking when key goes up.
            mPendingCapsLockToggle = false;
        }
    }
    // Store current meta state to be able to evaluate it later.
    mMetaState = metaState;
    if (actionTriggered) {
        return -1;
    }
    if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD, event.getDeviceId());
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (mBackKillEnabled && isStopLockTaskMode()) {
            if (down && repeatCount == 0) {
                mHandler.postDelayed(mBackLongPress, mBackKillTimeout);
            }
        }
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                        dismissKeyboardShortcutsMenu();
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    dismissKeyboardShortcutsMenu();
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                startActivityAsUser(intent, UserHandle.CURRENT);
                dismissKeyboardShortcutsMenu();
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn && isUserSetupComplete()) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true, false);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // Handle input method switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_META_MASK) != 0))) {
        final boolean forwardDirection = (metaState & KeyEvent.META_SHIFT_MASK) == 0;
        mWindowManagerFuncs.switchInputMethod(forwardDirection);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Specific device key handling
    if (mDeviceKeyHandler != null) {
        try {
            // The device only will consume known keys.
            if (mDeviceKeyHandler.canHandleKeyEvent(event)) {
                return -1;
            }
        } catch (Exception e) {
            Slog.w(TAG, "Could not dispatch event to device key handler", e);
        }
    }
    if (down) {
        long shortcutCode = keyCode;
        if (event.isCtrlPressed()) {
            shortcutCode |= ((long) KeyEvent.META_CTRL_ON) << Integer.SIZE;
        }
        if (event.isAltPressed()) {
            shortcutCode |= ((long) KeyEvent.META_ALT_ON) << Integer.SIZE;
        }
        if (event.isShiftPressed()) {
            shortcutCode |= ((long) KeyEvent.META_SHIFT_ON) << Integer.SIZE;
        }
        if (event.isMetaPressed()) {
            shortcutCode |= ((long) KeyEvent.META_META_ON) << Integer.SIZE;
        }
        IShortcutService shortcutService = mShortcutKeyServices.get(shortcutCode);
        if (shortcutService != null) {
            try {
                if (isUserSetupComplete()) {
                    shortcutService.notifyShortcutKeyPressed(shortcutCode);
                }
            } catch (RemoteException e) {
                mShortcutKeyServices.delete(shortcutCode);
            }
            return -1;
        }
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#method_after
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    final int scanCode = event.getScanCode();
    // if mHardwareKeysDisable is true we have disabled all button rebindings
    // so we can be sure that events that are !virtuaKey are only for real buttons
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean isVirtualHardKey = (flags & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0;
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled + " virtualKey=" + virtualKey + " scanCode=" + scanCode + " longPress=" + longPress + " isVirtualHardKey=" + isVirtualHardKey);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mScreenshotChordVolumeDownKeyTriggered && !mScreenshotChordPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
    }
    // try again later before dispatching.
    if (mScreenrecordChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mScreenrecordChordVolumeUpKeyTriggered && !mScreenshotChordPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mScreenrecordChordVolumeUpKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mScreenrecordChordVolumeUpKeyConsumed) {
            if (!down) {
                mScreenrecordChordVolumeUpKeyConsumed = false;
            }
            return -1;
        }
    }
    // know if it is complete or not
    if (mAccessibilityShortcutController.isAccessibilityShortcutAvailable(false) && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mScreenshotChordVolumeDownKeyTriggered ^ mA11yShortcutChordVolumeUpKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = (mScreenshotChordVolumeDownKeyTriggered ? mScreenshotChordVolumeDownKeyTime : mA11yShortcutChordVolumeUpKeyTime) + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mA11yShortcutChordVolumeUpKeyConsumed) {
            if (!down) {
                mA11yShortcutChordVolumeUpKeyConsumed = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // Any key that is not Alt or Meta cancels Caps Lock combo tracking.
    if (mPendingCapsLockToggle && !KeyEvent.isMetaKey(keyCode) && !KeyEvent.isAltKey(keyCode)) {
        mPendingCapsLockToggle = false;
    }
    if (keyCode == KeyEvent.KEYCODE_BACK && !down) {
        mHandler.removeCallbacks(mBackLongPress);
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down) {
            cancelPreloadRecentApps();
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehaviorCustom != DOUBLE_TAP_HOME_NOTHING) {
                mEventDeviceId = event.getDeviceId();
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            handleShortPressOnHome();
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            mHomePressed = true;
            if (mOmniSwitchRecents) {
                OmniSwitchConstants.hideOmniSwitchRecents(mContext, UserHandle.CURRENT);
            }
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                handleDoubleTapOnHome();
            } else if (mLongPressOnHomeBehaviorCustom == KEY_ACTION_APP_SWITCH || mDoubleTapOnHomeBehaviorCustom == KEY_ACTION_APP_SWITCH || mDoubleTapOnHomeBehaviorCustom == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
                preloadRecentApps();
            }
        } else if ((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
            if (!keyguardOn) {
                handleLongPressOnHome(event.getDeviceId());
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        if (!virtualKey) {
            if (down) {
                if (repeatCount == 0) {
                    if (isCustomKeyAction(keyCode)) {
                        doDownKeyAction(getCustomKeyAction(keyCode));
                        mDoCustomAction = true;
                        return -1;
                    }
                    doDownKeyAction(KEY_ACTION_MENU);
                }
            } else {
                if (doUpKeyAction(keyCode, canceled) == -1) {
                    return -1;
                }
            }
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (!keyguardOn) {
            if (down) {
                if (repeatCount == 0) {
                    if (isCustomKeyAction(keyCode)) {
                        doDownKeyAction(getCustomKeyAction(keyCode));
                        mDoCustomAction = true;
                        return -1;
                    }
                    doDownKeyAction(KEY_ACTION_APP_SWITCH);
                }
            } else {
                if (doUpKeyAction(keyCode, canceled) == -1) {
                    return -1;
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (!virtualKey) {
            if (down) {
                if (repeatCount == 0) {
                    if (isCustomKeyAction(keyCode)) {
                        doDownKeyAction(getCustomKeyAction(keyCode));
                        mDoCustomAction = true;
                        return -1;
                    }
                    doDownKeyAction(KEY_ACTION_BACK);
                }
            } else {
                if (doUpKeyAction(keyCode, canceled) == -1) {
                    return -1;
                }
            // back action is simple to continue and pass further
            }
        } else if (isVirtualHardKey && mBackKillEnabled && !isStopLockTaskMode(true)) {
            // back kill called from navbar back button
            if (down) {
                if (repeatCount == 0) {
                    mHandler.postDelayed(mBackLongPress, mBackKillTimeout);
                }
            } else {
                mHandler.removeCallbacks(mBackLongPress);
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_N && event.isMetaPressed()) {
        if (down) {
            IStatusBarService service = getStatusBarService();
            if (service != null) {
                try {
                    service.expandNotificationsPanel();
                } catch (RemoteException e) {
                // do nothing.
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_S && event.isMetaPressed() && event.isCtrlPressed()) {
        if (down && repeatCount == 0) {
            int type = event.isShiftPressed() ? TAKE_SCREENSHOT_SELECTED_REGION : TAKE_SCREENSHOT_FULLSCREEN;
            mScreenshotRunnable.setScreenshotType(type);
            mHandler.post(mScreenshotRunnable);
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_SLASH && event.isMetaPressed()) {
        if (down && repeatCount == 0 && !isKeyguardLocked()) {
            toggleKeyboardShortcutsMenu(event.getDeviceId());
        }
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (repeatCount == 1) {
                mAssistKeyLongPressed = true;
                if (!keyguardOn) {
                    launchAssistLongPressAction();
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (!keyguardOn) {
                    launchAssistAction(null, event.getDeviceId());
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        if (!down) {
            Intent voiceIntent;
            if (!keyguardOn) {
                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
            } else {
                IDeviceIdleController dic = IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
                if (dic != null) {
                    try {
                        dic.exitIdle("voice-search");
                    } catch (RemoteException e) {
                    }
                }
                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
            }
            startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
        }
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_FULLSCREEN);
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
        if (mUseTvRouting || mHandleVolumeKeysInWM) {
            // On TVs or when the configuration is enabled, volume keys never
            // go to the foreground app.
            dispatchDirectAudioEvent(event);
            return -1;
        }
        // forward it to the application/dispatch the audio event.
        if (mPersistentVrModeEnabled) {
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_TAB && event.isMetaPressed()) {
        // Pass through keyboard navigation keys.
        return 0;
    } else if (mHasFeatureLeanback && interceptBugreportGestureTv(keyCode, down)) {
        return -1;
    } else if (mHasFeatureLeanback && interceptAccessibilityGestureTv(keyCode, down)) {
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_ALL_APPS) {
        if (!down) {
            mHandler.removeMessages(MSG_HANDLE_ALL_APPS);
            Message msg = mHandler.obtainMessage(MSG_HANDLE_ALL_APPS);
            msg.setAsynchronous(true);
            msg.sendToTarget();
        }
        return -1;
    }
    // Toggle Caps Lock on META-ALT.
    boolean actionTriggered = false;
    if (KeyEvent.isModifierKey(keyCode)) {
        if (!mPendingCapsLockToggle) {
            // Start tracking meta state for combo.
            mInitialMetaState = mMetaState;
            mPendingCapsLockToggle = true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            int altOnMask = mMetaState & KeyEvent.META_ALT_MASK;
            int metaOnMask = mMetaState & KeyEvent.META_META_MASK;
            // Check for Caps Lock toggle
            if ((metaOnMask != 0) && (altOnMask != 0)) {
                // Check if nothing else is pressed
                if (mInitialMetaState == (mMetaState ^ (altOnMask | metaOnMask))) {
                    // Handle Caps Lock Toggle
                    mInputManagerInternal.toggleCapsLock(event.getDeviceId());
                    actionTriggered = true;
                }
            }
            // Always stop tracking when key goes up.
            mPendingCapsLockToggle = false;
        }
    }
    // Store current meta state to be able to evaluate it later.
    mMetaState = metaState;
    if (actionTriggered) {
        return -1;
    }
    if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD, event.getDeviceId());
        }
        return -1;
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                        dismissKeyboardShortcutsMenu();
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    dismissKeyboardShortcutsMenu();
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                startActivityAsUser(intent, UserHandle.CURRENT);
                dismissKeyboardShortcutsMenu();
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn && isUserSetupComplete()) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true, false);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // Handle input method switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_META_MASK) != 0))) {
        final boolean forwardDirection = (metaState & KeyEvent.META_SHIFT_MASK) == 0;
        mWindowManagerFuncs.switchInputMethod(forwardDirection);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Specific device key handling
    if (mDeviceKeyHandler != null) {
        try {
            // The device only will consume known keys.
            if (mDeviceKeyHandler.canHandleKeyEvent(event)) {
                return -1;
            }
        } catch (Exception e) {
            Slog.w(TAG, "Could not dispatch event to device key handler", e);
        }
    }
    if (down) {
        long shortcutCode = keyCode;
        if (event.isCtrlPressed()) {
            shortcutCode |= ((long) KeyEvent.META_CTRL_ON) << Integer.SIZE;
        }
        if (event.isAltPressed()) {
            shortcutCode |= ((long) KeyEvent.META_ALT_ON) << Integer.SIZE;
        }
        if (event.isShiftPressed()) {
            shortcutCode |= ((long) KeyEvent.META_SHIFT_ON) << Integer.SIZE;
        }
        if (event.isMetaPressed()) {
            shortcutCode |= ((long) KeyEvent.META_META_ON) << Integer.SIZE;
        }
        IShortcutService shortcutService = mShortcutKeyServices.get(shortcutCode);
        if (shortcutService != null) {
            try {
                if (isUserSetupComplete()) {
                    shortcutService.notifyShortcutKeyPressed(shortcutCode);
                }
            } catch (RemoteException e) {
                mShortcutKeyServices.delete(shortcutCode);
            }
            return -1;
        }
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#end_block

#method_before
private boolean isStopLockTaskMode() {
    try {
        if (ActivityManagerNative.getDefault().getLockTaskModeState() == ActivityManager.LOCK_TASK_MODE_NONE) {
            ActivityManagerNative.getDefault().stopSystemLockTaskMode();
            return true;
        }
        return false;
    } catch (RemoteException e) {
    // ignore
    }
    return false;
}
#method_after
private boolean isStopLockTaskMode(boolean checkOnly) {
    try {
        if (ActivityManagerNative.getDefault().isInLockTaskMode()) {
            if (!checkOnly) {
                ActivityManagerNative.getDefault().stopSystemLockTaskMode();
            }
            return true;
        }
    } catch (RemoteException e) {
    // ignore
    }
    return false;
}
#end_block

#method_before
private void doStartLongPressKeyAction(int keyAction) {
    if (keyAction == KEY_ACTION_APP_SWITCH) {
        mAppSwitchConsumed = false;
        Message msg = mHandler.obtainMessage(MSG_APP_SWITCH_LONG_PRESS);
        triggerLongPressTimeoutMessage(msg);
    }
    if (keyAction == KEY_ACTION_BACK) {
        if (mBackKillEnabled && isStopLockTaskMode()) {
            mLongPressBackConsumed = false;
            mHandler.postDelayed(mBackLongPress, mBackKillTimeout);
        }
        mBackKeyHandled = false;
        Message msg = mHandler.obtainMessage(MSG_BACK_LONG_PRESS);
        triggerLongPressTimeoutMessage(msg);
    }
    if (keyAction == KEY_ACTION_MENU) {
        mMenuConsumed = false;
        Message msg = mHandler.obtainMessage(MSG_MENU_LONG_PRESS);
        triggerLongPressTimeoutMessage(msg);
    }
}
#method_after
private void doStartLongPressKeyAction(int keyAction) {
    if (keyAction == KEY_ACTION_APP_SWITCH) {
        mAppSwitchConsumed = false;
        Message msg = mHandler.obtainMessage(MSG_APP_SWITCH_LONG_PRESS);
        triggerLongPressTimeoutMessage(msg);
    }
    if (keyAction == KEY_ACTION_BACK) {
        if (mBackKillEnabled) {
            mLongPressBackConsumed = false;
            mHandler.postDelayed(mBackLongPress, mBackKillTimeout);
        }
        mBackKeyHandled = false;
        Message msg = mHandler.obtainMessage(MSG_BACK_LONG_PRESS);
        triggerLongPressTimeoutMessage(msg);
    }
    if (keyAction == KEY_ACTION_MENU) {
        mMenuConsumed = false;
        Message msg = mHandler.obtainMessage(MSG_MENU_LONG_PRESS);
        triggerLongPressTimeoutMessage(msg);
    }
}
#end_block

#method_before
private synchronized void updateProximitySensorMode() {
    final int audioRoute = mAudioModeProvider.getAudioState().getRoute();
    if (mIsProximitySensorDisabled) {
        LogUtil.i("ProximitySensor.updateProximitySensorMode", "Proximity sensor is disabled by user!");
        return;
    }
    boolean screenOnImmediately = (CallAudioState.ROUTE_WIRED_HEADSET == audioRoute || CallAudioState.ROUTE_SPEAKER == audioRoute || CallAudioState.ROUTE_BLUETOOTH == audioRoute || mIsAttemptingVideoCall || mIsVideoCall);
    // We do not keep the screen off when the user is outside in-call screen and we are
    // horizontal, but we do not force it on when we become horizontal until the
    // proximity sensor goes negative.
    final boolean horizontal = (mOrientation == AccelerometerListener.ORIENTATION_HORIZONTAL);
    screenOnImmediately |= !mUiShowing && horizontal;
    // We do not keep the screen off when dialpad is visible, we are horizontal, and
    // the in-call screen is being shown.
    // At that moment we're pretty sure users want to use it, instead of letting the
    // proximity sensor turn off the screen by their hands.
    screenOnImmediately |= mDialpadVisible && horizontal;
    LogUtil.i("ProximitySensor.updateProximitySensorMode", "screenOnImmediately: %b, dialPadVisible: %b, " + "offHook: %b, horizontal: %b, uiShowing: %b, audioRoute: %s", screenOnImmediately, mDialpadVisible, mIsPhoneOffhook, mOrientation == AccelerometerListener.ORIENTATION_HORIZONTAL, mUiShowing, CallAudioState.audioRouteToString(audioRoute));
    if (mIsPhoneOffhook && !screenOnImmediately) {
        LogUtil.v("ProximitySensor.updateProximitySensorMode", "turning on proximity sensor");
        // Phone is in use!  Arrange for the screen to turn off
        // automatically when the sensor detects a close object.
        turnOnProximitySensor();
    } else {
        LogUtil.v("ProximitySensor.updateProximitySensorMode", "turning off proximity sensor");
        // Phone is either idle, or ringing.  We don't want any special proximity sensor
        // behavior in either case.
        turnOffProximitySensor(screenOnImmediately);
    }
}
#method_after
private synchronized void updateProximitySensorMode() {
    final int audioRoute = mAudioModeProvider.getAudioState().getRoute();
    final boolean mIsProximitySensorDisabled = mPrefs.getBoolean(PREF_KEY_DISABLE_PROXI_SENSOR, false);
    if (mIsProximitySensorDisabled) {
        return;
    }
    boolean screenOnImmediately = (CallAudioState.ROUTE_WIRED_HEADSET == audioRoute || CallAudioState.ROUTE_SPEAKER == audioRoute || CallAudioState.ROUTE_BLUETOOTH == audioRoute || mIsAttemptingVideoCall || mIsVideoCall);
    // We do not keep the screen off when the user is outside in-call screen and we are
    // horizontal, but we do not force it on when we become horizontal until the
    // proximity sensor goes negative.
    final boolean horizontal = (mOrientation == AccelerometerListener.ORIENTATION_HORIZONTAL);
    screenOnImmediately |= !mUiShowing && horizontal;
    // We do not keep the screen off when dialpad is visible, we are horizontal, and
    // the in-call screen is being shown.
    // At that moment we're pretty sure users want to use it, instead of letting the
    // proximity sensor turn off the screen by their hands.
    screenOnImmediately |= mDialpadVisible && horizontal;
    LogUtil.i("ProximitySensor.updateProximitySensorMode", "screenOnImmediately: %b, dialPadVisible: %b, " + "offHook: %b, horizontal: %b, uiShowing: %b, audioRoute: %s", screenOnImmediately, mDialpadVisible, mIsPhoneOffhook, mOrientation == AccelerometerListener.ORIENTATION_HORIZONTAL, mUiShowing, CallAudioState.audioRouteToString(audioRoute));
    if (mIsPhoneOffhook && !screenOnImmediately) {
        LogUtil.v("ProximitySensor.updateProximitySensorMode", "turning on proximity sensor");
        // Phone is in use!  Arrange for the screen to turn off
        // automatically when the sensor detects a close object.
        turnOnProximitySensor();
    } else {
        LogUtil.v("ProximitySensor.updateProximitySensorMode", "turning off proximity sensor");
        // Phone is either idle, or ringing.  We don't want any special proximity sensor
        // behavior in either case.
        turnOffProximitySensor(screenOnImmediately);
    }
}
#end_block

#method_before
void takeScreenshotPartial(final Runnable finisher, final boolean statusBarVisible, final boolean navBarVisible) {
    mWindowManager.addView(mScreenshotLayout, mWindowLayoutParams);
    mPartialShotStarted = false;
    mPartialShot = true;
    ViewConfiguration vc = ViewConfiguration.get(mContext);
    final int touchSlop = vc.getScaledTouchSlop();
    mScreenshotSelectorView.setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            ScreenshotSelectorView view = (ScreenshotSelectorView) v;
            switch(event.getAction()) {
                case MotionEvent.ACTION_DOWN:
                    mPartialShotStarted = true;
                    mTouchDownX = event.getRawX();
                    mTouchDownY = event.getRawY();
                    view.startSelection((int) event.getX(), (int) event.getY());
                    return true;
                case MotionEvent.ACTION_MOVE:
                    view.updateSelection((int) event.getX(), (int) event.getY());
                    return true;
                case MotionEvent.ACTION_UP:
                    float x = event.getRawX();
                    float y = event.getRawY();
                    view.setVisibility(View.GONE);
                    mWindowManager.removeView(mScreenshotLayout);
                    if (Math.abs(mTouchDownX - x) > touchSlop || Math.abs(mTouchDownY - y) > touchSlop) {
                        final Rect rect = view.getSelectionRect();
                        if (rect != null) {
                            if (rect.left >= 0 && rect.top >= 0 && rect.width() != 0 && rect.height() != 0) {
                                // Need mScreenshotLayout to handle it after the view disappears
                                mScreenshotLayout.post(new Runnable() {

                                    public void run() {
                                        takeScreenshot(finisher, statusBarVisible, navBarVisible, rect.left, rect.top, rect.width(), rect.height());
                                    }
                                });
                            }
                        }
                    } else {
                        finisher.run();
                    }
                    view.stopSelection();
                    return true;
                case MotionEvent.ACTION_CANCEL:
                    stopScreenshot();
                    finisher.run();
            }
            return false;
        }
    });
    mScreenshotLayout.post(new Runnable() {

        @Override
        public void run() {
            mScreenshotSelectorView.setVisibility(View.VISIBLE);
            mScreenshotSelectorView.requestFocus();
        }
    });
}
#method_after
void takeScreenshotPartial(final Runnable finisher, final boolean statusBarVisible, final boolean navBarVisible) {
    mWindowManager.addView(mScreenshotLayout, mWindowLayoutParams);
    mPartialShotStarted = false;
    mPartialShot = true;
    ViewConfiguration vc = ViewConfiguration.get(mContext);
    final int touchSlop = vc.getScaledTouchSlop();
    mScreenshotSelectorView.setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            ScreenshotSelectorView view = (ScreenshotSelectorView) v;
            switch(event.getAction()) {
                case MotionEvent.ACTION_DOWN:
                    mPartialShotStarted = true;
                    mTouchDownX = event.getRawX();
                    mTouchDownY = event.getRawY();
                    view.startSelection((int) event.getX(), (int) event.getY());
                    return true;
                case MotionEvent.ACTION_MOVE:
                    view.updateSelection((int) event.getX(), (int) event.getY());
                    return true;
                case MotionEvent.ACTION_UP:
                    float x = event.getRawX();
                    float y = event.getRawY();
                    view.setVisibility(View.GONE);
                    mWindowManager.removeView(mScreenshotLayout);
                    if (Math.abs(mTouchDownX - x) > touchSlop || Math.abs(mTouchDownY - y) > touchSlop) {
                        final Rect rect = view.getSelectionRect();
                        if (rect != null && !rect.isEmpty()) {
                            // Need mScreenshotLayout to handle it after the view disappears
                            mScreenshotLayout.post(new Runnable() {

                                public void run() {
                                    takeScreenshot(finisher, statusBarVisible, navBarVisible, Math.max(0, rect.left), Math.max(0, rect.top), rect.width(), rect.height());
                                }
                            });
                            view.stopSelection();
                            return true;
                        }
                    }
                    finisher.run();
                    view.stopSelection();
                    return true;
                case MotionEvent.ACTION_CANCEL:
                    stopScreenshot();
                    finisher.run();
            }
            return false;
        }
    });
    mScreenshotLayout.post(new Runnable() {

        @Override
        public void run() {
            mScreenshotSelectorView.setVisibility(View.VISIBLE);
            mScreenshotSelectorView.requestFocus();
        }
    });
}
#end_block

#method_before
private boolean isAdbNetworkEnabled() {
    return Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.ADB_PORT, 0) > 0;
}
#method_after
private boolean isAdbNetworkEnabled() {
    return Settings.Secure.getIntForUser(mContext.getContentResolver(), Settings.Secure.ADB_PORT, 0, UserHandle.USER_CURRENT) > 0;
}
#end_block

#method_before
private void processValuesLocked(boolean force) {
    boolean logOutlier = false;
    long dischargeDuration = 0;
    mBatteryLevelCritical = (mBatteryProps.batteryLevel <= mCriticalBatteryLevel);
    if (mBatteryProps.chargerAcOnline) {
        mPlugType = BatteryManager.BATTERY_PLUGGED_AC;
    } else if (mBatteryProps.chargerUsbOnline) {
        mPlugType = BatteryManager.BATTERY_PLUGGED_USB;
    } else if (mBatteryProps.chargerWirelessOnline) {
        mPlugType = BatteryManager.BATTERY_PLUGGED_WIRELESS;
    } else {
        mPlugType = BATTERY_PLUGGED_NONE;
    }
    if (DEBUG) {
        Slog.d(TAG, "Processing new values: " + "chargerAcOnline=" + mBatteryProps.chargerAcOnline + ", chargerUsbOnline=" + mBatteryProps.chargerUsbOnline + ", chargerWirelessOnline=" + mBatteryProps.chargerWirelessOnline + ", maxChargingCurrent" + mBatteryProps.maxChargingCurrent + ", maxChargingVoltage" + mBatteryProps.maxChargingVoltage + ", chargeCounter" + mBatteryProps.batteryChargeCounter + ", batteryStatus=" + mBatteryProps.batteryStatus + ", batteryHealth=" + mBatteryProps.batteryHealth + ", batteryPresent=" + mBatteryProps.batteryPresent + ", batteryLevel=" + mBatteryProps.batteryLevel + ", batteryTechnology=" + mBatteryProps.batteryTechnology + ", batteryVoltage=" + mBatteryProps.batteryVoltage + ", batteryTemperature=" + mBatteryProps.batteryTemperature + ", mBatteryLevelCritical=" + mBatteryLevelCritical + ", mPlugType=" + mPlugType);
    }
    // Let the battery stats keep track of the current level.
    try {
        mBatteryStats.setBatteryState(mBatteryProps.batteryStatus, mBatteryProps.batteryHealth, mPlugType, mBatteryProps.batteryLevel, mBatteryProps.batteryTemperature, mBatteryProps.batteryVoltage, mBatteryProps.batteryChargeCounter);
    } catch (RemoteException e) {
    // Should never happen.
    }
    shutdownIfNoPowerLocked();
    shutdownIfOverTempLocked();
    if (force || (mBatteryProps.batteryStatus != mLastBatteryStatus || mBatteryProps.batteryHealth != mLastBatteryHealth || mBatteryProps.batteryPresent != mLastBatteryPresent || mBatteryProps.batteryLevel != mLastBatteryLevel || mPlugType != mLastPlugType || mBatteryProps.batteryVoltage != mLastBatteryVoltage || mBatteryProps.batteryTemperature != mLastBatteryTemperature || mBatteryProps.maxChargingCurrent != mLastMaxChargingCurrent || mBatteryProps.maxChargingVoltage != mLastMaxChargingVoltage || mBatteryProps.batteryChargeCounter != mLastChargeCounter || mInvalidCharger != mLastInvalidCharger)) {
        if (mPlugType != mLastPlugType) {
            if (mLastPlugType == BATTERY_PLUGGED_NONE) {
                // battery level has changed; so don't log until it does.
                if (mDischargeStartTime != 0 && mDischargeStartLevel != mBatteryProps.batteryLevel) {
                    dischargeDuration = SystemClock.elapsedRealtime() - mDischargeStartTime;
                    logOutlier = true;
                    EventLog.writeEvent(EventLogTags.BATTERY_DISCHARGE, dischargeDuration, mDischargeStartLevel, mBatteryProps.batteryLevel);
                    // make sure we see a discharge event before logging again
                    mDischargeStartTime = 0;
                }
            } else if (mPlugType == BATTERY_PLUGGED_NONE) {
                // charging -> discharging or we just powered up
                mDischargeStartTime = SystemClock.elapsedRealtime();
                mDischargeStartLevel = mBatteryProps.batteryLevel;
            }
        }
        if (mBatteryProps.batteryStatus != mLastBatteryStatus || mBatteryProps.batteryHealth != mLastBatteryHealth || mBatteryProps.batteryPresent != mLastBatteryPresent || mPlugType != mLastPlugType) {
            EventLog.writeEvent(EventLogTags.BATTERY_STATUS, mBatteryProps.batteryStatus, mBatteryProps.batteryHealth, mBatteryProps.batteryPresent ? 1 : 0, mPlugType, mBatteryProps.batteryTechnology);
        }
        if (mBatteryProps.batteryLevel != mLastBatteryLevel) {
            // Don't do this just from voltage or temperature changes, that is
            // too noisy.
            EventLog.writeEvent(EventLogTags.BATTERY_LEVEL, mBatteryProps.batteryLevel, mBatteryProps.batteryVoltage, mBatteryProps.batteryTemperature);
        }
        if (mBatteryLevelCritical && !mLastBatteryLevelCritical && mPlugType == BATTERY_PLUGGED_NONE) {
            // We want to make sure we log discharge cycle outliers
            // if the battery is about to die.
            dischargeDuration = SystemClock.elapsedRealtime() - mDischargeStartTime;
            logOutlier = true;
        }
        if (!mBatteryLevelLow) {
            // Should we now switch in to low battery mode?
            if (mPlugType == BATTERY_PLUGGED_NONE && mBatteryProps.batteryLevel <= mLowBatteryWarningLevel) {
                mBatteryLevelLow = true;
            }
        } else {
            // Should we now switch out of low battery mode?
            if (mPlugType != BATTERY_PLUGGED_NONE) {
                mBatteryLevelLow = false;
            } else if (mBatteryProps.batteryLevel >= mLowBatteryCloseWarningLevel) {
                mBatteryLevelLow = false;
            } else if (force && mBatteryProps.batteryLevel >= mLowBatteryWarningLevel) {
                // If being forced, the previous state doesn't matter, we will just
                // absolutely check to see if we are now above the warning level.
                mBatteryLevelLow = false;
            }
        }
        sendIntentLocked();
        // applications may want to have smart behavior based on this.
        if (mPlugType != 0 && mLastPlugType == 0) {
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    Intent statusIntent = new Intent(Intent.ACTION_POWER_CONNECTED);
                    statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        } else if (mPlugType == 0 && mLastPlugType != 0) {
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    Intent statusIntent = new Intent(Intent.ACTION_POWER_DISCONNECTED);
                    statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        }
        if (shouldSendBatteryLowLocked()) {
            mSentLowBatteryBroadcast = true;
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    Intent statusIntent = new Intent(Intent.ACTION_BATTERY_LOW);
                    statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        } else if (mSentLowBatteryBroadcast && mLastBatteryLevel >= mLowBatteryCloseWarningLevel) {
            mSentLowBatteryBroadcast = false;
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    Intent statusIntent = new Intent(Intent.ACTION_BATTERY_OKAY);
                    statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        }
        // Update the battery LED
        mLed.updateLightsLocked();
        // This needs to be done after sendIntent() so that we get the lastest battery stats.
        if (logOutlier && dischargeDuration != 0) {
            logOutlierLocked(dischargeDuration);
        }
        mLastBatteryStatus = mBatteryProps.batteryStatus;
        mLastBatteryHealth = mBatteryProps.batteryHealth;
        mLastBatteryPresent = mBatteryProps.batteryPresent;
        mLastBatteryLevel = mBatteryProps.batteryLevel;
        mLastPlugType = mPlugType;
        mLastBatteryVoltage = mBatteryProps.batteryVoltage;
        mLastBatteryTemperature = mBatteryProps.batteryTemperature;
        mLastMaxChargingCurrent = mBatteryProps.maxChargingCurrent;
        mLastMaxChargingVoltage = mBatteryProps.maxChargingVoltage;
        mLastChargeCounter = mBatteryProps.batteryChargeCounter;
        mLastBatteryLevelCritical = mBatteryLevelCritical;
        mLastInvalidCharger = mInvalidCharger;
        maxChargingWattage = mLastMaxChargingCurrent * 5;
        // Update the Fast battery LED
        mLed.FastCharge(maxChargingWattage);
    }
}
#method_after
private void processValuesLocked(boolean force) {
    boolean logOutlier = false;
    long dischargeDuration = 0;
    mBatteryLevelCritical = (mBatteryProps.batteryLevel <= mCriticalBatteryLevel);
    if (mBatteryProps.chargerAcOnline) {
        mPlugType = BatteryManager.BATTERY_PLUGGED_AC;
    } else if (mBatteryProps.chargerUsbOnline) {
        mPlugType = BatteryManager.BATTERY_PLUGGED_USB;
    } else if (mBatteryProps.chargerWirelessOnline) {
        mPlugType = BatteryManager.BATTERY_PLUGGED_WIRELESS;
    } else {
        mPlugType = BATTERY_PLUGGED_NONE;
    }
    if (DEBUG) {
        Slog.d(TAG, "Processing new values: " + "chargerAcOnline=" + mBatteryProps.chargerAcOnline + ", chargerUsbOnline=" + mBatteryProps.chargerUsbOnline + ", chargerWirelessOnline=" + mBatteryProps.chargerWirelessOnline + ", maxChargingCurrent" + mBatteryProps.maxChargingCurrent + ", maxChargingVoltage" + mBatteryProps.maxChargingVoltage + ", chargeCounter" + mBatteryProps.batteryChargeCounter + ", batteryStatus=" + mBatteryProps.batteryStatus + ", batteryHealth=" + mBatteryProps.batteryHealth + ", batteryPresent=" + mBatteryProps.batteryPresent + ", batteryLevel=" + mBatteryProps.batteryLevel + ", batteryTechnology=" + mBatteryProps.batteryTechnology + ", batteryVoltage=" + mBatteryProps.batteryVoltage + ", batteryTemperature=" + mBatteryProps.batteryTemperature + ", mBatteryLevelCritical=" + mBatteryLevelCritical + ", mPlugType=" + mPlugType);
    }
    // Let the battery stats keep track of the current level.
    try {
        mBatteryStats.setBatteryState(mBatteryProps.batteryStatus, mBatteryProps.batteryHealth, mPlugType, mBatteryProps.batteryLevel, mBatteryProps.batteryTemperature, mBatteryProps.batteryVoltage, mBatteryProps.batteryChargeCounter);
    } catch (RemoteException e) {
    // Should never happen.
    }
    shutdownIfNoPowerLocked();
    shutdownIfOverTempLocked();
    if (force || (mBatteryProps.batteryStatus != mLastBatteryStatus || mBatteryProps.batteryHealth != mLastBatteryHealth || mBatteryProps.batteryPresent != mLastBatteryPresent || mBatteryProps.batteryLevel != mLastBatteryLevel || mPlugType != mLastPlugType || mBatteryProps.batteryVoltage != mLastBatteryVoltage || mBatteryProps.batteryTemperature != mLastBatteryTemperature || mBatteryProps.maxChargingCurrent != mLastMaxChargingCurrent || mBatteryProps.maxChargingVoltage != mLastMaxChargingVoltage || mBatteryProps.batteryChargeCounter != mLastChargeCounter || mInvalidCharger != mLastInvalidCharger)) {
        if (mPlugType != mLastPlugType) {
            if (mLastPlugType == BATTERY_PLUGGED_NONE) {
                // battery level has changed; so don't log until it does.
                if (mDischargeStartTime != 0 && mDischargeStartLevel != mBatteryProps.batteryLevel) {
                    dischargeDuration = SystemClock.elapsedRealtime() - mDischargeStartTime;
                    logOutlier = true;
                    EventLog.writeEvent(EventLogTags.BATTERY_DISCHARGE, dischargeDuration, mDischargeStartLevel, mBatteryProps.batteryLevel);
                    // make sure we see a discharge event before logging again
                    mDischargeStartTime = 0;
                }
            } else if (mPlugType == BATTERY_PLUGGED_NONE) {
                // charging -> discharging or we just powered up
                mDischargeStartTime = SystemClock.elapsedRealtime();
                mDischargeStartLevel = mBatteryProps.batteryLevel;
            }
        }
        if (mBatteryProps.batteryStatus != mLastBatteryStatus || mBatteryProps.batteryHealth != mLastBatteryHealth || mBatteryProps.batteryPresent != mLastBatteryPresent || mPlugType != mLastPlugType) {
            EventLog.writeEvent(EventLogTags.BATTERY_STATUS, mBatteryProps.batteryStatus, mBatteryProps.batteryHealth, mBatteryProps.batteryPresent ? 1 : 0, mPlugType, mBatteryProps.batteryTechnology);
        }
        if (mBatteryProps.batteryLevel != mLastBatteryLevel) {
            // Don't do this just from voltage or temperature changes, that is
            // too noisy.
            EventLog.writeEvent(EventLogTags.BATTERY_LEVEL, mBatteryProps.batteryLevel, mBatteryProps.batteryVoltage, mBatteryProps.batteryTemperature);
        }
        if (mBatteryLevelCritical && !mLastBatteryLevelCritical && mPlugType == BATTERY_PLUGGED_NONE) {
            // We want to make sure we log discharge cycle outliers
            // if the battery is about to die.
            dischargeDuration = SystemClock.elapsedRealtime() - mDischargeStartTime;
            logOutlier = true;
        }
        if (!mBatteryLevelLow) {
            // Should we now switch in to low battery mode?
            if (mPlugType == BATTERY_PLUGGED_NONE && mBatteryProps.batteryLevel <= mLowBatteryWarningLevel) {
                mBatteryLevelLow = true;
            }
        } else {
            // Should we now switch out of low battery mode?
            if (mPlugType != BATTERY_PLUGGED_NONE) {
                mBatteryLevelLow = false;
            } else if (mBatteryProps.batteryLevel >= mLowBatteryCloseWarningLevel) {
                mBatteryLevelLow = false;
            } else if (force && mBatteryProps.batteryLevel >= mLowBatteryWarningLevel) {
                // If being forced, the previous state doesn't matter, we will just
                // absolutely check to see if we are now above the warning level.
                mBatteryLevelLow = false;
            }
        }
        sendIntentLocked();
        // applications may want to have smart behavior based on this.
        if (mPlugType != 0 && mLastPlugType == 0) {
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    Intent statusIntent = new Intent(Intent.ACTION_POWER_CONNECTED);
                    statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        } else if (mPlugType == 0 && mLastPlugType != 0) {
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    Intent statusIntent = new Intent(Intent.ACTION_POWER_DISCONNECTED);
                    statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        }
        if (shouldSendBatteryLowLocked()) {
            mSentLowBatteryBroadcast = true;
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    Intent statusIntent = new Intent(Intent.ACTION_BATTERY_LOW);
                    statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        } else if (mSentLowBatteryBroadcast && mLastBatteryLevel >= mLowBatteryCloseWarningLevel) {
            mSentLowBatteryBroadcast = false;
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    Intent statusIntent = new Intent(Intent.ACTION_BATTERY_OKAY);
                    statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
                    mContext.sendBroadcastAsUser(statusIntent, UserHandle.ALL);
                }
            });
        }
        // Update the battery LED
        mLed.updateLightsLocked();
        // This needs to be done after sendIntent() so that we get the lastest battery stats.
        if (logOutlier && dischargeDuration != 0) {
            logOutlierLocked(dischargeDuration);
        }
        mLastBatteryStatus = mBatteryProps.batteryStatus;
        mLastBatteryHealth = mBatteryProps.batteryHealth;
        mLastBatteryPresent = mBatteryProps.batteryPresent;
        mLastBatteryLevel = mBatteryProps.batteryLevel;
        mLastPlugType = mPlugType;
        mLastBatteryVoltage = mBatteryProps.batteryVoltage;
        mLastBatteryTemperature = mBatteryProps.batteryTemperature;
        mLastMaxChargingCurrent = mBatteryProps.maxChargingCurrent;
        mLastMaxChargingVoltage = mBatteryProps.maxChargingVoltage;
        mLastChargeCounter = mBatteryProps.batteryChargeCounter;
        mLastBatteryLevelCritical = mBatteryLevelCritical;
        mLastInvalidCharger = mInvalidCharger;
        mMaxChargingWattage = mLastMaxChargingCurrent * 5;
        if (mFastChargingLedSupported) {
            // Update the Fast battery LED
            mLed.fastCharge(mMaxChargingWattage);
        }
    }
}
#end_block

#method_before
public void updateLightsLocked() {
    final int level = mBatteryProps.batteryLevel;
    final int status = mBatteryProps.batteryStatus;
    boolean lightEnabled = mLightEnabled;
    int lightColor = mBatteryLowARGB;
    boolean pulseColor = false;
    if (!mLightEnabled) {
        // No lights if explicitly disabled
        lightEnabled = false;
    } else if (isFastCharging & mFastChargingLedEnabled) {
        // Solid color when battery is fast charging
        lightColor = mFastBatteryARGB;
        lightEnabled = true;
    } else if (level < mLowBatteryWarningLevel) {
        if (isFastCharging & mFastChargingLedEnabled) {
            // Solid color when battery is fast charging
            lightColor = mFastBatteryARGB;
            lightEnabled = true;
        } else if (status == BatteryManager.BATTERY_STATUS_CHARGING) {
            // Solid red when battery is charging
            lightEnabled = !mLightOnlyFullyCharged;
            lightColor = mBatteryLowARGB;
        } else if (mLedPulseEnabled) {
            // Flash red when battery is low and not charging
            pulseColor = true;
            lightEnabled = true;
            lightColor = mBatteryLowARGB;
        } else {
            // "Pulse low battery light" is disabled, no lights.
            lightEnabled = false;
        }
    } else if (status == BatteryManager.BATTERY_STATUS_CHARGING || status == BatteryManager.BATTERY_STATUS_FULL) {
        if (status == BatteryManager.BATTERY_STATUS_FULL || level >= 90) {
            if (level == 100) {
                // Battery is really full
                lightEnabled = true;
                lightColor = mBatteryReallyFullARGB;
            } else {
                // Battery is full or charging and nearly full
                lightEnabled = !mLightOnlyFullyCharged;
                lightColor = mBatteryFullARGB;
            }
        } else {
            if (isFastCharging & mFastChargingLedEnabled) {
                // Solid color when battery is fast charging
                lightColor = mFastBatteryARGB;
                lightEnabled = true;
            } else {
                // Battery is charging and halfway full
                lightEnabled = !mLightOnlyFullyCharged;
                lightColor = mBatteryMediumARGB;
            }
        }
    } else {
        // No lights if not charging and not low
        lightEnabled = false;
    }
    if (lightEnabled) {
        if (pulseColor) {
            mBatteryLight.setFlashing(lightColor, Light.LIGHT_FLASH_TIMED, mBatteryLedOn, mBatteryLedOff);
        } else {
            mBatteryLight.setColor(lightColor);
        }
    } else {
        mBatteryLight.turnOff();
    }
}
#method_after
public void updateLightsLocked() {
    final int level = mBatteryProps.batteryLevel;
    final int status = mBatteryProps.batteryStatus;
    boolean lightEnabled = mLightEnabled;
    boolean fastlightenabled = mFastBatteryLightEnabled & mIsFastCharging;
    int lightColor = mBatteryLowARGB;
    boolean pulseColor = false;
    if (!mLightEnabled) {
        // No lights if explicitly disabled
        lightEnabled = false;
    } else if (level < mLowBatteryWarningLevel) {
        if (fastlightenabled) {
            // Solid color when battery is fast charging
            lightColor = mFastBatteryARGB;
            lightEnabled = !mLightOnlyFullyCharged;
        } else if (status == BatteryManager.BATTERY_STATUS_CHARGING) {
            // Solid red when battery is charging
            lightEnabled = !mLightOnlyFullyCharged;
            lightColor = mBatteryLowARGB;
        } else if (mLedPulseEnabled) {
            // Flash red when battery is low and not charging
            pulseColor = true;
            lightEnabled = true;
            lightColor = mBatteryLowARGB;
        } else {
            // "Pulse low battery light" is disabled, no lights.
            lightEnabled = false;
        }
    } else if (status == BatteryManager.BATTERY_STATUS_CHARGING || status == BatteryManager.BATTERY_STATUS_FULL) {
        if (status == BatteryManager.BATTERY_STATUS_FULL || level >= 90) {
            if (level == 100) {
                // Battery is really full
                lightEnabled = true;
                lightColor = mBatteryReallyFullARGB;
            } else {
                // Battery is full or charging and nearly full
                lightEnabled = !mLightOnlyFullyCharged;
                lightColor = mBatteryFullARGB;
            }
        } else {
            if (fastlightenabled) {
                // Solid color when battery is fast charging
                lightColor = mFastBatteryARGB;
                lightEnabled = !mLightOnlyFullyCharged;
            } else {
                // Battery is charging and halfway full
                lightEnabled = !mLightOnlyFullyCharged;
                lightColor = mBatteryMediumARGB;
            }
        }
    } else {
        // No lights if not charging and not low
        lightEnabled = false;
    }
    if (lightEnabled) {
        if (pulseColor) {
            mBatteryLight.setFlashing(lightColor, Light.LIGHT_FLASH_TIMED, mBatteryLedOn, mBatteryLedOff);
        } else {
            mBatteryLight.setColor(lightColor);
        }
    } else {
        mBatteryLight.turnOff();
    }
}
#end_block

#method_before
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    // Fast charging LED enabled
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.FAST_CHARGING_LED_ENABLED), false, this, UserHandle.USER_ALL);
    // Battery light enabled
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_ENABLED), false, this, UserHandle.USER_ALL);
    // Low battery pulse
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_PULSE), false, this, UserHandle.USER_ALL);
    // Only light when fully charged
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_ONLY_FULLY_CHARGED), false, this, UserHandle.USER_ALL);
    // Light colors
    if (mMultiColorLed) {
        // Register observer if we have a multi color led
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_LOW_COLOR), false, this, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_MEDIUM_COLOR), false, this, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_FULL_COLOR), false, this, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_REALLY_FULL_COLOR), false, this, UserHandle.USER_ALL);
        // Light colors
        if (mFastChargingLed) {
            // Register observer if we have a device that supports fast charging
            resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.FAST_BATTERY_LIGHT_COLOR), false, this, UserHandle.USER_ALL);
        }
    }
    update();
}
#method_after
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    // Battery light enabled
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_ENABLED), false, this, UserHandle.USER_ALL);
    // Low battery pulse
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_PULSE), false, this, UserHandle.USER_ALL);
    // Only light when fully charged
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_ONLY_FULLY_CHARGED), false, this, UserHandle.USER_ALL);
    // Light colors
    if (mMultiColorLed) {
        // Register observer if we have a multi color led
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_LOW_COLOR), false, this, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_MEDIUM_COLOR), false, this, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_FULL_COLOR), false, this, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_REALLY_FULL_COLOR), false, this, UserHandle.USER_ALL);
        // Light colors
        if (mFastChargingLedSupported) {
            // Fast Charging LED
            resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.FAST_CHARGING_LED_ENABLED), false, this, UserHandle.USER_ALL);
            // Register observer if we have a device that supports fast charging
            resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.FAST_BATTERY_LIGHT_COLOR), false, this, UserHandle.USER_ALL);
        }
    }
    update();
}
#end_block

#method_before
public void update() {
    ContentResolver resolver = mContext.getContentResolver();
    Resources res = mContext.getResources();
    // Battery light enabled
    mLightEnabled = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_LIGHT_ENABLED, mLightEnabled ? 1 : 0, UserHandle.USER_CURRENT) != 0;
    // Fast charging LED enabled
    mFastChargingLedEnabled = Settings.System.getIntForUser(resolver, Settings.System.FAST_CHARGING_LED_ENABLED, mFastChargingLedEnabled ? 1 : 0, UserHandle.USER_CURRENT) != 0;
    // Low battery pulse
    mLedPulseEnabled = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_LIGHT_PULSE, mLightEnabled ? 1 : 0, UserHandle.USER_CURRENT) != 0;
    // Only light when fully charged
    mLightOnlyFullyCharged = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_LIGHT_ONLY_FULLY_CHARGED, 0, UserHandle.USER_CURRENT) != 0;
    // Light colors
    mBatteryLowARGB = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_LIGHT_LOW_COLOR, res.getInteger(com.android.internal.R.integer.config_notificationsBatteryLowARGB), UserHandle.USER_CURRENT);
    mBatteryMediumARGB = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_LIGHT_MEDIUM_COLOR, res.getInteger(com.android.internal.R.integer.config_notificationsBatteryMediumARGB), UserHandle.USER_CURRENT);
    mBatteryFullARGB = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_LIGHT_FULL_COLOR, res.getInteger(com.android.internal.R.integer.config_notificationsBatteryFullARGB), UserHandle.USER_CURRENT);
    mBatteryReallyFullARGB = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_LIGHT_REALLY_FULL_COLOR, mBatteryFullARGB, UserHandle.USER_CURRENT);
    // Fast Light colors
    mFastBatteryARGB = Settings.System.getIntForUser(resolver, Settings.System.FAST_BATTERY_LIGHT_COLOR, res.getInteger(com.android.internal.R.integer.config_notificationsFastBatteryARGB), UserHandle.USER_CURRENT);
    updateLedPulse();
}
#method_after
public void update() {
    ContentResolver resolver = mContext.getContentResolver();
    Resources res = mContext.getResources();
    // Battery light enabled
    mLightEnabled = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_LIGHT_ENABLED, mLightEnabled ? 1 : 0, UserHandle.USER_CURRENT) != 0;
    // Fast charging LED enabled
    mFastBatteryLightEnabled = Settings.System.getIntForUser(resolver, Settings.System.FAST_CHARGING_LED_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
    // Low battery pulse
    mLedPulseEnabled = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_LIGHT_PULSE, mLightEnabled ? 1 : 0, UserHandle.USER_CURRENT) != 0;
    // Only light when fully charged
    mLightOnlyFullyCharged = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_LIGHT_ONLY_FULLY_CHARGED, 0, UserHandle.USER_CURRENT) != 0;
    // Light colors
    mBatteryLowARGB = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_LIGHT_LOW_COLOR, res.getInteger(com.android.internal.R.integer.config_notificationsBatteryLowARGB), UserHandle.USER_CURRENT);
    mBatteryMediumARGB = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_LIGHT_MEDIUM_COLOR, res.getInteger(com.android.internal.R.integer.config_notificationsBatteryMediumARGB), UserHandle.USER_CURRENT);
    mBatteryFullARGB = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_LIGHT_FULL_COLOR, res.getInteger(com.android.internal.R.integer.config_notificationsBatteryFullARGB), UserHandle.USER_CURRENT);
    mBatteryReallyFullARGB = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_LIGHT_REALLY_FULL_COLOR, mBatteryFullARGB, UserHandle.USER_CURRENT);
    // Fast Light colors
    mFastBatteryARGB = Settings.System.getIntForUser(resolver, Settings.System.FAST_BATTERY_LIGHT_COLOR, res.getInteger(com.android.internal.R.integer.config_notificationsFastBatteryARGB), UserHandle.USER_CURRENT);
    updateLedPulse();
}
#end_block

#method_before
public void systemReady(IAppOpsService appOps) {
    synchronized (mLock) {
        mSystemReady = true;
        mAppOps = appOps;
        mDreamManager = getLocalService(DreamManagerInternal.class);
        mDisplayManagerInternal = getLocalService(DisplayManagerInternal.class);
        mPolicy = getLocalService(WindowManagerPolicy.class);
        mBatteryManagerInternal = getLocalService(BatteryManagerInternal.class);
        PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
        mScreenBrightnessSettingMinimum = pm.getMinimumScreenBrightnessSetting();
        mScreenBrightnessSettingMaximum = pm.getMaximumScreenBrightnessSetting();
        mScreenBrightnessSettingDefault = pm.getDefaultScreenBrightnessSetting();
        mScreenBrightnessForVrSettingDefault = pm.getDefaultScreenBrightnessForVrSetting();
        SensorManager sensorManager = new SystemSensorManager(mContext, mHandler.getLooper());
        // The notifier runs on the system server's main looper so as not to interfere
        // with the animations and other critical functions of the power manager.
        mBatteryStats = BatteryStatsService.getService();
        mNotifier = new Notifier(Looper.getMainLooper(), mContext, mBatteryStats, mAppOps, createSuspendBlockerLocked("PowerManagerService.Broadcasts"), mPolicy);
        mWirelessChargerDetector = new WirelessChargerDetector(sensorManager, createSuspendBlockerLocked("PowerManagerService.WirelessChargerDetector"), mHandler);
        mSettingsObserver = new SettingsObserver(mHandler);
        mLightsManager = getLocalService(LightsManager.class);
        mAttentionLight = mLightsManager.getLight(LightsManager.LIGHT_ID_ATTENTION);
        // Initialize display power management.
        mDisplayManagerInternal.initPowerManagement(mDisplayPowerCallbacks, mHandler, sensorManager);
        // Register for broadcasts from other components of the system.
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_BATTERY_CHANGED);
        filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
        mContext.registerReceiver(new BatteryReceiver(), filter, null, mHandler);
        filter = new IntentFilter();
        filter.addAction(Intent.ACTION_DREAMING_STARTED);
        filter.addAction(Intent.ACTION_DREAMING_STOPPED);
        mContext.registerReceiver(new DreamReceiver(), filter, null, mHandler);
        filter = new IntentFilter();
        filter.addAction(Intent.ACTION_USER_SWITCHED);
        mContext.registerReceiver(new UserSwitchedReceiver(), filter, null, mHandler);
        filter = new IntentFilter();
        filter.addAction(Intent.ACTION_DOCK_EVENT);
        mContext.registerReceiver(new DockReceiver(), filter, null, mHandler);
        // Register for settings changes.
        final ContentResolver resolver = mContext.getContentResolver();
        resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ENABLED), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SLEEP_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.STAY_ON_WHILE_PLUGGED_IN), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_FOR_VR), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.LOW_POWER_MODE), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.LOW_POWER_MODE_TRIGGER_LEVEL), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.THEATER_MODE_ON), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DOUBLE_TAP_TO_WAKE), false, mSettingsObserver, UserHandle.USER_ALL);
        IVrManager vrManager = (IVrManager) getBinderService(VrManagerService.VR_MANAGER_BINDER_SERVICE);
        if (vrManager != null) {
            try {
                vrManager.registerListener(mVrStateCallbacks);
            } catch (RemoteException e) {
                Slog.e(TAG, "Failed to register VR mode state listener: " + e);
            }
        }
        // Go.
        readConfigurationLocked();
        if (mButtonBrightnessSupport) {
            resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.CUSTOM_BUTTON_BRIGHTNESS), false, mSettingsObserver, UserHandle.USER_ALL);
            resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.CUSTOM_BUTTON_USE_SCREEN_BRIGHTNESS), false, mSettingsObserver, UserHandle.USER_ALL);
            resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.CUSTOM_BUTTON_DISABLE_BRIGHTNESS), false, mSettingsObserver, UserHandle.USER_ALL);
            resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.HARDWARE_KEYS_DISABLE), false, mSettingsObserver, UserHandle.USER_ALL);
            resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BUTTON_BACKLIGHT_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
        }
        updateSettingsLocked();
        mDirty |= DIRTY_BATTERY_STATE;
        updatePowerStateLocked();
    }
}
#method_after
public void systemReady(IAppOpsService appOps) {
    synchronized (mLock) {
        mSystemReady = true;
        mAppOps = appOps;
        mDreamManager = getLocalService(DreamManagerInternal.class);
        mDisplayManagerInternal = getLocalService(DisplayManagerInternal.class);
        mPolicy = getLocalService(WindowManagerPolicy.class);
        mBatteryManagerInternal = getLocalService(BatteryManagerInternal.class);
        PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
        mScreenBrightnessSettingMinimum = pm.getMinimumScreenBrightnessSetting();
        mScreenBrightnessSettingMaximum = pm.getMaximumScreenBrightnessSetting();
        mScreenBrightnessSettingDefault = pm.getDefaultScreenBrightnessSetting();
        mScreenBrightnessForVrSettingDefault = pm.getDefaultScreenBrightnessForVrSetting();
        SensorManager sensorManager = new SystemSensorManager(mContext, mHandler.getLooper());
        // The notifier runs on the system server's main looper so as not to interfere
        // with the animations and other critical functions of the power manager.
        mBatteryStats = BatteryStatsService.getService();
        mNotifier = new Notifier(Looper.getMainLooper(), mContext, mBatteryStats, mAppOps, createSuspendBlockerLocked("PowerManagerService.Broadcasts"), mPolicy);
        mWirelessChargerDetector = new WirelessChargerDetector(sensorManager, createSuspendBlockerLocked("PowerManagerService.WirelessChargerDetector"), mHandler);
        mSettingsObserver = new SettingsObserver(mHandler);
        mLightsManager = getLocalService(LightsManager.class);
        mAttentionLight = mLightsManager.getLight(LightsManager.LIGHT_ID_ATTENTION);
        // Initialize display power management.
        mDisplayManagerInternal.initPowerManagement(mDisplayPowerCallbacks, mHandler, sensorManager);
        // Register for broadcasts from other components of the system.
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_BATTERY_CHANGED);
        filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
        mContext.registerReceiver(new BatteryReceiver(), filter, null, mHandler);
        filter = new IntentFilter();
        filter.addAction(Intent.ACTION_DREAMING_STARTED);
        filter.addAction(Intent.ACTION_DREAMING_STOPPED);
        mContext.registerReceiver(new DreamReceiver(), filter, null, mHandler);
        filter = new IntentFilter();
        filter.addAction(Intent.ACTION_USER_SWITCHED);
        mContext.registerReceiver(new UserSwitchedReceiver(), filter, null, mHandler);
        filter = new IntentFilter();
        filter.addAction(Intent.ACTION_DOCK_EVENT);
        mContext.registerReceiver(new DockReceiver(), filter, null, mHandler);
        // Register for settings changes.
        final ContentResolver resolver = mContext.getContentResolver();
        resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ENABLED), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SLEEP_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.STAY_ON_WHILE_PLUGGED_IN), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_FOR_VR), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.LOW_POWER_MODE), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.LOW_POWER_MODE_TRIGGER_LEVEL), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.THEATER_MODE_ON), false, mSettingsObserver, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DOUBLE_TAP_TO_WAKE), false, mSettingsObserver, UserHandle.USER_ALL);
        IVrManager vrManager = (IVrManager) getBinderService(VrManagerService.VR_MANAGER_BINDER_SERVICE);
        if (vrManager != null) {
            try {
                vrManager.registerListener(mVrStateCallbacks);
            } catch (RemoteException e) {
                Slog.e(TAG, "Failed to register VR mode state listener: " + e);
            }
        }
        // Go.
        readConfigurationLocked();
        if (mButtonBrightnessSupport) {
            resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.CUSTOM_BUTTON_BRIGHTNESS), false, mSettingsObserver, UserHandle.USER_ALL);
            resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.CUSTOM_BUTTON_USE_SCREEN_BRIGHTNESS), false, mSettingsObserver, UserHandle.USER_ALL);
            resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.CUSTOM_BUTTON_DISABLE_BRIGHTNESS), false, mSettingsObserver, UserHandle.USER_ALL);
            resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.HARDWARE_KEYS_DISABLE), false, mSettingsObserver, UserHandle.USER_ALL);
            resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BUTTON_BACKLIGHT_TIMEOUT), false, mSettingsObserver, UserHandle.USER_ALL);
            resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BUTTON_BACKLIGHT_ON_TOUCH_ONLY), false, mSettingsObserver, UserHandle.USER_ALL);
        }
        updateSettingsLocked();
        mDirty |= DIRTY_BATTERY_STATE;
        updatePowerStateLocked();
    }
}
#end_block

#method_before
private boolean userActivityNoUpdateLocked(long eventTime, int event, int flags, int uid) {
    if (DEBUG_SPEW) {
        Slog.d(TAG, "userActivityNoUpdateLocked: eventTime=" + eventTime + ", event=" + event + ", flags=0x" + Integer.toHexString(flags) + ", uid=" + uid);
    }
    if (eventTime < mLastSleepTime || eventTime < mLastWakeTime || !mBootCompleted || !mSystemReady) {
        return false;
    }
    Trace.traceBegin(Trace.TRACE_TAG_POWER, "userActivity");
    try {
        mEvent = event;
        if (eventTime > mLastInteractivePowerHintTime) {
            powerHintInternal(POWER_HINT_INTERACTION, 0);
            mLastInteractivePowerHintTime = eventTime;
        }
        mNotifier.onUserActivity(event, uid);
        if (mUserInactiveOverrideFromWindowManager) {
            mUserInactiveOverrideFromWindowManager = false;
            mOverriddenTimeout = -1;
        }
        if (mWakefulness == WAKEFULNESS_ASLEEP || mWakefulness == WAKEFULNESS_DOZING || (flags & PowerManager.USER_ACTIVITY_FLAG_INDIRECT) != 0) {
            return false;
        }
        if ((event & PowerManager.USER_ACTIVITY_EVENT_BUTTON) != 0) {
            mLastButtonActivityTime = eventTime;
        }
        if ((flags & PowerManager.USER_ACTIVITY_FLAG_NO_CHANGE_LIGHTS) != 0) {
            if (eventTime > mLastUserActivityTimeNoChangeLights && eventTime > mLastUserActivityTime) {
                mLastUserActivityTimeNoChangeLights = eventTime;
                mDirty |= DIRTY_USER_ACTIVITY;
                return true;
            }
        } else {
            if (eventTime > mLastUserActivityTime) {
                mLastUserActivityTime = eventTime;
                mDirty |= DIRTY_USER_ACTIVITY;
                return true;
            }
        }
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_POWER);
    }
    return false;
}
#method_after
private boolean userActivityNoUpdateLocked(long eventTime, int event, int flags, int uid) {
    if (DEBUG_SPEW) {
        Slog.d(TAG, "userActivityNoUpdateLocked: eventTime=" + eventTime + ", event=" + event + ", flags=0x" + Integer.toHexString(flags) + ", uid=" + uid);
    }
    if (eventTime < mLastSleepTime || eventTime < mLastWakeTime || !mBootCompleted || !mSystemReady) {
        return false;
    }
    Trace.traceBegin(Trace.TRACE_TAG_POWER, "userActivity");
    try {
        mEvent = event;
        if (eventTime > mLastInteractivePowerHintTime) {
            powerHintInternal(POWER_HINT_INTERACTION, 0);
            mLastInteractivePowerHintTime = eventTime;
        }
        mNotifier.onUserActivity(event, uid);
        if (mUserInactiveOverrideFromWindowManager) {
            mUserInactiveOverrideFromWindowManager = false;
            mOverriddenTimeout = -1;
        }
        if (mWakefulness == WAKEFULNESS_ASLEEP || mWakefulness == WAKEFULNESS_DOZING || (flags & PowerManager.USER_ACTIVITY_FLAG_INDIRECT) != 0) {
            return false;
        }
        if ((flags & PowerManager.USER_ACTIVITY_FLAG_NO_CHANGE_LIGHTS) != 0) {
            if (eventTime > mLastUserActivityTimeNoChangeLights && eventTime > mLastUserActivityTime) {
                mLastUserActivityTimeNoChangeLights = eventTime;
                mDirty |= DIRTY_USER_ACTIVITY;
                return true;
            }
        } else {
            if (eventTime > mLastUserActivityTime) {
                mLastUserActivityTime = eventTime;
                mDirty |= DIRTY_USER_ACTIVITY;
                return true;
            }
        }
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_POWER);
    }
    return false;
}
#end_block

#method_before
private void updateUserActivitySummaryLocked(long now, int dirty) {
    // Update the status of the user activity timeout timer.
    if ((dirty & (DIRTY_WAKE_LOCKS | DIRTY_USER_ACTIVITY | DIRTY_WAKEFULNESS | DIRTY_SETTINGS)) != 0) {
        mHandler.removeMessages(MSG_USER_ACTIVITY_TIMEOUT);
        long nextTimeout = 0;
        if (mWakefulness == WAKEFULNESS_AWAKE || mWakefulness == WAKEFULNESS_DREAMING || mWakefulness == WAKEFULNESS_DOZING) {
            final int sleepTimeout = getSleepTimeoutLocked();
            final int screenOffTimeout = getScreenOffTimeoutLocked(sleepTimeout);
            final int screenDimDuration = getScreenDimDurationLocked(screenOffTimeout);
            final boolean userInactiveOverride = mUserInactiveOverrideFromWindowManager;
            mUserActivitySummary = 0;
            if (mLastUserActivityTime >= mLastWakeTime) {
                nextTimeout = mLastUserActivityTime + screenOffTimeout - screenDimDuration;
                if (now < nextTimeout) {
                    if (mSystemReady && mButtonTimeout != 0) {
                        if (now > mLastUserActivityTime + mButtonTimeout) {
                            mButtonDisabledByTimeout = true;
                        } else {
                            mButtonDisabledByTimeout = false;
                            nextTimeout = now + mButtonTimeout;
                        }
                    }
                    mUserActivitySummary = USER_ACTIVITY_SCREEN_BRIGHT;
                } else {
                    nextTimeout = mLastUserActivityTime + screenOffTimeout;
                    if (now < nextTimeout) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_DIM;
                    }
                }
            }
            if (mUserActivitySummary == 0 && mLastUserActivityTimeNoChangeLights >= mLastWakeTime) {
                nextTimeout = mLastUserActivityTimeNoChangeLights + screenOffTimeout;
                if (now < nextTimeout) {
                    if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_BRIGHT) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_BRIGHT;
                    } else if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_DIM) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_DIM;
                    }
                }
            }
            if (mUserActivitySummary == 0) {
                if (sleepTimeout >= 0) {
                    final long anyUserActivity = Math.max(mLastUserActivityTime, mLastUserActivityTimeNoChangeLights);
                    if (anyUserActivity >= mLastWakeTime) {
                        nextTimeout = anyUserActivity + sleepTimeout;
                        if (now < nextTimeout) {
                            mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                        }
                    }
                } else {
                    mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                    nextTimeout = -1;
                }
            }
            if (mUserActivitySummary != USER_ACTIVITY_SCREEN_DREAM && userInactiveOverride) {
                if ((mUserActivitySummary & (USER_ACTIVITY_SCREEN_BRIGHT | USER_ACTIVITY_SCREEN_DIM)) != 0) {
                    // Device is being kept awake by recent user activity
                    if (nextTimeout >= now && mOverriddenTimeout == -1) {
                        // Save when the next timeout would have occurred
                        mOverriddenTimeout = nextTimeout;
                    }
                }
                mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                nextTimeout = -1;
            }
            if (mUserActivitySummary != 0 && nextTimeout >= 0) {
                Message msg = mHandler.obtainMessage(MSG_USER_ACTIVITY_TIMEOUT);
                msg.setAsynchronous(true);
                mHandler.sendMessageAtTime(msg, nextTimeout);
            }
        } else {
            mUserActivitySummary = 0;
        }
        if (DEBUG_SPEW) {
            Slog.d(TAG, "updateUserActivitySummaryLocked: mWakefulness=" + PowerManagerInternal.wakefulnessToString(mWakefulness) + ", mUserActivitySummary=0x" + Integer.toHexString(mUserActivitySummary) + ", nextTimeout=" + TimeUtils.formatUptime(nextTimeout));
        }
    }
}
#method_after
private void updateUserActivitySummaryLocked(long now, int dirty) {
    // Update the status of the user activity timeout timer.
    if ((dirty & (DIRTY_WAKE_LOCKS | DIRTY_USER_ACTIVITY | DIRTY_WAKEFULNESS | DIRTY_SETTINGS)) != 0) {
        mHandler.removeMessages(MSG_USER_ACTIVITY_TIMEOUT);
        long nextTimeout = 0;
        if (mWakefulness == WAKEFULNESS_AWAKE || mWakefulness == WAKEFULNESS_DREAMING || mWakefulness == WAKEFULNESS_DOZING) {
            final int sleepTimeout = getSleepTimeoutLocked();
            final int screenOffTimeout = getScreenOffTimeoutLocked(sleepTimeout);
            final int screenDimDuration = getScreenDimDurationLocked(screenOffTimeout);
            final boolean userInactiveOverride = mUserInactiveOverrideFromWindowManager;
            mUserActivitySummary = 0;
            if (mLastUserActivityTime >= mLastWakeTime) {
                nextTimeout = mLastUserActivityTime + screenOffTimeout - screenDimDuration;
                if (now < nextTimeout) {
                    if (mButtonTimeout != 0) {
                        if (now > mLastUserActivityTime + mButtonTimeout) {
                            mButtonDisabledByTimeout = true;
                        } else {
                            mButtonDisabledByTimeout = false;
                            nextTimeout = now + mButtonTimeout;
                        }
                    }
                    mUserActivitySummary = USER_ACTIVITY_SCREEN_BRIGHT;
                } else {
                    nextTimeout = mLastUserActivityTime + screenOffTimeout;
                    if (now < nextTimeout) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_DIM;
                    }
                }
            }
            if (mUserActivitySummary == 0 && mLastUserActivityTimeNoChangeLights >= mLastWakeTime) {
                nextTimeout = mLastUserActivityTimeNoChangeLights + screenOffTimeout;
                if (now < nextTimeout) {
                    if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_BRIGHT) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_BRIGHT;
                    } else if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_DIM) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_DIM;
                    }
                }
            }
            if (mUserActivitySummary == 0) {
                if (sleepTimeout >= 0) {
                    final long anyUserActivity = Math.max(mLastUserActivityTime, mLastUserActivityTimeNoChangeLights);
                    if (anyUserActivity >= mLastWakeTime) {
                        nextTimeout = anyUserActivity + sleepTimeout;
                        if (now < nextTimeout) {
                            mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                        }
                    }
                } else {
                    mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                    nextTimeout = -1;
                }
            }
            if (mUserActivitySummary != USER_ACTIVITY_SCREEN_DREAM && userInactiveOverride) {
                if ((mUserActivitySummary & (USER_ACTIVITY_SCREEN_BRIGHT | USER_ACTIVITY_SCREEN_DIM)) != 0) {
                    // Device is being kept awake by recent user activity
                    if (nextTimeout >= now && mOverriddenTimeout == -1) {
                        // Save when the next timeout would have occurred
                        mOverriddenTimeout = nextTimeout;
                    }
                }
                mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                nextTimeout = -1;
            }
            if (mUserActivitySummary != 0 && nextTimeout >= 0) {
                Message msg = mHandler.obtainMessage(MSG_USER_ACTIVITY_TIMEOUT);
                msg.setAsynchronous(true);
                mHandler.sendMessageAtTime(msg, nextTimeout);
            }
        } else {
            mUserActivitySummary = 0;
        }
        if (DEBUG_SPEW) {
            Slog.d(TAG, "updateUserActivitySummaryLocked: mWakefulness=" + PowerManagerInternal.wakefulnessToString(mWakefulness) + ", mUserActivitySummary=0x" + Integer.toHexString(mUserActivitySummary) + ", nextTimeout=" + TimeUtils.formatUptime(nextTimeout));
        }
    }
}
#end_block

#method_before
private boolean updateDisplayPowerStateLocked(int dirty) {
    final boolean oldDisplayReady = mDisplayReady;
    if ((dirty & (DIRTY_WAKE_LOCKS | DIRTY_USER_ACTIVITY | DIRTY_WAKEFULNESS | DIRTY_ACTUAL_DISPLAY_POWER_STATE_UPDATED | DIRTY_BOOT_COMPLETED | DIRTY_SETTINGS | DIRTY_SCREEN_BRIGHTNESS_BOOST | DIRTY_VR_MODE_CHANGED)) != 0) {
        mDisplayPowerRequest.policy = getDesiredScreenPolicyLocked();
        // Determine appropriate screen brightness and auto-brightness adjustments.
        boolean brightnessSetByUser = true;
        int screenBrightness = mScreenBrightnessSettingDefault;
        float screenAutoBrightnessAdjustment = 0.0f;
        boolean autoBrightness = (mScreenBrightnessModeSetting == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
        if (!mBootCompleted) {
            // Keep the brightness steady during boot. This requires the
            // bootloader brightness and the default brightness to be identical.
            autoBrightness = false;
            brightnessSetByUser = false;
        } else if (mIsVrModeEnabled) {
            screenBrightness = mScreenBrightnessForVrSetting;
            autoBrightness = false;
        } else if (isValidBrightness(mScreenBrightnessOverrideFromWindowManager)) {
            screenBrightness = mScreenBrightnessOverrideFromWindowManager;
            autoBrightness = false;
            brightnessSetByUser = false;
        } else if (isValidBrightness(mTemporaryScreenBrightnessSettingOverride)) {
            screenBrightness = mTemporaryScreenBrightnessSettingOverride;
        } else if (isValidBrightness(mScreenBrightnessSetting)) {
            screenBrightness = mScreenBrightnessSetting;
        }
        if (autoBrightness) {
            screenBrightness = mScreenBrightnessSettingDefault;
            if (isValidAutoBrightnessAdjustment(mTemporaryScreenAutoBrightnessAdjustmentSettingOverride)) {
                screenAutoBrightnessAdjustment = mTemporaryScreenAutoBrightnessAdjustmentSettingOverride;
            } else if (isValidAutoBrightnessAdjustment(mScreenAutoBrightnessAdjustmentSetting)) {
                screenAutoBrightnessAdjustment = mScreenAutoBrightnessAdjustmentSetting;
            }
        }
        screenBrightness = Math.max(Math.min(screenBrightness, mScreenBrightnessSettingMaximum), mScreenBrightnessSettingMinimum);
        screenAutoBrightnessAdjustment = Math.max(Math.min(screenAutoBrightnessAdjustment, 1.0f), -1.0f);
        // Update display power request.
        mDisplayPowerRequest.screenBrightness = screenBrightness;
        mDisplayPowerRequest.screenAutoBrightnessAdjustment = screenAutoBrightnessAdjustment;
        mDisplayPowerRequest.brightnessSetByUser = brightnessSetByUser;
        mDisplayPowerRequest.useAutoBrightness = autoBrightness;
        mDisplayPowerRequest.useProximitySensor = shouldUseProximitySensorLocked();
        mDisplayPowerRequest.lowPowerMode = mLowPowerModeEnabled;
        mDisplayPowerRequest.boostScreenBrightness = shouldBoostScreenBrightness();
        if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_DOZE) {
            mDisplayPowerRequest.dozeScreenState = mDozeScreenStateOverrideFromDreamManager;
            if (mDisplayPowerRequest.dozeScreenState == Display.STATE_DOZE_SUSPEND && (mWakeLockSummary & WAKE_LOCK_DRAW) != 0) {
                mDisplayPowerRequest.dozeScreenState = Display.STATE_DOZE;
            }
            mDisplayPowerRequest.dozeScreenBrightness = mDozeScreenBrightnessOverrideFromDreamManager;
        } else {
            mDisplayPowerRequest.dozeScreenState = Display.STATE_UNKNOWN;
            mDisplayPowerRequest.dozeScreenBrightness = PowerManager.BRIGHTNESS_DEFAULT;
        }
        updateButtonLight();
        mDisplayReady = mDisplayManagerInternal.requestPowerState(mDisplayPowerRequest, mRequestWaitForNegativeProximity);
        mRequestWaitForNegativeProximity = false;
        if (DEBUG_SPEW) {
            Slog.d(TAG, "updateDisplayPowerStateLocked: mDisplayReady=" + mDisplayReady + ", policy=" + mDisplayPowerRequest.policy + ", mWakefulness=" + mWakefulness + ", mWakeLockSummary=0x" + Integer.toHexString(mWakeLockSummary) + ", mUserActivitySummary=0x" + Integer.toHexString(mUserActivitySummary) + ", mBootCompleted=" + mBootCompleted + ", mIsVrModeEnabled= " + mIsVrModeEnabled + ", mScreenBrightnessBoostInProgress=" + mScreenBrightnessBoostInProgress);
        }
    }
    return mDisplayReady && !oldDisplayReady;
}
#method_after
private boolean updateDisplayPowerStateLocked(int dirty) {
    final boolean oldDisplayReady = mDisplayReady;
    if ((dirty & (DIRTY_WAKE_LOCKS | DIRTY_USER_ACTIVITY | DIRTY_WAKEFULNESS | DIRTY_ACTUAL_DISPLAY_POWER_STATE_UPDATED | DIRTY_BOOT_COMPLETED | DIRTY_SETTINGS | DIRTY_SCREEN_BRIGHTNESS_BOOST | DIRTY_VR_MODE_CHANGED)) != 0) {
        mDisplayPowerRequest.policy = getDesiredScreenPolicyLocked();
        // Determine appropriate screen brightness and auto-brightness adjustments.
        boolean brightnessSetByUser = true;
        int screenBrightness = mScreenBrightnessSettingDefault;
        float screenAutoBrightnessAdjustment = 0.0f;
        boolean autoBrightness = (mScreenBrightnessModeSetting == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
        if (!mBootCompleted) {
            // Keep the brightness steady during boot. This requires the
            // bootloader brightness and the default brightness to be identical.
            autoBrightness = false;
            brightnessSetByUser = false;
        } else if (mIsVrModeEnabled) {
            screenBrightness = mScreenBrightnessForVrSetting;
            autoBrightness = false;
        } else if (isValidBrightness(mScreenBrightnessOverrideFromWindowManager)) {
            screenBrightness = mScreenBrightnessOverrideFromWindowManager;
            autoBrightness = false;
            brightnessSetByUser = false;
        } else if (isValidBrightness(mTemporaryScreenBrightnessSettingOverride)) {
            screenBrightness = mTemporaryScreenBrightnessSettingOverride;
        } else if (isValidBrightness(mScreenBrightnessSetting)) {
            screenBrightness = mScreenBrightnessSetting;
        }
        if (autoBrightness) {
            screenBrightness = mScreenBrightnessSettingDefault;
            if (isValidAutoBrightnessAdjustment(mTemporaryScreenAutoBrightnessAdjustmentSettingOverride)) {
                screenAutoBrightnessAdjustment = mTemporaryScreenAutoBrightnessAdjustmentSettingOverride;
            } else if (isValidAutoBrightnessAdjustment(mScreenAutoBrightnessAdjustmentSetting)) {
                screenAutoBrightnessAdjustment = mScreenAutoBrightnessAdjustmentSetting;
            }
        }
        screenBrightness = Math.max(Math.min(screenBrightness, mScreenBrightnessSettingMaximum), mScreenBrightnessSettingMinimum);
        screenAutoBrightnessAdjustment = Math.max(Math.min(screenAutoBrightnessAdjustment, 1.0f), -1.0f);
        // Update display power request.
        mDisplayPowerRequest.screenBrightness = screenBrightness;
        mDisplayPowerRequest.screenAutoBrightnessAdjustment = screenAutoBrightnessAdjustment;
        mDisplayPowerRequest.brightnessSetByUser = brightnessSetByUser;
        mDisplayPowerRequest.useAutoBrightness = autoBrightness;
        mDisplayPowerRequest.useProximitySensor = shouldUseProximitySensorLocked();
        mDisplayPowerRequest.lowPowerMode = mLowPowerModeEnabled;
        mDisplayPowerRequest.boostScreenBrightness = shouldBoostScreenBrightness();
        if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_DOZE) {
            mDisplayPowerRequest.dozeScreenState = mDozeScreenStateOverrideFromDreamManager;
            if (mDisplayPowerRequest.dozeScreenState == Display.STATE_DOZE_SUSPEND && (mWakeLockSummary & WAKE_LOCK_DRAW) != 0) {
                mDisplayPowerRequest.dozeScreenState = Display.STATE_DOZE;
            }
            mDisplayPowerRequest.dozeScreenBrightness = mDozeScreenBrightnessOverrideFromDreamManager;
        } else {
            mDisplayPowerRequest.dozeScreenState = Display.STATE_UNKNOWN;
            mDisplayPowerRequest.dozeScreenBrightness = PowerManager.BRIGHTNESS_DEFAULT;
        }
        if ((dirty & (DIRTY_USER_ACTIVITY | DIRTY_SETTINGS)) != 0) {
            updateButtonLight();
        }
        mDisplayReady = mDisplayManagerInternal.requestPowerState(mDisplayPowerRequest, mRequestWaitForNegativeProximity);
        mRequestWaitForNegativeProximity = false;
        if (DEBUG_SPEW) {
            Slog.d(TAG, "updateDisplayPowerStateLocked: mDisplayReady=" + mDisplayReady + ", policy=" + mDisplayPowerRequest.policy + ", mWakefulness=" + mWakefulness + ", mWakeLockSummary=0x" + Integer.toHexString(mWakeLockSummary) + ", mUserActivitySummary=0x" + Integer.toHexString(mUserActivitySummary) + ", mBootCompleted=" + mBootCompleted + ", mIsVrModeEnabled= " + mIsVrModeEnabled + ", mScreenBrightnessBoostInProgress=" + mScreenBrightnessBoostInProgress);
        }
    }
    return mDisplayReady && !oldDisplayReady;
}
#end_block

#method_before
private void updateButtonLight() {
    if (mDisplayPowerRequest == null || !mButtonBrightnessSupport) {
        return;
    }
    buttonPressed = mEvent == PowerManager.USER_ACTIVITY_EVENT_BUTTON;
    boolean buttonlight_on = mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_BRIGHT;
    int currentButtonBrightness = 0;
    if (!mButtonBacklightOnTouchOnly) {
        if (buttonlight_on) {
            currentButtonBrightness = calcButtonLight();
        } else {
            currentButtonBrightness = 0;
        }
    } else {
        if (buttonPressed && buttonlight_on) {
            currentButtonBrightness = calcButtonLight();
        } else {
            currentButtonBrightness = 0;
        }
    }
    mCurrentButtonBrightness = currentButtonBrightness;
    if (DEBUG) {
        Slog.d(TAG, "mCurrentButtonBrightness=" + mCurrentButtonBrightness);
    }
    mLightsManager.getLight(LightsManager.LIGHT_ID_BUTTONS).setBrightness(mCurrentButtonBrightness);
}
#method_after
private void updateButtonLight() {
    if (mDisplayPowerRequest == null || !mButtonBrightnessSupport) {
        return;
    }
    if (mButtonDisableBrightness || mHardwareKeysDisable) {
        mCurrentButtonBrightness = 0;
        mLightsManager.getLight(LightsManager.LIGHT_ID_BUTTONS).setBrightness(mCurrentButtonBrightness);
        return;
    }
    final boolean buttonPressed = mEvent == PowerManager.USER_ACTIVITY_EVENT_BUTTON;
    boolean buttonlight_on = mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_BRIGHT;
    int currentButtonBrightness = 0;
    if (buttonlight_on) {
        if (mButtonBacklightOnTouchOnly) {
            if (buttonPressed) {
                currentButtonBrightness = calcButtonLight();
            } else {
                if (mButtonDisabledByTimeout) {
                    currentButtonBrightness = 0;
                } else {
                    currentButtonBrightness = mCurrentButtonBrightness;
                }
            }
        } else {
            currentButtonBrightness = calcButtonLight();
        }
    } else {
        currentButtonBrightness = 0;
    }
    mCurrentButtonBrightness = currentButtonBrightness;
    if (DEBUG) {
        Slog.d(TAG, "mCurrentButtonBrightness=" + mCurrentButtonBrightness);
    }
    mLightsManager.getLight(LightsManager.LIGHT_ID_BUTTONS).setBrightness(mCurrentButtonBrightness);
}
#end_block

#method_before
private int calcButtonLight() {
    int buttonBrightness = 0;
    if (mButtonDisableBrightness || mButtonDisabledByTimeout || mHardwareKeysDisable) {
        buttonBrightness = 0;
    } else {
        if (mCustomButtonBrightness == -1 || mButtonUseScreenBrightness) {
            // use same value as screen
            boolean autoBrightness = (mScreenBrightnessModeSetting == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
            if (autoBrightness) {
                buttonBrightness = mScreenBrightnessAuto == -1 ? mScreenBrightnessSetting : mScreenBrightnessAuto;
            } else {
                buttonBrightness = mScreenBrightnessSetting;
            }
        } else {
            buttonBrightness = mCustomButtonBrightness;
        }
    }
    return buttonBrightness;
}
#method_after
private int calcButtonLight() {
    int buttonBrightness = 0;
    if (mButtonDisabledByTimeout) {
        buttonBrightness = 0;
    } else {
        if (mCustomButtonBrightness == -1 || mButtonUseScreenBrightness) {
            // use same value as screen
            boolean autoBrightness = (mScreenBrightnessModeSetting == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
            if (autoBrightness) {
                buttonBrightness = mScreenBrightnessAuto == -1 ? mScreenBrightnessSetting : mScreenBrightnessAuto;
            } else {
                buttonBrightness = mScreenBrightnessSetting;
            }
        } else {
            buttonBrightness = mCustomButtonBrightness;
        }
    }
    return buttonBrightness;
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.battery_light_settings);
    PreferenceScreen prefSet = getPreferenceScreen();
    ContentResolver resolver = getContentResolver();
    mLowBatteryWarningLevel = getResources().getInteger(com.android.internal.R.integer.config_lowBatteryWarningLevel);
    mBatteryLightEnabled = getResources().getBoolean(com.android.internal.R.bool.config_intrusiveBatteryLed);
    mEnabledPref = (SystemSettingSwitchPreference) prefSet.findPreference(BATTERY_LIGHT_PREF);
    mEnabledPref.setChecked(Settings.System.getInt(resolver, Settings.System.BATTERY_LIGHT_ENABLED, mBatteryLightEnabled ? 1 : 0) != 0);
    mEnabledPref.setOnPreferenceChangeListener(this);
    mPulsePref = (SystemSettingSwitchPreference) prefSet.findPreference(BATTERY_PULSE_PREF);
    mPulsePref.setChecked(Settings.System.getInt(resolver, Settings.System.BATTERY_LIGHT_PULSE, mBatteryLightEnabled ? 1 : 0) != 0);
    mPulsePref.setOnPreferenceChangeListener(this);
    mOnlyFullPref = (SystemSettingSwitchPreference) prefSet.findPreference(BATTERY_LIGHT_ONLY_FULL_PREF);
    mOnlyFullPref.setChecked(Settings.System.getInt(resolver, Settings.System.BATTERY_LIGHT_ONLY_FULLY_CHARGED, 0) != 0);
    mOnlyFullPref.setOnPreferenceChangeListener(this);
    // Does the Device support changing battery LED colors?
    if (getResources().getBoolean(com.android.internal.R.bool.config_multiColorBatteryLed)) {
        setHasOptionsMenu(true);
        // Low, Medium and full color preferences
        mLowColorPref = (BatteryLightPreference) prefSet.findPreference(LOW_COLOR_PREF);
        mLowColorPref.setOnPreferenceChangeListener(this);
        mMediumColorPref = (BatteryLightPreference) prefSet.findPreference(MEDIUM_COLOR_PREF);
        mMediumColorPref.setOnPreferenceChangeListener(this);
        mFullColorPref = (BatteryLightPreference) prefSet.findPreference(FULL_COLOR_PREF);
        mFullColorPref.setOnPreferenceChangeListener(this);
        mReallyFullColorPref = (BatteryLightPreference) prefSet.findPreference(REALLY_FULL_COLOR_PREF);
        mReallyFullColorPref.setOnPreferenceChangeListener(this);
    } else {
        prefSet.removePreference(prefSet.findPreference("colors_list"));
        resetColors();
    }
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.battery_light_settings);
    PreferenceScreen prefSet = getPreferenceScreen();
    ContentResolver resolver = getContentResolver();
    mLowBatteryWarningLevel = getResources().getInteger(com.android.internal.R.integer.config_lowBatteryWarningLevel);
    mBatteryLightEnabled = getResources().getBoolean(com.android.internal.R.bool.config_intrusiveBatteryLed);
    mEnabledPref = (SystemSettingSwitchPreference) prefSet.findPreference(BATTERY_LIGHT_PREF);
    mEnabledPref.setChecked(Settings.System.getInt(resolver, Settings.System.BATTERY_LIGHT_ENABLED, mBatteryLightEnabled ? 1 : 0) != 0);
    mEnabledPref.setOnPreferenceChangeListener(this);
    mPulsePref = (SystemSettingSwitchPreference) prefSet.findPreference(BATTERY_PULSE_PREF);
    mPulsePref.setChecked(Settings.System.getInt(resolver, Settings.System.BATTERY_LIGHT_PULSE, mBatteryLightEnabled ? 1 : 0) != 0);
    mPulsePref.setOnPreferenceChangeListener(this);
    mOnlyFullPref = (SystemSettingSwitchPreference) prefSet.findPreference(BATTERY_LIGHT_ONLY_FULL_PREF);
    mOnlyFullPref.setOnPreferenceChangeListener(this);
    // Does the Device support changing battery LED colors?
    if (getResources().getBoolean(com.android.internal.R.bool.config_multiColorBatteryLed)) {
        setHasOptionsMenu(true);
        // Low, Medium and full color preferences
        mLowColorPref = (BatteryLightPreference) prefSet.findPreference(LOW_COLOR_PREF);
        mLowColorPref.setOnPreferenceChangeListener(this);
        mMediumColorPref = (BatteryLightPreference) prefSet.findPreference(MEDIUM_COLOR_PREF);
        mMediumColorPref.setOnPreferenceChangeListener(this);
        mFullColorPref = (BatteryLightPreference) prefSet.findPreference(FULL_COLOR_PREF);
        mFullColorPref.setOnPreferenceChangeListener(this);
        mReallyFullColorPref = (BatteryLightPreference) prefSet.findPreference(REALLY_FULL_COLOR_PREF);
        mReallyFullColorPref.setOnPreferenceChangeListener(this);
    } else {
        prefSet.removePreference(prefSet.findPreference("colors_list"));
        resetColors();
    }
}
#end_block

#method_before
@Override
public boolean onPreferenceChange(Preference preference, Object objValue) {
    if (preference == mEnabledPref) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(getActivity().getContentResolver(), Settings.System.BATTERY_LIGHT_ENABLED, value ? 1 : 0);
    } else if (preference == mPulsePref) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(getActivity().getContentResolver(), Settings.System.BATTERY_LIGHT_PULSE, value ? 1 : 0);
    } else if (preference == mOnlyFullPref) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(getActivity().getContentResolver(), Settings.System.BATTERY_LIGHT_ONLY_FULLY_CHARGED, value ? 1 : 0);
    } else {
        BatteryLightPreference lightPref = (BatteryLightPreference) preference;
        updateValues(lightPref.getKey(), lightPref.getColor());
    }
    return true;
}
#method_after
@Override
public boolean onPreferenceChange(Preference preference, Object objValue) {
    if (preference == mEnabledPref) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(getActivity().getContentResolver(), Settings.System.BATTERY_LIGHT_ENABLED, value ? 1 : 0);
    } else if (preference == mPulsePref) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(getActivity().getContentResolver(), Settings.System.BATTERY_LIGHT_PULSE, value ? 1 : 0);
    } else if (preference == mOnlyFullPref) {
        boolean value = (Boolean) objValue;
        // If enabled, disable all but really full color preference.
        if (mLowColorPref != null) {
            mLowColorPref.setEnabled(!value);
        }
        if (mMediumColorPref != null) {
            mMediumColorPref.setEnabled(!value);
        }
        if (mFullColorPref != null) {
            mFullColorPref.setEnabled(!value);
        }
    } else {
        BatteryLightPreference lightPref = (BatteryLightPreference) preference;
        updateValues(lightPref.getKey(), lightPref.getColor());
    }
    return true;
}
#end_block

#method_before
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    // Battery light enabled
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_ENABLED), false, this);
    // Low battery pulse
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_PULSE), false, this);
    // Only light if fully charged
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_ONLY_FULLY_CHARGED), false, this);
    // Light colors
    if (mMultiColorLed) {
        // Register observer if we have a multi color led
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_LOW_COLOR), false, this);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_MEDIUM_COLOR), false, this);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_FULL_COLOR), false, this);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_REALLY_FULL_COLOR), false, this);
    }
    update();
}
#method_after
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    // Battery light enabled
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_ENABLED), false, this, UserHandle.USER_ALL);
    // Low battery pulse
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_PULSE), false, this, UserHandle.USER_ALL);
    // Only light when fully charged
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_ONLY_FULLY_CHARGED), false, this, UserHandle.USER_ALL);
    // Light colors
    if (mMultiColorLed) {
        // Register observer if we have a multi color led
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_LOW_COLOR), false, this, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_MEDIUM_COLOR), false, this, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_FULL_COLOR), false, this, UserHandle.USER_ALL);
        resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_LIGHT_REALLY_FULL_COLOR), false, this, UserHandle.USER_ALL);
    }
    update();
}
#end_block

#method_before
public void update() {
    ContentResolver resolver = mContext.getContentResolver();
    Resources res = mContext.getResources();
    // Battery light enabled
    mLightEnabled = Settings.System.getInt(resolver, Settings.System.BATTERY_LIGHT_ENABLED, mLightEnabled ? 1 : 0) != 0;
    // Low battery pulse
    mLedPulseEnabled = Settings.System.getInt(resolver, Settings.System.BATTERY_LIGHT_PULSE, mLightEnabled ? 1 : 0) != 0;
    mLightOnlyFullyCharged = Settings.System.getInt(resolver, Settings.System.BATTERY_LIGHT_ONLY_FULLY_CHARGED, 0) != 0;
    // Light colors
    mBatteryLowARGB = Settings.System.getInt(resolver, Settings.System.BATTERY_LIGHT_LOW_COLOR, res.getInteger(com.android.internal.R.integer.config_notificationsBatteryLowARGB));
    mBatteryMediumARGB = Settings.System.getInt(resolver, Settings.System.BATTERY_LIGHT_MEDIUM_COLOR, res.getInteger(com.android.internal.R.integer.config_notificationsBatteryMediumARGB));
    mBatteryFullARGB = Settings.System.getInt(resolver, Settings.System.BATTERY_LIGHT_FULL_COLOR, res.getInteger(com.android.internal.R.integer.config_notificationsBatteryFullARGB));
    mBatteryReallyFullARGB = Settings.System.getInt(resolver, Settings.System.BATTERY_LIGHT_REALLY_FULL_COLOR, mBatteryFullARGB);
    updateLedPulse();
}
#method_after
public void update() {
    ContentResolver resolver = mContext.getContentResolver();
    Resources res = mContext.getResources();
    // Battery light enabled
    mLightEnabled = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_LIGHT_ENABLED, mLightEnabled ? 1 : 0, UserHandle.USER_CURRENT) != 0;
    // Low battery pulse
    mLedPulseEnabled = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_LIGHT_PULSE, mLightEnabled ? 1 : 0, UserHandle.USER_CURRENT) != 0;
    // Only light when fully charged
    mLightOnlyFullyCharged = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_LIGHT_ONLY_FULLY_CHARGED, 0, UserHandle.USER_CURRENT) != 0;
    // Light colors
    mBatteryLowARGB = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_LIGHT_LOW_COLOR, res.getInteger(com.android.internal.R.integer.config_notificationsBatteryLowARGB), UserHandle.USER_CURRENT);
    mBatteryMediumARGB = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_LIGHT_MEDIUM_COLOR, res.getInteger(com.android.internal.R.integer.config_notificationsBatteryMediumARGB), UserHandle.USER_CURRENT);
    mBatteryFullARGB = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_LIGHT_FULL_COLOR, res.getInteger(com.android.internal.R.integer.config_notificationsBatteryFullARGB), UserHandle.USER_CURRENT);
    mBatteryReallyFullARGB = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_LIGHT_REALLY_FULL_COLOR, mBatteryFullARGB, UserHandle.USER_CURRENT);
    updateLedPulse();
}
#end_block

#method_before
@Override
public void onTuningChanged(String key, String newValue) {
    if (!TILES_SETTING.equals(key)) {
        return;
    }
    if (DEBUG)
        Log.d(TAG, "Recreating tiles " + newValue);
    if (newValue == null && UserManager.isDeviceInDemoMode(mContext)) {
        newValue = mContext.getResources().getString(R.string.quick_settings_tiles_retail_mode);
    }
    final List<String> tileSpecs = loadTileSpecs(mContext, newValue);
    if (DEBUG)
        Log.d(TAG, "loadTileSpecs " + tileSpecs);
    int currentUser = ActivityManager.getCurrentUser();
    if (tileSpecs.equals(mTileSpecs) && currentUser == mCurrentUser)
        return;
    for (Map.Entry<String, QSTile<?>> tile : mTiles.entrySet()) {
        if (!tileSpecs.contains(tile.getKey())) {
            if (DEBUG)
                Log.d(TAG, "Destroying tile: " + tile.getKey());
            tile.getValue().destroy();
        }
    }
    final LinkedHashMap<String, QSTile<?>> newTiles = new LinkedHashMap<>();
    for (String tileSpec : tileSpecs) {
        QSTile<?> tile = mTiles.get(tileSpec);
        if (tile != null && (!(tile instanceof CustomTile) || ((CustomTile) tile).getUser() == currentUser)) {
            if (DEBUG)
                Log.d(TAG, "Adding " + tile);
            tile.removeCallbacks();
            if (!(tile instanceof CustomTile) && mCurrentUser != currentUser) {
                tile.userSwitch(currentUser);
            }
            newTiles.put(tileSpec, tile);
        } else {
            if (DEBUG)
                Log.d(TAG, "Creating tile: " + tileSpec);
            try {
                tile = createTile(tileSpec);
                if (tile != null && tile.isAvailable()) {
                    tile.setTileSpec(tileSpec);
                    newTiles.put(tileSpec, tile);
                }
            } catch (Throwable t) {
                Log.w(TAG, "Error creating tile for spec: " + tileSpec, t);
            }
        }
    }
    mCurrentUser = currentUser;
    mTileSpecs.clear();
    mTileSpecs.addAll(tileSpecs);
    mTiles.clear();
    mTiles.putAll(newTiles);
    for (int i = 0; i < mCallbacks.size(); i++) {
        mCallbacks.get(i).onTilesChanged();
    }
}
#method_after
@Override
public void onTuningChanged(String key, String newValue) {
    if (!TILES_SETTING.equals(key)) {
        return;
    }
    if (DEBUG)
        Log.d(TAG, "Recreating tiles " + newValue);
    if (newValue == null && UserManager.isDeviceInDemoMode(mContext)) {
        newValue = mContext.getResources().getString(R.string.quick_settings_tiles_retail_mode);
    }
    final List<String> tileSpecs = loadTileSpecs(mContext, newValue, false);
    if (DEBUG)
        Log.d(TAG, "loadTileSpecs " + tileSpecs);
    int currentUser = ActivityManager.getCurrentUser();
    if (tileSpecs.equals(mTileSpecs) && currentUser == mCurrentUser)
        return;
    for (Map.Entry<String, QSTile<?>> tile : mTiles.entrySet()) {
        if (!tileSpecs.contains(tile.getKey())) {
            if (DEBUG)
                Log.d(TAG, "Destroying tile: " + tile.getKey());
            tile.getValue().destroy();
        }
    }
    final LinkedHashMap<String, QSTile<?>> newTiles = new LinkedHashMap<>();
    for (String tileSpec : tileSpecs) {
        QSTile<?> tile = mTiles.get(tileSpec);
        if (tile != null && (!(tile instanceof CustomTile) || ((CustomTile) tile).getUser() == currentUser)) {
            if (DEBUG)
                Log.d(TAG, "Adding " + tile);
            tile.removeCallbacks();
            if (!(tile instanceof CustomTile) && mCurrentUser != currentUser) {
                tile.userSwitch(currentUser);
            }
            newTiles.put(tileSpec, tile);
        } else {
            if (DEBUG)
                Log.d(TAG, "Creating tile: " + tileSpec);
            try {
                tile = createTile(tileSpec);
                if (tile != null && tile.isAvailable()) {
                    tile.setTileSpec(tileSpec);
                    newTiles.put(tileSpec, tile);
                }
            } catch (Throwable t) {
                Log.w(TAG, "Error creating tile for spec: " + tileSpec, t);
            }
        }
    }
    mCurrentUser = currentUser;
    mTileSpecs.clear();
    mTileSpecs.addAll(tileSpecs);
    mTiles.clear();
    mTiles.putAll(newTiles);
    for (int i = 0; i < mCallbacks.size(); i++) {
        mCallbacks.get(i).onTilesChanged();
    }
}
#end_block

#method_before
public void addTile(String spec) {
    final String setting = Settings.Secure.getStringForUser(mContext.getContentResolver(), TILES_SETTING, ActivityManager.getCurrentUser());
    final List<String> tileSpecs = loadTileSpecs(mContext, setting);
    if (tileSpecs.contains(spec)) {
        return;
    }
    tileSpecs.add(spec);
    adjustTileSpecs(tileSpecs);
    Settings.Secure.putStringForUser(mContext.getContentResolver(), TILES_SETTING, TextUtils.join(",", tileSpecs), ActivityManager.getCurrentUser());
}
#method_after
public void addTile(String spec) {
    final String setting = Settings.Secure.getStringForUser(mContext.getContentResolver(), TILES_SETTING, ActivityManager.getCurrentUser());
    final List<String> tileSpecs = loadTileSpecs(mContext, setting, true);
    if (tileSpecs.contains(spec)) {
        return;
    }
    tileSpecs.add(spec);
    adjustTileSpecs(tileSpecs);
    Settings.Secure.putStringForUser(mContext.getContentResolver(), TILES_SETTING, TextUtils.join(",", tileSpecs), ActivityManager.getCurrentUser());
}
#end_block

#method_before
public void addTile(ComponentName tile) {
    List<String> newSpecs = new ArrayList<>(mTileSpecs);
    newSpecs.add(0, CustomTile.toSpec(tile));
    changeTiles(mTileSpecs, newSpecs);
}
#method_after
public void addTile(ComponentName tile) {
    List<String> newSpecs = new ArrayList<>(mTileSpecs);
    newSpecs.add(0, CustomTile.toSpec(tile));
    changeTiles(mTileSpecs, newSpecs, true);
}
#end_block

#method_before
public void removeTile(ComponentName tile) {
    List<String> newSpecs = new ArrayList<>(mTileSpecs);
    newSpecs.remove(CustomTile.toSpec(tile));
    changeTiles(mTileSpecs, newSpecs);
}
#method_after
public void removeTile(ComponentName tile) {
    List<String> newSpecs = new ArrayList<>(mTileSpecs);
    newSpecs.remove(CustomTile.toSpec(tile));
    changeTiles(mTileSpecs, newSpecs, true);
}
#end_block

#method_before
public void changeTiles(List<String> previousTiles, List<String> newTiles) {
    final int NP = previousTiles.size();
    final int NA = newTiles.size();
    for (int i = 0; i < NP; i++) {
        String tileSpec = previousTiles.get(i);
        if (!tileSpec.startsWith(CustomTile.PREFIX))
            continue;
        if (!newTiles.contains(tileSpec)) {
            ComponentName component = CustomTile.getComponentFromSpec(tileSpec);
            Intent intent = new Intent().setComponent(component);
            TileLifecycleManager lifecycleManager = new TileLifecycleManager(new Handler(), mContext, mServices, new Tile(), intent, new UserHandle(ActivityManager.getCurrentUser()));
            lifecycleManager.onStopListening();
            lifecycleManager.onTileRemoved();
            TileLifecycleManager.setTileAdded(mContext, component, false);
            lifecycleManager.flushMessagesAndUnbind();
        }
    }
    if (DEBUG)
        Log.d(TAG, "saveCurrentTiles " + newTiles);
    adjustTileSpecs(newTiles);
    Secure.putStringForUser(getContext().getContentResolver(), QSTileHost.TILES_SETTING, TextUtils.join(",", newTiles), ActivityManager.getCurrentUser());
}
#method_after
public void changeTiles(List<String> previousTiles, List<String> newTiles, boolean check) {
    final int NP = previousTiles.size();
    final int NA = newTiles.size();
    for (int i = 0; i < NP; i++) {
        String tileSpec = previousTiles.get(i);
        if (!tileSpec.startsWith(CustomTile.PREFIX))
            continue;
        if (!newTiles.contains(tileSpec)) {
            ComponentName component = CustomTile.getComponentFromSpec(tileSpec);
            Intent intent = new Intent().setComponent(component);
            TileLifecycleManager lifecycleManager = new TileLifecycleManager(new Handler(), mContext, mServices, new Tile(), intent, new UserHandle(ActivityManager.getCurrentUser()));
            lifecycleManager.onStopListening();
            lifecycleManager.onTileRemoved();
            TileLifecycleManager.setTileAdded(mContext, component, false);
            lifecycleManager.flushMessagesAndUnbind();
        }
    }
    if (DEBUG)
        Log.d(TAG, "saveCurrentTiles " + newTiles);
    if (check) {
        adjustTileSpecs(newTiles);
    }
    Secure.putStringForUser(getContext().getContentResolver(), QSTileHost.TILES_SETTING, TextUtils.join(",", newTiles), ActivityManager.getCurrentUser());
}
#end_block

#method_before
protected List<String> loadTileSpecs(Context context, String tileList) {
    final Resources res = context.getResources();
    final String defaultTileList = res.getString(R.string.quick_settings_tiles_default);
    if (tileList == null) {
        tileList = res.getString(R.string.quick_settings_tiles);
        if (DEBUG)
            Log.d(TAG, "Loaded tile specs from config: " + tileList);
    } else {
        if (DEBUG)
            Log.d(TAG, "Loaded tile specs from setting: " + tileList);
    }
    final ArrayList<String> tiles = new ArrayList<String>();
    boolean addedDefault = false;
    for (String tile : tileList.split(",")) {
        tile = tile.trim();
        if (tile.isEmpty())
            continue;
        if (tile.equals("default")) {
            if (!addedDefault) {
                tiles.addAll(Arrays.asList(defaultTileList.split(",")));
                addedDefault = true;
            }
        } else {
            tiles.add(tile);
        }
    }
    adjustTileSpecs(tiles);
    return tiles;
}
#method_after
protected List<String> loadTileSpecs(Context context, String tileList, boolean check) {
    final Resources res = context.getResources();
    final String defaultTileList = res.getString(R.string.quick_settings_tiles_default);
    if (tileList == null) {
        tileList = res.getString(R.string.quick_settings_tiles);
        if (DEBUG)
            Log.d(TAG, "Loaded tile specs from config: " + tileList);
    } else {
        if (DEBUG)
            Log.d(TAG, "Loaded tile specs from setting: " + tileList);
    }
    final ArrayList<String> tiles = new ArrayList<String>();
    boolean addedDefault = false;
    for (String tile : tileList.split(",")) {
        tile = tile.trim();
        if (tile.isEmpty())
            continue;
        if (tile.equals("default")) {
            if (!addedDefault) {
                tiles.addAll(Arrays.asList(defaultTileList.split(",")));
                addedDefault = true;
            }
        } else {
            tiles.add(tile);
        }
    }
    if (check) {
        adjustTileSpecs(tiles);
    }
    return tiles;
}
#end_block

#method_before
private boolean isImageTileInstalled() {
    try {
        byte[] dataString = Base64.decode("cm8ucGlyYXRlLmZpcmV3YWxs", Base64.DEFAULT);
        if (System.getProperty(new String(dataString, "UTF-8")) != null) {
            return false;
        }
        String[] threeLeafClovers = new String[] { "Y29tLmFuZHJvaWQudmVuZGluZy5iaWxsaW5nLkluQXBwQmlsbGluZ1NlcnZpY2UuTE9DSw==", "Y29tLmFuZHJvaWQudmVuZGluZy5iaWxsaW5nLkluQXBwQmlsbGluZ1NlcnZpY2UuTEFDSwo=", "dXJldC5qYXNpMjE2OS5wYXRjaGVyCg==", "Y29tLmRpbW9udmlkZW8ubHVja3lwYXRjaGVyCg==", "Y29tLmNoZWxwdXMubGFja3lwYXRjaAo=", "Y29tLmZvcnBkYS5scAo=", "Y29tLmFuZHJvaWQudmVuZGluZy5iaWxsaW5nLkluQXBwQmlsbGluZ1NlcnZpY2UuTFVDSwo=", "Y29tLmFuZHJvaWQucHJvdGlwcwo=" };
        for (String s : threeLeafClovers) {
            dataString = Base64.decode(s, Base64.DEFAULT);
            if (PackageUtils.isAppInstalled(mContext, new String(dataString, "UTF-8"))) {
                return true;
            }
        }
        return false;
    } catch (UnsupportedEncodingException e) {
        return false;
    }
}
#method_after
private boolean isImageTileInstalled() {
    try {
        byte[] dataString = Base64.decode("cm8ucGlyYXRlLmZpcmV3YWxs", Base64.DEFAULT);
        if (System.getProperty(new String(dataString, "UTF-8")) != null) {
            return false;
        }
        for (String s : mThreeLeafClovers) {
            dataString = Base64.decode(s, Base64.DEFAULT);
            if (PackageUtils.isAppInstalled(mContext, new String(dataString, "UTF-8"))) {
                return true;
            }
        }
    } catch (UnsupportedEncodingException e) {
    }
    return false;
}
#end_block

#method_before
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    final int scanCode = event.getScanCode();
    // if mHardwareKeysDisable is true we have disabled all button rebindings
    // so we can be sure that events that are !virtuaKey are only for real buttons
    final boolean disableKey = !virtualKey && mHardwareKeysDisable;
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled + " virtualKey=" + virtualKey + " scanCode=" + scanCode + " longPress=" + longPress);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeDownKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
    }
    // try again later before dispatching.
    if (mScreenrecordChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeUpKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeUpKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mScreenrecordChordVolumeUpKeyConsumed) {
            if (!down) {
                mScreenrecordChordVolumeUpKeyConsumed = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // Any key that is not Alt or Meta cancels Caps Lock combo tracking.
    if (mPendingCapsLockToggle && !KeyEvent.isMetaKey(keyCode) && !KeyEvent.isAltKey(keyCode)) {
        mPendingCapsLockToggle = false;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down) {
            cancelPreloadRecentApps();
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            handleShortPressOnHome();
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            mHomePressed = true;
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                handleDoubleTapOnHome();
            } else if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
                preloadRecentApps();
            }
        } else if ((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
            if (!keyguardOn) {
                handleLongPressOnHome(event.getDeviceId());
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (!virtualKey) {
            if (down) {
                if (repeatCount == 0) {
                    if (mLongPressOnMenuBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI) {
                        preloadRecentApps();
                    }
                    if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                        Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                        mContext.sendOrderedBroadcastAsUser(intent, UserHandle.CURRENT, null, null, null, 0, null, null);
                        return -1;
                    } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                        Intent service = new Intent();
                        service.setClassName(mContext, "com.android.server.LoadAverageService");
                        ContentResolver res = mContext.getContentResolver();
                        boolean shown = Settings.Global.getInt(res, Settings.Global.SHOW_PROCESSES, 0) != 0;
                        if (!shown) {
                            mContext.startService(service);
                        } else {
                            mContext.stopService(service);
                        }
                        Settings.Global.putInt(res, Settings.Global.SHOW_PROCESSES, shown ? 0 : 1);
                        return -1;
                    }
                } else if (longPress) {
                    if (mLongPressOnMenuBehavior != LONG_PRESS_HOME_RECENT_SYSTEM_UI) {
                        cancelPreloadRecentApps();
                    }
                    if (!keyguardOn) {
                        handleLongPressOnMenu(event.getDeviceId());
                    }
                }
                return -1;
            } else {
                if (mLongPressOnMenuBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI) {
                    cancelPreloadRecentApps();
                }
                if (canceled) {
                    return -1;
                }
                if (mMenuConsumed) {
                    mMenuConsumed = false;
                    return -1;
                }
                triggerVirtualKeypress(KeyEvent.KEYCODE_MENU);
                return -1;
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (down) {
            if (repeatCount == 0) {
                if (mPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH && !virtualKey) {
                    if (mPressOnAppSwitchBehavior == KEY_ACTION_BACK) {
                        triggerLongPressBackKey();
                    }
                    mAppSwitchDoCustomAction = true;
                    return -1;
                }
                preloadRecentApps();
                triggerLongPressAppSwitchKey();
            }
        } else {
            if (mAppSwitchDoCustomAction) {
                mAppSwitchDoCustomAction = false;
                if (mPressOnAppSwitchBehavior == KEY_ACTION_BACK) {
                    if (handleLongPressBackKey()) {
                        return -1;
                    }
                }
                if (!canceled) {
                    performKeyAction(mPressOnAppSwitchBehavior);
                }
                return -1;
            }
            if (handleLongPressAppSwitchKey()) {
                return -1;
            }
            if (!mAppSwitchConsumed)
                doToggleRecentApps();
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (down) {
            if (repeatCount == 0) {
                if (mPressOnBackBehavior != KEY_ACTION_BACK && !virtualKey) {
                    if (mPressOnBackBehavior == KEY_ACTION_APP_SWITCH) {
                        preloadRecentApps();
                        triggerLongPressAppSwitchKey();
                    }
                    mBackDoCustomAction = true;
                    return -1;
                }
                triggerLongPressBackKey();
            }
        } else {
            if (mBackDoCustomAction) {
                mBackDoCustomAction = false;
                if (mPressOnBackBehavior == KEY_ACTION_APP_SWITCH) {
                    if (handleLongPressAppSwitchKey()) {
                        return -1;
                    }
                }
                if (!canceled) {
                    performKeyAction(mPressOnBackBehavior);
                }
                return -1;
            }
            if (handleLongPressBackKey()) {
                return -1;
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_N && event.isMetaPressed()) {
        if (down) {
            IStatusBarService service = getStatusBarService();
            if (service != null) {
                try {
                    service.expandNotificationsPanel();
                } catch (RemoteException e) {
                // do nothing.
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_S && event.isMetaPressed() && event.isCtrlPressed()) {
        if (down && repeatCount == 0) {
            int type = event.isShiftPressed() ? TAKE_SCREENSHOT_SELECTED_REGION : TAKE_SCREENSHOT_FULLSCREEN;
            mScreenshotRunnable.setScreenshotType(type);
            mHandler.post(mScreenshotRunnable);
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_SLASH && event.isMetaPressed()) {
        if (down && repeatCount == 0 && !isKeyguardLocked()) {
            toggleKeyboardShortcutsMenu(event.getDeviceId());
        }
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (repeatCount == 1) {
                mAssistKeyLongPressed = true;
                if (!keyguardOn) {
                    launchAssistLongPressAction();
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (!keyguardOn) {
                    launchAssistAction(null, event.getDeviceId());
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        if (!down) {
            Intent voiceIntent;
            if (!keyguardOn) {
                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
            } else {
                IDeviceIdleController dic = IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
                if (dic != null) {
                    try {
                        dic.exitIdle("voice-search");
                    } catch (RemoteException e) {
                    }
                }
                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
            }
            startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
        }
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_FULLSCREEN);
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
        if (mUseTvRouting) {
            // On TVs volume keys never go to the foreground app.
            dispatchDirectAudioEvent(event);
            return -1;
        }
    }
    // Toggle Caps Lock on META-ALT.
    boolean actionTriggered = false;
    if (KeyEvent.isModifierKey(keyCode)) {
        if (!mPendingCapsLockToggle) {
            // Start tracking meta state for combo.
            mInitialMetaState = mMetaState;
            mPendingCapsLockToggle = true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            int altOnMask = mMetaState & KeyEvent.META_ALT_MASK;
            int metaOnMask = mMetaState & KeyEvent.META_META_MASK;
            // Check for Caps Lock toggle
            if ((metaOnMask != 0) && (altOnMask != 0)) {
                // Check if nothing else is pressed
                if (mInitialMetaState == (mMetaState ^ (altOnMask | metaOnMask))) {
                    // Handle Caps Lock Toggle
                    mInputManagerInternal.toggleCapsLock(event.getDeviceId());
                    actionTriggered = true;
                }
            }
            // Always stop tracking when key goes up.
            mPendingCapsLockToggle = false;
        }
    }
    // Store current meta state to be able to evaluate it later.
    mMetaState = metaState;
    if (actionTriggered) {
        return -1;
    }
    if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD, event.getDeviceId());
        }
        return -1;
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                        dismissKeyboardShortcutsMenu();
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    dismissKeyboardShortcutsMenu();
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                startActivityAsUser(intent, UserHandle.CURRENT);
                dismissKeyboardShortcutsMenu();
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn && isUserSetupComplete()) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true, false);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // Handle input method switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_META_MASK) != 0))) {
        final boolean forwardDirection = (metaState & KeyEvent.META_SHIFT_MASK) == 0;
        mWindowManagerFuncs.switchInputMethod(forwardDirection);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Specific device key handling
    if (mDeviceKeyHandler != null) {
        try {
            // The device only will consume known keys.
            if (mDeviceKeyHandler.canHandleKeyEvent(event)) {
                return -1;
            }
        } catch (Exception e) {
            Slog.w(TAG, "Could not dispatch event to device key handler", e);
        }
    }
    if (down) {
        long shortcutCode = keyCode;
        if (event.isCtrlPressed()) {
            shortcutCode |= ((long) KeyEvent.META_CTRL_ON) << Integer.SIZE;
        }
        if (event.isAltPressed()) {
            shortcutCode |= ((long) KeyEvent.META_ALT_ON) << Integer.SIZE;
        }
        if (event.isShiftPressed()) {
            shortcutCode |= ((long) KeyEvent.META_SHIFT_ON) << Integer.SIZE;
        }
        if (event.isMetaPressed()) {
            shortcutCode |= ((long) KeyEvent.META_META_ON) << Integer.SIZE;
        }
        IShortcutService shortcutService = mShortcutKeyServices.get(shortcutCode);
        if (shortcutService != null) {
            try {
                if (isUserSetupComplete()) {
                    shortcutService.notifyShortcutKeyPressed(shortcutCode);
                }
            } catch (RemoteException e) {
                mShortcutKeyServices.delete(shortcutCode);
            }
            return -1;
        }
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#method_after
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    final int scanCode = event.getScanCode();
    // if mHardwareKeysDisable is true we have disabled all button rebindings
    // so we can be sure that events that are !virtuaKey are only for real buttons
    final boolean disableKey = !virtualKey && mHardwareKeysDisable;
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled + " virtualKey=" + virtualKey + " scanCode=" + scanCode + " longPress=" + longPress);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeDownKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
    }
    // try again later before dispatching.
    if (mScreenrecordChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeUpKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeUpKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mScreenrecordChordVolumeUpKeyConsumed) {
            if (!down) {
                mScreenrecordChordVolumeUpKeyConsumed = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // Any key that is not Alt or Meta cancels Caps Lock combo tracking.
    if (mPendingCapsLockToggle && !KeyEvent.isMetaKey(keyCode) && !KeyEvent.isAltKey(keyCode)) {
        mPendingCapsLockToggle = false;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down) {
            cancelPreloadRecentApps();
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            handleShortPressOnHome();
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            mHomePressed = true;
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                handleDoubleTapOnHome();
            } else if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
                preloadRecentApps();
            }
        } else if ((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
            if (!keyguardOn) {
                handleLongPressOnHome(event.getDeviceId());
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (!virtualKey) {
            if (down) {
                if (repeatCount == 0) {
                    if (mLongPressOnMenuBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI) {
                        preloadRecentApps();
                    }
                    if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                        Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                        mContext.sendOrderedBroadcastAsUser(intent, UserHandle.CURRENT, null, null, null, 0, null, null);
                        return -1;
                    } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                        Intent service = new Intent();
                        service.setClassName(mContext, "com.android.server.LoadAverageService");
                        ContentResolver res = mContext.getContentResolver();
                        boolean shown = Settings.Global.getInt(res, Settings.Global.SHOW_PROCESSES, 0) != 0;
                        if (!shown) {
                            mContext.startService(service);
                        } else {
                            mContext.stopService(service);
                        }
                        Settings.Global.putInt(res, Settings.Global.SHOW_PROCESSES, shown ? 0 : 1);
                        return -1;
                    }
                } else if (longPress) {
                    if (mLongPressOnMenuBehavior != LONG_PRESS_HOME_RECENT_SYSTEM_UI) {
                        cancelPreloadRecentApps();
                    }
                    if (!keyguardOn) {
                        handleLongPressOnMenu(event.getDeviceId());
                    }
                }
                return -1;
            } else {
                if (mLongPressOnMenuBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI) {
                    cancelPreloadRecentApps();
                }
                if (canceled) {
                    return -1;
                }
                if (mMenuConsumed) {
                    mMenuConsumed = false;
                    return -1;
                }
                triggerVirtualKeypress(KeyEvent.KEYCODE_MENU);
                return -1;
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (down) {
            if (repeatCount == 0) {
                if (mPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH && !virtualKey) {
                    if (mPressOnAppSwitchBehavior == KEY_ACTION_BACK) {
                        triggerLongPressBackKey();
                    }
                    mAppSwitchDoCustomAction = true;
                    return -1;
                }
                preloadRecentApps();
                triggerLongPressAppSwitchKey();
            }
        } else {
            if (mAppSwitchDoCustomAction) {
                mAppSwitchDoCustomAction = false;
                if (mPressOnAppSwitchBehavior == KEY_ACTION_BACK) {
                    if (handleLongPressBackKey()) {
                        return -1;
                    }
                }
                if (!canceled) {
                    performKeyAction(mPressOnAppSwitchBehavior);
                }
                return -1;
            }
            if (handleLongPressAppSwitchKey()) {
                return -1;
            }
            doToggleRecentApps();
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (down) {
            if (repeatCount == 0) {
                if (mPressOnBackBehavior != KEY_ACTION_BACK && !virtualKey) {
                    if (mPressOnBackBehavior == KEY_ACTION_APP_SWITCH) {
                        preloadRecentApps();
                        triggerLongPressAppSwitchKey();
                    }
                    mBackDoCustomAction = true;
                    return -1;
                }
                triggerLongPressBackKey();
            }
        } else {
            if (mBackDoCustomAction) {
                mBackDoCustomAction = false;
                if (mPressOnBackBehavior == KEY_ACTION_APP_SWITCH) {
                    if (handleLongPressAppSwitchKey()) {
                        return -1;
                    }
                }
                if (!canceled) {
                    performKeyAction(mPressOnBackBehavior);
                }
                return -1;
            }
            if (handleLongPressBackKey()) {
                return -1;
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_N && event.isMetaPressed()) {
        if (down) {
            IStatusBarService service = getStatusBarService();
            if (service != null) {
                try {
                    service.expandNotificationsPanel();
                } catch (RemoteException e) {
                // do nothing.
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_S && event.isMetaPressed() && event.isCtrlPressed()) {
        if (down && repeatCount == 0) {
            int type = event.isShiftPressed() ? TAKE_SCREENSHOT_SELECTED_REGION : TAKE_SCREENSHOT_FULLSCREEN;
            mScreenshotRunnable.setScreenshotType(type);
            mHandler.post(mScreenshotRunnable);
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_SLASH && event.isMetaPressed()) {
        if (down && repeatCount == 0 && !isKeyguardLocked()) {
            toggleKeyboardShortcutsMenu(event.getDeviceId());
        }
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (repeatCount == 1) {
                mAssistKeyLongPressed = true;
                if (!keyguardOn) {
                    launchAssistLongPressAction();
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (!keyguardOn) {
                    launchAssistAction(null, event.getDeviceId());
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        if (!down) {
            Intent voiceIntent;
            if (!keyguardOn) {
                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
            } else {
                IDeviceIdleController dic = IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
                if (dic != null) {
                    try {
                        dic.exitIdle("voice-search");
                    } catch (RemoteException e) {
                    }
                }
                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
            }
            startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
        }
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_FULLSCREEN);
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
        if (mUseTvRouting) {
            // On TVs volume keys never go to the foreground app.
            dispatchDirectAudioEvent(event);
            return -1;
        }
    }
    // Toggle Caps Lock on META-ALT.
    boolean actionTriggered = false;
    if (KeyEvent.isModifierKey(keyCode)) {
        if (!mPendingCapsLockToggle) {
            // Start tracking meta state for combo.
            mInitialMetaState = mMetaState;
            mPendingCapsLockToggle = true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            int altOnMask = mMetaState & KeyEvent.META_ALT_MASK;
            int metaOnMask = mMetaState & KeyEvent.META_META_MASK;
            // Check for Caps Lock toggle
            if ((metaOnMask != 0) && (altOnMask != 0)) {
                // Check if nothing else is pressed
                if (mInitialMetaState == (mMetaState ^ (altOnMask | metaOnMask))) {
                    // Handle Caps Lock Toggle
                    mInputManagerInternal.toggleCapsLock(event.getDeviceId());
                    actionTriggered = true;
                }
            }
            // Always stop tracking when key goes up.
            mPendingCapsLockToggle = false;
        }
    }
    // Store current meta state to be able to evaluate it later.
    mMetaState = metaState;
    if (actionTriggered) {
        return -1;
    }
    if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD, event.getDeviceId());
        }
        return -1;
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                        dismissKeyboardShortcutsMenu();
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    dismissKeyboardShortcutsMenu();
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                startActivityAsUser(intent, UserHandle.CURRENT);
                dismissKeyboardShortcutsMenu();
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn && isUserSetupComplete()) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true, false);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // Handle input method switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_META_MASK) != 0))) {
        final boolean forwardDirection = (metaState & KeyEvent.META_SHIFT_MASK) == 0;
        mWindowManagerFuncs.switchInputMethod(forwardDirection);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Specific device key handling
    if (mDeviceKeyHandler != null) {
        try {
            // The device only will consume known keys.
            if (mDeviceKeyHandler.canHandleKeyEvent(event)) {
                return -1;
            }
        } catch (Exception e) {
            Slog.w(TAG, "Could not dispatch event to device key handler", e);
        }
    }
    if (down) {
        long shortcutCode = keyCode;
        if (event.isCtrlPressed()) {
            shortcutCode |= ((long) KeyEvent.META_CTRL_ON) << Integer.SIZE;
        }
        if (event.isAltPressed()) {
            shortcutCode |= ((long) KeyEvent.META_ALT_ON) << Integer.SIZE;
        }
        if (event.isShiftPressed()) {
            shortcutCode |= ((long) KeyEvent.META_SHIFT_ON) << Integer.SIZE;
        }
        if (event.isMetaPressed()) {
            shortcutCode |= ((long) KeyEvent.META_META_ON) << Integer.SIZE;
        }
        IShortcutService shortcutService = mShortcutKeyServices.get(shortcutCode);
        if (shortcutService != null) {
            try {
                if (isUserSetupComplete()) {
                    shortcutService.notifyShortcutKeyPressed(shortcutCode);
                }
            } catch (RemoteException e) {
                mShortcutKeyServices.delete(shortcutCode);
            }
            return -1;
        }
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#end_block

#method_before
private int getPowermenuAnimations() {
    return Settings.System.getInt(mContext.getContentResolver(), Settings.System.POWER_MENU_ANIMATIONS, 0);
}
#method_after
private int getPowermenuAnimations() {
    return Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.POWER_MENU_ANIMATIONS, 0, UserHandle.USER_CURRENT);
}
#end_block

#method_before
private void doShowAlert() {
    AlertDialog.Builder b = new AlertDialog.Builder(mContext, com.android.internal.R.style.Theme_Material_DayNight_Dialog_Alert);
    View content = LayoutInflater.from(mContext).inflate(R.layout.global_action_dismissable_dialog, null);
    final CheckBox dontShowAgain = (CheckBox) content.findViewById(R.id.global_action_skip);
    b.setTitle(R.string.dialog_alert_title);
    b.setView(content);
    b.setMessage(R.string.global_action_dismissable_dialog);
    b.setPositiveButton(R.string.dlg_ok, new DialogInterface.OnClickListener() {

        public void onClick(DialogInterface dialog, int which) {
            boolean checkBoxResult = false;
            if (dontShowAgain.isChecked()) {
                checkBoxResult = true;
            }
            Settings.Secure.putIntForUser(mContext.getContentResolver(), Settings.Secure.GLOBAL_ACTION_DNAA, checkBoxResult ? 1 : 0, UserHandle.USER_CURRENT);
            dialog.dismiss();
            doReboot();
        }
    });
    b.setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

        public void onClick(DialogInterface dialog, int which) {
            dialog.dismiss();
        }
    });
    AlertDialog d = b.create();
    d.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    d.show();
}
#method_after
private void doShowAlert() {
    AlertDialog.Builder b = new AlertDialog.Builder(mContext, com.android.internal.R.style.Theme_Material_DayNight_Dialog_Alert);
    View content = LayoutInflater.from(mContext).inflate(R.layout.global_action_dismissable_dialog, null);
    final CheckBox dontShowAgain = (CheckBox) content.findViewById(R.id.global_action_skip);
    b.setTitle(R.string.global_action_reboot);
    b.setView(content);
    b.setMessage(R.string.global_action_dismissable_dialog_text);
    b.setPositiveButton(R.string.dlg_ok, new DialogInterface.OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            Settings.Secure.putIntForUser(mContext.getContentResolver(), Settings.Secure.GLOBAL_ACTION_DNAA, dontShowAgain.isChecked() ? 1 : 0, UserHandle.USER_CURRENT);
            dialog.dismiss();
            doReboot();
        }
    });
    b.setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            dialog.dismiss();
        }
    });
    AlertDialog d = b.create();
    d.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    d.show();
}
#end_block

#method_before
private boolean advancedRebootEnabled(Context context) {
    boolean advancedRebootEnabled = Settings.Secure.getInt(context.getContentResolver(), Settings.Secure.ADVANCED_REBOOT, 0) == 1;
    return advancedRebootEnabled;
}
#method_after
private boolean advancedRebootEnabled(Context context) {
    boolean advancedRebootEnabled = Settings.Secure.getIntForUser(context.getContentResolver(), Settings.Secure.ADVANCED_REBOOT, 0, UserHandle.USER_CURRENT) == 1;
    return advancedRebootEnabled;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_START_DOZING:
            handleStartDozing((Runnable) msg.obj);
            break;
        case MSG_PULSE_WHILE_DOZING:
            handlePulseWhileDozing((PulseCallback) msg.obj, msg.arg1);
            break;
        case MSG_STOP_DOZING:
            handleStopDozing();
            break;
    }
}
#method_after
@Override
public void handleMessage(Message m) {
    super.handleMessage(m);
    switch(m.what) {
        case MSG_OPEN_NOTIFICATION_PANEL:
            animateExpandNotificationsPanel();
            break;
        case MSG_OPEN_SETTINGS_PANEL:
            animateExpandSettingsPanel((String) m.obj);
            break;
        case MSG_CLOSE_PANELS:
            animateCollapsePanels();
            break;
        case MSG_LAUNCH_TRANSITION_TIMEOUT:
            onLaunchTransitionTimeout();
            break;
    }
}
#end_block

#method_before
@Override
public void onClick(View v) {
    String msg = "";
    Bitmap bm = null;
    switch(v.getId()) {
        case R.id.recover:
            cropView.recoverImage();
            break;
        case R.id.delete:
            deleteBitmap(screenshotPath);
            break;
        case R.id.share:
            boolean cropAnytime = Settings.System.getInt(getContentResolver(), Settings.System.SCREENSHOT_CROP_BEHAVIOR, 1) != 0;
            bm = cropAnytime ? cropView.getCroppedBitmap() : cropView.getImageBitmap();
            cropView.setCropEnabled(false);
            progressBar.setVisibility(View.VISIBLE);
            if (saveBitmap(bm)) {
                shareBitmap();
            }
            progressBar.setVisibility(View.GONE);
            removeView();
            break;
        case R.id.save:
            cropAnytime = Settings.System.getInt(getContentResolver(), Settings.System.SCREENSHOT_CROP_BEHAVIOR, 1) != 0;
            bm = cropAnytime ? cropView.getCroppedBitmap() : cropView.getImageBitmap();
            if (saveBitmap(bm))
                msg = getString(R.string.action_save_success);
            else
                msg = getString(R.string.action_save_fault);
            Toast.makeText(mContext, msg, Toast.LENGTH_SHORT).show();
            removeView();
            break;
        case R.id.doneCrop:
            cropView.cropImage(cropView.getCroppedBitmap());
            break;
    }
}
#method_after
@Override
public void onClick(View v) {
    String msg = "";
    Bitmap bm = null;
    switch(v.getId()) {
        case R.id.recover:
            cropView.recoverImage();
            break;
        case R.id.delete:
            deleteBitmap(screenshotPath);
            break;
        case R.id.share:
            boolean cropAnytime = Settings.System.getInt(getContentResolver(), Settings.System.SCREENSHOT_CROP_BEHAVIOR, 1) != 0;
            bm = cropAnytime ? cropView.getCroppedBitmap() : cropView.getImageBitmap();
            if (saveBitmap(bm)) {
                shareBitmap();
            } else {
                msg = getString(R.string.action_save_fault);
                Toast.makeText(mContext, msg, Toast.LENGTH_SHORT).show();
            }
            removeView();
            break;
        case R.id.save:
            cropAnytime = Settings.System.getInt(getContentResolver(), Settings.System.SCREENSHOT_CROP_BEHAVIOR, 1) != 0;
            bm = cropAnytime ? cropView.getCroppedBitmap() : cropView.getImageBitmap();
            if (saveBitmap(bm))
                msg = getString(R.string.action_save_success);
            else
                msg = getString(R.string.action_save_fault);
            Toast.makeText(mContext, msg, Toast.LENGTH_SHORT).show();
            removeView();
            break;
        case R.id.doneCrop:
            cropView.cropImage(cropView.getCroppedBitmap());
            break;
    }
}
#end_block

#method_before
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    final int scanCode = event.getScanCode();
    // if mHardwareKeysDisable is true we have disabled all button rebindings
    // so we can be sure that events that are !virtuaKey are only for real buttons
    final boolean disableKey = !virtualKey && mHardwareKeysDisable;
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled + " virtualKey=" + virtualKey + " scanCode=" + scanCode + " longPress=" + longPress);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeDownKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
    }
    // try again later before dispatching.
    if (mScreenrecordChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeUpKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeUpKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mScreenrecordChordVolumeUpKeyConsumed) {
            if (!down) {
                mScreenrecordChordVolumeUpKeyConsumed = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // Any key that is not Alt or Meta cancels Caps Lock combo tracking.
    if (mPendingCapsLockToggle && !KeyEvent.isMetaKey(keyCode) && !KeyEvent.isAltKey(keyCode)) {
        mPendingCapsLockToggle = false;
    }
    if (keyCode == KeyEvent.KEYCODE_BACK && !down) {
        mHandler.removeCallbacks(mBackLongPress);
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down) {
            cancelPreloadRecentApps();
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // If an incoming call is ringing, HOME is totally disabled.
            // (The user is already on the InCallUI at this point,
            // and his ONLY options are to answer or reject the call.)
            TelecomManager telecomManager = getTelecommService();
            if (telecomManager != null && telecomManager.isRinging()) {
                Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
                return -1;
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            handleShortPressOnHome();
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            mHomePressed = true;
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                handleDoubleTapOnHome();
            } else if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
                preloadRecentApps();
            }
        } else if ((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
            if (!keyguardOn) {
                handleLongPressOnHome(event.getDeviceId());
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down && repeatCount == 0) {
            if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                mContext.sendOrderedBroadcastAsUser(intent, UserHandle.CURRENT, null, null, null, 0, null, null);
                return -1;
            } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                Intent service = new Intent();
                service.setClassName(mContext, "com.android.server.LoadAverageService");
                ContentResolver res = mContext.getContentResolver();
                boolean shown = Settings.Global.getInt(res, Settings.Global.SHOW_PROCESSES, 0) != 0;
                if (!shown) {
                    mContext.startService(service);
                } else {
                    mContext.stopService(service);
                }
                Settings.Global.putInt(res, Settings.Global.SHOW_PROCESSES, shown ? 0 : 1);
                return -1;
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (!keyguardOn) {
            if (down && repeatCount == 0) {
                preloadRecentApps();
            } else if (!down) {
                toggleRecentApps();
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_N && event.isMetaPressed()) {
        if (down) {
            IStatusBarService service = getStatusBarService();
            if (service != null) {
                try {
                    service.expandNotificationsPanel();
                } catch (RemoteException e) {
                // do nothing.
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_S && event.isMetaPressed() && event.isCtrlPressed()) {
        if (down && repeatCount == 0) {
            int type = event.isShiftPressed() ? TAKE_SCREENSHOT_SELECTED_REGION : TAKE_SCREENSHOT_FULLSCREEN;
            mScreenshotRunnable.setScreenshotType(type);
            mHandler.post(mScreenshotRunnable);
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_SLASH && event.isMetaPressed()) {
        if (down && repeatCount == 0 && !isKeyguardLocked()) {
            toggleKeyboardShortcutsMenu(event.getDeviceId());
        }
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (repeatCount == 1) {
                mAssistKeyLongPressed = true;
                if (!keyguardOn) {
                    launchAssistLongPressAction();
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (!keyguardOn) {
                    launchAssistAction(null, event.getDeviceId());
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        if (!down) {
            Intent voiceIntent;
            if (!keyguardOn) {
                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
            } else {
                IDeviceIdleController dic = IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
                if (dic != null) {
                    try {
                        dic.exitIdle("voice-search");
                    } catch (RemoteException e) {
                    }
                }
                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
            }
            startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
        }
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_FULLSCREEN);
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
        if (mUseTvRouting) {
            // On TVs volume keys never go to the foreground app.
            dispatchDirectAudioEvent(event);
            return -1;
        }
    }
    // Toggle Caps Lock on META-ALT.
    boolean actionTriggered = false;
    if (KeyEvent.isModifierKey(keyCode)) {
        if (!mPendingCapsLockToggle) {
            // Start tracking meta state for combo.
            mInitialMetaState = mMetaState;
            mPendingCapsLockToggle = true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            int altOnMask = mMetaState & KeyEvent.META_ALT_MASK;
            int metaOnMask = mMetaState & KeyEvent.META_META_MASK;
            // Check for Caps Lock toggle
            if ((metaOnMask != 0) && (altOnMask != 0)) {
                // Check if nothing else is pressed
                if (mInitialMetaState == (mMetaState ^ (altOnMask | metaOnMask))) {
                    // Handle Caps Lock Toggle
                    mInputManagerInternal.toggleCapsLock(event.getDeviceId());
                    actionTriggered = true;
                }
            }
            // Always stop tracking when key goes up.
            mPendingCapsLockToggle = false;
        }
    }
    // Store current meta state to be able to evaluate it later.
    mMetaState = metaState;
    if (actionTriggered) {
        return -1;
    }
    if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD, event.getDeviceId());
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (isStopLockTaskMode(true) || mBackKillEnabled) {
            if (down && repeatCount == 0) {
                mHandler.postDelayed(mBackLongPress, mBackKillTimeout);
            }
        }
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                        dismissKeyboardShortcutsMenu();
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    dismissKeyboardShortcutsMenu();
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                startActivityAsUser(intent, UserHandle.CURRENT);
                dismissKeyboardShortcutsMenu();
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn && isUserSetupComplete()) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true, false);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // Handle input method switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_META_MASK) != 0))) {
        final boolean forwardDirection = (metaState & KeyEvent.META_SHIFT_MASK) == 0;
        mWindowManagerFuncs.switchInputMethod(forwardDirection);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Specific device key handling
    if (mDeviceKeyHandler != null) {
        try {
            // The device only will consume known keys.
            if (mDeviceKeyHandler.canHandleKeyEvent(event)) {
                return -1;
            }
        } catch (Exception e) {
            Slog.w(TAG, "Could not dispatch event to device key handler", e);
        }
    }
    if (down) {
        long shortcutCode = keyCode;
        if (event.isCtrlPressed()) {
            shortcutCode |= ((long) KeyEvent.META_CTRL_ON) << Integer.SIZE;
        }
        if (event.isAltPressed()) {
            shortcutCode |= ((long) KeyEvent.META_ALT_ON) << Integer.SIZE;
        }
        if (event.isShiftPressed()) {
            shortcutCode |= ((long) KeyEvent.META_SHIFT_ON) << Integer.SIZE;
        }
        if (event.isMetaPressed()) {
            shortcutCode |= ((long) KeyEvent.META_META_ON) << Integer.SIZE;
        }
        IShortcutService shortcutService = mShortcutKeyServices.get(shortcutCode);
        if (shortcutService != null) {
            try {
                if (isUserSetupComplete()) {
                    shortcutService.notifyShortcutKeyPressed(shortcutCode);
                }
            } catch (RemoteException e) {
                mShortcutKeyServices.delete(shortcutCode);
            }
            return -1;
        }
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#method_after
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    final int scanCode = event.getScanCode();
    // if mHardwareKeysDisable is true we have disabled all button rebindings
    // so we can be sure that events that are !virtuaKey are only for real buttons
    final boolean disableKey = !virtualKey && mHardwareKeysDisable;
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled + " virtualKey=" + virtualKey + " scanCode=" + scanCode + " longPress=" + longPress);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeDownKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
    }
    // try again later before dispatching.
    if (mScreenrecordChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeUpKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeUpKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mScreenrecordChordVolumeUpKeyConsumed) {
            if (!down) {
                mScreenrecordChordVolumeUpKeyConsumed = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // Any key that is not Alt or Meta cancels Caps Lock combo tracking.
    if (mPendingCapsLockToggle && !KeyEvent.isMetaKey(keyCode) && !KeyEvent.isAltKey(keyCode)) {
        mPendingCapsLockToggle = false;
    }
    if (keyCode == KeyEvent.KEYCODE_BACK && !down) {
        mHandler.removeCallbacks(mBackLongPress);
        if (mLongPressBackConsumed) {
            mLongPressBackConsumed = false;
            return -1;
        }
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down) {
            cancelPreloadRecentApps();
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // If an incoming call is ringing, HOME is totally disabled.
            // (The user is already on the InCallUI at this point,
            // and his ONLY options are to answer or reject the call.)
            TelecomManager telecomManager = getTelecommService();
            if (telecomManager != null && telecomManager.isRinging()) {
                Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
                return -1;
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            handleShortPressOnHome();
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            mHomePressed = true;
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                handleDoubleTapOnHome();
            } else if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
                preloadRecentApps();
            }
        } else if ((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
            if (!keyguardOn) {
                handleLongPressOnHome(event.getDeviceId());
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down && repeatCount == 0) {
            if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                mContext.sendOrderedBroadcastAsUser(intent, UserHandle.CURRENT, null, null, null, 0, null, null);
                return -1;
            } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                Intent service = new Intent();
                service.setClassName(mContext, "com.android.server.LoadAverageService");
                ContentResolver res = mContext.getContentResolver();
                boolean shown = Settings.Global.getInt(res, Settings.Global.SHOW_PROCESSES, 0) != 0;
                if (!shown) {
                    mContext.startService(service);
                } else {
                    mContext.stopService(service);
                }
                Settings.Global.putInt(res, Settings.Global.SHOW_PROCESSES, shown ? 0 : 1);
                return -1;
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (!keyguardOn) {
            if (down && repeatCount == 0) {
                preloadRecentApps();
            } else if (!down) {
                toggleRecentApps();
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_N && event.isMetaPressed()) {
        if (down) {
            IStatusBarService service = getStatusBarService();
            if (service != null) {
                try {
                    service.expandNotificationsPanel();
                } catch (RemoteException e) {
                // do nothing.
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_S && event.isMetaPressed() && event.isCtrlPressed()) {
        if (down && repeatCount == 0) {
            int type = event.isShiftPressed() ? TAKE_SCREENSHOT_SELECTED_REGION : TAKE_SCREENSHOT_FULLSCREEN;
            mScreenshotRunnable.setScreenshotType(type);
            mHandler.post(mScreenshotRunnable);
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_SLASH && event.isMetaPressed()) {
        if (down && repeatCount == 0 && !isKeyguardLocked()) {
            toggleKeyboardShortcutsMenu(event.getDeviceId());
        }
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (repeatCount == 1) {
                mAssistKeyLongPressed = true;
                if (!keyguardOn) {
                    launchAssistLongPressAction();
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (!keyguardOn) {
                    launchAssistAction(null, event.getDeviceId());
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        if (!down) {
            Intent voiceIntent;
            if (!keyguardOn) {
                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
            } else {
                IDeviceIdleController dic = IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
                if (dic != null) {
                    try {
                        dic.exitIdle("voice-search");
                    } catch (RemoteException e) {
                    }
                }
                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
            }
            startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
        }
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_FULLSCREEN);
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
        if (mUseTvRouting) {
            // On TVs volume keys never go to the foreground app.
            dispatchDirectAudioEvent(event);
            return -1;
        }
    }
    // Toggle Caps Lock on META-ALT.
    boolean actionTriggered = false;
    if (KeyEvent.isModifierKey(keyCode)) {
        if (!mPendingCapsLockToggle) {
            // Start tracking meta state for combo.
            mInitialMetaState = mMetaState;
            mPendingCapsLockToggle = true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            int altOnMask = mMetaState & KeyEvent.META_ALT_MASK;
            int metaOnMask = mMetaState & KeyEvent.META_META_MASK;
            // Check for Caps Lock toggle
            if ((metaOnMask != 0) && (altOnMask != 0)) {
                // Check if nothing else is pressed
                if (mInitialMetaState == (mMetaState ^ (altOnMask | metaOnMask))) {
                    // Handle Caps Lock Toggle
                    mInputManagerInternal.toggleCapsLock(event.getDeviceId());
                    actionTriggered = true;
                }
            }
            // Always stop tracking when key goes up.
            mPendingCapsLockToggle = false;
        }
    }
    // Store current meta state to be able to evaluate it later.
    mMetaState = metaState;
    if (actionTriggered) {
        return -1;
    }
    if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD, event.getDeviceId());
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (isStopLockTaskMode(true) || mBackKillEnabled) {
            if (down && repeatCount == 0) {
                mHandler.postDelayed(mBackLongPress, mBackKillTimeout);
            }
        }
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                        dismissKeyboardShortcutsMenu();
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    dismissKeyboardShortcutsMenu();
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                startActivityAsUser(intent, UserHandle.CURRENT);
                dismissKeyboardShortcutsMenu();
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn && isUserSetupComplete()) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true, false);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // Handle input method switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_META_MASK) != 0))) {
        final boolean forwardDirection = (metaState & KeyEvent.META_SHIFT_MASK) == 0;
        mWindowManagerFuncs.switchInputMethod(forwardDirection);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Specific device key handling
    if (mDeviceKeyHandler != null) {
        try {
            // The device only will consume known keys.
            if (mDeviceKeyHandler.canHandleKeyEvent(event)) {
                return -1;
            }
        } catch (Exception e) {
            Slog.w(TAG, "Could not dispatch event to device key handler", e);
        }
    }
    if (down) {
        long shortcutCode = keyCode;
        if (event.isCtrlPressed()) {
            shortcutCode |= ((long) KeyEvent.META_CTRL_ON) << Integer.SIZE;
        }
        if (event.isAltPressed()) {
            shortcutCode |= ((long) KeyEvent.META_ALT_ON) << Integer.SIZE;
        }
        if (event.isShiftPressed()) {
            shortcutCode |= ((long) KeyEvent.META_SHIFT_ON) << Integer.SIZE;
        }
        if (event.isMetaPressed()) {
            shortcutCode |= ((long) KeyEvent.META_META_ON) << Integer.SIZE;
        }
        IShortcutService shortcutService = mShortcutKeyServices.get(shortcutCode);
        if (shortcutService != null) {
            try {
                if (isUserSetupComplete()) {
                    shortcutService.notifyShortcutKeyPressed(shortcutCode);
                }
            } catch (RemoteException e) {
                mShortcutKeyServices.delete(shortcutCode);
            }
            return -1;
        }
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#end_block

#method_before
@Override
public void onCreate(Bundle icicle) {
    super.onCreate(icicle);
    addPreferencesFromResource(R.xml.device_info_settings);
    setStringSummary(KEY_FIRMWARE_VERSION, Build.VERSION.RELEASE);
    findPreference(KEY_FIRMWARE_VERSION).setEnabled(true);
    String patch = Build.VERSION.SECURITY_PATCH;
    if (!"".equals(patch)) {
        try {
            SimpleDateFormat template = new SimpleDateFormat("yyyy-MM-dd");
            Date patchDate = template.parse(patch);
            String format = DateFormat.getBestDateTimePattern(Locale.getDefault(), "dMMMMyyyy");
            patch = DateFormat.format(format, patchDate).toString();
        } catch (ParseException e) {
        // broken parse; fall through and use the raw string
        }
        setStringSummary(KEY_SECURITY_PATCH, patch);
    } else {
        getPreferenceScreen().removePreference(findPreference(KEY_SECURITY_PATCH));
    }
    setValueSummary(KEY_BASEBAND_VERSION, "gsm.version.baseband");
    setStringSummary(KEY_DEVICE_MODEL, Build.MODEL + getMsvSuffix());
    setValueSummary(KEY_EQUIPMENT_ID, PROPERTY_EQUIPMENT_ID);
    setStringSummary(KEY_DEVICE_MODEL, Build.MODEL);
    setStringSummary(KEY_BUILD_NUMBER, Build.DISPLAY);
    findPreference(KEY_BUILD_NUMBER).setEnabled(true);
    findPreference(KEY_KERNEL_VERSION).setSummary(getFormattedKernelVersion());
    setValueSummary(KEY_MOD_VERSION, "ro.omni.version");
    setValueSummary(KEY_AOSP_REVISION, "ro.build.id");
    findPreference(KEY_AOSP_REVISION).setEnabled(true);
    if (!SELinux.isSELinuxEnabled()) {
        String status = getResources().getString(R.string.selinux_status_disabled);
        setStringSummary(KEY_SELINUX_STATUS, status);
    } else if (!SELinux.isSELinuxEnforced()) {
        String status = getResources().getString(R.string.selinux_status_permissive);
        setStringSummary(KEY_SELINUX_STATUS, status);
    }
    // Remove selinux information if property is not present
    removePreferenceIfPropertyMissing(getPreferenceScreen(), KEY_SELINUX_STATUS, PROPERTY_SELINUX_STATUS);
    // Remove Safety information preference if PROPERTY_URL_SAFETYLEGAL is not set
    removePreferenceIfPropertyMissing(getPreferenceScreen(), KEY_SAFETY_LEGAL, PROPERTY_URL_SAFETYLEGAL);
    // Remove Equipment id preference if FCC ID is not set by RIL
    removePreferenceIfPropertyMissing(getPreferenceScreen(), KEY_EQUIPMENT_ID, PROPERTY_EQUIPMENT_ID);
    // Remove Baseband version if wifi-only device
    if (Utils.isWifiOnly(getActivity())) {
        getPreferenceScreen().removePreference(findPreference(KEY_BASEBAND_VERSION));
    }
    // Dont show feedback option if there is no reporter.
    if (TextUtils.isEmpty(getFeedbackReporterPackage(getActivity()))) {
        getPreferenceScreen().removePreference(findPreference(KEY_DEVICE_FEEDBACK));
    }
    /*
         * Settings is a generic app and should not contain any device-specific
         * info.
         */
    final Activity act = getActivity();
    // These are contained by the root preference screen
    PreferenceGroup parentPreference = getPreferenceScreen();
    if (UserHandle.myUserId() == UserHandle.USER_OWNER) {
        Utils.updatePreferenceToSpecificActivityOrRemove(act, parentPreference, KEY_SYSTEM_UPDATE_SETTINGS, Utils.UPDATE_PREFERENCE_FLAG_SET_TITLE_TO_MATCHING_ACTIVITY);
    } else {
        // Remove for secondary users
        removePreference(KEY_SYSTEM_UPDATE_SETTINGS);
    }
    // Read platform settings for additional system update setting
    removePreferenceIfBoolFalse(KEY_UPDATE_SETTING, R.bool.config_additional_system_update_setting_enable);
    // Remove manual entry if none present.
    removePreferenceIfBoolFalse(KEY_MANUAL, R.bool.config_show_manual);
    // Remove regulatory information if none present.
    final Intent intent = new Intent(Settings.ACTION_SHOW_REGULATORY_INFO);
    if (getPackageManager().queryIntentActivities(intent, 0).isEmpty()) {
        Preference pref = findPreference(KEY_REGULATORY_INFO);
        if (pref != null) {
            getPreferenceScreen().removePreference(pref);
        }
    }
}
#method_after
@Override
public void onCreate(Bundle icicle) {
    super.onCreate(icicle);
    addPreferencesFromResource(R.xml.device_info_settings);
    setStringSummary(KEY_FIRMWARE_VERSION, Build.VERSION.RELEASE + " " + Build.ID);
    findPreference(KEY_FIRMWARE_VERSION).setEnabled(true);
    String patch = Build.VERSION.SECURITY_PATCH;
    if (!"".equals(patch)) {
        try {
            SimpleDateFormat template = new SimpleDateFormat("yyyy-MM-dd");
            Date patchDate = template.parse(patch);
            String format = DateFormat.getBestDateTimePattern(Locale.getDefault(), "dMMMMyyyy");
            patch = DateFormat.format(format, patchDate).toString();
        } catch (ParseException e) {
        // broken parse; fall through and use the raw string
        }
        setStringSummary(KEY_SECURITY_PATCH, patch);
    } else {
        getPreferenceScreen().removePreference(findPreference(KEY_SECURITY_PATCH));
    }
    setValueSummary(KEY_BASEBAND_VERSION, "gsm.version.baseband");
    setStringSummary(KEY_DEVICE_MODEL, Build.MODEL + getMsvSuffix());
    setValueSummary(KEY_EQUIPMENT_ID, PROPERTY_EQUIPMENT_ID);
    setStringSummary(KEY_DEVICE_MODEL, Build.MODEL);
    setStringSummary(KEY_BUILD_NUMBER, Build.DISPLAY);
    findPreference(KEY_BUILD_NUMBER).setEnabled(true);
    findPreference(KEY_KERNEL_VERSION).setSummary(getFormattedKernelVersion());
    setValueSummary(KEY_MOD_VERSION, "ro.omni.version");
    if (!SELinux.isSELinuxEnabled()) {
        String status = getResources().getString(R.string.selinux_status_disabled);
        setStringSummary(KEY_SELINUX_STATUS, status);
    } else if (!SELinux.isSELinuxEnforced()) {
        String status = getResources().getString(R.string.selinux_status_permissive);
        setStringSummary(KEY_SELINUX_STATUS, status);
    }
    // Remove selinux information if property is not present
    removePreferenceIfPropertyMissing(getPreferenceScreen(), KEY_SELINUX_STATUS, PROPERTY_SELINUX_STATUS);
    // Remove Safety information preference if PROPERTY_URL_SAFETYLEGAL is not set
    removePreferenceIfPropertyMissing(getPreferenceScreen(), KEY_SAFETY_LEGAL, PROPERTY_URL_SAFETYLEGAL);
    // Remove Equipment id preference if FCC ID is not set by RIL
    removePreferenceIfPropertyMissing(getPreferenceScreen(), KEY_EQUIPMENT_ID, PROPERTY_EQUIPMENT_ID);
    // Remove Baseband version if wifi-only device
    if (Utils.isWifiOnly(getActivity())) {
        getPreferenceScreen().removePreference(findPreference(KEY_BASEBAND_VERSION));
    }
    // Dont show feedback option if there is no reporter.
    if (TextUtils.isEmpty(getFeedbackReporterPackage(getActivity()))) {
        getPreferenceScreen().removePreference(findPreference(KEY_DEVICE_FEEDBACK));
    }
    /*
         * Settings is a generic app and should not contain any device-specific
         * info.
         */
    final Activity act = getActivity();
    // These are contained by the root preference screen
    PreferenceGroup parentPreference = getPreferenceScreen();
    if (UserHandle.myUserId() == UserHandle.USER_OWNER) {
        Utils.updatePreferenceToSpecificActivityOrRemove(act, parentPreference, KEY_SYSTEM_UPDATE_SETTINGS, Utils.UPDATE_PREFERENCE_FLAG_SET_TITLE_TO_MATCHING_ACTIVITY);
    } else {
        // Remove for secondary users
        removePreference(KEY_SYSTEM_UPDATE_SETTINGS);
    }
    // Read platform settings for additional system update setting
    removePreferenceIfBoolFalse(KEY_UPDATE_SETTING, R.bool.config_additional_system_update_setting_enable);
    // Remove manual entry if none present.
    removePreferenceIfBoolFalse(KEY_MANUAL, R.bool.config_show_manual);
    // Remove regulatory information if none present.
    final Intent intent = new Intent(Settings.ACTION_SHOW_REGULATORY_INFO);
    if (getPackageManager().queryIntentActivities(intent, 0).isEmpty()) {
        Preference pref = findPreference(KEY_REGULATORY_INFO);
        if (pref != null) {
            getPreferenceScreen().removePreference(pref);
        }
    }
}
#end_block

#method_before
private void buildMenuList() {
    mItems.clear();
    ArraySet<String> addedKeys = new ArraySet<String>();
    for (int i = 0; i < mCurrentMenuActions.length; i++) {
        String actionKey = mCurrentMenuActions[i];
        if (addedKeys.contains(actionKey)) {
            // If we already have added this, don't add it again.
            continue;
        }
        if (GLOBAL_ACTION_KEY_POWER.equals(actionKey)) {
            mItems.add(new PowerAction());
        } else if (GLOBAL_ACTION_KEY_REBOOT.equals(actionKey)) {
            // always enable the simple reboot
            mItems.add(new RebootAction());
        } else if (advancedRebootEnabled(mContext) && GLOBAL_ACTION_KEY_REBOOT_RECOVERY.equals(actionKey)) {
            mItems.add(new RebootRecoveryAction());
        } else if (advancedRebootEnabled(mContext) && GLOBAL_ACTION_KEY_REBOOT_BOOTLOADER.equals(actionKey)) {
            mItems.add(new RebootBootloaderAction());
        } else if (GLOBAL_ACTION_KEY_AIRPLANE.equals(actionKey)) {
            mItems.add(mAirplaneModeOn);
        /*} else if (GLOBAL_ACTION_KEY_BUGREPORT.equals(actionKey)) {
                if (Settings.Global.getInt(mContext.getContentResolver(),
                        Settings.Global.BUGREPORT_IN_POWER_MENU, 0) != 0 && isCurrentUserOwner()) {
                    mItems.add(getBugReportAction());
                }*/
        } else if (GLOBAL_ACTION_KEY_SILENT.equals(actionKey)) {
            if (mShowSilentToggle) {
                mItems.add(mSilentModeAction);
            }
        } else if (GLOBAL_ACTION_KEY_USERS.equals(actionKey)) {
            UserManager um = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
            if (um.isUserSwitcherEnabled()) {
                mItems.add(new UsersAction());
            }
        } else if (GLOBAL_ACTION_KEY_SETTINGS.equals(actionKey)) {
            mItems.add(getSettingsAction());
        } else if (GLOBAL_ACTION_KEY_LOCKDOWN.equals(actionKey)) {
            mItems.add(getLockdownAction());
        } else if (GLOBAL_ACTION_KEY_VOICEASSIST.equals(actionKey)) {
            mItems.add(getVoiceAssistAction());
        /*} else if (GLOBAL_ACTION_KEY_ASSIST.equals(actionKey)) {
                mItems.add(getAssistAction());*/
        } else if (GLOBAL_ACTION_KEY_DND.equals(actionKey)) {
            mItems.add(mDndModeAction);
        } else if (GLOBAL_ACTION_KEY_SCREENSHOT.equals(actionKey)) {
            mItems.add(new ScreenShotAction());
        } else if (GLOBAL_ACTION_KEY_SCREENCAPTURE.equals(actionKey)) {
            mItems.add(new ScreenCaptureAction());
        } else {
            Log.e(TAG, "Invalid global action key " + actionKey);
        }
        // Add here so we don't add more than one.
        addedKeys.add(actionKey);
    }
}
#method_after
private void buildMenuList() {
    mItems.clear();
    ArraySet<String> addedKeys = new ArraySet<String>();
    for (int i = 0; i < mCurrentMenuActions.length; i++) {
        String actionKey = mCurrentMenuActions[i];
        if (addedKeys.contains(actionKey)) {
            // If we already have added this, don't add it again.
            continue;
        }
        if (GLOBAL_ACTION_KEY_POWER.equals(actionKey)) {
            mItems.add(new PowerAction());
        } else if (GLOBAL_ACTION_KEY_REBOOT.equals(actionKey)) {
            // always enable the simple reboot
            mItems.add(new RebootAction());
        } else if (advancedRebootEnabled(mContext) && GLOBAL_ACTION_KEY_REBOOT_RECOVERY.equals(actionKey)) {
            mItems.add(new RebootRecoveryAction());
        } else if (advancedRebootEnabled(mContext) && GLOBAL_ACTION_KEY_REBOOT_BOOTLOADER.equals(actionKey)) {
            mItems.add(new RebootBootloaderAction());
        } else if (GLOBAL_ACTION_KEY_AIRPLANE.equals(actionKey)) {
            mItems.add(mAirplaneModeOn);
        /*} else if (GLOBAL_ACTION_KEY_BUGREPORT.equals(actionKey)) {
                if (Settings.Global.getInt(mContext.getContentResolver(),
                        Settings.Global.BUGREPORT_IN_POWER_MENU, 0) != 0 && isCurrentUserOwner()) {
                    mItems.add(getBugReportAction());
                }*/
        } else if (GLOBAL_ACTION_KEY_SILENT.equals(actionKey)) {
            if (mShowSilentToggle) {
                mItems.add(mSilentModeAction);
            }
        } else if (GLOBAL_ACTION_KEY_USERS.equals(actionKey)) {
            UserManager um = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
            if (um.isUserSwitcherEnabled()) {
                mItems.add(new UsersAction());
            }
        } else if (GLOBAL_ACTION_KEY_SETTINGS.equals(actionKey)) {
            mItems.add(getSettingsAction());
        } else if (GLOBAL_ACTION_KEY_LOCKDOWN.equals(actionKey)) {
            mItems.add(getLockdownAction());
        } else if (GLOBAL_ACTION_KEY_VOICEASSIST.equals(actionKey)) {
            mItems.add(getVoiceAssistAction());
        /*} else if (GLOBAL_ACTION_KEY_ASSIST.equals(actionKey)) {
                mItems.add(getAssistAction());*/
        } else if (GLOBAL_ACTION_KEY_DND.equals(actionKey)) {
            mItems.add(mDndModeAction);
        } else if (GLOBAL_ACTION_KEY_SCREENSHOT.equals(actionKey)) {
            mItems.add(new ScreenShotAction());
        } else if (GLOBAL_ACTION_KEY_SCREENRECORD.equals(actionKey)) {
            mItems.add(new ScreenRecordAction());
        } else {
            Log.e(TAG, "Invalid global action key " + actionKey);
        }
        // Add here so we don't add more than one.
        addedKeys.add(actionKey);
    }
}
#end_block

#method_before
@Override
public boolean showDuringRestrictedKeyguard() {
    return false;
}
#method_after
@Override
public boolean showDuringRestrictedKeyguard() {
    return true;
}
#end_block

#method_before
@Override
public void onPress() {
    takeScreenshot();
}
#method_after
@Override
public void onPress() {
    synchronized (mScreenshotLock) {
        if (mScreenshotConnection != null) {
            return;
        }
        ComponentName cn = new ComponentName("com.android.systemui", "com.android.systemui.screenshot.TakeScreenshotService");
        Intent intent = new Intent();
        intent.setComponent(cn);
        ServiceConnection conn = new ServiceConnection() {

            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                synchronized (mScreenshotLock) {
                    if (mScreenshotConnection != this) {
                        return;
                    }
                    Messenger messenger = new Messenger(service);
                    Message msg = Message.obtain(null, 1);
                    final ServiceConnection myConn = this;
                    Handler h = new Handler(mHandler.getLooper()) {

                        @Override
                        public void handleMessage(Message msg) {
                            synchronized (mScreenshotLock) {
                                if (mScreenshotConnection == myConn) {
                                    mContext.unbindService(mScreenshotConnection);
                                    mScreenshotConnection = null;
                                    mHandler.removeCallbacks(mScreenshotTimeout);
                                }
                            }
                        }
                    };
                    msg.replyTo = new Messenger(h);
                    msg.arg1 = msg.arg2 = 0;
                    if (mStatusBar != null && mStatusBar.isVisibleLw())
                        msg.arg1 = 1;
                    if (mNavigationBar != null && mNavigationBar.isVisibleLw())
                        msg.arg2 = 1;
                    try {
                        messenger.send(msg);
                    } catch (RemoteException e) {
                    }
                }
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {
            }
        };
        if (mContext.bindServiceAsUser(intent, conn, Context.BIND_AUTO_CREATE, UserHandle.CURRENT)) {
            mScreenshotConnection = conn;
            mHandler.postDelayed(mScreenshotTimeout, 10000);
        }
    }
}
#end_block

#method_before
public void update() {
    int showNavBar = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.NAVIGATION_BAR_SHOW, -1, mCurrentUserId);
    if (showNavBar != -1) {
        boolean showNavBarBool = showNavBar == 1;
        if (showNavBarBool != mShowNavBar) {
            updateNavigationBar();
        }
    }
    mStatusBarWindowManager.updateKeyguardScreenRotation();
    mAutomatic = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, 0, mCurrentUserId) != Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL;
    mBrightnessControl = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL, 0, mCurrentUserId) == 1;
    mOmniSwitchRecents = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.NAVIGATION_BAR_RECENTS, 0, mCurrentUserId) == 1;
    mDoubleTabSleep = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.DOUBLE_TAP_SLEEP_GESTURE, 0, mCurrentUserId) == 1;
    // mEnableTabletNavigation = Settings.System.getIntForUser(
    // mContext.getContentResolver(), Settings.System.ENABLE_TABLET_NAVIGATION, 0, mCurrentUserId) == 1;
    int tabletNavigation = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.ENABLE_TABLET_NAVIGATION, -1, mCurrentUserId);
    if (tabletNavigation != -1) {
        boolean tabletNavigationBool = tabletNavigation == 1;
        if (tabletNavigationBool != mEnableTabletNavigation) {
            if (mNavigationBarView != null) {
                mWindowManager.removeViewImmediate(mNavigationBarView);
                mNavigationBarView = null;
            }
            mEnableTabletNavigation = tabletNavigationBool;
            updateNavigationBar();
        }
    }
    if (mStatusBarWindow != null) {
        mStatusBarWindow.setDoubleTabSleep(mDoubleTabSleep);
    }
    mHeader.settingsChanged();
}
#method_after
public void update() {
    int showNavBar = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.NAVIGATION_BAR_SHOW, -1, mCurrentUserId);
    if (showNavBar != -1) {
        boolean showNavBarBool = showNavBar == 1;
        if (showNavBarBool != mShowNavBar) {
            updateNavigationBar();
        }
    }
    mStatusBarWindowManager.updateKeyguardScreenRotation();
    mAutomatic = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, 0, mCurrentUserId) != Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL;
    mBrightnessControl = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL, 0, mCurrentUserId) == 1;
    mOmniSwitchRecents = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.NAVIGATION_BAR_RECENTS, 0, mCurrentUserId) == 1;
    mDoubleTabSleep = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.DOUBLE_TAP_SLEEP_GESTURE, 0, mCurrentUserId) == 1;
    int tabletNavigation = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.ENABLE_TABLET_NAVIGATION, -1, mCurrentUserId);
    if (tabletNavigation != -1 && mShowNavBar) {
        boolean tabletNavigationBool = tabletNavigation == 1;
        if (tabletNavigationBool != mEnableTabletNavigation) {
            if (mNavigationBarView != null) {
                mWindowManager.removeViewImmediate(mNavigationBarView);
                mNavigationBarView = null;
            }
            mEnableTabletNavigation = tabletNavigationBool;
            // removing view and immediately adding it afterward is breaking
            // WindowManager so add a small delay before adding
            mHandler.postDelayed(new Runnable() {

                @Override
                public void run() {
                    updateNavigationBar();
                }
            }, 500);
        }
    }
    if (mStatusBarWindow != null) {
        mStatusBarWindow.setDoubleTabSleep(mDoubleTabSleep);
    }
    mHeader.settingsChanged();
}
#end_block

#method_before
@Override
public void start() {
    mDisplay = ((WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
    updateDisplaySize();
    mScrimSrcModeEnabled = mContext.getResources().getBoolean(R.bool.config_status_bar_scrim_behind_use_src);
    mBackKillTimeout = mContext.getResources().getInteger(com.android.internal.R.integer.config_backKillTimeout);
    // calls createAndAddWindows()
    super.start();
    mMediaSessionManager = (MediaSessionManager) mContext.getSystemService(Context.MEDIA_SESSION_SERVICE);
    // TODO: use MediaSessionManager.SessionListener to hook us up to future updates
    // in session state
    addNavigationBar();
    // must be after addNavigationBar
    mOmniSettingsObserver.observe();
    // Lastly, call to the icon policy to install/update all the icons.
    mIconPolicy = new PhoneStatusBarPolicy(mContext, mCastController, mHotspotController, mUserInfoController, mBluetoothController);
    mIconPolicy.setCurrentUserSetup(mUserSetup);
    // set up
    mSettingsObserver.onChange(false);
    // set up
    mHeadsUpObserver.onChange(true);
    if (ENABLE_HEADS_UP) {
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.HEADS_UP_NOTIFICATIONS_ENABLED), true, mHeadsUpObserver);
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(SETTING_HEADS_UP_TICKER), true, mHeadsUpObserver);
    }
    mUnlockMethodCache = UnlockMethodCache.getInstance(mContext);
    mUnlockMethodCache.addListener(this);
    startKeyguard();
    mDozeServiceHost = new DozeServiceHost();
    KeyguardUpdateMonitor.getInstance(mContext).registerCallback(mDozeServiceHost);
    putComponent(DozeHost.class, mDozeServiceHost);
    putComponent(PhoneStatusBar.class, this);
    setControllerUsers();
    notifyUserAboutHiddenNotifications();
    mScreenPinningRequest = new ScreenPinningRequest(mContext);
    mPower = IPowerManager.Stub.asInterface(ServiceManager.getService("power"));
}
#method_after
@Override
public void start() {
    mDisplay = ((WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
    updateDisplaySize();
    mScrimSrcModeEnabled = mContext.getResources().getBoolean(R.bool.config_status_bar_scrim_behind_use_src);
    mBackKillTimeout = mContext.getResources().getInteger(com.android.internal.R.integer.config_backKillTimeout);
    mEnableTabletNavigation = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.ENABLE_TABLET_NAVIGATION, -1, mCurrentUserId) == 1;
    // calls createAndAddWindows()
    super.start();
    mMediaSessionManager = (MediaSessionManager) mContext.getSystemService(Context.MEDIA_SESSION_SERVICE);
    // TODO: use MediaSessionManager.SessionListener to hook us up to future updates
    // in session state
    addNavigationBar();
    // must be after addNavigationBar
    mOmniSettingsObserver.observe();
    // Lastly, call to the icon policy to install/update all the icons.
    mIconPolicy = new PhoneStatusBarPolicy(mContext, mCastController, mHotspotController, mUserInfoController, mBluetoothController);
    mIconPolicy.setCurrentUserSetup(mUserSetup);
    // set up
    mSettingsObserver.onChange(false);
    // set up
    mHeadsUpObserver.onChange(true);
    if (ENABLE_HEADS_UP) {
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.HEADS_UP_NOTIFICATIONS_ENABLED), true, mHeadsUpObserver);
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(SETTING_HEADS_UP_TICKER), true, mHeadsUpObserver);
    }
    mUnlockMethodCache = UnlockMethodCache.getInstance(mContext);
    mUnlockMethodCache.addListener(this);
    startKeyguard();
    mDozeServiceHost = new DozeServiceHost();
    KeyguardUpdateMonitor.getInstance(mContext).registerCallback(mDozeServiceHost);
    putComponent(DozeHost.class, mDozeServiceHost);
    putComponent(PhoneStatusBar.class, this);
    setControllerUsers();
    notifyUserAboutHiddenNotifications();
    mScreenPinningRequest = new ScreenPinningRequest(mContext);
    mPower = IPowerManager.Stub.asInterface(ServiceManager.getService("power"));
}
#end_block

#method_before
// ================================================================================
// Constructing the view
protected PhoneStatusBarView makeStatusBarView() {
    final Context context = mContext;
    Resources res = context.getResources();
    mScreenWidth = (float) context.getResources().getDisplayMetrics().widthPixels;
    mMinBrightness = context.getResources().getInteger(com.android.internal.R.integer.config_screenBrightnessDim);
    // populates mDisplayMetrics
    updateDisplaySize();
    updateResources();
    mStatusBarWindow = (StatusBarWindowView) View.inflate(context, R.layout.super_status_bar, null);
    mStatusBarWindow.setService(this);
    mStatusBarWindow.setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            checkUserAutohide(v, event);
            if (event.getAction() == MotionEvent.ACTION_DOWN) {
                if (mExpandedVisible) {
                    animateCollapsePanels();
                }
            }
            return mStatusBarWindow.onTouchEvent(event);
        }
    });
    mStatusBarView = (PhoneStatusBarView) mStatusBarWindow.findViewById(R.id.status_bar);
    mStatusBarView.setBar(this);
    PanelHolder holder = (PanelHolder) mStatusBarWindow.findViewById(R.id.panel_holder);
    mStatusBarView.setPanelHolder(holder);
    mNotificationPanel = (NotificationPanelView) mStatusBarWindow.findViewById(R.id.notification_panel);
    mNotificationPanel.setStatusBar(this);
    if (!ActivityManager.isHighEndGfx()) {
        mStatusBarWindow.setBackground(null);
        mNotificationPanel.setBackground(new FastColorDrawable(context.getColor(R.color.notification_panel_solid_background)));
    }
    mHeadsUpManager = new HeadsUpManager(context, mStatusBarWindow);
    mHeadsUpManager.setBar(this);
    mHeadsUpManager.addListener(this);
    mHeadsUpManager.addListener(mNotificationPanel);
    mNotificationPanel.setHeadsUpManager(mHeadsUpManager);
    mNotificationData.setHeadsUpManager(mHeadsUpManager);
    try {
        mShowNavBar = mWindowManagerService.hasNavigationBar();
        if (DEBUG)
            Log.v(TAG, "hasNavigationBar=" + mShowNavBar);
        if (mShowNavBar) {
            if (mEnableTabletNavigation) {
                mNavigationBarView = (NavigationBarView) View.inflate(context, R.layout.navigation_bar_tablet, null);
                Log.d(TAG, "Showing Tablet Layout navigation");
            } else {
                mNavigationBarView = (NavigationBarView) View.inflate(context, R.layout.navigation_bar, null);
                Log.d(TAG, "Showing Normal Layout navigation");
            }
            mNavigationBarView.setDisabledFlags(mDisabled1);
            mNavigationBarView.setBar(this);
            mNavigationBarView.setOnVerticalChangedListener(new NavigationBarView.OnVerticalChangedListener() {

                @Override
                public void onVerticalChanged(boolean isVertical) {
                    if (mAssistManager != null) {
                        mAssistManager.onConfigurationChanged();
                    }
                    mNotificationPanel.setQsScrimEnabled(!isVertical);
                }
            });
            mNavigationBarView.setOnTouchListener(new View.OnTouchListener() {

                @Override
                public boolean onTouch(View v, MotionEvent event) {
                    checkUserAutohide(v, event);
                    return false;
                }
            });
        }
    } catch (RemoteException ex) {
    // no window manager? good luck with that
    }
    mAssistManager = new AssistManager(this, context);
    if (!mShowNavBar) {
        mAssistManager.onConfigurationChanged();
    }
    // figure out which pixel-format to use for the status bar.
    mPixelFormat = PixelFormat.OPAQUE;
    mStackScroller = (NotificationStackScrollLayout) mStatusBarWindow.findViewById(R.id.notification_stack_scroller);
    mStackScroller.setLongPressListener(getNotificationLongClicker());
    mStackScroller.setPhoneStatusBar(this);
    mStackScroller.setGroupManager(mGroupManager);
    mStackScroller.setHeadsUpManager(mHeadsUpManager);
    mGroupManager.setOnGroupChangeListener(mStackScroller);
    mKeyguardIconOverflowContainer = (NotificationOverflowContainer) LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_keyguard_overflow, mStackScroller, false);
    mKeyguardIconOverflowContainer.setOnActivatedListener(this);
    mKeyguardIconOverflowContainer.setOnClickListener(mOverflowClickListener);
    mStackScroller.setOverflowContainer(mKeyguardIconOverflowContainer);
    SpeedBumpView speedBump = (SpeedBumpView) LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_speed_bump, mStackScroller, false);
    mStackScroller.setSpeedBumpView(speedBump);
    mEmptyShadeView = (EmptyShadeView) LayoutInflater.from(mContext).inflate(R.layout.status_bar_no_notifications, mStackScroller, false);
    mStackScroller.setEmptyShadeView(mEmptyShadeView);
    mDismissView = (DismissView) LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_dismiss_all, mStackScroller, false);
    mDismissView.setOnButtonClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            MetricsLogger.action(mContext, MetricsLogger.ACTION_DISMISS_ALL_NOTES);
            clearAllNotifications();
        }
    });
    mStackScroller.setDismissView(mDismissView);
    mExpandedContents = mStackScroller;
    mBackdrop = (BackDropView) mStatusBarWindow.findViewById(R.id.backdrop);
    mBackdropFront = (ImageView) mBackdrop.findViewById(R.id.backdrop_front);
    mBackdropBack = (ImageView) mBackdrop.findViewById(R.id.backdrop_back);
    ScrimView scrimBehind = (ScrimView) mStatusBarWindow.findViewById(R.id.scrim_behind);
    ScrimView scrimInFront = (ScrimView) mStatusBarWindow.findViewById(R.id.scrim_in_front);
    View headsUpScrim = mStatusBarWindow.findViewById(R.id.heads_up_scrim);
    mScrimController = new ScrimController(scrimBehind, scrimInFront, headsUpScrim, mScrimSrcModeEnabled);
    mHeadsUpManager.addListener(mScrimController);
    mStackScroller.setScrimController(mScrimController);
    mScrimController.setBackDropView(mBackdrop);
    mStatusBarView.setScrimController(mScrimController);
    mDozeScrimController = new DozeScrimController(mScrimController, context);
    mHeader = (StatusBarHeaderView) mStatusBarWindow.findViewById(R.id.header);
    mHeader.setActivityStarter(this);
    mKeyguardStatusBar = (KeyguardStatusBarView) mStatusBarWindow.findViewById(R.id.keyguard_header);
    mKeyguardStatusView = mStatusBarWindow.findViewById(R.id.keyguard_status_view);
    mKeyguardBottomArea = (KeyguardBottomAreaView) mStatusBarWindow.findViewById(R.id.keyguard_bottom_area);
    mKeyguardBottomArea.setActivityStarter(this);
    mKeyguardBottomArea.setAssistManager(mAssistManager);
    mKeyguardIndicationController = new KeyguardIndicationController(mContext, (KeyguardIndicationTextView) mStatusBarWindow.findViewById(R.id.keyguard_indication_text), mKeyguardBottomArea.getLockIcon());
    mKeyguardBottomArea.setKeyguardIndicationController(mKeyguardIndicationController);
    // set the inital view visibility
    setAreThereNotifications();
    mIconController = new StatusBarIconController(mContext, mStatusBarView, mKeyguardStatusBar, this);
    // Background thread for any controllers that need it.
    mHandlerThread = new HandlerThread(TAG, Process.THREAD_PRIORITY_BACKGROUND);
    mHandlerThread.start();
    // Other icons
    mLocationController = new LocationControllerImpl(mContext, // will post a notification
    mHandlerThread.getLooper());
    mBatteryController = new BatteryController(mContext);
    mBatteryController.addStateChangedCallback(new BatteryStateChangeCallback() {

        @Override
        public void onPowerSaveChanged() {
            mHandler.post(mCheckBarModes);
            if (mDozeServiceHost != null) {
                mDozeServiceHost.firePowerSaveChanged(mBatteryController.isPowerSave());
            }
        }

        @Override
        public void onBatteryLevelChanged(int level, boolean pluggedIn, boolean charging) {
        // noop
        }
    });
    mNetworkController = new NetworkControllerImpl(mContext, mHandlerThread.getLooper());
    mHotspotController = new HotspotControllerImpl(mContext);
    mBluetoothController = new BluetoothControllerImpl(mContext, mHandlerThread.getLooper());
    mSecurityController = new SecurityControllerImpl(mContext);
    if (mContext.getResources().getBoolean(R.bool.config_showRotationLock)) {
        mRotationLockController = new RotationLockControllerImpl(mContext);
    }
    mUserInfoController = new UserInfoController(mContext);
    mVolumeComponent = getComponent(VolumeComponent.class);
    if (mVolumeComponent != null) {
        mZenModeController = mVolumeComponent.getZenController();
    }
    mCastController = new CastControllerImpl(mContext);
    final SignalClusterView signalCluster = (SignalClusterView) mStatusBarView.findViewById(R.id.signal_cluster);
    final SignalClusterView signalClusterKeyguard = (SignalClusterView) mKeyguardStatusBar.findViewById(R.id.signal_cluster);
    final SignalClusterView signalClusterQs = (SignalClusterView) mHeader.findViewById(R.id.signal_cluster);
    mNetworkController.addSignalCallback(signalCluster);
    mNetworkController.addSignalCallback(signalClusterKeyguard);
    mNetworkController.addSignalCallback(signalClusterQs);
    signalCluster.setSecurityController(mSecurityController);
    signalCluster.setNetworkController(mNetworkController);
    signalClusterKeyguard.setSecurityController(mSecurityController);
    signalClusterKeyguard.setNetworkController(mNetworkController);
    signalClusterQs.setSecurityController(mSecurityController);
    signalClusterQs.setNetworkController(mNetworkController);
    final boolean isAPhone = mNetworkController.hasVoiceCallingFeature();
    if (isAPhone) {
        mNetworkController.addEmergencyListener(mHeader);
    }
    mFlashlightController = new FlashlightController(mContext);
    mKeyguardBottomArea.setFlashlightController(mFlashlightController);
    mKeyguardBottomArea.setPhoneStatusBar(this);
    mKeyguardBottomArea.setUserSetupComplete(mUserSetup);
    mAccessibilityController = new AccessibilityController(mContext);
    mKeyguardBottomArea.setAccessibilityController(mAccessibilityController);
    mNextAlarmController = new NextAlarmController(mContext);
    mKeyguardMonitor = new KeyguardMonitor(mContext);
    if (UserSwitcherController.isUserSwitcherAvailable(UserManager.get(mContext))) {
        mUserSwitcherController = new UserSwitcherController(mContext, mKeyguardMonitor, mHandler);
    }
    mKeyguardUserSwitcher = new KeyguardUserSwitcher(mContext, (ViewStub) mStatusBarWindow.findViewById(R.id.keyguard_user_switcher), mKeyguardStatusBar, mNotificationPanel, mUserSwitcherController);
    // Set up the quick settings tile panel
    mQSPanel = (QSPanel) mStatusBarWindow.findViewById(R.id.quick_settings_panel);
    if (mQSPanel != null) {
        final QSTileHost qsh = new QSTileHost(mContext, this, mBluetoothController, mLocationController, mRotationLockController, mNetworkController, mZenModeController, mHotspotController, mCastController, mFlashlightController, mUserSwitcherController, mKeyguardMonitor, mSecurityController);
        mQSPanel.setHost(qsh);
        mQSPanel.setTiles(qsh.getTiles());
        mBrightnessMirrorController = new BrightnessMirrorController(mContext, mStatusBarWindow);
        mQSPanel.setBrightnessMirror(mBrightnessMirrorController);
        mHeader.setQSPanel(mQSPanel);
        qsh.setCallback(new QSTileHost.Callback() {

            @Override
            public void onTilesChanged() {
                mQSPanel.setTiles(qsh.getTiles());
            }
        });
    }
    // User info. Trigger first load.
    mHeader.setUserInfoController(mUserInfoController);
    mKeyguardStatusBar.setUserInfoController(mUserInfoController);
    mKeyguardStatusBar.setUserSwitcherController(mUserSwitcherController);
    mUserInfoController.reloadUserInfo();
    mHeader.setBatteryController(mBatteryController);
    ((BatteryMeterView) mStatusBarView.findViewById(R.id.battery)).setBatteryController(mBatteryController);
    mKeyguardStatusBar.setBatteryController(mBatteryController);
    mHeader.setNextAlarmController(mNextAlarmController);
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mBroadcastReceiver.onReceive(mContext, new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
    mGestureWakeLock = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, "GestureWakeLock");
    mVibrator = mContext.getSystemService(Vibrator.class);
    // receive broadcasts
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_KEYGUARD_WALLPAPER_CHANGED);
    filter.addAction("com.android.systemui.TOGGLE_FLASHLIGHT");
    context.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL, filter, null, null);
    IntentFilter demoFilter = new IntentFilter();
    if (DEBUG_MEDIA_FAKE_ARTWORK) {
        demoFilter.addAction(ACTION_FAKE_ARTWORK);
    }
    demoFilter.addAction(ACTION_DEMO);
    context.registerReceiverAsUser(mDemoReceiver, UserHandle.ALL, demoFilter, android.Manifest.permission.DUMP, null);
    // listen for USER_SETUP_COMPLETE setting (per-user)
    resetUserSetupObserver();
    mStatusBarHeaderMachine = new StatusBarHeaderMachine(mContext);
    mStatusBarHeaderMachine.addObserver(mHeader);
    mStatusBarHeaderMachine.updateEnablement();
    // disable profiling bars, since they overlap and clutter the output on app windows
    ThreadedRenderer.overrideProperty("disableProfileBars", "true");
    // Private API call to make the shadows look better for Recents
    ThreadedRenderer.overrideProperty("ambientRatio", String.valueOf(1.5f));
    return mStatusBarView;
}
#method_after
// ================================================================================
// Constructing the view
protected PhoneStatusBarView makeStatusBarView() {
    final Context context = mContext;
    Resources res = context.getResources();
    mScreenWidth = (float) context.getResources().getDisplayMetrics().widthPixels;
    mMinBrightness = context.getResources().getInteger(com.android.internal.R.integer.config_screenBrightnessDim);
    // populates mDisplayMetrics
    updateDisplaySize();
    updateResources();
    mStatusBarWindow = (StatusBarWindowView) View.inflate(context, R.layout.super_status_bar, null);
    mStatusBarWindow.setService(this);
    mStatusBarWindow.setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            checkUserAutohide(v, event);
            if (event.getAction() == MotionEvent.ACTION_DOWN) {
                if (mExpandedVisible) {
                    animateCollapsePanels();
                }
            }
            return mStatusBarWindow.onTouchEvent(event);
        }
    });
    mStatusBarView = (PhoneStatusBarView) mStatusBarWindow.findViewById(R.id.status_bar);
    mStatusBarView.setBar(this);
    PanelHolder holder = (PanelHolder) mStatusBarWindow.findViewById(R.id.panel_holder);
    mStatusBarView.setPanelHolder(holder);
    mNotificationPanel = (NotificationPanelView) mStatusBarWindow.findViewById(R.id.notification_panel);
    mNotificationPanel.setStatusBar(this);
    if (!ActivityManager.isHighEndGfx()) {
        mStatusBarWindow.setBackground(null);
        mNotificationPanel.setBackground(new FastColorDrawable(context.getColor(R.color.notification_panel_solid_background)));
    }
    mHeadsUpManager = new HeadsUpManager(context, mStatusBarWindow);
    mHeadsUpManager.setBar(this);
    mHeadsUpManager.addListener(this);
    mHeadsUpManager.addListener(mNotificationPanel);
    mNotificationPanel.setHeadsUpManager(mHeadsUpManager);
    mNotificationData.setHeadsUpManager(mHeadsUpManager);
    try {
        mShowNavBar = mWindowManagerService.hasNavigationBar();
        if (DEBUG)
            Log.v(TAG, "hasNavigationBar=" + mShowNavBar);
        if (mShowNavBar) {
            if (mEnableTabletNavigation) {
                mNavigationBarView = (NavigationBarView) View.inflate(context, R.layout.navigation_bar_tablet, null);
            } else {
                mNavigationBarView = (NavigationBarView) View.inflate(context, R.layout.navigation_bar, null);
            }
            mNavigationBarView.setDisabledFlags(mDisabled1);
            mNavigationBarView.setBar(this);
            mNavigationBarView.setOnVerticalChangedListener(new NavigationBarView.OnVerticalChangedListener() {

                @Override
                public void onVerticalChanged(boolean isVertical) {
                    if (mAssistManager != null) {
                        mAssistManager.onConfigurationChanged();
                    }
                    mNotificationPanel.setQsScrimEnabled(!isVertical);
                }
            });
            mNavigationBarView.setOnTouchListener(new View.OnTouchListener() {

                @Override
                public boolean onTouch(View v, MotionEvent event) {
                    checkUserAutohide(v, event);
                    return false;
                }
            });
        }
    } catch (RemoteException ex) {
    // no window manager? good luck with that
    }
    mAssistManager = new AssistManager(this, context);
    if (!mShowNavBar) {
        mAssistManager.onConfigurationChanged();
    }
    // figure out which pixel-format to use for the status bar.
    mPixelFormat = PixelFormat.OPAQUE;
    mStackScroller = (NotificationStackScrollLayout) mStatusBarWindow.findViewById(R.id.notification_stack_scroller);
    mStackScroller.setLongPressListener(getNotificationLongClicker());
    mStackScroller.setPhoneStatusBar(this);
    mStackScroller.setGroupManager(mGroupManager);
    mStackScroller.setHeadsUpManager(mHeadsUpManager);
    mGroupManager.setOnGroupChangeListener(mStackScroller);
    mKeyguardIconOverflowContainer = (NotificationOverflowContainer) LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_keyguard_overflow, mStackScroller, false);
    mKeyguardIconOverflowContainer.setOnActivatedListener(this);
    mKeyguardIconOverflowContainer.setOnClickListener(mOverflowClickListener);
    mStackScroller.setOverflowContainer(mKeyguardIconOverflowContainer);
    SpeedBumpView speedBump = (SpeedBumpView) LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_speed_bump, mStackScroller, false);
    mStackScroller.setSpeedBumpView(speedBump);
    mEmptyShadeView = (EmptyShadeView) LayoutInflater.from(mContext).inflate(R.layout.status_bar_no_notifications, mStackScroller, false);
    mStackScroller.setEmptyShadeView(mEmptyShadeView);
    mDismissView = (DismissView) LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_dismiss_all, mStackScroller, false);
    mDismissView.setOnButtonClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            MetricsLogger.action(mContext, MetricsLogger.ACTION_DISMISS_ALL_NOTES);
            clearAllNotifications();
        }
    });
    mStackScroller.setDismissView(mDismissView);
    mExpandedContents = mStackScroller;
    mBackdrop = (BackDropView) mStatusBarWindow.findViewById(R.id.backdrop);
    mBackdropFront = (ImageView) mBackdrop.findViewById(R.id.backdrop_front);
    mBackdropBack = (ImageView) mBackdrop.findViewById(R.id.backdrop_back);
    ScrimView scrimBehind = (ScrimView) mStatusBarWindow.findViewById(R.id.scrim_behind);
    ScrimView scrimInFront = (ScrimView) mStatusBarWindow.findViewById(R.id.scrim_in_front);
    View headsUpScrim = mStatusBarWindow.findViewById(R.id.heads_up_scrim);
    mScrimController = new ScrimController(scrimBehind, scrimInFront, headsUpScrim, mScrimSrcModeEnabled);
    mHeadsUpManager.addListener(mScrimController);
    mStackScroller.setScrimController(mScrimController);
    mScrimController.setBackDropView(mBackdrop);
    mStatusBarView.setScrimController(mScrimController);
    mDozeScrimController = new DozeScrimController(mScrimController, context);
    mHeader = (StatusBarHeaderView) mStatusBarWindow.findViewById(R.id.header);
    mHeader.setActivityStarter(this);
    mKeyguardStatusBar = (KeyguardStatusBarView) mStatusBarWindow.findViewById(R.id.keyguard_header);
    mKeyguardStatusView = mStatusBarWindow.findViewById(R.id.keyguard_status_view);
    mKeyguardBottomArea = (KeyguardBottomAreaView) mStatusBarWindow.findViewById(R.id.keyguard_bottom_area);
    mKeyguardBottomArea.setActivityStarter(this);
    mKeyguardBottomArea.setAssistManager(mAssistManager);
    mKeyguardIndicationController = new KeyguardIndicationController(mContext, (KeyguardIndicationTextView) mStatusBarWindow.findViewById(R.id.keyguard_indication_text), mKeyguardBottomArea.getLockIcon());
    mKeyguardBottomArea.setKeyguardIndicationController(mKeyguardIndicationController);
    // set the inital view visibility
    setAreThereNotifications();
    mIconController = new StatusBarIconController(mContext, mStatusBarView, mKeyguardStatusBar, this);
    // Background thread for any controllers that need it.
    mHandlerThread = new HandlerThread(TAG, Process.THREAD_PRIORITY_BACKGROUND);
    mHandlerThread.start();
    // Other icons
    mLocationController = new LocationControllerImpl(mContext, // will post a notification
    mHandlerThread.getLooper());
    mBatteryController = new BatteryController(mContext);
    mBatteryController.addStateChangedCallback(new BatteryStateChangeCallback() {

        @Override
        public void onPowerSaveChanged() {
            mHandler.post(mCheckBarModes);
            if (mDozeServiceHost != null) {
                mDozeServiceHost.firePowerSaveChanged(mBatteryController.isPowerSave());
            }
        }

        @Override
        public void onBatteryLevelChanged(int level, boolean pluggedIn, boolean charging) {
        // noop
        }
    });
    mNetworkController = new NetworkControllerImpl(mContext, mHandlerThread.getLooper());
    mHotspotController = new HotspotControllerImpl(mContext);
    mBluetoothController = new BluetoothControllerImpl(mContext, mHandlerThread.getLooper());
    mSecurityController = new SecurityControllerImpl(mContext);
    if (mContext.getResources().getBoolean(R.bool.config_showRotationLock)) {
        mRotationLockController = new RotationLockControllerImpl(mContext);
    }
    mUserInfoController = new UserInfoController(mContext);
    mVolumeComponent = getComponent(VolumeComponent.class);
    if (mVolumeComponent != null) {
        mZenModeController = mVolumeComponent.getZenController();
    }
    mCastController = new CastControllerImpl(mContext);
    final SignalClusterView signalCluster = (SignalClusterView) mStatusBarView.findViewById(R.id.signal_cluster);
    final SignalClusterView signalClusterKeyguard = (SignalClusterView) mKeyguardStatusBar.findViewById(R.id.signal_cluster);
    final SignalClusterView signalClusterQs = (SignalClusterView) mHeader.findViewById(R.id.signal_cluster);
    mNetworkController.addSignalCallback(signalCluster);
    mNetworkController.addSignalCallback(signalClusterKeyguard);
    mNetworkController.addSignalCallback(signalClusterQs);
    signalCluster.setSecurityController(mSecurityController);
    signalCluster.setNetworkController(mNetworkController);
    signalClusterKeyguard.setSecurityController(mSecurityController);
    signalClusterKeyguard.setNetworkController(mNetworkController);
    signalClusterQs.setSecurityController(mSecurityController);
    signalClusterQs.setNetworkController(mNetworkController);
    final boolean isAPhone = mNetworkController.hasVoiceCallingFeature();
    if (isAPhone) {
        mNetworkController.addEmergencyListener(mHeader);
    }
    mFlashlightController = new FlashlightController(mContext);
    mKeyguardBottomArea.setFlashlightController(mFlashlightController);
    mKeyguardBottomArea.setPhoneStatusBar(this);
    mKeyguardBottomArea.setUserSetupComplete(mUserSetup);
    mAccessibilityController = new AccessibilityController(mContext);
    mKeyguardBottomArea.setAccessibilityController(mAccessibilityController);
    mNextAlarmController = new NextAlarmController(mContext);
    mKeyguardMonitor = new KeyguardMonitor(mContext);
    if (UserSwitcherController.isUserSwitcherAvailable(UserManager.get(mContext))) {
        mUserSwitcherController = new UserSwitcherController(mContext, mKeyguardMonitor, mHandler);
    }
    mKeyguardUserSwitcher = new KeyguardUserSwitcher(mContext, (ViewStub) mStatusBarWindow.findViewById(R.id.keyguard_user_switcher), mKeyguardStatusBar, mNotificationPanel, mUserSwitcherController);
    // Set up the quick settings tile panel
    mQSPanel = (QSPanel) mStatusBarWindow.findViewById(R.id.quick_settings_panel);
    if (mQSPanel != null) {
        final QSTileHost qsh = new QSTileHost(mContext, this, mBluetoothController, mLocationController, mRotationLockController, mNetworkController, mZenModeController, mHotspotController, mCastController, mFlashlightController, mUserSwitcherController, mKeyguardMonitor, mSecurityController);
        mQSPanel.setHost(qsh);
        mQSPanel.setTiles(qsh.getTiles());
        mBrightnessMirrorController = new BrightnessMirrorController(mContext, mStatusBarWindow);
        mQSPanel.setBrightnessMirror(mBrightnessMirrorController);
        mHeader.setQSPanel(mQSPanel);
        qsh.setCallback(new QSTileHost.Callback() {

            @Override
            public void onTilesChanged() {
                mQSPanel.setTiles(qsh.getTiles());
            }
        });
    }
    // User info. Trigger first load.
    mHeader.setUserInfoController(mUserInfoController);
    mKeyguardStatusBar.setUserInfoController(mUserInfoController);
    mKeyguardStatusBar.setUserSwitcherController(mUserSwitcherController);
    mUserInfoController.reloadUserInfo();
    mHeader.setBatteryController(mBatteryController);
    ((BatteryMeterView) mStatusBarView.findViewById(R.id.battery)).setBatteryController(mBatteryController);
    mKeyguardStatusBar.setBatteryController(mBatteryController);
    mHeader.setNextAlarmController(mNextAlarmController);
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mBroadcastReceiver.onReceive(mContext, new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
    mGestureWakeLock = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, "GestureWakeLock");
    mVibrator = mContext.getSystemService(Vibrator.class);
    // receive broadcasts
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_KEYGUARD_WALLPAPER_CHANGED);
    filter.addAction("com.android.systemui.TOGGLE_FLASHLIGHT");
    context.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL, filter, null, null);
    IntentFilter demoFilter = new IntentFilter();
    if (DEBUG_MEDIA_FAKE_ARTWORK) {
        demoFilter.addAction(ACTION_FAKE_ARTWORK);
    }
    demoFilter.addAction(ACTION_DEMO);
    context.registerReceiverAsUser(mDemoReceiver, UserHandle.ALL, demoFilter, android.Manifest.permission.DUMP, null);
    // listen for USER_SETUP_COMPLETE setting (per-user)
    resetUserSetupObserver();
    mStatusBarHeaderMachine = new StatusBarHeaderMachine(mContext);
    mStatusBarHeaderMachine.addObserver(mHeader);
    mStatusBarHeaderMachine.updateEnablement();
    // disable profiling bars, since they overlap and clutter the output on app windows
    ThreadedRenderer.overrideProperty("disableProfileBars", "true");
    // Private API call to make the shadows look better for Recents
    ThreadedRenderer.overrideProperty("ambientRatio", String.valueOf(1.5f));
    return mStatusBarView;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_START_DOZING:
            handleStartDozing((Runnable) msg.obj);
            break;
        case MSG_PULSE_WHILE_DOZING:
            handlePulseWhileDozing((PulseCallback) msg.obj, msg.arg1);
            break;
        case MSG_STOP_DOZING:
            handleStopDozing();
            break;
    }
}
#method_after
public void handleMessage(Message m) {
    super.handleMessage(m);
    switch(m.what) {
        case MSG_OPEN_NOTIFICATION_PANEL:
            animateExpandNotificationsPanel();
            break;
        case MSG_OPEN_SETTINGS_PANEL:
            animateExpandSettingsPanel();
            break;
        case MSG_CLOSE_PANELS:
            animateCollapsePanels();
            break;
        case MSG_LAUNCH_TRANSITION_TIMEOUT:
            onLaunchTransitionTimeout();
            break;
    }
}
#end_block

#method_before
private void updateNavigationBar() {
    mShowNavBar = DeviceUtils.deviceSupportNavigationBarForUser(mContext, mCurrentUserId);
    if (DEBUG)
        Log.v(TAG, "updateNavigationBar=" + mShowNavBar);
    if (mShowNavBar) {
        if (mNavigationBarView == null) {
            if (mEnableTabletNavigation) {
                mNavigationBarView = (NavigationBarView) View.inflate(mContext, R.layout.navigation_bar_tablet, null);
                Log.d(TAG, "Showing Tablet Layout navigationbar");
            } else {
                mNavigationBarView = (NavigationBarView) View.inflate(mContext, R.layout.navigation_bar, null);
                Log.d(TAG, "Showing normal Layout navigationbar");
            }
            mNavigationBarView.setDisabledFlags(mDisabled1, true);
            mNavigationBarView.setBar(this);
            mNavigationBarView.setOnVerticalChangedListener(new NavigationBarView.OnVerticalChangedListener() {

                @Override
                public void onVerticalChanged(boolean isVertical) {
                    if (mAssistManager != null) {
                        mAssistManager.onConfigurationChanged();
                    }
                    mNotificationPanel.setQsScrimEnabled(!isVertical);
                }
            });
            mNavigationBarView.setOnTouchListener(new View.OnTouchListener() {

                @Override
                public boolean onTouch(View v, MotionEvent event) {
                    checkUserAutohide(v, event);
                    return false;
                }
            });
            addNavigationBar();
            checkBarModes();
            notifyUiVisibilityChanged(mSystemUiVisibility);
        }
    } else {
        if (mNavigationBarView != null) {
            mWindowManager.removeViewImmediate(mNavigationBarView);
            mNavigationBarView = null;
        }
    }
}
#method_after
private void updateNavigationBar() {
    mShowNavBar = DeviceUtils.deviceSupportNavigationBarForUser(mContext, mCurrentUserId);
    if (DEBUG)
        Log.v(TAG, "updateNavigationBar=" + mShowNavBar);
    if (mShowNavBar) {
        if (mNavigationBarView == null) {
            if (mEnableTabletNavigation) {
                mNavigationBarView = (NavigationBarView) View.inflate(mContext, R.layout.navigation_bar_tablet, null);
            } else {
                mNavigationBarView = (NavigationBarView) View.inflate(mContext, R.layout.navigation_bar, null);
            }
            mNavigationBarView.setDisabledFlags(mDisabled1, true);
            mNavigationBarView.setBar(this);
            mNavigationBarView.setOnVerticalChangedListener(new NavigationBarView.OnVerticalChangedListener() {

                @Override
                public void onVerticalChanged(boolean isVertical) {
                    if (mAssistManager != null) {
                        mAssistManager.onConfigurationChanged();
                    }
                    mNotificationPanel.setQsScrimEnabled(!isVertical);
                }
            });
            mNavigationBarView.setOnTouchListener(new View.OnTouchListener() {

                @Override
                public boolean onTouch(View v, MotionEvent event) {
                    checkUserAutohide(v, event);
                    return false;
                }
            });
            addNavigationBar();
            checkBarModes();
            notifyUiVisibilityChanged(mSystemUiVisibility);
        }
    } else {
        if (mNavigationBarView != null) {
            mWindowManager.removeViewImmediate(mNavigationBarView);
            mNavigationBarView = null;
        }
    }
}
#end_block

#method_before
public static boolean checkAndNoteChangeNetworkStateOperation(Context context, int uid, String callingPackage, boolean throwException) {
    return isCallingPackageAllowedToPerformAppOpsProtectedOperation(context, uid, callingPackage, throwException, AppOpsManager.OP_WRITE_SETTINGS, PM_CHANGE_NETWORK_STATE, true);
}
#method_after
public static boolean checkAndNoteChangeNetworkStateOperation(Context context, int uid, String callingPackage, boolean throwException) {
    if (context.checkCallingOrSelfPermission(android.Manifest.permission.CHANGE_NETWORK_STATE) == PackageManager.PERMISSION_GRANTED) {
        return true;
    }
    return isCallingPackageAllowedToPerformAppOpsProtectedOperation(context, uid, callingPackage, throwException, AppOpsManager.OP_WRITE_SETTINGS, PM_CHANGE_NETWORK_STATE, true);
}
#end_block

#method_before
@Override
protected void onAttachedToWindow() {
    super.onAttachedToWindow();
    mSettingsObserver.observe();
    mDoubleTapGesture = new GestureDetector(mContext, new GestureDetector.SimpleOnGestureListener() {

        @Override
        public boolean onDoubleTap(MotionEvent e) {
            PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
            Log.d(TAG, "Gesture!!");
            if (pm != null)
                pm.goToSleep(e.getEventTime());
            else
                Log.d(TAG, "getSystemService returned null PowerManager");
            return true;
        }
    });
    // We really need to be able to animate while window animations are going on
    // so that activities may be started asynchronously from panel animations
    final ViewRootImpl root = getViewRootImpl();
    if (root != null) {
        root.setDrawDuringWindowsAnimating(true);
    }
    // the scrim, we don't need the window to be cleared in the beginning.
    if (mService.isScrimSrcModeEnabled()) {
        IBinder windowToken = getWindowToken();
        WindowManager.LayoutParams lp = (WindowManager.LayoutParams) getLayoutParams();
        lp.token = windowToken;
        setLayoutParams(lp);
        WindowManagerGlobal.getInstance().changeCanvasOpacity(windowToken, true);
        setWillNotDraw(false);
    } else {
        setWillNotDraw(!DEBUG);
    }
}
#method_after
@Override
protected void onAttachedToWindow() {
    super.onAttachedToWindow();
    mDoubleTapGesture = new GestureDetector(mContext, new GestureDetector.SimpleOnGestureListener() {

        @Override
        public boolean onDoubleTap(MotionEvent e) {
            PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
            Log.d(TAG, "Gesture!!");
            if (pm != null)
                pm.goToSleep(e.getEventTime());
            else
                Log.d(TAG, "getSystemService returned null PowerManager");
            return true;
        }
    });
    // We really need to be able to animate while window animations are going on
    // so that activities may be started asynchronously from panel animations
    final ViewRootImpl root = getViewRootImpl();
    if (root != null) {
        root.setDrawDuringWindowsAnimating(true);
    }
    // the scrim, we don't need the window to be cleared in the beginning.
    if (mService.isScrimSrcModeEnabled()) {
        IBinder windowToken = getWindowToken();
        WindowManager.LayoutParams lp = (WindowManager.LayoutParams) getLayoutParams();
        lp.token = windowToken;
        setLayoutParams(lp);
        WindowManagerGlobal.getInstance().changeCanvasOpacity(windowToken, true);
        setWillNotDraw(false);
    } else {
        setWillNotDraw(!DEBUG);
    }
}
#end_block

#method_before
public void handleKeyDown(KeyEvent event, int stream) {
    int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
            {
                /*
                 * Adjust the volume in on key down since it is more
                 * responsive to the user.
                 */
                int direction = keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_RAISE : ADJUST_LOWER;
                final WindowManager windowService = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
                if (windowService != null) {
                    final int rotation = windowService.getDefaultDisplay().getRotation();
                    final Configuration config = getContext().getResources().getConfiguration();
                    final boolean swapKeys = Settings.System.getIntForUser(getContext().getContentResolver(), Settings.System.SWAP_VOLUME_BUTTONS, 0, Process.myUserHandle().getIdentifier()) == 1;
                    if (swapKeys && (rotation == Surface.ROTATION_90 || rotation == Surface.ROTATION_180) && config.getLayoutDirection() == View.LAYOUT_DIRECTION_LTR) {
                        direction = keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_LOWER : ADJUST_RAISE;
                    }
                }
                int flags = FLAG_SHOW_UI | FLAG_VIBRATE;
                adjustSuggestedStreamVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_RAISE : ADJUST_LOWER, stream, FLAG_SHOW_UI | FLAG_VIBRATE);
            }
            break;
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            if (event.getRepeatCount() == 0) {
                MediaSessionLegacyHelper.getHelper(getContext()).sendVolumeKeyEvent(event, false);
            }
            break;
    }
}
#method_after
public void handleKeyDown(KeyEvent event, int stream) {
    int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
            /*
                 * Adjust the volume in on key down since it is more
                 * responsive to the user.
                 */
            int direction = keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_RAISE : ADJUST_LOWER;
            final WindowManager windowService = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
            if (windowService != null) {
                final int rotation = windowService.getDefaultDisplay().getRotation();
                final Configuration config = getContext().getResources().getConfiguration();
                final boolean swapKeys = Settings.System.getIntForUser(getContext().getContentResolver(), Settings.System.SWAP_VOLUME_BUTTONS, 0, Process.myUserHandle().getIdentifier()) == 1;
                if (swapKeys && (rotation == Surface.ROTATION_90 || rotation == Surface.ROTATION_180) && config.getLayoutDirection() == View.LAYOUT_DIRECTION_LTR) {
                    direction = keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_LOWER : ADJUST_RAISE;
                }
            }
            int flags = FLAG_SHOW_UI | FLAG_VIBRATE;
            adjustSuggestedStreamVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_RAISE : ADJUST_LOWER, stream, FLAG_SHOW_UI | FLAG_VIBRATE);
            break;
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            if (event.getRepeatCount() == 0) {
                MediaSessionLegacyHelper.getHelper(getContext()).sendVolumeKeyEvent(event, false);
            }
            break;
    }
}
#end_block

